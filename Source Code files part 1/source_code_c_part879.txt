
        goto Failed;

    return S_OK;

Failed:

    if (pvmUpdateDSRoot)
    {
        pvmUpdateDSRoot->Destroy();
        pvmUpdateDSRoot = NULL;
    }
    if (pvmLayoutRoot)
    {
        pvmLayoutRoot->Destroy();
        pvmLayoutRoot = NULL;
    }
    if (pdaPC)
    {
        pdaPC->Destroy();
        pdaPC = NULL;
    }
    if (pdaGC)
    {
        pdaGC->Destroy();
        pdaGC = NULL;
    }
    if (pdaGCLP)
    {
        pdaGCLP->Destroy();
        pdaGCLP = NULL;
    }

    return hr;
}

DeferCycle::~DeferCycle()
{
    if (pdaGCLP)
        pdaGCLP->Destroy();
    if (pdaGC)
        pdaGC->Destroy();
    if (pdaPC)
        pdaPC->Destroy();
    if (pvmLayoutRoot)
        pvmLayoutRoot->Destroy();
    if (pvmUpdateDSRoot)
        pvmUpdateDSRoot->Destroy();
}

void DeferCycle::Reset()
{
    // Return to initial state for reuse
    fFiring = false;

    iGCPtr = -1;
    if (pdaGC)
        pdaGC->Reset();

    iGCLPPtr = -1;
    if (pdaGCLP)
        pdaGCLP->Reset();
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_CORE_PUBLISHED_H_INCLUDED
#define DUI_CORE_PUBLISHED_H_INCLUDED

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

#endif // DUI_CORE_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\sources.inc ===
!IF 0

    DirectUI Core Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
	..\accessibility.cpp  \
        ..\element.cpp        \
        ..\expression.cpp     \
        ..\host.cpp           \
        ..\layout.cpp         \
        ..\navigation.cpp     \
        ..\property.cpp       \
        ..\proxy.cpp          \
        ..\render.cpp         \
        ..\sheet.cpp          \
        ..\thread.cpp         \
        ..\value.cpp          \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxcore.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\proxy.cpp ===
/*
 * Proxy
 */

#include "stdafx.h"
#include "core.h"

#include "duiproxy.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Proxy

// Use for synchronous thread-safe cross-thread access

// It is safe to act on Element hierarchies from other threads via a proxy
// that was created in this same thread. The proxy's methods will invoke
// only when all other processing within the thread is complete. Hence,
// access to the callee (the proxy and any Element in the thread) will be
// synchronized and thread-safe. The proxy can provide synchronous or
// asynchronous type calls for the caller.

Proxy::Proxy()
{
    _hgSync = CreateGadget(NULL, GC_MESSAGE, SyncCallback, this);
}

Proxy::~Proxy()
{
    if (_hgSync)
        DeleteHandle(_hgSync);
}

////////////////////////////////////////////////////////
// Caller Invoke

void Proxy::Invoke(UINT nType, void* pData)
{
    // Package proxy message
    GMSG_PROXYINVOKE gmsgPI;
    gmsgPI.cbSize = sizeof(GMSG_PROXYINVOKE);
    gmsgPI.nMsg = GM_PROXYINVOKE;
    gmsgPI.hgadMsg = _hgSync;

    // Initialize custom fields
    gmsgPI.nType = nType;
    gmsgPI.pData = pData;

    // Invoke
    DUserSendEvent(&gmsgPI, 0);  // Direct message
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke (override)

void Proxy::OnInvoke(UINT nType, void* pData)
{
    UNREFERENCED_PARAMETER(nType);
    UNREFERENCED_PARAMETER(pData);
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke

HRESULT Proxy::SyncCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);

    switch (pGMsg->nMsg)
    {
    case GM_PROXYINVOKE:

        // Direct message only
        DUIAssertNoMsg(GET_EVENT_DEST(pGMsg) == GMF_DIRECT);
        
        // Marshalled
        Proxy* pProxy = (Proxy*)pvCur;
        GMSG_PROXYINVOKE* pPI = (GMSG_PROXYINVOKE*)pGMsg;

        // Invoke callback sink
        pProxy->OnInvoke(pPI->nType, pPI->pData);        

        return DU_S_COMPLETE;
    }

    return DU_S_NOTHANDLED;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\sheet.cpp ===
/*
 * Sheet
 */

#include "stdafx.h"
#include "core.h"

#include "duisheet.h"

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// PropertySheet

HRESULT PropertySheet::Create(OUT PropertySheet** ppSheet)
{
    *ppSheet = NULL;

    PropertySheet* ps = HNew<PropertySheet>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppSheet = ps;

    return S_OK;
}

HRESULT PropertySheet::Initialize()
{
    HRESULT hr;
    
    _pdaSharedCond = NULL;
    _pDB = NULL;
    _pCIIdxMap = NULL;

    hr = DynamicArray<Cond*>::Create(0, false, &_pdaSharedCond);
    if (FAILED(hr))
        goto Failed;

    // Pointer to an array of Records, indexed by unique class index
    _pDB = (Record*)HAllocAndZero(g_iGlobalCI * sizeof(Record));
    if (!_pDB)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    _pCIIdxMap = (IClassInfo**)HAlloc(g_iGlobalCI * sizeof(IClassInfo*));
    if (!_pCIIdxMap)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    
    _uRuleId = 0;
    _fImmutable = false;

    return S_OK;

Failed:

    if (_pdaSharedCond)
    {
        _pdaSharedCond->Destroy();
        _pdaSharedCond = NULL;
    }

    if (_pCIIdxMap)
    {
        HFree(_pCIIdxMap);
        _pCIIdxMap = NULL;
    }

    if (_pDB)
    {
        HFree(_pDB);
        _pDB = NULL;
    }

    return hr;
}

PropertySheet::~PropertySheet()
{
    //DUITrace("Destroying PS: <%x>\n", this);

    UINT i;

    // Scan for entries
    if (_pDB)
    {
        PIData* ppid;
        Cond* pc;
        UINT p;
        UINT c;
        for (i = 0; i < g_iGlobalCI; i++)
        {
            // Free PIData
            if (_pDB[i].ppid)
            {
                DUIAssert(_pCIIdxMap[i], "No ClassInfo from global index map");

                // Scan PIDatas (one per propertyinfo for class)
                for (p = 0; p < _pCIIdxMap[i]->GetPICount(); p++)
                {
                    ppid = _pDB[i].ppid + p;
                
                    // Free condition maps
                    if (ppid->pCMaps)
                    {
                        // Release all held values in maps
                        for (c = 0; c < ppid->cCMaps; c++)
                        {
                            // Conditional values used in conditional map
                            pc = ppid->pCMaps[c].pConds;
                            while (pc->ppi && pc->pv)  // Release all values in conditionals
                            {
                                pc->pv->Release();
                                pc++;
                            }
                            
                            // Conditional Map value
                            ppid->pCMaps[c].pv->Release();  // Value cannot be NULL (AddRule)
                        }

                        HFree(ppid->pCMaps);
                    }

                    // Free dependents propertyinfo list
                    if (ppid->pDeps)
                        HFree(ppid->pDeps);
                } 

                // Free PIData array for class type
                HFree(_pDB[i].ppid);
            }

            // Free scope list
            if (_pDB[i].ss.pDeps)
                HFree(_pDB[i].ss.pDeps);
        }

        // Free PIData pointer array
        HFree(_pDB);
    }

    if (_pCIIdxMap)
        HFree(_pCIIdxMap);

    // Free shared conditional arrays
    if (_pdaSharedCond)
    {
        for (i = 0; i < _pdaSharedCond->GetSize(); i++)
            HFree(_pdaSharedCond->GetItem(i));

        _pdaSharedCond->Destroy();
    }
}

////////////////////////////////////////////////////////
// Rule addition and helpers

// Helper: Get the unique class-relative index of property
inline UINT _GetClassPIIndex(PropertyInfo* ppi)
{
    IClassInfo* pciBase = ppi->_pciOwner->GetBaseClass();
    return (pciBase ? pciBase->GetPICount() : 0) + ppi->_iIndex;
}

// Helper: Duplicate conditionals of rule, including zero terminator
inline Cond* _CopyConds(Cond* pConds)
{
    if (!pConds)
        return NULL;

    // Count
    UINT c = 0;
    while (pConds[c].ppi && pConds[c].pv)  // Either with NULL value marks terminator
        c++;

    // Copy terminator
    c++;

    Cond* pc = (Cond*)HAlloc(c * sizeof(Cond));
    if (pc)
        CopyMemory(pc, pConds, c * sizeof(Cond));

    return pc;  // Must be freed with HFree
}

// Helper: Compute specificity of conditionals given rule id that it appears in
// pConds may be NULL (no conditions)
// RuleID clipped to 16-bit
inline UINT _ComputeSpecif(Cond* pConds, IClassInfo* pci, UINT uRuleId)
{   
    UNREFERENCED_PARAMETER(pci);

    DUIAssert(pci, "Univeral rules unsupported");

    // Clip to 8-bits
    BYTE cId = 0;   // Id property count
    BYTE cAtt = 0;  // Property count

    // Count properties
    if (pConds)
    {
        Cond* pc = pConds;
        while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
        {
            if (pc->ppi == Element::IDProp)
                cId++;

            cAtt++;

            pc++;
        }
    }

    // Build specificity
    return (cId << 24) | (cAtt << 16) | (USHORT)uRuleId;
}

// Helper: Add entry in Conditional to Value mapping list at specified PIData
// pConds is not duplicated, Value will be AddRef'd. pConds may be NULL (no conditions)
inline HRESULT _AddCondMapping(PIData* ppid, Cond* pConds, UINT uSpecif, Value* pv)
{
    // Increase list by one
    if (ppid->pCMaps)
    {
        //pr->pCMaps = (CondMap*)HReAlloc(pr->pCMaps, (pr->cCMaps + 1) * sizeof(CondMap));
        CondMap* pNewMaps = (CondMap*)HReAlloc(ppid->pCMaps, (ppid->cCMaps + 1) * sizeof(CondMap));
        if (!pNewMaps)
            return E_OUTOFMEMORY;

        ppid->pCMaps = pNewMaps;
    }
    else
    {
        ppid->pCMaps = (CondMap*)HAlloc((ppid->cCMaps + 1) * sizeof(CondMap));
        if (!ppid->pCMaps)
            return E_OUTOFMEMORY;
    }

    // Move to new map
    CondMap* pcm = ppid->pCMaps + ppid->cCMaps;

    // Set entry

    // Conditionals
    pcm->pConds = pConds;

    Cond* pc = pConds;
    while (pc->ppi && pc->pv)  // Add ref all values in conditionals
    {
        pc->pv->AddRef();
        pc++;
    }

    // Value (add ref)
    pcm->pv = pv;
    pcm->pv->AddRef();

    // Specificity
    pcm->uSpecif = uSpecif;

    ppid->cCMaps++;

    return S_OK;
}

// Helper: Checks if a given propertyinfo exists in a propertyinfo array
// pPIList may be NULL
inline bool _IsPIInList(PropertyInfo* ppi, PropertyInfo** pPIList, UINT cPIList)
{
    if (!pPIList)
        return false;

    for (UINT i = 0; i < cPIList; i++)
        if (ppi == pPIList[i])
            return true;

    return false;
}

// Helper: Add entries in Dependency list at specified dependency list
// All PropertyInfos in declarations will be added to list (pDecls must be non-NULL, NULL terminated)
inline HRESULT _AddDeps(DepList* pdl, Decl* pDecls)
{
    Decl* pd = pDecls;
    while (pd->ppi && pd->pv)  // Either with NULL value marks terminator
    {
        if (!_IsPIInList(pd->ppi, pdl->pDeps, pdl->cDeps))
        {
            // Increase list by one
            if (pdl->pDeps)
            {
                //pdl->pDeps = (PropertyInfo**)HReAlloc(pdl->pDeps, (pdl->cDeps + 1) * sizeof(PropertyInfo*));
                PropertyInfo** pNewDeps = (PropertyInfo**)HReAlloc(pdl->pDeps, (pdl->cDeps + 1) * sizeof(PropertyInfo*));
                if (!pNewDeps)
                    return E_OUTOFMEMORY;

                pdl->pDeps = pNewDeps;
            }
            else
            {
                pdl->pDeps = (PropertyInfo**)HAlloc((pdl->cDeps + 1) * sizeof(PropertyInfo*));
                if (!pdl->pDeps)
                    return E_OUTOFMEMORY;
            }
            
            // Move to new entry
            PropertyInfo** pppi = pdl->pDeps + pdl->cDeps;

            // Set entry
            *pppi = pd->ppi;

            pdl->cDeps++;
        }

        pd++;
    }

    return S_OK;
}

// Setup database for constant time lookups, conditionals and declarations are NULL terminated
// pConds and pDecls may be NULL
HRESULT PropertySheet::AddRule(IClassInfo* pci, Cond* pConds, Decl* pDecls)
{
    DUIAssert(pci, "Invalid parameter: NULL");

    DUIAssert(!_fImmutable, "PropertySheet has been made immutable");

    HRESULT hr;
    bool fPartial = false;
    UINT uSpecif = 0;

    // Members that can result in failure
    Cond* pCondsDup = NULL;

    // Get PIData array based on class index
    PIData* ppid = _pDB[pci->GetGlobalIndex()].ppid;
    DepList* pss = &(_pDB[pci->GetGlobalIndex()].ss);

    // Create PIData list for this type if doesn't exist (one per PropertyInfo for class)
    if (!ppid)
    {
        ppid = (PIData*)HAllocAndZero(pci->GetPICount() * sizeof(PIData));
        if (!ppid)
        {
            hr = E_OUTOFMEMORY;
            goto Failed;
        }

        _pDB[pci->GetGlobalIndex()].ppid = ppid;
        _pCIIdxMap[pci->GetGlobalIndex()] = pci;  // Track matching IClassInfo
    }

    // Setup GetValue quick lookup data structure and sheet property scope

    // Duplicate conditionals for this rule and track pointer (instead of
    // ref counting) for shared usage by every property in this rule for lookup

    pCondsDup = _CopyConds(pConds);
    if (!pCondsDup)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    pConds = pCondsDup;
    
    _pdaSharedCond->Add(pConds);

    // Get specificity
    uSpecif = _ComputeSpecif(pConds, pci, _uRuleId);

    // For every property in declaration list, store a direct mapping between each conditional
    // and the value for the property in the rule that will be used if condition is true.
    // Also, store a list of all properties that this sheet affects (property scope)
    if (pDecls)
    {
        Decl* pd = pDecls;
        while (pd->ppi && pd->pv)  // Either with NULL value marks terminator
        {
            // GetValue table
            DUIAssert(pci->IsValidProperty(pd->ppi), "Invalid property for class type");
            DUIAssert(pd->ppi->fFlags & PF_Cascade, "Property cannot be used in a Property Sheet declaration");
            DUIAssert(Element::IsValidValue(pd->ppi, pd->pv), "Invalid value type for property");

            hr = _AddCondMapping(ppid + _GetClassPIIndex(pd->ppi), pConds, uSpecif, pd->pv);
            if (FAILED(hr))
                fPartial = true;

            pd++;
        }

        // Property scope list
        hr = _AddDeps(pss, pDecls);
        if (FAILED(hr))
            fPartial = true;
    }

    // Setup GetDependencies quick lookup data structure

    // Go through each conditional of rule and PIData all properties (declarations)
    // it affects due to a change
    if (pConds && pDecls)
    {
        Cond* pc = pConds;
        while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
        {
            DUIAssert(pci->IsValidProperty(pc->ppi), "Invalid property for class type");
            DUIAssert(Element::IsValidValue(pc->ppi, pc->pv), "Invalid value type for property");

            hr = _AddDeps(ppid + _GetClassPIIndex(pc->ppi), pDecls);
            if (FAILED(hr))
                fPartial = true;

            pc++;
        }
    }

    // Increment for next rule
    _uRuleId++;

    return (fPartial) ? DUI_E_PARTIAL : S_OK;

Failed:

    if (pCondsDup)
        HFree(pCondsDup);

    return hr;
}

// Helper: Sort Condition Maps by specificity
int __cdecl _CondMapCompare(const void* pA, const void* pB)
{
    if (((CondMap*)pA)->uSpecif == ((CondMap*)pB)->uSpecif)
        return 0;
    else if (((CondMap*)pA)->uSpecif > ((CondMap*)pB)->uSpecif)
        return -1;
    else
        return 1;
}

void PropertySheet::MakeImmutable()
{
    if (!_fImmutable)
    {
        // Lock sheet
        _fImmutable = true;

        // Sort all conditional maps by specificity
        PIData* ppid;
        UINT p;

        for (UINT i = 0; i < g_iGlobalCI; i++)
        {
            if (_pDB[i].ppid)
            {
                DUIAssert(_pCIIdxMap[i], "No ClassInfo from global index map");

                // Scan PIDatas (one per propertyinfo for class)
                for (p = 0; p < _pCIIdxMap[i]->GetPICount(); p++)
                {
                    ppid = _pDB[i].ppid + p;
                
                    if (ppid->pCMaps)
                    {
                        // Sort
                        qsort(ppid->pCMaps, ppid->cCMaps, sizeof(CondMap), _CondMapCompare);
                    }
                } 
            }
        }
    }
}

////////////////////////////////////////////////////////
// Getting values

// ppi is assumed to be Specified index
Value* PropertySheet::GetSheetValue(Element* pe, PropertyInfo* ppi)
{
    //DUITrace("Querying PS: <%x>\n", this);

    // Get pointer to PIData
    PIData* ppid = _pDB[pe->GetClassInfo()->GetGlobalIndex()].ppid;

    if (ppid)
    {
        // One or more rules exists for this class, jump to the PIData that matches this property
        ppid += _GetClassPIIndex(ppi);

        // Scan conditional-maps for this property (in specificity order) for match
        Cond* pc;
        bool bRes;
        Value* pv;

        for (UINT i = 0; i < ppid->cCMaps; i++)
        {
            bRes = true;  // Assume success

            pc = ppid->pCMaps[i].pConds;
            if (pc)  // Array of conditions for this rule
            {
                // pc is NULL terminated
                while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
                {
                    // Optimize for frequently used values
                    switch (pc->ppi->_iGlobalIndex)
                    {
                    case _PIDX_ID:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetID() == pc->pv->GetAtom()) : (pe->GetID() != pc->pv->GetAtom());
                        break;

                    case _PIDX_MouseFocused:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetMouseFocused() == pc->pv->GetBool()) : (pe->GetMouseFocused() != pc->pv->GetBool());
                        break;

                    case _PIDX_Selected:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetSelected() == pc->pv->GetBool()) : (pe->GetSelected() != pc->pv->GetBool());
                        break;

                    case _PIDX_KeyFocused:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetKeyFocused() == pc->pv->GetBool()) : (pe->GetKeyFocused() != pc->pv->GetBool());
                        break;

                    default:
                        {
                        pv = pe->GetValue(pc->ppi, RetIdx(pc->ppi));

                        // Check if false
                        switch (pc->nLogOp)
                        {
                        case PSLO_Equal:
                            bRes = pv->IsEqual(pc->pv);
                            break;

                        case PSLO_NotEqual:
                            bRes = !pv->IsEqual(pc->pv);
                            break;

                        default:
                            DUIAssertForce("Unsupported PropertySheet rule operation");
                            break;
                        }

                        pv->Release();
                        }
                        break;
                    }

                    if (!bRes)  // A condition return false, this rule doesn't apply
                        break;

                    pc++;
                }
            }

            if (bRes)
            {
                // This rule's condition array passed, return value associated with this rule's condmap
                ppid->pCMaps[i].pv->AddRef(); // AddRef for return
                return ppid->pCMaps[i].pv;
            }

            // Rule conditionals didn't match, continue
        }
    }

    // No match
    return Value::pvUnset;
}

////////////////////////////////////////////////////////
// Getting Dependencies

// ppi is assumed to be Retrieval index
void PropertySheet::GetSheetDependencies(Element* pe, PropertyInfo* ppi, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    // Get pointer to PIData
    PIData* ppid = _pDB[pe->GetClassInfo()->GetGlobalIndex()].ppid;

    if (ppid)
    {
        // One or more rules exists for this class, jump to the PIData that matches this property
        ppid += _GetClassPIIndex(ppi);

        // Add all dependents, always Specified index dependencies
        for (UINT i = 0; i < ppid->cDeps; i++)
        {
            Element::_AddDependency(pe, ppid->pDeps[i], PI_Specified, pdr, pdc, phr);
        }
    }
}

////////////////////////////////////////////////////////
// Getting Sheet's scope of influence

// ppi is assumed to be Retrieval index
void PropertySheet::GetSheetScope(Element* pe, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    // Get sheet scope struct
    DepList* pss = &(_pDB[pe->GetClassInfo()->GetGlobalIndex()].ss);

    if (pss->pDeps)
    {
        // Add all dependents, always Specified index dependencies
        for (UINT i = 0; i < pss->cDeps; i++)
        {
            Element::_AddDependency(pe, pss->pDeps[i], PI_Specified, pdr, pdc, phr);
        }
    }
}

} // namespace "DirectUI"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_CORE_STDAFX_H_INCLUDED
#define DUI_CORE_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_CORE_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\stdafxcore.cpp ===
/*
 * stdafxcore.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\render.cpp ===
/*
 * Render
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duihost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Element rendering (box model)

inline void _ReduceBounds(LPRECT prcTarget, LPCRECT prcAmount)
{
    prcTarget->left += prcAmount->left;

    if (prcTarget->left > prcTarget->right)
        prcTarget->left = prcTarget->right;
    else
    {
        prcTarget->right -= prcAmount->right;

        if (prcTarget->right < prcTarget->left)
            prcTarget->right = prcTarget->left;
    }

    prcTarget->top += prcAmount->top;

    if (prcTarget->top > prcTarget->bottom)
        prcTarget->top = prcTarget->bottom;
    else
    {
        prcTarget->bottom -= prcAmount->bottom;
      
        if (prcTarget->bottom < prcTarget->top)
            prcTarget->bottom = prcTarget->top;    
    }
}

#ifdef GADGET_ENABLE_GDIPLUS

inline void _ReduceBounds(Gdiplus::RectF* prcTarget, LPCRECT prcAmount)
{
    RECT rcTemp;
    rcTemp.left     = (long)prcTarget->X;
    rcTemp.top      = (long)prcTarget->Y;
    rcTemp.right    = (long)(prcTarget->X + prcTarget->Width);
    rcTemp.bottom   = (long)(prcTarget->Y + prcTarget->Height);

    _ReduceBounds(&rcTemp, prcAmount);

    prcTarget->X     = (float)rcTemp.left;
    prcTarget->Y     = (float)rcTemp.top;
    prcTarget->Width = (float)(rcTemp.right - rcTemp.left);
    prcTarget->Height= (float)(rcTemp.bottom - rcTemp.top);
}

inline const Gdiplus::RectF Convert(const RECT* prc)
{
    Gdiplus::RectF rc(
        (float)prc->left, 
        (float)prc->top,
        (float)(prc->right - prc->left),
        (float)(prc->bottom - prc->top));

    return rc;
}

#endif // GADGET_ENABLE_GDIPLUS

inline void _Fill(HDC hDC, HBRUSH hb, int left, int top, int right, int bottom)
{
    RECT rc;
    SetRect(&rc, left, top, right, bottom);
    FillRect(hDC, &rc, hb);
}

void MapRect(Element* pel, const RECT* prc, RECT* prcOut)
{
    if (pel->IsRTL())
    {
        prcOut->left = prc->right;
        prcOut->right = prc->left;
    }
    else
    {
        prcOut->left = prc->left;
        prcOut->right = prc->right;
    }
    prcOut->top = prc->top;
    prcOut->bottom = prc->bottom;
}

int MapAlign(Element* pel, int iAlign)
{
    if (pel->IsRTL())
    {
        if ((iAlign & 0x3) == 0x0) // Left
            iAlign |= 0x2; // Right
        else if ((iAlign & 0x3) == 0x2) // Right
            iAlign &= ~0x2; // Left
    }

    return iAlign;
}

#ifdef GADGET_ENABLE_GDIPLUS

inline void _Fill(Gdiplus::Graphics * pgpgr, Gdiplus::Brush * pgpbr, 
        float left, float top, float right, float bottom)
{
    pgpgr->FillRectangle(pgpbr, left, top, right - left, bottom - top);
}

void _SetupStringFormat(Gdiplus::StringFormat* psf, Element* pel)
{
    // Align
    int dCAlign = MapAlign(pel, pel->GetContentAlign());

    switch (dCAlign & 0x3)  // Lower 2 bits
    {
    case 0x0:   // Left
        psf->SetAlignment(Gdiplus::StringAlignmentNear);
        break;

    case 0x1:   // Center
        psf->SetAlignment(Gdiplus::StringAlignmentCenter);
        break;

    case 0x2:   // Right
        psf->SetAlignment(Gdiplus::StringAlignmentFar);
        break;
    }

    switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
    {
    case 0x0:  // Top
        psf->SetLineAlignment(Gdiplus::StringAlignmentNear);
        break;

    case 0x1:  // Middle
        psf->SetLineAlignment(Gdiplus::StringAlignmentCenter);
        break;

    case 0x2:  // Bottom
        psf->SetLineAlignment(Gdiplus::StringAlignmentFar);
        break;
    }
}


int GetGpFontStyle(Element * pel)
{
    int nRawStyle = pel->GetFontStyle();
    int nWeight = pel->GetFontWeight();
    int nFontStyle = 0;

    if (nWeight <= FW_MEDIUM) {
        // Regular

        if ((nRawStyle & FS_Italic) != 0) {
            nFontStyle = Gdiplus::FontStyleItalic;
        } else {
            nFontStyle = Gdiplus::FontStyleRegular;
        }
    } else {
        // Bold

        if ((nRawStyle & FS_Italic) != 0) {
            nFontStyle = Gdiplus::FontStyleBoldItalic;
        } else {
            nFontStyle = Gdiplus::FontStyleBold;
        }
    }

    if ((nRawStyle & FS_Underline) != 0) {
        nFontStyle |= Gdiplus::FontStyleUnderline;
    } 
    
    if ((nRawStyle & FS_StrikeOut) != 0) {
        nFontStyle |= Gdiplus::FontStyleStrikeout;
    }

    return nFontStyle;
}


inline float GetGpFontHeight(Element * pel)
{
    float flSize = (float) pel->GetFontSize();
    return flSize * 72.0f / 96.0f;
}


#endif // GADGET_ENABLE_GDIPLUS

#define LIGHT       0.5
#define VERYLIGHT   0.8
#define DARK        -0.3
#define VERYDARK    -0.75

// 1 >= fIllum >= -1
inline COLORREF _AdjustBrightness(COLORREF cr, double fIllum)
{
    double r, g, b;

    r = (double)GetRValue(cr);
    g = (double)GetGValue(cr);
    b = (double)GetBValue(cr);

    if (fIllum > 0.0)
    {
        r += (255.0 - r) * fIllum;
        g += (255.0 - g) * fIllum;
        b += (255.0 - b) * fIllum;
    }
    else
    {
        r += r * fIllum;
        g += g * fIllum;
        b += b * fIllum;
    }

    return RGB((int)r, (int)g, (int)b);
}

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Color _AdjustBrightness(Gdiplus::Color cr, double fIllum)
{
    double r, g, b;

    r = (double)cr.GetR();
    g = (double)cr.GetG();
    b = (double)cr.GetB();

    if (fIllum > 0.0)
    {
        r += (255.0 - r) * fIllum;
        g += (255.0 - g) * fIllum;
        b += (255.0 - b) * fIllum;
    }
    else
    {
        r += r * fIllum;
        g += g * fIllum;
        b += b * fIllum;
    }

    return Gdiplus::Color(cr.GetA(), (BYTE)r, (BYTE)g, (BYTE)b);
}

inline Gdiplus::Color AdjustAlpha(Gdiplus::Color cr, BYTE bAlphaLevel)
{
    int aa1 = cr.GetA();
    int aa2 = bAlphaLevel;

    DUIAssert((aa1 <= 255) && (aa2 >= 0), "Ensure valid nA alpha");
    DUIAssert((aa2 <= 255) && (aa2 >= 0), "Ensure valid nB alpha");

    int aaaa = aa1 * aa2 + 0x00FF;
    
    return Gdiplus::Color((BYTE) (aaaa >> 8), cr.GetR(), cr.GetG(), cr.GetB());
}


class AlphaBitmap
{
public:
    AlphaBitmap(Gdiplus::Bitmap * pgpbmp, BYTE bAlphaLevel)
    {
        DUIAssert(pgpbmp != NULL, "Must have a valid bitmap");
        
        m_fDelete       = FALSE;
        m_pgpbmpSrc     = pgpbmp;
        m_bAlphaLevel   = bAlphaLevel;
    }

    ~AlphaBitmap()
    {
        if (m_fDelete) {
            delete m_pgpbmpAlpha;  // Allocated by GDI+ (cannot use HDelete)
        }
    }

    operator Gdiplus::Bitmap *()
    {
        //
        // Create the alpha bitmap on the first request.  This avoids creating
        // the bitmap if it will never be used.
        //
        // When the alpha bitmap has been created, we no longer need the source 
        // bitmap.  By setting this to NULL, we signal that the alpha bitmap is 
        // 'valid' and we won't recompute it.
        //
        
        if (m_pgpbmpSrc != NULL) {
            if (m_bAlphaLevel < 5) {
                //
                // Completely transparent, so nothing to draw.  This is okay, as 
                // Graphics::DrawImage() properly checks if the Image is NULL.
                //

                m_pgpbmpAlpha = NULL;
                m_pgpbmpSrc = NULL;
            } else if (m_bAlphaLevel >= 250) {
                //
                // No alpha being applied, so just use the original bitmap
                //

                m_pgpbmpAlpha = m_pgpbmpSrc;
                m_pgpbmpSrc = NULL;
            } else {
                //
                // Need to build a new bitmap and multiply in the constant 
                // alpha.  We create a 32-bit _P_ARGB bitmap because we can
                // premultiply the alpha channel into the R, G, and B channels
                // more efficiently here than GDI+ can do later, and the work
                // needs to get done.
                //

                Gdiplus::PixelFormat gppf = PixelFormat32bppPARGB;
                Gdiplus::Rect rc(0, 0, (int) m_pgpbmpSrc->GetWidth(), (int) m_pgpbmpSrc->GetHeight());
                m_pgpbmpAlpha = m_pgpbmpSrc->Clone(rc, gppf);

                if (m_pgpbmpAlpha != NULL) {
                    m_fDelete = TRUE;

                    Gdiplus::BitmapData bd;
                    if (m_pgpbmpAlpha->LockBits(&rc, Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeWrite, 
                            gppf, &bd) == Gdiplus::Ok) {

                        BYTE *pRow = (BYTE*) bd.Scan0;
                        DWORD *pCol;
                        Gdiplus::ARGB c;
                        for (int y = 0; y < rc.Height; y++, pRow += bd.Stride) {
                            pCol = (DWORD *) pRow;
                            for (int x = 0; x < rc.Width; x++, pCol++) {
                                //
                                // NOTE: This code is taken from GDI+ and is 
                                // optimized to premultiply a constant alpha
                                // level.
                                //
                                
                                c = *pCol;
                                if ((c & 0xff000000) != 0x00000000) {
                                    Gdiplus::ARGB _00aa00gg = (c >> 8) & 0x00ff00ff;
                                    Gdiplus::ARGB _00rr00bb = (c & 0x00ff00ff);

                                    Gdiplus::ARGB _aaaagggg = _00aa00gg * m_bAlphaLevel + 0x00ff00ff;
                                    _aaaagggg += ((_aaaagggg >> 8) & 0x00ff00ff);

                                    Gdiplus::ARGB _rrrrbbbb = _00rr00bb * m_bAlphaLevel + 0x00ff00ff;
                                    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

                                    c = (_aaaagggg & 0xff00ff00) |
                                           ((_rrrrbbbb >> 8) & 0x00ff00ff);
                                } else {
                                    c = 0;
                                }

                                *pCol = c;
                            }
                        }

                        m_pgpbmpAlpha->UnlockBits(&bd);
                    } else {
                        DUIAssertForce("Unable to lock bits of GpBitmap");
                    }
                    m_pgpbmpSrc = NULL;
                }
            }
        }
        
        return m_pgpbmpAlpha;
    }

protected:
            Gdiplus::Bitmap * 
                        m_pgpbmpSrc;
            Gdiplus::Bitmap * 
                        m_pgpbmpAlpha;
            BOOL        m_fDelete;
            BYTE        m_bAlphaLevel;
};


#endif // GADGET_ENABLE_GDIPLUS

#define ModCtrl  0
#define ModAlt   1
#define ModShift 2
#define ModCount 3

static LPWSTR lpszMods[ModCount] = { L"Ctrl", L"Alt", L"Shift" };
static int maxMod = -1;


// Length (in characters) of modifier strings + ' ' + '(' + 3 chars for '+' after
// each modifier + 1 char for mnemonic + ')'. (I.e "Test (Ctrl+Alt+Shift+O)")
// Covers both the size of the postpended help string, or the added '&' (whichever is used).
int GetMaxMod()
{
    if (maxMod == -1)
        maxMod = (int) (wcslen(lpszMods[ModCtrl]) + wcslen(lpszMods[ModAlt]) + wcslen(lpszMods[ModShift]) + 7);

    return maxMod;
}


void BuildRenderString(LPWSTR pszSrc, LPWSTR pszDst, WCHAR wcShortcut, BOOL* pfUnderline)
{
    BOOL fAllowUnderline = *pfUnderline;
    *pfUnderline = FALSE;

    if ((wcShortcut >= 'a') && (wcShortcut <= 'z'))
        wcShortcut -= 32;

    while (*pszSrc)                    
    {
        WCHAR wc = *pszSrc++;
        if (fAllowUnderline && !*pfUnderline)
        {
            if ((wc - (((wc >= 'a') && (wc <= 'z')) ? 32 : 0)) == wcShortcut)
            {
                *pszDst++ = '&';
                *pfUnderline = TRUE;
            }
        }
        *pszDst++ = wc;
    }

    if (!*pfUnderline)
    {
        *pszDst++ = ' ';
        *pszDst++ = '(';
        if (0)
        {
            LPWSTR pszMod = lpszMods[ModCtrl];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        if (1)
        {
            LPWSTR pszMod = lpszMods[ModAlt];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        if (0)
        {
            LPWSTR pszMod = lpszMods[ModShift];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        *pszDst++ = wcShortcut;
        *pszDst++ = ')';
    }

    *pszDst = 0;
}
                
inline int _MaxClip(int dNew, int dMax)
{
    return (dNew > dMax) ? dMax : dNew;
}


//
// GDI Rendering
//

// NULL prBorder or prPadding means all-zero sided
// If prcSkipBorder is non-NULL, don't render border, rather, set inner border edges (where the
// background begins) in provided rectangle (thickness is prcBounds and *prcSkipBorder difference)
// If prcSkipContent is non-NULL, don't render content, rather, set content bounds in provided rectangle
void Element::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    //DUITrace(L"Paint <%x>", this);

    RECT rcPaint = *prcBounds;
    HBRUSH hb;
    bool fDelete;

    // Retrieve all rendering parameters and adjust for RTL if needed

    // Background Value
    Value* pvBackgnd = GetValue(BackgroundProp, PI_Specified);

    // Border thickness
    RECT rcBorder;
    SetRectEmpty(&rcBorder);

    if (HasBorder())
    {
        Value* pvBorder = GetValue(BorderThicknessProp, PI_Specified, NULL);
        MapRect(this, pvBorder->GetRect(), &rcBorder);
        pvBorder->Release();
    }

    // Padding thickness
    RECT rcPadding;
    SetRectEmpty(&rcPadding);

    if (HasPadding())
    {
        // Get non-zero padding
        Value* pvPadding = GetValue(PaddingProp, PI_Specified, NULL);
        MapRect(this, pvPadding->GetRect(), &rcPadding);
        pvPadding->Release();
    }

    //
    // Draw border
    // Skip if requested
    //

    // The following restrictions apply:
    //
    //   Only solid colors supported in border rendering
    //   Border rendering skipped if nine-grid background rendering is used

    if (!prcSkipBorder)
    {
        // Before rendering border, check if background type is nine-grid.
        // If so, skip. Border rendering will happen during background painting pass
        if ((pvBackgnd->GetType() != DUIV_GRAPHIC) ||
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGrid) &&
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGridTransColor) &&
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGridAlphaConstPerPix))
        {
            COLORREF crBase = 0;  // Base color for raised and sunken painting
            RECT rcLessBD;

            // Get border color (Value) (alpha not yet impl)
            hb = NULL;
            fDelete = true;

            // Get border style
            int dBDStyle = GetBorderStyle();

            Value* pvBdrColor = GetValue(BorderColorProp, PI_Specified); 
            switch (pvBdrColor->GetType())
            {
            case DUIV_INT:
                fDelete = false;
                hb = BrushFromEnumI(pvBdrColor->GetInt());
                if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                    crBase = ColorFromEnumI(pvBdrColor->GetInt());
                break;

            case DUIV_FILL:
                {
                    const Fill* pf = pvBdrColor->GetFill();  // Only solid colors supported
                    if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                        hb = CreateSolidBrush(RemoveAlpha(pf->ref.cr));
                    else
                    {
                        crBase = RemoveAlpha(pf->ref.cr);
                        hb = CreateSolidBrush(crBase);
                    }
                }
                break;
            }
            pvBdrColor->Release();

            // Get rect less border
            rcLessBD = rcPaint;
            _ReduceBounds(&rcLessBD, &rcBorder);

            RECT rc;
            switch (dBDStyle)
            {
            case BDS_Solid:  // Solid border
                _Fill(hDC, hb, rcPaint.left, rcLessBD.top, rcLessBD.left, rcLessBD.bottom);    // left
                _Fill(hDC, hb, rcPaint.left, rcPaint.top, rcPaint.right, rcLessBD.top);        // top
                _Fill(hDC, hb, rcLessBD.right, rcLessBD.top, rcPaint.right, rcLessBD.bottom);  // right
                _Fill(hDC, hb, rcPaint.left, rcLessBD.bottom, rcPaint.right, rcPaint.bottom);  // bottom
                /*
                // Paint via clipping
                ElTls* pet = (ElTls*)TlsGetValue(g_dwElSlot);  // Per-thread regions for drawing
                SetRectRgn(pet->hClip0, rcLessBD.left, rcLessBD.top, rcLessBD.right, rcLessBD.bottom);
                SetRectRgn(pet->hClip1, rcPaint.left, rcPaint.top, rcPaint.right, rcPaint.bottom);
                CombineRgn(pet->hClip1, pet->hClip1, pet->hClip0, RGN_DIFF);
                SelectClipRgn(hDC, pet->hClip1);
                FillRect(hDC, &rcPaint, hb);
                SelectClipRgn(hDC, NULL);
                */
                break;

            case BDS_Rounded:   // Rounded rectangle
                //
                // TODO: Implement RoundRect in GDI.  This is more than calling 
                // GDI's RoundRect() since we are using a brush and need to be able to specify
                // a thickness.  To accomplish this, probably build a temporary pen.
                //

                DUIAssertForce("Rounded style not yet supported with GDI");
                break;

            case BDS_Raised:    // Raised border
            case BDS_Sunken:    // Sunken border
                {
                    // Find where etch begins
                    SetRect(&rc, rcBorder.left / 2, rcBorder.top / 2, rcBorder.right / 2, rcBorder.bottom / 2);
                    RECT rcEtch = rcPaint;
                    _ReduceBounds(&rcEtch, &rc);

                    // Create other intensity brushes
                    HBRUSH hbOLT;  // Brush for outter left and top
                    HBRUSH hbORB;  // Brush for outter right and bottom
                    HBRUSH hbILT;  // Brush for inner left top
                    HBRUSH hbIRB;  // Brush for inner right and bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        hbOLT = hb;
                        hbORB = CreateSolidBrush(_AdjustBrightness(crBase, VERYDARK));
                        hbILT = CreateSolidBrush(_AdjustBrightness(crBase, VERYLIGHT));
                        hbIRB = CreateSolidBrush(_AdjustBrightness(crBase, DARK));
                    }
                    else
                    {
                        hbOLT = CreateSolidBrush(_AdjustBrightness(crBase, VERYDARK));
                        hbORB = CreateSolidBrush(_AdjustBrightness(crBase, VERYLIGHT));
                        hbILT = CreateSolidBrush(_AdjustBrightness(crBase, DARK));
                        hbIRB = hb;
                    }

                    // Paint etches
                    _Fill(hDC, hbOLT, rcPaint.left, rcPaint.top, rcEtch.left, rcEtch.bottom);       // Outter left
                    _Fill(hDC, hbOLT, rcEtch.left, rcPaint.top, rcEtch.right, rcEtch.top);          // Outter top
                    _Fill(hDC, hbORB, rcEtch.right, rcPaint.top, rcPaint.right, rcPaint.bottom);    // Outter right
                    _Fill(hDC, hbORB, rcPaint.left, rcEtch.bottom, rcEtch.right, rcPaint.bottom);   // Outter bottom
                    _Fill(hDC, hbILT, rcEtch.left, rcEtch.top, rcLessBD.left, rcLessBD.bottom);     // Inner left
                    _Fill(hDC, hbILT, rcLessBD.left, rcEtch.top, rcLessBD.right, rcLessBD.top);     // Inner top 
                    _Fill(hDC, hbIRB, rcLessBD.right, rcEtch.top, rcEtch.right, rcEtch.bottom);     // Inner right
                    _Fill(hDC, hbIRB, rcEtch.left, rcLessBD.bottom, rcLessBD.right, rcEtch.bottom); // Inner bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        if (hbORB)
                            DeleteObject(hbORB);
                        if (hbILT)
                            DeleteObject(hbILT);
                        if (hbIRB)
                            DeleteObject(hbIRB);
                    }
                    else
                    {
                        if (hbOLT)
                            DeleteObject(hbOLT);
                        if (hbORB)
                            DeleteObject(hbORB);
                        if (hbILT)
                            DeleteObject(hbILT);
                    }
                }
                break;
            }

            // Cleanup
            if (hb && fDelete)
                DeleteObject(hb);

            // New rectangle for painting background
            rcPaint = rcLessBD;
        }
        else
        {
            // Border rendering manually skipped, reduce painting rect by borders
            _ReduceBounds(&rcPaint, &rcBorder);
        }
    }
    else
    {
        // Skipping border render due to outside request, reduce bounds, copy into
        // provided rect, and continue
        _ReduceBounds(&rcPaint, &rcBorder);
        *prcSkipBorder = rcPaint;
    }

    //
    // Draw background
    //

    // All graphic types are used as fills except those marked as stretched, nine-grid and metafiles, 
    // they are drawn to fit.
    //
    // The following restrictions apply:
    //
    //   Icons are not supported in background
    //   Metafiles automaticlly stretch to fit
    //   GRAPHIC_TransColor and GRAPHIC_TrandColorAuto Bitmaps unsupported
    //   GRAPHIC_NoBlend and GRAPHIC_EntireAlpha fill via tiling, per-pixel alpha ignored

    hb = NULL;
    fDelete = true;
    BYTE dAlpha = 255;  // Opaque
    const Fill* pfGradient = NULL;

    switch (pvBackgnd->GetType())
    {
    case DUIV_INT:
        fDelete = false;
        hb = BrushFromEnumI(pvBackgnd->GetInt());
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value
        {
            const Fill* pf = pvBackgnd->GetFill();
            switch (pf->dType)
            {
            case FILLTYPE_Solid:
                dAlpha = GetAValue(pf->ref.cr);
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
                    hb = CreateSolidBrush(RemoveAlpha(pf->ref.cr));
                break;

            case FILLTYPE_HGradient:
            case FILLTYPE_VGradient:
            case FILLTYPE_TriHGradient:
            case FILLTYPE_TriVGradient:
                pfGradient = pvBackgnd->GetFill();
                fDelete = false;
                break;

            case FILLTYPE_DrawFrameControl:
                DrawFrameControl(hDC, &rcPaint, pf->fillDFC.uType, pf->fillDFC.uState);
                dAlpha = 0;  // Bypass fill
                fDelete = false;
                break;

            case FILLTYPE_DrawThemeBackground:
                DrawThemeBackground(pf->fillDTB.hTheme, hDC, pf->fillDTB.iPartId, pf->fillDTB.iStateId, &rcPaint, &rcPaint);
                dAlpha = 0;  // Bypass fill
                fDelete = false;
                break;
            }
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills unsupported
        {
            Graphic* pg = pvBackgnd->GetGraphic();
            
            switch (pg->BlendMode.dImgType)
            {
            case GRAPHICTYPE_Bitmap:
                {
                    switch (pg->BlendMode.dMode)
                    {
                    case GRAPHIC_Stretch:
                        {
                            // Render immediately, no brush is created
                            HBITMAP hbmSrc = GethBitmap(pvBackgnd, IsRTL());
                            HDC hdcSrc = CreateCompatibleDC(hDC);
                            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcSrc, hbmSrc);
                            int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);

                            StretchBlt(hDC, rcPaint.left, rcPaint.top, rcPaint.right - rcPaint.left, rcPaint.bottom - rcPaint.top,
                                       hdcSrc, 0, 0, pg->cx, pg->cy, SRCCOPY);

                            SetStretchBltMode(hDC, nSBMOld);
                            SelectObject(hdcSrc, hbmOld);
                            DeleteDC(hdcSrc);

                            dAlpha = 0;  // Bypass fill
                        }
                        break;

                    case GRAPHIC_NineGrid:
                    case GRAPHIC_NineGridTransColor:
                    case GRAPHIC_NineGridAlphaConstPerPix:
                        {
                            // Render immediately, no brush is created, stretch to bounds
                            NGINFO ng;
                            ZeroMemory(&ng, sizeof(ng));

                            int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);

                            ng.dwSize = sizeof(ng);
                            ng.hdcDest = hDC;
                            ng.eImageSizing = ST_STRETCH;
                            ng.hBitmap = GethBitmap(pvBackgnd, IsRTL());
                            SetRect(&ng.rcSrc, 0, 0, pg->cx, pg->cy);
                            SetRect(&ng.rcDest, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom);
                            CopyRect(&ng.rcClip, &ng.rcDest);
                            //CopyRect(&ng.rcClip, prcInvalid);
                            ng.iSrcMargins[0] = ng.iDestMargins[0] = rcBorder.left;
                            ng.iSrcMargins[1] = ng.iDestMargins[1] = rcBorder.right;
                            ng.iSrcMargins[2] = ng.iDestMargins[2] = rcBorder.top;
                            ng.iSrcMargins[3] = ng.iDestMargins[3] = rcBorder.bottom;

                            if (pg->BlendMode.dMode == GRAPHIC_NineGridTransColor)
                            {
                                ng.dwOptions = DNG_TRANSPARENT;
                                ng.crTransparent = RGB(pg->BlendMode.rgbTrans.r, pg->BlendMode.rgbTrans.g, pg->BlendMode.rgbTrans.b);
                            }
                            else if (pg->BlendMode.dMode == GRAPHIC_NineGridAlphaConstPerPix)
                            {
                                ng.dwOptions = DNG_ALPHABLEND;
                                ng.AlphaBlendInfo.BlendOp = AC_SRC_OVER;
                                ng.AlphaBlendInfo.BlendFlags = 0;
                                ng.AlphaBlendInfo.SourceConstantAlpha = pg->BlendMode.dAlpha;
                                ng.AlphaBlendInfo.AlphaFormat = AC_SRC_ALPHA;
                            }

                            DrawNineGrid(&ng);

                            SetStretchBltMode(hDC, nSBMOld);

                            dAlpha = 0;  // Bypass fill
                        }
                        break;

                    case GRAPHIC_AlphaConst:
                        // Update Alpha value (was initialized to 255: opaque)
                        dAlpha = pg->BlendMode.dAlpha;

                        // If transparent , do not create a bitmap brush for tiling
                        if (dAlpha == 0)
                        {
                            fDelete = false;
                            break;
                        }

                        // Fall though

                    default:
                        // Create a patterned brush
                        hb = CreatePatternBrush(GethBitmap(pvBackgnd, IsRTL()));
                        break;
                    }
                }
                break;

            case GRAPHICTYPE_EnhMetaFile:
                {
                    // Render immediately, no brush is created
                    PlayEnhMetaFile(hDC, GethEnhMetaFile(pvBackgnd, IsRTL()), &rcPaint);
                    dAlpha = 0;  // Bypass fill
                }
                break;

#ifdef GADGET_ENABLE_GDIPLUS
            case GRAPHICTYPE_GpBitmap:
                break;
#endif
            }
        }
        break;
    }

    // Fill using either a gradient or a supplied fill brush
    // Any stretch-based fill has already occured and will force
    // dAlpha to be 0 so that this step is bypassed

    if (!pfGradient)
    {
        if (dAlpha)  // No fill if 0 opacity
        {
            // Use intersection of invalid rect with background fill area
            // (stored in rcPaint) as new fill area
            RECT rcFill;
            IntersectRect(&rcFill, prcInvalid, &rcPaint);

            if (dAlpha == 255)  // Normal fill for opaque
                FillRect(hDC, &rcFill, hb);
            else
                UtilDrawBlendRect(hDC, &rcFill, hb, dAlpha, 0, 0);
        }
    }
    else
    {
        // Gradient background fill
        TRIVERTEX vert[2];
        GRADIENT_RECT gRect;

        vert[0].x = rcPaint.left;
        vert[0].y = rcPaint.top;
        vert[1].x = rcPaint.right;
        vert[1].y = rcPaint.bottom; 

        int i = IsRTL() ? 1 : 0;

        // first vertex
        vert[i].Red   = (USHORT)(GetRValue(pfGradient->ref.cr) << 8);
        vert[i].Green = (USHORT)(GetGValue(pfGradient->ref.cr) << 8);
        vert[i].Blue  = (USHORT)(GetBValue(pfGradient->ref.cr) << 8);
        vert[i].Alpha = (USHORT)(GetAValue(pfGradient->ref.cr) << 8);

        i = 1 - i;

        // second vertex
        vert[i].Red   = (USHORT)(GetRValue(pfGradient->ref.cr2) << 8);
        vert[i].Green = (USHORT)(GetGValue(pfGradient->ref.cr2) << 8);
        vert[i].Blue  = (USHORT)(GetBValue(pfGradient->ref.cr2) << 8);
        vert[i].Alpha = (USHORT)(GetAValue(pfGradient->ref.cr2) << 8);

        gRect.UpperLeft  = 0;
        gRect.LowerRight = 1;

        GradientFill(hDC, vert, 2, &gRect, 1, (pfGradient->dType == FILLTYPE_HGradient) ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V);
    }

    // Clean up brush, if exists
    if (hb && fDelete)
        DeleteObject(hb);

    //
    // Reduce by padding
    //

    _ReduceBounds(&rcPaint, &rcPadding);

    //
    // Content
    //

    // The following restrictions apply:
    //
    //   Only solid colors supported for foreground rendering (graphics unsupported)
    //   
    //   Border rendering skipped if nine-grid background rendering is used
    //   All icons, metafiles, and bimaps (of bitmaps: GRAPHIC_NoBlend,
    //       GRAPHIC_EntireAlpha, GRAPHIC_TransColor, GRAPHIC_TransColorAuto supported)
    //   If destination is smaller than image size, it will be shrinked in all cases

    // Skip content drawing if requested
    if (!prcSkipContent)
    {
        // Draw content (if exists)

        // Get content alignment and map
        int dCAlign = MapAlign(this, GetContentAlign());

        // Render focus rect if requested and if Element is active
        if ((dCAlign & CA_FocusRect) && (GetActive() & AE_Keyboard))
        {
            // Check if should display this keyboard cue
            Element* peRoot = GetRoot();
            if (peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
            {
                if (((HWNDElement*)peRoot)->ShowFocus())
                {
                    RECT rcFocus = rcPaint;
                    
                    int xInset = min(rcPadding.left / 2, rcPadding.right / 2);
                    int yInset = min(rcPadding.top / 2, rcPadding.bottom / 2);
                    
                    rcFocus.left = rcPaint.left - rcPadding.left + xInset; rcFocus.right = rcPaint.right + rcPadding.right - xInset;
                    rcFocus.top  = rcPaint.top - rcPadding.top + yInset;   rcFocus.bottom = rcPaint.bottom + rcPadding.bottom - yInset;
                    
                    IntersectRect(&rcFocus, &rcFocus, prcBounds);
                    DrawFocusRect(hDC, &rcFocus);
                }
            }
        }

        // Foreground is only used during text content rendering (graphics are ignored)
        if (HasContent())
        {
            Value* pvContent = GetValue(ContentProp, PI_Specified);
            switch (pvContent->GetType())
            {
            case DUIV_STRING:
                {
                    LPWSTR pszContent = pvContent->GetString(); 
                    WCHAR wcShortcut = (WCHAR) GetShortcut();
                    BOOL fUnderline = FALSE;
                    if (wcShortcut)
                    {
                        LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                        fUnderline = TRUE;
                        BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                        pszContent = pszNew;
                    }

                    HFONT hFont = NULL;
                    HFONT hOldFont = NULL;

                    int dFontSize = GetFontSize();

                    FontCache* pfc = GetFontCache();
                    if (pfc)
                    {
                        Value* pvFFace;
                        hFont = pfc->CheckOutFont(GetFontFace(&pvFFace), 
                                                  dFontSize, 
                                                  GetFontWeight(), 
                                                  GetFontStyle(),
                                                  0);
                        pvFFace->Release();
                    }

                    if (hFont)
                        hOldFont = (HFONT)SelectObject(hDC, hFont);

                    // Set foreground (graphic is unsupported)
                    Value* pvFore = GetValue(ForegroundProp, PI_Specified); 
                    switch (pvFore->GetType())
                    {
                    case DUIV_INT:
                        // Auto-map if using palettes (PALETTERGB)
                        SetTextColor(hDC, NearestPalColor(ColorFromEnumI(pvFore->GetInt())));
                        break;

                    case DUIV_FILL:
                        // Auto-map if using palettes (PALETTERGB)
                        SetTextColor(hDC, NearestPalColor(RemoveAlpha(pvFore->GetFill()->ref.cr)));  // Map out any Alpha channel, solid colors only
                        break;
                    }
                    pvFore->Release();

                    // Never draw font backgrounds
                    SetBkMode(hDC, TRANSPARENT);

                    // Compensate for font overhang. Clipping rectangle is wider than
                    // painting rectangle (by 1/6 height of font for each side)
                    
                    // NOTE: Since DrawText doesn't allow for a clipping rectangle that's
                    // different than the drawing rectangle, this overhang compension
                    // only works for ExtTextOut (i.e. no wrapping or underlining)
                    RECT rcClip = rcPaint;

                    dFontSize = abs(dFontSize); // Need magnitude

                    RECT rcOverhang;
                    SetRect(&rcOverhang, dFontSize / 6, 0, dFontSize / 6, 0);
                    
                    _ReduceBounds(&rcPaint, &rcOverhang);
                    
                    // Output text
                    // Use faster method if not word wrapping, no prefix chars, and no ellipsis, and not vertically centered
                    if (!IsWordWrap() && !fUnderline && !(dCAlign & CA_EndEllipsis) && (((dCAlign & 0xC) >> 2) != 0x1))
                    {
                        // Setup alignment
                        UINT fMode = 0;
                        int x = 0;
                        int y = 0;
                        
                        switch (dCAlign & 0x3)  // Lower 2 bits
                        {
                        case 0x0:   // Left
                            fMode |= TA_LEFT;
                            x = rcPaint.left;
                            break;
                
                        case 0x1:   // Center
                            fMode |= TA_CENTER;
                            x = (rcPaint.left + rcPaint.right) / 2;
                            break;

                        case 0x2:   // Right
                            fMode |= TA_RIGHT;
                            x = rcPaint.right;
                            break;
                        }
                        
                        switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                        {
                        case 0x0:  // Top
                            fMode |= TA_TOP;
                            y = rcPaint.top;
                            break;

                        case 0x1:  // Middle
                            // Only option is TA_BASELINE, which isn't
                            // accurate for centering vertically
                            break;

                        case 0x2:  // Bottom
                            fMode |= TA_BOTTOM;
                            y = rcPaint.bottom;
                            break;
                        }

                        UINT fOldMode = SetTextAlign(hDC, fMode);

                        ExtTextOutW(hDC, x, y, ETO_CLIPPED | (IsRTL() ? ETO_RTLREADING : 0), &rcClip, pszContent, (UINT)wcslen(pszContent), NULL);

                        // Restore
                        SetTextAlign(hDC, fOldMode);
                    }
                    else
                    {
                        UINT dFlags = fUnderline ? 0 : DT_NOPREFIX;

                        if (IsRTL())
                            dFlags |= DT_RTLREADING;

                        if (dCAlign & CA_EndEllipsis)
                            dFlags |= DT_END_ELLIPSIS;

                        switch (dCAlign & 0x3)  // Lower 2 bits
                        {
                        case 0x0:   // Left
                            dFlags |= DT_LEFT;
                            break;
                
                        case 0x1:   // Center
                            dFlags |= DT_CENTER;
                            break;

                        case 0x2:   // Right
                            dFlags |= DT_RIGHT;
                            break;
                        }

                        switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                        {
                        case 0x0:  // Top
                            dFlags |= (DT_TOP | DT_SINGLELINE);
                            break;

                        case 0x1:  // Middle
                            dFlags |= (DT_VCENTER | DT_SINGLELINE);
                            break;

                        case 0x2:  // Bottom
                            dFlags |= (DT_BOTTOM | DT_SINGLELINE);
                            break;

                        case 0x3:  // Wrap
                            dFlags |= DT_WORDBREAK;
                            break;
                        }

                        //DUITrace("DrawText (%S), x:%d y:%d cx:%d cy:%d\n", pszContent, rcPaint.left, rcPaint.top, 
                        //    rcPaint.right - rcPaint.left, rcPaint.bottom - rcPaint.top);
                
                        DrawTextW(hDC, pszContent, -1, &rcPaint, dFlags);
                    }
     
                    if (hOldFont)
                        SelectObject(hDC, hOldFont);
                    if (pfc)
                        pfc->CheckInFont();
                }
                break;

            case DUIV_GRAPHIC:
            case DUIV_FILL:
                {
                    SIZE sizeContent;

                    if (pvContent->GetType() == DUIV_GRAPHIC)
                    {
                        // DUIV_GRAPHIC
                        Graphic* pgContent = pvContent->GetGraphic();
                        sizeContent.cx = pgContent->cx;
                        sizeContent.cy = pgContent->cy;
                    }
                    else
                    {
                        // DUIV_FILL
                        const Fill* pfContent = pvContent->GetFill();
                        GetThemePartSize(pfContent->fillDTB.hTheme, hDC, pfContent->fillDTB.iPartId, pfContent->fillDTB.iStateId, NULL, TS_TRUE, &sizeContent);
                    }

                    // Clipped image size, shrink when desintation is smaller than image size
                    SIZE sizeDest;
                    sizeDest.cx = _MaxClip(rcPaint.right - rcPaint.left, sizeContent.cx);
                    sizeDest.cy = _MaxClip(rcPaint.bottom - rcPaint.top, sizeContent.cy);

                    // Adjust top/left offset based on content alignment. Bottom/right is not
                    // changed (sizeDest will be used when rendering)

                    switch (dCAlign & 0x3)  // Lower 2 bits
                    {
                    case 0x0:   // Left
                        break;

                    case 0x1:   // Center
                        rcPaint.left += (rcPaint.right - rcPaint.left - sizeDest.cx) / 2;
                        break;

                    case 0x2:   // Right
                        rcPaint.left = rcPaint.right - sizeDest.cx;
                        break;
                    }

                    switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                    {
                    case 0x0:  // Top
                        break;

                    case 0x1:  // Middle
                        rcPaint.top += (rcPaint.bottom - rcPaint.top - sizeDest.cy) / 2;
                        break;

                    case 0x2:  // Bottom
                        rcPaint.top = rcPaint.bottom - sizeDest.cy;
                        break;

                    case 0x3:  // Wrap
                        break;
                    }

                    // Draw
                    if (pvContent->GetType() == DUIV_GRAPHIC)
                    {
                        // DUIV_GRAPHIC
                    
                        Graphic* pgContent = pvContent->GetGraphic();

                        switch (pgContent->BlendMode.dImgType)
                        {
                        case GRAPHICTYPE_Bitmap:
                            {
                                // Draw bitmap
                                HDC hMemDC = CreateCompatibleDC(hDC);
                                SelectObject(hMemDC, GethBitmap(pvContent, IsRTL()));

                                switch (pgContent->BlendMode.dMode)
                                {
                                case GRAPHIC_NoBlend:
                                    if ((sizeDest.cx == pgContent->cx) && (sizeDest.cy == pgContent->cy))
                                        BitBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, SRCCOPY);
                                    else
                                    {
                                        int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);
                                        StretchBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy, SRCCOPY);
                                        SetStretchBltMode(hDC, nSBMOld);
                                    }
                                    break;

                                case GRAPHIC_AlphaConst:
                                case GRAPHIC_AlphaConstPerPix:
                                    {
                                        BLENDFUNCTION bf = { static_cast<BYTE>(AC_SRC_OVER), 0, static_cast<BYTE>(pgContent->BlendMode.dAlpha), (pgContent->BlendMode.dMode == GRAPHIC_AlphaConstPerPix) ? static_cast<BYTE>(AC_SRC_ALPHA) : static_cast<BYTE>(0) };
                                        AlphaBlend(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy, bf);
                                    }
                                    break;

                                case GRAPHIC_TransColor:
                                    TransparentBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy,
                                                   RGB(pgContent->BlendMode.rgbTrans.r, pgContent->BlendMode.rgbTrans.g, pgContent->BlendMode.rgbTrans.b));
                                    break;
                                }

                                DeleteDC(hMemDC);
                            }
                            break;

                        case GRAPHICTYPE_Icon:
                            // Draw icon, always shink for destinations that are smaller than image size
                            // Zero width/height denotes draw actual size, don't draw in this case
                            if (sizeDest.cx && sizeDest.cy)
                                DrawIconEx(hDC, rcPaint.left, rcPaint.top, GethIcon(pvContent, IsRTL()), sizeDest.cx, sizeDest.cy, 0, NULL, DI_NORMAL);
                            break;

                        case GRAPHICTYPE_EnhMetaFile:
                            // Draw enhanced metafile

                            // Adjust rest of painting bounds since API doesn't take width/height
                            rcPaint.right = rcPaint.left + sizeDest.cx;
                            rcPaint.bottom = rcPaint.top + sizeDest.cy;
                            
                            PlayEnhMetaFile(hDC, GethEnhMetaFile(pvContent, IsRTL()), &rcPaint);
                            break;

#ifdef GADGET_ENABLE_GDIPLUS
                        case GRAPHICTYPE_GpBitmap:
                            DUIAssertForce("GDI+ bitmaps not yet supported in a GDI tree");
                            break;
#endif // GADGET_ENABLE_GDIPLUS
                        }
                    }
                    else
                    {
                        // DUIV_FILL

                        // Adjust rest of painting bounds since API doesn't take width/height
                        rcPaint.right = rcPaint.left + sizeDest.cx;
                        rcPaint.bottom = rcPaint.top + sizeDest.cy;
                        
                        const Fill* pfContent = pvContent->GetFill();
                        DrawThemeBackground(pfContent->fillDTB.hTheme, hDC, pfContent->fillDTB.iPartId, pfContent->fillDTB.iStateId, &rcPaint, &rcPaint);
                    }
                }
                break;
            }

            pvContent->Release();
        }
    }
    else
    {
        *prcSkipContent = rcPaint;
    }

    // Clean up
    pvBackgnd->Release();
}


//
// GDI+ Rendering
//

#ifdef GADGET_ENABLE_GDIPLUS

struct NGINFOGP
{
    Gdiplus::Graphics * pgpgr;
    Gdiplus::Bitmap *   pgpbmp;
    Gdiplus::RectF      rcDest;
    Gdiplus::RectF      rcSrc;
    RECT                rcMargins;
    SIZINGTYPE          eImageSizing;
    BYTE                bAlphaLevel;
    DWORD               dwOptions;                // subset DrawNineGrid() option flags
};

void StretchNGSection(Gdiplus::Graphics * pgpgr, Gdiplus::Bitmap * pgpbmp,
        const Gdiplus::RectF & rcDest, const Gdiplus::RectF & rcSrc)
{
    if ((rcSrc.Width > 0) && (rcSrc.Height > 0))
    {
        pgpgr->DrawImage(pgpbmp, rcDest, rcSrc.X, rcSrc.Y, rcSrc.Width, rcSrc.Height, Gdiplus::UnitPixel);
    }
}

void CheapDrawNineGrid(NGINFOGP * png)
{
    DUIAssert(png->pgpgr != NULL, "Must have valid Graphics");
    DUIAssert(png->pgpbmp != NULL, "Must have valid Graphics");
    DUIAssert(png->eImageSizing == ST_STRETCH, "Only support stretching");

    // Sources margins
    float lw1, rw1, th1, bh1;
    lw1 = (float) png->rcMargins.left;
    rw1 = (float) png->rcMargins.right;
    th1 = (float) png->rcMargins.top;
    bh1 = (float) png->rcMargins.bottom;

    // Destination margins
    float lw2, rw2, th2, bh2;
    lw2 = (float) png->rcMargins.left;
    rw2 = (float) png->rcMargins.right;
    th2 = (float) png->rcMargins.top;
    bh2 = (float) png->rcMargins.bottom;

    const Gdiplus::RectF & rcSrc = png->rcSrc;
    const Gdiplus::RectF & rcDest = png->rcDest;

    if ((lw1 < 0) || (rw1 < 0) || (th1 < 0) || (bh1 < 0))   // not valid
    {
        DUIAssertForce("Illegal parameters");
        return;
    }

    // Setup an alpha bitmap
    BYTE bAlphaLevel;
    if ((png->dwOptions & DNG_ALPHABLEND) != 0)
        bAlphaLevel = png->bAlphaLevel;
    else
        bAlphaLevel = 255;
    AlphaBitmap bmpAlpha(png->pgpbmp, bAlphaLevel);

    // Optimize when only need to draw the center
    if ((lw1 == 0) && (rw1 == 0) && (th1 == 0) && (bh1 == 0))
    {
        StretchNGSection(png->pgpgr, bmpAlpha, png->rcDest, png->rcSrc);
        return;
    }

    // Draw left side
    if (lw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = lw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = lw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

    // Draw the right side
    if (rw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X + rcSrc.Width - rw1;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = rw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X + rcDest.Width - rw2;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = rw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

    float mw1 = rcSrc.Width - lw1 - rw1;
    float mw2 = rcDest.Width - lw2 - rw2;
    
    if (mw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X + lw1;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = mw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X + lw2;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = mw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

}


void GetGpBrush(int c, BYTE bAlphaLevel, Gdiplus::Brush ** ppgpbr, bool * pfDelete)
{
    //
    // We don't cache GDI+ brushes for the system colors, so we need to create 
    // them here.  We also need to account for the alpha-level, so we can't
    // always use the cached brushes.
    //

    Gdiplus::Brush * pgpbr;
    bool fDelete;
    
    if (IsOpaque(bAlphaLevel))
    {
        if (IsSysColorEnum(c)) 
        {
            pgpbr = new Gdiplus::SolidBrush(ConvertSysColorEnum(c));
            fDelete = true;
        }
        else
        {
            pgpbr = GetStdColorBrushF(c);
            fDelete = false;
        }
    }
    else
    {
        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(ColorFromEnumF(c), bAlphaLevel));
        fDelete = true;
    }

    *ppgpbr = pgpbr;
    *pfDelete = fDelete;
}


void Element::Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prcSkipBorder, Gdiplus::RectF* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcInvalid);

    Gdiplus::RectF rcPaint = *prcBounds;
    Gdiplus::Brush * pgpbr;
    bool fDelete;
    Value* pv;

    //
    // Setup deep state to use when rendering the tree
    //

    if (IsRoot()) 
    {
        pgpgr->SetTextRenderingHint(Gdiplus::TextRenderingHintAntiAlias);
    }


    // Border thickness
    RECT rcBorder;
    SetRectEmpty(&rcBorder);
    if (HasBorder())
    {
        Value* pvBorder = GetValue(BorderThicknessProp, PI_Specified, NULL);
        MapRect(this, pvBorder->GetRect(), &rcBorder);
        pvBorder->Release();
    }


    //
    // Compute the constant alpha level that will be used when rendering this 
    // sub-tree.
    //
    
    float flAlphaLevel = GetTreeAlphaLevel();
    BYTE bAlphaLevel = (BYTE) (flAlphaLevel * 255.0f);
    if (IsTransparent(bAlphaLevel)) {
        //
        // Completely transparent, so nothing to draw
        //

        goto CleanUp;
    }


    // Draw border (if exists)
    if (!prcSkipBorder)
    {
        if (HasBorder())
        {
            Gdiplus::Color crBase = 0;  // Base color for raised and sunken painting

            // Get border color (Value) (alpha not yet impl)
            pgpbr = NULL;
            fDelete = true;

            // Get border style
            int dBDStyle = GetBorderStyle();

            pv = GetValue(BorderColorProp, PI_Specified); 
            switch (pv->GetType())
            {
            case DUIV_INT:
                GetGpBrush(pv->GetInt(), bAlphaLevel, &pgpbr, &fDelete);
                if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                    crBase = ColorFromEnumF(pv->GetInt());
                break;

            case DUIV_FILL:
                {
                    const Fill* pf = pv->GetFill();  // Only solid colors supported
                    if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(Convert(pf->ref.cr), bAlphaLevel));
                    else
                    {
                        crBase = Convert(pf->ref.cr);
                        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(crBase, bAlphaLevel));
                    }
                }
                break;
            }
            pv->Release();

            // Get rect less border
            Gdiplus::RectF rcLessBD = rcPaint;
            _ReduceBounds(&rcLessBD, &rcBorder);

            float flLessX2  = rcLessBD.X + rcLessBD.Width;
            float flLessY2  = rcLessBD.Y + rcLessBD.Height;
            float flPaintX2 = rcPaint.X + rcPaint.Width;
            float flPaintY2 = rcPaint.Y + rcPaint.Height;


            switch (dBDStyle)
            {
            case BDS_Solid:     // Solid border
                _Fill(pgpgr, pgpbr, rcPaint.X, rcLessBD.Y, rcLessBD.X, flLessY2); // left
                _Fill(pgpgr, pgpbr, rcPaint.X, rcPaint.Y, flPaintX2, rcLessBD.Y); // top
                _Fill(pgpgr, pgpbr, flLessX2, rcLessBD.Y, flPaintX2, flLessY2);   // right
                _Fill(pgpgr, pgpbr, rcPaint.X, flLessY2, flPaintX2, flPaintY2);   // bottom
                break;

            case BDS_Rounded:   // Rounded rectangle
                {
                    //
                    // Setup rendering mode
                    //

                    Gdiplus::SmoothingMode gpsm = pgpgr->GetSmoothingMode();
                    pgpgr->SetSmoothingMode(Gdiplus::SmoothingModeHighQuality);

                    Gdiplus::SizeF sizePen((float) rcBorder.left, (float) rcBorder.top);
                    Gdiplus::SizeF sizeCornerEdge(sizePen.Width + 1.0f, sizePen.Height + 1.0f);
                    Gdiplus::SizeF sizeCornerShadow(sizePen.Width + 3.0f, sizePen.Height + 3.0f);


                    //
                    // Draw shadow
                    //

                    Gdiplus::Color crShadow(40, 0, 0, 0);
                    Gdiplus::SolidBrush gpbrShadow(AdjustAlpha(crShadow, bAlphaLevel));
                    Gdiplus::RectF rcShadow;
                    rcShadow.X      = rcPaint.X + (float) rcBorder.left;
                    rcShadow.Y      = rcPaint.Y + (float) rcBorder.top;
                    rcShadow.Width  = rcPaint.Width - (float) rcBorder.left - 1.0f;
                    rcShadow.Height = rcPaint.Height - (float) rcBorder.top - 1.0f;

                    DUser::RenderUtil::FillRoundRect(pgpgr, &gpbrShadow, rcShadow, sizeCornerShadow);

                    
                    //
                    // Draw border
                    //

                    Gdiplus::Pen gppen(pgpbr, min(sizePen.Width, sizePen.Height));
                    DUser::RenderUtil::DrawRoundRect(pgpgr, &gppen, rcLessBD, sizeCornerEdge, DUser::RenderUtil::baOutside);


                    //
                    // Clean-up
                    //

                    pgpgr->SetSmoothingMode(gpsm);
                }
                break;

            case BDS_Raised:    // Raised border
            case BDS_Sunken:    // Sunken border
                {
                    // Find where etch begins
                    RECT rc;
                    SetRect(&rc, rcBorder.left / 2, rcBorder.top / 2, rcBorder.right / 2, rcBorder.bottom / 2);
                    Gdiplus::RectF rcEtch = rcPaint;
                    _ReduceBounds(&rcEtch, &rc);

                    // Create other intensity brushes
                    Gdiplus::Brush * pgpbrOLT;  // Brush for outter left and top
                    Gdiplus::Brush * pgpbrORB;  // Brush for outter right and bottom
                    Gdiplus::Brush * pgpbrILT;  // Brush for inner left top
                    Gdiplus::Brush * pgpbrIRB;  // Brush for inner right and bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        pgpbrOLT = pgpbr;
                        pgpbrORB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYDARK), bAlphaLevel));
                        pgpbrILT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYLIGHT), bAlphaLevel));
                        pgpbrIRB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, DARK), bAlphaLevel));
                    }
                    else
                    {
                        pgpbrOLT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYDARK), bAlphaLevel));
                        pgpbrORB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYLIGHT), bAlphaLevel));
                        pgpbrILT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, DARK), bAlphaLevel));
                        pgpbrIRB = pgpbr;
                    }

                    // Paint etches
                    float flEtchX2  = rcEtch.X + rcEtch.Width;
                    float flEtchY2  = rcEtch.Y + rcEtch.Height;

                    _Fill(pgpgr, pgpbrOLT, rcPaint.X, rcPaint.Y, rcEtch.X, flEtchY2);   // Outter left
                    _Fill(pgpgr, pgpbrOLT, rcEtch.X, rcPaint.Y, flEtchX2, rcEtch.Y);    // Outter top
                    _Fill(pgpgr, pgpbrORB, flEtchX2, rcPaint.Y, flPaintX2, flPaintY2);  // Outter right
                    _Fill(pgpgr, pgpbrORB, rcPaint.X, flEtchY2, flEtchX2, flPaintY2);   // Outter bottom
                    _Fill(pgpgr, pgpbrILT, rcEtch.X, rcEtch.Y, rcLessBD.X, flLessY2);   // Inner left
                    _Fill(pgpgr, pgpbrILT, rcLessBD.X, rcEtch.Y, flLessX2, rcLessBD.Y); // Inner top 
                    _Fill(pgpgr, pgpbrIRB, flLessX2, rcEtch.Y, flEtchX2, flEtchY2);     // Inner right
                    _Fill(pgpgr, pgpbrIRB, rcEtch.X, flLessY2, flLessX2, flEtchY2);     // Inner bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        if (pgpbrORB)
                            delete pgpbrORB;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrILT)
                            delete pgpbrILT;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrIRB)
                            delete pgpbrIRB;  // Allocated by GDI+ (cannot use HDelete)
                    }
                    else
                    {
                        if (pgpbrOLT)
                            delete pgpbrOLT;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrORB)
                            delete pgpbrORB;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrILT)
                            delete pgpbrILT;  // Allocated by GDI+ (cannot use HDelete)
                    }
                }
                break;
            }

            // Cleanup
            if (pgpbr && fDelete)
                delete pgpbr;  // Allocated by GDI+ (cannot use HDelete)

            // New rectangle for painting background
            rcPaint = rcLessBD;
        }
    }
    else
    {
        // Skipping border render, reduce bounds, copy into provided rect, and continue
        if (HasBorder())
        {
            // Get non-zero border
            Value* pvBrdr = GetValue(BorderThicknessProp, PI_Specified, NULL);

            _ReduceBounds(&rcPaint, pvBrdr->GetRect());
            *prcSkipBorder = rcPaint;

            pvBrdr->Release();
        }
        else
        {
            // No border thickness
            *prcSkipBorder = rcPaint;
        }
    }

    // Draw background

    // All graphic types are used as fills except metafiles, they are drawn to fit
    // Icons are not supported in backgrounds
    // TODO: Convert value-based fill logic into a helper function
    pgpbr = NULL;
    fDelete = true;
    BYTE dAlpha = 255;  // Opaque
    const Fill* pfGradient = NULL;

    pv = GetValue(BackgroundProp, PI_Specified); 

    switch (pv->GetType())
    {
    case DUIV_INT:
        GetGpBrush(pv->GetInt(), bAlphaLevel, &pgpbr, &fDelete);
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value
        {
            const Fill* pf = pv->GetFill();
            if (pf->dType == FILLTYPE_Solid)
            {
                dAlpha = GetAValue(pf->ref.cr);
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
                {
                    Gdiplus::Color cr(dAlpha, GetRValue(pf->ref.cr),
                            GetGValue(pf->ref.cr), GetBValue(pf->ref.cr));
                    pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(cr, bAlphaLevel));
                }
            }
            else  // Gradient
            {
                pfGradient = pv->GetFill();
                fDelete = false;
            }
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills unsupported
        {
            Graphic* pg = pv->GetGraphic();

            switch (pg->BlendMode.dImgType)
            {
            case GRAPHICTYPE_Bitmap:
                if (pg->BlendMode.dMode == GRAPHIC_AlphaConst)
                    dAlpha = pg->BlendMode.dAlpha;
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
#if 0                
                    hb = CreatePatternBrush(GethBitmap(pv, IsRTL()));
#else
                {
                    // TODO: Support texture brushes
                    // Need to support loading Gdiplus::Bitmap.
                }
#endif
                break;

            case GRAPHICTYPE_EnhMetaFile:
                // Render immediately, no brush is created
#if 0
                PlayEnhMetaFile(hDC, GethEnhMetaFile(pv, IsRTL()), &rcPaint);
#else
                // TODO: Support rendering metafiles
#endif
                dAlpha = 0;  // Bypass fill
                break;

            case GRAPHICTYPE_GpBitmap:
                switch (pg->BlendMode.dMode)
                {
                case GRAPHIC_NineGrid:
                case GRAPHIC_NineGridTransColor:
                    {
                        NGINFOGP ng;
                        ng.pgpgr = pgpgr;
                        ng.eImageSizing = ST_STRETCH;
                        ng.dwOptions = DNG_ALPHABLEND;
                        ng.pgpbmp = GetGpBitmap(pv, IsRTL());
                        ng.rcDest = *prcBounds;
                        ng.rcSrc = Gdiplus::RectF(0, 0, pg->cx, pg->cy);
                        ng.rcMargins = rcBorder;
                        ng.bAlphaLevel = bAlphaLevel;
                        CheapDrawNineGrid(&ng);
                    }
                    break;

                case GRAPHIC_Stretch:
                    {
                        Gdiplus::Bitmap * pgpbmp = GetGpBitmap(pv, IsRTL());
                        pgpgr->DrawImage(AlphaBitmap(pgpbmp, bAlphaLevel), rcPaint);
                    }
                    break;

                case GRAPHIC_AlphaConst:
                    break;

                default:
                    // Create a patterned brush
                    pgpbr = new Gdiplus::TextureBrush(AlphaBitmap(GetGpBitmap(pv, IsRTL()), bAlphaLevel));
                    fDelete = true;
                }
                break;
            }
        }
        break;
    }

    // Fill
    if (!pfGradient)
    {
        if (dAlpha)  // No fill if 0 opacity
        {
            //
            // Not every background mode will build a brush (such as 
            // GRAPHIC_Stretch).  We need to detect this.
            //

            if (pgpbr != NULL) {
                // Use intersection of invalid rect with background fill area
                // (stored in rcPaint) as new fill area
                Gdiplus::RectF rcFill;
                Gdiplus::RectF::Intersect(rcFill, *prcInvalid, rcPaint);
                pgpgr->FillRectangle(pgpbr, rcFill);
            }
        }
    }
    else if ((pfGradient->dType == FILLTYPE_HGradient) || (pfGradient->dType == FILLTYPE_VGradient))
    {
        Gdiplus::RectF lineRect(rcPaint);
        Gdiplus::Color cr1(Convert(pfGradient->ref.cr));
        Gdiplus::Color cr2(Convert(pfGradient->ref.cr2));

        Gdiplus::LinearGradientMode gplgm;
        switch (pfGradient->dType)
        {
        case FILLTYPE_HGradient:
            gplgm = Gdiplus::LinearGradientModeHorizontal;
            break;

        case FILLTYPE_VGradient:
            gplgm = Gdiplus::LinearGradientModeVertical;
            break;

        default:
            DUIAssertForce("Unknown gradient type");
            gplgm = Gdiplus::LinearGradientModeHorizontal;
        }

        Gdiplus::LinearGradientBrush gpbr(lineRect, AdjustAlpha(cr1, bAlphaLevel), AdjustAlpha(cr2, bAlphaLevel), gplgm);
        pgpgr->FillRectangle(&gpbr, rcPaint);
    } 
    else if ((pfGradient->dType == FILLTYPE_TriHGradient) || (pfGradient->dType == FILLTYPE_TriVGradient))
    {
        Gdiplus::RectF lineRect1, lineRect2;
        Gdiplus::Color cr1(Convert(pfGradient->ref.cr));
        Gdiplus::Color cr2(Convert(pfGradient->ref.cr2));
        Gdiplus::Color cr3(Convert(pfGradient->ref.cr3));

        float flHalfWidth = rcPaint.Width / 2 + 0.5f;
        float flHalfHeight = rcPaint.Height / 2 + 0.5f;

        Gdiplus::LinearGradientMode gplgm;
        switch (pfGradient->dType)
        {
        case FILLTYPE_TriHGradient:
            gplgm = Gdiplus::LinearGradientModeHorizontal;
            
            lineRect1.X         = rcPaint.X;
            lineRect1.Y         = rcPaint.Y;
            lineRect1.Width     = flHalfWidth;
            lineRect1.Height    = rcPaint.Height;
            lineRect2.X         = lineRect1.X + flHalfWidth;
            lineRect2.Y         = lineRect1.Y;
            lineRect2.Width     = rcPaint.Width - flHalfWidth;
            lineRect2.Height    = lineRect1.Height;
            break;

        case FILLTYPE_TriVGradient:
            gplgm = Gdiplus::LinearGradientModeVertical;

            lineRect1.X         = rcPaint.X;
            lineRect1.Y         = rcPaint.Y;
            lineRect1.Width     = rcPaint.Width;
            lineRect1.Height    = flHalfHeight;
            lineRect2.X         = lineRect1.X;
            lineRect2.Y         = lineRect1.Y + flHalfHeight;
            lineRect2.Width     = lineRect1.Width;
            lineRect2.Height    = rcPaint.Height - flHalfHeight;
            break;

        default:
            DUIAssertForce("Unknown gradient type");
            gplgm = Gdiplus::LinearGradientModeHorizontal;
        }

        Gdiplus::LinearGradientBrush gpbr1(lineRect1, AdjustAlpha(cr1, bAlphaLevel), AdjustAlpha(cr2, bAlphaLevel), gplgm);
        Gdiplus::LinearGradientBrush gpbr2(lineRect2, AdjustAlpha(cr2, bAlphaLevel), AdjustAlpha(cr3, bAlphaLevel), gplgm);
        pgpgr->FillRectangle(&gpbr1, lineRect1);
        pgpgr->FillRectangle(&gpbr2, lineRect2);
    } 

    if (fDelete && (pgpbr != NULL))
        delete pgpbr;  // Allocated by GDI+ (cannot use HDelete)

    pv->Release();

    // Reduce by padding
    if (HasPadding())
    {
        // Get non-zero padding
        Value* pvPad = GetValue(PaddingProp, PI_Specified, NULL);
        RECT rcPadding;
        MapRect(this, pvPad->GetRect(), &rcPadding);

        _ReduceBounds(&rcPaint, &rcPadding);

        // Done with value
        pvPad->Release();
    }

    // Skip content drawing if requested
    if (!prcSkipContent)
    {
        // Draw content (if exists)

        // Foreground is only used during text content rendering (graphics are ignored)
        if (HasContent())
        {
            Value* pvContent = GetValue(ContentProp, PI_Specified);
            if (pvContent->GetType() == DUIV_STRING)
            {
                LPWSTR pszContent = pvContent->GetString(); 
                WCHAR wcShortcut = (WCHAR) GetShortcut();
                BOOL fUnderline = FALSE;
                if (wcShortcut)
                {
                    LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                    BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                    pszContent = pszNew;
                }


                Value* pvFFace;
                BOOL fShadow = GetFontStyle() & FS_Shadow;

                // TEMPORARY: Properly determine the font
                Gdiplus::Font gpfnt(GetFontFace(&pvFFace), GetGpFontHeight(this), GetGpFontStyle(this), Gdiplus::UnitPoint);
                pvFFace->Release();

                Gdiplus::Color crText;

                // Set foreground (graphic is unsupported)
                Value* pvFore = GetValue(ForegroundProp, PI_Specified); 
                switch (pvFore->GetType())
                {
                case DUIV_INT:
                    // Auto-map if using palettes (PALETTERGB)
                    crText = ColorFromEnumF(pvFore->GetInt());
                    break;

                case DUIV_FILL:
                    // Auto-map if using palettes (PALETTERGB)
                    crText = Convert(pvFore->GetFill()->ref.cr);
                    break;

                default:
                    crText = Gdiplus::Color(0, 0, 0);
                }
                pvFore->Release();

                Gdiplus::SolidBrush gpbr(AdjustAlpha(crText, bAlphaLevel));
                int cch = (int) wcslen(pszContent);

                // Output text
                Gdiplus::StringFormat gpsf(0);
                Gdiplus::StringFormat * pgpsf = NULL;
                if (!IsDefaultCAlign())
                {
                    pgpsf = &gpsf;
                    _SetupStringFormat(pgpsf, this);
                }
                
                if (fShadow)
                {
                    Gdiplus::RectF rcShadow = rcPaint;
                    rcShadow.Offset(2, 2);
                    Gdiplus::SolidBrush gpbrShadow(AdjustAlpha(Gdiplus::Color(60, 0, 0, 0), bAlphaLevel));
                    pgpgr->DrawString(pszContent, cch, &gpfnt, rcShadow, pgpsf, &gpbrShadow);
                }
                pgpgr->DrawString(pszContent, cch, &gpfnt, rcPaint, pgpsf, &gpbr);
            }
            else  // DUIV_GRAPHIC
            {
                Graphic* pgContent = pvContent->GetGraphic();

                // TODO: Stretching

                // Clipped image size
                int dImgWidth = _MaxClip((int) rcPaint.Width, pgContent->cx);
                int dImgHeight = _MaxClip((int) rcPaint.Height, pgContent->cy);

                // Compute alignment
                int dCAlign = MapAlign(this, GetContentAlign());

                switch (dCAlign & 0x3)  // Lower 2 bits
                {
                case 0x0:   // Left
                    break;

                case 0x1:   // Center
                    rcPaint.X += (rcPaint.Width - dImgWidth) / 2;
                    break;

                case 0x2:   // Right
                    rcPaint.X = (rcPaint.X + rcPaint.Width) - dImgWidth;
                    break;
                }

                switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                {
                case 0x0:  // Top
                    break;

                case 0x1:  // Middle
                    rcPaint.Y += (rcPaint.Height - dImgHeight) / 2;
                    break;

                case 0x2:  // Bottom
                    rcPaint.Y = (rcPaint.Y + rcPaint.Height) - dImgHeight;
                    break;

                case 0x3:  // Wrap
                    break;
                }

                switch (pgContent->BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    // TODO: Rendering HBITMAP's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_Icon:
                    // TODO: Rendering HICONS's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    // TODO: Rendering HEMF's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_GpBitmap:
                    switch (pgContent->BlendMode.dMode)
                    {
                    case GRAPHIC_NoBlend:
                        pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel),
                                rcPaint.X, rcPaint.Y, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel);
                        break;

                    case GRAPHIC_AlphaConst:
                        // TODO: Alpha-blend the image, per-pixel alpha not yet impl
                        pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel),
                                rcPaint.X, rcPaint.Y, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel);
                        break;

                    case GRAPHIC_TransColor:
                        {
                            Gdiplus::ImageAttributes gpia;
                            Gdiplus::Color cl(pgContent->BlendMode.rgbTrans.r, pgContent->BlendMode.rgbTrans.g, pgContent->BlendMode.rgbTrans.b);
                            Gdiplus::RectF rc(rcPaint.X, rcPaint.Y, (float) dImgWidth, (float) dImgHeight);

                            gpia.SetColorKey(cl, cl);
                            pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel), 
                                    rc, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel, &gpia);
                        }
                        break;
                    }

                    break;
                }
            }

            pvContent->Release();
        }
    }
    else
    {
        *prcSkipContent = rcPaint;
    }

CleanUp:
    ;
}

#endif // GADGET_ENABLE_GDIPLUS

SIZE Element::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    SIZE sizeDS;
    ZeroMemory(&sizeDS, sizeof(SIZE));

    // Get content extent, if exists
    if (HasContent())
    {
        Value* pvContent = GetValue(ContentProp, PI_Specified);
        switch (pvContent->GetType())
        {
        case DUIV_STRING:
            {
                LPWSTR pszContent = pvContent->GetString(); 
                WCHAR wcShortcut = (WCHAR) GetShortcut();
                BOOL fUnderline = FALSE;
                if (wcShortcut)
                {
                    LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                    fUnderline = TRUE;
                    BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                    pszContent = pszNew;
                }


                Value* pvFFace;

                switch (psrf->GetType())
                {
                case Surface::stDC:
                    {
                        HDC hDC = CastHDC(psrf);
                        HFONT hFont = NULL;
                        HFONT hOldFont = NULL;
                        FontCache* pfc = GetFontCache();

                        int dFontSize = GetFontSize();

                        if (pfc)
                        {
                            hFont = pfc->CheckOutFont(GetFontFace(&pvFFace), 
                                                      dFontSize, 
                                                      GetFontWeight(), 
                                                      GetFontStyle(),
                                                      0);
                            pvFFace->Release();
                        }

                        if (hFont)
                            hOldFont = (HFONT)SelectObject(hDC, hFont);

                        // Get size
                        dFontSize = abs(dFontSize);  // Need magnitude

                        // Overhang correction
                        int dOverhang = (dFontSize / 6) + (dFontSize / 6);  // Make sure rounding is correct for render
                        
                        // Can use faster method as long as we aren't word wrapping or underlining
                        // Alignment and ellipsis ignored (are not relevant to dimension calculations)
                        if (!IsWordWrap() && !fUnderline)
                        {
                            GetTextExtentPoint32W(hDC, pszContent, (int)wcslen(pszContent), &sizeDS);
                        }
                        else
                        {
                            // Adjust for overhang correction
                            RECT rcDS = { 0, 0, dConstW - dOverhang, dConstH };

                            // DrawText returns infinite height if the width is 0 -- make width 1 so that we don't get infinite height
                            if (rcDS.right <= 0)
                                rcDS.right = 1;

                            UINT dFlags = DT_CALCRECT;
                            dFlags |= (fUnderline) ? 0 : DT_NOPREFIX;
                            dFlags |= (IsWordWrap()) ? DT_WORDBREAK : 0;

                            DrawTextW(hDC, pszContent, -1, &rcDS, dFlags);
                            sizeDS.cx = rcDS.right;
                            sizeDS.cy = rcDS.bottom;
                        }

                        // Add on additional width to all text (1/6 font height per size) to compensate
                        // for font overhang, when rendering, this additional space will not be used
                        sizeDS.cx += dOverhang;

                        //DUITrace("String DS (%S), WC:%d: %d,%d\n", pszContent, dConstW, sizeDS.cx, sizeDS.cy);
     
                        if (hOldFont)
                            SelectObject(hDC, hOldFont);
                        if (pfc)
                            pfc->CheckInFont();
                    }
                    break;

#ifdef GADGET_ENABLE_GDIPLUS
                case Surface::stGdiPlus:
                    {
                        Gdiplus::Graphics* pgpgr = CastGraphics(psrf);
                        Gdiplus::Font gpfnt(GetFontFace(&pvFFace), GetGpFontHeight(this), GetGpFontStyle(this), Gdiplus::UnitPoint);
                        pvFFace->Release();

                        int cch = (int)wcslen(pszContent);
                        Gdiplus::StringFormat gpsf(0);
                        _SetupStringFormat(&gpsf, this);

                        if (!IsWordWrap())
                        {
                            Gdiplus::PointF pt;
                            Gdiplus::RectF rcBounds;

                            pgpgr->MeasureString(pszContent, cch, &gpfnt, pt, &gpsf, &rcBounds);
                            sizeDS.cx = ((long)rcBounds.Width) + 1;
                            sizeDS.cy = ((long)rcBounds.Height) + 1;
                        }
                        else 
                        {
                            Gdiplus::SizeF sizeTemp((float)dConstW, (float)dConstH);
                            Gdiplus::SizeF sizeBounds;

                            // DrawText returns infinite height if the width is 0 -- make width 1 so that we don't get infinite height
                            if (dConstW == 0)
                                sizeTemp.Width = 1.0f;

                            pgpgr->MeasureString(pszContent, cch, &gpfnt, sizeTemp, &gpsf, &sizeBounds);
                            sizeDS.cx = ((long)sizeBounds.Width) + 1;
                            sizeDS.cy = ((long)sizeBounds.Height) + 1;
                        }
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS

                default:
                    DUIAssertForce("Unknown surface type");
                }
            }
            break;

        case DUIV_GRAPHIC:
            {
                Graphic* pgContent = pvContent->GetGraphic();
                sizeDS.cx = pgContent->cx;
                sizeDS.cy = pgContent->cy;
            }
            break;

        case DUIV_FILL:
            {
                if (psrf->GetType() == Surface::stDC)
                {
                    // Theme-based fills have a desired size
                    const Fill* pf = pvContent->GetFill();
                    if (pf->dType == FILLTYPE_DrawThemeBackground)
                    {
                        GetThemePartSize(pf->fillDTB.hTheme, CastHDC(psrf), pf->fillDTB.iPartId, pf->fillDTB.iStateId, NULL, TS_TRUE, &sizeDS);
                    }
                }
            }
            break;
        }
        
        pvContent->Release();
    }

    if (sizeDS.cx > dConstW)
        sizeDS.cx = dConstW;

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

float Element::GetTreeAlphaLevel()
{
    float flAlpha = 1.0f;
    
    Element * peCur = this;
    while (peCur != NULL)
    {
        float flCur = (peCur->GetAlpha() / 255.0f);
        flAlpha = flAlpha * flCur;
        peCur = peCur->GetParent();
    }

    return flAlpha;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\thread.cpp ===
/*
 * Thread methods, local storage
 */

#include "stdafx.h"
#include "core.h"

#include "duithread.h"

#include "duielement.h"
#include "duihost.h"

namespace DirectUI
{

#if DBG
// Value small block leak detector
class LeakDetect : public ISBLeak
{
    void AllocLeak(void* pBlock)
    {
        Value* pv = (Value*)pBlock;
        WCHAR sz[2048];
        DUITrace(">> DUIValue Leak! Type: %d, Value: %S, Refs: %d\n", pv->GetType(), pv->ToString(sz, sizeof(sz) / sizeof(WCHAR)), pv->GetRefCount());
    };
};
LeakDetect* g_pldValue = NULL;
#endif

////////////////////////////////////////////////////////
// Initialization and cleanup

BOOL g_fStandardMessaging = FALSE;

inline BOOL IsWhistler()
{
    OSVERSIONINFO ovi;
    ZeroMemory(&ovi, sizeof(ovi));
    ovi.dwOSVersionInfoSize = sizeof(ovi);

    DUIVerify(GetVersionEx(&ovi), "Must always be able to get the version");
    return (ovi.dwMajorVersion >= 5) && (ovi.dwMinorVersion >= 1);
}

// Global locks
// Global parser lock (for yyparse, can only parse 1 Parser context at a time)
Lock* g_plkParser = NULL;

// Application startup/shutdown code (run once)
// This and class registration must be synchronized on a single thread

UINT g_cInitProcessRef = 0;

void ClassMapCleanupCB(void* pKey, IClassInfo* pci)
{
    UNREFERENCED_PARAMETER(pKey);

    //DUITrace("FreeDUIClass: '%S'\n", pci->GetName());
    pci->Destroy();
}

HRESULT InitProcess()
{
    HRESULT hr;

    if (g_cInitProcessRef > 0)
    {
        g_cInitProcessRef++;
        return S_OK;
    }

    // If running on Whistler, use DirectUser's "Standard" messaging mode.
    g_fStandardMessaging = IsWhistler();
    g_iGlobalCI = 1;
    g_iGlobalPI = _PIDX_TOTAL;

    // DirectUI process heap
    g_hHeap = HeapCreate(0, 256 * 1024, 0);
    if (!g_hHeap)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // Thread slot
    g_dwElSlot = TlsAlloc();
    if (g_dwElSlot == -1)
    {
        hr = DU_E_OUTOFKERNELRESOURCES;
        goto Failure;
    }

    // ClassInfo mapping list
    hr = BTreeLookup<IClassInfo*>::Create(true, &Element::pciMap);  // Key is string
    if (FAILED(hr))
        goto Failure;

    // Controls registration
    hr = RegisterAllControls();
    if (FAILED(hr))
        goto Failure;

    // Locks
    g_plkParser = HNew<Lock>();
    if (!g_plkParser)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

#if DBG
    // Leak detection
    g_pldValue = HNew<LeakDetect>();
    if (!g_pldValue)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }
#endif

    g_cInitProcessRef = 1;

    //DUITrace("DUI: Process startup <%x>\n", GetCurrentProcessId());

    return S_OK;

Failure:

#if DBG
    if (g_pldValue)
    {
        HDelete<LeakDetect>(g_pldValue);
        g_pldValue = NULL;
    }
#endif

    if (g_plkParser)
    {
        HDelete<Lock>(g_plkParser);
        g_plkParser = NULL;
    }

    if (Element::pciMap)
    {
        Element::pciMap->Enum(ClassMapCleanupCB);
    
        Element::pciMap->Destroy();
        Element::pciMap = NULL;
    }

    if (g_dwElSlot != -1)
    {
        TlsFree(g_dwElSlot);
        g_dwElSlot = (DWORD)-1;
    }

    if (g_hHeap)
    {
        HeapDestroy(g_hHeap);
        g_hHeap = NULL;
    }

    return hr;
}

HRESULT UnInitProcess()
{
    if (g_cInitProcessRef == 0)
    {
        DUIAssertForce("Mismatched InitProcess/UnInitProcess");
        return E_FAIL;
    }

    if (g_cInitProcessRef > 1)
    {
        g_cInitProcessRef--;
        return S_OK;
    }

#if DBG
    HDelete<LeakDetect>(g_pldValue);
    g_pldValue = NULL;
#endif

    HDelete<Lock>(g_plkParser);
    g_plkParser = NULL;

    // Run through all registered IClassInfo's and destroy
    Element::pciMap->Enum(ClassMapCleanupCB);

    Element::pciMap->Destroy();
    Element::pciMap = NULL;

    TlsFree(g_dwElSlot);
    g_dwElSlot = (DWORD)-1;

    HeapDestroy(g_hHeap);
    g_hHeap = NULL;

    g_cInitProcessRef = 0;

    //DUITrace("DUI: Process shutdown <%x>\n", GetCurrentProcessId());

    return S_OK;
}

#ifdef GADGET_ENABLE_GDIPLUS
long g_fInitGdiplus = FALSE;
#endif

// DirectUI Element data structures are setup per-context, however, context
// affinity cannot be enforced. A new context is created per thread
// initialization. The application must ensure that only a single thread
// is allowed to access Elements in it's context.
HRESULT InitThread()
{
    HRESULT hr;
    ElTls* pet = NULL;

    // Check if process initialized correctly
    if (g_dwElSlot == -1)
    {
        hr = E_FAIL;
        goto Failure;
    }

    // Check if this is a reentrant init
    pet = (ElTls*)TlsGetValue(g_dwElSlot);
    if (pet)
    {
        pet->cRef++;
        return S_OK;
    }

    // Allocate a new context per thread
    pet = (ElTls*)HAllocAndZero(sizeof(ElTls));
    if (!pet)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    TlsSetValue(g_dwElSlot, pet);

    // Small block allocator
#if DBG
    hr = SBAlloc::Create(sizeof(Value), 48, (ISBLeak*)g_pldValue, &pet->psba);
#else
    hr = SBAlloc::Create(sizeof(Value), 48, NULL, &pet->psba);
#endif
    if (FAILED(hr))
        goto Failure;

    // Defer cycle table
    hr = DeferCycle::Create(&pet->pdc);
    if (FAILED(hr))
        goto Failure;

    // Font cache
    hr = FontCache::Create(8, &pet->pfc);
    if (FAILED(hr))
        goto Failure;

    pet->cRef = 1;
    pet->fCoInitialized = false;  // Initially, the thread has not been initialized for COM
    pet->dEnableAnimations = 0;   // Enable animations by default (0 means active)

    // Initialize DirectUser context
    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize = sizeof(ig);
    ig.nThreadMode = IGTM_SEPARATE;
    ig.nMsgMode = g_fStandardMessaging ? IGMM_STANDARD : IGMM_ADVANCED;
    ig.nPerfMode = IGPM_BLEND;

    pet->hCtx = InitGadgets(&ig);
    if (!pet->hCtx)
    {
        hr = GetLastError();
        goto Failure;
    }

    // DirectUser optional components
#ifdef GADGET_ENABLE_GDIPLUS
    if (InterlockedExchange(&g_fInitGdiplus, TRUE) == FALSE) {
        if (!InitGadgetComponent(IGC_GDIPLUS)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Failure;
        }
    }
#endif // GADGET_ENABLE_GDIPLUS


    //DUITrace("DUI: Thread startup <%x|%x:%x>\n", GetCurrentThreadId(), pet->hCtx, g_dwElSlot);  

    return S_OK;

Failure:
    // Failure to fully init thread, back out

    // Destroy per context objects
    if (pet)
    {
        if (pet->pfc)
            pet->pfc->Destroy();
        if (pet->pdc)
            pet->pdc->Destroy();
        if (pet->hCtx)
            DeleteHandle(pet->hCtx);

        HFree(pet);

        TlsSetValue(g_dwElSlot, NULL);
    }

    return hr;
}

HRESULT UnInitThread()
{
    // Check if process initialized correctly
    if (g_dwElSlot == -1)
        return E_FAIL;

    ElTls* pet = (ElTls*)TlsGetValue(g_dwElSlot);

    // Check if this thread has been previously initialized
    if (pet == NULL)
        return DU_E_GENERIC;

    // Check for reentrant uninits
    pet->cRef--;

    if (pet->cRef > 0)
        return S_OK;

    //DUITrace("DUI: Thread shutdown <%x|%x:%x>\n", GetCurrentThreadId(), pet->hCtx, g_dwElSlot);

    // DirectUser context
    DeleteHandle(pet->hCtx);

    // Uninitialize COM if it was previously initialized for this thread
    // (was not automatically initialized on init of thread)
    if (pet->fCoInitialized)
        CoUninitialize();

    // Font cache
    pet->pfc->Destroy();

    // Defer cycle
    pet->pdc->Destroy();

    // Small block allocator
    pet->psba->Destroy();

    HFree(pet);

    TlsSetValue(g_dwElSlot, NULL);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Message pump

void StartMessagePump()
{
    MSG msg;

    // Flush working set
    SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1);

    if (g_fStandardMessaging) 
    {
        while (GetMessageW(&msg, 0, 0, 0) != 0)
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
    else
    {
        while (GetMessageExW(&msg, 0, 0, 0) != 0)
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
}

void StopMessagePump()
{
    PostQuitMessage(0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\core\value.cpp ===
/*
 * Value
 */

#include "stdafx.h"
#include "core.h"

#include "duivalue.h"

#include "duielement.h"
#include "duisheet.h"
#include "duilayout.h"
#include "duiexpression.h"

namespace DirectUI
{

BOOL FlipIcon(HICON hIcon, HICON *phAltIcon);
BOOL FlipBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy);

////////////////////////////////////////////////////////
// Value (immutable with reference count)

Value* Value::CreateInt(int dValue)
{

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_INT;
        pv->_intVal = dValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateBool(bool bValue)
{
    // No need for AddRef of global static objects
    return (bValue) ? Value::pvBoolTrue : Value::pvBoolFalse;
}

Value* Value::CreateElementRef(Element* peValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ELEMENTREF;
        pv->_peVal = peValue;
        pv->_cRef = 1;
    }

    return pv;
}

// Pointer stored, will be deleted on value destruction, made immutable on create
Value* Value::CreateElementList(ElementList* peListValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ELLIST;
        if (peListValue)
            peListValue->MakeImmutable();  // Cannot modify
        pv->_peListVal = peListValue;      // List stored directly
        pv->_cRef = 1;
    }

    return pv;
}

// String is duplicated and freed on value destruction
Value* Value::CreateString(LPCWSTR pszValue, HINSTANCE hResLoad)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_STRING;

        // Assume string to use is one passed in
        LPCWSTR psz = pszValue;

        // If an instance handle in provided, assume loading from resource
        WCHAR szRes[256];
        if (hResLoad)
        {
            ZeroMemory(&szRes, sizeof(szRes));

#if DBG
            int cRead = 0;
            cRead = LoadStringW(hResLoad, (WORD)pszValue, szRes, DUIARRAYSIZE(szRes));
            DUIAssert(cRead, "Could not locate string resource");
#else
            LoadStringW(hResLoad, (WORD)pszValue, szRes, DUIARRAYSIZE(szRes));
#endif
            // Map to resource string
            psz = szRes;
        }

        // Duplicate string and store
        if (psz)
        {
            pv->_pszVal = (LPWSTR)HAlloc((wcslen(psz) + (SIZE_T)1) * sizeof(WCHAR));
            if (pv->_pszVal)
                wcscpy(pv->_pszVal, psz);  // String duplicated and stored
        }
        else
            pv->_pszVal = NULL;

        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreatePoint(int x, int y)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_POINT;
        pv->_ptVal.x = x;
        pv->_ptVal.y = y;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateSize(int cx, int cy)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_SIZE;
        pv->_sizeVal.cx = cx;
        pv->_sizeVal.cy = cy;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateRect(int left, int top, int right, int bottom)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_RECT;
        SetRect(&pv->_rectVal, left, top, right, bottom);
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_Solid;
        pv->_fillVal.ref.cr = cr;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr0, COLORREF cr1, BYTE dType)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = dType;
        pv->_fillVal.ref.cr = cr0;
        pv->_fillVal.ref.cr2 = cr1;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr0, COLORREF cr1, COLORREF cr2, BYTE dType)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = dType;
        pv->_fillVal.ref.cr = cr0;
        pv->_fillVal.ref.cr2 = cr1;
        pv->_fillVal.ref.cr3 = cr2;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateDFCFill(UINT uType, UINT uState)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_DrawFrameControl;
        pv->_fillVal.fillDFC.uType = uType;
        pv->_fillVal.fillDFC.uState = uState;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateDTBFill(HTHEME hTheme, int iPartId, int iStateId)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_DrawThemeBackground;
        pv->_fillVal.fillDTB.hTheme = hTheme;
        pv->_fillVal.fillDTB.iPartId = iPartId;
        pv->_fillVal.fillDTB.iStateId = iStateId;
        pv->_cRef = 1;
    }

    return pv;
}
    
Value* Value::CreateFill(const Fill & clrSrc)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal = clrSrc;
        pv->_cRef = 1;
    }

    return pv;
}


// Pointer stored, will be deleted on value destruction
Value* Value::CreateLayout(Layout* plValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_LAYOUT;
        pv->_plVal = plValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateGraphic(HBITMAP hBitmap, BYTE dBlendMode, UINT dBlendValue, bool bFlip, bool bRTL)
{
    DUIAssert(hBitmap, "Invalid bitmap: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    if (dBlendMode == GRAPHIC_AlphaConstPerPix || dBlendMode == GRAPHIC_NineGridAlphaConstPerPix)
    {
        // Attempt to pre-multiply bitmap if it's a 32-bpp image with a non-zero alpha channel overall.
        // A new bitmap is created on success.
        HBITMAP hAlphaBMP = ProcessAlphaBitmapI(hBitmap);

        // Destroy original bitmap, new process bitmap is in hAlphaBMP
        DeleteObject(hBitmap);

        // Successful processing of a 32bpp alpha image results in a non-NULL hAlphaBMP, this is
        // the bitmap to be used. It's a DIB.
        hBitmap = hAlphaBMP;

        DUIAssert(hBitmap, "Unable to process alpha bitmap");
    }

    if (!hBitmap)
    {
        return NULL;
    }

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hBitmap;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_Bitmap;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_graphicVal.hAltImage = NULL;

        if (pv->_graphicVal.hImage)
        {
            BITMAP bm;
            GetObjectW(pv->_graphicVal.hImage, sizeof(BITMAP), &bm);
            pv->_graphicVal.cx = (USHORT)bm.bmWidth;
            pv->_graphicVal.cy = (USHORT)bm.bmHeight;
        }

        pv->_graphicVal.BlendMode.dMode = dBlendMode;

        switch (dBlendMode)
        {
        case GRAPHIC_NoBlend:
            pv->_graphicVal.BlendMode.dAlpha = 0;       // Unused
            break;

        case GRAPHIC_AlphaConst:
        case GRAPHIC_AlphaConstPerPix:
        case GRAPHIC_NineGridAlphaConstPerPix:
            pv->_graphicVal.BlendMode.dAlpha = (BYTE)dBlendValue;
            break;

        case GRAPHIC_TransColor:
            if (dBlendValue == (UINT)-1 && pv->_graphicVal.hImage)
            {
                // Automatically choose transparent color
                HDC hMemDC = CreateCompatibleDC(NULL);
                if (hMemDC)
                {
                    HBITMAP hOldBm = (HBITMAP)SelectObject(hMemDC, pv->_graphicVal.hImage);
                    dBlendValue = GetPixel(hMemDC, 0, 0);
                    SelectObject(hMemDC, hOldBm);
                    DeleteDC(hMemDC);
                }
            }
            // Fall through

        case GRAPHIC_NineGridTransColor:
            pv->_graphicVal.BlendMode.rgbTrans.r = GetRValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.g = GetGValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.b = GetBValue(dBlendValue);
            break;
        }

        pv->_cRef = 1;
    }

    return pv;
}

#ifdef GADGET_ENABLE_GDIPLUS

Value* Value::CreateGraphic(Gdiplus::Bitmap * pgpbmp, BYTE dBlendMode, UINT dBlendValue, bool bFlip, bool bRTL)
{
    DUIAssert(pgpbmp, "Invalid bitmap: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = pgpbmp;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_GpBitmap;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_graphicVal.hAltImage = NULL;


        if (pv->_graphicVal.hImage)
        {
            pv->_graphicVal.cx = (USHORT)pgpbmp->GetWidth();
            pv->_graphicVal.cy = (USHORT)pgpbmp->GetHeight();
        }

        pv->_graphicVal.BlendMode.dMode = dBlendMode;

        switch (dBlendMode)
        {
        case GRAPHIC_NoBlend:
            pv->_graphicVal.BlendMode.dAlpha = 0;       // Unused
            break;

        case GRAPHIC_AlphaConst:
        case GRAPHIC_AlphaConstPerPix:
            pv->_graphicVal.BlendMode.dAlpha = (BYTE)dBlendValue;
            break;

        case GRAPHIC_TransColor:
            if (dBlendValue == (UINT)-1 && pv->_graphicVal.hImage)
            {
                // Automatically choose transparent color
                Gdiplus::Color cl;
                pgpbmp->GetPixel(0, 0, &cl);
                dBlendValue = cl.ToCOLORREF();
            }
            // Fall through
        case GRAPHIC_NineGridTransColor:
            pv->_graphicVal.BlendMode.rgbTrans.r = GetRValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.g = GetGValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.b = GetBValue(dBlendValue);
            break;
        }
        pv->_cRef = 1;
    }

    return pv;
}

#endif // GADGET_ENABLE_GDIPLUS

Value* Value::CreateGraphic(HICON hIcon, bool bFlip, bool bRTL)
{
    DUIAssert(hIcon, "Invalid icon: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

#ifdef GADGET_ENABLE_GDIPLUS

    Gdiplus::Bitmap * pgpbmp = Gdiplus::Bitmap::FromHICON(hIcon);
    if (pgpbmp == NULL) {
        DUIAssertForce("Unable to create GpBitmap from HICON");
        return NULL;
    }

#endif // GADGET_ENABLE_GDIPLUS

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
#ifdef GADGET_ENABLE_GDIPLUS

        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = pgpbmp;
        pv->_graphicVal.hAltImage = NULL;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_GpBitmap;
        pv->_graphicVal.cx = (USHORT)pgpbmp->GetWidth();
        pv->_graphicVal.cy = (USHORT)pgpbmp->GetHeight();

        DeleteObject(hIcon);

#else // GADGET_ENABLE_GDIPLUS

        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hIcon;
        pv->_graphicVal.hAltImage = NULL;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_Icon;

        if (pv->_graphicVal.hImage)
        {
            ICONINFO ii;
            GetIconInfo((HICON)pv->_graphicVal.hImage, &ii);

            BITMAP bm;
            GetObjectW(ii.hbmColor, sizeof(BITMAP), &bm);
            pv->_graphicVal.cx = (USHORT)bm.bmWidth;
            pv->_graphicVal.cy = (USHORT)bm.bmHeight;

            DeleteObject(ii.hbmMask);
            DeleteObject(ii.hbmColor);
        }

#endif // GADGET_ENABLE_GDIPLUS

        pv->_graphicVal.BlendMode.dMode = 0;
        pv->_graphicVal.BlendMode.dAlpha = 0;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_cRef = 1;
    }
#ifdef GADGET_ENABLE_GDIPLUS
    else
    {
        delete pgpbmp;  // Allocated by GDI+ (cannot use HDelete)
    }
#endif // GADGET_ENABLE_GDIPLUS

    return pv;
}

Value* Value::CreateGraphic(HENHMETAFILE hEnhMetaFile, HENHMETAFILE hAltEnhMetaFile)
{
    DUIAssert(hEnhMetaFile, "Invalid metafile: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hEnhMetaFile;
        pv->_graphicVal.hAltImage = hAltEnhMetaFile;
        pv->_graphicVal.BlendMode.bFlip = true;
        pv->_graphicVal.BlendMode.bRTLGraphic = false;

        if (pv->_graphicVal.hImage)
        {
            ENHMETAHEADER emh;
            GetEnhMetaFileHeader((HENHMETAFILE)pv->_graphicVal.hImage, sizeof(ENHMETAHEADER), &emh);

            pv->_graphicVal.cx = (USHORT)emh.rclBounds.right;
            pv->_graphicVal.cy = (USHORT)emh.rclBounds.bottom;
        }

        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_EnhMetaFile;
        pv->_graphicVal.BlendMode.dMode = 0;
        pv->_graphicVal.BlendMode.dAlpha = 0;
        pv->_graphicVal.BlendMode.bFreehImage = false;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateGraphic(LPCWSTR pszBMP, BYTE dBlendMode, UINT dBlendValue, USHORT cx, USHORT cy, HINSTANCE hResLoad, bool bFlip, bool bRTL)
{
    DUIAssert(pszBMP, "Invalid bitmap name: NULL");

#ifdef GADGET_ENABLE_GDIPLUS

    Gdiplus::Bitmap * pgpbmp;
    if (FAILED(LoadDDBitmap(pszBMP, hResLoad, cx, cy, PixelFormat32bppPARGB, &pgpbmp)))
    {
        DUITrace("WARNING: Unable to load bitmap: %S", pszBMP);
        return NULL;
    }

    Value* pv = CreateGraphic(pgpbmp, dBlendMode, dBlendValue, bFlip, bRTL);

    if (!pv)
        delete pgpbmp;  // Allocated by GDI+ (cannot use HDelete)

    return pv;

#else // GADGET_ENABLE_GDIPLUS

    // If an instance handle in provided, assume loading from resource

    HBITMAP hBitmap;

    // If loading a bitmap with the per pixel alpha mode, always load as a DIB
    if (dBlendMode == GRAPHIC_AlphaConstPerPix || dBlendMode == GRAPHIC_NineGridAlphaConstPerPix)
    {
        hBitmap = (HBITMAP)LoadImageW(hResLoad, pszBMP, IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION | (hResLoad ? 0 : LR_LOADFROMFILE));       
    }
    else
    {
        // All other types load as a converted device dependent bitmap
        hBitmap = LoadDDBitmap(pszBMP, hResLoad, cx, cy);
    }

    if (!hBitmap)
    {
        DUITrace("WARNING: Unable to load bitmap: %S", pszBMP);
        return NULL;
    }

    Value* pv = CreateGraphic(hBitmap, dBlendMode, dBlendValue, bFlip, bRTL);

    if (!pv)
        DeleteObject(hBitmap);

    return pv;

#endif
}

Value* Value::CreateGraphic(LPCWSTR pszICO, USHORT cxDesired, USHORT cyDesired, HINSTANCE hResLoad, bool bFlip, bool bRTL)
{
    DUIAssert(pszICO, "Invalid icon name: NULL");

    // If an instance handle in provided, assume loading from resource
    HICON hIcon = (HICON)LoadImageW(hResLoad, pszICO, IMAGE_ICON, cxDesired, cyDesired, hResLoad ? 0 : LR_LOADFROMFILE);
    if (!hIcon)
    {
        DUIAssert(hIcon, "Unable to load icon");
        return NULL;
    }

    Value* pv = CreateGraphic(hIcon, bFlip, bRTL);

    if (!pv)
        DestroyIcon(hIcon);

    return pv;
}

// Pointer stored, will be deleted on value destruction
Value* Value::CreatePropertySheet(PropertySheet* ppsValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_SHEET;
        if (ppsValue)
            ppsValue->MakeImmutable();
        pv->_ppsVal = ppsValue;
        pv->_cRef = 1;
    }

    return pv;
}

// Pointer stored, will be deleted on value destruction
Value* Value::CreateExpression(Expression* pexValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_EXPR;
        pv->_pexVal = pexValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateAtom(LPCWSTR pszValue)
{
    DUIAssert(pszValue, "Invalid string: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ATOM;
        pv->_atomVal = AddAtomW(pszValue);
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateCursor(HCURSOR hValue)
{
    DUIAssert(hValue, "Invalid cursor: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_CURSOR;
        pv->_cursorVal.hCursor = hValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateCursor(LPCWSTR pszValue)
{
    DUIAssert(pszValue, "Invalid cursor: NULL");

    return CreateCursor(LoadCursorFromFileW(pszValue));
}

// AddRef/Release are inline, extra 0th release logic isn't
void Value::_ZeroRelease()
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return;
#endif

    // Destroy this and any additional memory
    switch (_dType)
    {
    case DUIV_ELLIST:
        if (_peListVal)
            _peListVal->Destroy();
        break;

    case DUIV_STRING:
        if (_pszVal)
            HFree(_pszVal);
        break;

    case DUIV_LAYOUT:
        if (_plVal)
            _plVal->Destroy();
        break;

    case DUIV_GRAPHIC:
        switch (_graphicVal.BlendMode.dImgType)
        {
        case GRAPHICTYPE_Bitmap:
            if (_graphicVal.hImage)
                DeleteObject(_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DeleteObject(_graphicVal.hAltImage);
            break;
        
        case GRAPHICTYPE_Icon:
            if (_graphicVal.hImage)
                DestroyIcon((HICON)_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DestroyIcon((HICON)_graphicVal.hAltImage);
            break;

        case GRAPHICTYPE_EnhMetaFile:
            if (_graphicVal.hImage)
                DeleteEnhMetaFile((HENHMETAFILE)_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DeleteEnhMetaFile((HENHMETAFILE)_graphicVal.hAltImage);
            break;

#ifdef GADGET_ENABLE_GDIPLUS
        case GRAPHICTYPE_GpBitmap:
            if (_graphicVal.hImage)
                delete (Gdiplus::Bitmap *)_graphicVal.hImage;  // Allocated by GDI+ (cannot use HDelete)
            if (_graphicVal.hAltImage)
                delete (Gdiplus::Bitmap *)_graphicVal.hAltImage;  // Allocated by GDI+ (cannot use HDelete)
            break;
#endif // GADGET_ENABLE_GDIPLUS
        }

        break;

    case DUIV_SHEET:
        if (_ppsVal)
            _ppsVal->Destroy();
        break;

    case DUIV_EXPR:
        if (_pexVal)
            _pexVal->Destroy();
        break;

    case DUIV_ATOM:
        if (_atomVal)
            DUIVerify(DeleteAtom(_atomVal) == 0, "Atom value not found");
        break;
    }                

    psba->Free(this);
}

// Equality
bool Value::IsEqual(Value* pv)
{
    if (pv == this)
        return true;

    if (_dType == pv->_dType)
    {
        switch (_dType)
        {
        case DUIV_INT:
            return _intVal == pv->_intVal;
        case DUIV_BOOL:
            return _boolVal == pv->_boolVal;
        case DUIV_ELEMENTREF:
            return _peVal == pv->_peVal;
        case DUIV_ELLIST:
            if (_peListVal)
                return _peListVal->IsEqual(pv->_peListVal);
            else if (!pv->_peListVal)
                return true;
            break;
        case DUIV_STRING:
            if (_pszVal && pv->_pszVal)
                return wcscmp(_pszVal, pv->_pszVal) == 0;
            else if (!_pszVal && !pv->_pszVal)
                return true;
            break;
        case DUIV_POINT:
            return _ptVal.x == pv->_ptVal.x && _ptVal.y == pv->_ptVal.y;
        case DUIV_SIZE:
            return _sizeVal.cx == pv->_sizeVal.cx && _sizeVal.cy == pv->_sizeVal.cy;
        case DUIV_RECT:
            return EqualRect(&_rectVal, &pv->_rectVal) != 0;
        case DUIV_FILL:
            {
                bool fRes = true;  // Assume true
                
                if (_fillVal.dType == pv->_fillVal.dType)
                {
                    switch (_fillVal.dType)
                    {
                    case FILLTYPE_DrawFrameControl:
                        fRes = (_fillVal.fillDFC.uType == pv->_fillVal.fillDFC.uType) &&
                               (_fillVal.fillDFC.uState == pv->_fillVal.fillDFC.uState);
                        break;

                    case FILLTYPE_DrawThemeBackground:
                        fRes = (_fillVal.fillDTB.hTheme == pv->_fillVal.fillDTB.hTheme) &&
                               (_fillVal.fillDTB.iPartId == pv->_fillVal.fillDTB.iPartId) &&
                               (_fillVal.fillDTB.iStateId == pv->_fillVal.fillDTB.iStateId);
                        break;

                    case FILLTYPE_TriHGradient:
                    case FILLTYPE_TriVGradient:
                        // Check third color ref
                        fRes = _fillVal.ref.cr3 == pv->_fillVal.ref.cr3;
                        
                        // Fall through to check rest of structure

                    default:
                        if (fRes)
                        {
                            fRes = (_fillVal.ref.cr == pv->_fillVal.ref.cr) && 
                                   (_fillVal.ref.cr2 == pv->_fillVal.ref.cr2);
                        }
                        break;
                    }
                }
                else
                    fRes = false;

                return fRes;
            }
         case DUIV_LAYOUT:
            return _plVal == pv->_plVal;
        case DUIV_GRAPHIC:
            return (_graphicVal.hImage    == pv->_graphicVal.hImage) &&   // Same handle means equal
                   (_graphicVal.hAltImage == pv->_graphicVal.hAltImage);  // Same handle means equal
        case DUIV_SHEET:
            return _ppsVal == pv->_ppsVal;
        case DUIV_EXPR:
            return _pexVal == pv->_pexVal;
        case DUIV_ATOM:
            return _atomVal == pv->_atomVal;
        case DUIV_CURSOR:
            return _cursorVal.hCursor == pv->_cursorVal.hCursor;  // Same handles means equal

        default:  // All other types content match doesn't apply
            return true;
        }
    }

    return false;
}

// Conversion
LPWSTR Value::ToString(LPWSTR psz, UINT c)
{
    DUIAssert(psz && c, "Invalid parameters");

    switch (_dType)
    {
    case DUIV_UNAVAILABLE:
        wcsncpy(psz, L"Unavail", c);
        break;
    case DUIV_UNSET:
        wcsncpy(psz, L"Unset", c);
        break;
    case DUIV_NULL:
        wcsncpy(psz, L"Null", c);
        break;
    case DUIV_INT:
        _snwprintf(psz, c, L"%d", _intVal);
        break;
    case DUIV_BOOL:
        _snwprintf(psz, c, L"%s", (_boolVal) ? L"True" : L"False");
        break;
    case DUIV_ELEMENTREF:
        _snwprintf(psz, c, L"El<0x%p>", _peVal);
        break;
    case DUIV_ELLIST:
        _snwprintf(psz, c, L"ElList<%d>", (_peListVal) ? _peListVal->GetSize() : 0);
        break;
    case DUIV_STRING:
        if (_pszVal)
            _snwprintf(psz, c, L"'%s'", _pszVal);
        else
            wcsncpy(psz, L"'(null)'", c);
        break;
    case DUIV_POINT:
        _snwprintf(psz, c, L"Pt<%d,%d>", _ptVal.x, _ptVal.y);
        break;
    case DUIV_SIZE:
        _snwprintf(psz, c, L"Size<%d,%d>", _sizeVal.cx, _sizeVal.cy);
        break;
    case DUIV_RECT:
        _snwprintf(psz, c, L"Rect<%d,%d,%d,%d>", _rectVal.left, _rectVal.top, _rectVal.right, _rectVal.bottom);
        break;
    case DUIV_FILL:
        {
            switch (_fillVal.dType)
            {
            case FILLTYPE_Solid:
                _snwprintf(psz, c, L"ARGB<%d,%d,%d,%d>", GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr));
                break;

            case FILLTYPE_HGradient:
            case FILLTYPE_VGradient:
                _snwprintf(psz, c, L"ARGB0<%d,%d,%d,%d>,ARGB1<%d,%d,%d,%d>", 
                    GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr),
                    GetAValue(_fillVal.ref.cr2), GetRValue(_fillVal.ref.cr2), GetGValue(_fillVal.ref.cr2), GetBValue(_fillVal.ref.cr2));
                break;

            case FILLTYPE_TriHGradient:
            case FILLTYPE_TriVGradient:
                _snwprintf(psz, c, L"ARGB0<%d,%d,%d,%d>,ARGB1<%d,%d,%d,%d>,ARGB2<%d,%d,%d,%d>", 
                    GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr),
                    GetAValue(_fillVal.ref.cr2), GetRValue(_fillVal.ref.cr2), GetGValue(_fillVal.ref.cr2), GetBValue(_fillVal.ref.cr2),
                    GetAValue(_fillVal.ref.cr3), GetRValue(_fillVal.ref.cr3), GetGValue(_fillVal.ref.cr3), GetBValue(_fillVal.ref.cr3));
                break;

            case FILLTYPE_DrawFrameControl:
                _snwprintf(psz, c, L"DFCFill<T:%d,S:%d>", _fillVal.fillDFC.uType, _fillVal.fillDFC.uState);
                break;

            case FILLTYPE_DrawThemeBackground:
                _snwprintf(psz, c, L"DTBFill<H:0x%p,P:%d,S:%d>", _fillVal.fillDTB.hTheme, _fillVal.fillDTB.iPartId, _fillVal.fillDTB.iStateId);
                break;

            default:
                wcsncpy(psz, L"Unknown Fill Type", c);
                break;
            }
        }                
        break;
    case DUIV_LAYOUT:
        _snwprintf(psz, c, L"Layout<0x%p>", _plVal);
        break;
    case DUIV_GRAPHIC:
        _snwprintf(psz, c, L"Graphic<0x%p>", _graphicVal.hImage);
        break;
    case DUIV_SHEET:
        _snwprintf(psz, c, L"Sheet<0x%p>", _ppsVal);
        break;
    case DUIV_EXPR:
        _snwprintf(psz, c, L"Expr<0x%p>", _pexVal);
        break;
    case DUIV_ATOM:
        _snwprintf(psz, c, L"ATOM<%d>", _atomVal);
        break;
    case DUIV_CURSOR:
        _snwprintf(psz, c, L"Cursor<0x%p>", _cursorVal.hCursor);
        break;

    default:
        wcsncpy(psz, L"<ToString Unavailable>", c);
        break;
    }

    // Auto-terminate
    *(psz + (c - 1)) = NULL;

    return psz;
}

LPVOID Value::GetImage(bool bGetRTL)
{
    DUIAssert(_dType == DUIV_GRAPHIC, "Invalid value type");

    DUIAssert((_graphicVal.hImage != _graphicVal.hAltImage), "hImage and hAltImage can not be equal!!!");

    if (!_graphicVal.BlendMode.bFlip)
        return _graphicVal.hImage;
    else
    {
        if (_graphicVal.BlendMode.bRTLGraphic != bGetRTL)
        {
            if (_graphicVal.hAltImage == NULL)
            {
                switch (_graphicVal.BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    FlipBitmap((HBITMAP)_graphicVal.hImage, (HBITMAP *)&_graphicVal.hAltImage);
                    break;
        
                case GRAPHICTYPE_Icon:
                    FlipIcon((HICON)_graphicVal.hImage, (HICON *)&_graphicVal.hAltImage);
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    DUIAssertForce("We do not Flip EnhancedMetaFiles you have to provide a flied one");
                    break;
#ifdef GADGET_ENABLE_GDIPLUS
                case GRAPHICTYPE_GpBitmap:
                    {
                        Gdiplus::Bitmap *pgpBitmap = (Gdiplus::Bitmap *)_graphicVal.hImage;
                        Gdiplus::Rect rect(0, 0, pgpBitmap->GetWidth(), pgpBitmap->GetHeight());
                        _graphicVal.hAltImage = pgpBitmap->Clone(rect, PixelFormatDontCare);
                        ((Gdiplus::Bitmap *)_graphicVal.hAltImage)->RotateFlip(Gdiplus::RotateNoneFlipX);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS
                }

                DUIAssert(_graphicVal.hAltImage, "Could not create hAltImage");

                if (_graphicVal.BlendMode.bFreehImage && _graphicVal.hAltImage)
                {
                    switch (_graphicVal.BlendMode.dImgType)
                    {
                    case GRAPHICTYPE_Bitmap:
                        if (_graphicVal.hImage)
                            DeleteObject(_graphicVal.hImage);
                        break;

                    case GRAPHICTYPE_Icon:
                        if (_graphicVal.hImage)
                            DestroyIcon((HICON)_graphicVal.hImage);
                        break;

#ifdef GADGET_ENABLE_GDIPLUS
                    case GRAPHICTYPE_GpBitmap:
                        if (_graphicVal.hImage)
                            delete (Gdiplus::Bitmap *)_graphicVal.hImage;  // Allocated by GDI+ (cannot use HDelete)
                        break;
#endif // GADGET_ENABLE_GDIPLUS
                    }
                    _graphicVal.hImage = NULL;
                }
            }
            return _graphicVal.hAltImage;
        }
        else
        {
            _graphicVal.BlendMode.bFreehImage = false;
            
            if (_graphicVal.hImage == NULL)
            {
                DUIAssertForce("The same image is used for LTR and RTL");
                
                //Get hImage by flipping hAltImage.

                switch (_graphicVal.BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    FlipBitmap((HBITMAP)_graphicVal.hAltImage, (HBITMAP *)&_graphicVal.hImage);
                    break;
        
                case GRAPHICTYPE_Icon:
                    FlipIcon((HICON)_graphicVal.hAltImage, (HICON *)&_graphicVal.hImage);
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    DUIAssertForce("We do not Flip EnhancedMetaFiles you have to provide a flied one");
                    break;
#ifdef GADGET_ENABLE_GDIPLUS
                case GRAPHICTYPE_GpBitmap:
                    {
                        Gdiplus::Bitmap *pgpAltBitmap = (Gdiplus::Bitmap *)_graphicVal.hAltImage;
                        Gdiplus::Rect rect(0, 0, pgpAltBitmap->GetWidth(), pgpAltBitmap->GetHeight());
                        _graphicVal.hImage = pgpAltBitmap->Clone(rect, PixelFormatDontCare);
                        ((Gdiplus::Bitmap *)_graphicVal.hImage)->RotateFlip(Gdiplus::RotateNoneFlipX);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS
                }
            }

            DUIAssert(_graphicVal.hImage, "hImage is NULL.");
            
            return _graphicVal.hImage;
        }
    }
}

#define CHECK(EXPR) \
    { if(!(EXPR)) { goto Error; } }

BOOL FlipBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy)
{
    BOOL    bRet = FALSE;
    BOOL	bBltOK = FALSE;
    HBITMAP	hbmCopy = NULL;
    HBITMAP	hbmOldSrc = NULL;
    HBITMAP	hbmOldDst = NULL;
    HDC     hdcSrc = NULL;
    HDC     hdcDst = NULL;
    HDC     hdcScreen = NULL;
    int     cBytes = 0;

    BITMAP bm;
    ::ZeroMemory(&bm, sizeof(bm));

    *phbmCopy = NULL;

    // Base the DC and bitmaps on the screen so that any low fidelity bitmaps
    // will be upgraded to the screen's color depth. For example, a 16 bit color
    // bitmap copied for a 24 bit color screen will upgrade the bitmap to 24
    // bit color.

    hdcScreen = GetDC(NULL);
    CHECK(NULL != hdcScreen);

    // Need a memory DC for the source bitmap

    hdcSrc = CreateCompatibleDC(hdcScreen);
    CHECK(NULL != hdcSrc);

    // Use a memory DC to generate the copy bitmap

    hdcDst = CreateCompatibleDC(hdcScreen);
    CHECK(NULL != hdcDst);

    // Get the BITMAP structure for the source to determine its height and width
    
    cBytes = ::GetObject (hbmSrc, sizeof(BITMAP), &bm);
    CHECK(0 != cBytes);

    // Create an empty bitmap in the destination DC

    hbmCopy = ::CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
    CHECK(NULL != hbmCopy);

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmSrc));
    hbmOldDst = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmCopy));
    
    bBltOK = ::StretchBlt(hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, bm.bmWidth-1, 0, -bm.bmWidth, bm.bmHeight, SRCCOPY);

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmOldSrc));
    hbmCopy = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmOldDst));

    if (bBltOK) {
        *phbmCopy = hbmCopy;
        hbmCopy = NULL;
        bRet = TRUE;
    }

Error:
    if (NULL != hbmCopy)
    {
        DeleteObject(hbmCopy);
    }

    if (NULL != hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    if (NULL != hdcSrc)
    {
        DeleteDC(hdcSrc);
    }

    if (NULL != hdcDst)
    {
        DeleteDC(hdcDst);
    }

    return(bRet);
}

BOOL FlipIcon(HICON hIcon, HICON *phAltIcon)
{
    BOOL bRet = FALSE;
    ICONINFO ii;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmColor = NULL;

    if(hIcon && phAltIcon && GetIconInfo(hIcon, &ii))
    {
        hbmMask = ii.hbmMask;
        hbmColor = ii.hbmColor;
        *phAltIcon = NULL;

        if (FlipBitmap(hbmMask, &ii.hbmMask) &&
            FlipBitmap(hbmColor, &ii.hbmColor))
        {
            *phAltIcon = CreateIconIndirect(&ii);
            bRet = TRUE;
        }

        if (hbmMask)
            DeleteObject(hbmMask);

        if (hbmColor)
            DeleteObject(hbmColor);
        
        if (ii.hbmMask && (ii.hbmMask != hbmMask))
            DeleteObject(ii.hbmMask);

        if (ii.hbmColor && (ii.hbmColor != hbmColor))
            DeleteObject(ii.hbmColor);

    }

    return bRet;
}

// Common values
StaticValue(svUnavailable, DUIV_UNAVAILABLE, 0);
StaticValue(svNull, DUIV_NULL, 0);
StaticValue(svUnset, DUIV_UNSET, 0);
StaticValue(svElementNull, DUIV_ELEMENTREF, NULL);
StaticValue(svElListNull, DUIV_ELLIST, NULL);
StaticValue(svBoolTrue, DUIV_BOOL, true);
StaticValue(svBoolFalse, DUIV_BOOL, false);
StaticValue(svStringNull, DUIV_STRING, NULL);
StaticValue2(svPointZero, DUIV_POINT, 0, 0);
StaticValue2(svSizeZero, DUIV_SIZE, 0, 0);
StaticValue4(svRectZero, DUIV_RECT, 0, 0, 0, 0);
StaticValue(svIntZero, DUIV_INT, 0);
StaticValue(svLayoutNull, DUIV_LAYOUT, NULL);
StaticValue(svSheetNull, DUIV_SHEET, NULL);
StaticValue(svExprNull, DUIV_EXPR, NULL);
StaticValue(svAtomZero, DUIV_ATOM, 0);
StaticValue(svCursorNull, DUIV_CURSOR, NULL);
StaticValueColorSolid(svColorTrans, ARGB(0,0,0,0));

Value* Value::pvUnavailable = (Value*)&svUnavailable;
Value* Value::pvNull        = (Value*)&svNull;
Value* Value::pvUnset       = (Value*)&svUnset;
Value* Value::pvElementNull = (Value*)&svElementNull;
Value* Value::pvElListNull  = (Value*)&svElListNull;
Value* Value::pvBoolTrue    = (Value*)&svBoolTrue;
Value* Value::pvBoolFalse   = (Value*)&svBoolFalse;
Value* Value::pvStringNull  = (Value*)&svStringNull;
Value* Value::pvPointZero   = (Value*)&svPointZero;
Value* Value::pvSizeZero    = (Value*)&svSizeZero;
Value* Value::pvRectZero    = (Value*)&svRectZero;
Value* Value::pvIntZero     = (Value*)&svIntZero;
Value* Value::pvLayoutNull  = (Value*)&svLayoutNull;
Value* Value::pvSheetNull   = (Value*)&svSheetNull;
Value* Value::pvExprNull    = (Value*)&svExprNull;
Value* Value::pvAtomZero    = (Value*)&svAtomZero;
Value* Value::pvCursorNull  = (Value*)&svCursorNull;
Value* Value::pvColorTrans  = (Value*)&svColorTrans;

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\borderlayout.cpp ===
/*
 * BorderLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiborderlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// BorderLayout

struct MARGINFLAGS
{
    bool bLeft   : 1;
    bool bTop    : 1;
    bool bRight  : 1;
    bool bBottom : 1;
};

HRESULT BorderLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT BorderLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    BorderLayout* pbl = HNew<BorderLayout>();
    if (!pbl)
        return E_OUTOFMEMORY;

    pbl->Initialize();

    *ppLayout = pbl;

    return S_OK;
}

void BorderLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _peClientPos = NULL;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void BorderLayout::DoLayout(Element* pec, int cx, int cy)
{
    UINT cChildren = GetLayoutChildCount(pec);

    int x = 0;
    int y = 0;
    int xChild;
    int yChild;
    int cxOrg = cx;
    int cyOrg = cy;
 
    if (cChildren == 0)
        return;

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    RECT rcMargin = { 0 };
    MARGINFLAGS mfSet = { false, false, false, false };
    
    for (UINT i = 0; (i < cChildren) && ((cx > 0) || (cy > 0)); i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        if (peChild == _peClientPos)
            // come back to it after all of the others have been laid out
            continue;

        int iLayoutPos = peChild->GetLayoutPos(); 

        xChild = x;
        yChild = y;
        SIZE sizeChild = *(peChild->GetDesiredSize()); 

        Value* pv;
        const RECT* prcChildMargin = peChild->GetMargin(&pv); 

        if ((iLayoutPos == BLP_Left) || (iLayoutPos == BLP_Right))
        {
            sizeChild.cy = cy;

            if (iLayoutPos == BLP_Left)
            {
                if (mfSet.bLeft)
                {
                    int iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                    if (iMargin > cx)
                        iMargin = cx;

                    xChild += iMargin;
                    x += iMargin;
                    cx -= iMargin;
                }

                rcMargin.left = prcChildMargin->right;
                mfSet.bLeft = true;
            }
            else // (iLayoutPos == BLP_Right)
            {
                if (mfSet.bRight)
                {
                    cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                    if (cx < 0)
                        cx = 0;
                }

                rcMargin.right = prcChildMargin->left;
                mfSet.bRight = true;
            }

            if (mfSet.bTop)
            {
                int iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                if (iMargin > sizeChild.cy)
                    iMargin = sizeChild.cy;

                yChild += iMargin;
                sizeChild.cy -= iMargin;
            }

            if (mfSet.bBottom)
            {
                sizeChild.cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                if (sizeChild.cy < 0)
                    sizeChild.cy = 0;
            }

            if (sizeChild.cx > cx)
            {
                sizeChild.cx = cx;
                cx = 0;
            }
            else
                cx -= sizeChild.cx;

            if (iLayoutPos == BLP_Left)
                x += sizeChild.cx;
            else // (iLayoutPos == BLP_Right)
                xChild += cx;  // child's width has already been subtracted off of cx
        }                    
        else // ((iLayoutPos == BLP_Top) || (iLayoutPos == BLP_Bottom))
        {
            sizeChild.cx = cx;

            if (iLayoutPos == BLP_Top)
            {
                if (mfSet.bTop)
                {
                    int iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                    if (iMargin > cy)
                        iMargin = cy;

                    yChild += iMargin;
                    y += iMargin;
                    cy -= iMargin;
                }

                rcMargin.top = prcChildMargin->bottom;
                mfSet.bTop = true;
            }
            else // (iLayoutPos == BLP_Bottom)
            {
                if (mfSet.bBottom)
                {
                    cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                    if (cy < 0)
                        cy = 0;
                }

                rcMargin.bottom = prcChildMargin->top;
                mfSet.bBottom = true;
            }

            if (mfSet.bLeft)
            {
                int iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                if (iMargin > sizeChild.cx)
                    iMargin = sizeChild.cx;

                xChild += iMargin;
                sizeChild.cx -= iMargin;
            }

            if (mfSet.bRight)
            {
                sizeChild.cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                if (sizeChild.cx < 0)
                    sizeChild.cx = 0;
            }

            if (sizeChild.cy > cy)
            {
                sizeChild.cy = cy;
                cy = 0;
            }
            else
                cy -= sizeChild.cy;


            if (iLayoutPos == BLP_Top)
                y += sizeChild.cy;
            else // (iLayoutPos == BLP_Bottom)
                yChild += cy; // child's height has already been subtracted off of cy
        }

        pv->Release();

        UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, xChild, yChild, sizeChild.cx, sizeChild.cy);
    }

    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
    }

    if (_peClientPos)
    {
        peChild = _peClientPos;

        if ((cx == 0) && (cy == 0))
        {
            UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
        }
        else
        {
            Value* pv;
            const RECT *prcChildMargin = peChild->GetMargin(&pv); 

            int iMargin;

            if (mfSet.bLeft)
            {
                iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                if (iMargin > cx)
                    iMargin = cx;
                x += iMargin;
                cx -= iMargin;
            }

            if (mfSet.bTop)
            {
                iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                if (iMargin > cy)
                    iMargin = cy;
                y += iMargin;
                cy -= iMargin;
            }

            if (mfSet.bRight)
            {
                cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                if (cx < 0)
                    cx = 0;
            }

            if (mfSet.bBottom)
            {
                cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                if (cy < 0)
                    cy = 0;
            }

            pv->Release();

            UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
        }
    }

    pvChildren->Release();
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE BorderLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    // sizeRemaining will shrink to represent remaining width and height as each child is calculated.
    // So, when sizeRemaining reaches zero, we've run out of space.
    // Note that this requires zero in both dimensions, as a zero in one dimension does not mean that we will 
    // always end up with zero remaining in the other dimension.
    UINT cChildren = GetLayoutChildCount(pec);

    // meanwhile, _sizeDesired will grow to represent size needed to layout children
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;

    SIZE sizeRemaining = { cxConstraint, cyConstraint };

    // sizeMax is the way that we determine if a dimension of a child is going to push out the desired size in that dimension;
    SIZE sizeMax = { 0, 0 };

    if (cChildren == 0)
        return _sizeDesired;

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    RECT rcMargin = { 0 };
    MARGINFLAGS mfSet = { false, false, false, false };
    
    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called
    for (UINT i = 0; i < cChildren; i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        if (peChild == _peClientPos)
            // come back to it after all of the others have been laid out
            continue;

        int iLayoutPos = peChild->GetLayoutPos(); 

        SIZE sizeChild = peChild->_UpdateDesiredSize(sizeRemaining.cx, sizeRemaining.cy, psrf);

        Value* pv;
        const RECT *prcChildMargin = peChild->GetMargin(&pv); 

        switch (iLayoutPos)
        {
            case BLP_Left:
                if (mfSet.bLeft)
                    sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;

                rcMargin.left = prcChildMargin->right;
                mfSet.bLeft = true;
                break;

            case BLP_Top:
                if (mfSet.bTop)
                    sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

                rcMargin.top = prcChildMargin->bottom;
                mfSet.bTop = true;
                break;

            case BLP_Right:
                if (mfSet.bRight)
                    sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

                rcMargin.right = prcChildMargin->left;
                mfSet.bRight = true;
                break;

            case BLP_Bottom:
                if (mfSet.bBottom)
                    sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

                rcMargin.bottom = prcChildMargin->top;
                mfSet.bBottom = true;
                break;

        }

        if ((iLayoutPos == BLP_Left) || (iLayoutPos == BLP_Right))
        {
            // vertically oriented element
            if (mfSet.bTop)
                sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

            if (mfSet.bBottom)
                sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

            if (sizeChild.cx > sizeRemaining.cx)
            {
                sizeChild.cx = sizeRemaining.cx;
                sizeRemaining.cx = 0;
            }
            else
                sizeRemaining.cx -= sizeChild.cx;
                
            sizeMax.cx -= sizeChild.cx;
            if (sizeMax.cx < 0)
            {
                _sizeDesired.cx += -sizeMax.cx;
                sizeMax.cx = 0;
            }

            int iDiff = sizeChild.cy - sizeMax.cy;
            if (iDiff > 0)
            {
                _sizeDesired.cy += iDiff;
                sizeMax.cy = sizeChild.cy;
            }
        }
        else
        {
            // horizontally oriented element
            if (mfSet.bLeft)
                sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
            if (mfSet.bRight)
                sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

            if (sizeChild.cy > sizeRemaining.cy)
            {
                sizeChild.cy = sizeRemaining.cy;
                sizeRemaining.cy = 0;
            }
            else
                sizeRemaining.cy -= sizeChild.cy;

            sizeMax.cy -= sizeChild.cy;
            if (sizeMax.cy < 0)
            {
                _sizeDesired.cy += -sizeMax.cy;
                sizeMax.cy = 0;
            }

            int iDiff = sizeChild.cx - sizeMax.cx;
            if (iDiff > 0)
            {
                _sizeDesired.cx += iDiff;
                sizeMax.cx = sizeChild.cx;
            }
        }

        pv->Release();

        if ((sizeRemaining.cx == 0) && (sizeRemaining.cy == 0))
            // we can't fit anything else, we're done
            break;
    }

    if (i == cChildren)
    {
        SIZE sizeChild;

        // there was space for the client -- add him in
        if (_peClientPos)
        {
            peChild = _peClientPos;
            sizeChild = peChild->_UpdateDesiredSize(sizeRemaining.cx, sizeRemaining.cy, psrf);

            Value* pv;
            const RECT *prcChildMargin = peChild->GetMargin(&pv); 

            if (mfSet.bLeft)
                sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;

            if (mfSet.bTop)
                sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

            if (mfSet.bRight)
                sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

            if (mfSet.bBottom)
                sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

            pv->Release();
        }
        else
        {
            // no client -- treat residual margins as the size of the client

            if (mfSet.bLeft || mfSet.bRight)
            {
                if (mfSet.bLeft && mfSet.bRight)
                    sizeChild.cx = (rcMargin.left > rcMargin.right) ? rcMargin.left : rcMargin.right;
                else if (mfSet.bLeft)
                    sizeChild.cx = rcMargin.left;
                else // (mfSet.bRight)
                    sizeChild.cx = rcMargin.right;
            }
            else
                sizeChild.cx = 0;

            if (mfSet.bTop || mfSet.bBottom)
            {
                if (mfSet.bTop && mfSet.bBottom)
                    sizeChild.cy = (rcMargin.top > rcMargin.bottom) ? rcMargin.top : rcMargin.bottom;
                else if (mfSet.bTop)
                    sizeChild.cy = rcMargin.top;
                else // (mfSet.bBottom)
                    sizeChild.cy = rcMargin.bottom;
            }
            else
                sizeChild.cy = 0;
        }

        // no further need for sizeRemaining -- so don't bother updating here
        //sizeRemaining.cx -= sizeChild.cx;
        //sizeRemaining.cy -= sizeChild.cy;

        int iDiff = sizeChild.cx - sizeMax.cx;
        if (iDiff > 0)
            _sizeDesired.cx += iDiff;

        iDiff = sizeChild.cy - sizeMax.cy;
        if (iDiff > 0)
            _sizeDesired.cy += iDiff;
    }

    pvChildren->Release();

    if (_sizeDesired.cx > cxConstraint)
        _sizeDesired.cx = cxConstraint;

    if (_sizeDesired.cy > cyConstraint)
        _sizeDesired.cy = cyConstraint;

    return _sizeDesired;
}

void BorderLayout::SetClient(Element* pe)
{
    if (_peClientPos)
    {
        // throw exception -- there can only be one client
    }
    _peClientPos = pe;
}

void BorderLayout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
    {
        if (ppeAdd[i]->GetLayoutPos() == BLP_Client)
            SetClient(ppeAdd[i]);
    }

    Layout::OnAdd(pec, ppeAdd, cCount);
}

void BorderLayout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
    {
        if (ppeRemove[i] == _peClientPos)
            _peClientPos = NULL;
    }

    Layout::OnRemove(pec, ppeRemove, cCount);
}

void BorderLayout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    if (peChanged == _peClientPos)
        _peClientPos = NULL;
    else if (dNewLP == BLP_Client)
        SetClient(peChanged);

    Layout::OnLayoutPosChanged(pec, peChanged, dOldLP, dNewLP);
}


Element* BorderLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        UINT cChildren = GetLayoutChildCount(pec);

        Element* peChild;
        Element* peMatch = NULL;
        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        //
        // there are two scenarios that all navigations boil down to for this layout:
        //  (1) tunneling into the border layout
        //  (2) crawling out of the border layout
        //
        // The second scenario is the easier of the two, because there is no need to check the reference rectangle for 
        // maximal overlap (because, by virtue of the subtractive rects algorithm used by this layout, all peers encountered
        // while crawling out of the border layout will cover at least the entire side of the child being navigated from).
        // So, as soon as we find a child positioned in the direction of the navigation, we're done.
        //
        // The first scenario is not that lucky.  When tunneling in, it is entirely possible that there will be multiple 
        // children sharing an adjacent side in the direction of the navigation.  So, as we encounter children positioned in
        // the direction of the navigation, we have to save off the child with the highest overlap score.  In the end, the
        // child with the highest score wins.
        //

        bool bTunnel = false;
        int iFromLayoutPos = 0;
        int iStart = -1;

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            bTunnel = true;

            switch (iNavDir)
            {
                case NAV_UP:    iFromLayoutPos = BLP_Bottom; break;
                case NAV_DOWN:  iFromLayoutPos = BLP_Top;    break;
                case NAV_LEFT:  iFromLayoutPos = BLP_Right;  break;
                case NAV_RIGHT: iFromLayoutPos = BLP_Left;   break;
            }
        }
        else
        {
            iFromLayoutPos = peFrom->GetLayoutPos();

            if (iFromLayoutPos == BLP_Client)
                iStart = cChildren;
            else
            {
                iStart = GetLayoutIndexFromChild(pec, peFrom);

                switch (iFromLayoutPos)
                {
                    case BLP_Top:    bTunnel = (iNavDir == NAV_DOWN);  break;
                    case BLP_Left:   bTunnel = (iNavDir == NAV_RIGHT); break;
                    case BLP_Bottom: bTunnel = (iNavDir == NAV_UP);    break;
                    case BLP_Right:  bTunnel = (iNavDir == NAV_LEFT);  break;
                }
            }
        }

        if (bTunnel)
        {
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            bool bIgnoreClient = false;
            bool bFoundLateral = false;
            int iOpposingPos = 0;
            Element* peLastOpposing = NULL;

            switch (iFromLayoutPos)
            {
                case BLP_Top:    iOpposingPos = BLP_Bottom; break;
                case BLP_Bottom: iOpposingPos = BLP_Top;    break;
                case BLP_Right:  iOpposingPos = BLP_Left;   break;
                case BLP_Left:   iOpposingPos = BLP_Right;  break;
            }

            for (UINT i = (iStart + 1); i < cChildren; i++)
            {
                peChild = GetChildFromLayoutIndex(pec, i, peList);

                if (peChild == _peClientPos)
                    continue;

                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                if (!peTo)
                    continue;

                int iLayoutPos = peChild->GetLayoutPos();

                if (!bFoundLateral && (iLayoutPos == iFromLayoutPos))
                {
                    // optimization -- if the first peer we encounter takes up the entire side, then there is no need to go any further
                    ns.peWinner = peTo;
                    bIgnoreClient = true;
                    break;
                }

                if (iLayoutPos == iOpposingPos)
                    peLastOpposing = peTo;
                else
                {
                    if (ns.TrackScore(peChild, peTo))
                    {
                        bIgnoreClient = true;
                        break;
                    }

                    bFoundLateral = true;
                }

                if (iLayoutPos == iFromLayoutPos)
                {
                    // optimization -- once we've encountered a peer in the same layout position, we don't need to check any further because
                    // we have found all peers that cover that side
                    bIgnoreClient = true;
                    break;
                }
            }

            if (!bIgnoreClient)
            {
                if (_peClientPos)
                {
                    Element* peTo = _peClientPos->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                    // one goofy behavior here is that, if the client is not visible because it's zero sized, we actually pick one
                    // of the lateral neighbors instead of the opposing neighbor, even if the opposing neighbor is the winner
                    if (peTo)
                        ns.TrackScore(_peClientPos, peTo);
                }

                if (!ns.peWinner)
                {
                    if (!peLastOpposing && (iStart > 0))
                    {
                        UINT i = iStart;

                        while ((i > 0) && !peLastOpposing)
                        {
                            peChild = GetChildFromLayoutIndex(pec, --i, peList);
                            if (peChild->GetLayoutPos() == iOpposingPos)
                                peLastOpposing = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                        }
                    }

                    ns.peWinner = peLastOpposing;
                }
            }
            peMatch = ns.peWinner;
        }
        else // crawl
        {
            for (UINT i = iStart; (i > 0) && !peMatch;)
            {
                peChild = GetChildFromLayoutIndex(pec, --i, peList);

                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                if (!peTo)
                    continue;

                switch (peChild->GetLayoutPos())
                {
                    case BLP_Top:    if (iNavDir == NAV_UP)    peMatch = peTo; break;
                    case BLP_Left:   if (iNavDir == NAV_LEFT)  peMatch = peTo; break;
                    case BLP_Bottom: if (iNavDir == NAV_DOWN)  peMatch = peTo; break;
                    case BLP_Right:  if (iNavDir == NAV_RIGHT) peMatch = peTo; break;
                }
            }
        }

        pvChildren->Release();
        return peMatch;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, bKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\flowlayout.cpp ===
/*
 * FlowLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiflowlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// flow layout

SIZE FlowLayout::g_sizeZero = { 0, 0 };

// ----------------------------------------------------------------------------------------------------------------
//
//  method overview:
//    public:
//      DoLayout          -- responsible for doing all of the alignment work and placing the elements
//      HitTest           -- simply calls superclass for now
//      UpdateDesiredSize -- simply calls BuildCacheInfo
// 
//    protected:
//      BuildCacheInfo    -- the workhorse of this layout -- builds up the line array and per-line element arrays
//
// ----------------------------------------------------------------------------------------------------------------

HRESULT FlowLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 1:
        hr = Create(pParams[0] ? true : false, ALIGN_TOP, ALIGN_LEFT, ALIGN_CENTER, &pl);
        break;

    case 2:
        hr = Create(pParams[0] ? true : false, pParams[1], ALIGN_LEFT, ALIGN_CENTER, &pl);
        break;

    case 3:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], ALIGN_CENTER, &pl);
        break;

    case 4:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], pParams[3], &pl);
        break;

    default:
        hr = Create(true, ALIGN_TOP, ALIGN_LEFT, ALIGN_CENTER, &pl);
    }

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT FlowLayout::Create(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    FlowLayout* pfl = HNew<FlowLayout>();
    if (!pfl)
        return E_OUTOFMEMORY;

    pfl->Initialize(fWrap, uYAlign, uXLineAlign, uYLineAlign);

    *ppLayout = pfl;

    return S_OK;
}

void FlowLayout::Initialize(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _fWrap = fWrap;
    _uXLineAlign = uXLineAlign;
    _uYLineAlign = uYLineAlign;
    _uYAlign = uYAlign;
    _arLines = NULL;
    _cLines = 0;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
    _sizeLastConstraint.cx = 0;
    _sizeLastConstraint.cy = 0;
}

FlowLayout::~FlowLayout()
{
    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].arxElement)
                HFree(_arLines[k].arxElement);
        }

        HFree(_arLines);
    }
}

////////////////////////////////////////////////////////
// Callbacks from clients

void FlowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (!_cLines || IsCacheDirty())
        return;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    LINE* plCur = _arLines + (_cLines - 1);

    int yStart = 0;
    int cyContent = 0;

    if (_uYAlign != ALIGN_TOP)
    {
        cyContent = plCur->y + plCur->cy;
        int cyDelta = cy - cyContent;

        if (_uYAlign == ALIGN_CENTER)
            yStart = cyDelta / 2;
        else if (_uYAlign == ALIGN_BOTTOM)
            yStart = cyDelta;
    }

    plCur = _arLines;
    UINT i = 0;

    for (UINT uLine = 0; uLine < _cLines; uLine++)
    {
        int xStart = 0;

        if (_uXLineAlign == ALIGN_CENTER)
            xStart = (cx - plCur->cx) / 2;
        else if (_uXLineAlign == ALIGN_RIGHT)
            xStart = cx - plCur->cx;

        int yLine = plCur->y;
        int cyLine = plCur->cy;

        if ((_uYAlign == ALIGN_JUSTIFY) && (cyContent < cy))
        {
            if (!cyContent)
            {
                // zero desired height -- so spread equally among lines
                yLine = cy * uLine / _cLines;
                cyLine = (cy * (uLine + 1) / _cLines) - yLine;
            }
            else
            {
                cyLine = cyLine * cy / cyContent;
                yLine  = yLine  * cy / cyContent;
            }
        }

        int xElement;
        int yElement;
        
        for (UINT uElement = 0; uElement < plCur->cElements; uElement++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
    
            SIZE size = *(peChild->GetDesiredSize());

            //xElement = (uElement == 0) ? 0 : plCur->arxElement[uElement - 1];
            xElement = 0;
            if (uElement != 0 && plCur->arxElement)
                xElement = plCur->arxElement[uElement - 1];

            yElement = 0;
            if (_uYLineAlign == ALIGN_CENTER)
                yElement = (cyLine - size.cy) / 2;
            else if (_uYLineAlign == ALIGN_BOTTOM)
                yElement = cyLine - size.cy;
            else if (_uYLineAlign == ALIGN_JUSTIFY)
                size.cy = cyLine;

            if ((_uXLineAlign == ALIGN_JUSTIFY) && (plCur->cx < (UINT) cx))
            {
                size.cx  = plCur->cx ? (size.cx  * cx / plCur->cx) : 0;
                xElement = plCur->cx ? (xElement * cx / plCur->cx) : 0;
            }

            xElement += xStart;
            yElement += yStart + yLine;

            // constrain it to bounds of layout (0,0)-(cx,cy)
            if (xElement < 0)
            {
                size.cx += xElement;
                xElement = 0;
                if (size.cx < 0)
                    size.cx = 0;
            }
            
            if ((xElement + size.cx) > cx)
            {
                size.cx = cx - xElement;
                if (size.cx < 0)
                    size.cx = 0;
            }

            if (yElement < 0)
            {
                size.cy += yElement;
                yElement = 0;
                if (size.cy < 0)
                    size.cy = 0;
            }

            if ((yElement + size.cy) > cy)
            {
                size.cy = cy - yElement;
                if (size.cy < 0)
                    size.cy = 0;
            }

            UpdateLayoutRect(pec, cx, cy, peChild, xElement, yElement, size.cx, size.cy);

            i++;
        }
        plCur++;
    }

    // this code is only ever hit when the line array does not include all layout elements in the container;
    // currently, this only happens when wrapping is off.
    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cx, cy, peChild, 0, 0, 0, 0);
    }

    pvChildren->Release();
}

SIZE FlowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    return BuildCacheInfo(pec, cxConstraint, cyConstraint, psrf, false);
}
        
SIZE FlowLayout::BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize)
{
    UNREFERENCED_PARAMETER(fRealSize);

    SetCacheDirty();

    /*
    if (_arLines != NULL)
    {
        // check to make sure we really have to recalc

        if (cxConstraint == sizeLastConstraint.cx)
            // if cxConstraint doesn't change, then the calculation stays the same
            return _sizeDesired;
    }
    */

    // I'm saving previous constraints to be able to optimize this stage.
    // When I get flags coming into UpdateDesiredSize, I can get rid of this.
    _sizeLastConstraint.cx = cxConstraint;
    _sizeLastConstraint.cy = cyConstraint;

    UINT cChildren = GetLayoutChildCount(pec);

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called

    int cyCur = 0;
    int cxCur = 0;
    UINT i = 0;

    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].arxElement)
                HFree(_arLines[k].arxElement);
        }

        HFree(_arLines);
    }

    _cLines = 0;

    // Allocate space for the data for the initial line
    _arLines = (LINE*)HAllocAndZero(sizeof(LINE) * 1);
    if (!_arLines)
    {
        pvChildren->Release();
        return g_sizeZero;
    }

    int cxMax = 0;

    int cxRealConstraint = cxConstraint;

    int iLeftMargin;
    int iTopMargin;
    int iRightMargin;
    int iBottomMargin;

    int iLineTopMargin = 0;
    int iLineBottomMargin = 0;

    int iPrevLineBottomMargin = 0;

    while (i < cChildren)
    {
        cxCur = 0;
        int cyMax;
        int iMargin = 0;

        _cLines++;
        if (_cLines > 1)
        {
            // Allocate space for the data for subsequent lines (space for the first line was alloc'ed outside of this loop
            LINE* arNewLines = (LINE*)HReAllocAndZero(_arLines, sizeof(LINE) * _cLines);
            if (!arNewLines)
            {
                HFree(_arLines);
                _arLines = NULL;
                pvChildren->Release();
                return g_sizeZero;
            }

            _arLines = arNewLines;
        }

        // Initialize line computation with information from first element on line 
        LINE* plCur = _arLines + (_cLines - 1);

        peChild = GetChildFromLayoutIndex(pec, i, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        Value* pv;
        const RECT* prect = peChild->GetMargin(&pv); 
        iLeftMargin   = prect->left;
        iTopMargin    = prect->top;
        iRightMargin  = prect->right;
        iBottomMargin = prect->bottom;
        pv->Release();
        
        plCur->y = cyCur;

        plCur->cElements = 1;
        plCur->iStart = i;
        plCur->arxElement = NULL;

        if (_fWrap)
        {
            // potential for more lines -- keep track of max top and bottom margins for this line
            if (_cLines > 1)
            {
                if ((_uYLineAlign == ALIGN_TOP) || (_uYLineAlign == ALIGN_JUSTIFY))
                    // iLineTopMargin is a running total of max top margin
                    iLineTopMargin = iTopMargin;
                else if (_uYLineAlign == ALIGN_CENTER)
                    // iLineTopMargin is a running total of max thickness / 2 + top margin (add one because of rounding error only for top)
                    iLineTopMargin = ((sizeChild.cy + 1) / 2) + iTopMargin;
                else // _uYLineAlign == ALIGN_BOTTOM
                    // iLineTopMargin is a running total of max thickness + top margin
                    iLineTopMargin = sizeChild.cy + iTopMargin;
            }

            if ((_uYLineAlign == ALIGN_BOTTOM) || (_uYLineAlign == ALIGN_JUSTIFY))
                // iLineBottomMargin is a running total of max bottom margin
                iLineBottomMargin = iBottomMargin;
            else if (_uYLineAlign == ALIGN_CENTER)
                // iLineBottomMargin is a running total of max thickness / 2 + bottom margin
                iLineBottomMargin = (sizeChild.cy / 2) + iBottomMargin;
            else // _uYLineAlign == ALIGN_TOP
                // iLineBottomMargin is a running total of max thickness + bottom margin
                iLineBottomMargin = sizeChild.cy + iBottomMargin;
        }

        cyMax = sizeChild.cy;
        cxCur += sizeChild.cx;
        iMargin = iRightMargin;

        // step to next element
        i++;

        // Line loop -- loop until we go beyond length of line
        while (i < cChildren)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

            const RECT* prect = peChild->GetMargin(&pv);
            iLeftMargin   = prect->left;
            iTopMargin    = prect->top;
            iRightMargin  = prect->right;
            iBottomMargin = prect->bottom;
            pv->Release();

            // use the max margin value between the right margin of the preceding element and
            // the left margin of this element
            if (iMargin < iLeftMargin)
                iMargin = iLeftMargin;

            if (_fWrap && (cxCur + iMargin + sizeChild.cx > cxRealConstraint))
                // we're wrapping and we went beyond length of line -- break out of this loop
                break;

            if (plCur->cElements == 1)
            {
                plCur->arxElement = (UINT*)HAllocAndZero(sizeof(UINT));
                if (!plCur->arxElement)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }
            }
            else
            {
                UINT* pNew = (UINT*)HReAllocAndZero(plCur->arxElement, sizeof(UINT) * plCur->cElements);
                if (!pNew)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }

                plCur->arxElement = pNew;
            }

            plCur->arxElement[plCur->cElements - 1] = cxCur + iMargin;
            plCur->cElements++;

            // keep track of the maximum thickness of the elements on this line
            if (cyMax < sizeChild.cy)
                cyMax = sizeChild.cy;

            cxCur += iMargin + sizeChild.cx;

            if (_fWrap)
            {
                // potential for more lines -- keep track of max top and bottom margins for this line
                if (_cLines > 1)
                {
                    // keep track of the maximum top or left margin on this line
                    if ((_uYLineAlign == ALIGN_TOP) || (_uYLineAlign == ALIGN_JUSTIFY))
                        // iLineTopMargin is a running total of max top or left margin
                        iMargin = iTopMargin;
                    else if (_uYLineAlign == ALIGN_CENTER)
                        // iLineTopMargin is a running total of max thickness / 2 + top or left margin (add one because of rounding error only for top/left)
                        iMargin = ((sizeChild.cy + 1) / 2) + iTopMargin;
                    else // _uYLineAlign == ALIGN_BOTTOM
                        // iLineTopMargin is a running total of max thickness + top or left margin
                        iMargin = sizeChild.cy + iTopMargin;

                    if (iLineTopMargin < iMargin)
                        iLineTopMargin = iMargin;
                }

                // keep track of the maximum bottom or right margin on this line
                if ((_uYLineAlign == ALIGN_BOTTOM) || (_uYLineAlign == ALIGN_JUSTIFY))
                    // iLineBottomMargin is a running total of max bottom or right margin
                    iMargin = iBottomMargin;
                else if (_uYLineAlign == ALIGN_CENTER)
                    // iLineBottomMargin is a running total of max thickness / 2 + bottom or right margin
                    iMargin = (sizeChild.cy / 2) + iBottomMargin;
                else // _uYLineAling == ALIGN_TOP
                    // iLineBottomMargin is a running total of max thickness + bottom or right margin
                    iMargin = sizeChild.cy + iBottomMargin;

                if (iLineBottomMargin < iMargin)
                    iLineBottomMargin = iMargin;
            }

            iMargin = iRightMargin;
            i++;
        }

        if (cxMax < cxCur)
            cxMax = cxCur;

        if (_fWrap)
        {
            // adjust margin running totals to reflect residual margin --
            // the bummer here is that we have to nuke negative margins because otherwise we're messed up
            if (_uYLineAlign == ALIGN_CENTER)
            {
                iLineTopMargin -= (cyMax + 1) / 2;
                if (iLineTopMargin < 0)
                    iLineTopMargin = 0;

                iLineBottomMargin -= cyMax / 2;
                if (iLineBottomMargin < 0)
                    iLineBottomMargin = 0;
            }
            else if (_uYLineAlign == ALIGN_BOTTOM)
            {
                iLineTopMargin -= cyMax;
                if (iLineTopMargin < 0)
                    iLineTopMargin = 0;
            }
            else if (_uYLineAlign == ALIGN_TOP)
            {
                iLineBottomMargin -= cyMax;
                if (iLineBottomMargin < 0)
                    iLineBottomMargin = 0;
            }

            if (_cLines > 1)
            {
                // account for margins between lines

                if (iPrevLineBottomMargin < iLineTopMargin)
                    iPrevLineBottomMargin = iLineTopMargin;

                // iPrevLineBottomMargin is now the max margin between the previous line and this line
                plCur->y += iPrevLineBottomMargin;
                cyCur += iPrevLineBottomMargin;
            }

            // save off this line's bottom margin to compare with the next line's resulting top margin
            iPrevLineBottomMargin = iLineBottomMargin;
        }

        cyCur += cyMax;

        plCur->cx = cxCur;
        plCur->cy = cyMax;
    }

    _sizeDesired.cx = (cxMax < cxConstraint) ? cxMax : cxConstraint;
    _sizeDesired.cy = (cyCur < cyConstraint) ? cyCur : cyConstraint;

    pvChildren->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

int FlowLayout::GetLine(Element* pec, Element* pe)
{
    int iChild = GetLayoutIndexFromChild(pec, pe);

    if (iChild >= 0)
    {
        UINT uChild = (UINT) iChild;

        for (UINT i = 0; i < _cLines; i++)
        {
            LINE* pLine = _arLines + i;
            if (uChild < (pLine->iStart + pLine->cElements))
                return i;
        }
    }
    return -1;
}

Element* FlowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        if (!_cLines || IsCacheDirty())
            return NULL;

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        NavScoring ns;

        ns.Init(pec, iNavDir, pnr);

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            bool fForward = ((iNavDir & NAV_FORWARD) != 0);

            if (iNavDir & NAV_VERTICAL)
            {
                int l = fForward ? 0 : (_cLines - 1);
                LINE* pLine = _arLines + l;
                while (!ns.peWinner)
                {
                    for (UINT i = 0; i < pLine->cElements; i++)
                    {
                        if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }

                    if (fForward)
                    {
                        l++;
                        if ((UINT) l == _cLines)
                            break;

                        pLine++;
                    }
                    else
                    {
                        if (pLine == _arLines)
                            break;
                        pLine--;
                    }
                }
            }
            else
            {
                UINT uOffset = 0;

                while (!ns.peWinner)
                {
                    BOOL fFoundOne = FALSE;

                    for (UINT l = 0; l < _cLines; l++)
                    {
                        LINE* pLine = _arLines + l;
                        int i = pLine->iStart;

                        if (uOffset >= pLine->cElements)
                            continue;

                        fFoundOne = TRUE;

                        if (fForward)
                            i += uOffset;
                        else
                            i += pLine->cElements - (uOffset + 1);
                        
                        if (ns.Try(GetChildFromLayoutIndex(pec, i, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }
                    if (!fFoundOne)
                        break;

                    uOffset++;
                }
            }
        }
        else // we're navigating from child within container
        {
            int iLine = GetLine(pec, peFrom);

            switch (iNavDir)
            {
                case NAV_UP:
                    while (iLine > 0)
                    {
                        iLine--;
                        LINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_DOWN:
                    while (iLine < (int) (_cLines - 1))
                    {
                        iLine++;
                        LINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_LEFT:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    while (i > (int) _arLines[iLine].iStart)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, --i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }

                case NAV_RIGHT:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    int iMax = (int) (_arLines[iLine].iStart + _arLines[iLine].cElements - 1);
                    while (i < iMax)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, ++i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }
            }
        }

        pvChildren->Release();

        return ns.peWinner ? ns.peWinner : NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\filllayout.cpp ===
/*
 * FillLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duifilllayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// FillLayout

////////////////////////////////////////////////////////
// Parser callback (static)

HRESULT FillLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT FillLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    FillLayout* pfl = HNew<FillLayout>();
    if (!pfl)
        return E_OUTOFMEMORY;

    pfl->Initialize();

    *ppLayout = pfl;

    return S_OK;
}

void FillLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    rcMargin.left   = 0;
    rcMargin.top    = 0;
    rcMargin.right  = 0;
    rcMargin.bottom = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void FillLayout::DoLayout(Element* pec, int cx, int cy)
{
    int x = rcMargin.left;
    int y = rcMargin.top;
    cx -= rcMargin.left + rcMargin.right;
    cy -= rcMargin.top + rcMargin.bottom;

    int xAdj;
    int yAdj;
    int cxAdj;
    int cyAdj;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    const SIZE* pDS;
    int dLP;

    for (UINT u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);

        xAdj = x;
        yAdj = y;
        cxAdj = cx;
        cyAdj = cy;

        dLP = peChild->GetLayoutPos();
        if (dLP != LP_Auto)
        {
            pDS = peChild->GetDesiredSize();
            switch (dLP)
            {
            case FLP_Right:
                xAdj = x + cx - pDS->cx;
                // Fall through

            case FLP_Left:
                cxAdj = pDS->cx;
                break;

            case FLP_Bottom:
                yAdj = y + cy - pDS->cy;
                // Fall through

            case FLP_Top:
                cyAdj = pDS->cy;
                break;
            }
        }

        if (xAdj < 0)
            xAdj = 0;
        if (yAdj < 0)
            yAdj = 0;

        if (cxAdj < 0)
            cxAdj = 0;
        if (cyAdj < 0)
            cyAdj = 0;
        
        peChild->_UpdateLayoutPosition(xAdj, yAdj);
        peChild->_UpdateLayoutSize(cxAdj, cyAdj);
    }
    
    pvChildren->Release();
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE FillLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT u;
    Element* peChild;

    rcMargin.left   = -INT_MAX;
    rcMargin.top    = -INT_MAX;
    rcMargin.right  = -INT_MAX;
    rcMargin.bottom = -INT_MAX;

    for (u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);
        Value* pvMargin;
        const RECT* prcChildMargin = peChild->GetMargin(&pvMargin); 

        if (rcMargin.left   < prcChildMargin->left  )   rcMargin.left   = prcChildMargin->left;
        if (rcMargin.top    < prcChildMargin->top   )   rcMargin.top    = prcChildMargin->top;
        if (rcMargin.right  < prcChildMargin->right )   rcMargin.right  = prcChildMargin->right;
        if (rcMargin.bottom < prcChildMargin->bottom)   rcMargin.bottom = prcChildMargin->bottom;

        pvMargin->Release();
    }

    if (rcMargin.left   < 0)    rcMargin.left   = 0;
    if (rcMargin.top    < 0)    rcMargin.top    = 0;
    if (rcMargin.right  < 0)    rcMargin.right  = 0;
    if (rcMargin.bottom < 0)    rcMargin.bottom = 0;

    cxConstraint -= rcMargin.left + rcMargin.right;
    cyConstraint -= rcMargin.top + rcMargin.bottom;

    SIZE sizeMax = { 0, 0 };

    for (u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        if (sizeMax.cx < sizeChild.cx)
            sizeMax.cx = sizeChild.cx;

        if (sizeMax.cy < sizeChild.cy)
            sizeMax.cy = sizeChild.cy;
    }

    pvChildren->Release();

    sizeMax.cx += rcMargin.left + rcMargin.right;
    sizeMax.cy += rcMargin.top + rcMargin.bottom;
    return sizeMax;
}

Element* FillLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
            return NULL;
        else if (!peFrom)
        {
            UINT cChildren = GetLayoutChildCount(pec);

            Value* pvChildren;
            ElementList* peList = pec->GetChildren(&pvChildren); 

            UINT u;
            Element* peChild;

            for (u = 0 ; u < cChildren; u++)
            {
                peChild = GetChildFromLayoutIndex(pec, u, peList);
                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                if (peTo)
                {
                    pvChildren->Release();
                    return peTo;
                }
            }

            pvChildren->Release();
        }
        // else -- when navigating from inside, we always return NULL since only one item within you is navigable
        // so just fall through to NULL here

        return NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\layout.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_LAYOUT_H_INCLUDED
#define DUI_LAYOUT_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>

#endif // DUI_LAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\ninegridlayout.cpp ===
/*
 * NineGridLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duininegridlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// NineGridLayout

////////////////////////////////////////////////////////
// Parser callback (static)

HRESULT NineGridLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT NineGridLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    NineGridLayout* pngl = HNew<NineGridLayout>();
    if (!pngl)
        return E_OUTOFMEMORY;

    pngl->Initialize();

    *ppLayout = pngl;

    return S_OK;
}

void NineGridLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    for (UINT i = 0; i < 9; i++)
        _peTiles[i] = NULL;

    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void NineGridLayout::DoLayout(Element* pec, int cx, int cy)
{
    UNREFERENCED_PARAMETER(pec);

    // we use the same number of slots for the starting locations for the elements, but in fact we are not using any of the margin slots;
    // duh!
    int start[NumDims][NumSlots];
    int i,j;


    // determine length of center slots
    for (i = 0; i < NumDims; i++)
    {
        int cRemaining = (i == X) ? cx : cy;

        for (int j = 0; j < NumSlots; j++)
        {
            if (j == Center)
                continue;

            cRemaining -= _length[i][j];
        }

        if (cRemaining < 0)
            // we hit less than zero when we have margins, which are not calculated with 
            // constraints in mind, that sum greater than the element's size
            cRemaining = 0;

        _length[i][Center] = cRemaining;
    }

    // set the start positions by adding the previous slot's  start and length
    for (i = 0; i < NumDims; i++)
    {
        start[i][0] = 0;

        for (j = 1; j < NumSlots; j++)
                start[i][j] = start[i][j-1] + _length[i][j-1];
    }

    
    int iX = 1;
    int iY = 1;

    // loop through the tiles and set the position and size for each occupied cell
    for (i = 0; i < NumCells; i++)
    {
        if (_peTiles[i])
        {
            UpdateLayoutRect(pec, cx, cy, _peTiles[i], start [X][iX], start [Y][iY], _length[X][iX], _length[Y][iY]);
        }

        iX += 2;
        if (iX >= NumSlots)
        {
            iX = 1;
            iY += 2;
        }
    }
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE NineGridLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(pec);

    int i,j;

    // initialize all margin lengths to smallest int and all cell lengths to 0
    for (i = 0; i < NumDims; i++)
    {
        for (j = 0; j < NumSlots; j += 2)
        {
            _length[i][j]   = -INT_MAX;
            if ((j + 1) < NumSlots)
                _length[i][j+1] = 0;
        }
    }

    int iY = 1;
    int iX = 1;
    i = 0;
    // scan margins and find the largest margin for each margin slot
    while (i < NumCells)
    {
        if (_peTiles[i])
        {
            Value* pvMargin;
            const RECT* prc = _peTiles[i]->GetMargin(&pvMargin);

            if (_length[X][iX - 1] < prc->left)
                _length[X][iX - 1] = prc->left;
            if (_length[X][iX + 1] < prc->right)
                _length[X][iX + 1] = prc->right;
            if (_length[Y][iY - 1] < prc->top)
                _length[Y][iY - 1] = prc->top;
            if (_length[Y][iY + 1] < prc->bottom)
                _length[Y][iY + 1] = prc->bottom;

            pvMargin->Release();
        }

        i++;
        if (!(i % CellsPerRow))
        {
            iY += 2;
            iX = 1;
        }
        else
            iX += 2;
    }

    int cRemaining[NumDims];

    cRemaining[X] = cxConstraint;
    cRemaining[Y] = cyConstraint;

    // reduce remaining width and height by margin lengths;
    // if any margins are still set to smallest int, then no elements were using that margin, so reset margin length to 0
    for (i = 0; i < NumDims; i++)
    {
        for (j = 0; j < NumSlots; j += 2)
        {
            if (_length[i][j] == -INT_MAX)
                _length[i][j] = 0;
            else
                cRemaining[i] -= _length[i][j];
        }
    }

    int iOrder[NumCells] =  { NGLP_Top, NGLP_Left, NGLP_Bottom, NGLP_Right, NGLP_TopLeft, NGLP_TopRight, NGLP_BottomLeft, NGLP_BottomRight, NGLP_Client };

    for (i = 0; i < NumCells; i++)
    {
        int iTile = iOrder[i];

        if (_peTiles[iTile])
        {
            iY = ((iTile / CellsPerRow) * 2) + 1;
            iX = ((iTile % CellsPerRow) * 2) + 1;

            // add back in the longest length for that slot since this element is actually constrained by not only the remaining size, but
            // also the size currently being set aside for that slot
            cRemaining[X] += _length[X][iX];
            cRemaining[Y] += _length[Y][iY];

            SIZE sizeChild = _peTiles[iTile]->_UpdateDesiredSize(cRemaining[X], cRemaining[Y], psrf);

            // check for longest length for given slot
            if (_length[X][iX] < sizeChild.cx)
                _length[X][iX] = sizeChild.cx;
            if (_length[Y][iY] < sizeChild.cy)
                _length[Y][iY] = sizeChild.cy;

            // remove longest length for that slot to set us up for the next pass (i.e. to undo what was done above when we added it back in;
            // the only difference is that it may have changed to a larger value becuase of this element's desired size -- in which case
            // we'd reduce the remaining size by more than we incresed it above -- which is exactly the behavior we want
            cRemaining[X] -= _length[X][iX];
            cRemaining[Y] -= _length[Y][iY];
        }
    }

    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;

    for (i = 0; i < NumDims; i++)
        for (j = 0; j < NumSlots; j++)
            ((int*) &_sizeDesired)[i] += _length[i][j];

    if (_sizeDesired.cx > cxConstraint)
        _sizeDesired.cx = cxConstraint;

    if (_sizeDesired.cy > cyConstraint)
        _sizeDesired.cy = cyConstraint;

    return _sizeDesired;
}

void NineGridLayout::_UpdateTileList(int iTile, Element* pe)
{
    if ((iTile >= 0) && (iTile < NumCells))
    {
        if (pe)
        {
            DUIAssert(_peTiles[iTile] == NULL, "There can only be one element in each layout position for Nine Grid Layout");
        }
        _peTiles[iTile] = pe;
    }
}

void NineGridLayout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
        _UpdateTileList(ppeAdd[i]->GetLayoutPos(), ppeAdd[i]);

    Layout::OnAdd(pec, ppeAdd, cCount);
}

void NineGridLayout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
        _UpdateTileList(ppeRemove[i]->GetLayoutPos(), NULL);

    Layout::OnRemove(pec, ppeRemove, cCount);
}

void NineGridLayout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    _UpdateTileList(dOldLP, NULL);
    _UpdateTileList(dNewLP, peChanged);

    Layout::OnLayoutPosChanged(pec, peChanged, dOldLP, dNewLP);
}

Element* NineGridLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
            return NULL;
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = NumCells - 1;
            }

            if (!(iNavDir & NAV_VERTICAL))
                iInc *= 3;

            for (int i = 0; i < 3; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < 3; j++, iTile += iInc)
                {
                    Element* peChild = _peTiles[iTile];

                    if (!peChild)
                        continue;

                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                    if (!peTo)
                        continue;

                    if (ns.TrackScore(peChild, peTo))
                        break;
                }

                if (ns.peWinner)
                    return ns.peWinner;

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * 3;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            return NULL;
        }
        else
        {
            int iLayoutPos = peFrom->GetLayoutPos();
            int iPos[2] = { -1, -1 };

            switch (iLayoutPos)
            {
                case NGLP_Left:
                    switch (iNavDir)
                    {
                        case NAV_RIGHT:  iPos[0] = NGLP_Client;      iPos[1] = NGLP_Right; break;
                        case NAV_UP:     iPos[0] = NGLP_TopLeft;     break;
                        case NAV_DOWN:   iPos[0] = NGLP_BottomLeft;  break;
                    }
                    break;

                case NGLP_Top:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Client;      iPos[1] = NGLP_Bottom; break;
                        case NAV_LEFT:   iPos[0] = NGLP_TopLeft;     break;
                        case NAV_RIGHT:  iPos[0] = NGLP_TopRight;    break;
                    }
                    break;

                case NGLP_Right:
                    switch (iNavDir)
                    {
                        case NAV_LEFT:   iPos[0] = NGLP_Client;      iPos[1] = NGLP_Left; break;
                        case NAV_UP:     iPos[0] = NGLP_TopRight;    break;
                        case NAV_DOWN:   iPos[0] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_Bottom:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Client;      iPos[1] = NGLP_Top; break;
                        case NAV_LEFT:   iPos[0] = NGLP_BottomLeft;  break;
                        case NAV_RIGHT:  iPos[0] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_Client:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Top;         break;
                        case NAV_DOWN:   iPos[0] = NGLP_Bottom;      break;
                        case NAV_LEFT:   iPos[0] = NGLP_Left;        break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Right;       break;
                    }
                    break;

                case NGLP_TopLeft:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Left;        iPos[1] = NGLP_BottomLeft; break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Top;         iPos[1] = NGLP_TopRight;   break;
                    }
                    break;

                case NGLP_TopRight:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Right;       iPos[1] = NGLP_BottomRight; break;
                        case NAV_LEFT:   iPos[0] = NGLP_Top;         iPos[1] = NGLP_TopLeft;     break;
                    }
                    break;

                case NGLP_BottomLeft:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Left;        iPos[1] = NGLP_TopLeft;     break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Bottom;      iPos[1] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_BottomRight:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Right;       iPos[1] = NGLP_TopRight;   break;
                        case NAV_LEFT:   iPos[0] = NGLP_Bottom;      iPos[1] = NGLP_BottomLeft; break;
                    }
                    break;
            }

            for (int i = 0; i < 2; i++)
            {
                if (iPos[i] == -1)
                    return NULL;

                Element* peTile = _peTiles[iPos[i]];
                if (peTile)
                {
                    Element* peTo = peTile->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                    if (peTo)
                        return peTo;
                }
            }

            return NULL;
        }
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, bKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_LAYOUT_PUBLISHED_H_INCLUDED
#define DUI_LAYOUT_PUBLISHED_H_INCLUDED

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

#endif // DUI_LAYOUT_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\gridlayout.cpp ===
/*
 * Gridlayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duigridlayout.h"

namespace DirectUI
{

#define GetColumnFromIndex(cCols, i)  (i % cCols)
#define GetRowFromIndex(cCols, i)     (i / cCols)

////////////////////////////////////////////////////////
// GridLayout

#define CALCCOLS 0x00000001
#define CALCROWS 0x00000002

HRESULT GridLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 2:
        hr = Create(pParams[0], pParams[1], &pl);
        break;

    default:
        hr = Create(1, 1, &pl);
    }
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT GridLayout::Create(int iRows, int iCols, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    GridLayout* pgl = HNew<GridLayout>();
    if (!pgl)
        return E_OUTOFMEMORY;

    pgl->Initialize(iRows, iCols);

    *ppLayout = pgl;

    return S_OK;
}

// Not shareable by default

void GridLayout::Initialize(int iRows, int iCols)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _uRows = 0;
    _uCols = 0;
    _fBits = 0;
    _arRowMargins = NULL;
    _arColMargins = NULL;

    if (iRows == -1)
    {
        _fBits |= CALCROWS;
        if (iCols == -1)
        {
            DUIAssertForce("Cannot specify -1 for both the number of rows and the number of columns");
            _uRows = 1;
        }
    }
    else if (iRows <= 0)
    {
        DUIAssertForce("Number of rows cannot be zero or negative.");
        _uRows = 1;
    }
    else
        _uRows = (UINT) iRows;

    if (iCols == -1)
        _fBits |= CALCCOLS;
    else if (iCols <= 0)
    {
        DUIAssertForce("Number of columns cannot be zero or negative.");
        _uCols = 1;
    }
    else
        _uCols = (UINT) iCols;
}

GridLayout::~GridLayout()
{
    if (_arColMargins)
        HFree(_arColMargins);

    if (_arRowMargins)
        HFree(_arRowMargins);
}

////////////////////////////////////////////////////////
// Callbacks from clients

void GridLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (IsCacheDirty())
        return;

    Element* peChild;
    int cxOrg = cx;
    int cyOrg = cy;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT i = 0;

    UINT rows = GetCurrentRows(cChildren);
    UINT cols = GetCurrentCols(cChildren);

    if (!rows || !cols || ((rows > 1) && !_arRowMargins) || ((cols > 1) && !_arColMargins))
    {
        pvChildren->Release();
        return;
    }

    for (UINT r = 0; r < (rows - 1); r++)
    {
        cy -= _arRowMargins[r];
        if (cy < 0)
        {
            cy = 0;
            break;
        }
    }

    for (UINT c = 0; c < (cols - 1); c++)
    {
        cx -= _arColMargins[c];
        if (cx < 0)
        {
            cx = 0;
            break;
        }
    }

    UINT* xCols = (UINT*)HAllocAndZero(sizeof(UINT) * (cols + 1));
    if (!xCols)
    {
        pvChildren->Release();
        return;
    }

    for (c = 0; c <= cols; c++)
        xCols[c] = (cx * c) / cols;

    int yRow = 0;
    int yMarginOffset = 0;

    for (r = 0; r < rows; r++)
    {
        int yNextRow = (cy * (r + 1)) / rows;
        int xMarginOffset = 0;

        for (c = 0; c < cols; c++)
        {
            if (i < cChildren)
            {
                peChild = GetChildFromLayoutIndex(pec, i, peList);

                UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, xCols[c] + xMarginOffset, yRow + yMarginOffset, xCols[c+1] - xCols[c], yNextRow - yRow);
                if (c < (cols - 1))
                    xMarginOffset += _arColMargins[c];
            }

            i++;
        }
        yRow = yNextRow;
        if (r < (rows - 1))
            yMarginOffset += _arRowMargins[r];
    }

    HFree(xCols);
    
    pvChildren->Release();
}

SIZE GridLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    SetCacheDirty();

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT rows = GetCurrentRows(cChildren);
    UINT cols = GetCurrentCols(cChildren);

    if (_arColMargins)
    {
        HFree(_arColMargins);
        _arColMargins = NULL;
    }

    if (_arRowMargins)
    {
        HFree(_arRowMargins);
        _arRowMargins = NULL;
    }

    if (!rows || !cols)
    {
        pvChildren->Release();
        SIZE s = { 0, 0 };
        return s;
    }

    if (cols > 1)
    {
        _arColMargins = (int*)HAllocAndZero(sizeof(int) * (cols - 1));
        if (!_arColMargins)
        {
            pvChildren->Release();
            SIZE s = { 0, 0 };
            return s;
        }
    }

    if (rows > 1)
    {
        _arRowMargins = (int*)HAllocAndZero(sizeof(int) * (rows - 1));
        if (!_arRowMargins)
        {
            pvChildren->Release();
            SIZE s = { 0, 0 };
            return s;
        }
    }

    UINT r;
    UINT c;
    UINT i = 0;

    if (cChildren == 0)
        goto EndMarginLoop;

    for (c = 0; c < (cols - 1); c++)
        _arColMargins[c] = -INT_MAX;


    for (r = 0; r < rows; r++)
    {
        if (r < (rows - 1))
            _arRowMargins[r] = -INT_MAX;

        for (c = 0; c < cols; c++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            Value* pv;
            const RECT* prcChildMargin = peChild->GetMargin(&pv); 
            if ((c > 0) && (_arColMargins[c - 1] < prcChildMargin->left))
                _arColMargins[c - 1] = prcChildMargin->left;
            if ((c < (cols - 1)) && (_arColMargins[c] < prcChildMargin->right))
                _arColMargins[c] = prcChildMargin->right;
            if ((r > 0) && (_arRowMargins[r - 1] < prcChildMargin->top))
                _arRowMargins[r - 1] = prcChildMargin->top;
            if ((r < (rows - 1)) && (_arRowMargins[r] < prcChildMargin->bottom))
                _arRowMargins[r] = prcChildMargin->bottom;
            pv->Release();

            i++;

            if (i == cChildren)
            {
                if (r == 0)
                {
                    while (c < (cols - 1))
                        _arColMargins[c++] = 0;
                }
                goto EndMarginLoop;                
            }
        }
    }

EndMarginLoop:
    SIZE sizeDesired = { 0, 0 };

    for (r = 0; r < (rows - 1); r++)
    {
        sizeDesired.cy += _arRowMargins[r];
        cyConstraint -= _arRowMargins[r];
        if (cyConstraint < 0)
        {
            sizeDesired.cy -= cyConstraint;
            cyConstraint = 0;
            break;
        }
    }
    for (c = 0; c < (cols - 1); c++)
    {
        sizeDesired.cx += _arColMargins[c];
        cxConstraint -= _arColMargins[c];
        if (cxConstraint < 0)
        {
            sizeDesired.cx += cxConstraint;
            cxConstraint = 0;
            break;
        }
    }

    UINT* cxCols = (UINT*)HAllocAndZero(sizeof(UINT) * cols);
    UINT* cyRows = (UINT*)HAllocAndZero(sizeof(UINT) * rows);

    UINT* cxColConstraints = (UINT*)HAllocAndZero(sizeof(UINT) * cols);

    if (!cxCols || !cyRows || !cxColConstraints)
    {
        if (cxCols)
            HFree(cxCols);
        if (cyRows)
            HFree(cyRows);
        if (cxColConstraints)
            HFree(cxColConstraints);

        pvChildren->Release();
        SIZE s = { 0, 0 };
        return s;
    }

    i = 0;

    int cx = cxConstraint / cols;
    cxColConstraints[0] = cx;
    for (c = 1; c < cols; c++)
    {
        cxColConstraints[c] = (int) ((((__int64) cxConstraint * (c + 1)) / cols)) - cx;
        cx += cxColConstraints[c];
    }

    int cy = cyConstraint / rows;
    int cyRowConstraint = cy;

    for (r = 0; r < rows; r++)
    {
        for (c = 0; c < cols; c++)
        {
            if (i == cChildren)
            {
                if (rows == 1)
                {
                    while (c < cols)
                        cxCols[c++] = 0;
                }
                goto EndLoop;                
            }

            peChild = GetChildFromLayoutIndex(pec, i, peList);
            SIZE sizeChild = peChild->_UpdateDesiredSize(cxColConstraints[c], cyRowConstraint, psrf);

            if (cxCols[c] < (UINT) sizeChild.cx)
                cxCols[c] = (UINT) sizeChild.cx;
            if (cyRows[r] < (UINT) sizeChild.cy)
                cyRows[r] = (UINT) sizeChild.cy;

            i++;
        }
        cyRowConstraint = (int) ((((__int64) cyConstraint * (r + 2)) / rows)) - cy;
        cy += cyRowConstraint;
    }

EndLoop:
    int nMax = 0;
    UINT cyMax = 0;
    for (r = 0; r < rows; r++)
    {
        if (cyMax < cyRows[r])
        {
            cyMax = cyRows[r];
            nMax = 1;
        }
        else if (cyMax == cyRows[r])
            nMax++;
    }
    
    cy = ((cyMax - 1) * rows) + nMax;
    int cyMaxDesired = cyMax * rows;

    while (cy < cyMaxDesired)
    {
        int nRunMax = nMax;
        UINT cyRun = cy / rows;
        UINT cySum = cyRun;
        for (UINT r = 0; r < rows; r++)
        {
            if (cyRows[r] == cyMax)
            {
                if (cyRun < cyMax)
                    break;

                if (--nRunMax == 0)
                    break;
            }
            UINT cyNext = (int) ((((__int64) cy * (r + 2)) / rows));
            cyRun = cyNext - cySum;
            cySum = cyNext;
        }
        if (nRunMax == 0)
            break;
        cy++;
    }


    nMax = 0;
    UINT cxMax = 0;
    for (c = 0; c < cols; c++)
    {
        if (cxMax < cxCols[c])
        {
            cxMax = cxCols[c];
            nMax = 1;
        }
        else if (cxMax == cxCols[c])
            nMax++;
    }
    
    cx = ((cxMax - 1) * cols) + nMax;
    int cxMaxDesired = cxMax * cols;

    while (cx < cxMaxDesired)
    {
        int nRunMax = nMax;
        UINT cxRun = cx / cols;
        UINT cxSum = cxRun;
        for (UINT c = 0; c < cols; c++)
        {
            if (cxCols[c] == cxMax)
            {
                if (cxRun < cxMax)
                    break;

                if (--nRunMax == 0)
                    break;
            }
            UINT cxNext = (int) ((((__int64) cx * (c + 2)) / cols));
            cxRun = cxNext - cxSum;
            cxSum = cxNext;
        }
        if (nRunMax == 0)
            break;
        cx++;
    }

    HFree(cxColConstraints);
    HFree(cxCols);
    HFree(cyRows);

    pvChildren->Release();

    DUIAssert(cx <= cxConstraint, "Desired width is over constraint");
    DUIAssert(cy <= cyConstraint, "Desired width is over constraint");

    sizeDesired.cx += cx;
    sizeDesired.cy += cy;

    ClearCacheDirty();

    return sizeDesired;
}

UINT GridLayout::GetCurrentRows(Element* pec)
{
    return (_fBits & CALCROWS) ? GetCurrentRows(GetLayoutChildCount(pec)) : _uRows;
}

UINT GridLayout::GetCurrentRows(int c)
{
    if (_fBits & CALCROWS)
        return (_uCols == 1) ? c : (c + (_uCols - 1)) / _uCols;
    return _uRows;
}

UINT GridLayout::GetCurrentCols(Element* pec)
{
    return (_fBits & CALCCOLS) ? GetCurrentCols(GetLayoutChildCount(pec)) : _uCols;
}

UINT GridLayout::GetCurrentCols(int c)
{
    if (_fBits & CALCCOLS)
        return (_uRows == 1) ? c : (c + (_uRows - 1)) / _uRows;
    return _uCols;
}

Element* GridLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        int cChildren = GetLayoutChildCount(pec);

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            int cCols = GetCurrentCols(cChildren);
            int cRows = GetCurrentRows(cChildren);

            int cOuter, cInner;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = (cCols * cRows) - 1;
            }

            if (iNavDir & NAV_VERTICAL)
            {
                cOuter = cRows;
                cInner = cCols;
            }
            else
            {
                cOuter = cCols;
                cInner = cRows;

                iInc *= cCols;
            }

            for (int i = 0; i < cOuter; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < cInner; j++, iTile += iInc)
                {
                    if (iTile >= cChildren)
                        continue;

                    if (ns.Try(GetChildFromLayoutIndex(pec, iTile, peList), iNavDir, pnr, fKeyableOnly))
                        break;
                }

                if (ns.peWinner)
                {
                    pvChildren->Release();
                    return ns.peWinner;
                }

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * cCols;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            pvChildren->Release();

            return NULL;
        }
        else // we're navigating from a child within container
        {
            int i = GetLayoutIndexFromChild(pec, peFrom);
            int iInc;
            int iEnd;
            int cCols = GetCurrentCols(cChildren);

            if (iNavDir & NAV_VERTICAL)
            {
                iInc = cCols;
                int iRow = GetRowFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + (((GetCurrentRows(cChildren) - 1) - iRow) * cCols);
                else
                    iEnd = i - (iRow * cCols);
            }
            else
            {
                iInc = 1;
                int iCol = GetColumnFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + ((cCols - 1) - iCol);
                else
                    iEnd = i - iCol;
            }

            if (!(iNavDir & NAV_FORWARD))
                iInc *= -1;

            if (i != iEnd)
            {
                do 
                {
                    i += iInc;

                    Element* peChild = GetChildFromLayoutIndex(pec, i, peList);
                    if (!peChild)
                        continue;

                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

                    if (peTo)
                    {
                        pvChildren->Release();
                        return peTo;
                    }
                }
                while (i != iEnd);
            }
        }

        pvChildren->Release();
        return NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\rowlayout.cpp ===
/*
 * RowLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiRowLayout.h"

namespace DirectUI
{

//
// NOTE: RowLayout is NOT yet thread-safe (access to _arPairs).
// Do not use it in applications where more than one thread uses RowLayout.
//

////////////////////////////////////////////////////////
// RowLayout

struct idLayoutPair
{
    int id;
    RowLayout* prl;
    Value* pv;
};

static DynamicArray<idLayoutPair>* _arPairs = NULL;

//
// for now, we are tracking all instances of RowLayout, using an integer id as a parameter to signal *collaboration*
// i.e. 5 elements that want the same instance of RowLayout will pass the same id in their instantiation calls
//
// ideally, the parser will give us this functionality with:
// <RowLayout res:id=foo res:shared=true />
//
// <Element Layout=res:foo />
// <Element Layout=res:foo />
//
HRESULT RowLayout::InternalCreate(UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    RowLayout* prl = HNew<RowLayout>();

    if (!prl)
        return E_OUTOFMEMORY;

    prl->Initialize(uXAlign, uYAlign);

    *ppLayout = prl;

    return S_OK;
}

HRESULT RowLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    int idShare = (dNumParams) ? pParams[0] : -1;

    if (idShare >= 0)
    {
        int cPairs = 0;
        if (_arPairs)
            cPairs = _arPairs->GetSize();
        for (int i = 0; i < cPairs; i++)
        {
            idLayoutPair idlp = _arPairs->GetItem(i);
            if (idlp.id == idShare)
            {
                *ppValue = idlp.pv;
                (*ppValue)->AddRef();
                return S_OK;
            }
        }

        if (!_arPairs)
        {
            DynamicArray<idLayoutPair>::Create(0, false, &_arPairs);
            if (!_arPairs)
                return E_OUTOFMEMORY;
        }
    }

    Layout* pl;
    UINT uXAlign = ALIGN_LEFT;
    UINT uYAlign = ALIGN_TOP;
    if (dNumParams > 1)
    {
        uXAlign = (UINT) pParams[1];
        if (dNumParams > 2)
            uYAlign = (UINT) pParams[2];
    }
    HRESULT hr = InternalCreate(uXAlign, uYAlign, &pl);

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }

    if (idShare >= 0)
    {
        idLayoutPair idlp;
        idlp.id = idShare;
        idlp.prl = (RowLayout*) pl;
        idlp.pv = *ppValue;
        _arPairs->Add(idlp);
    }

    return S_OK;
}

HRESULT RowLayout::Create(int idShare, UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout)
{
    if (idShare >= 0)
    {
        int cPairs = _arPairs ? _arPairs->GetSize() : 0;
        for (int i = 0; i < cPairs; i++)
        {
            idLayoutPair idlp = _arPairs->GetItem(i);
            if (idlp.id == idShare)
            {
                *ppLayout = idlp.prl;
                return S_OK;
            }
        }

        *ppLayout = NULL;


        if (!_arPairs)
        {
            DynamicArray<idLayoutPair>::Create(0, false, &_arPairs);
            if (!_arPairs)
                return E_OUTOFMEMORY;
        }
    }

    Layout* pl;
    HRESULT hr = InternalCreate(uXAlign, uYAlign, &pl);

    if (FAILED(hr))
        return hr;

    if (idShare >= 0)
    {
        idLayoutPair idlp;
        idlp.id = idShare;
        idlp.prl = (RowLayout*) pl;
        idlp.pv = NULL;
        _arPairs->Add(idlp);
    }

    *ppLayout = pl;

    return S_OK;
}

void RowLayout::Initialize(UINT uXAlign, UINT uYAlign)
{
    // Initialize base
    Layout::Initialize();    

    _uXAlign = uXAlign;
    _uYAlign = uYAlign;

    _fRecalc = TRUE;
    _arpeClients = NULL;
    _arxCols = NULL;
    _cCols = 0;
}

RowLayout::~RowLayout()
{
    if (_arpeClients)
        _arpeClients->Destroy();
    // how do we know when to destroy _arPairs?
    //    if (_arPairs->GetSize() == 0)
    //        _arPairs->Destroy();
}

// todo: use a dynamic array -- for arPairs as well
void RowLayout::Attach(Element* pec)
{
    if (!_arpeClients)
    {
        DynamicArray<Element*>::Create(0, false, &_arpeClients);
        if (!_arpeClients)
            return; //todo -- should return an hresult of E_OUTOFMEMORY;
    }

    DUIAssert(_arpeClients->GetIndexOf(pec) == -1, "this client is already attached to this layout");

    _arpeClients->Add(pec);
}

void RowLayout::Detach(Element* pec)
{
    if (_arpeClients)
    {
        int dIgnIdx = _arpeClients->GetIndexOf(pec);
        if (dIgnIdx != -1)
            _arpeClients->Remove(dIgnIdx);
    }

    // todo: _pdaIgnore -- has to be per use
}

////////////////////////////////////////////////////////
// Callbacks from clients

void RowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (IsCacheDirty())
        return;

    _fRecalc = TRUE;
    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    int cxRemaining = cx;
    int xLeft = 0;
    int xRight;
    for (UINT i = 0; i < cChildren; i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        int cxCol;
        if (cxRemaining)
        {
            xRight = _arxCols[i];
            cxCol = xRight - xLeft;
            if (cxCol > cxRemaining)
                cxCol = cxRemaining;

            cxRemaining -= cxCol;
        }
        else
        {
            cxCol = 0;
            xRight = xLeft;
        }
        SIZE size = *(peChild->GetDesiredSize());
        int yChild = 0;
        int xChild = xLeft;
        int cyChild;
        if (_uXAlign != ALIGN_JUSTIFY)
        {
            if (_uXAlign != ALIGN_LEFT)
            {
                int xDelta = cxCol - size.cx;
                if (_uXAlign == ALIGN_RIGHT)
                    xChild += xDelta;
                else
                    xChild += xDelta / 2;
            }
            cxCol = size.cx;
        }
        if (_uYAlign != ALIGN_JUSTIFY)
        {
            if (_uXAlign != ALIGN_LEFT)
            {
                int yDelta = cy - size.cy;
                if (_uXAlign == ALIGN_RIGHT)
                    yChild += yDelta;
                else
                    yChild += yDelta / 2;
            }
            cyChild = size.cy;
        }
        else
            cyChild = cy;


        UpdateLayoutRect(pec, cx, cy, peChild, xChild, yChild, cxCol, cyChild);
        xLeft = xRight;
    }

    pvChildren->Release();
}

struct ClientInfo
{
    UINT cElements;
    ElementList* pel;   
    Value* pvValue;
    Element* peCur;
    int cyMax;
};

// for first column, loop through all clients
//   collect left margin and right margin
// 
// for each column after the first column, loop through all clients
// collect information on the max left margin and the max right margin
// move xRight = xLeft 
//
// i'm thinking that i need to calc right margin as i go -- but that's not true
// because all I'll do is subtract off the left margin, and if there's no room left
// then that means that the next component just doesn't show up -- translation: the
// right margin only matters when there's an element on the right
//

SIZE RowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    SetCacheDirty();

    if (!_fRecalc)
    {
        SIZE size = _sizeDesired;
        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;

        ClearCacheDirty();
            
        return size;
    }

    _fRecalc = FALSE;

    UINT uOldCols = _cCols;
    _cCols = 0;

    int iThisClient = -1;

    UINT cClients = (UINT) _arpeClients->GetSize();
    ClientInfo* arci = (ClientInfo*) _alloca(sizeof(ClientInfo) * cClients);

    for (UINT i = 0; i < cClients; i++)
    {
        Element* peClient = _arpeClients->GetItem(i);
        if (peClient == pec)
            iThisClient = i;

        // GLCC is returning -1 here -- bogus !
        int cElements = GetLayoutChildCount(peClient);
        if ((int) _cCols < cElements)
            _cCols = cElements;
        arci[i].cElements = cElements;
        arci[i].pel = peClient->GetChildren(&(arci[i].pvValue));
        arci[i].cyMax = 0;
    }

    if ((uOldCols != _cCols) || !_arxCols)
    {
        if (_arxCols)
            HFree(_arxCols);
        _arxCols = (UINT*) HAllocAndZero(sizeof(UINT) * _cCols);

        if (!_arxCols)
        {
            SIZE size = {0,0};
            return size;
        }
    }

    int xLeft = -INT_MAX;
    int xRight = -INT_MAX;

    int x = 0;

    for (UINT col = 0; col < _cCols; col++)
    {
        for (i = 0; i < cClients; i++)
        {
            if (arci[i].cElements > col)
            {
                Element* peChild = GetChildFromLayoutIndex(_arpeClients->GetItem(i), col, arci[i].pel);
                arci[i].peCur = peChild;
                
                Value* pv;
                const RECT* prcChildMargin = peChild->GetMargin(&pv); 
                if (xLeft < prcChildMargin->left)
                    xLeft = prcChildMargin->left;
                if (xRight < prcChildMargin->right)
                    xRight = prcChildMargin->right;
                pv->Release();
            }
            else
                arci[i].peCur = NULL; 
        }

        if (col > 0)
        {
            if (xLeft > cxConstraint)
                xLeft = cxConstraint;

            x += xLeft;
            cxConstraint -= xLeft;

            _arxCols[col - 1] = x;
        }

        int cx = 0;
        for (i = 0; i < cClients; i++)
        {
            Element* peCur = arci[i].peCur;
            if (peCur)
            {
                SIZE sizeChild = peCur->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

                if (arci[i].cyMax < sizeChild.cy)
                    arci[i].cyMax = sizeChild.cy;
            
                if (cx < sizeChild.cx)
                    cx = sizeChild.cx;
            }
        }

        if (cx > cxConstraint)
            cx = cxConstraint;

        x += cx;
        cxConstraint -= cx;

        xLeft = xRight;
        xRight = -INT_MAX;
    }

    _arxCols[col - 1] = x;

    _sizeDesired.cx = x;
    _sizeDesired.cy = arci[iThisClient].cyMax;

    for (i = 0; i < cClients; i++)
        arci[i].pvValue->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

Element* RowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
/*
        int cChildren = GetLayoutChildCount(pec);

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            int cCols = GetCurrentCols(cChildren);
            int cRows = GetCurrentRows(cChildren);

            int cOuter, cInner;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = (cCols * cRows) - 1;
            }

            if (iNavDir & NAV_VERTICAL)
            {
                cOuter = cRows;
                cInner = cCols;
            }
            else
            {
                cOuter = cCols;
                cInner = cRows;

                iInc *= cCols;
            }

            for (int i = 0; i < cOuter; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < cInner; j++, iTile += iInc)
                {
                    if (iTile >= cChildren)
                        continue;

                    if (ns.Try(GetChildFromLayoutIndex(pec, iTile, peList), iNavDir, pnr, fKeyableOnly))
                        break;
                }

                if (ns.peWinner)
                {
                    pvChildren->Release();
                    return ns.peWinner;
                }

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * cCols;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            pvChildren->Release();

            return NULL;
        }
        else // we're navigating from a child within container
        {
            int i = GetLayoutIndexFromChild(pec, peFrom);
            int iInc;
            int iEnd;
            int cCols = GetCurrentCols(cChildren);

            if (iNavDir & NAV_VERTICAL)
            {
                iInc = cCols;
                int iRow = GetRowFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + (((GetCurrentRows(cChildren) - 1) - iRow) * cCols);
                else
                    iEnd = i - (iRow * cCols);
            }
            else
            {
                iInc = 1;
                int iCol = GetColumnFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + ((cCols - 1) - iCol);
                else
                    iEnd = i - iCol;
            }

            if (!(iNavDir & NAV_FORWARD))
                iInc *= -1;

            if (i != iEnd)
            {
                do 
                {
                    i += iInc;

                    Element* peChild = GetChildFromLayoutIndex(pec, i, peList);
                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

                    if (peTo)
                    {
                        pvChildren->Release();
                        return peTo;
                    }
                }
                while (i != iEnd);
            }
        }

        pvChildren->Release();
*/
        return NULL;
    }
    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\sources.inc ===
!IF 0

    DirectUI Layout Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\borderlayout.cpp       \
        ..\filllayout.cpp         \
        ..\flowlayout.cpp         \
        ..\gridlayout.cpp         \
        ..\ninegridlayout.cpp     \
        ..\rowlayout.cpp          \
        ..\verticalflowlayout.cpp \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxlayout.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\stdafxlayout.cpp ===
/*
 * stdafxlayout.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\makefile.inc ===
#
# Parser generation
#

Parse.cpp: parse.y
    set bison_simple=$(PARSERTOOLS)\Bison.skl 
    $(PARSERTOOLS)\bison -l -o$@ -d $**

Scan.cpp: scan.l
    $(PARSERTOOLS)\flex -B -L -o$@ -S$(PARSERTOOLS)\flex.skl $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_LAYOUT_STDAFX_H_INCLUDED
#define DUI_LAYOUT_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_LAYOUT_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\layout\verticalflowlayout.cpp ===
/*
 * Verticalflowlayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiverticalflowlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// vertical flow layout

SIZE VerticalFlowLayout::g_sizeZero = { 0, 0 };

// ----------------------------------------------------------------------------------------------------------------
//
//  method overview:
//    public:
//      DoLayout          -- responsible for doing all of the alignment work and placing the elements
//      UpdateDesiredSize -- simply calls BuildCacheInfo
// 
//    protected:
//      BuildCacheInfo    -- the workhorse of this layout -- builds up the line array and per-line element arrays
//
// ----------------------------------------------------------------------------------------------------------------

HRESULT VerticalFlowLayout::Create(int dNumParams, int* pParams, Value** ppValue)  // For parser
{
    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 1:
        hr = Create(pParams[0] ? true : false, ALIGN_LEFT, ALIGN_CENTER, ALIGN_TOP, &pl);
        break;

    case 2:
        hr =  Create(pParams[0] ? true : false, pParams[1], ALIGN_CENTER, ALIGN_TOP, &pl);
        break;

    case 3:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], ALIGN_TOP, &pl);
        break;

    case 4:
        hr =  Create(pParams[0] ? true : false, pParams[1], pParams[2], pParams[3], &pl);
        break;

    default:
        hr = Create(true, ALIGN_LEFT, ALIGN_CENTER, ALIGN_TOP, &pl);
    }
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT VerticalFlowLayout::Create(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign, Layout** ppLayout)
{
    *ppLayout = NULL;

    VerticalFlowLayout* pvfl = HNew<VerticalFlowLayout>();
    if (!pvfl)
        return E_OUTOFMEMORY;

    pvfl->Initialize(fWrap, uXAlign, uXLineAlign, uYLineAlign);

    *ppLayout = pvfl;

    return S_OK;
}

void VerticalFlowLayout::Initialize(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _fWrap = fWrap;
    _uXLineAlign = uXLineAlign;
    _uYLineAlign = uYLineAlign;
    _uXAlign = uXAlign;
    _arLines = NULL;
    _cLines = 0;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
    _sizeLastConstraint.cx = 0;
    _sizeLastConstraint.cy = 0;
}

VerticalFlowLayout::~VerticalFlowLayout()
{
    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].aryElement)
                HFree(_arLines[k].aryElement);
        }

        HFree(_arLines);
    }
}

////////////////////////////////////////////////////////
// Callbacks from clients

void VerticalFlowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (!_cLines || IsCacheDirty())
        return;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    VLINE *plCur = _arLines + (_cLines - 1);

    int xStart = 0;
    int cxContent = 0;

    if (_uXAlign != ALIGN_LEFT)
    {
        cxContent = plCur->x + plCur->cx;
        int cxDelta = cx - cxContent;

        if (_uXAlign == ALIGN_CENTER)
            xStart = cxDelta / 2;
        else if (_uXAlign == ALIGN_RIGHT)
            xStart = cxDelta;
    }

    plCur = _arLines;
    UINT i = 0;

    for (UINT uLine = 0; uLine < _cLines; uLine++)
    {
        int yStart = 0;

        if (_uYLineAlign == ALIGN_CENTER)
            yStart = (cy - plCur->cy) / 2;
        else if (_uYLineAlign == ALIGN_BOTTOM)
            yStart = cy - plCur->cy;

        int xLine = plCur->x;
        int cxLine = plCur->cx;

        if ((_uXAlign == ALIGN_JUSTIFY) && (cxContent < cx))
        {
            if (!cxContent)
            {
                // zero desired width -- so spread equally among lines
                xLine = cx * uLine / _cLines;
                cxLine = (cx * (uLine + 1) / _cLines) - xLine;
            }
            else
            {
                cxLine = cxLine * cx / cxContent;
                xLine  = xLine  * cx / cxContent;
            }
        }

        int xElement;
        int yElement;
        
        for (UINT uElement = 0; uElement < plCur->cElements; uElement++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
    
            SIZE size = *(peChild->GetDesiredSize());

            //yElement = (uElement == 0) ? 0 : plCur->aryElement[uElement - 1];
            yElement = 0;
            if (uElement != 0 && plCur->aryElement)
                yElement = plCur->aryElement[uElement - 1];

            xElement = 0;
            if (_uXLineAlign == ALIGN_CENTER)
                xElement = (cxLine - size.cx) / 2;
            else if (_uXLineAlign == ALIGN_RIGHT)
                xElement = cxLine - size.cx;
            else if (_uXLineAlign == ALIGN_JUSTIFY)
                size.cx = cxLine;

            if ((_uYLineAlign == ALIGN_JUSTIFY) && (plCur->cy < (UINT) cy))
            {
                size.cy  = plCur->cy ? (size.cy  * cy / plCur->cy) : 0;
                yElement = plCur->cy ? (yElement * cy / plCur->cy) : 0;
            }

            xElement += xStart + xLine;
            yElement += yStart;

            // constrain it to bounds of layout (0,0)-(cx,cy)
            if (xElement < 0)
            {
                size.cx += xElement;
                xElement = 0;
                if (size.cx < 0)
                    size.cx = 0;
            }
            
            if ((xElement + size.cx) > cx)
            {
                size.cx = cx - xElement;
                if (size.cx < 0)
                    size.cx = 0;
            }

            if (yElement < 0)
            {
                size.cy += yElement;
                yElement = 0;
                if (size.cy < 0)
                    size.cy = 0;
            }

            if ((yElement + size.cy) > cy)
            {
                size.cy = cy - yElement;
                if (size.cy < 0)
                    size.cy = 0;
            }

            UpdateLayoutRect(pec, cx, cy, peChild, xElement, yElement, size.cx, size.cy);

            i++;
        }
        plCur++;
    }

    // this code is only ever hit when the line array does not include all layout elements in the container;
    // currently, this only happens when wrapping is off.
    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cx, cy, peChild, 0, 0, 0, 0);
    }

    pvChildren->Release();
}

SIZE VerticalFlowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    return BuildCacheInfo(pec, cxConstraint, cyConstraint, psrf, false);
}
        
SIZE VerticalFlowLayout::BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize)
{
    UNREFERENCED_PARAMETER(fRealSize);

    SetCacheDirty();

    /*
    if (_arLines != NULL)
    {
        // check to make sure we really have to recalc

        if (cxConstraint == sizeLastConstraint.cx)
            // if cxConstraint doesn't change, then the calculation stays the same
            return _sizeDesired;
    }
    */
    // I'm saving previous constraints to be able to optimize this stage.
    // When I get flags coming into UpdateDesiredSize, I can get rid of this.
    _sizeLastConstraint.cx = cxConstraint;
    _sizeLastConstraint.cy = cyConstraint;

    UINT cChildren = GetLayoutChildCount(pec);

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called

    int cxCur = 0;
    int cyCur = 0;
    UINT i = 0;

    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].aryElement)
                HFree(_arLines[k].aryElement);
        }

        HFree(_arLines);
    }

    _cLines = 0;

    // Allocate space for the data for the initial line
    _arLines = (VLINE*)HAllocAndZero(sizeof(VLINE) * 1);
    if (!_arLines)
    {
        pvChildren->Release();
        return g_sizeZero;
    }

    int cyMax = 0;

    int cyRealConstraint = cyConstraint;

    int iLeftMargin;
    int iTopMargin;
    int iRightMargin;
    int iBottomMargin;

    int iLineLeftMargin = 0;
    int iLineRightMargin = 0;

    int iPrevLineRightMargin = 0;

    while (i < cChildren)
    {
        cyCur = 0;
        int cxMax;
        int iMargin = 0;

        _cLines++;
        if (_cLines > 1)
        {
            // Allocate space for the data for subsequent lines (space for the first line was alloc'ed outside of this loop
            VLINE* arNewLines = (VLINE*)HReAllocAndZero(_arLines, sizeof(VLINE) * _cLines);
            if (!arNewLines)
            {
                pvChildren->Release();
                HFree(_arLines);
                _arLines = NULL;
                return g_sizeZero;
            }

            _arLines = arNewLines;
        }

        // Initialize line computation with information from first element on line 
        VLINE *plCur = _arLines + (_cLines - 1);

        peChild = GetChildFromLayoutIndex(pec, i, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        Value* pv;
        const RECT* prect = peChild->GetMargin(&pv); 
        iLeftMargin   = prect->left;
        iTopMargin    = prect->top;
        iRightMargin  = prect->right;
        iBottomMargin = prect->bottom;
        pv->Release();
        
        plCur->x = cxCur;

        plCur->cElements = 1;
        plCur->iStart = i;
        plCur->aryElement = NULL;

        if (_fWrap)
        {
            // potential for more lines -- keep track of max left and right margins for this line
            if (_cLines > 1)
            {
                if ((_uXLineAlign == ALIGN_LEFT) || (_uXLineAlign == ALIGN_JUSTIFY))
                    // iLineLeftMargin is a running total of max left margin
                    iLineLeftMargin = iLeftMargin;
                else if (_uXLineAlign == ALIGN_CENTER)
                    // iLineLeftMargin is a running total of max thickness / 2 + left margin
                    // (add one because of rounding error only for left)
                    iLineLeftMargin = ((sizeChild.cx + 1) / 2) + iLeftMargin;
                else // _uXLineAlign == ALIGN_RIGHT
                    // iLineLeftMargin is a running total of max thickness + left margin
                    iLineLeftMargin = sizeChild.cx + iLeftMargin;
            }

            if ((_uXLineAlign == ALIGN_RIGHT) || (_uXLineAlign == ALIGN_JUSTIFY))
                // iLineRightMargin is a running total of max right margin
                iLineRightMargin = iRightMargin;
            else if (_uXLineAlign == ALIGN_CENTER)
                // iLineRightMargin is a running total of max thickness / 2 + right margin
                iLineRightMargin = (sizeChild.cx / 2) + iRightMargin;
            else // _uXLineAlign == ALIGN_LEFT
                // iLineRightMargin is a running total of max thickness + right margin
                iLineRightMargin = sizeChild.cx + iRightMargin;
        }

        cxMax = sizeChild.cx;
        cyCur += sizeChild.cy;
        iMargin = iBottomMargin;

        // step to next element
        i++;

        // Line loop -- loop until we go beyond length of line
        while (i < cChildren)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

            const RECT* prect = peChild->GetMargin(&pv); 
            iLeftMargin   = prect->left;
            iTopMargin    = prect->top;
            iRightMargin  = prect->right;
            iBottomMargin = prect->bottom;
            pv->Release();

            // use the max margin value between the bottom margin of the preceding element and
            // the top margin of this element
            if (iMargin < iTopMargin)
                iMargin = iTopMargin;

            if (_fWrap && (cyCur + iMargin + sizeChild.cy > cyRealConstraint))
                // we're wrapping and we went beyond length of line -- break out of this loop
                break;

            if (plCur->cElements == 1)
            {
                plCur->aryElement = (UINT*)HAllocAndZero(sizeof(UINT));
                if (!plCur->aryElement)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }
            }
            else
            {
                UINT* pNew = (UINT*)HReAllocAndZero(plCur->aryElement, sizeof(UINT) * plCur->cElements);
                if (!pNew)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }

                plCur->aryElement = pNew;
            }

            plCur->aryElement[plCur->cElements - 1] = cyCur + iMargin;
            plCur->cElements++;

            // keep track of the maximum thickness of the elements on this line
            if (cxMax < sizeChild.cx)
                cxMax = sizeChild.cx;

            cyCur += iMargin + sizeChild.cy;

            if (_fWrap)
            {
                // potential for more lines -- keep track of max top and bottom margins for this line
                if (_cLines > 1)
                {
                    // keep track of the maximum left margin on this line
                    if ((_uXLineAlign == ALIGN_LEFT) || (_uXLineAlign == ALIGN_JUSTIFY))
                        // iLineLeftMargin is a running total of max left margin
                        iMargin = iLeftMargin;
                    else if (_uXLineAlign == ALIGN_CENTER)
                        // iLineLeftMargin is a running total of max thickness / 2 + left margin
                        // (add one because of rounding error only for left)
                        iMargin = ((sizeChild.cx + 1) / 2) + iLeftMargin;
                    else // _uXLineAlign == ALIGN_RIGHT
                        // iLineTopMargin is a running total of max thickness + left margin
                        iMargin = sizeChild.cx + iLeftMargin;

                    if (iLineLeftMargin < iMargin)
                        iLineLeftMargin = iMargin;
                }

                // keep track of the maximum right margin on this line
                if ((_uXLineAlign == ALIGN_RIGHT) || (_uXLineAlign == ALIGN_JUSTIFY))
                    // iLineRightMargin is a running total of max right margin
                    iMargin = iRightMargin;
                else if (_uXLineAlign == ALIGN_CENTER)
                    // iLineRightMargin is a running total of max thickness / 2 + right margin
                    iMargin = (sizeChild.cx / 2) + iRightMargin;
                else // _uXLineAlign == ALIGN_LEFT
                    // iLineRightMargin is a running total of max thickness + right margin
                    iMargin = sizeChild.cx + iRightMargin;

                if (iLineRightMargin < iMargin)
                    iLineRightMargin = iMargin;
            }

            iMargin = iBottomMargin;
            i++;
        }

        if (cyMax < cyCur)
            cyMax = cyCur;

        if (_fWrap)
        {
            // adjust margin running totals to reflect residual margin --
            // the bummer here is that we have to nuke negative margins because otherwise we're messed up
            if (_uXLineAlign == ALIGN_CENTER)
            {
                iLineLeftMargin -= (cxMax + 1) / 2;
                if (iLineLeftMargin < 0)
                    iLineLeftMargin = 0;

                iLineRightMargin -= cxMax / 2;
                if (iLineRightMargin < 0)
                    iLineRightMargin = 0;
            }
            else if (_uXLineAlign == ALIGN_RIGHT)
            {
                iLineLeftMargin -= cxMax;
                if (iLineLeftMargin < 0)
                    iLineLeftMargin = 0;
            }
            else if (_uXLineAlign == ALIGN_LEFT)
            {
                iLineRightMargin -= cxMax;
                if (iLineRightMargin < 0)
                    iLineRightMargin = 0;
            }

            if (_cLines > 1)
            {
                // account for margins between lines

                if (iPrevLineRightMargin < iLineLeftMargin)
                    iPrevLineRightMargin = iLineLeftMargin;

                // iPrevLineRightMargin is now the max margin between the previous line and this line
                plCur->x += iPrevLineRightMargin;
                cxCur += iPrevLineRightMargin;
            }

            // save off this line's right margin to compare with the next line's resulting left margin
            iPrevLineRightMargin = iLineRightMargin;
        }

        cxCur += cxMax;

        plCur->cy = cyCur;
        plCur->cx = cxMax;
    }

    _sizeDesired.cy = (cyMax < cyConstraint) ? cyMax : cyConstraint;
    _sizeDesired.cx = (cxCur < cxConstraint) ? cxCur : cxConstraint;

    pvChildren->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

int VerticalFlowLayout::GetLine(Element* pec, Element* pe)
{
    int iChild = GetLayoutIndexFromChild(pec, pe);

    if (iChild >= 0)
    {
        UINT uChild = (UINT) iChild;

        for (UINT i = 0; i < _cLines; i++)
        {
            VLINE* pLine = _arLines + i;
            if (uChild < (pLine->iStart + pLine->cElements))
                return i;
        }
    }
    return -1;
}

Element* VerticalFlowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        if (!_cLines || IsCacheDirty())
            return NULL;

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        NavScoring ns;

        ns.Init(pec, iNavDir, pnr);

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            bool fForward = ((iNavDir & NAV_FORWARD) != 0);

            if (!(iNavDir & NAV_VERTICAL))
            {
                int l = fForward ? 0 : (_cLines - 1);
                VLINE* pLine = _arLines + l;
                while (!ns.peWinner)
                {
                    for (UINT i = 0; i < pLine->cElements; i++)
                    {
                        if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }

                    if (fForward)
                    {
                        l++;
                        if ((UINT) l == _cLines)
                            break;

                        pLine++;
                    }
                    else
                    {
                        if (pLine == _arLines)
                            break;
                        pLine--;
                    }
                }
            }
            else
            {
                UINT uOffset = 0;
                
                while (!ns.peWinner)
                {
                    BOOL fFoundOne = FALSE;

                    for (UINT l = 0; l < _cLines; l++)
                    {
                        VLINE* pLine = _arLines + l;
                        int i = pLine->iStart;

                        if (uOffset >= pLine->cElements)
                            continue;

                        fFoundOne = TRUE;

                        if (fForward)
                            i += uOffset;
                        else
                            i += pLine->cElements - (uOffset + 1);
                        
                        if (ns.Try(GetChildFromLayoutIndex(pec, i, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }
                    if (!fFoundOne)
                        break;

                    uOffset++;
                }
            }
        }
        else // we're navigating from child within container
        {
            int iLine = GetLine(pec, peFrom);

            switch (iNavDir)
            {
                case NAV_LEFT:
                    while (iLine > 0)
                    {
                        iLine--;
                        VLINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_RIGHT:
                    while (iLine < (int) (_cLines - 1))
                    {
                        iLine++;
                        VLINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_UP:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    while (i > (int) _arLines[iLine].iStart)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, --i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }

                case NAV_DOWN:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    int iMax = (int) (_arLines[iLine].iStart + _arLines[iLine].cElements - 1);
                    while (i < iMax)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, ++i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }
            }
        }

        pvChildren->Release();

        return ns.peWinner ? ns.peWinner : NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\parse.cpp.h ===
typedef union
{
    // Temporary data returned from tokens (lexer) and productions (parser)
    int num;                    // Stored by lexer (YYINT) and inter-production data transfer
    WCHAR ident[MAXIDENT];      // Stored by lexer (YYIDENT)
    LPWSTR str;                 // Tracked pointer with quotes stripped (YYSTRING)

    EnumsList el;               // Inter-production data transfer
    ParamsList pl;              // Inter-production data transfer
    StartTag st;                // Inter-production data transfer
    COLORREF cr;                // Inter-production data transfer
    HANDLE h;                   // Inter-production data transfer

    ValueNode* pvn;             // NT_ValueNode
    PropValPairNode* ppvpn;     // NT_PropValPairNode
    ElementNode* pen;           // NT_ElementNode
    AttribNode* pan;            // NT_AttribNode
    RuleNode* prn;              // NT_RuleNode
    SheetNode* psn;             // NT_SheetNode
} YYSTYPE;
#define	YYIDENT	258
#define	YYINT	259
#define	YYSTRING	260
#define	YYSHEET	261
#define	YYSHEETREF	262
#define	YYRECT	263
#define	YYPOINT	264
#define	YYRGB	265
#define	YYARGB	266
#define	YYGRADIENT	267
#define	YYGRAPHIC	268
#define	YYDFC	269
#define	YYDTB	270
#define	YYTRUE	271
#define	YYFALSE	272
#define	YYRESID	273
#define	YYATOM	274
#define	YYRCSTR	275
#define	YYRCBMP	276
#define	YYRCINT	277
#define	YYRCCHAR	278
#define	YYPT	279
#define	YYRP	280
#define	YYSYSMETRIC	281
#define	YYSYSMETRICSTR	282
#define	YYHANDLEMAP	283


extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\parser.cpp ===
/*
 * Parser
 */

/*
 * Parser tree instantiation and Value creation is one pass. Nodes are marked as "fixup"
 * if names cannot be resolved until more information is known (i.e. PropertyInfo's cannot
 * be known until the Element Class is known)
 */

// The parser deals with UNICODE input only
// Scan.c and Parse.c will always be built UNICODE enabled

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"

#define DIRECTUIPP_IGNORESYSDEF
#include "directuipp.h"  // Duplicate system defines ignored

namespace DirectUI
{

////////////////////////////////////////////////////////
// Control library class registration (process init)

HRESULT RegisterAllControls()
{
    HRESULT hr;
    
    // Create all ClassInfos for DirectUI controls. These
    // objects will be referenced by each class. A ClassInfo
    // mapping will be established as well

    // Any failure will cause process initialization to fail

    hr = Element::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Button::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Combobox::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Edit::Register();
    if (FAILED(hr))
        goto Failure;

    hr = HWNDElement::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = HWNDHost::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Progress::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = RefPointElement::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = RepeatButton::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = ScrollBar::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = ScrollViewer::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Selector::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Thumb::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Viewer::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}

////////////////////////////////////////////////////////
// Parser tables

// For LayoutPos values only
EnumTable _et[] =  { 
                        { L"auto",               -1 },
                        { L"absolute",           LP_Absolute },
                        { L"none",               LP_None },
                        { L"left",               BLP_Left },
                        { L"top",                BLP_Top },
                        { L"right",              BLP_Right },
                        { L"bottom",             BLP_Bottom },
                        { L"client",             BLP_Client },
                        { L"ninetopleft",        NGLP_TopLeft },
                        { L"ninetop",            NGLP_Top },
                        { L"ninetopright",       NGLP_TopRight },
                        { L"nineleft",           NGLP_Left },
                        { L"nineclient",         NGLP_Client },
                        { L"nineright",          NGLP_Right },
                        { L"ninebottomleft",     NGLP_BottomLeft },
                        { L"ninebottom",         NGLP_Bottom },
                        { L"ninebottomright",    NGLP_BottomRight },
                   };

LayoutTable _lt[] = {
                        { L"borderlayout",       BorderLayout::Create },
                        { L"filllayout",         FillLayout::Create },
                        { L"flowlayout",         FlowLayout::Create },
                        { L"gridlayout",         GridLayout::Create },
                        { L"ninegridlayout",     NineGridLayout::Create },
                        { L"rowlayout",          RowLayout::Create },
                        { L"verticalflowlayout", VerticalFlowLayout::Create },
                    };

SysColorTable _sct[] = {
                        { L"activeborder",       COLOR_ACTIVEBORDER },
                        { L"activecaption",      COLOR_ACTIVECAPTION },
                        { L"appworkspace",       COLOR_APPWORKSPACE },
                        { L"background",         COLOR_BACKGROUND },
                        { L"buttonface",         COLOR_BTNFACE },
                        { L"buttonhighlight",    COLOR_BTNHIGHLIGHT },
                        { L"buttonshadow",       COLOR_BTNSHADOW },
                        { L"buttontext",         COLOR_BTNTEXT },
                        { L"captiontext",        COLOR_CAPTIONTEXT },
                        { L"GradientActiveCaption", COLOR_GRADIENTACTIVECAPTION },
                        { L"GradientInactiveCaption", COLOR_GRADIENTINACTIVECAPTION },
                        { L"graytext",           COLOR_GRAYTEXT },
                        { L"highlight",          COLOR_HIGHLIGHT },
                        { L"highlighttext",      COLOR_HIGHLIGHTTEXT },
                        { L"HotLight",           COLOR_HOTLIGHT },
                        { L"inactiveborder",     COLOR_INACTIVEBORDER },
                        { L"inactivecaption",    COLOR_INACTIVECAPTION },
                        { L"inactivecaptiontext", COLOR_INACTIVECAPTIONTEXT },
                        { L"infobackground",     COLOR_INFOBK },
                        { L"infotext",           COLOR_INFOTEXT },
                        { L"menu",               COLOR_MENU },
                        { L"menutext",           COLOR_MENUTEXT },
                        { L"scrollbar",          COLOR_SCROLLBAR },
                        { L"threeddarkshadow",   COLOR_3DDKSHADOW },
                        { L"threedface",         COLOR_3DFACE },
                        { L"threedhighlight",    COLOR_3DHIGHLIGHT },
                        { L"threedlightshadow",  COLOR_3DLIGHT },
                        { L"threedshadow",       COLOR_3DSHADOW },
                        { L"window",             COLOR_WINDOW },
                        { L"windowframe",        COLOR_WINDOWFRAME },
                        { L"windowtext",         COLOR_WINDOWTEXT },
                    };

////////////////////////////////////////////////////////
// Current parser context that Flex and Bison act on
// This variable also acts as a threading lock

Parser* Parser::g_pParserCtx = NULL;
HDC Parser::g_hDC = NULL;
int Parser::g_nDPI = 0;
bool Parser::g_fParseAbort = false;
HRESULT Parser::g_hrParse;

// Flex/Bison methods and global variables
int yyparse();
BOOL yyrestart(FILE* yyin);
void yy_delete_current_buffer();  // Custom, defined in scan.l

extern int yylineno;

// Used to force an error in the parser and terminate
void CallbackParseError(LPCWSTR pszError, LPCWSTR pszToken);

////////////////////////////////////////////////////////
// Construction

// Parse input (single byte buffer)
HRESULT Parser::Create(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pBuffer, cCharCount, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pBuffer, cCharCount, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;
    *_szDrive = 0;
    *_szPath = 0;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }
   
    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    HRESULT hr = _ParseBuffer(pBuffer, cCharCount);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

// Parser based on a resource (resource type must be "UIFile")
HRESULT Parser::Create(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(uRCID, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(uRCID, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;
    *_szDrive = 0;
    *_szPath = 0;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }

    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    // Locate resource
    WCHAR szID[41];
    swprintf(szID, L"#%u", uRCID);

    HRESULT hr;

    // Assuming 0th contains UI file resource
    HINSTANCE hInstUI = static_cast<HINSTANCE>(_pHList[0]);

    HRSRC hResInfo = FindResourceW(hInstUI, szID, L"UIFile");
    DUIAssert(hResInfo, "Unable to locate resource");

    if (hResInfo)
    {
        HGLOBAL hResData = LoadResource(hInstUI, hResInfo);
        DUIAssert(hResData, "Unable to load resource");

        if (hResData)
        {
            const CHAR* pBuffer = (const CHAR*)LockResource(hResData);
            DUIAssert(pBuffer, "Resource could not be locked");

            hr = _ParseBuffer(pBuffer, SizeofResource(hInstUI, hResInfo) / sizeof(CHAR));
            if (FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

// Parser input file
HRESULT Parser::Create(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pFile, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pFile, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }

    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    HRESULT hr;
    HANDLE hFile = NULL;
    DWORD dwBytesRead = 0;
    int dBufChars = 0;

    // Values to free on failure
    LPSTR pParseBuffer = NULL;

    OFSTRUCT of = { 0 };
    of.cBytes = sizeof(OFSTRUCT);

    hFile = CreateFileW(pFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        _ParseError(L"Could not open file", pFile, -1);
        return S_OK;
    }

    // Save the path to the file being parsed for resolution of all paths
    // specified in the file being parsed
    LPWSTR pszLastSlash = 0;
    LPWSTR pszColon = 0;
    LPWSTR pszWalk = _szDrive;

    StringCbCopyW(_szDrive, sizeof(_szDrive), pFile);

    // find the first colon and the last slash in the path
    while (*pszWalk)
    {
        if (!pszColon && (*pszWalk == ':'))
            pszColon = pszWalk;
        else if ((*pszWalk == '\\') || (*pszWalk == '/'))
            pszLastSlash = pszWalk;
        pszWalk++;
    }

    SSIZE_T iOffset;
    if (pszColon)
    {
        StringCbCopyW(_szPath, sizeof(_szPath), pszColon + 1);
        *(pszColon + 1) = 0;
        iOffset = pszLastSlash - (pszColon + 1);
    }
    else
    {
        StringCbCopyW(_szPath, sizeof(_szPath), _szDrive);
        *_szDrive = 0;
        iOffset = pszLastSlash - _szDrive;
    }

    // pszLastSlash is now a relative to the beginning of the path
    if (iOffset >= 0)
        *(_szPath + iOffset + 1) = 0; // there was a slash, strip off everything after that slash
    else                              
        *_szPath = 0;  // there was no slash or colon, so there is no path

    // Read file straight into buffer (single-byte)
    DWORD dwSize = GetFileSize(hFile, NULL);
    pParseBuffer = (LPSTR)HAlloc(dwSize);
    if (!pParseBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    dBufChars = dwSize / sizeof(CHAR);

    ReadFile(hFile, (void*)pParseBuffer, dwSize, &dwBytesRead, NULL);
    DUIAssert(dwSize == dwBytesRead, "Unable to buffer entire file");

    CloseHandle(hFile);
    hFile = NULL;

    // Parse
    hr = _ParseBuffer(pParseBuffer, dBufChars);
    if (FAILED(hr))
        goto Failed;

    // Free buffer
    HFree(pParseBuffer);

    return S_OK;

Failed:

    if (hFile)
        CloseHandle(hFile);

    if (pParseBuffer)
        HFree(pParseBuffer);

    return hr;
}

void Parser::_DestroyTables()
{
    // Free non-node, non-temp parse tree memory (stored by nodes)
    if (_pdaMemTrack)
    {
        for (UINT i = 0; i < _pdaMemTrack->GetSize(); i++)
            HFree(_pdaMemTrack->GetItem(i));
        _pdaMemTrack->Reset();

        _pdaMemTrack->Destroy();
        _pdaMemTrack = NULL;
    }

    // Free all nodes
    if (_pdaNodeMemTrack)
    {
        Node* pn;
        for (UINT i = 0; i < _pdaNodeMemTrack->GetSize(); i++)
        {
            pn = _pdaNodeMemTrack->GetItem(i);

            // Do any node-specific cleanup
            switch (pn->nType)
            {
            case NT_ValueNode:
                if(((ValueNode*)pn)->nValueType == VNT_Normal)
                    ((ValueNode*)pn)->pv->Release();
                break;

            case NT_ElementNode:
                if (((ElementNode*)pn)->pvContent)
                    ((ElementNode*)pn)->pvContent->Release();
                break;            

            case NT_SheetNode:
                if (((SheetNode*)pn)->pvSheet)
                    ((SheetNode*)pn)->pvSheet->Release();
                break;
            }

            // Free node
            HFree(pn);
        }

        _pdaNodeMemTrack->Destroy();
        _pdaNodeMemTrack = NULL;
    }

    // Clear rest of tables
    if (_pdaTempMemTrack)
    {
        _pdaTempMemTrack->Destroy();
        _pdaTempMemTrack = NULL;
    }

    if (_pdaSheetList)
    {
        _pdaSheetList->Destroy();
        _pdaSheetList = NULL;
    }

    if (_pdaElementList)
    {
        _pdaElementList->Destroy();
        _pdaElementList = NULL;
    }
}

// Free parser state
Parser::~Parser()
{
    _DestroyTables();
}

HRESULT Parser::_ParseBuffer(const CHAR* pBuffer, int cCharCount)
{
    // Create tables
    _pdaElementList = NULL;
    _pdaSheetList = NULL;
    _pdaNodeMemTrack = NULL;
    _pdaMemTrack = NULL;
    _pdaTempMemTrack = NULL;

    HRESULT hr;

    hr = DynamicArray<ElementNode*>::Create(0, false, &_pdaElementList);  // Root Element list
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<SheetNode*>::Create(0, false, &_pdaSheetList);      // Sheet list
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Node*>::Create(0, false, &_pdaNodeMemTrack);        // Parser nodes
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<void*>::Create(0, false, &_pdaMemTrack);            // Parser node extra memory
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<void*>::Create(0, false, &_pdaTempMemTrack);        // Temp parse-time only memory
    if (FAILED(hr))
        goto Failed;

    // Global lock of parser (one Parser as context per parse)
    g_plkParser->Enter();

    // Set global bison/flex context to this
    g_pParserCtx = this;
    g_hDC = GetDC(NULL);
    g_nDPI = g_hDC ? GetDeviceCaps(g_hDC, LOGPIXELSY) : 0;
    g_fParseAbort = false;

    // Set parse buffer pointer to buffer passed in
    _pInputBuf = pBuffer;
    _dInputChars = cCharCount;
    _dInputPtr = 0;

    g_hrParse = S_OK;  // Track abnormal errors during parse

    // Reset the scanner (will create default (current) buffer)
    if (!yyrestart(NULL))
        g_hrParse = DU_E_GENERIC;  // Internal scanner error

    // Do parse if yyrestart was successful
    if (SUCCEEDED(g_hrParse))
    {
        if (yyparse()) // Non-zero on error
        {
            // A production callback will have already set the appropriate HRESULT
            // If an internal scanning/parser or syntax error occurred, the result code will
            // not have set. Set it manually
            if (SUCCEEDED(g_hrParse))
                g_hrParse = DU_E_GENERIC;
        }
    }

    // Free the default (current) scanning buffer
    yy_delete_current_buffer();
    yylineno = 1;

    // Done with parser lock
    if (g_hDC)
        ReleaseDC(NULL, g_hDC);
    Parser::g_pParserCtx = NULL;

    // Unlock parser
    g_plkParser->Leave();

    // Free temporary parser-time allocations (strings and Flex/Bison allocations)
    for (UINT i = 0; i < _pdaTempMemTrack->GetSize(); i++)
        HFree(_pdaTempMemTrack->GetItem(i));
    _pdaTempMemTrack->Reset();

    if (FAILED(g_hrParse))
    {
        hr = g_hrParse;
        goto Failed;
    }

    return S_OK;

Failed:

    _fParseError = true;

    _DestroyTables();

    return hr;
}

// Input
int Parser::_Input(CHAR* pBuffer, int cMaxChars)
{
    if (_dInputPtr == _dInputChars)
        return 0;  // EOF

    int cCharsRead;

    if (_dInputPtr + cMaxChars > _dInputChars)
    {
        cCharsRead = _dInputChars - _dInputPtr;
    }
    else
    {
        cCharsRead = cMaxChars;
    }

    CopyMemory(pBuffer, _pInputBuf + _dInputPtr, sizeof(CHAR) * cCharsRead);

    _dInputPtr += cCharsRead;

    return cCharsRead;
}

////////////////////////////////////////////////////////
// Parser/scanner memory allocation (parse pass (temp) and parser lifetime)

// Memory allocation tracking for tree Nodes
void* Parser::_TrackNodeAlloc(SIZE_T s)
{
    Node* pm = (Node*)HAlloc(s);

    if (pm)
        _pdaNodeMemTrack->Add(pm);

    return pm;
}

void Parser::_UnTrackNodeAlloc(Node* pm)
{
    int i = _pdaNodeMemTrack->GetIndexOf(pm);
    if (i != -1)
        _pdaNodeMemTrack->Remove(i);
}

// Memory allocation tracking for Node extra dynamic state
void* Parser::_TrackAlloc(SIZE_T s)
{
    Node* pm = (Node*)HAlloc(s);

    if (pm)
        _pdaMemTrack->Add(pm);

    return pm;
}

// Memory allocation tracking for temporary memory used during parse
// This includes all string values (those in double quotes) from the scanner and
// all identifiers to be fixed up (propertyinfo's and enums) as well as memory
// required by the scanner/parser (such as params list build up)
void* Parser::_TrackTempAlloc(SIZE_T s)
{
    void* pm = HAlloc(s);

    if (pm)
        _pdaTempMemTrack->Add(pm);

    return pm;
}

void Parser::_TrackTempAlloc(void* pm)
{
    _pdaTempMemTrack->Add(pm);
}

void* Parser::_TrackTempReAlloc(void* pm, SIZE_T s)
{
    // Attempt to realloc
    void* pnew = HReAlloc(pm, s);
    if (pnew)
    {
        // Update tracking if moved
        if (pm != pnew)
        {
            _UnTrackTempAlloc(pm);

            _pdaTempMemTrack->Add(pnew);
        }
    }

    return pnew;
}

void Parser::_UnTrackTempAlloc(void* pm)
{
    int i = _pdaTempMemTrack->GetIndexOf(pm);
    if (i != -1)
        _pdaTempMemTrack->Remove(i);
}

////////////////////////////////////////////////////////
// Error condition, called only during parse (construction)

void Parser::_ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR sz[101];
    _snwprintf(sz, DUIARRAYSIZE(sz), L"DUIParserFailure: %s '%s' %d\n", pszError, pszToken, dLine);
    sz[DUIARRAYSIZE(sz)-1] = NULL;  // Clip
    
    OutputDebugStringW(sz);
    
    // Use callback if provided
    if (_pfnErrorCB)
        _pfnErrorCB(pszError, pszToken, dLine);
}

////////////////////////////////////////////////////////
// Parse Tree Node creation callbacks

// All values passed to callbacks are only guaranteed good
// for the lifetime of the callback

// Parser callback to create Values (if possible)
ValueNode* Parser::_CreateValueNode(BYTE nValueType, void* pData)
{
    ValueNode* pvn = (ValueNode*)_TrackNodeAlloc(sizeof(ValueNode));
    if (!pvn)
    {
        g_hrParse = E_OUTOFMEMORY;
        goto Failure;
    }

    ZeroMemory(pvn, sizeof(ValueNode));

    // Store node type and specifiec ValueNode type
    pvn->nType = NT_ValueNode;
    pvn->nValueType = nValueType;

    switch (nValueType)
    {
    case VNT_Normal:
        if (!pData)
        {
            CallbackParseError(L"Value creation failed", L"");
            goto Failure;
        }
        pvn->pv = (Value*)pData;  // Use ref count
        break;

    case VNT_LayoutCreate:
        {
        LayoutCreate* plc = (LayoutCreate*)pData;

        // Get layout creation information
        PLAYTCREATE pfnLayoutHold = ConvertLayout(plc->pszLayout);

        if (!pfnLayoutHold)
        {
            CallbackParseError(L"Unknown Layout:", plc->pszLayout);
            goto Failure;  // Unknown layout
        }

        pvn->lc.pfnLaytCreate = pfnLayoutHold;
        pvn->lc.dNumParams = plc->dNumParams;

        // Duplicate parameters for Parser lifetime storage
        if (pvn->lc.dNumParams)
        {
            pvn->lc.pParams = (int*)_TrackAlloc(sizeof(int) * pvn->lc.dNumParams);
            if (!pvn->lc.pParams)
            {
                g_hrParse = E_OUTOFMEMORY;
                goto Failure;
            }
            CopyMemory(pvn->lc.pParams, plc->pParams, sizeof(int) * pvn->lc.dNumParams);
        }
        }
        break;

    case VNT_SheetRef:
        // Store ResID
        pvn->psres = (LPWSTR)_TrackAlloc((wcslen((LPWSTR)pData) + 1) * sizeof(WCHAR));
        if (!pvn->psres)
        {
            g_hrParse = E_OUTOFMEMORY;
            goto Failure;
        }
        wcscpy(pvn->psres, (LPWSTR)pData);
        break;

    case VNT_EnumFixup:
        // Store temp tracked list of enumeration strings for later fixup
        pvn->el = *((EnumsList*)pData);
        break;
    }

    return pvn;

Failure:

    // Failure creating Value node, parser will abort and free all parser tables.
    // Make sure this node isn't in the table

    if (pvn)
    {
        _UnTrackNodeAlloc(pvn);
        HFree(pvn);
    }

    return NULL;
}

// Parser callback to create Property/Value pair nodes (requires fixup)
// If a logical operation is provided, an AttribNode is created instead (subclass of PropValPairNode)
PropValPairNode* Parser::_CreatePropValPairNode(LPCWSTR pszProperty, ValueNode* pvn, UINT* pnLogOp)
{
    PropValPairNode* ppvpn = (PropValPairNode*)_TrackNodeAlloc((!pnLogOp) ? sizeof(PropValPairNode) : sizeof(AttribNode));
    if (!ppvpn)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(ppvpn, (!pnLogOp) ? sizeof(PropValPairNode) : sizeof(AttribNode));

    // Store node type and specific PropValPairNode type
    ppvpn->nType = NT_PropValPairNode;
    ppvpn->nPropValPairType = PVPNT_Fixup;  // Type is always fixup from parser

    // Copy property string from parser (parse phase-only alloc)
    ppvpn->pszProperty = (LPWSTR)_TrackTempAlloc((wcslen(pszProperty) + 1) * sizeof(WCHAR));
    if (!ppvpn->pszProperty)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    wcscpy(ppvpn->pszProperty, pszProperty);

    // Store value
    ppvpn->pvn = pvn;

    if (pnLogOp)
        ((AttribNode*)ppvpn)->nLogOp = *pnLogOp;

    return ppvpn;
}

// Parser callback to create Rule nodes (will fixup PropertyInfo's and Enum values)
RuleNode* Parser::_CreateRuleNode(LPCWSTR pszClass, AttribNode* pCondNodes, PropValPairNode* pDeclNodes)
{
    RuleNode* prn = (RuleNode*)_TrackNodeAlloc(sizeof(RuleNode));
    if (!prn)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(prn, sizeof(RuleNode));

    // Store node type
    prn->nType = NT_RuleNode;

    // Set Rule-specific members, resolve Element class
    prn->pCondNodes = pCondNodes;
    prn->pDeclNodes = pDeclNodes;

    prn->pci = ConvertElement(pszClass);

    if (!prn->pci)
    {
        CallbackParseError(L"Unknown element type:", pszClass);
        return NULL;
    }

    // Fixup PropertyInfo's of conditionals
    PropValPairNode* ppvpn = pCondNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, prn->pci, true))
            return NULL;

        ppvpn = ppvpn->pNext;
    }

    // Fixup PropertyInfo's of declarations
    ppvpn = pDeclNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, prn->pci, true))
            return NULL;

        // Make sure this property can be used in a declaration
        if (!(ppvpn->ppi->fFlags & PF_Cascade))
        {
            CallbackParseError(L"Property cannot be used in a Property Sheet declaration:", ppvpn->pszProperty);
            return NULL;
        }

        ppvpn = ppvpn->pNext;
    }

    return prn;
}

// Parser callback to create Element nodes (will fixup PropertyInfo's and Enum values)
ElementNode* Parser::_CreateElementNode(StartTag* pst, Value* pvContent)
{
    ElementNode* pen = (ElementNode*)_TrackNodeAlloc(sizeof(ElementNode));
    if (!pen)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(pen, sizeof(ElementNode));

    // Store node type
    pen->nType = NT_ElementNode;

    // Set Element-specific members, resolve Element class
    pen->pPVNodes = pst->pPVNodes;
    pen->pvContent = pvContent;  // Use ref count
    pen->pszResID = NULL;

    pen->pci = ConvertElement(pst->szTag);

    if (!pen->pci)
    {
        CallbackParseError(L"Unknown element type:", pst->szTag);
        return NULL;
    }

    // Fixup PropertyInfo's of this Element
    PropValPairNode* ppvpn = pst->pPVNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, pen->pci, false))
            return NULL;

        ppvpn = ppvpn->pNext;
    }

    // Store ResID if available
    if (pst->szResID[0])
    {
        pen->pszResID = (LPWSTR)_TrackAlloc((wcslen(pst->szResID) + 1) * sizeof(WCHAR));
        if (!pen->pszResID)
        {
            g_hrParse = E_OUTOFMEMORY;
            return NULL;
        }
        wcscpy(pen->pszResID, pst->szResID);
    }

    return pen;
}

// Parser callback to create Sheet nodes
SheetNode* Parser::_CreateSheetNode(LPCWSTR pszResID, RuleNode* pRuleNodes)
{
    HRESULT hr;
    SheetNode* psn = NULL;
    PropertySheet* pps = NULL;
    RuleNode* pRuleNode = NULL;

    // Values to free on failure
    DynamicArray<Cond>* _pdaConds = NULL;
    DynamicArray<Decl>* _pdaDecls = NULL;

    psn = (SheetNode*)_TrackNodeAlloc(sizeof(SheetNode));
    if (!psn)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    ZeroMemory(psn, sizeof(SheetNode));

    // Store node type
    psn->nType = NT_SheetNode;

    // Set Sheet-specific members
    psn->pRules = pRuleNodes;

    // ResID isn't optional
    DUIAssert(*pszResID, "Sheet resource ID must be provided");
    psn->pszResID = (LPWSTR)_TrackAlloc((wcslen(pszResID) + 1) * sizeof(WCHAR));
    if (!psn->pszResID)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    wcscpy(psn->pszResID, pszResID);

    // Sheets are values, create and hold
    hr = PropertySheet::Create(&pps);
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Cond>::Create(4, false, &_pdaConds);
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Decl>::Create(4, false, &_pdaDecls);
    if (FAILED(hr))
        goto Failed;

    // Add rules
    pRuleNode = pRuleNodes;
    AttribNode* pCondNode;
    PropValPairNode* pDeclNode;
    Cond* pCond;
    Decl* pDecl;
    while (pRuleNode)
    {
        _pdaConds->Reset();
        _pdaDecls->Reset();

        // Build conditional array
        pCondNode = pRuleNode->pCondNodes;
        while (pCondNode)
        {
            hr = _pdaConds->AddPtr(&pCond);
            if (FAILED(hr))
                goto Failed;

            pCond->ppi = pCondNode->ppi;
            pCond->nLogOp = pCondNode->nLogOp;
            pCond->pv = pCondNode->pvn->pv;

            pCondNode = (AttribNode*)pCondNode->pNext;
        }

        // Insert conditionals terminator
        hr = _pdaConds->AddPtr(&pCond);
        if (FAILED(hr))
            goto Failed;

        pCond->ppi = NULL;
        pCond->nLogOp = 0;
        pCond->pv = NULL;

        // Build declarations array
        pDeclNode = pRuleNode->pDeclNodes;
        while (pDeclNode)
        {
            hr = _pdaDecls->AddPtr(&pDecl);
            if (FAILED(hr))
                goto Failed;

            pDecl->ppi = pDeclNode->ppi;
            pDecl->pv = pDeclNode->pvn->pv;

            pDeclNode = pDeclNode->pNext;
        }

        // Insert declarations terminator
        hr = _pdaDecls->AddPtr(&pDecl);
        if (FAILED(hr))
            goto Failed;

        pDecl->ppi = NULL;
        pDecl->pv = NULL;

        // DynamicArrays are contiguous in memory, pass pointer to first to AddRule
        hr = pps->AddRule(pRuleNode->pci, _pdaConds->GetItemPtr(0), _pdaDecls->GetItemPtr(0));
        if (FAILED(hr))
            goto Failed;

        // Next rule
        pRuleNode = pRuleNode->pNext;
    }

    // Create value, marks sheet as immutable
    psn->pvSheet = Value::CreatePropertySheet(pps); // Use ref count
    if (!psn->pvSheet)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    _pdaConds->Destroy();
    _pdaDecls->Destroy();

    return psn;

Failed:

    if (_pdaConds)
        _pdaConds->Destroy();
    if (_pdaDecls)
        _pdaDecls->Destroy();

    g_hrParse = hr;

    return NULL;
}

//  GetPath will resolve a relative path against the path for the file 
//  currently being parsed.  Absolute paths are not altered.
//  For example, if c:\wazzup\foo.ui is being parsed:
//   a) a path of c:\dude\wazzup.bmp is specfied in foo.ui
//       GetPath would return the unaltered path of c:\dude\wazzup.bmp
//   b) a path of \wazzup\b.bmp is specified in foo.ui
//       GetPath would resolve the drive letter, but leave the rest of the
//       path as is, returning c:\wazzup\b.bmp
//   c) a path of ..\images\bar.bmp is specified in foo.ui
//       GetPath would resolve that to c:\wazzup\..\images\bar.bmp
//
//  pIn -- path specified in file being parsed
//  pOut -- pIn resolved against path to file being parsed

void Parser::GetPath(LPCWSTR pIn, LPWSTR pOut, size_t cbOut)
{
    LPCWSTR pszWalk = pIn;

    // walk through pIn, stopping when either a colon, backslash, or forward slash
    // is encountered (and, obviously, stopping at the end of the string)
    while (*pszWalk && (*pszWalk != ':') && (*pszWalk != '\\') && (*pszWalk != '/'))
        pszWalk++;

    if (*pszWalk == ':')
        // a colon was found -- the path is absolute; return it as is
        StringCbCopyW(pOut, cbOut, pIn);
    else if (*pszWalk && (pszWalk == pIn))
        // a slash as the first character was encountered -- the path is absolute within the drive, but relative
        // to the drive of the the parsed file; prepend the parsed file drive to the path passed in
        StringCbPrintfW(pOut, cbOut, L"%s%s", _szDrive, pIn);
    else
        // the path is relative; prepend the parsed file drive and path to the path passed in
        StringCbPrintfW(pOut, cbOut, L"%s%s%s", _szDrive, _szPath, pIn);
}

// Helper: Fixup PropValPairNode
// bRestrictVal limits valid values to VNT_Normal only
bool Parser::_FixupPropValPairNode(PropValPairNode* ppvpn, IClassInfo* pci, bool bRestrictVal)
{
    int dScan;
    PropertyInfo* ppi;

    DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

    // Check if this property (string) exists on the provided element type
    dScan = 0;
    while ((ppi = pci->EnumPropertyInfo(dScan++)) != NULL)
    {
        // Fixup property pointers and check for valid types
        if (!_wcsicmp(ppi->szName, ppvpn->pszProperty))
        {
            // Fixup
            ppvpn->nPropValPairType = PVPNT_Normal; // Convert node type
            ppvpn->ppi = ppi;  // Original string is temp tracked
            break;
        }
    }

    // Check if fixup happened, if not, error
    if (ppvpn->nPropValPairType != PVPNT_Normal)
    {
        CallbackParseError(L"Invalid property:", ppvpn->pszProperty);
        return false;
    }

    // TODO: Fixup Value enumerations based on PropertyInfo
    if (ppvpn->pvn->nValueType == VNT_EnumFixup)
    {
        int nTotal = 0;
        int nEnum;

        for (int i = 0; i < ppvpn->pvn->el.dNumParams; i++)
        {
            if (!ConvertEnum(ppvpn->pvn->el.pEnums[i], &nEnum, ppvpn->ppi))
            {
                CallbackParseError(L"Invalid enumeration value:", ppvpn->pvn->el.pEnums[i]);
                return false;
            }

            nTotal |= nEnum;
        }

        ppvpn->pvn->pv = Value::CreateInt(nTotal);
        if (!ppvpn->pvn->pv)
        {
            g_hrParse = E_OUTOFMEMORY;
            return NULL;
        }
        ppvpn->pvn->nValueType = VNT_Normal;
    }

    // Make sure value type matches property (special cases for deferred creation values)
    bool bValidVal = false;
    switch (ppvpn->pvn->nValueType)
    {
    case VNT_Normal:
        if (Element::IsValidValue(ppvpn->ppi, ppvpn->pvn->pv))
            bValidVal = true;
        break;

    case VNT_LayoutCreate:
        if (!bRestrictVal && ppvpn->ppi == Element::LayoutProp)
            bValidVal = true;
        break;

    case VNT_SheetRef:  
        if (!bRestrictVal && ppvpn->ppi == Element::SheetProp)
            bValidVal = true;
        break;
    }

    if (!bValidVal)
    {
        CallbackParseError(L"Invalid value type for property in conditional:", ppvpn->ppi->szName);
        return false;
    }

    // All fixups and checks successful
    DUIAssert(ppvpn->ppi, "PVPair fixup's property resolution failed");

    return true;
}


// Enum conversion callback
bool Parser::ConvertEnum(LPCWSTR pszEnum, int* pEnum, PropertyInfo* ppi)
{
    // Map enum string to integer value based using property's enummap
    if (ppi->pEnumMaps)
    {
        EnumMap* pem = ppi->pEnumMaps;
        while (pem->pszEnum)
        {
            if (!_wcsicmp(pem->pszEnum, pszEnum))
            {
                *pEnum = pem->nEnum;

                return true;
            }

            pem++;
        }
    }

    // Enum not located, special case for other values
    switch (ppi->_iGlobalIndex)
    {
    case _PIDX_Foreground:
    case _PIDX_Background:
    case _PIDX_BorderColor:
        {
            // Check if it's a standard color
            UINT nColorCheck = FindStdColor(pszEnum);
            if (nColorCheck != (UINT)-1)
            {
                // Match found
                *pEnum = nColorCheck;
                return true;
            }

            // No match, check if it's a system color
            for (int i = 0; i < sizeof(_sct) / sizeof(SysColorTable); i++)
            {
                if (!_wcsicmp(_sct[i].pszSysColor, pszEnum))
                {
                    // Match found. Since it's a system color, offset index by
                    // system color base so it can be identified as a system color
                    *pEnum = MakeSysColorEnum(_sct[i].nSysColor);
                    return true;
                }
            }
        }
        break;

    case _PIDX_LayoutPos:
        // Check parser table for layout pos values
        for (int i = 0; i < sizeof(_et) / sizeof(EnumTable); i++)
        {
            if (!_wcsicmp(_et[i].pszEnum, pszEnum))
            {
                *pEnum = _et[i].nEnum;
                return true;
            }
        }
        break;
    }

    // Could find no match
    return false;
}

PLAYTCREATE Parser::ConvertLayout(LPCWSTR pszLayout)
{
    for (int i = 0; i < sizeof(_lt) / sizeof(LayoutTable); i++)
    {
        if (!_wcsicmp(_lt[i].pszLaytType, pszLayout))
        {
            return _lt[i].pfnLaytCreate;
        }
    }

    // Could find no match
    return NULL;
}

IClassInfo* Parser::ConvertElement(LPCWSTR pszElement)
{
    IClassInfo** ppci = Element::pciMap->GetItem((void*)pszElement);
    if (!ppci)
        return NULL;

    return *ppci;
}

// System metric integers
int Parser::_QuerySysMetric(int idx)
{
    int iMetric = 0;

    if (idx < 0)
    {
        // DSM_* custom DUI system define mappings
        if (DSM_NCMIN <= idx && idx <= DSM_NCMAX)
        {
            NONCLIENTMETRICSW ncm;
            ncm.cbSize = sizeof(ncm);

            SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE);
        
            switch (idx)
            {
            case DSM_CAPTIONFONTSIZE:
                iMetric = ncm.lfCaptionFont.lfHeight;
                break;

            case DSM_CAPTIONFONTWEIGHT:
                iMetric = ncm.lfCaptionFont.lfWeight;
                break;
            
            case DSM_CAPTIONFONTSTYLE:
                if (ncm.lfCaptionFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfCaptionFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfCaptionFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
                
            case DSM_MENUFONTSIZE:
                iMetric = ncm.lfMenuFont.lfHeight;
                break;
                
            case DSM_MENUFONTWEIGHT:
                iMetric = ncm.lfMenuFont.lfWeight;
                break;
                
            case DSM_MENUFONTSTYLE:
                if (ncm.lfMenuFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfMenuFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfMenuFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_MESSAGEFONTSIZE:
                iMetric = ncm.lfMessageFont.lfHeight;
                break;

            case DSM_MESSAGEFONTWEIGHT:
                iMetric = ncm.lfMessageFont.lfWeight;
                break;

            case DSM_MESSAGEFONTSTYLE:
                if (ncm.lfMessageFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfMessageFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfMessageFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_SMCAPTIONFONTSIZE:
                iMetric = ncm.lfSmCaptionFont.lfHeight;
                break;

            case DSM_SMCAPTIONFONTWEIGHT:
                iMetric = ncm.lfSmCaptionFont.lfWeight;
                break;

            case DSM_SMCAPTIONFONTSTYLE:
                if (ncm.lfSmCaptionFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfSmCaptionFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfSmCaptionFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_STATUSFONTSIZE:
                iMetric = ncm.lfStatusFont.lfHeight;
                break;
                
            case DSM_STATUSFONTWEIGHT:
                iMetric = ncm.lfStatusFont.lfWeight;
                break;

            case DSM_STATUSFONTSTYLE:
                if (ncm.lfStatusFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfStatusFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfStatusFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
            }
        }
        else if (DSM_ICMIN <= idx && idx <= DSM_ICMAX)
        {
            ICONMETRICSW icm;
            icm.cbSize = sizeof(icm);

            SystemParametersInfoW(SPI_GETICONMETRICS, sizeof(icm), &icm, FALSE);

            switch (idx)
            {
            case DSM_ICONFONTSIZE:
                iMetric = icm.lfFont.lfHeight;
                break;

            case DSM_ICONFONTWEIGHT:
                iMetric = icm.lfFont.lfWeight;
                break;
            
            case DSM_ICONFONTSTYLE:
                if (icm.lfFont.lfItalic)
                    iMetric |= FS_Italic;
                if (icm.lfFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (icm.lfFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
            }            
        }
    }
    else
    {
        // SM_* system defines
        iMetric = GetSystemMetrics(idx);
    }

    return iMetric;
}

// System metric strings
// Pointer returned is a system metric pointer, it will be valid after return
LPCWSTR Parser::_QuerySysMetricStr(int idx, LPWSTR psz, UINT c)
{
    LPCWSTR pszMetric = L"";

    // DSM_* custom DUI system define mappings
    if (DSMS_NCMIN <= idx && idx <= DSMS_NCMAX)
    {
        NONCLIENTMETRICSW ncm;
        ncm.cbSize = sizeof(ncm);

        SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE);
    
        switch (idx)
        {
        case DSMS_CAPTIONFONTFACE:
            pszMetric = ncm.lfCaptionFont.lfFaceName;
            break;

        case DSMS_MENUFONTFACE:
            pszMetric = ncm.lfMenuFont.lfFaceName;
            break;
            
        case DSMS_MESSAGEFONTFACE:
            pszMetric = ncm.lfMessageFont.lfFaceName;
            break;

        case DSMS_SMCAPTIONFONTFACE:
            pszMetric = ncm.lfSmCaptionFont.lfFaceName;
            break;

        case DSMS_STATUSFONTFACE:
            pszMetric = ncm.lfStatusFont.lfFaceName;
            break;
        }
    }
    else if (DSMS_ICMIN <= idx && idx <= DSMS_ICMAX)
    {
        ICONMETRICSW icm;
        icm.cbSize = sizeof(icm);

        SystemParametersInfoW(SPI_GETICONMETRICS, sizeof(icm), &icm, FALSE);

        switch (idx)
        {
        case DSMS_ICONFONTFACE:
            pszMetric = icm.lfFont.lfFaceName;
            break;
        }            
    }

    wcsncpy(psz, pszMetric, c);

    // Auto-terminate (in event source was longer than destination)
    *(psz + (c - 1)) = NULL;

    // Return string passed in for convienence
    return psz;
}

// Instantiate an element by resource ID
// If a substitute is provided, don't create a new node. Rather, the use substitute, set
// properties on it and create all content within it. Substitute must support the same
// properties as the type defined in the UI file
// Returns NULL if resid is not found, or if cannot create Element (if not substituting)
HRESULT Parser::CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement)
{
    HRESULT hr = S_OK;

    Element* pe = NULL;

    Element::StartDefer();

    // TODO: Implement DFS search for resource ID, for now, just toplevel
    ElementNode* pen;
    for (UINT i = 0; i < _pdaElementList->GetSize(); i++)
    {
        pen = _pdaElementList->GetItem(i);

        if (pen->pszResID)
        {
            if (!_wcsicmp(pen->pszResID, pszResID))
            {
                hr = _InstantiateElementNode(pen, peSubstitute, NULL, &pe);
                break;
            }
        }
    }

    Element::EndDefer();

    *ppElement = pe;

    return hr;
}

// Find a property sheet by resource ID (returned as Value, ref counted)
Value* Parser::GetSheet(LPCWSTR pszResID)
{
    SheetNode* psn;
    for (UINT i = 0; i < _pdaSheetList->GetSize(); i++)
    {
        psn = _pdaSheetList->GetItem(i);

        DUIAssert(psn->pszResID, "Sheet resource ID required");  // Must have a resid

        if (!_wcsicmp(psn->pszResID, pszResID))
        {
            psn->pvSheet->AddRef();
            return psn->pvSheet;
        }
    }

    return NULL;
}

// Locate resource ID by Value. Pointer returned is guaranteed good as
// long as Parser is valid
LPCWSTR Parser::ResIDFromSheet(Value* pvSheet)
{
    SheetNode* psn;
    for (UINT i = 0; i < _pdaSheetList->GetSize(); i++)
    {
        psn = _pdaSheetList->GetItem(i);

        if (psn->pvSheet == pvSheet)
            return psn->pszResID;
    }

    return NULL;
}

// Returns NULL if can't instantiate Element. If using substitution,
// reutrn value is substituted Element
HRESULT Parser::_InstantiateElementNode(ElementNode* pen, Element* peSubstitute, Element* peParent, OUT Element** ppElement)
{
    *ppElement = NULL;

    HRESULT hr;
    PropValPairNode* ppvpn = NULL;
    ElementNode* pChild = NULL;
    Element* peChild = NULL;

    // Values to free on failure
    Element* pe = NULL;

    if (!peSubstitute)
    {
        hr = pen->pci->CreateInstance(&pe);
        if (FAILED(hr))
            goto Failed;
    }
    else
        // Substitute
        pe = peSubstitute;

    DUIAssert(pe, "Invalid Element: NULL");

    // Set properties
    ppvpn = pen->pPVNodes;
    while (ppvpn)
    {
        // Set property value
        switch (ppvpn->pvn->nValueType)
        {
        case VNT_Normal:
            // Value already created
            pe->SetValue(ppvpn->ppi, PI_Local, ppvpn->pvn->pv);
            break;

        case VNT_LayoutCreate:
            {
            // Value that needs to be created (layout)
            Value* pv;
            hr = ppvpn->pvn->lc.pfnLaytCreate(ppvpn->pvn->lc.dNumParams, ppvpn->pvn->lc.pParams, &pv);
            if (FAILED(hr))
                goto Failed;

            pe->SetValue(ppvpn->ppi, PI_Local, pv);
            pv->Release();  // Must release since must not be held by parse tree
            }
            break;

        case VNT_SheetRef:
            {
            // Value already created, but is referenced by id (resid) since it was defined
            // in another part of the document and can be shared, search for it
            Value* pv = GetSheet(ppvpn->pvn->psres);
            if (!pv)
            {
                hr = E_OUTOFMEMORY;
                goto Failed;
            }

            pe->SetValue(ppvpn->ppi, PI_Local, pv);
            pv->Release();  // Must release since must not be held by parse tree
            }
            break;
        }

        ppvpn = ppvpn->pNext;
    }

    // Create children and parent to this element
    pChild = pen->pChild;

    if (peParent)
        peParent->Add(pe);

    while (pChild)
    {
        hr = _InstantiateElementNode(pChild, NULL, pe, &peChild);
        if (FAILED(hr))
            goto Failed;

        pChild = pChild->pNext;
    }

    // Set content
    if (pen->pvContent)
        pe->SetValue(Element::ContentProp, PI_Local, pen->pvContent);

    *ppElement = pe;

    // ContainerCleanup: call ppElement->OnLoadedFromResource() right here -- handing a resource dictionary 

    return S_OK;

Failed:

    // Destroying Element will release and free all values and children
    if (pe)
        pe->Destroy();

    return hr;
}

// Given a tree, will replace all occurances of a particular style sheet with
// another. ReplaceSheets will walk to every Element, check to see if it
// has a local sheet set on it. If it does, it will try to match the
// sheet value pointer to one of the sheets being held by Parser pFrom. When
// a match is found, it'll use the resid to locate the corresponding sheet
// in Parser pTo. If found, it'll reset the Sheet on the Element with this
// new value.
HRESULT Parser::ReplaceSheets(Element* pe, Parser* pFrom, Parser* pTo)
{
    Element::StartDefer();

    HRESULT hrPartial = S_FALSE;  // Will resume on failure, assume success false
    HRESULT hr;

    // Check if Element has a local sheet set on it (will be pvUnset if none)
    Value* pvSheet = pe->GetValue(Element::SheetProp, PI_Local);
    LPCWSTR pszResID;
    
    if (pvSheet->GetType() == DUIV_SHEET)
    {
        // Found local sheet, try locate in "from" Parser list
        pszResID = pFrom->ResIDFromSheet(pvSheet);

        if (pszResID)
        {
            // Found sheet in "from" parser and have unique resid.
            // Try to match to "to" parser.

            Value* pvNewSheet = pTo->GetSheet(pszResID);
            if (pvNewSheet)
            {
                // Found equivalent sheet in "to" parser, set
                hr = pe->SetValue(Element::SheetProp, PI_Local, pvNewSheet);
                if (FAILED(hr))
                    hrPartial = hr;
            
                pvNewSheet->Release();

                if (SUCCEEDED(hrPartial))
                    hrPartial = S_OK;
            }
        }
    }

    pvSheet->Release();
    
    // Do same for all children
    Value* pvChildren;
    ElementList* peList = pe->GetChildren(&pvChildren);
    Element* pec;
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            pec = peList->GetItem(i);

            hr = ReplaceSheets(pec, pFrom, pTo);
            if ((FAILED(hr) || (hr == S_FALSE)) && SUCCEEDED(hrPartial))
                hrPartial = hr;
        }
    }

    pvChildren->Release();

    Element::EndDefer();

    return hrPartial;
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_PARSER_STDAFX_H_INCLUDED
#define DUI_PARSER_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_PARSER_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\stdafxparser.cpp ===
/*
 * stdafxparser.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_PARSER_PUBLISHED_H_INCLUDED
#define DUI_PARSER_PUBLISHED_H_INCLUDED

#include "duiparserobj.h"

#endif // DUI_PARSER_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\parser.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_PARSER_PARSER_H_INCLUDED
#define DUI_PARSER_PARSER_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>
#include <DUILayoutP.h>
#include <DUIControlP.h>

#endif // DUI_PARSER_PARSER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\scan.cpp ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

////////////////////////////
// DirectUI

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"
namespace DirectUI 
{ 
#include "parse.cpp.h"
}

#pragma warning (push,3)
#pragma warning (disable:4244)
#pragma warning (disable:4102)

#define YY_NEVER_INTERACTIVE 1

////////////////////////////

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

//
// DirectUI: Modified to prop fatal (abnormal) execution information:
//
// yylex (-1) 
// yy_get_next_buffer (EOB_ACT_FATAL_ERROR) <yylex (-1), yyinput (EOF)>
// yyinput (EOF) <yyinput (EOF)>
// yyunput (FALSE) <no callers>
// yy_create_buffer (NULL) <yyrestart (FALSE), yylex (-1), yy_set_interactive (no callers), yy_set_bol (no callers)>
// yy_scan_buffer (NULL) <yy_scan_bytes (NULL)>
// yy_scan_bytes (NULL) <yy_scan_string (NULL)>
// yy_push_state (FALSE) <no callers>
// yy_pop_state (FALSE) <no callers>
//

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
//#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

////////////////////////////
// DirectUI
namespace DirectUI
{
////////////////////////////

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_FATAL_ERROR -1  // DirectUI
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *      yyless( 5 );
 *  else
 *      do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        *yy_cp = yy_hold_char; \
        YY_RESTORE_YY_MORE_OFFSET \
        yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        } \
    while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */

////////////////////////////
// DirectUI

typedef SIZE_T yy_size_t;
//typedef unsigned int yy_size_t;

////////////////////////////

struct yy_buffer_state
    {
    FILE *yy_input_file;

    char *yy_ch_buf;        /* input buffer */
    char *yy_buf_pos;       /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
    };

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;      /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;     /* whether we need to initialize */
static int yy_start = 0;    /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

BOOL yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

// DirectUI: Not used. Error info not propped
#define yy_set_interactive(is_interactive) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_is_interactive = is_interactive; \
    }

// DirectUI: Not used. Error info not propped
#define yy_set_bol(at_bol) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_at_bol = at_bol; \
    }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)


#define YY_USES_REJECT
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern int yylineno;
int yylineno = 1;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
    yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
    yy_hold_char = *yy_cp; \
    *yy_cp = '\0'; \
    yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 37
#define YY_END_OF_BUFFER 38
static yyconst short int yy_acclist[175] =
    {   0,
       38,   32,   37,   31,   32,   37,   31,   37,   32,   37,
       32,   37,   32,   37,   32,   37,   27,   32,   37,   27,
       32,   37,   26,   32,   37,   26,   32,   37,   26,   32,
       37,   26,   32,   37,   26,   32,   37,   26,   32,   37,
       26,   32,   37,   26,   32,   37,   26,   32,   37,   26,
       32,   37,   34,   37,   34,   37,   36,   37,   35,   37,
       31,   30,   28,   27,    1,    2,   26,   26,   26,   26,
       26,   26,   26,   26,   26,   21,   26,   26,   26,   26,
       22,   26,   26,   26,   26,   33,   29,   26,   26,   11,
       26,   12,   26,   26,   26,   26,   26,   26,   26,   26,

       26,   26,   26,    7,   26,   26,   26,   26,    8,   26,
       16,   26,   26,   26,   26,   26,   26,   26,   26,   26,
       26,    6,   26,   26,   26,   26,   13,   26,   14,   26,
       26,   26,   26,    5,   26,   18,   26,   26,   19,   26,
       17,   26,   15,   26,    3,   26,   26,   26,   26,   26,
       20,   26,   26,   26,   26,   10,   26,   26,   26,   26,
        9,   26,   26,    4,   26,   26,   25,   26,   23,   26,
       26,   26,   24,   26
    } ;

static yyconst short int yy_accept[126] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    2,    4,    7,
        9,   11,   13,   15,   17,   20,   23,   26,   29,   32,
       35,   38,   41,   44,   47,   50,   53,   55,   57,   59,
       61,   62,   62,   63,   64,   65,   66,   67,   67,   68,
       69,   70,   71,   72,   73,   74,   75,   76,   78,   79,
       80,   81,   83,   84,   85,   86,   87,   88,   89,   90,
       92,   94,   95,   96,   97,   98,   99,  100,  101,  102,
      103,  104,  106,  107,  108,  109,  111,  113,  114,  115,
      116,  117,  118,  119,  120,  121,  122,  124,  125,  126,
      127,  129,  131,  132,  133,  134,  136,  138,  139,  141,

      143,  145,  147,  148,  149,  150,  151,  153,  154,  155,
      156,  158,  159,  160,  161,  163,  164,  166,  167,  169,
      171,  172,  173,  175,  175
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
        1,    6,    1,    1,    7,    1,    8,    9,   10,   10,
       10,   10,   10,   10,   10,   10,   10,    1,    1,    1,
        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
       17,   18,   19,   20,   20,   21,   22,   23,   24,   25,
       20,   26,   27,   28,   29,   20,   20,   30,   31,   20,
        1,    1,    1,    1,    1,    1,   11,   12,   13,   14,

       15,   16,   17,   18,   19,   20,   20,   21,   22,   23,
       24,   25,   20,   26,   27,   28,   29,   20,   20,   30,
       31,   20,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[32] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3
    } ;

static yyconst short int yy_base[131] =
    {   0,
        0,    0,  145,  144,  146,  145,  147,  152,   30,   32,
      142,    0,   27,   32,   32,   34,   19,    0,   23,  134,
      118,  132,   22,   39,   27,  116,  152,  133,  152,  152,
       46,  136,  152,    0,   50,  152,  152,    0,    0,  122,
      114,  124,  124,  114,  123,  110,  113,    0,   53,   40,
      119,    0,   99,  102,   99,  152,    0,  115,  104,    0,
        0,   98,   43,  110,  100,  100,  103,   97,   91,   90,
       98,    0,   95,   93,   99,    0,    0,   98,   93,   93,
       89,   81,   83,   96,   78,   79,    0,   90,   88,   87,
        0,    0,   86,   81,   84,    0,    0,   72,    0,    0,

        0,   71,   68,   72,   81,   71,    0,   77,   53,   50,
        0,   66,   60,   56,    0,   49,    0,   60,    0,   44,
       42,   43,    0,  152,   80,   83,   86,   61,   88,   59
    } ;

static yyconst short int yy_def[131] =
    {   0,
      124,    1,  125,  125,  126,  126,  124,  124,  124,  124,
      127,  128,  124,  124,  124,  124,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  124,  124,  124,  124,
      124,  127,  124,  128,  124,  124,  124,  130,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  124,  130,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,

      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,    0,  124,  124,  124,  124,  124,  124
    } ;

static yyconst short int yy_nxt[184] =
    {   0,
        8,    9,   10,   11,   12,    8,   13,   14,   15,   16,
       17,   18,   18,   19,   18,   20,   21,   22,   18,   18,
       18,   18,   18,   18,   23,   24,   25,   26,   18,   18,
       18,   31,   31,   31,   31,   35,   35,   36,   42,   37,
       35,   35,   35,   35,   40,   47,   41,   31,   31,   48,
       43,   49,   70,   50,   53,   51,   79,   54,   35,   35,
       57,   38,   34,   52,   66,   67,   71,   80,  123,  122,
      121,   68,  120,  119,  118,  117,  116,  115,  114,   69,
       27,   27,   27,   29,   29,   29,   32,   32,   32,   39,
       39,  113,  112,  111,  110,  109,  108,  107,  106,  105,

      104,  103,  102,  101,  100,   99,   98,   97,   96,   95,
       94,   93,   92,   91,   90,   89,   88,   87,   86,   85,
       84,   83,   82,   81,   78,   77,   76,   75,   74,   73,
       72,   65,   64,   63,   62,   61,   60,   59,   58,   33,
       56,   55,   46,   45,   44,   33,  124,   30,   30,   28,
       28,    7,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124
    } ;

static yyconst short int yy_chk[184] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    9,    9,   10,   10,   13,   13,   14,   19,   14,
       15,   15,   16,   16,   17,   23,   17,   31,   31,   23,
       19,   24,   50,   24,   25,   24,   63,   25,   35,   35,
      130,   15,  128,   24,   49,   49,   50,   63,  122,  121,
      120,   49,  118,  116,  114,  113,  112,  110,  109,   49,
      125,  125,  125,  126,  126,  126,  127,  127,  127,  129,
      129,  108,  106,  105,  104,  103,  102,   98,   95,   94,

       93,   90,   89,   88,   86,   85,   84,   83,   82,   81,
       80,   79,   78,   75,   74,   73,   71,   70,   69,   68,
       67,   66,   65,   64,   62,   59,   58,   55,   54,   53,
       51,   47,   46,   45,   44,   43,   42,   41,   40,   32,
       28,   26,   22,   21,   20,   11,    7,    6,    5,    4,
        3,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124
    } ;

static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static char *yy_full_match;
static int yy_lp;
#define REJECT \
{ \
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yy_full_match; /* restore poss. backed-over text */ \
++yy_lp; \
goto find_rule; \
}
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#define INITIAL 0
/* FLEX */
/*
 * Scanner is single-byte
 * All strings and identifiers will be converted for storage to Unicode at this stage
 */

void yyerror(LPCSTR s);

#define YY_INPUT(buf, result, n) result = Parser::g_pParserCtx->_Input(buf, n)
#define YY_FATAL_ERROR(msg)      { yytext = "<ScannerFailure>"; yylineno = 0; yyerror(msg); }

// Defined in Flex.skl so that is at top of file
/*
#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"
namespace DirectUI
{ 
#include "parse.cpp.h"
}

#pragma warning (push,3)
#pragma warning (disable:4244)
#pragma warning (disable:4102)

#define YY_NEVER_INTERACTIVE 1
*/

// Helper functions
LPWSTR UniDupString(LPSTR ps);

#define CUSTOMALLOC     HAlloc
#define CUSTOMREALLOC   HReAlloc
#define CUSTOMFREE      HFree

#define ppc             Parser::g_pParserCtx

#define COMMENT 1

#define INLINECOMMENT 2


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static BOOL yyunput YY_PROTO(( int c, char *buf_ptr ));  // DirectUI: Can fail, FALSE on failure
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static BOOL yy_push_state YY_PROTO(( int new_state ));  // DirectUI: Can fail, FALSE on failure
#endif
#ifndef YY_NO_POP_STATE
static BOOL yy_pop_state YY_PROTO(( void ));  // DirectUI: Can fail, FALSE on failure
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

//// YY_INPUT redefined by DirectUI

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( BOOL* pfRes ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

// DirectUI: yylex (YY_DECL), out param used as success code (yyterminate() called on failure)

YY_DECL
    {
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;

    *pfRes = TRUE;  // DirectUI: Init success out param




    if ( yy_init )
        {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if ( ! yy_start )
            yy_start = 1;   /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( ! yy_current_buffer )
            {
            yy_current_buffer =
                yy_create_buffer( yyin, YY_BUF_SIZE );
            if ( ! yy_current_buffer )  // DirectUI
                {
                *pfRes = FALSE;
                yyterminate();  // Failure
                }
            }

        yy_load_buffer_state();
        }

    while ( 1 )     /* loops until end-of-file is reached */
        {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

		yy_current_state = yy_start;
		yy_state_ptr = yy_state_buf;
		*yy_state_ptr++ = yy_current_state;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 125 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			*yy_state_ptr++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_current_state != 124 );

yy_find_action:
		yy_current_state = *--yy_state_ptr;
		yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[yy_lp];
					{
					yy_full_match = yy_cp;
					break;
					}
				}
			--yy_cp;
			yy_current_state = *--yy_state_ptr;
			yy_lp = yy_accept[yy_current_state];
			}

        YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					++yylineno;
			}

do_action:  /* This label is used only to access EOF actions. */


        switch ( yy_act )
    { /* beginning of action switch */
case 1:
YY_RULE_SETUP
{ BEGIN COMMENT; }
	YY_BREAK
case 2:
YY_RULE_SETUP
{ BEGIN INLINECOMMENT; }
	YY_BREAK
case 3:
YY_RULE_SETUP
{ return YYSHEET; }
	YY_BREAK
case 4:
YY_RULE_SETUP
{ return YYSHEETREF; }
	YY_BREAK
case 5:
YY_RULE_SETUP
{ return YYPOINT; }
	YY_BREAK
case 6:
YY_RULE_SETUP
{ return YYRECT; }
	YY_BREAK
case 7:
YY_RULE_SETUP
{ return YYRGB; }
	YY_BREAK
case 8:
YY_RULE_SETUP
{ return YYARGB; }
	YY_BREAK
case 9:
YY_RULE_SETUP
{ return YYGRADIENT; }
	YY_BREAK
case 10:
YY_RULE_SETUP
{ return YYGRAPHIC; }
	YY_BREAK
case 11:
YY_RULE_SETUP
{ return YYDFC; }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ return YYDTB; }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ return YYTRUE; }
	YY_BREAK
case 14:
YY_RULE_SETUP
{ return YYFALSE; }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ return YYRESID; }
	YY_BREAK
case 16:
YY_RULE_SETUP
{ return YYATOM; }
	YY_BREAK
case 17:
YY_RULE_SETUP
{ return YYRCSTR; }
	YY_BREAK
case 18:
YY_RULE_SETUP
{ return YYRCBMP; }
	YY_BREAK
case 19:
YY_RULE_SETUP
{ return YYRCINT; }
	YY_BREAK
case 20:
YY_RULE_SETUP
{ return YYRCCHAR; }
	YY_BREAK
case 21:
YY_RULE_SETUP
{ return YYPT; }
	YY_BREAK
case 22:
YY_RULE_SETUP
{ return YYRP; }
	YY_BREAK
case 23:
YY_RULE_SETUP
{
                                   return YYSYSMETRIC;
                                 }
	YY_BREAK
case 24:
YY_RULE_SETUP
{
                                   return YYSYSMETRICSTR;
                                 }
	YY_BREAK
case 25:
YY_RULE_SETUP
{
                                   return YYHANDLEMAP;
                                 }
	YY_BREAK
case 26:
YY_RULE_SETUP
{
                                    MultiByteToWideChar(DUI_CODEPAGE, 0, yytext, -1, yylval.ident, MAXIDENT);
                                    // No NULL termination on truncation, always add it
                                    yylval.ident[MAXIDENT - 1] = NULL;
                                    return YYIDENT;
                                 }
	YY_BREAK
case 27:
YY_RULE_SETUP
{
                                    yylval.num = atoi(yytext);
                                    return YYINT; 
                                 }
	YY_BREAK
case 28:
YY_RULE_SETUP
{
                                    yylval.num = strtol(yytext + 1, NULL, 16);
                                    return YYINT; 
                                 }
	YY_BREAK
case 29:
YY_RULE_SETUP
{
                                    yylval.num = strtol(yytext + 2, NULL, 16);
                                    return YYINT; 
                                 }
	YY_BREAK
case 30:
YY_RULE_SETUP
{
                                    yylval.str = UniDupString(yytext);
                                    return YYSTRING;
                                 }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 32:
YY_RULE_SETUP
{ return *yytext; }
	YY_BREAK
case 33:
YY_RULE_SETUP
{ BEGIN 0; }
	YY_BREAK
case 34:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 35:
YY_RULE_SETUP
{ BEGIN 0; }
	YY_BREAK
case 36:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 37:
YY_RULE_SETUP
ECHO;
	YY_BREAK
			case YY_STATE_EOF(INITIAL):
			case YY_STATE_EOF(COMMENT):
			case YY_STATE_EOF(INLINECOMMENT):
				yyterminate();

    case YY_END_OF_BUFFER:
        {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_hold_char;
        YY_RESTORE_YY_MORE_OFFSET

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
            {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between yy_current_buffer and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yy_n_chars = yy_current_buffer->yy_n_chars;
            yy_current_buffer->yy_input_file = yyin;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
            }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans( yy_current_state );

            yy_bp = yytext_ptr + YY_MORE_ADJ;

            if ( yy_next_state )
                {
                /* Consume the NUL. */
                yy_cp = ++yy_c_buf_p;
                yy_current_state = yy_next_state;
                goto yy_match;
                }

            else
                {
				yy_cp = yy_c_buf_p;
                goto yy_find_action;
                }
            }

        else switch ( yy_get_next_buffer() )
            {
            case EOB_ACT_END_OF_FILE:
                {
                yy_did_buffer_switch_on_eof = 0;

                if ( yywrap() )
                    {
                    /* Note: because we've taken care in
                     * yy_get_next_buffer() to have set up
                     * yytext, we can now set up
                     * yy_c_buf_p so that if some total
                     * hoser (like flex itself) wants to
                     * call the scanner after we return the
                     * YY_NULL, it'll still work - another
                     * YY_NULL will get returned.
                     */
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                    yy_act = YY_STATE_EOF(YY_START);
                    goto do_action;
                    }

                else
                    {
                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
                    }
                break;
                }

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p =
                    yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_match;

            case EOB_ACT_LAST_MATCH:
                yy_c_buf_p =
                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;

            case EOB_ACT_FATAL_ERROR:
                *pfRes = FALSE;  // DirectUI                
                yyterminate();
            }
        break;
        }

    default:
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--no action found" );
        *pfRes = FALSE;  // DirectUI
        yyterminate();
    } /* end of action switch */

        } /* end of scanning one token */
    } /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_FATAL_ERROR  // DirectUI (-1)
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
    {
    register char *dest = yy_current_buffer->yy_ch_buf;
    register char *source = yytext_ptr;
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        {
        YY_FATAL_ERROR(
        "fatal flex scanner internal error--end of buffer missed" );
        return EOB_ACT_FATAL_ERROR;  // DirectUI
        }

    if ( yy_current_buffer->yy_fill_buffer == 0 )
        { /* Don't try to fill the buffer, so this is an EOF. */
        if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
            {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
            }

        else
            {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
            }
        }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_current_buffer->yy_n_chars = yy_n_chars = 0;

    else
        {
        int num_to_read =
            yy_current_buffer->yy_buf_size - number_to_move - 1;

        while ( num_to_read <= 0 )
            { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
            return EOB_ACT_FATAL_ERROR;
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset =
                (int) (yy_c_buf_p - b->yy_ch_buf);

            if ( b->yy_is_our_buffer )
                {
                int new_size = b->yy_buf_size * 2;

                if ( new_size <= 0 )
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc( (void *) b->yy_ch_buf,
                             b->yy_buf_size + 2 );
                }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if ( ! b->yy_ch_buf )
                {
                YY_FATAL_ERROR(
                "fatal error - scanner input buffer overflow" );
                return EOB_ACT_FATAL_ERROR;
                }

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size -
                        number_to_move - 1;
#endif
            }

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
            yy_n_chars, num_to_read );

        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    if ( yy_n_chars == 0 )
        {
        if ( number_to_move == YY_MORE_ADJ )
            {
            ret_val = EOB_ACT_END_OF_FILE;
            if ( ! yyrestart( yyin ) )  // DirectUI: Can fail
                return EOB_ACT_FATAL_ERROR;
            }

        else
            {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status =
                YY_BUFFER_EOF_PENDING;
            }
        }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
    }


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
    {
    register yy_state_type yy_current_state;
    register char *yy_cp;

	yy_current_state = yy_start;
	yy_state_ptr = yy_state_buf;
	*yy_state_ptr++ = yy_current_state;

    for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        {
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 125 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		*yy_state_ptr++ = yy_current_state;
        }

    return yy_current_state;
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
    {
    register int yy_is_jam;

	register YY_CHAR yy_c = 1;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 125 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 124);
	if ( ! yy_is_jam )
		*yy_state_ptr++ = yy_current_state;

    return yy_is_jam ? 0 : yy_current_state;
    }


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static BOOL yyunput( int c, register char *yy_bp )
#else
static BOOL yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
    {
    // DirectUI: Returns BOOL, FALSE on failure
    
    register char *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        register int number_to_move = yy_n_chars + 2;
        register char *dest = &yy_current_buffer->yy_ch_buf[
                    yy_current_buffer->yy_buf_size + 2];
        register char *source =
                &yy_current_buffer->yy_ch_buf[number_to_move];

        while ( source > yy_current_buffer->yy_ch_buf )
            *--dest = *--source;

        yy_cp += (int) (dest - source);
        yy_bp += (int) (dest - source);
        yy_current_buffer->yy_n_chars =
            yy_n_chars = yy_current_buffer->yy_buf_size;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
            {
            YY_FATAL_ERROR( "flex scanner push-back overflow" );
            return FALSE;
            }
        }

    *--yy_cp = (char) c;

	if ( c == '\n' )
		--yylineno;

    yytext_ptr = yy_bp;
    yy_hold_char = *yy_cp;
    yy_c_buf_p = yy_cp;

    return TRUE;
    }
#endif  /* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
    {
    // DirectUI: Return EOF (-1) on error
    
    int c;

    *yy_c_buf_p = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* This was really a NUL. */
            *yy_c_buf_p = '\0';

        else
            { /* need more input */
            int offset = yy_c_buf_p - yytext_ptr;
            ++yy_c_buf_p;

            switch ( yy_get_next_buffer() )
                {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    if ( ! yyrestart( yyin ) )  // DirectUI: Return on failure
                        return EOF;

                    /* fall through */

                case EOB_ACT_END_OF_FILE:
                    {
                    if ( yywrap() )
                        return EOF;

                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();  // DirectUI: Return EOF on failure
#else
                    return input();
#endif
                    }

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext_ptr + offset;
                    break;

                case EOB_ACT_FATAL_ERROR:
                    return EOF;
                }
            }
        }

    c = *(unsigned char *) yy_c_buf_p;  /* cast for 8-bit char's */
    *yy_c_buf_p = '\0'; /* preserve yytext */
    yy_hold_char = *++yy_c_buf_p;

	if ( c == '\n' )
		++yylineno;

    return c;
    }


#ifdef YY_USE_PROTOS
BOOL yyrestart( FILE *input_file )
#else
BOOL yyrestart( input_file )
FILE *input_file;
#endif
    {
    // DirectUI: Return BOOL, FALSE on failure
    
    if ( ! yy_current_buffer )
        {
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
        if (! yy_current_buffer )  // DirectUI
            return FALSE;  // Failure
        }

    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();

    return TRUE;
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
        {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
    {
    // DirectUI: NULL on allocation error
    
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
    if ( ! b->yy_ch_buf )
        {
        yy_flex_free(b);  // DirectUI: Free initial alloc
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_is_our_buffer = 1;

    yy_init_buffer( b, file );

    return b;
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
    {
    if ( ! b )
        return;

    if ( b == yy_current_buffer )
        yy_current_buffer = (YY_BUFFER_STATE) 0;

    if ( b->yy_is_our_buffer )
        yy_flex_free( (void *) b->yy_ch_buf );

    yy_flex_free( (void *) b );
    }


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


    {
    yy_flush_buffer( b );

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = 0;
#else
    b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
    }


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    if ( ! b )
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if ( b == yy_current_buffer )
        yy_load_buffer_state();
    }


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
    {
    // DirectUI: Return NULL on error
    
    YY_BUFFER_STATE b;

    if ( size < 2 ||
         base[size-2] != YY_END_OF_BUFFER_CHAR ||
         base[size-1] != YY_END_OF_BUFFER_CHAR )
        /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer( b );

    return b;
    }
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
    {
    // DirectUI: Can return NULL (props yy_scan_bytes value)
    
    int len;
    for ( len = 0; yy_str[len]; ++len )
        ;

    return yy_scan_bytes( yy_str, len );
    }
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
    {
    // DirectUI: Return NULL on error
    
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = (char *) yy_flex_alloc( n );
    if ( ! buf )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
        return NULL;
        }

    for ( i = 0; i < len; ++i )
        buf[i] = bytes[i];

    buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer( buf, n );
    if ( ! b )
        {
        yy_flex_free(buf);  // DirectUI: Free previous alloc on failure
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        return NULL;
        }

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
    }
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static BOOL yy_push_state( int new_state )
#else
static BOOL yy_push_state( new_state )
int new_state;
#endif
    {
    // DirectUI: Return FALSE on error
    
    if ( yy_start_stack_ptr >= yy_start_stack_depth )
        {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof( int );

        if ( ! yy_start_stack )
            yy_start_stack = (int *) yy_flex_alloc( new_size );

        else
            yy_start_stack = (int *) yy_flex_realloc(
                    (void *) yy_start_stack, new_size );

        if ( ! yy_start_stack )
            {
            YY_FATAL_ERROR(
            "out of memory expanding start-condition stack" );
            return FALSE;  // DirectUI
            }
        }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
    }
#endif


#ifndef YY_NO_POP_STATE
static BOOL yy_pop_state()
    {
    // DirectUI: Returns BOOL, FALSE on failure
    
    if ( --yy_start_stack_ptr < 0 )
        {
        YY_FATAL_ERROR( "start-condition stack underflow" );
        return FALSE;  // DirectUI
        }

    BEGIN(yy_start_stack[yy_start_stack_ptr]);

    return TRUE;
    }
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
    {
    return yy_start_stack[yy_start_stack_ptr - 1];
    }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
    {
    (void) fprintf( stderr, "%s\n", msg );
    //exit( YY_EXIT_FAILURE );  // DirectUI: Never exit process
    }



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        yytext[yyleng] = yy_hold_char; \
        yy_c_buf_p = yytext + n; \
        yy_hold_char = *yy_c_buf_p; \
        *yy_c_buf_p = '\0'; \
        yyleng = n; \
        } \
    while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
    {
    register int i;
    for ( i = 0; i < n; ++i )
        s1[i] = s2[i];
    }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
    {
    register int n;
    for ( n = 0; s[n]; ++n )
        ;

    return n;
    }
#endif

////////////////////////////
// DirectUI
#ifndef CUSTOMALLOC
#define CUSTOMALLOC malloc
#endif
////////////////////////////

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
    {
    return (void *) CUSTOMALLOC ( size );
    }

////////////////////////////
// DirectUI
#ifndef CUSTOMREALLOC
#define CUSTOMREALLOC realloc
#endif
////////////////////////////

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
    {
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void *) CUSTOMREALLOC ( (char *) ptr, size );
    }

////////////////////////////
// DirectUI
#ifndef CUSTOMFREE
#define CUSTOMFREE free
#endif
////////////////////////////


#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
    {
    CUSTOMFREE ( ptr );
    }

#if YY_MAIN
int main()
    {
    yylex();
    return 0;
    }
#endif

////////////////////////////
// DirectUI
} // namespace DirectUI
////////////////////////////


namespace DirectUI
{

int yywrap()
{
    return 1;
}

LPWSTR UniDupString(LPSTR ps)
{
    // Convert raw string to Unicode, all strings are placed in temp parse-time storage
    LPWSTR pns = MultiByteToUnicode(ps);
    ppc->_TrackTempAlloc(pns);

    // "Trim" quotes from string
    *(pns + (wcslen(pns) - 1)) = 0;
    pns++;

    // Insert newlines (newline code is '~', requires 'wrap' content align)
    LPWSTR pscan = pns;

    while (*pscan)
    {
        if (*pscan == '~')
            *pscan = '\n';

        pscan++;
    }

    // Must be freed
    return pns;
}

void yy_delete_current_buffer()
{
    yy_delete_buffer(YY_CURRENT_BUFFER);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\convert.cpp ===
/*
 * Conversion
 */

#include "stdafx.h"
#include "util.h"

#include "duiconvert.h"

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// String conversion

// String must be freed with HeapFree(...)
LPSTR UnicodeToMultiByte(LPCWSTR pszUnicode, int cChars, int* pMultiBytes)
{
    // Negative chars means null-terminated
    // Get number of bytes required for multibyte string
    int dMultiBytes = WideCharToMultiByte(DUI_CODEPAGE, 0, pszUnicode, cChars, NULL, 0, NULL, NULL);

    LPSTR pszMulti = (LPSTR)HAlloc(dMultiBytes);

    if (pszMulti)
    {
        WideCharToMultiByte(DUI_CODEPAGE, 0, pszUnicode, cChars, pszMulti, dMultiBytes, NULL, NULL);

        if (pMultiBytes)
            *pMultiBytes = dMultiBytes;
    }

    return pszMulti;
}

// String must be freed with HeapFree(...)
LPWSTR MultiByteToUnicode(LPCSTR pszMulti, int dBytes, int* pUniChars)
{
    // Negative chars means null-terminated
    // Get number of bytes required for unicode string
    int cUniChars = MultiByteToWideChar(DUI_CODEPAGE, 0, pszMulti, dBytes, NULL, 0);

    LPWSTR pszUnicode = (LPWSTR)HAlloc(cUniChars * sizeof(WCHAR));

    if (pszUnicode)
    {
        MultiByteToWideChar(DUI_CODEPAGE, 0, pszMulti, dBytes, pszUnicode, cUniChars);

        if (pUniChars)
            *pUniChars = cUniChars;
    }

    return pszUnicode;
}

/////////////////////////////////////////////////////////////////////////////
// Atom conversion

ATOM StrToID(LPCWSTR psz)
{
    ATOM atom = FindAtomW(psz);
    DUIAssert(atom, "Atom could not be located");
    return atom;
}

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

// Loads a device-dependent (screen) image. Bitmap color information is
// converted to match device. If device is palette-based, image will be
// dithered to the halftone palette
//
// Device-dependent bitmaps are much faster in blitting operations than
// device-independent bitmps (no conversions required)

HBITMAP LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy)
{
    if (!pszBitmap)
    {
        DUIAssertForce("Invalid parameter: NULL");
        return NULL;
    }

    HBITMAP hBitmap = NULL;
    HDC hDC = GetDC(NULL);

    // Check device color depth
    if ((GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE) != RC_PALETTE)
    {
        // RBG --> RGB
        // PAL --> RGB

        // Non-palette based device. Do normal device-dependent LoadImage
        // which will map colors to the display device
        hBitmap = (HBITMAP)LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, cx, cy, hResLoad ? 0 : LR_LOADFROMFILE);
    }
    else
    {
        // RGB --> PAL
        // PAL --> PAL

        // Palette based. Map colors of image to device (using halftone dithering
        // if needed)
        HBITMAP hDib = (HBITMAP)LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION | (hResLoad ? 0 : LR_LOADFROMFILE));
        if (hDib)
        {
            DIBSECTION ds;
            ZeroMemory(&ds, sizeof(DIBSECTION));

            if (GetObjectW(hDib, sizeof(DIBSECTION), &ds) == sizeof(DIBSECTION))
            {
                // Get DIB info
                BITMAPINFOHEADER* pbmih = &ds.dsBmih;

                // Compatible (with screen) source DC
                HDC hDibDC = CreateCompatibleDC(hDC);
                if (hDibDC)
                {
                    // Select in DIB
                    HBITMAP hOldDibBm = (HBITMAP)SelectObject(hDibDC, hDib);

                    // Compatible (with screen) destination DC
                    HDC hHtDC = CreateCompatibleDC(hDC);
                    if (hHtDC)
                    {
                        // Create a bitmap for memory DC (and compatible with screen) and select
                        hBitmap = CreateCompatibleBitmap(hDC, pbmih->biWidth, pbmih->biHeight);
                        if (hBitmap)
                        {
                            HBITMAP hOldHtBm = (HBITMAP)SelectObject(hHtDC, hBitmap);

                            // Create and select halftone palette
                            HPALETTE hHtPal = CreateHalftonePalette(hHtDC);

                            if (hHtPal)
                            {
                                HPALETTE hOldPal = (HPALETTE)SelectPalette(hHtDC, hHtPal, FALSE);
                                RealizePalette(hHtDC);

                                // Setup blitting mode
                                POINT ptBrushOrg;
                                GetBrushOrgEx(hHtDC, &ptBrushOrg);
                                SetStretchBltMode(hHtDC, HALFTONE);
                                SetBrushOrgEx(hHtDC, ptBrushOrg.x, ptBrushOrg.y, NULL);

                                // Blit
                                StretchBlt(hHtDC, 0, 0, pbmih->biWidth, pbmih->biHeight, hDibDC,
                                    0, 0, pbmih->biWidth, pbmih->biHeight, SRCCOPY);

                                SelectPalette(hHtDC, hOldPal, TRUE);
                                DeleteObject(hHtPal);
                            }

                            SelectObject(hHtDC, hOldHtBm);
                        }

                        DeleteDC(hHtDC);
                    }

                    SelectObject(hDibDC, hOldDibBm);
                    DeleteDC(hDibDC);
                }
            }

            DeleteObject(hDib);
        }
    }

    ReleaseDC(NULL, hDC);

    return hBitmap;
}

#ifdef GADGET_ENABLE_GDIPLUS

HRESULT LoadDDBitmap(
    IN  LPCWSTR pszBitmap, 
    IN  HINSTANCE hResLoad, 
    IN  int cx, 
    IN  int cy, 
    IN  UINT nFormat, 
    OUT Gdiplus::Bitmap** ppgpbmp)
{
    HRESULT hr = E_INVALIDARG;
    Gdiplus::Bitmap* pgpbmp = NULL;

    *ppgpbmp = NULL;

    if (hResLoad)
    {
        // Handle if loading from a resource.  Load the HBITMAP and then 
        // convert it to GDI+.
        HBITMAP hbmpRaw = (HBITMAP) LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, 0, 0, 
                LR_CREATEDIBSECTION | LR_SHARED);
        if (hbmpRaw == NULL) {
            return E_OUTOFMEMORY;
        }

        if ((nFormat == PixelFormat32bppPARGB) || (nFormat == PixelFormat32bppARGB)) {
            pgpbmp = ProcessAlphaBitmapF(hbmpRaw, nFormat);
        }

        if (pgpbmp == NULL) {
            pgpbmp = Gdiplus::Bitmap::FromHBITMAP(hbmpRaw, NULL);
        }

        if (hbmpRaw != NULL) {
            DeleteObject(hbmpRaw);
        }
        
        if (pgpbmp == NULL) {
            return E_OUTOFMEMORY;
        }
    } 
    else 
    {
        // Load from a file.  We can have GDI+ directly do this.
        pgpbmp = Gdiplus::Bitmap::FromFile(pszBitmap);
        if (!pgpbmp)
            return E_OUTOFMEMORY;
    }

    // Resize the bitmap
    int cxBmp = pgpbmp->GetWidth();
    int cyBmp = pgpbmp->GetHeight();

    if ((cx != 0) && (cy != 0) && ((cx != cxBmp) || (cy != cyBmp)))
    {
        Gdiplus::PixelFormat gppf = pgpbmp->GetPixelFormat();
        Gdiplus::Bitmap * pgpbmpTemp = new Gdiplus::Bitmap(cx, cy, gppf);
        if (pgpbmpTemp != NULL)
        {
            Gdiplus::Graphics gpgrNew(pgpbmpTemp);
            Gdiplus::Rect rcDest(0, 0, cx, cy);
            gpgrNew.DrawImage(pgpbmp, rcDest, 0, 0, cxBmp, cyBmp, Gdiplus::UnitPixel);

            *ppgpbmp = pgpbmpTemp;
            pgpbmpTemp = NULL;
            hr = S_OK;
        }

        delete pgpbmp;  // Created by GDI+ (cannot use HDelete)
    } 
    else 
    {
        *ppgpbmp = pgpbmp;
        hr = S_OK;
    }

    if (*ppgpbmp == NULL)
    {
        DUITrace("WARNING: Unable to load bitmap 0x%x\n", pszBitmap);
    }

    return hr;
}

#endif // GADGET_ENABLE_GDIPLUS


BOOL HasAlphaChannel(RGBQUAD * pBits, int cPixels)
{
    //
    // We need to examine the source bitmap to see if it contains an alpha
    // channel.  This is simply a heuristic since there is no format difference
    // between 32bpp 888 RGB image and 32bpp 8888 ARGB image.  What we do is look
    // for any non-0 alpha/reserved values.  If all alpha/reserved values are 0,
    // then the image would be 100% invisible if blitted with alpha - which is
    // almost cerainly not the desired result.  So we assume such bitmaps are
    // 32bpp non-alpha.
    //
    
    BOOL fAlphaChannel = FALSE;
    for (int i = 0; i < cPixels; i++) 
    {
        if (pBits[i].rgbReserved != 0)
        {
            fAlphaChannel = TRUE;
            break;
        }
    }

    return fAlphaChannel;
}


// Examines the source bitmap to see if it supports and uses an alpha
// channel.  If it does, a new DIB section is created that contains a
// premultiplied copy of the data from the source bitmap.
//
// If the source bitmap is not capable of supporting, or simply doesn't use,
// an alpha channel, the return value is NULL.
//
// If an error occurs, the return value is NULL.
//
// Ported from ProcessAlphaBitmap in ntuser kernel

HBITMAP ProcessAlphaBitmapI(HBITMAP hbmSource)
{
    BITMAP bmp;
    BITMAPINFO bi;
    HBITMAP hbmAlpha;
    RGBQUAD* pAlphaBitmapBits;
    DWORD cPixels;
    DWORD i;
    RGBQUAD pixel;
    BOOL fAlphaChannel;

    // There are several code paths that end up calling us with a NULL
    // hbmSource.  This is fine, in that it simply indicates that there
    // is no alpha channel.

    if (hbmSource == NULL)
        return NULL;

    if (GetObjectW(hbmSource, sizeof(BITMAP), &bmp) == 0)
        return NULL;

    // Only single plane, 32bpp bitmaps can even contain an alpha channel.
    if (bmp.bmPlanes != 1 || bmp.bmBitsPixel != 32) 
        return NULL;

    // Allocate room to hold the source bitmap's bits for examination.
    // We actually allocate a DIB - that will be passed out if the
    // source bitmap does indeed contain an alpha channel.

    ZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth       = bmp.bmWidth;
    bi.bmiHeader.biHeight      = bmp.bmHeight;
    bi.bmiHeader.biPlanes      = 1;
    bi.bmiHeader.biBitCount    = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    HDC hdcScreen = GetDC(NULL);

    hbmAlpha = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, (void**)&pAlphaBitmapBits, NULL, 0);

    if (NULL != hbmAlpha)
    {
        // Set up the header again in case it was tweaked by GreCreateDIBitmapReal.
        ZeroMemory(&bi, sizeof(bi));
        bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biWidth       = bmp.bmWidth;
        bi.bmiHeader.biHeight      = bmp.bmHeight;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biBitCount    = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        // Copy the bitmap data from the source bitmap into our alpha DIB.
        if (!GetDIBits(hdcScreen, hbmSource, 0, bi.bmiHeader.biHeight, (LPBYTE)pAlphaBitmapBits, (LPBITMAPINFO)&bi, DIB_RGB_COLORS))
        {
            DeleteObject(hbmAlpha);
            ReleaseDC(NULL, hdcScreen);
            return NULL;
        }

        cPixels  = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
        fAlphaChannel = HasAlphaChannel(pAlphaBitmapBits, cPixels);

        if (fAlphaChannel == FALSE)
        {
            DeleteObject(hbmAlpha);
            ReleaseDC(NULL, hdcScreen);
            return NULL;
        }

        // The source bitmap appears to use an alpha channel.  Spin through our
        // copy of the bits and premultiply them.  This is a necessary step to
        // prepare an alpha bitmap for use by GDI.
        for (i = 0; i < cPixels; i++)
        {
            pixel = pAlphaBitmapBits[i];

            pAlphaBitmapBits[i].rgbReserved = pixel.rgbReserved;
            pAlphaBitmapBits[i].rgbRed = (pixel.rgbRed * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbGreen = (pixel.rgbGreen * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbBlue = (pixel.rgbBlue * pixel.rgbReserved) / 0xFF;
        }
    }

    ReleaseDC(NULL, hdcScreen);

    return hbmAlpha;
}



#ifdef GADGET_ENABLE_GDIPLUS

Gdiplus::Bitmap * ProcessAlphaBitmapF(HBITMAP hbmSource, UINT nFormat)
{
    DUIAssert((nFormat == PixelFormat32bppPARGB) || (nFormat == PixelFormat32bppARGB),
            "Must have a valid format");
    
    //
    // Get the bits out of the DIB
    //
    // NOTE: Gdiplus::ARGB has bits in the same order as RGBQUAD, which allows 
    // us to directly copy without bit reordering.
    //
    
    DIBSECTION ds;
    if (GetObject(hbmSource, sizeof(ds), &ds) == 0) {
        DUIAssertForce("GDI+ requires DIB's for alpha-channel conversion");
        return NULL;
    }

    // Only single plane, 32bpp bitmaps can even contain an alpha channel.
    if ((ds.dsBm.bmPlanes) != 1 || (ds.dsBm.bmBitsPixel != 32)) {
        return NULL;
    }


    RGBQUAD * pvBits    = (RGBQUAD *) ds.dsBm.bmBits;
    DUIAssert(pvBits != NULL, "DIB must have valid bits");

    int nWidth  = ds.dsBm.bmWidth;
    int nHeight = ds.dsBm.bmHeight;
    int cPixels = nWidth * nHeight;
    if (!HasAlphaChannel(pvBits, cPixels)) {
        return NULL;
    }

    //
    // DIB's may go bottom up or top down, depending on the height.  This is a
    // bit of a pain, so we need to properly traverse them.
    //

    int cbDIBStride;
    BOOL fBottomUp = ds.dsBmih.biHeight >= 0;
    if (fBottomUp) {
        pvBits += (nHeight - 1) * nWidth;
        cbDIBStride = -(int) (nWidth * 2);
    } else {
        cbDIBStride = 0;
    }
    Gdiplus::ARGB * pc  = (Gdiplus::ARGB *) pvBits;
        


    //
    // Create a GDI+ bitmap to store the data in
    //

    Gdiplus::Bitmap * pgpbmpNew = new Gdiplus::Bitmap(nWidth, nHeight, nFormat);
    if (pgpbmpNew == NULL) {
        return NULL;  // Unable to allocate bitmap
    }


    //
    // Iterate over the DIB, copying the bits into the GDI+ bitmap
    //

    Gdiplus::BitmapData bd;
    Gdiplus::Rect rc(0, 0, nWidth, nHeight);
    if (pgpbmpNew->LockBits(&rc, Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeWrite, 
            nFormat, &bd) == Gdiplus::Ok) {

        BYTE *pRow = (BYTE*) bd.Scan0;
        DWORD *pCol;
        Gdiplus::ARGB c;

        switch (nFormat)
        {
        case PixelFormat32bppPARGB:
            {
                for (int y = 0; y < nHeight; y++, pRow += bd.Stride, pc += cbDIBStride) {
                    pCol = (DWORD *) pRow;
                    for (int x = 0; x < nWidth; x++, pCol++) {
                        //
                        // NOTE: This code is taken from GDI+ and is optimized 
                        // to premultiply a constant alpha level.
                        //

                        c = *pc++;
                        DWORD _aa000000 = c & 0xff000000;
                        BYTE bAlphaLevel = (BYTE) ((_aa000000) >> 24);
                        if (bAlphaLevel != 0x00000000) {
                            Gdiplus::ARGB _000000gg = (c >> 8) & 0x000000ff;
                            Gdiplus::ARGB _00rr00bb = (c & 0x00ff00ff);

                            Gdiplus::ARGB _0000gggg = _000000gg * bAlphaLevel + 0x00000080;
                            _0000gggg += ((_0000gggg >> 8) & 0x000000ff);

                            Gdiplus::ARGB _rrrrbbbb = _00rr00bb * bAlphaLevel + 0x00800080;
                            _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

                            c = _aa000000 | (_0000gggg & 0x0000ff00) | ((_rrrrbbbb >> 8) & 0x00ff00ff);
                        } else {
                            c = 0;
                        }

                        *pCol = c;
                    }
                }

                break;
            }
            
        case PixelFormat32bppARGB:
            {
                for (int y = 0; y < nHeight; y++, pRow += bd.Stride, pc += cbDIBStride) {
                    pCol = (DWORD *) pRow;
                    for (int x = 0; x < nWidth; x++) {
                        *pCol++ = *pc++;
                    }
                }
                break;
            }
        }

        pgpbmpNew->UnlockBits(&bd);
    }

    return pgpbmpNew;
}

#endif // GADGET_ENABLE_GDIPLUS


/////////////////////////////////////////////////////////////////////////////
// Color conversion

HBRUSH BrushFromEnumI(int c)
{
    if (IsSysColorEnum(c))
        return GetSysColorBrush(ConvertSysColorEnum(c));
    else
        return GetStdColorBrushI(c);
}

COLORREF ColorFromEnumI(int c)
{
    if (IsSysColorEnum(c))
        return GetSysColor(ConvertSysColorEnum(c));
    else
        return GetStdColorI(c);
}

#ifdef GADGET_ENABLE_GDIPLUS

Gdiplus::Color ColorFromEnumF(int c)
{
    if (IsSysColorEnum(c))
        return Convert(GetSysColor(ConvertSysColorEnum(c)));
    else
        return GetStdColorF(c);
}

#endif


/////////////////////////////////////////////////////////////////////////////
// Palettes

// Determine if primary device is palettized
bool IsPalette(HWND hWnd)
{
    HDC hDC = GetDC(hWnd);
    bool bPalette = (GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE) == RC_PALETTE;
    ReleaseDC(hWnd, hDC);

    return bPalette;
}

/*
// PAL file conversion, takes file name, pointer to RGBQUAD 256 element array, pointer to error buffer
HPALETTE PALToHPALETTE(LPWSTR pPALFile, bool bMemFile, DWORD dMemFileSize, LPRGBQUAD pRGBQuad, LPWSTR pError)
{
    HPALETTE hPalette = NULL;

    if (pRGBQuad)
        ZeroMemory(pRGBQuad, sizeof(RGBQUAD) * 256);

    HANDLE hFile = NULL;

    if (!bMemFile)
    {
        hFile = CreateFileW(pPALFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            if (pError)
                wcscpy(pError, L"Could not open file!");
            return NULL;
        }
    }

    // Load palette
    HMMIO hmmio;
    MMIOINFO info;

    ZeroMemory(&info, sizeof(MMIOINFO));
    if(!bMemFile)
        info.adwInfo[0] = (DWORD)(UINT_PTR)hFile;    // Use file
    else
    {
        info.pchBuffer = (HPSTR)pPALFile;  // Use memory palette data
        info.fccIOProc = FOURCC_MEM;
        info.cchBuffer = dMemFileSize;
    }
    hmmio = mmioOpen(NULL, &info, MMIO_READ | MMIO_ALLOCBUF);
    if (!hmmio)
    {
        if (pError)
            wcscpy(pError, L"Could not open file! (mmio)");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Process RIFF file
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('P','A','L',' ');
    if (mmioDescend(hmmio, &ckFile, NULL, MMIO_FINDRIFF) != 0)
    {
        if (pError)
            wcscpy(pError, L"Not a valid PAL file!");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Find the 'data' chunk
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(hmmio, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0)
    {
        if (pError)
            wcscpy(pError, L"Not a valid PAL file!");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    int dSize = ckChunk.cksize;
    void* pData = HAlloc(dSize);
    mmioRead(hmmio, (HPSTR)pData, dSize);
    
    LOGPALETTE* pLogPal = (LOGPALETTE*)pData;
    if (pLogPal->palVersion != 0x300)
    {
        if (pError)
            wcscpy(pError, L"Invalid PAL file version (not 3.0)!");
        if (pData)
            HFree(pData);
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Check number of entires
    if (pLogPal->palNumEntries != 256)
    {   
        if (pError)
            wcscpy(pError, L"PAL file must have 256 color entries!");
        if (pData)
            HFree(pData);
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Create palette
    hPalette = CreatePalette(pLogPal);

    // Copy palette entries to RGBQUAD array
    if (pRGBQuad)
    {
        for(int x = 0; x < 256; x++)
        {
            pRGBQuad[x].rgbRed = pLogPal->palPalEntry[x].peRed;
            pRGBQuad[x].rgbGreen = pLogPal->palPalEntry[x].peGreen;
            pRGBQuad[x].rgbBlue = pLogPal->palPalEntry[x].peBlue;
            pRGBQuad[x].rgbReserved = 0;
        }
    }

    // Done
    mmioClose(hmmio,MMIO_FHOPEN);
    HFree(pData);
    if(!bMemFile)
        CloseHandle(hFile);

    return hPalette;
}
*/


int PointToPixel(int nPoint)
{
    // Get DPI
    HDC hDC = GetDC(NULL);
    int nDPI = hDC ? GetDeviceCaps(hDC, LOGPIXELSY) : 0;
    if (hDC)
        ReleaseDC(NULL, hDC);

    // Convert
    return PointToPixel(nPoint, nDPI);
}

int RelPixToPixel(int nRelPix)
{
    // Get DPI
    HDC hDC = GetDC(NULL);
    int nDPI = hDC ? GetDeviceCaps(hDC, LOGPIXELSY) : 0;
    if (hDC)
        ReleaseDC(NULL, hDC);

    // Convert
    return RelPixToPixel(nRelPix, nDPI);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\parser\query.cpp ===
/*
 * Query
 */

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"

namespace DirectUI
{

#ifdef DBG

char* g_arMarkupLines[] = {
    "<style resid=mainss>",
        "element { background: argb(0,0,0,0); }",
    "</style>",
    "<style resid=headerss>",
        "element [id=atom(header)] { foreground: white; background: cornflowerblue; fontsize: 16pt; fontstyle: italic; borderthickness: rect(0,0,0,1); padding: rect(3,3,3,3); contentalign: topleft | endellipsis; }",
        "element [id=atom(subheader)] { foreground: white; background: firebrick; fontsize: 10pt; fontweight: bold; borderthickness: rect(0,0,0,1); padding: rect(3,3,3,3); contentalign: topleft | endellipsis; }",
    "</style>",
    "<style resid=tabless>",
        "element { background:gainsboro; fontsize: 10pt; }"
        "element [id=atom(propertytitle)] { background: gainsboro; contentalign: topright | endellipsis; borderthickness: rect(2,2,2,2); bordercolor: gainsboro; padding: rect(2,2,2,2); fontstyle: italic; borderstyle: raised; }",
        "element [id=atom(valuetitle)] { background: gainsboro; borderthickness: rect(2,2,2,2); bordercolor: gainsboro; padding: rect(2,2,2,2); fontweight: bold; borderstyle: raised; contentalign: topleft | endellipsis; }",
        "element [id=atom(property)] {background: oldlace; contentalign: topright | endellipsis; fontstyle: italic; borderthickness: rect(0,0,1,1); padding: rect(2,2,2,2); }",
        "element [id=atom(value)] { background: white; contentalign: wrapleft; fontweight: bold; borderthickness: rect(0,0,0,1); padding: rect(2,2,2,2); }",
    "</style>",
    "<style resid=scrollerss>",
        "scrollbar { layoutpos: ninebottom; }",
        "scrollbar [vertical] { layoutpos: nineright; }",
        "viewer { layoutpos: nineclient; }",
        "thumb { background: dfc(4, 0x0010); }",
        "repeatbutton [id=atom(lineup)] { background: dfc(3, 0x0000); width: sysmetric(2); height: sysmetric(20); }",
        "repeatbutton [id=atom(lineup)][pressed] { background: dfc(3, 0x0000 | 0x0200); }",
        "repeatbutton [id=atom(linedown)] { background: dfc(3, 0x0001); width: sysmetric(2); height: sysmetric(20); }",
        "repeatbutton [id=atom(linedown)][pressed] { background: dfc(3, 0x0001 | 0x0200); }",
        "repeatbutton [class=\"Page\"] { background: scrollbar; }",
        "repeatbutton [class=\"Page\"][pressed] { background: buttonshadow; }",
    "</style>",
    "<element resid=main sheet=styleref(mainss) layout=borderlayout()>",
        "<element id=atom(header) sheet=styleref(headerss) layoutpos=top/>",
        "<element id=atom(subheader) sheet=styleref(headerss) layoutpos=top/>",
        "<scrollviewer sheet=styleref(scrollerss) layoutpos=client xscrollable=false>",
            "<element id=atom(table) sheet=styleref(tabless) layoutpos=top layout=verticalflowlayout(0,3,3,0)>",
                "<element layout=gridlayout(1,2)>",
                    "<element id=atom(propertytitle)>\"Property\"</element>",
                    "<element id=atom(valuetitle)>\"Value\"</element>",
                "</element>",
            "</element>",
        "</scrollviewer>",
    "</element>",
    "<element resid=item layout=gridlayout(1,2)>",
        "<element id=atom(property)/>",
        "<element id=atom(value)/>",
    "</element>",
};

#endif // DBG

void QueryDetails(Element* pe, HWND hParent)
{
    UNREFERENCED_PARAMETER(pe);
    UNREFERENCED_PARAMETER(hParent);

#ifdef DBG

    HRESULT hr;
    int cBufSize = 0;
    LPSTR pBuf = NULL;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    HWNDElement* phe = NULL;
    bool fEndDeferOnFail = false;
    Element* peTable = NULL;
    Element* peHold = NULL;
    Element* peHold1 = NULL;
    WCHAR szTemp[256];
    IClassInfo* pci = NULL;
    PropertyInfo* ppi = NULL;
    int nEnum = 0;
    Value* pv = NULL;

    // Create buffer for parser based on markup
    for (int i = 0; i < DUIARRAYSIZE(g_arMarkupLines); i++)
        cBufSize += (int)strlen(g_arMarkupLines[i]);

    // Buffer is single byte
    pBuf = (LPSTR)HAlloc(cBufSize + 1);
    if (!pBuf)
        goto Failure;
    *pBuf = 0;

    for (i = 0; i < DUIARRAYSIZE(g_arMarkupLines); i++)
        strcat(pBuf, g_arMarkupLines[i]);
    
    // Parse buffer, not loading resources
    hr = Parser::Create(pBuf, cBufSize, GetModuleHandle(NULL), NULL, &pParser);
    if (FAILED(hr))
        goto Failure;

    // Done with buffer
    HFree(pBuf);
    pBuf = NULL;

    // Create host (will auto-destroy when HWND is destroyed)
    NativeHWNDHost::Create(L"Element Details...", hParent, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 
        360, 540, 0, WS_OVERLAPPEDWINDOW, NHHO_NoSendQuitMessage | NHHO_DeleteOnHWNDDestroy, &pnhh);
    if (!pnhh)
        goto Failure;

    Element::StartDefer();
    fEndDeferOnFail = true;

    // Create root
    HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);
    if (!phe)
        goto Failure;

    // Create tree using parser (via substituation)
    hr = pParser->CreateElement(L"main", phe, &peHold);
    if (FAILED(hr))
        goto Failure;

    // Get element class
    pci = pe->GetClassInfo();

    // Populate header
    peHold = phe->FindDescendent(StrToID(L"header"));
    if (!peHold)
        goto Failure;

    if (pe->GetID())
    {
        WCHAR szID[128];
        GetAtomNameW(pe->GetID(), szID, DUIARRAYSIZE(szID));
        _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"%s [%s]", pci->GetName(), szID);
    }
    else
        _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"%s", pci->GetName());
    *(szTemp + (DUIARRAYSIZE(szTemp) - 1)) = NULL;
    
    peHold->SetContentString(szTemp);

    // Populate sub-header
    peHold = phe->FindDescendent(StrToID(L"subheader"));
    if (!peHold)
        goto Failure;

    _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"Address: 0x%p", pe);

    peHold->SetContentString(szTemp);

    // Get table for populating
    peTable = phe->FindDescendent(StrToID(L"table"));
    if (!peTable)
        goto Failure;
            
    // Enumerate properties
    while ((ppi = pci->EnumPropertyInfo(nEnum++)) != NULL)
    {
        hr = pParser->CreateElement(L"item", NULL, &peHold);
        if (FAILED(hr))
            goto Failure;

        // Set property string
        peHold1 = peHold->FindDescendent(StrToID(L"property"));
        if (!peHold1)
            goto Failure;

        peHold1->SetContentString(ppi->szName);

        // Set value string
        peHold1 = peHold->FindDescendent(StrToID(L"value"));
        if (!peHold1)
            goto Failure;

        pv = pe->GetValue(ppi, RetIdx(ppi));
        pv->ToString(szTemp, DUIARRAYSIZE(szTemp));
        pv->Release();
        
        peHold1->SetContentString(szTemp);

        // Add to table
        peTable->Add(peHold);        
    }

    pnhh->Host(phe);

    // Set visible
    phe->SetVisible(true);

    Element::EndDefer();

    // Done with parser
    pParser->Destroy();
    pParser = NULL;

    pnhh->ShowWindow(SW_NORMAL);

    return;
   
Failure:

    if (fEndDeferOnFail)
        Element::EndDefer();

    if (pParser)
        pParser->Destroy();

    if (pBuf)
        HFree(pBuf);

    if (pnhh)
        pnhh->DestroyWindow();  // This will destroy pnhh and remaining subtree

#endif // DBG

    return;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\emfload.cpp ===
/*
 * Metafile converter/loader
 */

#include "stdafx.h"
#include "util.h"

#include "duiemfload.h"

namespace DirectUI
{

// Caller must free using DeleteEnhMetaFile

HENHMETAFILE LoadMetaFile(LPCWSTR pszMetaFile)
{
    HENHMETAFILE hEMF = NULL;

    // Open file read only
    HANDLE hFile = CreateFileW(pszMetaFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (hFile == (HANDLE)-1)
        return NULL;

    // Create file mapping of open file
    HANDLE hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hFileMap)
    {
        CloseHandle(hFile);
        return NULL;
    }

    // Map a view of the whole file
    void* pFileMap = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);

    if (!pFileMap)
    {
        CloseHandle(hFileMap);
        CloseHandle(hFile);
        return NULL;
    }

    hEMF = LoadMetaFile(pFileMap, GetFileSize(hFile, NULL));

    // Cleanup
    UnmapViewOfFile(pFileMap);
    CloseHandle(hFileMap);
    CloseHandle(hFile);

    return hEMF;
}

HENHMETAFILE LoadMetaFile(UINT uRCID, HINSTANCE hInst)
{
    HENHMETAFILE hEMF = NULL;

    // Locate resource
    WCHAR szID[41];
    swprintf(szID, L"#%u", uRCID);

    HRSRC hResInfo = FindResourceW(hInst, szID, L"MetaFile");
    DUIAssert(hResInfo, "Unable to locate resource");

    if (hResInfo)
    {
        HGLOBAL hResData = LoadResource(hInst, hResInfo);
        DUIAssert(hResData, "Unable to load resource");

        if (hResData)
        {
            const CHAR* pBuffer = (const CHAR*)LockResource(hResData);
            DUIAssert(pBuffer, "Resource could not be locked");

            hEMF = LoadMetaFile((void*)pBuffer, SizeofResource(hInst, hResInfo));
        }
    }

    return hEMF;
}

HENHMETAFILE LoadMetaFile(void* pData, UINT cbSize)
{
    HENHMETAFILE hEMF = NULL;

    // Process file based on type
    if (((LPENHMETAHEADER)pData)->dSignature == ENHMETA_SIGNATURE)
    {
        // Found Windows Enhanced Metafile
        hEMF = SetEnhMetaFileBits(cbSize, (BYTE*)pData);
    }
    else if (*((LPDWORD)pData) == APM_SIGNATURE)
    {
        // Found Aldus Placeable Metafile (APM)
        PAPMFILEHEADER pApm = (PAPMFILEHEADER)pData;
        PMETAHEADER pMf = (PMETAHEADER)(pApm + 1);
        METAFILEPICT mfpMf;
        HDC hDC;

        // Setup metafile picture structure
        mfpMf.mm = MM_ANISOTROPIC;
        mfpMf.xExt = MulDiv(pApm->bbox.right-pApm->bbox.left, HIMETRICINCH, pApm->inch);
        mfpMf.yExt = MulDiv(pApm->bbox.bottom-pApm->bbox.top, HIMETRICINCH, pApm->inch);
        mfpMf.hMF = NULL;

        // Reference DC
        hDC = GetDC(NULL);
        SetMapMode(hDC,MM_TEXT);

        // Convert to an Enhanced Metafile
        hEMF = SetWinMetaFileBits(pMf->mtSize * 2, (PBYTE)pMf, hDC, &mfpMf);

        ReleaseDC(NULL, hDC);
    }
    else
    {
        // Found Windows 3.x Metafile
		hEMF = SetWinMetaFileBits(cbSize, (PBYTE)pData, NULL, NULL);
    }

    return hEMF;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_UTIL_PUBLISHED_H_INCLUDED
#define DUI_UTIL_PUBLISHED_H_INCLUDED

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"
#include "duininegrid.h"

#endif // DUI_UTIL_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\sources.inc ===
!IF 0

    DirectUI Util Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\convert.cpp        \
        ..\emfload.cpp        \
        ..\gadget.cpp         \
        ..\ninegrid.cpp       \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxutil.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\gadget.cpp ===
/*
 * Manual Gadget utility methods
 */

#include "stdafx.h"
#include "util.h"

#include "duigadget.h"

namespace DirectUI
{

void SetGadgetOpacity(HGADGET hgad, BYTE dAlpha)
{
#ifdef GADGET_ENABLE_GDIPLUS

    //
    // When using GDI+, we are directly modifying the alpha channel of our 
    // primitives, rather than using DirectUser's buffers.
    //

    UNREFERENCED_PARAMETER(hgad);
    UNREFERENCED_PARAMETER(dAlpha);

#else

    // Set gadget opacity (225=opaque, 0=transparent)
    if (dAlpha == 255) 
    {
        SetGadgetStyle(hgad, 0, GS_BUFFERED);
        SetGadgetStyle(hgad, 0, GS_OPAQUE);
    } 
    else 
    {
        SetGadgetStyle(hgad, GS_OPAQUE, GS_OPAQUE);
        SetGadgetStyle(hgad, GS_BUFFERED, GS_BUFFERED);

        BUFFER_INFO bi = {0};
        bi.cbSize = sizeof(BUFFER_INFO);
        bi.nMask = GBIM_ALPHA;
        bi.bAlpha = dAlpha;

        SetGadgetBufferInfo(hgad, &bi);
    }
    
#endif    
}

void OffsetGadgetPosition(HGADGET hgad, int x, int y)
{
    RECT rc;
    GetGadgetRect(hgad, &rc, SGR_PARENT);
    rc.left += x;
    rc.top += y;
    SetGadgetRect(hgad, rc.left, rc.top, 0, 0, SGR_PARENT | SGR_MOVE);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_UTIL_STDAFX_H_INCLUDED
#define DUI_UTIL_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_UTIL_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\stdafxutil.cpp ===
/*
 * stdafxutil.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\ninegrid.cpp ===
/*
 * NineGrid bitmap rendering (ported from UxTheme)
 */

#include "stdafx.h"
#include "util.h"

#include "duininegrid.h"

namespace DirectUI
{

//---------------------------------------------------------------------------
void GetAlignedRect(HALIGN halign, VALIGN valign, CONST RECT *prcFull, 
    int width, int height, RECT *prcTrue)
{
    //---- apply HALIGN ----
    if (halign == HA_LEFT)
    {
        prcTrue->left = prcFull->left;
    }
    else if (halign == HA_CENTER)
    {
        int diff = WIDTH(*prcFull) - width;
        prcTrue->left = prcFull->left + (diff/2); 
    }
    else            // halign == HA_RIGHT
    {
        prcTrue->left = prcFull->right - width;
    }

    if (prcTrue->left < prcFull->left)
        prcTrue->left = prcFull->left;

    if ((prcTrue->left + width) > prcFull->right)
        prcTrue->right = prcFull->right;
    else
        prcTrue->right = prcTrue->left + width;

    //---- apply VALIGN ----
    if (valign == VA_TOP)
    {
        prcTrue->top = prcFull->top;
    }
    else if (valign == VA_CENTER)
    {
        int diff = HEIGHT(*prcFull) - height;
        prcTrue->top = prcFull->top + (diff/2); 
    }
    else            // valign == VA_BOTTOM
    {
        prcTrue->top = prcFull->bottom - height;
    }

    if (prcTrue->top < prcFull->top)
        prcTrue->top = prcFull->top;

    if ((prcTrue->top + height) > prcFull->bottom)
        prcTrue->bottom = prcFull->bottom;
    else
        prcTrue->bottom = prcTrue->top + height;
}
//---------------------------------------------------------------------------
HBRUSH CreateDibDirectBrush(HDC hdcSrc, int iSrcX, int iSrcY, int iSrcW, int iSrcH, 
    BITMAPINFOHEADER *pSrcHdr, BYTE *pSrcBits, BRUSHBUFF *pbb, BOOL fFlipIt)
{
    UNREFERENCED_PARAMETER(hdcSrc);

    HBRUSH hbr = NULL;

//    ATLAssert(pSrcHdr != NULL);
//    ATLAssert(pSrcBits != NULL);
//    ATLAssert(pbb != NULL);

    //---- ensure pbb->pBuff is big enough for our temp. brush DIB ----
    BITMAPINFOHEADER *pHdr;
    BYTE *pDest;
    BYTE *pSrc;
    int iBytesPerPixel = pSrcHdr->biBitCount/8;

    int iSrcRawBytesPerRow = pSrcHdr->biWidth*iBytesPerPixel;
    int iSrcBytesPerRow = ((iSrcRawBytesPerRow + 3)/4)*4;

    int iDestRawBytesPerRow = iSrcW*iBytesPerPixel;
    int iDestBytesPerRow = ((iDestRawBytesPerRow + 3)/4)*4;

    int iBuffLen = sizeof(BITMAPINFOHEADER) + iSrcH*iDestBytesPerRow;

    if (iBuffLen > pbb->iBuffLen)          // reallocate 
    {
        HFree(pbb->pBuff);
        pbb->iBuffLen = 0;

        pbb->pBuff = (BYTE*)HAlloc(iBuffLen * sizeof(BYTE));
        if (! pbb->pBuff)
        {
//            MakeError32(E_OUTOFMEMORY);
            goto exit;
        }
        
        pbb->iBuffLen = iBuffLen;
    }

    //---- fill out hdr ----
    pHdr = (BITMAPINFOHEADER *)pbb->pBuff;
    memset(pHdr, 0, sizeof(BITMAPINFOHEADER));

    pHdr->biSize = sizeof(BITMAPINFOHEADER);
    pHdr->biWidth = iSrcW;
    pHdr->biHeight = iSrcH;
    pHdr->biPlanes = 1;
    pHdr->biBitCount = static_cast<WORD>(iBytesPerPixel * 8);

    //---- NOTE: rows are reversed in the DIB src and should also be----
    //---- built reversed in the DIB dest ----

    //---- prepare to copy brush bits to buff ----
    pSrc = pSrcBits + (pSrcHdr->biHeight - (iSrcY + iSrcH))*iSrcBytesPerRow + iSrcX*iBytesPerPixel;
    pDest = pbb->pBuff + sizeof(BITMAPINFOHEADER);

    if (fFlipIt)       // trickier case - mirror the pixels in each row
    {
        int iTwoPixelBytes = 2*iBytesPerPixel;

        //---- copy each row ----
        for (int iRow=0; iRow < iSrcH; iRow++)
        {
            pDest += (iDestRawBytesPerRow - iBytesPerPixel);      // point at last value
            BYTE *pSrc2 = pSrc;

            //---- copy each pixel in current row ----
            for (int iCol=0; iCol < iSrcW; iCol++)
            {
                //---- copy a single pixel ----
                for (int iByte=0; iByte < iBytesPerPixel; iByte++)
                    *pDest++ = *pSrc2++;

                pDest -= iTwoPixelBytes;        // point at previous value
            }

            pSrc += iSrcBytesPerRow;
            pDest += (iDestBytesPerRow + iBytesPerPixel);
        }
    }
    else            // non-mirrored rows
    {
        //---- copy each row ----
        for (int iRow=0; iRow < iSrcH; iRow++)
        {
            memcpy(pDest, pSrc, iSrcW*iBytesPerPixel);

            pSrc += iSrcBytesPerRow;
            pDest += iDestBytesPerRow;
        }
    }

    //---- now create the brush ----
    hbr = CreateDIBPatternBrushPt(pbb->pBuff, DIB_RGB_COLORS);

exit:
    return hbr;
}
//---------------------------------------------------------------------------
HBRUSH CreateDibBrush(HDC hdcSrc, int iSrcX, int iSrcY, int iSrcW, int iSrcH, BOOL fFlipIt)
{
    //---- this function is REALLY SLOW for 32-bit source dc/bitmap ----
    
    //---- copy our target portion of bitmap in hdcSrc to a memory dc/bitmap ----
    //---- and then call CreatePatternBrush() to make a brush from it ----

    HBRUSH hbr = NULL;
    DWORD dwOldLayout = 0;

    HBITMAP hBitmap = CreateCompatibleBitmap(hdcSrc, iSrcW, iSrcH);
    if (hBitmap)
    {
        HDC hdcMemory = CreateCompatibleDC(hdcSrc);
        if (hdcMemory)
        {
            if (fFlipIt)
            {
                dwOldLayout = GetLayout(hdcMemory);

                //---- toggle layout so it is different than png->hdcSrc ----
                if (dwOldLayout & LAYOUT_RTL)
                    SetLayout(hdcMemory, 0);
                else
                    SetLayout(hdcMemory, LAYOUT_RTL);
            }

            HBITMAP hbmOld = (HBITMAP) SelectObject(hdcMemory, hBitmap);
            if (hbmOld)
            {
                BitBlt(hdcMemory, 0, 0, iSrcW, iSrcH, hdcSrc, iSrcX, iSrcY, SRCCOPY);

                SelectObject(hdcMemory, hbmOld);

                hbr = CreatePatternBrush(hBitmap);
            }

            if (fFlipIt)
                SetLayout(hdcMemory, dwOldLayout);

            DeleteDC(hdcMemory);
        }

        DeleteObject(hBitmap);
    }

    return hbr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltCopy(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY)
{
    HRESULT hr = S_OK;

    int width = iDestW;
    int height = iDestH;

    //---- draw image in true size ----
    if (pmb->dwOptions & DNG_ALPHABLEND)
    {
        AlphaBlend(pmb->hdcDest, iDestX, iDestY, width, height, 
            pmb->hdcSrc, iSrcX, iSrcY, width, height, 
            pmb->AlphaBlendInfo);
    }
    else if (pmb->dwOptions & DNG_TRANSPARENT)
    {
        TransparentBlt(pmb->hdcDest, iDestX, iDestY, width, height, 
            pmb->hdcSrc, iSrcX, iSrcY, width, height, 
            pmb->crTransparent);
    }
    else
    {
        if (pmb->dwOptions & DNG_DIRECTBITS)
        {
            //---- this guy requires flipped out y values ----
            int iTotalHeight = pmb->pbmHdr->biHeight;

            int iSrcY2 = iTotalHeight - (iSrcY + iDestH);

            StretchDIBits(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH,
                iSrcX, iSrcY2, iDestW, iDestH, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                DIB_RGB_COLORS, SRCCOPY);
        }
        else
        {
            BOOL fOk = BitBlt(pmb->hdcDest, iDestX, iDestY, width, height, 
                pmb->hdcSrc, iSrcX, iSrcY, SRCCOPY);

            if (! fOk)       // something went wrong
            {
                //ATLAssert(0);       // local testing only

                hr = GetLastError();
            }
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltStretch(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_OK;
    
    //---- do the real work here ----
    if (pmb->dwOptions & DNG_ALPHABLEND)
    {
        AlphaBlend(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
            pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, 
            pmb->AlphaBlendInfo);
    }
    else if (pmb->dwOptions & DNG_TRANSPARENT)
    {
        TransparentBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
            pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, 
            pmb->crTransparent);
    }
    else
    {
        if (pmb->dwOptions & DNG_DIRECTBITS)
        {
            //---- this guy requires flipped out y values ----
            int iTotalHeight = pmb->pbmHdr->biHeight;

            int iSrcY2 = iTotalHeight - (iSrcY + iSrcH);

            StretchDIBits(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH,
                iSrcX, iSrcY2, iSrcW, iSrcH, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                DIB_RGB_COLORS, SRCCOPY);
        }
        else
        {
            StretchBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
                pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, SRCCOPY);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltTile(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_OK;
    BOOL fFlipGrids = pmb->dwOptions & DNG_FLIPGRIDS;

    //---- default origin ----
    int alignx = iDestX;         
    int aligny = iDestY;         

    if (pmb->dwOptions & DNG_TILEORIGIN)
    {
        alignx = pmb->ptTileOrigin.x;
        aligny = pmb->ptTileOrigin.y;
    }

    if ((pmb->dwOptions & DNG_ALPHABLEND) || (pmb->dwOptions & DNG_TRANSPARENT) || 
        (pmb->dwOptions & DNG_DIRECTBITS) || (pmb->dwOptions & DNG_MANUALTILING))
    {
        //---- must do manual tiling ----
        int maxbot = iDestY + iDestH;
        int maxright = iDestX + iDestW;

        int iTileCount = 0;

        for (int yoff=iDestY; yoff < maxbot; yoff+=iSrcH)
        {
            for (int xoff=iDestX; xoff < maxright; xoff+=iSrcW)
            {
                //---- manual clipping ----
                int width = min(iSrcW, maxright - xoff);
                int height = min(iSrcH, maxbot - yoff);
    
                if (pmb->dwOptions & DNG_ALPHABLEND)
                {
                    AlphaBlend(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, width, height, pmb->AlphaBlendInfo);
                }
                else if (pmb->dwOptions & DNG_TRANSPARENT)
                {
                    TransparentBlt(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, width, height, pmb->crTransparent);
                }
                else if (pmb->dwOptions & DNG_DIRECTBITS)
                {
                    //---- this guy requires flipped out y values ----
                    int iTotalHeight = pmb->pbmHdr->biHeight;

                    int iSrcY2 = iTotalHeight - (iSrcY + height);

                    StretchDIBits(pmb->hdcDest, xoff, yoff, width, height,
                        iSrcX, iSrcY2, width, height, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                        DIB_RGB_COLORS, SRCCOPY);
                }
                else        // manual tiling option
                {
                    BitBlt(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, SRCCOPY);
                }

                iTileCount++;
            }
        }

//        Log(LOG_TILECNT, L"Manual Tile: Grid=%d, SrcW=%d, SrcH=%d, DstW=%d, DstH=%d, TileCount=%d", 
//            pmb->iCacheIndex, iSrcW, iSrcH, iDestW, iDestH, iTileCount);
    }
    else
    {
        //---- FAST TILE: need to create a sub-bitmap ----
        HBRUSH hBrush = NULL;

        //---- need a tiling brush - try cache first ----
        if ((pmb->dwOptions & DNG_CACHEBRUSHES) && (pmb->pCachedBrushes))
        {
            hBrush = pmb->pCachedBrushes[pmb->iCacheIndex];
        }

        if (! hBrush)       // need to build one
        {
            if (pmb->dwOptions & DNG_DIRECTBRUSH)
            {
                hBrush = CreateDibDirectBrush(pmb->hdcSrc, iSrcX, iSrcY,
                    iSrcW, iSrcH, pmb->pbmHdr, pmb->pBits, pmb->pBrushBuff, fFlipGrids);
            }
            else
            {
//                Log(LOG_TILECNT, L"CreateDibBrush: MirrDest=%d, MirrSrc=%d, FlipDest=%d, FlipSrc=%d",
//                    IsMirrored(pmb->hdcDest), IsMirrored(pmb->hdcSrc), IsFlippingBitmaps(pmb->hdcDest),
//                    IsFlippingBitmaps(pmb->hdcSrc));

                hBrush = CreateDibBrush(pmb->hdcSrc, iSrcX, iSrcY,
                    iSrcW, iSrcH, fFlipGrids);
            }
        }

        //---- align brush with rect being painted ----
        if (fFlipGrids)      
        {
            //---- calculate brush origin in device coords ----
            POINT pt = {alignx + iDestW - 1, aligny};
            LPtoDP(pmb->hdcDest, &pt, 1);

            alignx = pt.x;
        }

        SetBrushOrgEx(pmb->hdcDest, alignx, aligny, NULL);

        HBRUSH hbrOld = (HBRUSH)SelectObject(pmb->hdcDest, hBrush);
        PatBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, PATCOPY);
        SelectObject(pmb->hdcDest, hbrOld);

        //RECT rc = {iDestX, iDestY, iDestX+iDestW, iDestY+iDestH};
        //FillRect(pmb->hdcDest, &rc, hBrush);

        //---- add back to cache, if possible ----
        if ((pmb->dwOptions & DNG_CACHEBRUSHES) && (pmb->pCachedBrushes))
        {
            pmb->pCachedBrushes[pmb->iCacheIndex] = hBrush;
        }
        else
        {
            DeleteObject(hBrush);
        }

//        Log(LOG_TILECNT, L"PatBlt() Tile: Grid=%d, SrcW=%d, SrcH=%d, DstW=%d, DstH=%d", 
//            pmb->iCacheIndex, iSrcW, iSrcH, iDestW, iDestH);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBlt(MBINFO *pmb, MBSIZING eSizing, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_FALSE;
    RECT rect;

    //---- validate MBINFO ----
    if (pmb->dwSize != sizeof(MBINFO))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //---- anything to paint from? ----
    if ((iSrcW <= 0) || (iSrcH <= 0))
        goto exit;

    //---- clipping ----
    rect = pmb->rcClip;

    if (iDestX < rect.left)
        iDestX = rect.left;

    if (iDestY < rect.top)
        iDestY = rect.top;

    if (iDestX + iDestW > rect.right)
        iDestW = rect.right - rect.left;

    if (iDestY + iDestH > rect.bottom)
        iDestH = rect.bottom - rect.top;

    //---- anything iLeft to draw? ----
    if ((iDestW <= 0) || (iDestH <= 0))
        goto exit;

    //---- dispatch to correct handler ----
    if (eSizing == MB_COPY)
    {
        hr = MultiBltCopy(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY);
    }
    else if (eSizing == MB_STRETCH)
    {
        hr = MultiBltStretch(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY, iSrcW, iSrcH);
    }
    else if (eSizing == MB_TILE)
    {
        hr = MultiBltTile(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY, iSrcW, iSrcH);
    }
    else
    {
        hr = E_INVALIDARG;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT DrawSampledBorders(NGINFO *png, HDC hdcSrc, int lw1, int rw1, int th1, int bh1)
{
    UNREFERENCED_PARAMETER(hdcSrc);
    UNREFERENCED_PARAMETER(bh1);
    UNREFERENCED_PARAMETER(th1);
    UNREFERENCED_PARAMETER(rw1);
    UNREFERENCED_PARAMETER(lw1);

    int iCount, iTop, iBot, iLeft, iRight;
    HDC hdcDest = png->hdcDest;
    COLORREF crOld = SetBkColor(hdcDest, 0);
    RECT rcDest = png->rcDest;

    //---- draw left borders ----
    iCount = png->iSrcMargins[0];
    iTop = rcDest.top;
    iBot = rcDest.bottom;
    iLeft = rcDest.left;

    COLORREF *pNextColor = png->pcrBorders;

    if (png->dwOptions & DNG_SOLIDCONTENT)
        pNextColor++;       // skip over content color

    for (int i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iTop, iLeft+1, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iBot--;
        iLeft++;
    }

    //---- draw right borders ----
    iCount = png->iSrcMargins[1];
    iTop = rcDest.top;
    iBot = rcDest.bottom;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iRight-1, iTop, iRight, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iBot--;
        iRight--;
    }

    //---- draw top borders ----
    iCount = png->iSrcMargins[2];
    iTop = rcDest.top;
    iLeft = rcDest.left;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iTop, iRight, iTop+1};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iLeft++;
        iRight--;
    }

    //---- draw bottom borders ----
    iCount = png->iSrcMargins[3];
    iBot = rcDest.bottom;
    iLeft = rcDest.left;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iBot-1, iRight, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iBot--;
        iLeft++;
        iRight--;
    }

    //---- restore old color ----
    SetBkColor(hdcDest, crOld);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT DrawNineGrid(NGINFO *png)
{
    HBITMAP hOldBitmap = NULL;
    MBINFO mbinfo = {sizeof(mbinfo)};
    HRESULT hr = S_OK;
    HDC hdcSrc = NULL;
    BOOL fBorder;
    BOOL fContent;
    DWORD dwOldLayout = 0;

    RECT rcDest = png->rcDest;
    RECT rcSrc = png->rcSrc;

    //---- the source margin variables ----
    int lw1, rw1, th1, bh1;
    lw1 = png->iSrcMargins[0];
    rw1 = png->iSrcMargins[1];
    th1 = png->iSrcMargins[2];
    bh1 = png->iSrcMargins[3];

    if ((lw1 < 0) || (rw1 < 0) || (th1 < 0) || (bh1 < 0))   // not valid
    {
        hr = E_FAIL;
        goto exit;
    }

    int iDestW, iDestH;
    iDestH = HEIGHT(rcDest);
    iDestW = WIDTH(rcDest);

    int iSrcW, iSrcH;
    iSrcH = HEIGHT(rcSrc);
    iSrcW = WIDTH(rcSrc);

    //---- prevent left/right src margins from drawing overlapped ----
    if (lw1 + rw1 > iDestW)
    {
        //---- reduce each but maintain ratio ----
        lw1 = int(.5 + float(lw1*iDestW)/float(lw1+rw1));
        rw1 = iDestW - lw1;
    }

    //---- prevent top/bottom src margins from drawing overlapped ----
    if ((th1 + bh1) > iDestH)
    {
        //---- reduce each but maintain ratio ----
        th1 = int(.5 + float(th1*iDestH)/float(th1+bh1));
        bh1 = iDestH - th1;
    }

    //---- make our bitmap usable ----
    hdcSrc = CreateCompatibleDC(png->hdcDest);
    if (! hdcSrc)
    {
        hr = GetLastError();
        goto exit;
    }
    
    if (png->dwOptions & DNG_FLIPGRIDS)
    {
        dwOldLayout = GetLayout(hdcSrc);

        //---- toggle layout so it is different than png->hdcDest ----
        if (dwOldLayout & LAYOUT_RTL)
            SetLayout(hdcSrc, 0);
        else
            SetLayout(hdcSrc, LAYOUT_RTL);
    }
    
    hOldBitmap = (HBITMAP) SelectObject(hdcSrc, png->hBitmap);
    if (! hOldBitmap)       // something wrong with png->hBitmap
    {
        hr = GetLastError();
        goto exit;
    }

    //---- transfer info from png to mbinfo ----
    mbinfo.hdcSrc = hdcSrc;
    mbinfo.hdcDest = png->hdcDest;
    mbinfo.dwOptions = png->dwOptions;

    mbinfo.crTransparent = png->crTransparent;
    mbinfo.rcClip = png->rcClip;
    mbinfo.hBitmap = png->hBitmap;

    mbinfo.pBits = png->pBits;
    mbinfo.pbmHdr = png->pbmHdr;

    mbinfo.AlphaBlendInfo = png->AlphaBlendInfo;
    mbinfo.ptTileOrigin = png->ptTileOrigin;
    mbinfo.iCacheIndex = 0;
    mbinfo.pCachedBrushes = png->pCachedBrushes;

    mbinfo.pBrushBuff = png->pBrushBuff;

    //---- make some values easier to read ----
    fBorder = ((png->dwOptions & DNG_OMITBORDER)==0);
    fContent = ((png->dwOptions & DNG_OMITCONTENT)==0);

    if ((png->eImageSizing == ST_TRUESIZE) && (fBorder) && (fContent))            // just draw & exit
    {
        if (png->dwOptions & DNG_BGFILL)
        {
            //---- fill bg ----
            HBRUSH hbr = CreateSolidBrush(png->crFill);
            if (! hbr)
            {
                hr = GetLastError();
                goto exit;
            }

            FillRect(png->hdcDest, &rcDest, hbr);
            DeleteObject(hbr);
        }

        RECT rcActual;
        GetAlignedRect(png->eHAlign, png->eVAlign, &rcDest, iSrcW, iSrcH, &rcActual);

        hr = MultiBlt(&mbinfo, MB_COPY, rcActual.left, rcActual.top, iSrcW, iSrcH,
            rcSrc.left, rcSrc.top, iSrcW, iSrcH);
        goto exit;
    }

    MBSIZING eSizing, eDefaultSizing;
    if (png->eImageSizing > ST_TILE)            // special tiling mode (dependent on grid)
        eSizing = MB_STRETCH;       // will correct where needed
    else
        eSizing = (MBSIZING)png->eImageSizing;

    //---- optimize for no borders specified
    if ((! lw1) && (! rw1) && (! th1) && (! bh1))
    {
        if (fContent)
        {
            mbinfo.iCacheIndex = 0;

            hr = MultiBlt(&mbinfo, eSizing, rcDest.left, rcDest.top, iDestW, iDestH,
                rcSrc.left, rcSrc.top, iSrcW, iSrcH);
        }

        goto exit;
    }

    //---- the destination margin variables ----
    int lw2, rw2, th2, bh2;
    lw2 = png->iDestMargins[0];
    rw2 = png->iDestMargins[1];
    th2 = png->iDestMargins[2];
    bh2 = png->iDestMargins[3];

    int w2;
    w2 = iDestW - lw2 - rw2;
    int h2;
    h2 = iDestH - th2 - bh2;
    
    //---- prevent left/right dest margins from drawing overlapped ----
    if (lw2 + rw2 > iDestW)
    {
        //---- reduce each but maintain ratio ----
        lw2 = int(.5 + float(lw2*iDestW)/float(lw2+rw2));
        rw2 = iDestW - lw2;
    }

    //---- prevent top/bottom dest margins from drawing overlapped ----
    if ((th2 + bh2) > iDestH)
    {
        //---- reduce each but maintain ratio ----
        th2 = int(.5 + float(th2*iDestH)/float(th2+bh2));
        bh2 = iDestH - th2;
    }

    eDefaultSizing = eSizing;

    if (fContent)
    {
        //---- can we draw content as a solid color? ----
        if ((png->dwOptions & DNG_SOLIDCONTENT) && (png->pcrBorders))
        {
            //---- fast rect draw ----
            COLORREF crContent = *png->pcrBorders;       // first one is content color

            COLORREF crOld = SetBkColor(png->hdcDest, crContent);
            RECT rcLine = {rcDest.left + lw2, rcDest.top + th2, rcDest.right - rw2,
                rcDest.bottom - bh2};

            ExtTextOut(png->hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);
            
            //---- restore color ----
            SetBkColor(png->hdcDest, crOld);
        }
        else
        {
            //---- middle area ----
            if (png->eImageSizing == ST_TILECENTER)
                eSizing = MB_TILE;
            else
                eSizing = eDefaultSizing;

            mbinfo.iCacheIndex = 0;

            hr = MultiBlt(&mbinfo, eSizing, 
                    // destination: x, y, width, height
                    rcDest.left + lw2, rcDest.top + th2, w2, h2,
                    // source: x, y, width, height
                    rcSrc.left + lw1, rcSrc.top + th1, iSrcW-lw1-rw1, iSrcH-th1-bh1);

            if (FAILED(hr))
                goto exit;
        }
    }

    if (fBorder)
    {
        //---- can we draw borders as solids? ----
        if ((png->dwOptions & DNG_SOLIDBORDER) && (png->pcrBorders))
        {
            hr = DrawSampledBorders(png, hdcSrc, lw1, rw1, th1, bh1);
            goto exit;
        }

        //---- here come the stretch/tile areas ----
        //---- upper/middle area ----
        if (png->eImageSizing == ST_TILEHORZ)
            eSizing = MB_TILE;
        else
            eSizing = eDefaultSizing;
        
        mbinfo.iCacheIndex = 2;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left + lw2, rcDest.top, w2, th2,  
                // source: x, y, width, height
                rcSrc.left + lw1, rcSrc.top, iSrcW-lw1-rw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- lower/middle area ----
        mbinfo.iCacheIndex = 4;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left + lw2, rcDest.bottom-bh2, w2, bh2, 
                // source: x, y, width, height
                rcSrc.left+lw1, rcSrc.top+iSrcH-bh1, iSrcW-lw1-rw1, bh1);

        if (FAILED(hr))
            goto exit;

        //---- left/middle area ----
        if (png->eImageSizing == ST_TILEVERT)
            eSizing = MB_TILE;
        else
            eSizing = eDefaultSizing;

        mbinfo.iCacheIndex = 1;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left, rcDest.top + th2, lw2, h2,
                // source: x, y, width, height
                rcSrc.left, rcSrc.top+th1, lw1, iSrcH-th1-bh1);

        if (FAILED(hr))
            goto exit;

        //---- right/middle area ----
        mbinfo.iCacheIndex = 3;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.top + th2, rw2, h2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top+th1, rw1, iSrcH-th1-bh1);

        if (FAILED(hr))
            goto exit;

        //---- upper/left corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.left, rcDest.top, lw2, th2, 
                // source: x, y, width, height
                rcSrc.left, rcSrc.top, lw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- upper/right corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.top, rw2, th2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top, rw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- bottom/right corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.bottom-bh2, rw2, bh2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top+iSrcH-bh1, rw1, bh1);

        if (FAILED(hr))
            goto exit;
    
        //---- bottom/left corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.left, rcDest.bottom-bh2, lw2, bh2, 
                // source: x, y, width, height
                rcSrc.left, rcSrc.top+iSrcH-bh1, lw1, bh1);

        if (FAILED(hr))
            goto exit;
    }

exit:
    if (hdcSrc)
    {
        if (png->dwOptions & DNG_FLIPGRIDS)
            SetLayout(hdcSrc, dwOldLayout);

        if (hOldBitmap)
            SelectObject(hdcSrc, hOldBitmap);

        DeleteDC(hdcSrc);
    }

    return hr;
}
//---------------------------------------------------------------------------

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\commonstdafx.h ===
/*
 * Common include for all stdafx.h project headers
 * This includes all common external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_COMMONSTDAFX_H_INCLUDED
#define DUI_COMMONSTDAFX_H_INCLUDED

#pragma once

// Engine warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function
#pragma warning (disable:4201)  // W4: Nameless struct/union may not be compiler portable

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>            // Safe string library (inline)

// Themes support
#include <uxtheme.h>

// DirectUser headers

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS

#include <DUser.h>              // DirectUser
#include <DUserCtrl.h>
#ifdef GADGET_ENABLE_GDIPLUS
#include <RenderUtil.h>
#endif

#endif // DUI_COMMONSTDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\engine\util\util.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_UTIL_UTIL_H_INCLUDED
#define DUI_UTIL_UTIL_H_INCLUDED

#pragma once

#include <DUIBaseP.h>

#endif // DUI_UTIL_UTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\public\directui.h ===
/*
 * DirectUI main header
 */

#ifndef DUI_INC_DIRECTUI_H_INCLUDED
#define DUI_INC_DIRECTUI_H_INCLUDED

#pragma once

// External dependencies

// The following is required to build using DirectUI

/******************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // TODO: Remove this when updated headers are available
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser
#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
*******************************************************/

// Base Published

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

// Util Published

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"

// Core Published

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

// Control Published

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

// Layout Published

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

// Parser Published

#include "duiparserobj.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duicorep.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUICOREP_H_INCLUDED
#define DUI_DUICOREP_H_INCLUDED

#pragma once

#include "..\Engine\Core\Published.h"

#endif // DUI_DUICOREP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duilayoutp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUILAYOUTP_H_INCLUDED
#define DUI_DUILAYOUTP_H_INCLUDED

#pragma once

#include "..\Engine\Layout\Published.h"

#endif // DUI_DUILAYOUTP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duiparserp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIPARSERP_H_INCLUDED
#define DUI_DUIPARSERP_H_INCLUDED

#pragma once

#include "..\Engine\Parser\Published.h"

#endif // DUI_DUIPARSERP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duicontrolp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUICONTROLP_H_INCLUDED
#define DUI_DUICONTROLP_H_INCLUDED

#pragma once

#include "..\Engine\Control\Published.h"

#endif // DUI_DUICONTROLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\directuip.h ===
/*
 * DirectUI main header (private)
 */

#ifndef DUI_INC_DIRECTUIP_H_INCLUDED
#define DUI_INC_DIRECTUIP_H_INCLUDED

#pragma once

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>

#include "DUIBaseP.h"
#include "DUIUtilP.h"
#include "DUICoreP.h"
#include "DUIControlP.h"
#include "DUILayoutP.h"
#include "DUIParserP.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duiutilp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIUTILP_H_INCLUDED
#define DUI_DUIUTILP_H_INCLUDED

#pragma once

#include "..\Engine\Util\Published.h"

#endif // DUI_DUIUTILP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\duibasep.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIBASEP_H_INCLUDED
#define DUI_DUIBASEP_H_INCLUDED

#pragma once

#include "..\Engine\Base\Published.h"

#endif // DUI_DUIBASEP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\makefile.inc ===
HDEPENDENCIES=exts.h stdext64.h

$(O)\DuExts.def: genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP genuedef.c >$@

#
# Dependencies for dummy targets
#
DuExts.cpp: \
        DuExts.h \
        $(HDEPENDENCIES) \
        stdext64.cpp

precomp.h: \
        DuExts.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\precomp.h ===
#ifndef DUEXTS__PreComp_h__INCLUDED
#define DUEXTS__PreComp_h__INCLUDED

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>

#include <DUser.h>

#include "DuExts.h"

#endif // DUEXTS__PreComp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\genuedef.c ===
LIBRARY DUEXTS

;
; This file allows one file (exts.h) to be used to generate extension 
; exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to DuExts.c
;

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"

;--------------------------------------------------------------------
;
; these are the extension service functions provided for the debugger
;
;--------------------------------------------------------------------

    WinDbgExtensionDllInit
    ExtensionApiVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\directui\inc\public\directuipp.h ===
/*
 * DirectUI UI file pre-process header
 */

#ifndef DUI_INC_DIRECTUIPP_H_INCLUDED
#define DUI_INC_DIRECTUIPP_H_INCLUDED

/*
 * NOTE: Various system #defines are replicated here for 2 reasons:
 *    1) Preprocessing a file like winuser.h results in a huge UIPP file
 *    2) The resultant UIPP file cannot be parsed by DUI due to function prototypes
 */


/*
 * SYSMETRIC: Retrieves system dependent information (integer values)
 *
 * Can use GetSystemMetrics() SM_* values plus DirectUI-specific values
 * as argument
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// GetSystemMetrics()

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_CXFIXEDFRAME         SM_CXDLGFRAME
#define SM_CYFIXEDFRAME         SM_CYDLGFRAME
#define SM_CXSIZEFRAME          SM_CXFRAME
#define SM_CYSIZEFRAME          SM_CYFRAME
#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#define SM_CMETRICS             83

#endif // DIRECTUIPP_IGNORESYSDEF

#define DSM_NCMAX               -1
#define DSM_CAPTIONFONTSIZE     -1
#define DSM_CAPTIONFONTWEIGHT   -2
#define DSM_CAPTIONFONTSTYLE    -3
#define DSM_MENUFONTSIZE        -4
#define DSM_MENUFONTWEIGHT      -5
#define DSM_MENUFONTSTYLE       -6
#define DSM_MESSAGEFONTSIZE     -7
#define DSM_MESSAGEFONTWEIGHT   -8
#define DSM_MESSAGEFONTSTYLE    -9
#define DSM_SMCAPTIONFONTSIZE   -10
#define DSM_SMCAPTIONFONTWEIGHT -11
#define DSM_SMCAPTIONFONTSTYLE  -12
#define DSM_STATUSFONTSIZE      -13
#define DSM_STATUSFONTWEIGHT    -14
#define DSM_STATUSFONTSTYLE     -15
#define DSM_NCMIN               -15

#define DSM_ICMAX               -16
#define DSM_ICONFONTSIZE        -16
#define DSM_ICONFONTWEIGHT      -17
#define DSM_ICONFONTSTYLE       -18
#define DSM_ICMIN               -18


/*
 * SYSMETRICSTR: Retrieves system dependent information (string values)
 *
 * Can use DirectUI-specific values as argument
 */

#define DSMS_NCMIN              1
#define DSMS_CAPTIONFONTFACE    1
#define DSMS_MENUFONTFACE       2
#define DSMS_MESSAGEFONTFACE    3
#define DSMS_SMCAPTIONFONTFACE  4
#define DSMS_STATUSFONTFACE     5
#define DSMS_NCMAX              5

#define DSMS_ICMIN              6
#define DSMS_ICONFONTFACE       6
#define DSMS_ICMAX              6


#ifndef DIRECTUIPP_IGNORESYSDEF

/*
 * DrawFrameControl
 */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

#endif // DIRECTUIPP_IGNORESYSDEF

/*
 * Themes Support (from TmSchema.h)
 *
 * Can't include UxTheme headers directly since they use 'enum' 
 * instead of #define. So, the preprocessor won't resolve to numbers.
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// Button parts
#define BP_PUSHBUTTON           1
#define BP_RADIOBUTTON          2
#define BP_CHECKBOX             3
#define BP_GROUPBOX             4
#define BP_USERBUTTON           5

// PushButton states
#define PBS_NORMAL              1
#define PBS_HOT                 2
#define PBS_PRESSED             3
#define PBS_DISABLED            4
#define PBS_DEFAULTED           5

// RadioButton states
#define RBS_UNCHECKEDNORMAL     1
#define RBS_UNCHECKEDHOT        2
#define RBS_UNCHECKEDPRESSED    3
#define RBS_UNCHECKEDDISABLED   4
#define RBS_CHECKEDNORMAL       5
#define RBS_CHECKEDHOT          6
#define RBS_CHECKEDPRESSED      7
#define RBS_CHECKEDDISABLED     8

// CheckBox states
#define CBS_UNCHECKEDNORMAL     1
#define CBS_UNCHECKEDHOT        2
#define CBS_UNCHECKEDPRESSED    3
#define CBS_UNCHECKEDDISABLED   4
#define CBS_CHECKEDNORMAL       5
#define CBS_CHECKEDHOT          6
#define CBS_CHECKEDPRESSED      7
#define CBS_CHECKEDDISABLED     8
#define CBS_MIXEDNORMAL         9
#define CBS_MIXEDHOT            10
#define CBS_MIXEDPRESSED        11
#define CBS_MIXEDDISABLED       12

// ScrollBar parts
#define SBP_ARROWBTN            1
#define SBP_THUMBBTNHORZ        2
#define SBP_THUMBBTNVERT        3
#define SBP_LOWERTRACKHORZ      4
#define SBP_UPPERTRACKHORZ      5
#define SBP_LOWERTRACKVERT      6
#define SBP_UPPERTRACKVERT      7
#define SBP_GRIPPERHORZ         8
#define SBP_GRIPPERVERT         9
#define SBP_SIZEBOX             10

// ArrowBtn states
#define ABS_UPNORMAL            1
#define ABS_UPHOT               2
#define ABS_UPPRESSED           3
#define ABS_UPDISABLED          4
#define ABS_DOWNNORMAL          5
#define ABS_DOWNHOT             6
#define ABS_DOWNPRESSED         7
#define ABS_DOWNDISABLED        8    
#define ABS_LEFTNORMAL          9
#define ABS_LEFTHOT             10
#define ABS_LEFTPRESSED         11
#define ABS_LEFTDISABLED        12
#define ABS_RIGHTNORMAL         13
#define ABS_RIGHTHOT            14
#define ABS_RIGHTPRESSED        15
#define ABS_RIGHTDISABLED       16

// ScrollBar states
#define SCRBS_NORMAL            1
#define SCRBS_HOT               2
#define SCRBS_PRESSED           3
#define SCRBS_DISABLED          4

// SizeBox states
#define SZB_RIGHTALIGN          1
#define SZB_LEFTALIGN           2

// Toolbar parts
#define TP_BUTTON               1
#define TP_DROPDOWNBUTTON       2
#define TP_SPLITBUTTON          3
#define TP_SPLITBUTTONDROPDOWN  4
#define TP_SEPARATOR            5
#define TP_SEPARATORVERT        6

// Toolbar states
#define TS_NORMAL               1
#define TS_HOT                  2
#define TS_PRESSED              3
#define TS_DISABLED             4
#define TS_CHECKED              5
#define TS_HOTCHECKED           6

#endif // DIRECTUIPP_IGNORESYSDEF

#endif // DUI_INC_DIRECTUIPP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\duexts.h ===
/****************************** Module Header ******************************\
*
* Module Name: DuExts.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Common include files for DuExts
* 
* History:
* 11-30-2000    JStall      Created
*
\***************************************************************************/
#ifndef DUEXTS__DuExts_h__INCLUDED
#define DUEXTS__DuExts_h__INCLUDED

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI

#endif // DUEXTS__DuExts_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdext64.h and stdext64.cpp.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help                - To dump short help text on all commands.\n"
         "  help -v             - To dump long help text on all commands.\n"
         "  help cmd            - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   tls
        ,"tls                           - Displays the current value in a TLS slot\n"
        ,
         "  tls slot             - dumps the given TLS slot for the current thread\n"
         "  tls slot pteb        - dumps the given TLS slot for the given thread\n"
        ,""
        ,STDARGS2)

DOIT(   gcontext
        ,"gcontext                      - Displays information on a given DUser Context\n"
        ,
         "  gcontext             - dumps info on current DUser context\n"
         "  gcontext pcontext    - dumps info on given DUser context\n"
         "  gcontext -t pteb     - dumps info on specified context\n"
         "  gcontext -v          - dumps verbose info\n"
        ,"tv"
        ,STDARGS1)

DOIT(   gme
        ,"gme -lv pme                   - Displays information on a given MsgEntry\n"
        ,
         "  gme pme             - dumps simple info for MsgEntry at pme\n"
         "  gme -l pme          - dumps MsgEntry list\n"
         "  gme -v pme          - dumps verbose info\n"
        ,"lv"
        ,STDARGS1)

DOIT(   gmsg
        ,"gmsg -v pmsg                  - Displays information on a given GMSG\n"
        ,
         "  gmsg pmsg           - dumps simple info for GMSG at pme\n"
         "  gmsg -v pmsg        - dumps verbose info\n"
        ,"v"
        ,STDARGS1)

DOIT(   gthread
        ,"gthread                       - Displays information on a given DUser Thread\n"
        ,
         "  gthread             - dumps info on current DUser thread\n"
         "  gthread pThread     - dumps info on given DUser thread\n"
         "  gthread -t pteb     - dumps info on specified thread\n"
         "  gthread -v          - dumps verbose info\n"
        ,"tv"
        ,STDARGS1)

DOIT(   gticket
        ,"gticket                       - Displays information about DUser tickets\n"
        ,"  gticket                - dumps info on all DUser tickets\n"
         "  gticket -t ticket      - dumps info on the specified ticket\n"
         "  gticket -s slot        - dumps info on the ticket at the specified slot\n"
         "  gticket -o object      - dumps info on the ticket for the specified object\n"
         "  gticket -u uniqueness  - dumps info on all tickets with the specified uniqueness\n"
         "  gticket -v             - adds verbose info (if any)\n"
        ,"tsouv"
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\kdexts.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(dwReserved);

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    WINDBG_EXTENSION_APIS *lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif
    UNREFERENCED_PARAMETER(args);
    UNREFERENCED_PARAMETER(dwProcessor);
    UNREFERENCED_PARAMETER(dwCurrentPc);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(hCurrentProcess);

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\duexts.cpp ===
/****************************** Module Header ******************************\
*
* Module Name: DuExts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 11-30-2000    JStall      Created
*
\******************************************************************************/

#include "precomp.h"
#pragma hdrstop

PSTR pszExtName         = "DUEXTS";

#include "stdext64.h"
#include "stdext64.cpp"

/******************************************************************************\
* Constants
\******************************************************************************/
#define BF_MAX_WIDTH    80
#define BF_COLUMN_WIDTH 19

#define NULL_POINTER    ((ULONG64)(0))
#define COUNTOF(x) (sizeof(x) / sizeof(x[0]))

// If you want to debug the extension, enable this.
#if 0
#undef DEBUGPRINT
#define DEBUGPRINT  Print
#endif

/******************************************************************************\
* Global variables
\******************************************************************************/
BOOL bServerDebug = TRUE;
BOOL bShowFlagNames = TRUE;
char gach1[80];
char gach2[80];
char gach3[80];
int giBFColumn;                     // bit field: current column
char gaBFBuff[BF_MAX_WIDTH + 1];    // bit field: buffer

// used in dsi() and dinp()
typedef struct {
    int     iMetric;
    LPSTR   pstrMetric;
} SYSMET_ENTRY;
#define SMENTRY(sm) {SM_##sm, #sm}

extern int gnIndent; // indentation of !dso
/******************************************************************************\
* Macros
\******************************************************************************/

#define NELEM(array) (sizeof(array)/sizeof(array[0]))

#define TestWWF(pww, flag)   (*(((PBYTE)(pww)) + (int)HIBYTE(flag)) & LOBYTE(flag))

void ShowProgress(ULONG i);

void PrivateSetRipFlags(DWORD dwRipFlags, DWORD pid);

#define VAR(v)  "DUser!" #v
#define SYM(s)  "DUser!" #s


/*
 * Use these macros to print field values, globals, local values, etc.
 * This assures consistent formating plus make the extensions easier to read and to maintain.
 */
#define STRWD1 "67"
#define STRWD2 "28"
#define DWSTR1 "%08lx %." STRWD1 "s"
#define DWSTR2 "%08lx %-" STRWD2 "." STRWD2 "s"
#define PTRSTR1 "%08p %-" STRWD1 "s"
#define PTRSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define DWPSTR1 "%08p %." STRWD1 "s"
#define DWPSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define PRTFDW1(p, f1) Print(DWSTR1 "\n", (DWORD)##p##f1, #f1)
#define PRTVDW1(s1, v1) Print(DWSTR1 "\n", v1, #s1)
#define PRTFDW2(p, f1, f2) Print(DWSTR2 "\t" DWSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD)##p##f2, #f2)
#define PRTVDW2(s1, v1, s2, v2) Print(DWSTR2 "\t" DWPSTR2 "\n", v1, #s1, v2, #s2)
#define PRTFRC(p, rc) Print("%-" STRWD2 "s{%#lx, %#lx, %#lx, %#lx}\n", #rc, ##p##rc.left, ##p##rc.top, ##p##rc.right, ##p##rc.bottom)
#define PRTFPT(p, pt) Print("%-" STRWD2 "s{%#lx, %#lx}\n", #pt, ##p##pt.x, ##p##pt.y)
#define PRTVPT(s, pt) Print("%-" STRWD2 "s{%#lx, %#lx}\n", #s, pt.x, pt.y)
#define PRTFDWP1(p, f1) Print(DWPSTR1 "\n", (DWORD_PTR)##p##f1, #f1)
#define PRTFDWP2(p, f1, f2) Print(DWPSTR2 "\t" DWPSTR2 "\n", (DWORD_PTR)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)
#define PRTFDWPDW(p, f1, f2) Print(DWPSTR2 "\t" DWSTR2 "\n", (DWORD_PTR)##p##f1, #f1, (DWORD)##p##f2, #f2)
#define PRTFDWDWP(p, f1, f2) Print(DWSTR2 "\t" DWPSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)

/*
 * Bit Fields
 */
#define BEGIN_PRTFFLG()
#define PRTFFLG(p, f)   PrintBitField(#f, (BOOLEAN)!!(p.f))
#define END_PRTFFLG()   PrintEndBitField()


#define PRTGDW1(g1) \
        { DWORD _dw1; \
            moveExpValue(&_dw1, VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); }

#define PRTGDW2(g1, g2) \
        { DWORD _dw1, _dw2; \
            moveExpValue(&_dw1, VAR(g1)); \
            moveExpValue(&_dw2, VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n",  _dw1, #g1, _dw2, #g2); }

#define PTRGPTR1(g1) \
    Print(PTRSTR1 "\n", GetGlobalPointer(VAR(g1)), #g1)

#define PRTGPTR2(g1, g2) \
    Print(PTRSTR2 "\t" PTRSTR2 "\n", GetGlobalPointer(VAR(g1)), #g1, GetGlobalPointer(VAR(g2)), #g2)


/* This macro requires char ach[...]; to be previously defined */
#define PRTWND(s, pwnd) \
        { DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #s, pwnd, ach); }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd; \
            moveExpValuePtr(&_pwnd, VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }

LPSTR GetFlags(WORD wType, DWORD dwFlags, LPSTR pszBuf, BOOL fPrintZero);
BOOL CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax);

int PtrWidth()
{
    static int width = 0;
    if (width) {
        return width;
    }
    if (IsPtr64()) {
        return width = 17;
    }
    return width = 8;
}


/*******************************************************************************\
* Flags stuff
\*******************************************************************************/

#define NO_FLAG (LPCSTR)(LONG_PTR)0xFFFFFFFF  // use this for non-meaningful entries.
#define _MASKENUM_START         (NO_FLAG-1)
#define _MASKENUM_END           (NO_FLAG-2)
#define _SHIFT_BITS             (NO_FLAG-3)
#define _CONTINUE_ON            (NO_FLAG-4)

#define MASKENUM_START(mask)    _MASKENUM_START, (LPCSTR)(mask)
#define MASKENUM_END(shift)     _MASKENUM_END, (LPCSTR)(shift)
#define SHIFT_BITS(n)           _SHIFT_BITS, (LPCSTR)(n)
#define CONTINUE_ON(arr)        _CONTINUE_ON, (LPCSTR)(arr)

#if 0
enum GF_FLAGS {
    GF_MAX
};


CONST PCSTR* aapszFlag[GF_MAX] = {
};


/***************************************************************************\
* Procedure: GetFlags
*
* Description:
*
* Converts a 32bit set of flags into an appropriate string.
* pszBuf should be large enough to hold this string, no checks are done.
* pszBuf can be NULL, allowing use of a local static buffer but note that
* this is not reentrant.
* Output string has the form: "FLAG1 | FLAG2 ..." or "0"
*
* Returns: pointer to given or static buffer with string in it.
*
* 6/9/1995 Created SanfordS
*
\***************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    CONST PCSTR *apszFlags;
    LPSTR apszFlagNames[sizeof(DWORD) * 8], pszT;
    const char** ppszNextFlag;
    UINT uFlagsCount, uNextFlag;
    DWORD dwUnnamedFlags, dwLoopFlag;
    DWORD dwShiftBits;
    DWORD dwOrigFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    if (!bShowFlagNames) {
        sprintf(pszBuf, "%x", dwFlags);
        return pszBuf;
    }

    if (wType >= GF_MAX) {
        strcpy(pszBuf, "Invalid flag type.");
        return pszBuf;
    }

    /*
     * Initialize output buffer and names array
     */
    *pszBuf = '\0';
    RtlZeroMemory(apszFlagNames, sizeof(apszFlagNames));

    apszFlags = aapszFlag[wType];

    /*
     * Build a sorted array containing the names of the flags in dwFlags
     */
    uFlagsCount = 0;
    dwUnnamedFlags = dwOrigFlags = dwFlags;
    dwLoopFlag = 1;
    dwShiftBits = 0;

reentry:
    for (i = 0; dwFlags; dwFlags >>= 1, i++, dwLoopFlag <<= 1, ++dwShiftBits) {
        const char* lpszFlagName = NULL;

        /*
         * Bail if we reached the end of the flag names array
         */
        if (apszFlags[i] == NULL) {
            break;
        }

        if (apszFlags[i] == _MASKENUM_START) {
            //
            // Masked enumerative items.
            //
            DWORD en = 0;
            DWORD dwMask = (DWORD)(ULONG_PTR)apszFlags[++i];

            // First, clear up the handled bits.
            dwUnnamedFlags &= ~dwMask;
            lpszFlagName = NULL;
            for (++i; apszFlags[i] != NULL && apszFlags[i] != _MASKENUM_END; ++i, ++en) {
                if ((dwOrigFlags & dwMask) == (en << dwShiftBits )) {
                    if (apszFlags[i] != NO_FLAG) {
                        lpszFlagName = apszFlags[i];
                    }
                }
            }
            //
            // Shift the bits and get ready for the next item.
            // Next item right after _MASKENUM_END holds the bits to shift.
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            if (lpszFlagName == NULL) {
                //
                // Could not find the match. Skip to the next item.
                //
                continue;
            }
        }
        else if (apszFlags[i] == _CONTINUE_ON) {
            //
            // Refer the other item array. Pointer to the array is stored at [i+1].
            //
            apszFlags = (LPSTR*)apszFlags[i + 1];
            goto reentry;
        }
        else if (apszFlags[i] == _SHIFT_BITS) {
            //
            // To save some space, just shift some bits..
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            continue;
        }
        else {
            /*
             * continue if this bit is not set or we don't have a name for it
             */
            if (!(dwFlags & 1) || (apszFlags[i] == NO_FLAG)) {
                continue;
            }
            lpszFlagName = apszFlags[i];
        }

        /*
         * Find the sorted position where this name should go
         */
        ppszNextFlag = apszFlagNames;
        uNextFlag = 0;
        while (uNextFlag < uFlagsCount) {
            if (strcmp(*ppszNextFlag, lpszFlagName) > 0) {
                break;
            }
            ppszNextFlag++;
            uNextFlag++;
        }
        /*
         * Insert the new name
         */
        RtlMoveMemory((char*)(ppszNextFlag + 1), ppszNextFlag, (uFlagsCount - uNextFlag) * sizeof(DWORD));
        *ppszNextFlag = lpszFlagName;
        uFlagsCount++;
        /*
         * We got a name so clear it from the unnamed bits.
         */
        dwUnnamedFlags &= ~dwLoopFlag;
    }

    /*
     * Build the string now
     */
    ppszNextFlag = apszFlagNames;
    pszT = pszBuf;
    /*
     * Add the first name
     */
    if (uFlagsCount > 0) {
        pszT += sprintf(pszT, "%s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * Concatenate all other names with " |"
     */
    while (uFlagsCount > 0) {
        pszT += sprintf(pszT, " | %s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * If there are unamed bits, add them at the end
     */
    if (dwUnnamedFlags != 0) {
        pszT += sprintf(pszT, " | %#lx", dwUnnamedFlags);
    }
    /*
     * Print zero if needed and asked to do so
     */
    if (fPrintZero && (pszT == pszBuf)) {
        sprintf(pszBuf, "0");
    }

    return pszBuf;
}

#endif

///////////////////////////////////////////////////////////////////////////
//
// Enumerated items with mask
//
///////////////////////////////////////////////////////////////////////////

typedef struct {
    LPCSTR  name;
    DWORD   value;
} EnumItem;

#define EITEM(a)     { #a, a }

/***************************************************************************\
* Helper Procedures: dso etc.
*
* 04/19/2000 Created Hiro
\***************************************************************************/

// to workaround nosy InitTypeRead
#define _InitTypeRead(Addr, lpszType)   GetShortField(Addr, (PUCHAR)lpszType, 1)

#define CONTINUE    EXCEPTION_EXECUTE_HANDLER

#define RAISE_EXCEPTION() RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL)

#define BAD_SYMBOL(symbol) \
    Print("Failed to get %s: bad symbol?\n", symbol); \
    RAISE_EXCEPTION()

#define CANT_GET_VALUE(symbol, p) \
    Print("Failed to get %s @ %p: memory paged out?\n", symbol, p); \
    RAISE_EXCEPTION()



BOOL dso(LPCSTR szStruct, ULONG64 address, ULONG dwOption)
{
    SYM_DUMP_PARAM symDump = {
        sizeof symDump, (PUCHAR) szStruct, dwOption, // 0 for default dump like dt
        address,
        NULL, NULL, NULL, 0, NULL
    };

    return Ioctl(IG_DUMP_SYMBOL_INFO, &symDump, symDump.size);
}

ULONG64 GetPointer(ULONG64 addr)
{
    ULONG64 p = 0;
    if (!ReadPointer(addr, &p)) {
        CANT_GET_VALUE("a pointer", addr);
    }
    return p;
}

DWORD GetDWord(ULONG64 addr)
{
    ULONG64 dw = 0xbaadbaad;

    if (!GetFieldData(addr, "DWORD", NULL, sizeof dw, &dw)) {
        CANT_GET_VALUE("DWORD", addr);
    }
    return (DWORD)dw;
}

WORD GetWord(ULONG64 addr)
{
    ULONG64 w = 0xbaad;

    if (!GetFieldData(addr, "WORD", NULL, sizeof w, &w)) {
        CANT_GET_VALUE("WORD", addr);
    }
    return (WORD)w;
}

BYTE GetByte(ULONG64 addr)
{
    ULONG64 b = 0;

    if (GetFieldData(addr, "BYTE", NULL, sizeof b, &b)) {
        CANT_GET_VALUE("BYTE", addr);
    }
    return (BYTE)b;
}

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) || (result < sizeof(ULONG))) {
        dprintf("GetUlongFromAddress: unable to read from %I64x\n", Location);
        RAISE_EXCEPTION();
    }

    return Value;
}


ULONG64 GetGlobalPointer(LPSTR symbol)
{
    ULONG64 pp;
    ULONG64 p = 0;

    pp = EvalExp(symbol);
    if (pp == 0) {
        BAD_SYMBOL(symbol);
    } else if (!ReadPointer(pp, &p)) {
        CANT_GET_VALUE(symbol, pp);
    }
    return p;
}

ULONG64 GetGlobalPointerNoExp(LPSTR symbol) // no exception
{
    ULONG64 p = 0;
    __try {
        p = GetGlobalPointer(symbol);
    } __except (CONTINUE) {
    }
    return p;
}

ULONG64 GetGlobalMemberAddress(LPSTR symbol, LPSTR type, LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG offset;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldOffset(type, field, &offset)) {
        BAD_SYMBOL(type);
    }

    return pVar + offset;
}

ULONG64 GetGlobalMember(LPSTR symbol, LPSTR type, LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG64 val;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldValue(pVar, type, field, val)) {
        CANT_GET_VALUE(symbol, pVar);
    }

    return val;
}

ULONG64 GetArrayElement(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index,
    LPSTR lpszType)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
        ulSize = GetTypeSize(lpszType);
    }
    ReadMemory(pAddr + ulOffsetBase + ulSize * index, &result, ulSize, NULL);

    return result;
}

ULONG64 GetArrayElementPtr(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
    }
    if (ulSize == 0) {
        ulSize = GetTypeSize("PVOID");
    }
    ReadPointer(pAddr + ulOffsetBase + ulSize * index, &result);

    return result;
}

/*
 * Show progress in time consuming commands
 * 10/15/2000 hiroyama
 */
void ShowProgress(ULONG i)
{
    const char* clock[] = {
        "\r-\r",
        "\r\\\r",
        "\r|\r",
        "\r/\r",
    };

    /*
     * Show the progress :-)
     */
    Print(clock[i % COUNTOF(clock)]);
}

#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

/***************************************************************************\
* Procedure: PrintBitField, PrintEndBitField
*
* Description: Printout specified boolean value in a structure.
*  Assuming strlen(pszFieldName) will not exceeds BF_COLUMN_WIDTH.
*
* Returns: None
*
* 10/12/1997 Created HiroYama
*
\***************************************************************************/
void PrintBitField(LPSTR pszFieldName, BOOLEAN fValue)
{
    int iWidth;
    int iStart = giBFColumn;

    sprintf(gach1, fValue ? "*%-s " : " %-s ", pszFieldName);

    iWidth = (strlen(gach1) + BF_COLUMN_WIDTH - 1) / BF_COLUMN_WIDTH;
    iWidth *= BF_COLUMN_WIDTH;

    if ((giBFColumn += iWidth) >= BF_MAX_WIDTH) {
        giBFColumn = iWidth;
        Print("%s\n", gaBFBuff);
        iStart = 0;
    }

    sprintf(gaBFBuff + iStart, "%-*s", iWidth, gach1);
}

void PrintEndBitField()
{
    if (giBFColumn != 0) {
        giBFColumn = 0;
        Print("%s\n", gaBFBuff);
    }
}


/***************************************************************************\
*
* Procedure: CopyUnicodeString
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\***************************************************************************/
BOOL
CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax)
{
    ULONG Length;
    ULONG64 Buffer;
    char szLengthName[256];
    char szBufferName[256];

    if (pData == 0) {
        pszDest[0] = '\0';
        return FALSE;
    }

    strcpy(szLengthName, pszFieldName);
    strcat(szLengthName, ".Length");
    strcpy(szBufferName, pszFieldName);
    strcat(szBufferName, ".Buffer");

    if (GetFieldValue(pData, pszStructName, szLengthName, Length) ||
        GetFieldValue(pData, pszStructName, szBufferName, Buffer)) {

        wcscpy(pszDest, L"<< Can't get name >>");
        return FALSE;
    }

    if (Buffer == 0) {
        wcscpy(pszDest, L"<null>");
    } else {
        ULONG cbText;
        cbText = min(cchMax, Length + sizeof(WCHAR));
        if (!(tryMoveBlock(pszDest, Buffer, cbText))) {
            wcscpy(pszDest, L"<< Can't get value >>");
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************\
*
* DirectUser TLS access
*
* 12/03/2000 JStall       Created
*
\***************************************************************************/

BOOL
ReadTlsValue(ULONG64 pteb, ULONG idxSlot, ULONG64 * ppValue)
{
    BOOL fSuccess = FALSE;
    ULONG64 pValue = NULL;

    //
    // Need to remove the high-bit from the TLS slot.  This is set on in 
    // Checked build to detect illegal / uninitialized slots, such as '0'.
    //

    idxSlot &= 0x7FFFFFFF;


    //
    // Get TLS info
    //

    ULONG64 pThread = 0;

//    Print("> idxSlot: %d\n", idxSlot);
//    Print("> TEB: 0x%p\n", pteb);

    if (pteb) {
        ULONG64 rgTLS   = NULL;
        ULONG ulOffset  = 0;
        ULONG ulSize    = GetTypeSize("PVOID");
//        Print("> ulSize: %d\n", ulSize);

        if (idxSlot < TLS_MINIMUM_AVAILABLE) {
            // pThread = Teb->TlsSlots[idxSlot];

            GetFieldOffset(SYM(_TEB), "TlsSlots", &ulOffset);
//            Print("> TlsSlots offset: %d\n", ulOffset);

            ReadPointer(pteb + ulOffset + ulSize * idxSlot, &pValue);
            fSuccess = TRUE;

        } else if (idxSlot >= TLS_MINIMUM_AVAILABLE + TLS_EXPANSION_SLOTS) {
            Print("ERROR: Invalid TLS index %d\n", idxSlot);
        } else {
            // pThread = Teb->TlsExpansionSlots[idxSlot - TLS_MINIMUM_AVAILABLE];

            GetFieldOffset("_TEB", "TlsExpansionSlots", &ulOffset);
//            Print("> TlsExpansionSlots offset: %d\n", ulOffset);

            rgTLS = GetPointer(pteb + ulOffset);
            if (rgTLS != NULL) {
                ReadPointer(rgTLS + ulSize * (idxSlot - TLS_MINIMUM_AVAILABLE), &pValue);
                fSuccess = TRUE;
            }
        }
    }

    *ppValue = pValue;
    return fSuccess;
}


/***************************************************************************\
*
* GetDUserThread
*
* GetDUserThread() returns the global Thread object for the current thread.
*
* 12/03/2000 JStall       Created
*
\***************************************************************************/

BOOL
GetDUserThread(ULONG64 pteb, ULONG64 * ppThread)
{
    *ppThread = NULL;


    //
    // Get DUser TLS slot
    //

    ULONG idxSlot = (ULONG) GetGlobalPointer(VAR(g_tlsThread));
    if (idxSlot == (UINT) -1) {
        Print("ERROR: Unable to get DirectUser TLS information.\n");
        return FALSE;
    }

    if ((!ReadTlsValue(pteb, idxSlot, ppThread)) || (*ppThread == NULL)) {
        Print("ERROR: Unable to get DirectUser Thread information.\n");
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igthread
*
* Dumps DUser Thread information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igthread(DWORD opts, ULONG64 param1)
{
    int nMsg;
    ULONG64 pThread = NULL, pteb = NULL;

    BOOL fVerbose = TRUE;

    __try {
        //
        // Determine options
        //

        fVerbose = opts & OFLAG(v);


        //
        // Get Thread information
        //

        if (opts & OFLAG(t)) {
            //
            // Use the specified TEB
            //

            pteb = param1;
        } else if (param1 == 0) {
            //
            // Use the current thread's TEB
            //

            GetTebAddress(&pteb);
        } 

        if (pteb != NULL) {
            GetDUserThread(pteb, &pThread);
        }
        

        //
        // Display information
        //

        if (pThread != NULL) {
            Print("DUser Thread: 0x%p  pteb: 0x%p\n", pThread, pteb);
            dso(SYM(Thread), pThread, 0);

            ULONG64 pCoreST = GetArrayElementPtr(pThread, SYM(Thread), "m_rgSTs", 0);

            if (pCoreST != NULL) {
                Print("\nDUser CoreST: 0x%p\n", pCoreST);
                dso(SYM(CoreST), pCoreST, 0);
            }

        } else {
            Print("ERROR: Unable to read DUser Thread\n");
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Itls
*
* Dumps a TLS slot value
*
*  6/08/2001 JStall       Created
*
\***************************************************************************/

BOOL Itls(DWORD opts, ULONG64 param1, ULONG64 param2)
{
    __try {
        ULONG idxSlot = ((ULONG) param1) & 0x7FFFFFFF;
        ULONG64 pteb = param2;
        ULONG64 pData;

        if (idxSlot == 0) {
            Print("ERROR: Need to specify a TLS slot.\n");
        } else {
            if (param2 == 0) {
                //
                // Need to determine the current thread
                //
                GetTebAddress(&pteb);
            }

            if (pteb == 0) {
                Print("ERROR: Unable to get thread information.\n");
            } else {
                if (!ReadTlsValue(pteb, idxSlot, &pData)) {
                    Print("ERROR: Unable to get TLS information.\n");
                } else {
                    Print("TLS[%d] = 0x%p  %d\n", idxSlot, pData, pData);
                }
            }
        }
    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igcontext
*
* Dumps DUser Context information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igcontext(DWORD opts, ULONG64 param1)
{
    int nMsg;
    ULONG64 pThread = NULL, pContext = NULL, pteb = NULL;

    BOOL fVerbose = TRUE;

    __try {
        //
        // Determine options
        //

        fVerbose = opts & OFLAG(v);


        //
        // Get Thread and Context information
        //

        if (opts & OFLAG(t)) {
            //
            // Use the specified TEB
            //

            pteb = param1;
        } else if (param1 == 0) {
            //
            // Use the current thread's TEB
            //

            GetTebAddress(&pteb);
        } else {
            pContext = param1;
        }

        if (pteb != NULL) {
            GetDUserThread(pteb, &pThread);
            Print("> Thread: 0x%p\n", pThread);

            if (pThread != NULL) {
                ULONG ulOffset;
                GetFieldOffset(SYM(Thread), "m_pContext", &ulOffset);
                Print("> ulOffset: 0x%x = d\n", ulOffset, ulOffset);

                ReadPointer(pThread + ulOffset, &pContext);
            }
        }


        //
        // Display information
        //

        if (pContext != NULL) {
            Print("DUser Context: 0x%p\n", pContext, pteb);
            dso(SYM(Context), pContext, 0);

            ULONG64 pCoreSC = GetArrayElementPtr(pContext, SYM(Context), "m_rgSCs", 0);
            ULONG64 pMotionSC = GetArrayElementPtr(pContext, SYM(Context), "m_rgSCs", 1);

            if (pCoreSC != NULL) {
                Print("\nDUser CoreSC: 0x%p\n", pCoreSC);
                dso(SYM(CoreSC), pCoreSC, 0);
            }

            if (pMotionSC != NULL) {
                Print("\nDUser MotionSC: 0x%p\n", pMotionSC);
                dso(SYM(MotionSC), pMotionSC, 0);
            }

        } else {
            Print("ERROR: Unable to read DUser Context\n");
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* DirectUser Message Dumping
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

struct DbgMsgInfo 
{
    int         cLevel;                 // Level in heirarchy
    LPCSTR      pszStructName;          // Structure to type-case to
    int         nValue;                 // Value (of children)
    LPCSTR      pszValueName;           // Message / value name
    LPCSTR      pszFieldName;           // Name of field for child lookup
};

#define DBGMI_PARENT(cLevel, pszStructName, value, pszFieldName) \
{ cLevel, SYM(pszStructName), value, #value, #pszFieldName }

#define DBGMI_LEAF(cLevel, pszStructName, value) \
{ cLevel, SYM(pszStructName), value, #value, NULL }

DbgMsgInfo g_dmi[] = {
    DBGMI_PARENT(0, GMSG_DESTROY,       GM_DESTROY,         nCode),
    DBGMI_LEAF(  1, GMSG_DESTROY,       GDESTROY_START),
    DBGMI_LEAF(  1, GMSG_DESTROY,       GDESTROY_FINAL),

    DBGMI_PARENT(0, GMSG_PAINT,         GM_PAINT,           nCmd),
    DBGMI_PARENT(1, GMSG_PAINT,         GPAINT_RENDER,      nSurfaceType),
    DBGMI_LEAF(  2, GMSG_PAINTRENDERI,  GSURFACE_HDC),
    DBGMI_LEAF(  2, GMSG_PAINTRENDERF,  GSURFACE_GPGRAPHICS),

    DBGMI_PARENT(0, GMSG_INPUT,         GM_INPUT,           nDevice),

    DBGMI_PARENT(1, GMSG_MOUSE,         GINPUT_MOUSE,       nCode),
    DBGMI_LEAF(  2, GMSG_MOUSE,         GMOUSE_MOVE),
    DBGMI_LEAF(  2, GMSG_MOUSECLICK,    GMOUSE_DOWN),
    DBGMI_LEAF(  2, GMSG_MOUSECLICK,    GMOUSE_UP),
    DBGMI_LEAF(  2, GMSG_MOUSEDRAG,     GMOUSE_DRAG),
    DBGMI_LEAF(  2, GMSG_MOUSE,         GMOUSE_HOVER),
    DBGMI_LEAF(  2, GMSG_MOUSEWHEEL,    GMOUSE_WHEEL),

    DBGMI_PARENT(1, GMSG_KEYBOARD,      GINPUT_KEYBOARD,    nCode),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_DOWN),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_UP),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_CHAR),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSDOWN),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSUP),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSCHAR),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GMOUSE_WHEEL),

    DBGMI_LEAF(  1, GMSG_INPUT,         GINPUT_JOYSTICK),

    DBGMI_PARENT(0, GMSG_CHANGESTATE,   GM_CHANGESTATE,     nCode),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_KEYBOARDFOCUS),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_MOUSEFOCUS),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_ACTIVE),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_CAPTURE),

    DBGMI_LEAF(  0, GMSG_CHANGERECT,    GM_CHANGERECT),

    DBGMI_LEAF(  0, GMSG_CHANGESTYLE,   GM_CHANGESTYLE),

    DBGMI_PARENT(0, GMSG_QUERY,         GM_QUERY,           nCode),
#ifdef GADGET_ENABLE_OLE
    DBGMI_LEAF(  1, GMSG_QUERYINTERFACE,GQUERY_INTERFACE),
    DBGMI_LEAF(  1, GMSG_QUERYINTERFACE,GQUERY_OBJECT),
#endif
    DBGMI_LEAF(  1, GMSG_QUERYRECT,     GQUERY_RECT),
    DBGMI_LEAF(  1, GMSG_QUERYDESC,     GQUERY_DESCRIPTION),
    DBGMI_LEAF(  1, GMSG_QUERYHITTEST,  GQUERY_HITTEST),
    DBGMI_LEAF(  1, GMSG_QUERYPADDING,  GQUERY_PADDING),
#ifdef GADGET_ENABLE_OLE
    DBGMI_LEAF(  1, GMSG_QUERYDROPTARGET,GQUERY_DROPTARGET),
#endif

    { -1, NULL, NULL, NULL, NULL }  // End of list
};


/***************************************************************************\
*
* Procedure: FindMsgInfo()
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

const DbgMsgInfo *
FindMsgInfo(ULONG64 pmsg)
{
    LPCSTR pszCurField = "nMsg";
    int cCurLevel = 0;
    int nSearchValue;
    const DbgMsgInfo * pdmiCur  = g_dmi;
    const DbgMsgInfo * pdmiBest = NULL;

    
    //
    // Start off by decoding the GMSG
    //

    InitTypeRead(pmsg, GMSG);
    nSearchValue = (int) ReadField(nMsg);

//    Print("...searching for nMsg: 0x%x\n", nSearchValue);

    while (pdmiCur->cLevel >= cCurLevel) {
//        Print("   %d: %s, %d\n", pdmiCur->cLevel, pdmiCur->pszStructName, pdmiCur->nValue);

        //
        // Search entries at the same level for a matching value
        //

        if (pdmiCur->cLevel == cCurLevel) {
            if (pdmiCur->nValue == nSearchValue) {
                //
                // We've found a corresponding entry.  We can update our best
                // guess as the to the message type and start searching its
                // children.
                //

                pdmiBest = pdmiCur;
                cCurLevel++;

                if (pdmiBest->pszFieldName != NULL) {
                    //
                    // This node has children that can be used to typecast the
                    // message futher.
                    //

                    // Perform an InitTypeRead() to cast the structure
                    GetShortField(pmsg, pdmiBest->pszStructName, 1);
                
                    // Read the next (int) ReadField(nMsg);
                    nSearchValue = (int) GetShortField(0, pdmiBest->pszFieldName, 0);

//                    Print("...searching for %s: 0x%x\n", pdmiBest->pszFieldName, nSearchValue);
                } else {
                    //
                    // This node has no children, so we are now down.
                    //

                    break;
                }
            }
        }

        pdmiCur++;
    }

    return pdmiBest;
}


/***************************************************************************\
*
* FormatMsgName
*
* FormatMsgName() generates a descriptive message name for a given message.
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

void
FormatMsgName(ULONG64 pmsg, char * pszMsgName, int cch, const DbgMsgInfo ** ppdmi)
{
    UNREFERENCED_PARAMETER(cch);

    if (ppdmi != NULL) {
        *ppdmi = NULL;
    }

    InitTypeRead(pmsg, GMSG);
    int nMsg = (int) ReadField(nMsg);

    if (nMsg < GM_EVENT) {
        strcpy(pszMsgName, "(Method)");
    } else if (nMsg > GM_USER) {
        strcpy(pszMsgName, "(User defined event)");
    } else {
        const DbgMsgInfo * pdmi = FindMsgInfo(pmsg);
        if (pdmi != NULL) {
            sprintf(pszMsgName, "%s : %s", pdmi->pszStructName, pdmi->pszValueName);

            if (ppdmi != NULL) {
                *ppdmi = pdmi;
            }
        } else {
            strcpy(pszMsgName, "(Unable to find GMSG)");
        }
    }
}


/***************************************************************************\
*
* Procedure: Igmsg
*
* Dumps DUser GMSG information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igmsg(DWORD opts, ULONG64 param1)
{
    int nMsg;
    LPCSTR pszMsgName;
    ULONG64 pmsg;
    CHAR szFullMsgName[256];

    BOOL fVerbose = TRUE;
    const DbgMsgInfo * pdmi = NULL;

    pmsg = param1;

    __try {
        //
        // Determine options
        //

        fVerbose    = opts & OFLAG(v);


        //
        // Get GMSG information
        //

        FormatMsgName(pmsg, szFullMsgName, COUNTOF(szFullMsgName), &pdmi);

        
        //
        // Display information
        //

        Print("GMSG = %s\n", szFullMsgName);

        if (pdmi != NULL) {
            dso(pdmi->pszStructName, pmsg, 0);
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igme
*
* Dumps DUser MsgEntry information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igme(DWORD opts, ULONG64 param1)
{
    DWORD cbSize;
    int nMsg;
    LPCSTR pszMsgName;
    ULONG64 pme, pmsg;
    CHAR szFullMsgName[256];
    const DbgMsgInfo * pdmi = NULL;

    BOOL fVerbose = TRUE;
    BOOL fList = FALSE;

    pme = param1;

    __try {
        //
        // Determine options
        //

        fVerbose    = opts & OFLAG(v);
        fList       = opts & OFLAG(l);

        while (pme != NULL) {
            //
            // Read standard information
            //

            pmsg = pme + GetTypeSize(SYM(MsgEntry));

            InitTypeRead(pmsg, GMSG);
            nMsg        = (int) ReadField(nMsg);

            FormatMsgName(pmsg, szFullMsgName, COUNTOF(szFullMsgName), &pdmi);


            //
            // Display information
            //

            if (fVerbose) {
                Print("MsgEntry:        0x%p\n", pme);
                Print("  Message:       0x%p  %s\n", pmsg, szFullMsgName);

                if (pdmi != NULL) {
                    dso(pdmi->pszStructName, pmsg, 0);
                }
            } else {
                Print("MsgEntry: 0x%p   GMSG: 0x%p   nMsg: 0x%x = %s\n", pme, pmsg, nMsg, szFullMsgName);
            }


            if (fList) {
                //
                // Reading a list, so go to next message
                //

                InitTypeRead(pme, MsgEntry);
                pme = ReadField(pNext);

                if (fVerbose & (pme != NULL)) {
                    Print("\n");
                }
            } else {
                //
                // Not displaying a list, so just exit
                //

                break;
            }
        }
    } __except (CONTINUE) {
    }

    return TRUE;
}

//
// WARNING: Keep this is sync with the real DuTicket
//
struct DuTicketCopy
{
    DWORD Index : 16;
    DWORD Uniqueness : 8;
    DWORD Type : 7;
    DWORD Unused : 1;
};

/***************************************************************************\
*
* Procedure: ForAllTickets
*
* Iterates over all of the tickets in the ticket manager, invoking the
* specified callback for each one.
*
\***************************************************************************/
typedef BOOL (*PfnTicketCallback)(DuTicketCopy ticket, ULONG64 pObject, void * pRawData);
void ForAllTickets(PfnTicketCallback pfnTicketCallback, void * pRawData)
{
	if (pfnTicketCallback == NULL) {
		return;
	}

	//
	// Prepare to read the value of g_TicketManager->m_arTicketData;
	//
	ULONG64 pTicketManager = EvalExp(VAR(g_TicketManager));
	ULONG ulTicketDataOffset = 0;
	GetFieldOffset(SYM(DuTicketManager), "m_arTicketData", &ulTicketDataOffset);
	InitTypeRead(pTicketManager + ulTicketDataOffset, DuTicketDataArray);

	//
	// Extract the data about the actual DuTicketDataArray since we are here.
	//
	ULONG64 paTicketData = ReadField(m_aT);
	int nSize = (int) ReadField(m_nSize);
	int nAllocSize = (int) ReadField(m_nAllocSize);

	//
	// Walk through the entire array.
	//
	ULONG cbTicketData = GetTypeSize("DuTicketData");

	for (int i = 0; i < nSize; i++) {
		InitTypeRead(paTicketData, DuTicketData);

		//
		// Read the fields of the ticket data.
		//
		ULONG64 pObject = ReadField(pObject);
		WORD idxFree = (WORD) ReadField(idxFree);
		BYTE cUniqueness = (BYTE) ReadField(cUniqueness);

		//
		// Construct the equivalent ticket for this ticket data.
		//
		DuTicketCopy ticket;
		ticket.Index = i;
		ticket.Uniqueness = cUniqueness;
		ticket.Type = 0; // TODO: Get this data
		ticket.Unused = 0;

        if (FALSE == pfnTicketCallback(ticket, pObject, pRawData)) {
            //
            // The callback requested that we bail out early!
            //
            break;
        }

		//
		// Advance to the next element in the array.
		//
		paTicketData += cbTicketData;
	}
}

/***************************************************************************\
*
* Procedure: DumpAllTicketsCB
*
* Callback that can be passed to the ForAllTickets function to dump the 
* ticket data for all tickets in the table.
*
\***************************************************************************/
struct DumpAllTicketsData
{
    DumpAllTicketsData(bool f) : fVerbose(f), nSize(0), cTickets(0) {}

    bool fVerbose;
    int nSize;
    int cTickets;
};

BOOL DumpAllTicketsCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpAllTicketsData * pData = (DumpAllTicketsData *) pRawData;

    if (pData == NULL) {
        return FALSE;
    }

    if (pObject != NULL || pData->fVerbose) {
        //     iSlot cUniqueness pObject
        Print("%4d   %4d         0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
    }

    //
    // Count the number of tickets that have a pointer associated with them.
    //
    if (pObject != NULL) {
        pData->cTickets++;
    }

    //
    // Count the number of slots in the table.
    //
    pData->nSize++;

	//
	// Keep going...
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByTicketCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given ticket.
*
\***************************************************************************/
struct DumpTicketByTicketData
{
    DumpTicketByTicketData(DuTicketCopy t) : ticket(t) {}
    DumpTicketByTicketData(DWORD t) : ticket(*((DuTicketCopy*) &t)) {}
	
    DuTicketCopy ticket;
};

BOOL DumpTicketByTicketCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByTicketData * pData = (DumpTicketByTicketData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Index == pData->ticket.Index) {
		if (ticket.Uniqueness != pData->ticket.Uniqueness) {
			Print("Warning: the uniqueness (%d) doesn't match!\n", pData->ticket.Uniqueness);
		}

		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByUniquenessCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given uniqueness.
*
\***************************************************************************/
struct DumpTicketByUniquenessData
{
    DumpTicketByUniquenessData(UINT c) : cUniqueness(c) {}
	
    UINT cUniqueness;
};

BOOL DumpTicketByUniquenessCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByUniquenessData * pData = (DumpTicketByUniquenessData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Uniqueness == pData->cUniqueness) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
	}

	//
	// Keep going...
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketBySlotCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given slot.
*
\***************************************************************************/
struct DumpTicketBySlotData
{
    DumpTicketBySlotData(UINT i) : iSlot(i) {}
	
    UINT iSlot;
};

BOOL DumpTicketBySlotCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketBySlotData * pData = (DumpTicketBySlotData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Index == pData->iSlot) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByObjectCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given object.
*
\***************************************************************************/
struct DumpTicketByObjectData
{
    DumpTicketByObjectData(ULONG64 p) : pObject(p) {}
	
    ULONG64 pObject;
};

BOOL DumpTicketByObjectCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByObjectData * pData = (DumpTicketByObjectData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (pObject == pData->pObject) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: Igticket
*
* Dumps DUser ticket information
*
\***************************************************************************/

BOOL Igticket(DWORD opts, ULONG64 param1)
{
    DWORD cbSize;
    int nMsg;
    LPCSTR pszMsgName;
    CHAR szFullMsgName[256];
    const DbgMsgInfo * pdmi = NULL;

    __try {
        //
        // Determine options
        //
        BOOL fTicket = opts & OFLAG(t);
        BOOL fSlot = opts & OFLAG(s);
		BOOL fObject = opts & OFLAG(o);
		BOOL fUniqueness = opts & OFLAG(u);
		BOOL fVerbose = opts & OFLAG(v);

        if (fTicket) {
			DumpTicketByTicketData data((DWORD)param1);
			ForAllTickets(DumpTicketByTicketCB, &data);
        } else if (fSlot) {
			DumpTicketBySlotData data((UINT)param1);
			ForAllTickets(DumpTicketBySlotCB, &data);
        } else if (fObject) {
			DumpTicketByObjectData data(param1);
			ForAllTickets(DumpTicketByObjectCB, &data);
        } else if (fUniqueness) {
			DumpTicketByUniquenessData data((UINT)param1);
			ForAllTickets(DumpTicketByUniquenessCB, &data);
        } else {
			//
			// Just display information about all of the tickets in the table.
			//
			//     slot uniq pObject
			Print("iSlot  cUniqueness  pObject\n");
			Print("---------------------------\n");

            DumpAllTicketsData data(fVerbose ? true : false);
			ForAllTickets(DumpAllTicketsCB, &data);

            Print("Slots: %d, Tickets: %d\n", data.nSize, data.cTickets);
        }
	} __except (CONTINUE) {
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\sources.inc ===
!IF 0

Module Name:  Shared sources.inc file for Engine projects.

Abstract:

Author:
        JStall

!ENDIF

SOURCES_USED=..\sources.inc

MSC_STDCALL=1
MSC_WARNING_LEVEL=-W4
NT_UP=0

USE_MSVCRT=1

USE_STATIC_ATL=1
ATL_VER=30

INCLUDES=\
        ..\..\inc;\
        ..\..\inc\Public;\
        ..\ObjectAPI\$(O);\
        $(WINDOWS_INC_PATH)\DUser;\
        $(BASE_INC_PATH);\
        $(SDK_INC_PATH)\gdiplus

C_DEFINES=$(C_DEFINES) -DWIN32 -D_MBCS -DDUSER_EXPORTS -DNO_DEFAULT_HEAP -DROCKALL_DIRECTUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\stdext64.h ===
/****************************** Module Header ******************************\
* Module Name: stdext64.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern ULONG64                 dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, ULONG64 src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, ULONG64 src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PULONG64 pdst, LPSTR pszExp);
VOID moveExpValuePtr(PULONG64 pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

ULONG64 OptEvalExp(LPSTR psz);
ULONG64 OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
ULONG64 EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, ULONG64);
typedef BOOL (* TYPE_STDARGS2)(DWORD, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS3)(DWORD, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS4)(DWORD, ULONG64, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, ULONG64 param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3, ULONG64 param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\assertdlg.cpp ===
// AssertDlg.cpp : Implementation of CCAssertDlg
#include "stdafx.h"
#include "AssertDlg.h"
#include "DebugCore.h"

extern HINSTANCE g_hDll;

//**************************************************************************************************
//
// Global Functions
//
//**************************************************************************************************

//-----------------------------------------------------------------------------
void CopyToClipboard(const char * pszMessage)
{
    HANDLE hText;
    UINT nStrSize;
    char * pszText;

    if (OpenClipboard(NULL)) {
        nStrSize = (UINT) strlen(pszMessage) +1;

        hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, nStrSize);
        if (hText != NULL) {
            pszText = (char *) GlobalLock(hText);
            if (pszText != NULL) {
                strcpy(pszText, pszMessage);
                GlobalUnlock(hText);

                EmptyClipboard();
                if (SetClipboardData(CF_TEXT, hText) != NULL) {
                    // Data is now owned by the clipboard
                    hText = NULL;
                }
            }

            if (hText != NULL) {
                // Unable to set clipboard data
                GlobalFree(hText);
            }
        }
        CloseClipboard();
    }
}


//**************************************************************************************************
//
// class CAssertDlg
//
//**************************************************************************************************

BOOL CAssertDlg::s_fInit = FALSE;

//******************************************************************************
//
// CAssertDlg Construction
//
//******************************************************************************

//------------------------------------------------------------------------------
CAssertDlg::CAssertDlg()
{
    m_pszExpression     = "";
    m_pszFileName       = "";
    m_szLineNum[0]      = '\0';
    m_hStackData        =  NULL;
    m_cCSEntries        = 0;
    m_cSkipLevels       = 0;
    m_fProperShutdown   = FALSE;
}


//------------------------------------------------------------------------------
CAssertDlg::~CAssertDlg()
{

}


//******************************************************************************
//
// CAssertDlg Operations
//
//******************************************************************************

//------------------------------------------------------------------------------
INT_PTR
CAssertDlg::ShowDialog(
    IN  LPCSTR pszType,
    IN  LPCSTR pszExpression,
    IN  LPCSTR pszFileName,
    IN  UINT idxLineNum,
    IN  HANDLE hStackData,
    IN  UINT cCSEntries,
    IN  UINT cSkipLevels)
{
    m_pszTitle = pszType;
    m_pszExpression = pszExpression;
    m_pszFileName =  pszFileName;
    wsprintf(m_szLineNum, "%d", (int) idxLineNum);

    m_hStackData    = hStackData;
    m_cCSEntries    = cCSEntries;
    m_cSkipLevels   = cSkipLevels;

    if (!s_fInit) {
        s_fInit = TRUE;
        INITCOMMONCONTROLSEX iccs;
        iccs.dwSize = sizeof(iccs);
        iccs.dwICC  = ICC_LISTVIEW_CLASSES;
        if (!InitCommonControlsEx(&iccs)) {
            return -1;
        }
    }

    INT_PTR nResult = DialogBoxParam(g_hDll, MAKEINTRESOURCE(IDD_Assert), NULL, DlgProc, (LPARAM) this);
    if (!m_fProperShutdown) {
        nResult = IDC_DEBUG;
    }

    return nResult;
}


//******************************************************************************
//
// CAssertDlg Message Handlers
//
//******************************************************************************

//------------------------------------------------------------------------------
void inline InsertColumn(HWND hwnd, int idxColumn, TCHAR * pszName, int fmt = LVCFMT_LEFT)
{
    _ASSERTE(::IsWindow(hwnd));

    LVCOLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = fmt;
    lvc.iOrder  = idxColumn;
    lvc.pszText = pszName;
    ListView_InsertColumn(hwnd, 0, &lvc);
}


//------------------------------------------------------------------------------
INT_PTR CALLBACK 
CAssertDlg::DlgProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CAssertDlg * pThis = (CAssertDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    if (pThis == NULL) {
        if (nMsg == WM_INITDIALOG) {
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CAssertDlg *) lParam;
            pThis->m_hwnd = hwnd;
        }
    }

    BOOL bHandled = FALSE;
    if (pThis != NULL) {
        LRESULT lRet    = 0;
        
        switch (nMsg)
        {
        case WM_INITDIALOG:
            lRet = pThis->OnInitDialog(nMsg, wParam, lParam, bHandled);
            break;

        case WM_DESTROY:
            lRet = pThis->OnDestroy(nMsg, wParam, lParam, bHandled);
            break;

        case WM_COMMAND:
            {
                WORD nCode  = HIWORD(wParam);
                WORD nID    = LOWORD(wParam);
                HWND hwndC  = (HWND) lParam;

                
                if (nCode == BN_CLICKED) {
                    switch (nID)
                    {
                    case IDCANCEL:
                    case IDC_DEBUG:
                    case IDC_IGNORE:
                        lRet = pThis->OnClicked(nCode, nID, hwndC, bHandled);
                        break;

                    case IDC_COPY:
                        lRet = pThis->OnCopy(nCode, nID, hwndC, bHandled);
                    }
                }
            }
            break;
        }

        if (bHandled) {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lRet);
        }
    }
    
    return bHandled;
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

//  CenterWindow();

    SetWindowText(m_hwnd, m_pszTitle);

    //
    // Setup the child windows and fill in all of the values in the dialog.
    //

    HWND hwndT;
    
    hwndT = GetDlgItem(m_hwnd, IDC_ebcExpression);
    SetWindowText(hwndT, m_pszExpression);

    hwndT = GetDlgItem(m_hwnd, IDC_ebcFileName);
    SetWindowText(hwndT, m_pszFileName);

    hwndT = GetDlgItem(m_hwnd, IDC_ebcLineNum);
    SetWindowText(hwndT, m_szLineNum);

    //
    // Display the stack
    //
    if ((hwndT = GetDlgItem(m_hwnd, IDC_lvcCallStack)) != NULL) {
        if (m_hStackData != NULL) {
            InsertColumn(hwndT, 0, _T("Address"));
            InsertColumn(hwndT, 1, _T("Module"));
            InsertColumn(hwndT, 2, _T("Function"));

            DWORD * pdwStackData = (DWORD *) ::GlobalLock(m_hStackData);
            _ASSERTE(pdwStackData != NULL);

            int idxItem = 0;
            DUSER_SYMBOL_INFO si;
            HANDLE hProcess = ::GetCurrentProcess();
            for (UINT nAddress = m_cSkipLevels; nAddress < m_cCSEntries; nAddress++) {
                CDebugHelp::ResolveStackItem(hProcess, pdwStackData, nAddress, si);

                TCHAR szAddr[20];
                wsprintf(szAddr, "0x%p", pdwStackData[nAddress]);

                LVITEM item;
                item.mask       = LVIF_TEXT;
                item.pszText    = szAddr;
                item.iItem      = idxItem++;
                item.iSubItem   = 0;
                int idxAdd = ListView_InsertItem(hwndT, &item);

                ListView_SetItemText(hwndT, idxAdd, 1, si.szModule);
                ListView_SetItemText(hwndT, idxAdd, 2, si.szSymbol);
            }

            ListView_SetColumnWidth(hwndT, 0, LVSCW_AUTOSIZE);
            ListView_SetColumnWidth(hwndT, 1, 130);
            ListView_SetColumnWidth(hwndT, 2, 200);

            ListView_SetExtendedListViewStyle(hwndT, LVS_EX_FULLROWSELECT);

            ::GlobalUnlock(m_hStackData);
        } else {
            EnableWindow(hwndT, FALSE);
        }
    }

    MessageBeep(MB_ICONHAND);

    return TRUE; // let Windows set the focus
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    return 0;
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(wNotifyCode);
    UNREFERENCED_PARAMETER(wID);
    UNREFERENCED_PARAMETER(hWndCtl);
    UNREFERENCED_PARAMETER(bHandled);

    m_fProperShutdown = TRUE;
    EndDialog(m_hwnd, wID);
    return 0;
}


inline void Append(char * & pszCur, const char * pszSrc)
{
    _ASSERTE(pszCur != NULL);
    _ASSERTE(pszSrc != NULL);

    strcpy(pszCur, pszSrc);
    pszCur += strlen(pszSrc);
}

//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnCopy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(wNotifyCode);
    UNREFERENCED_PARAMETER(wID);
    UNREFERENCED_PARAMETER(hWndCtl);
    UNREFERENCED_PARAMETER(bHandled);

    char szBuffer[10000];
    szBuffer[0] = '\0';
    char * pszCur = szBuffer;

    Append(pszCur, "Expression:\r\n");
    Append(pszCur, m_pszExpression);
    Append(pszCur, "\r\n\r\n");
    Append(pszCur, "File: \"");
    Append(pszCur, m_pszFileName);
    Append(pszCur, "\"\r\nLine: ");
    Append(pszCur, m_szLineNum);
    Append(pszCur, "\r\n\r\n");

    DWORD * pdwStackData = (DWORD *) ::GlobalLock(m_hStackData);
    _ASSERTE(pdwStackData != NULL);

    Append(pszCur, "Call stack:\r\n");

    DUSER_SYMBOL_INFO si;
    HANDLE hProcess = ::GetCurrentProcess();
    for (UINT nAddress = m_cSkipLevels; nAddress < m_cCSEntries; nAddress++)
    {
        CDebugHelp::ResolveStackItem(hProcess, pdwStackData, nAddress, si);

        TCHAR szAddr[20];
        wsprintf(szAddr, "0x%8.8x: ", pdwStackData[nAddress]);
        Append(pszCur, szAddr);
        Append(pszCur, si.szModule);
        Append(pszCur, ", ");
        Append(pszCur, si.szSymbol);
        Append(pszCur, "\r\n");
    }

    ::GlobalUnlock(m_hStackData);

    CopyToClipboard(szBuffer);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\assertdlg.h ===
// AssertDlg.h : Declaration of the CCAssertDlg

#if !defined(AUTOUTIL__AssertDlg_h__INCLUDED)
#define AUTOUTIL__AssertDlg_h__INCLUDED

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCAssertDlg
class CAssertDlg
{
// Construction
public:
    CAssertDlg();
    ~CAssertDlg();

// Operations
public:
    INT_PTR ShowDialog(LPCSTR pszType, LPCSTR pszExpression, LPCSTR pszFileName,
            UINT idxLineNum, HANDLE hStackData, UINT cCSEntries, UINT cSkipLevels = 0);

// Implementation
protected:
    static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCopy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
// Data
protected:
            HWND        m_hwnd;

            LPCSTR      m_pszTitle;         // Dialog title
            LPCSTR      m_pszExpression;    // Expression / comment
            LPCSTR      m_pszFileName;      // FileName
            char        m_szLineNum[10];    // Line number
            HANDLE      m_hStackData;       // Stack data
            UINT        m_cCSEntries;       // Number of levels on stack
            UINT        m_cSkipLevels;      // Number of levels of stack to skip
            BOOL        m_fProperShutdown;  // Had proper shutdown of dialog
    static  BOOL        s_fInit;
};

#endif // AUTOUTIL__AssertDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\autoutil.h ===
#if !defined(AUTOUTIL__AutoUtil_h__INCLUDED)
#define AUTOUTIL__AutoUtil_h__INCLUDED

#include <..\inc\AutoUtil.h>

#endif // AUTOUTIL__AutoUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\duexts\stdext64.cpp ===
/****************************** Module Header ******************************\
* Module Name: stdext64.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdext64.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
ULONG64                 dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
DWORD                   dwProcessor;

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit()
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }
    return fCtrlCHit;
}



VOID moveBlock(
PVOID pdst,
ULONG64 src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    __try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    (PVOID)src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}



BOOL tryMoveBlock(
PVOID pdst,
ULONG64 src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    __try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, (PVOID)src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }
    return(fSuccess);
}



VOID moveExp(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            fSuccess = tryMove(dwGlobal, dwGlobal);
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExp(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, addr)) {
            *((PDWORD)pdst) = dw;
            return(TRUE);
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return(FALSE);
}


BOOL tryMoveExpPtr(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValuePtr(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, dw, sizeof(dw))) {
            *pdst = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


/***************************************************************************
 * Common command parsing stuff                                            *
 ***************************************************************************/
ULONG64 EvalExp(
LPSTR psz)
{
    ULONG64 p;

    p = (lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == 0) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }
    return p;
}



ULONG64 OptEvalExp(
LPSTR psz)
{
    while (*psz == ' ')
        psz++;
    if (*psz == '\0') {
        return(0);
    }
    return(EvalExp(psz));
}



ULONG64 OptEvalExp2(
LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    ULONG64 dwRet = 0;

    while (*psz == ' ')
        psz++;
    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;
    return(dwRet);
}



DWORD StringToOpts(
LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return(OPTS_ERROR);     // any non-letter option is an error.
        }
        psz++;
    }
    return(opts);
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
LPSTR *ppszArgs,
LPSTR pszLegalArgs) // OPTIONAL
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return(Opts);
        }
    }
    return(Opts);
}



VOID PrintHuge(
LPSTR psz)
{
    /*
     * Looks like this is faulting these days - Print seems to be fixed
     * so I'm leaving this entry point for compatibility. (SAS)
     */
#ifdef ITWORKS
#define HUNK_SIZE   400
    int cch;
    CHAR chSave;

    /*
     * since Print extension can't handle very long strings,
     * break it up into peices for it to chew.
     */
    cch = strlen(psz);
    while (cch > HUNK_SIZE) {
        chSave = psz[HUNK_SIZE];
        psz[HUNK_SIZE] = '\0';
        Print(psz);
        psz[HUNK_SIZE] = chSave;
        psz += HUNK_SIZE;
        cch -= HUNK_SIZE;
    }
#endif
    Print(psz);
}



/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
PVOID pFunction,
LPSTR pszName,
int type,
LPSTR pszLegalOpts,
HANDLE hcp,
HANDLE hct,
ULONG64 dwcp,
DWORD dwp,
LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    ULONG64 param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;

#if 0
    DEBUGPRINT("CommonEP(%x, \"%s\", %d, \"%s\", %x, %x, %x, %x, \"%s\")\n",
            pFunction,
            pszName,
            type,
            pszLegalOpts,
            hcp,
            hct,
            dwcp,
            dwp,
            lpas);
#endif

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    __try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } __except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    ULONG64 dwcp,                                       \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ')
        lpas++;

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                PrintHuge(he[i].pszHelp2);
            }
        }
        return(TRUE);
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                PrintHuge(he[i].pszHelp2);
                return(TRUE);
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\autoutil.cpp ===
// AutoUtil.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\resource.h ===
#include "..\DUser\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  AutoUtil.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\debugcore.cpp ===
#include "stdafx.h"
#include "DebugCore.h"
#include "resource.h"
#include "AssertDlg.h"


//------------------------------------------------------------------------------
AUTOUTIL_API void _cdecl AutoTrace(const char * pszFormat, ...)
{
    va_list args;
    va_start(args, pszFormat);

    {
        int nBuf;
        char szBuffer[2048];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), pszFormat, args);
        AssertMsg(nBuf < sizeof(szBuffer), "Output truncated as it was > sizeof(szBuffer)");

        OutputDebugStringA(szBuffer);
    }
    va_end(args);
}


//**************************************************************************************************
//
// Global Functions
//
//**************************************************************************************************

CDebugHelp g_DebugHelp;

//------------------------------------------------------------------------------
AUTOUTIL_API IDebug * WINAPI
GetDebug()
{
    return (IDebug *) &g_DebugHelp;
}


#pragma comment(lib, "imagehlp.lib")

#define DUSER_API

//**************************************************************************************************
//
// class CDebugHelp
//
//**************************************************************************************************

//******************************************************************************
//
// CDebugHelp Construction
//
//******************************************************************************

//------------------------------------------------------------------------------
CDebugHelp::CDebugHelp()
{

}


//------------------------------------------------------------------------------
CDebugHelp::~CDebugHelp()
{

}


//******************************************************************************
//
// IDebug Implementation
//
//******************************************************************************

//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::AssertFailedLine(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum)
{
    HGLOBAL hStackData = NULL;
    UINT cCSEntries;

    BuildStack(&hStackData, &cCSEntries);
    BOOL fResult = AssertDialog("Assert", pszExpression, pszFileName, idxLineNum, hStackData, cCSEntries);

    if (hStackData != NULL)
        ::GlobalFree(hStackData);

    return fResult;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::Prompt(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle)
{
    HGLOBAL hStackData = NULL;
    UINT cCSEntries;

    BuildStack(&hStackData, &cCSEntries);
    BOOL fResult = AssertDialog(pszTitle, pszExpression, pszFileName, idxLineNum, hStackData, cCSEntries);

    if (hStackData != NULL)
        ::GlobalFree(hStackData);

    return fResult;
}


//------------------------------------------------------------------------------
//
// IsValidAddress() is taken from AfxIsValidAddress().
//
// IsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::IsValidAddress(const void * lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CDebugHelp::BuildStack(HGLOBAL * phStackData, UINT * pcCSEntries)
{
    DumpStack(phStackData, pcCSEntries);
}


//******************************************************************************
//
// Implementation
//
//******************************************************************************

BOOL g_fShowAssert = FALSE;
BOOL g_fUnderKernelDebugger = FALSE;

//------------------------------------------------------------------------------
BOOL
IsUnderKernelDebugger()
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION  kdInfo;
    if (NT_SUCCESS(NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                       &kdInfo,
                                       sizeof(kdInfo),
                                       NULL))) {
        return kdInfo.KernelDebuggerEnabled;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
BOOL
CDebugHelp::AssertDialog(
        LPCSTR pszType,
        LPCSTR pszExpression,
        LPCSTR pszFileName,
        UINT idxLineNum,
        HANDLE hStackData,
        UINT cCSEntries)
{
    AutoTrace("%s @ %s, line %d:\n'%s'\n",
            pszType, pszFileName, idxLineNum, pszExpression);

    BOOL fShowAssert = TRUE;
    if (InterlockedExchange((LONG *) &g_fShowAssert, fShowAssert)) {
        OutputDebugString("Displaying another Assert while in first Assert.\n");
        return TRUE;
    }

    //
    // When running under a kernel debugger, immediately break.  This is so that
    // while running under Stress, we break immediately and don't "loose" the
    // Assert in a pile of other things.
    //

    if (IsUnderKernelDebugger()) {
        DebugBreak();
    }


    //
    // Display the dialog
    //

    CAssertDlg dlg;
    INT_PTR nReturn = dlg.ShowDialog(pszType, pszExpression, pszFileName, idxLineNum,
            hStackData, cCSEntries, 3 /* Number of levels to skip*/);

    fShowAssert = FALSE;
    InterlockedExchange((LONG *) &g_fShowAssert, fShowAssert);

    if (nReturn == -1)
    {
        _ASSERTE(pszExpression != NULL);

        // Can't display the dialog for some reason, so revert to MessageBox
        TCHAR szBuffer[10000];
        if (pszFileName != NULL)
        {
            wsprintf(szBuffer, "An %s failed in the program.\n%s\nFile:\t%s\nLine:%d",
                    pszType, pszExpression, pszFileName, idxLineNum);
        }
        else
        {
            wsprintf(szBuffer, "An %s failed in the program.\n%s",
                    pszType, pszExpression);
        }
        nReturn = ::MessageBox(NULL, szBuffer, pszType,
                MB_ABORTRETRYIGNORE | MB_ICONSTOP | MB_DEFBUTTON2);

        // Translate the return code
        switch (nReturn)
        {
        case IDABORT:
            nReturn = IDOK;
            break;
        case IDRETRY:
            nReturn = IDC_DEBUG;
            break;
        case IDIGNORE:
            nReturn = IDC_IGNORE;
            break;
        default:
            _ASSERTE(0 && "Unknown return from MessageBox");
            nReturn = IDC_DEBUG;  // Debug, just in case
        }
    }
    switch (nReturn)
    {
    case IDOK:
    case IDCANCEL:
        (void)TerminateProcess(GetCurrentProcess(), 1);
        (void)raise(SIGABRT);
        _exit(3);
        return FALSE;   // Program will have exited

    case IDC_DEBUG:
        return TRUE;    // Break into the debugger

    case IDC_IGNORE:
        return FALSE;   // Just ignore and continue

    default:
        _ASSERTE(0 && "Unknown return code");
        return TRUE;    // Go to the debugger just in case
    }
}


/////////////////////////////////////////////////////////////////////////////
// Routine to produce stack dump

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress);
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress);

//------------------------------------------------------------------------------
static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress)
{
    return SymFunctionTableAccess(hProcess, dwPCAddress);
}


//------------------------------------------------------------------------------
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress)
{
    IMAGEHLP_MODULE moduleInfo;

    if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
    {
        MEMORY_BASIC_INFORMATION memoryBasicInfo;

        if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress,
            &memoryBasicInfo, sizeof(memoryBasicInfo)))
        {
            DWORD cch = 0;
            char szFile[MAX_PATH] = { 0 };

            cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase,
                szFile, MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            SymLoadModule(hProcess,
                NULL, ((cch) ? szFile : NULL),
                NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0);

            return (DWORD_PTR) memoryBasicInfo.AllocationBase;
        }
        else
            Trace("GetModuleBase() VirtualQueryEx() Error: %d\n", GetLastError());
    }

    return 0;
}


//------------------------------------------------------------------------------
static BOOL ResolveSymbol(HANDLE hProcess, DWORD dwAddress,
    DUSER_SYMBOL_INFO &siSymbol)
{
    BOOL fRetval = TRUE;

    siSymbol.dwAddress = dwAddress;

    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    CHAR szUndec[256];
    CHAR szWithOffset[256];
    LPSTR pszSymbol = NULL;
    IMAGEHLP_MODULE mi;

    memset(&siSymbol, 0, sizeof(DUSER_SYMBOL_INFO));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
        lstrcpyA(siSymbol.szModule, "<no module>");
    else
    {
        LPSTR pszModule = strchr(mi.ImageName, '\\');
        if (pszModule == NULL)
            pszModule = mi.ImageName;
        else
            pszModule++;

        lstrcpynA(siSymbol.szModule, pszModule, _countof(siSymbol.szModule));
       lstrcatA(siSymbol.szModule, "! ");
    }

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddress;
        sym.MaxNameLength = 255;

        if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym))
        {
            pszSymbol = sym.Name;

            if (UnDecorateSymbolName(sym.Name, szUndec, _countof(szUndec),
                UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
            {
                pszSymbol = szUndec;
            }
            else if (SymUnDName(&sym, szUndec, _countof(szUndec)))
            {
                pszSymbol = szUndec;
            }

            if (siSymbol.dwOffset != 0)
            {
                wsprintfA(szWithOffset, "%s + %d bytes", pszSymbol, siSymbol.dwOffset);
                pszSymbol = szWithOffset;
            }
      }
      else
          pszSymbol = "<no symbol>";
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
    }

    lstrcpynA(siSymbol.szSymbol, pszSymbol, _countof(siSymbol.szSymbol));
    return fRetval;
}


//------------------------------------------------------------------------------
void
CDebugHelp::DumpStack(
        HGLOBAL * phStackData,
        UINT * pcCSEntries
        )
{
    _ASSERTE(phStackData != NULL);
    _ASSERTE(pcCSEntries != NULL);

    CSimpleValArray<DWORD_PTR> adwAddress;
    HANDLE hProcess = ::GetCurrentProcess();
    if (SymInitialize(hProcess, NULL, FALSE))
    {
        // force undecorated names to get params
        DWORD dw = SymGetOptions();
        dw |= SYMOPT_UNDNAME;
        SymSetOptions(dw);

        HANDLE hThread = ::GetCurrentThread();
        CONTEXT threadContext;

        threadContext.ContextFlags = CONTEXT_FULL;

        if (::GetThreadContext(hThread, &threadContext))
        {
            STACKFRAME stackFrame;
            memset(&stackFrame, 0, sizeof(stackFrame));

            DWORD dwMachType;

#if defined(_M_IX86)
            dwMachType                  = IMAGE_FILE_MACHINE_I386;
            stackFrame.AddrPC.Offset    = threadContext.Eip;
            stackFrame.AddrPC.Mode      = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.Esp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;
            stackFrame.AddrFrame.Offset = threadContext.Ebp;
            stackFrame.AddrFrame.Mode   = AddrModeFlat;

#elif defined(_M_AMD64)
            dwMachType                  = IMAGE_FILE_MACHINE_AMD64;
            stackFrame.AddrPC.Offset    = threadContext.Rip;
            stackFrame.AddrPC.Mode      = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.Rsp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;

#elif defined(_M_IA64)
            dwMachType                   = IMAGE_FILE_MACHINE_IA64;
            stackFrame.AddrPC.Offset     = threadContext.StIIP;
            stackFrame.AddrPC.Mode       = AddrModeFlat;
            stackFrame.AddrStack.Offset  = threadContext.IntSp;
            stackFrame.AddrStack.Mode    = AddrModeFlat;

#else
#error("Unknown Target Machine");
#endif

            int nFrame;
            for (nFrame = 0; nFrame < 1024; nFrame++)
            {
                if (!StackWalk(dwMachType, hProcess, hProcess,
                    &stackFrame, &threadContext, NULL,
                    FunctionTableAccess, GetModuleBase, NULL))
                {
                    break;
                }

                adwAddress.Add(stackFrame.AddrPC.Offset);
            }

            // Now, copy it to the global memory
            UINT cbData     = adwAddress.GetSize() * sizeof(DWORD);
            HGLOBAL hmem    = ::GlobalAlloc(GMEM_MOVEABLE, cbData);
            if (hmem != NULL)
            {
                void * pmem = ::GlobalLock(hmem);
                memcpy(pmem, adwAddress.GetData(), cbData);
                ::GlobalUnlock(hmem);

                *phStackData    = hmem;
                *pcCSEntries    = adwAddress.GetSize();
            }
        }
    }
    else
    {
        DWORD dw = GetLastError();
        Trace("AutoDumpStack Error: IMAGEHLP.DLL wasn't found. GetLastError() returned 0x%8.8X\r\n", dw);
    }
}


//------------------------------------------------------------------------------
void
CDebugHelp::ResolveStackItem(
    HANDLE hProcess,
    DWORD * pdwStackData,
    int idxItem,
    DUSER_SYMBOL_INFO & si)
{
    _ASSERTE(hProcess != NULL);
    _ASSERTE(pdwStackData != NULL);
    _ASSERTE(idxItem >= 0);

    DWORD dwAddress = pdwStackData[idxItem];
    if (ResolveSymbol(hProcess, dwAddress, si))
    {
        //
        // Successfully resolved the symbol, but we don't need the whole path.
        // Just keep the filename and extension.
        //

        TCHAR szFileName[_MAX_FNAME];
        TCHAR szExt[_MAX_EXT];
        _tsplitpath(si.szModule, NULL, NULL, szFileName, szExt);
        strcpy(si.szModule, szFileName);
        strcat(si.szModule, szExt);
    }
    else
    {
        //
        // Unable to resolve the symbol, so just stub out.
        //

        _tcscpy(si.szSymbol, "<symbol not found>");
        si.szModule[0] = '\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\allocpool.cpp ===
/***************************************************************************\
*
* File: AllocPool.cpp
*
* Description:
* AllocPool implements a lightweight class used to pool memory allocations in
* a LIFO stack.  This class has been designed work specifically well with
* RockAll.
*
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "AllocPool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\debugcore.h ===
#if !defined(AUTOUTIL__DebugCore_h__INCLUDED)
#define AUTOUTIL__DebugCore_h__INCLUDED

const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;

struct DUSER_SYMBOL_INFO
{
    DWORD_PTR   dwAddress;
    DWORD_PTR   dwOffset;
    CHAR        szModule[MODULE_NAME_LEN];
    CHAR        szSymbol[SYMBOL_NAME_LEN];
};


class CDebugHelp : public IDebug
{
public:
    CDebugHelp();
    ~CDebugHelp();

// IDebug Implementation
public:
    STDMETHOD_(BOOL, AssertFailedLine)(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum);
    STDMETHOD_(BOOL, IsValidAddress)(const void * lp, UINT nBytes, BOOL bReadWrite);
    STDMETHOD_(void, BuildStack)(HGLOBAL * phStackData, UINT * pcCSEntries);
    STDMETHOD_(BOOL, Prompt)(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle);

// Operations
public:
    static void ResolveStackItem(HANDLE hProcess, DWORD * pdwStackData, int idxItem, DUSER_SYMBOL_INFO & si);

// Implementation
protected:
    static BOOL AssertDialog(LPCSTR pszType, LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, HANDLE hStackData, UINT cCSEntries);
    static void DumpStack(HGLOBAL * phStackData, UINT * pcCSEntries);
};

#endif // AUTOUTIL__DebugCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\autoutil\stdafx.h ===
#if !defined(AUTOUTIL__StdAfx_h__INCLUDED)
#define AUTOUTIL__StdAfx_h__INCLUDED
#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // Only compile for NT5
#endif

#include <nt.h>                 // NtQuerySystemInformation()
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <CommCtrl.h>
#include <atlbase.h>

#include <stdio.h>              // Get _vsnprintf

#include <signal.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdarg.h>

#include <AutoUtil.h>

#endif // !defined(AUTOUTIL__StdAfx_h__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\allocpool.h ===
/***************************************************************************\
*
* File: AllocPool.h
*
* Description:
* AllocPool defines a lightweight class used to pool memory allocations in
* a LIFO stack.  This class has been designed work specifically well with
* RockAll.
*
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__AllocPool_h__INCLUDED)
#define BASE__AllocPool_h__INCLUDED
#pragma once

#include "SimpleHeap.h"
#include "Locks.h"

template <class T, int cbBlock = 64, class heap = ContextHeap>
class AllocPoolNL
{
// Construction
public:
    inline  AllocPoolNL();
    inline  ~AllocPoolNL();
    inline  void        Destroy();

// Operations
public:
    inline  T *         New();
    inline  void        Delete(T * pvMem);
    inline  BOOL        IsEmpty() const;

// Data
protected:
            T *         m_rgItems[cbBlock * 2];
            int         m_nTop;
};


template <class T, int cbBlock = 64>
class AllocPool : public AllocPoolNL<T, cbBlock, ProcessHeap>
{
// Operations
public:
    inline  T *         New();
    inline  void        Delete(T * pvMem);

// Data
protected:
            CritLock    m_lock;
};


#include "AllocPool.inl"

#endif // BASE__AllocPool_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\allocpool.inl ===
/***************************************************************************\
*
* File: AllocPool.inl
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__AllocPool_inl__INCLUDED)
#define BASE__AllocPool_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class AllocListNL
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline  
AllocPoolNL<T, cbBlock, heap>::AllocPoolNL()
{
    m_nTop = 0;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline  
AllocPoolNL<T, cbBlock, heap>::~AllocPoolNL()
{
    Destroy();
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline void
AllocPoolNL<T, cbBlock, heap>::Destroy()
{
    if (m_nTop > 0) {
        ContextMultiFree(heap::GetHeap(), m_nTop, (void **) m_rgItems, sizeof(T));
        m_nTop = 0;
    }
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline T * 
AllocPoolNL<T, cbBlock, heap>::New()
{
    T * ptNew;

    if (m_nTop <= 0) {
        //
        // Not enough items in the pool to hand any new one out, so we need to
        // allocate more.  These will NOT be zero-initialized by the memory 
        // allocator.
        //

        ContextMultiAlloc(heap::GetHeap(), &m_nTop, (void **) m_rgItems, cbBlock, sizeof(T));
        if (m_nTop == 0) {
            ptNew = NULL;
            goto exit;
        }
    }


    //
    // There is an item in the pool, but we need to "scrub" it before handing 
    // it out.
    //
    
    ptNew = m_rgItems[--m_nTop];
    ZeroMemory(ptNew, sizeof(T));
    placement_new(ptNew, T);

exit:
    return ptNew;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline void 
AllocPoolNL<T, cbBlock, heap>::Delete(T * pvMem)
{
    if (pvMem == NULL) {
        return;
    }

    placement_delete(pvMem, T);
    m_rgItems[m_nTop++] = pvMem;

    if (m_nTop >= cbBlock * 2) {
        ContextMultiFree(heap::GetHeap(), cbBlock, (void **) &m_rgItems[cbBlock], sizeof(T));
        m_nTop -= cbBlock;
    }
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline BOOL
AllocPoolNL<T, cbBlock, heap>::IsEmpty() const
{
    return m_nTop == 0;
}


/***************************************************************************\
*****************************************************************************
*
* class AllocList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, int cbBlock>
inline T * 
AllocPool<T, cbBlock>::New()
{
    m_lock.Enter();
    T * pNew = AllocPoolNL<T, cbBlock>::New();
    m_lock.Leave();
    return pNew;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock>
inline void 
AllocPool<T, cbBlock>::Delete(T * pvMem)
{
    m_lock.Enter();
    AllocPoolNL<T, cbBlock>::Delete(pvMem);
    m_lock.Leave();
}


#endif // BASE__AllocPool_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\array.cpp ===
/***************************************************************************\
*
* File: Array.cpp
*
* Description:
* Array.cpp implements a collection of different array classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "Array.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\base.h ===
/***************************************************************************\
*
* File: Base.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Base_h__INCLUDED)
#define BASE__Base_h__INCLUDED

#include <DUserError.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Base Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // BASE__Base_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\baseobject.inl ===
/***************************************************************************\
*
* File: BaseObject.inl
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BaseObject_inl__INCLUDED)
#define BASE__BaseObject_inl__INCLUDED
#pragma once

#include "Locks.h"

//------------------------------------------------------------------------------
inline HANDLE GetHandle(const BaseObject * pbase)
{
    if (pbase != NULL) {
        return pbase->GetHandle();
    }

    return NULL;
}


/***************************************************************************\
*****************************************************************************
*
* class BaseObject
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
BaseObject::BaseObject()
{
    m_cRef  = 1;  // Start off with a valid reference
}


//------------------------------------------------------------------------------
inline HANDLE  
BaseObject::GetHandle() const
{
    return (HANDLE) this;
}


//------------------------------------------------------------------------------
inline BaseObject *
BaseObject::ValidateHandle(HANDLE h)
{
    return (BaseObject *) h;
}


#if DBG
//------------------------------------------------------------------------------
inline void
BaseObject::DEBUG_CheckValidLockCount() const
{
    if (!DEBUG_IsZeroLockCountValid()) {
        AssertMsg(m_cRef > 0, "Object must have an outstanding reference.");
    }
}
#endif // DBG


//------------------------------------------------------------------------------
inline void
BaseObject::Lock()
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

    SafeIncrement(&m_cRef);
}


/***************************************************************************\
*
* BaseObject::xwUnlock
*
* xwUnlock() decrements the objects's usage count by 1.  When the usage count
* reaches 0, the object will be destroyed.
*
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
* <retval>  Returns if the object is still valid (has not been destroyed)</retval>
*
\***************************************************************************/

inline BOOL
BaseObject::xwUnlock()
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

#if DBG
    AssertMsg((this != s_DEBUG_pobjEnsure) || (m_cRef > 1), "Ensure Object is remains valid");
#endif // DBG

    if (SafeDecrement(&m_cRef) == 0) {
        xwDestroy();
        return FALSE;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
BaseObject::xwUnlockNL(FinalUnlockProc pfnFinal, void * pvData)
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

#if DBG
    AssertMsg((this != s_DEBUG_pobjEnsure) || (m_cRef > 1), "Ensure Object is remains valid");
#endif // DBG

    if (SafeDecrement(&m_cRef) == 0) {
        //
        // Object needs to be destroyed, so notify the caller so that it has
        // an opportunity to prepare.
        //

        if (pfnFinal != NULL) {
            pfnFinal(this, pvData);
        }

        xwDestroy();
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class ObjectLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
ObjectLock::ObjectLock(BaseObject * pobjLock)
{
    AssertMsg(pobjLock->GetHandleType() != htContext, "Use ContextLock to lock a Context");

    pobj = pobjLock;
    pobj->Lock();

#if DBG
    pobjLock->DEBUG_AssertValid();
#endif
}


//------------------------------------------------------------------------------
inline  
ObjectLock::~ObjectLock()
{
    pobj->xwUnlock();
}


#endif // BASE__BaseObject_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\baseobject.cpp ===
/***************************************************************************\
*
* File: BaseObject.cpp
*
* Description:
* BaseObject.cpp implements the "basic object" that provides handle-support 
* for all items exposed outside DirectUser.
*
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "BaseObject.h"
#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* class BaseObject
*
*****************************************************************************
\***************************************************************************/

#if DBG
BaseObject* BaseObject::s_DEBUG_pobjEnsure = NULL;
#endif //DBG


//------------------------------------------------------------------------------
BaseObject::~BaseObject()
{

}


/***************************************************************************\
*
* BaseObject::xwDestroy
*
* In the standard setup, xwDestroy() gets called by xwUnlock() when the lock
* count reaches 0.  The object should then call its destructor to free memory
* and resources.  
* 
* The default implementation will free using the current Context's heap.  
* An object MUST override this if it is stored in a pool or uses the 
* Process heap.
*
\***************************************************************************/

void    
BaseObject::xwDestroy()
{
    ClientDelete(BaseObject, this);
}


/***************************************************************************\
*
* BaseObject::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.  
*
* The default implementation just Unlock's the object.  If an object has
* different schemantics, it should override this function.
*
\***************************************************************************/

BOOL    
BaseObject::xwDeleteHandle()
{
#if DBG
    if (m_DEBUG_fDeleteHandle) {
        PromptInvalid("DeleteHandle() was called multiple times on the same object.");
    }
    m_DEBUG_fDeleteHandle = TRUE;
#endif // DBG

    return xwUnlock();
}


/***************************************************************************\
*
* BaseObject::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
BaseObject::IsStartDelete() const
{
    return FALSE;
}


#if DBG

/***************************************************************************\
*
* BaseObject::DEBUG_IsZeroLockCountValid
*
* DEBUG_IsZeroLockCountValid is called to check if an object allows zero
* lock counts, for example during a destruction stage.  This is only valid
* if an object has overridden xwDestroy() to provide an implementation that
* checks if the object is currently being destroyed and will return safely.
*
* This is a DEBUG only check because it is used only to Prompt the 
* application.  The RELEASE code should properly do the "right thing" in its
* xwDestroy() function.
*
* The default implementation is to return FALSE because 
* BaseObject::xwDestroy() does not check for existing destruction.
*
\***************************************************************************/

BOOL
BaseObject::DEBUG_IsZeroLockCountValid() const
{
    return FALSE;
}


/***************************************************************************\
*
* BaseObject::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

void
BaseObject::DEBUG_AssertValid() const
{
    Assert(m_cRef >= 0);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\array.inl ===
/***************************************************************************\
*
* File: Array.inl
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Array_inl__INCLUDED)
#define BASE__Array_inl__INCLUDED

#include "SimpleHeap.h"

/***************************************************************************\
*
* class GArrayS
* 
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, class heap>
inline
GArrayS<T, heap>::GArrayS() : m_aT(NULL)
{
    //
    // All elements in GArrayS<T, heap> must be at least sizeof(int) large.  This is
    // because of the design that stores the size in the element preceeding the
    // data for the array.
    //

    AssertMsg(sizeof(T) >= sizeof(int), "Ensure minimum element size");
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline 
GArrayS<T, heap>::~GArrayS()
{
    RemoveAll();
}


//------------------------------------------------------------------------------
template <class T, class heap>
BOOL        
GArrayS<T, heap>::IsEmpty() const
{
    return m_aT == NULL;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void *      
GArrayS<T, heap>::GetRawData(BOOL fCheckNull) const
{
    if (fCheckNull) {
        //
        // Need to check if array is allocated
        //

        if (m_aT != NULL) {
            return (void *) (&m_aT[-1]);
        } else {
            return NULL;
        }
    } else {
        //
        // Blindly return the size
        //

        AssertMsg(m_aT != NULL, "Array must be allocated if not checking");
        return &m_aT[-1];
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void    
GArrayS<T, heap>::SetRawSize(int cNewItems)
{
    //
    // Store the size before the array data.  This function should only be 
    // called when an array is allocated (and thus have a non-zero size).
    //

    AssertMsg(cNewItems > 0, "Must specify a positive number of items");
    AssertMsg(m_aT != NULL, "Must allocate range to set number of items");

    int * pnSize = (int *) GetRawData(FALSE);
    *pnSize = cNewItems;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayS<T, heap>::GetSize() const
{
    if (m_aT != NULL) {
        int * pnSize = (int *) GetRawData(FALSE);
        int cItems = *pnSize;
        AssertMsg(cItems >= 1, "Must have at least one item");
        return cItems;
    } else {
        return 0;
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayS<T, heap>::SetSize(int cItems)
{
    AssertMsg(cItems >= 0, "Must have valid size");

    int cSize = GetSize();
    if (cSize == cItems) {
        return TRUE;
    }

    if (cItems == 0) {
        RemoveAll();
        return TRUE;
    } else {
        return Resize(cItems, cSize);
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int
GArrayS<T, heap>::Add(const T & t)
{
    int idxAdd = GetSize();
    if (!Resize(idxAdd + 1, idxAdd)) {
        return -1;
    }

	SetAtIndex(idxAdd, t);
    return idxAdd;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayS<T, heap>::InsertAt(int idxItem, const T & t)
{
    AssertMsg(idxItem <= GetSize(), "Check index");

    // Actually may need to increase the size by one and shift everything 
    // down

    int idxAdd = GetSize();
    if (!Resize(idxAdd + 1, idxAdd)) {
        return FALSE;
    }

    int cbMove = (idxAdd - idxItem) * sizeof(T);
    if (cbMove > 0) {
        MoveMemory(&m_aT[idxItem + 1], &m_aT[idxItem], cbMove);
    }
    SetAtIndex(idxItem, t);
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayS<T, heap>::Remove(const T & t)
{
	int idxItem = Find(t);
    if(idxItem == -1) {
		return FALSE;
    }
	return RemoveAt(idxItem);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayS<T, heap>::RemoveAt(int idxItem)
{
	int cItems = GetSize();
    AssertMsg((idxItem < cItems) && (cItems >= 0), "Ensure valid index");
    m_aT[idxItem].~T();

    cItems--;
    if (cItems > 0) {
        //
        // Found the element, so we need to splice it out of the array.  We
        // can not just Realloc() the buffer b/c we need to slide all
        // property data after this down one.  This means that we have to
        // allocate a new buffer.  If we are unable to allocate a temporary
        // buffer, we can go ahead and just use the existing buffer, but we
        // won't be able to free any memory.
        //

        if (idxItem < cItems) {
		    MoveMemory((void*)&m_aT[idxItem], (void*)&m_aT[idxItem + 1], (cItems - idxItem) * sizeof(T));
	    }

        T * rgNewData = (T *) ContextRealloc(heap::GetHeap(), GetRawData(FALSE), (cItems + 1) * sizeof(T));
        if (rgNewData != NULL) {
            m_aT = &rgNewData[1];
        }

	    SetRawSize(cItems);
    } else {
		ContextFree(heap::GetHeap(), GetRawData(FALSE));
        m_aT = NULL;
    }

	return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayS<T, heap>::RemoveAll()
{
	if(m_aT != NULL) {
        int cItems = GetSize();
        for(int i = 0; i < cItems; i++) {
			m_aT[i].~T();
        }
		ContextFree(heap::GetHeap(), GetRawData(FALSE));
		m_aT = NULL;
	}
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T & 
GArrayS<T, heap>::operator[] (int idxItem) const
{
	Assert(idxItem >= 0 && idxItem < GetSize());
	return m_aT[idxItem];
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T * 
GArrayS<T, heap>::GetData() const
{
	return m_aT;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayS<T, heap>::SetAtIndex(int idxItem, const T & t)
{
	Assert(idxItem >= 0 && (idxItem < GetSize()));
	placement_copynew(&m_aT[idxItem], T, t);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayS<T, heap>::Find(const T & t) const
{
    int cItems = GetSize();
	for(int i = 0; i < cItems; i++) {
        if(m_aT[i] == t) {
			return i;
        }
	}

	return -1;  // not found
}


/***************************************************************************\
*
* GArrayS<T, heap>::Resize()
*
* Resize() changes the size of the array to a non-zero number of elements.
*
* NOTE: This function has been specifically written for the GArrayS<T, heap> 
* class and has slightly different behavior that GArrayF<T, heap>::Resize().
* 
\***************************************************************************/

template <class T, class heap>
inline BOOL
GArrayS<T, heap>::Resize(
    IN  int cItems,                 // New number of items
    IN  int cSize)                  // Current size
{
    AssertMsg(cItems > 0, "Must have non-zero and positive number of items");
    AssertMsg(cItems != cSize, "Must have a different size");

    if (cItems < cSize) {
        //
        // Making the array smaller, so need to destruct the objects we are
        // getting rid of.
        //

        AssertMsg(m_aT != NULL, "Should have data allocated");
        for(int i = cItems; i < cSize; i++) {
			m_aT[i].~T();
        }
    }

    //
    // Resize the array and store the new size.
    //

	T * aT;
	aT = (T *) ContextRealloc(heap::GetHeap(), GetRawData(TRUE), (cItems + 1) * sizeof(T));
    if(aT == NULL) {
        AssertMsg(cItems >= cSize, "Should never fail when shrinking");
		return FALSE;
    }

	m_aT = &aT[1];
    SetRawSize(cItems);

    return TRUE;
}


/***************************************************************************\
*
* class GArrayBase
* 
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, class heap>
inline
GArrayF<T, heap>::GArrayF() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
{

}


//------------------------------------------------------------------------------
template <class T, class heap>
inline 
GArrayF<T, heap>::~GArrayF()
{
    RemoveAll();
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL        
GArrayF<T, heap>::IsEmpty() const
{
    //
    // GArrayF may have a non-NULL m_aT but a m_nSize if only Add() and Remove()
    // are used, treating the array like a stack.  Therefore, we must use 
    // m_nSize to determine if the array is "empty".  To free all memory 
    // allocated by the array, use RemoveAll().
    //

    return m_nSize <= 0;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayF<T, heap>::GetSize() const
{
	return m_nSize;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayF<T, heap>::SetSize(int cItems)
{
    AssertMsg(cItems >= 0, "Must have valid size");

    if (!Resize(cItems)) {
        return FALSE;
    }

    m_nSize = cItems;
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int
GArrayF<T, heap>::Add(const T & t)
{
	if(m_nSize == m_nAllocSize)	{
		int nNewAllocSize = (m_nAllocSize == 0) ? 8 : (m_nAllocSize * 2);
        if (!Resize(nNewAllocSize)) {
            return -1;
        }
	}

    int idxAdd = m_nSize;
	m_nSize++;
	SetAtIndex(idxAdd, t);
    return idxAdd;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayF<T, heap>::InsertAt(int idxItem, const T & t)
{
    AssertMsg(idxItem <= m_nSize, "Check index");

    // Actually may need to increase the size by one and shift everything 
    // down

    if (!Resize(m_nSize + 1)) {
        return FALSE;
    }

    int cbMove = (m_nSize - idxItem) * sizeof(T);
    if (cbMove > 0) {
        MoveMemory(&m_aT[idxItem + 1], &m_aT[idxItem], cbMove);
    }
    m_nSize++;
    SetAtIndex(idxItem, t);
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayF<T, heap>::Remove(const T & t)
{
	int idxItem = Find(t);
    if(idxItem == -1) {
		return FALSE;
    }
	return RemoveAt(idxItem);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayF<T, heap>::RemoveAt(int idxItem)
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");

	if(idxItem != (m_nSize - 1)) {
		m_aT[idxItem].~T();
		MoveMemory((void*)&m_aT[idxItem], (void*)&m_aT[idxItem + 1], (m_nSize - (idxItem + 1)) * sizeof(T));
	}
	m_nSize--;
	return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayF<T, heap>::RemoveAll()
{
	if(m_aT != NULL) {
        for(int i = 0; i < m_nSize; i++) {
			m_aT[i].~T();
        }
		ContextFree(heap::GetHeap(), m_aT);
		m_aT = NULL;
	}
	m_nSize = 0;
	m_nAllocSize = 0;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T & 
GArrayF<T, heap>::operator[] (int idxItem) const
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");
	return m_aT[idxItem];
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T * 
GArrayF<T, heap>::GetData() const
{
	return m_aT;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayF<T, heap>::SetAtIndex(int idxItem, const T & t)
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");
	placement_copynew(&m_aT[idxItem], T, t);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayF<T, heap>::Find(const T & t) const
{
	for(int i = 0; i < m_nSize; i++) {
        if(m_aT[i] == t) {
			return i;
        }
	}
	return -1;  // not found
}


/***************************************************************************\
*
* GArrayF<T, heap>::Resize()
*
* Resize() changes the size of the array.
*
* NOTE: This function has been specifically written for the GArrayF<T, heap> 
* class and has slightly different behavior that GArrayS<T, heap>::Resize().
* 
\***************************************************************************/

template <class T, class heap>
inline BOOL
GArrayF<T, heap>::Resize(int cItems)
{
    if (cItems == 0) {
		RemoveAll();
    } else {
        AssertMsg(m_nAllocSize >= m_nSize, "Ensure legal sizes");

        if (cItems < m_nSize) {
            //
            // Making the array smaller, so need to destruct the objects we are
            // getting rid of.
            //

            if(m_aT != NULL) {
                for(int i = cItems; i < m_nSize; i++) {
			        m_aT[i].~T();
                }
	        }
        }

        //
        // Resize the array, but don't update m_nSize b/c that is the caller's
        // responsibility.
        //

	    T * aT;
	    aT = (T *) ContextRealloc(heap::GetHeap(), m_aT, cItems * sizeof(T));
        if(aT == NULL) {
		    return FALSE;
        }

	    m_nAllocSize = cItems;
	    m_aT = aT;
    }

    return TRUE;
}


#endif // BASE__Array_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\bithelp.h ===
/***************************************************************************\
*
* File: BitHelp.h
*
* Description:
* BitHelp.h defines a collection of helpful bit-manipulation routines used
* commonly throughout DirectUser.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BitHelp_h__INCLUDED)
#define BASE__BitHelp_h__INCLUDED

//------------------------------------------------------------------------------
inline HWND 
ValidateHWnd(HWND hwnd)
{
    if ((hwnd == NULL) || (!IsWindow(hwnd))) {
        return NULL;
    }

    return hwnd;
}


//------------------------------------------------------------------------------
__forceinline bool
TestFlag(UINT nValue, UINT nMask)
{
    return (nValue & nMask) != 0;
}


//------------------------------------------------------------------------------
__forceinline bool
TestAllFlags(UINT nValue, UINT nMask)
{
    return (nValue & nMask) == nMask;
}


//------------------------------------------------------------------------------
__forceinline UINT
SetFlag(UINT & nValue, UINT nMask)
{
    nValue |= nMask;
    return nValue;
}


//------------------------------------------------------------------------------
__forceinline UINT
ClearFlag(UINT & nValue, UINT nMask)
{
    nValue &= ~nMask;
    return nValue;
}


//------------------------------------------------------------------------------
__forceinline UINT
ChangeFlag(UINT & nValue, UINT nNewValue, UINT nMask)
{
    nValue = (nNewValue & nMask) | (nValue & ~nMask);
    return nValue;
}


//------------------------------------------------------------------------------
template <class T>
void SafeAddRef(T * p)
{
    if (p != NULL) {
        p->AddRef();
    }
}


//------------------------------------------------------------------------------
template <class T>
void SafeRelease(T * & p)
{
    if (p != NULL) {
        p->Release();
        p = NULL;
    }
}

#endif // BASE__BitHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\array.h ===
/***************************************************************************\
*
* File: Array.h
*
* Description:
* Array.h defines a collection of different array classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Array_h__INCLUDED)
#define BASE__Array_h__INCLUDED

/***************************************************************************\
*
* GArrayS implements an array that is optimized for minimum size.  When no
* items are allocated, the array is only 4 bytes.  When any items are 
* allocated, an extra item is allocated BEFORE the memory location pointed
* by m_aT where the size is stored.
*
* This array class is not designed for continuous size changing.  Any time
* an element is added or removed, the entire array size is reallocated.  
* This helps keep memory usage down, at the expense of runtime performance.
* 
\***************************************************************************/

template <class T, class heap = ContextHeap>
class GArrayS
{
// Construction/destruction
public:
	GArrayS();
	~GArrayS();

// Operations
public:
	int         GetSize() const;
    BOOL        SetSize(int cItems);

    BOOL        IsEmpty() const;

	int         Add(const T & t);
	BOOL        Remove(const T & t);
	BOOL        RemoveAt(int idxItem);
	void        RemoveAll();
    BOOL        InsertAt(int idxItem, const T & t);
	int         Find(const T & t) const;
	T &         operator[] (int idxItem) const;
	T *         GetData() const;

// Implementation
protected:
    void *      GetRawData(BOOL fCheckNull) const;
    void        SetRawSize(int cNewItems);
    BOOL        Resize(int cItems, int cSize);
	void        SetAtIndex(int idxItem, const T & t);

// Data
protected:
	T *         m_aT;
};


/***************************************************************************\
*
* GArrayF implements an array that is optimized for more frequent add and 
* remove operations.  This array class reallocates it size when the 
* used size is either larger or significantly smaller than the current size.
* This implementation takes 12 bytes of storage, so it is more memory 
* expensive than GArrayS<T> when the array is usually empty.
* 
\***************************************************************************/

template <class T, class heap = ContextHeap>
class GArrayF
{
// Construction/destruction
public:
	GArrayF();
	~GArrayF();

// Operations
public:
	int         GetSize() const;
    BOOL        SetSize(int cItems);

    BOOL        IsEmpty() const;

	int         Add(const T & t);
	BOOL        Remove(const T & t);
	BOOL        RemoveAt(int idxItem);
	void        RemoveAll();
    BOOL        InsertAt(int idxItem, const T & t);
	int         Find(const T & t) const;
	T &         operator[] (int idxItem) const;
	T *         GetData() const;

// Implementation
protected:
    BOOL        Resize(int cItems);
	void        SetAtIndex(int idxItem, const T & t);

// Data
protected:
	T *         m_aT;
	int         m_nSize;
	int         m_nAllocSize;
};

#include "Array.inl"

#endif // BASE__Array_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\baseobject.h ===
/***************************************************************************\
*
* File: BaseObject.h
*
* Description:
* BaseObject.h defines the "basic object" that provides handle-support
* for all items exposed outside DirectUser.
*
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BaseObject_h__INCLUDED)
#define BASE__BaseObject_h__INCLUDED
#pragma once

enum HandleType
{
    htNone              = 0,
    htContext           = 1,
    htHWndContainer     = 2,
    htParkContainer     = 3,
    htNcContainer       = 4,
    htDxContainer       = 5,
    htVisual            = 6,
    htListener          = 7,
    htTransition        = 8,
    htAction            = 9,
    htMsgClass          = 10,
    htMsgObject         = 11,
    htMAX
};


enum HandleMask
{
    hmMsgObject         = 0x00000001,
    hmEventGadget       = 0x00000002,
    hmVisual            = 0x00000004,
    hmContainer         = 0x00000008,
};


/***************************************************************************\
*
* class BaseObject defines an internally referenced counted object that 
* provides conversions from HANDLE's to internal pointers.
*
* NOTE: If created objects are ever exposed as reference counted objects,
* they MUST provide a separate reference count for their "handles".  There 
* is substantial internal code that relies on internal-only reference 
* counting.
* 
\***************************************************************************/

class BaseObject
{
// Construction
public:
    inline  BaseObject();
	virtual	~BaseObject();
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();

// Operations
public:

    inline  HANDLE      GetHandle() const;
    inline static 
            BaseObject* ValidateHandle(HANDLE h);

    virtual BOOL        IsStartDelete() const;

    virtual HandleType  GetHandleType() const PURE;
    virtual UINT        GetHandleMask() const PURE;

    inline  void        Lock();
    inline  BOOL        xwUnlock();

    typedef void        (CALLBACK * FinalUnlockProc)(BaseObject * pobj, void * pvData);
    inline  BOOL        xwUnlockNL(FinalUnlockProc pfnFinal, void * pvData);

// Implementation
protected:
#if DBG
    inline  void        DEBUG_CheckValidLockCount() const;
    virtual BOOL        DEBUG_IsZeroLockCountValid() const;

public:
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
            long        m_cRef;         // Outstanding locks against object

#if DBG
            BOOL        m_DEBUG_fDeleteHandle;
    static  BaseObject* s_DEBUG_pobjEnsure;
#endif // DBG
};


/***************************************************************************\
*****************************************************************************
*
* ObjectLock provides a convenient mechanism of locking a generic Object and
* automatically unlocking when finished.
*
*****************************************************************************
\***************************************************************************/

class ObjectLock
{
public:
    inline  ObjectLock(BaseObject * pobjLock);
    inline  ~ObjectLock();

    BaseObject * pobj;
};


#include "BaseObject.inl"

#endif // BASE__BaseObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\list.cpp ===
/***************************************************************************\
*
* File: List.cpp
*
* Description:
* List.h implements a collection of different list classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "List.h"

//------------------------------------------------------------------------------
GRawList::GetSize() const
{
    int cItems = 0;
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        cItems++;
        pCur = pCur->pNext;
    }

    return cItems;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::GetTail() const
{
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        if (pCur->pNext == NULL) {
            return pCur;
        }
        pCur = pCur->pNext;
    }

    return NULL;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::GetAt(int idxItem) const
{
    ListNode * pCur = m_pHead;
    while ((pCur != NULL) && (idxItem-- > 0)) {
        pCur = pCur->pNext;
    }

    return pCur;
}


//------------------------------------------------------------------------------
void
GRawList::AddHead(ListNode * pNode)
{
    pNode->pPrev = NULL;
    pNode->pNext = m_pHead;

    if (m_pHead != NULL) {
        m_pHead->pPrev = pNode;
    }

    m_pHead = pNode;
}


//------------------------------------------------------------------------------
void
GRawList::AddTail(ListNode * pNode)
{
    ListNode * pTail = GetTail();
    if (pTail != NULL) {
        pNode->pPrev    = pTail;
        pTail->pNext    = pNode;
    } else {
        m_pHead = pNode;
    }
}


//------------------------------------------------------------------------------
void
GRawList::InsertAfter(ListNode * pInsert, ListNode * pBefore)
{
    if ((pBefore == NULL) || IsEmpty()) {
        AddHead(pInsert);
    } else {
        pInsert->pNext = pBefore->pNext;
        if (pInsert->pNext != NULL) {
            pInsert->pNext->pPrev = pInsert;
        }
        pBefore->pNext = pInsert;
    }
}


//------------------------------------------------------------------------------
void
GRawList::InsertBefore(ListNode * pInsert, ListNode * pAfter)
{
    if ((pAfter == m_pHead) || (pAfter == NULL) || IsEmpty()) {
        AddHead(pInsert);
    } else {
        pInsert->pPrev = pAfter->pPrev;
        pInsert->pNext = pAfter;

        AssertMsg(pInsert->pPrev != NULL, "Must have previous or else is head");

        pInsert->pPrev->pNext = pInsert;
        pAfter->pPrev = pInsert;
    }
}


//------------------------------------------------------------------------------
void
GRawList::Unlink(ListNode * pNode)
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pPrev = pNode->pPrev;
    ListNode * pNext = pNode->pNext;

    if (pPrev != NULL) {
        pPrev->pNext = pNext;
    }

    if (pNext != NULL) {
        pNext->pPrev = pPrev;
    }

    if (m_pHead == pNode) {
        m_pHead = pNext;
    }

    pNode->pPrev = NULL;
    pNode->pNext = NULL;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::UnlinkHead()
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pHead = m_pHead;

    m_pHead = pHead->pNext;
    if (m_pHead != NULL) {
        m_pHead->pPrev = NULL;
    }

    pHead->pNext = NULL;
    AssertMsg(pHead->pPrev == NULL, "Check");

    return pHead;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::UnlinkTail()
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pTail = GetTail();
    if (pTail != NULL) {
        if (m_pHead == pTail) {
            m_pHead = NULL;
        } else {
            AssertMsg(pTail->pPrev != NULL, "If not head, must have prev");
            pTail->pPrev->pNext = NULL;
        }
        pTail->pPrev = NULL;
        AssertMsg(pTail->pNext == NULL, "Check");
    }

    return pTail;
}


//------------------------------------------------------------------------------
int
GRawList::Find(ListNode * pNode) const
{
    int cItems = -1;
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        cItems++;
        if (pCur != pNode) {
            pCur = pCur->pNext;
        } else {
            break;
        }
    }

    return cItems;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\locks.cpp ===
/***************************************************************************\
*
* File: Locks.cpp
*
* Description:
* Locks.h implements a collection wrappers used to maintain critical sections
* and other locking devices.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "Locks.h"

//
// NOTE: Must default to multiple threaded.  We can only turn this off if this
// is the first Context that is initialized.
//

BOOL    g_fThreadSafe = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\locks.h ===
/***************************************************************************\
*
* File: Locks.h
*
* Description:
* Locks.h defines a collection wrappers used to maintain critical sections
* and other locking devices.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Locks_h__INCLUDED)
#define BASE__Locks_h__INCLUDED
#pragma once

#include "List.h"

class CritLock
{
// Construction
public:
    inline  CritLock();
    inline  ~CritLock();

// Operations
public:
    inline  void        Enter();
    inline  void        Leave();

    inline  BOOL        GetThreadSafe() const;
    inline  void        SetThreadSafe(BOOL fThreadSafe);

// Data
protected:
    CRITICAL_SECTION    m_cs;
    BOOL                m_fThreadSafe;
};


template <class base> 
class AutoCleanup
{
public:
    ~AutoCleanup();
    void Link(base * pItem);
    void Delete(base * pItem);
    void DeleteAll();

protected:
    GList<base> m_lstItems;
    CritLock    m_lock;
};

template <class base, class derived>
inline derived * New(AutoCleanup<base> & lstItems);

inline  BOOL    IsMultiThreaded();

#if 1
inline  long    SafeIncrement(volatile long * pl);
inline  long    SafeDecrement(volatile long * pl);
inline  void    SafeEnter(volatile CRITICAL_SECTION * pcs);
inline  void    SafeLeave(volatile CRITICAL_SECTION * pcs);
#endif

#include "Locks.inl"

#endif // BASE__Locks_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\gfxhelp.h ===
#if !defined(UTIL__GfxHelp_h__INCLUDED)
#define BASE__GfxHelp_h__INCLUDED
#pragma once

#pragma comment(lib, "msimg32.lib")

namespace Gdiplus
{
    class Graphics;
    class Brush;
};

class DuSurface;

BOOL        GdDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush);
BOOL        GdDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness = 1);
BOOL        GdDrawOutlineRect(Gdiplus::Graphics * pgpgr, const RECT * prcPxl, Gdiplus::Brush * pgpbr, int nThickness = 1);

#endif // BASE__GfxHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\gfxhelp.cpp ===
#include "stdafx.h"
#include "Base.h"
#include "GfxHelp.h"

/***************************************************************************\
*
* GdDrawBlendRect
*
* GdDrawBlendRect draws a alpha-blended rectangle using the current brush
* and specified alpha level
*
\***************************************************************************/

BOOL GdDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush)
{
    HBITMAP hbmpSrc = NULL, hbmpOld = NULL;
    HDC hdcSrc = NULL;
    HBRUSH hbrOld;
    BOOL fSuccess = FALSE;

    if ((wBrush == 0) || (hBrush == 0)) {
        wBrush = 100;
        hBrush = 100;
    }

    hbmpSrc = CreateCompatibleBitmap(hdcDest, wBrush, hBrush);
    if (hbmpSrc == NULL) {
        goto cleanup;
    }

    hdcSrc = CreateCompatibleDC(hdcDest);
    if (hdcSrc == NULL) {
        goto cleanup;
    }

    hbmpOld = (HBITMAP) SelectObject(hdcSrc, hbmpSrc);
    hbrOld = (HBRUSH) SelectObject(hdcSrc, hbrFill);
    PatBlt(hdcSrc, 0, 0, wBrush, hBrush, PATCOPY);
    SelectObject(hdcSrc, hbrOld);

    BLENDFUNCTION blend;

    blend.BlendOp     = AC_SRC_OVER;
    blend.BlendFlags  = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

    AlphaBlend(hdcDest, prcDest->left, prcDest->top, 
            prcDest->right - prcDest->left, prcDest->bottom - prcDest->top,
            hdcSrc, 0, 0, wBrush, hBrush, blend);

    fSuccess = TRUE;

cleanup:
    if (hdcSrc != NULL) {
        SelectObject(hdcSrc, hbmpOld);
        DeleteDC(hdcSrc);
    }

    DeleteObject(hbmpSrc);

    return fSuccess;
}


/***************************************************************************\
*
* GetSignFromMappingMode
*
* For the current mapping mode,  find out the sign of x from left to right,
* and the sign of y from top to bottom.
*
* History:
* 2000-04-22    JStall      Ported from NT-USER
*
\***************************************************************************/

BOOL GetSignFromMappingMode (
    HDC    hdc,
    PPOINT pptSign)
{
    SIZE sizeViewPortExt;
    SIZE sizeWindowExt;

    if (!GetViewportExtEx(hdc, &sizeViewPortExt)
            || !GetWindowExtEx(hdc, &sizeWindowExt)) {

        return FALSE;
    }

    pptSign->x = ((sizeViewPortExt.cx ^ sizeWindowExt.cx) < 0) ? -1 : 1;

    pptSign->y = ((sizeViewPortExt.cy ^ sizeWindowExt.cy) < 0) ? -1 : 1;

    return TRUE;
}


BOOL
GdDrawOutlineRect(Gdiplus::Graphics * pgpgr, const RECT * prcPxl, Gdiplus::Brush * pgpbr, int nThickness)
{
    Gdiplus::RectF rc(
        (float) prcPxl->left,
        (float) prcPxl->top, 
        (float) (prcPxl->right - prcPxl->left),
        (float) (prcPxl->bottom - prcPxl->top));

    if ((rc.Width < 0) || (rc.Height < 0)) {
        return FALSE;
    }
    Gdiplus::RectF rcPxl(rc);


    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */

    Gdiplus::PointF ptEdge((float) nThickness, (float) nThickness);

    Gdiplus::RectF rcFill;
    BOOL fSuccess = TRUE;

    // Top border
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = rc.Width;
    rcFill.Height   = ptEdge.Y;
    pgpgr->FillRectangle(pgpbr, rcFill);

    // Bottom border
    rc.Y            = rcPxl.Y + rcPxl.Height - ptEdge.Y;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = rc.Width;
    rcFill.Height   = ptEdge.Y;
    pgpgr->FillRectangle(pgpbr, rcFill);

    /*
     * Left Border
     * Don't xor the corners twice
     */
    rc.Y            = rcPxl.Y + ptEdge.Y;
    rc.Height      -= 2 * ptEdge.Y;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = ptEdge.X;
    rcFill.Height   = rc.Height;
    pgpgr->FillRectangle(pgpbr, rcFill);

    // Right Border
    rc.X            = rcPxl.X + rcPxl.Width - ptEdge.X;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = ptEdge.X;
    rcFill.Height   = rc.Height;
    pgpgr->FillRectangle(pgpbr, rcFill);

    return fSuccess;
}


/***************************************************************************\
*
* GdDrawOutlineRect
*
* GdDrawOutlineRect draws the outline of a rectange using the specified 
* brush.  This function uses the same "off-by-1" errors as GDI.
*
\***************************************************************************/

BOOL
GdDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness)
{
    int        w;
    int        h;
    POINT      point;
    POINT      ptEdge;

    if (!GetSignFromMappingMode(hdc, &ptEdge))
        return FALSE;

    h = prcPxl->bottom - (point.y = prcPxl->top);
    if (h < 0) {
        return FALSE;
    }

    w = prcPxl->right -  (point.x = prcPxl->left);

    /*
     * Check width and height signs
     */
    if (((w ^ ptEdge.x) < 0) || ((h ^ ptEdge.y) < 0))
        return FALSE;

    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */
    ptEdge.x *= nThickness;
    ptEdge.y *= nThickness;

    RECT rcFill;
    BOOL fSuccess = TRUE;

    // Top border
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + w;
    rcFill.bottom   = point.y + ptEdge.y;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    // Bottom border
    point.y         = prcPxl->bottom - ptEdge.y;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + w;
    rcFill.bottom   = point.y + ptEdge.y;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    /*
     * Left Border
     * Don't xor the corners twice
     */
    point.y         = prcPxl->top + ptEdge.y;
    h              -= 2 * ptEdge.y;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + ptEdge.x;
    rcFill.bottom   = point.y + h;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    // Right Border
    point.x         = prcPxl->right - ptEdge.x;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + ptEdge.x;
    rcFill.bottom   = point.y + h;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\list.h ===
/***************************************************************************\
*
* File: List.h
*
* Description:
* List.h defines a collection of different list classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__List_h__INCLUDED)
#define BASE__List_h__INCLUDED
#pragma once

#if DUSER_INCLUDE_SLIST
#include "SList.h"
#endif


/***************************************************************************\
*****************************************************************************
*
* class GList provides a high-performance, doublely-linked list.
*
*****************************************************************************
\***************************************************************************/

//
// ListNode wraps some object so that it can be maintained in a list.
// This class does not derive from the class b/c it wants to always have
// pNext and pPrev as the first members of the data so that they are in the
// same place for all lists
//


struct ListNode
{
    ListNode *  pNext;
    ListNode *  pPrev;
};


//------------------------------------------------------------------------------
template <class T>
struct ListNodeT : ListNode
{
    inline  T *         GetNext() const;
    inline  T *         GetPrev() const;
};


//------------------------------------------------------------------------------
class GRawList
{
// Construction/destruction
public:
            GRawList();
            ~GRawList();

// Operations
public:
            int         GetSize() const;
            ListNode *  GetHead() const;
            ListNode *  GetTail() const;
            ListNode *  GetAt(int idxItem) const;

    inline  BOOL        IsEmpty() const;
    inline  void        Extract(GRawList & lstSrc);
    inline  void        MarkEmpty();

            void        Add(ListNode * pNode);
            void        AddHead(ListNode * pNode);
            void        AddTail(ListNode * pNode);

            void        InsertAfter(ListNode * pInsert, ListNode * pBefore);
            void        InsertBefore(ListNode * pInsert, ListNode * pAfter);

            void        Unlink(ListNode * pNode);
            ListNode *  UnlinkHead();
            ListNode *  UnlinkTail();

            int         Find(ListNode * pNode) const;

// Implementation
protected:

// Data
protected:
            ListNode *  m_pHead;
};


//------------------------------------------------------------------------------
template <class T>
class GList : public GRawList
{
// Construction/destruction
public:
    inline  ~GList();

// Operations
public:
    inline  T *         GetHead() const;
    inline  T *         GetTail() const;
    inline  T *         GetAt(int idxItem) const;

    inline  void        Extract(GList<T> & lstSrc);
    inline  T *         Extract();

    inline  void        Add(T * pNode);
    inline  void        AddHead(T * pNode);
    inline  void        AddTail(T * pNode);

    inline  void        InsertAfter(T * pInsert, T * pBefore);
    inline  void        InsertBefore(T * pInsert, T * pAfter);

    inline  void        Remove(T * pNode);
    inline  BOOL        RemoveAt(int idxItem);
    inline  void        RemoveAll();

    inline  void        Unlink(T * pNode);
    inline  void        UnlinkAll();
    inline  T *         UnlinkHead();
    inline  T *         UnlinkTail();

    inline  int         Find(T * pNode) const;
};


/***************************************************************************\
*****************************************************************************
*
* class GSingleList provides a high-performance, non-thread-safe, 
* single-linked list that is similar to GInterlockedList but without 
* the cross-thread overhead.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GSingleList
{
// Construction
public:
    inline  GSingleList();
    inline  ~GSingleList();

// Operations
public:
    inline  T *         GetHead() const;

    inline  BOOL        IsEmpty() const;
    inline  void        AddHead(T * pNode);
            void        Remove(T * pNode);
    inline  T *         Extract();

// Data
protected:
            T *         m_pHead;
};


#if DUSER_INCLUDE_SLIST

/***************************************************************************\
*****************************************************************************
*
* class GInterlockedList provides a high-performance, thread-safe stack
* that doesn't use any locks.  Because of its high-performance, lightweight
* nature, there are not very many functions that are available.  All of the
* available functions use InterlockedXXX functions to safely manipulate
* the list.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GInterlockedList
{
// Construction
public:
    inline  GInterlockedList();
    inline  ~GInterlockedList();

// Operations
public:
    inline  BOOL        IsEmptyNL() const;
    inline  void        AddHeadNL(T * pNode);
    inline  T *         RemoveHeadNL();
    inline  T *         ExtractNL();

// Implementation
protected:
    inline  void        CheckAlignment() const;

// Data
protected:
    SLIST_HEADER    m_head;
};

#endif // DUSER_INCLUDE_SLIST


/***************************************************************************\
*****************************************************************************
*
* Generic List Utilities
*
*****************************************************************************
\***************************************************************************/

template <class T> bool IsLoop(const T * pEntry);
template <class T> void ReverseSingleList(T * & pEntry);


#include "List.inl"

#endif // BASE__List_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\locks.inl ===
/***************************************************************************\
*
* File: Locks.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Locks_inl__INCLUDED)
#define BASE__Locks_inl__INCLUDED
#pragma once

#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

extern  BOOL    g_fThreadSafe;

//------------------------------------------------------------------------------
inline BOOL
IsMultiThreaded()
{
    return g_fThreadSafe;
}


#if 1
//------------------------------------------------------------------------------
inline long
SafeIncrement(volatile long * pl) 
{
    if (g_fThreadSafe) {
        return InterlockedIncrement((long *) pl);
    } else {
        return ++(*pl);
    }
}


//------------------------------------------------------------------------------
inline long
SafeDecrement(volatile long * pl)
{
    if (g_fThreadSafe) {
        return InterlockedDecrement((long *) pl);
    } else {
        return --(*pl);
    }
}


//------------------------------------------------------------------------------
inline void
SafeEnter(volatile CRITICAL_SECTION * pcs)
{
    Assert(pcs);

    if (g_fThreadSafe) {
        EnterCriticalSection((CRITICAL_SECTION *) pcs);
    }
}


//------------------------------------------------------------------------------
inline void
SafeLeave(volatile CRITICAL_SECTION * pcs)
{
    Assert(pcs);

    if (g_fThreadSafe) {
        LeaveCriticalSection((CRITICAL_SECTION *) pcs);
    }
}
#else
#define SafeIncrement   InterlockedIncrement
#define SafeDecrement   InterlockedDecrement
#define SafeEnter       EnterCriticalSection
#define SafeLeave       LeaveCriticalSection
#endif


/***************************************************************************\
*****************************************************************************
*
* class CritLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
CritLock::CritLock()
{
    m_fThreadSafe = g_fThreadSafe;
    InitializeCriticalSectionAndSpinCount(&m_cs, 500);
}


//------------------------------------------------------------------------------
inline
CritLock::~CritLock()
{
    DeleteCriticalSection(&m_cs);
}


//------------------------------------------------------------------------------
inline void        
CritLock::Enter()
{
    if (m_fThreadSafe) {
        SafeEnter(&m_cs);
    }
}
            

//------------------------------------------------------------------------------
inline void
CritLock::Leave()
{
    if (m_fThreadSafe) {
        SafeLeave(&m_cs);
    }
}


//------------------------------------------------------------------------------
inline BOOL
CritLock::GetThreadSafe() const
{
    return m_fThreadSafe;
}


//------------------------------------------------------------------------------
inline void
CritLock::SetThreadSafe(BOOL fThreadSafe)
{
    m_fThreadSafe = fThreadSafe;
}


/***************************************************************************\
*****************************************************************************
*
* class AutoCleanup
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
template <class base> 
inline
AutoCleanup<base>::~AutoCleanup()
{
    DeleteAll();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::DeleteAll()
{
    //
    // Once we start deleting items during shutdown, no new items should be 
    // created, or they will not be destroyed.
    //
    // Currently, to help ensure this, we take the lock around the entire 
    // shutdown.  If another thread tries to add during this time, they get 
    // blocked.  However, they should not be doing this because this instance
    // is going away and the object will not have a chance to be cleaned up.
    //

    m_lock.Enter();
    while (!m_lstItems.IsEmpty()) {
        base * pItem = m_lstItems.UnlinkHead();
        placement_delete(pItem, base);
        HeapFree(GetProcessHeap(), 0, pItem);
    }
    m_lock.Leave();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::Link(base * pItem) {
    m_lock.Enter();
    m_lstItems.AddHead(pItem);
    m_lock.Leave();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::Delete(base * pItem)
{
    AssertMsg(pItem != NULL, "Must specify a valid item");

    m_lock.Enter();
    m_lstItems.Unlink(pItem);
    m_lock.Leave();

    placement_delete(pItem, base);
    HeapFree(GetProcessHeap(), 0, pItem);
}


//------------------------------------------------------------------------------
template <class base, class derived>
inline derived * 
New(AutoCleanup<base> & lstItems)
{
    derived * pItem = (derived *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(derived));
    if (pItem != NULL) {
        placement_new(pItem, derived);
        lstItems.Link(pItem);
    }
    return pItem;
}

#endif // BASE__Locks_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\list.inl ===
/***************************************************************************\
*
* File: List.inl
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__List_inl__INCLUDED)
#define BASE__List_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* Generic List Utilities
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
bool IsLoop(const T * pEntry)
{
    if (pEntry == NULL) {
        return false;
    }

    const T * p1 = pEntry;
    const T * p2 = pEntry->pNext;

    while (1) {
        if (p2 == NULL) {
            return false;
        } else if (p1 == p2) {
            return true;
        }

        p2 = p2->pNext;
        if (p2 == NULL) {
            return false;
        } else if (p1 == p2) {
            return true;
        }

        p2 = p2->pNext;
        p1 = p1->pNext;
    }
}


//------------------------------------------------------------------------------
template <class T>
void ReverseSingleList(T * & pEntry)
{
    T * pPrev, * pNext;

    pPrev = NULL;
    while (pEntry != NULL) {
        pNext = static_cast<T *> (pEntry->pNext);
        pEntry->pNext = pPrev;
        pPrev = pEntry;
        pEntry = pNext;
    }

    if (pEntry == NULL) {
        pEntry = pPrev;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class ListNodeT<T>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline T *
ListNodeT<T>::GetNext() const
{
    return (T *) pNext;
}


//------------------------------------------------------------------------------
template <class T>
inline T *
ListNodeT<T>::GetPrev() const
{
    return (T *) pPrev;
}


/***************************************************************************\
*****************************************************************************
*
* class GRawList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
GRawList::GRawList()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
inline
GRawList::~GRawList()
{
    AssertMsg(m_pHead == NULL, "List data was not cleaned up");
}


//------------------------------------------------------------------------------
inline BOOL
GRawList::IsEmpty() const
{
    return m_pHead == NULL;
}


//------------------------------------------------------------------------------
inline ListNode *
GRawList::GetHead() const
{
    return m_pHead;
}


//------------------------------------------------------------------------------
inline void
GRawList::Extract(GRawList & lstSrc)
{
    AssertMsg(IsEmpty(), "Destination list must be empty to receive a new list");

    m_pHead         = lstSrc.m_pHead;
    lstSrc.m_pHead  = NULL;
}


//------------------------------------------------------------------------------
inline void
GRawList::MarkEmpty()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
inline void
GRawList::Add(ListNode * pNode)
{
    AddHead(pNode);
}


/***************************************************************************\
*****************************************************************************
*
* class GList<T>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GList<T>::~GList()
{
    //
    // NOTE: We do not call RemoveAll() from the destructor because this causes
    // too many bugs.  Components are not always aware that GList<> is deleting
    // its members in the destructor.
    //
    // Instead, we'll warn if the list is not empty and just unlink everything.

    if (!IsEmpty()) {
        Trace("WARNING: GList<> at 0x%p is not empty\n", this);
        UnlinkAll();
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetHead() const
{
    return static_cast<T *> (GRawList::GetHead());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetTail() const
{
    return static_cast<T *> (GRawList::GetTail());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetAt(int idxItem) const
{
    return static_cast<T *> (GRawList::GetAt(idxItem));
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Extract(GList<T> & lstSrc)
{
    GRawList::Extract(lstSrc);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::Extract()
{
    T * pHead = static_cast<T *> (m_pHead);
    m_pHead = NULL;
    return pHead;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Add(T * pNode)
{
    GRawList::Add(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::AddHead(T * pNode)
{
    GRawList::AddHead(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::AddTail(T * pNode)
{
    GRawList::AddTail(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::InsertAfter(T * pInsert, T * pBefore)
{
    GRawList::InsertAfter(pInsert, pBefore);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::InsertBefore(T * pInsert, T * pAfter)
{
    GRawList::InsertBefore(pInsert, pAfter);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Remove(T * pNode)
{
    Unlink(pNode);
    DoClientDelete<T>(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline BOOL
GList<T>::RemoveAt(int idxItem)
{
    ListNode * pCur = GetAt(idxItem);
    if (pCur != NULL) {
        Remove(pCur);
        return TRUE;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::RemoveAll()
{
    //
    // When removing each item, need to typecase to T so that delete can do the
    // right thing and call the correct destructor.
    //

    while (m_pHead != NULL) {
        ListNode * pNext = m_pHead->pNext;
        m_pHead->pPrev= NULL;
        T * pHead = (T *) m_pHead;
        DoClientDelete<T>(pHead);
        m_pHead = pNext;
    }
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Unlink(T * pNode)
{
    GRawList::Unlink(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::UnlinkAll()
{
    while (!IsEmpty()) {
        UnlinkHead();
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::UnlinkHead()
{
    return static_cast<T *> (GRawList::UnlinkHead());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::UnlinkTail()
{
    return static_cast<T *> (GRawList::UnlinkTail());
}

//------------------------------------------------------------------------------
template <class T>
inline int
GList<T>::Find(T * pNode) const
{
    return GRawList::Find(pNode);
}


/***************************************************************************\
*****************************************************************************
*
* class GSingleList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GSingleList<T>::GSingleList()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline
GSingleList<T>::~GSingleList()
{
    //
    // The list should be cleaned up before being destroyed.  This is being
    // explicitly Assert'd here to help ensure this, since when it is not it is
    // most likely a programming error internal to DirectUser.
    //

    AssertMsg(IsEmpty(), "List data was not cleaned up");
}

//------------------------------------------------------------------------------
template <class T>
inline T *
GSingleList<T>::GetHead() const
{
    return m_pHead;
}

//------------------------------------------------------------------------------
template <class T>
inline BOOL
GSingleList<T>::IsEmpty() const
{
    return m_pHead == NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GSingleList<T>::AddHead(T * pNode)
{
    Assert(pNode != NULL);
    pNode->pNext = m_pHead;
    m_pHead = pNode;
}

//------------------------------------------------------------------------------
template <class T>
void
GSingleList<T>::Remove(T * pNode)
{
    Assert(pNode != NULL);
    if (pNode == m_pHead) {
        m_pHead = pNode->pNext;
        pNode->pNext = NULL;
    } else {
        for (T * pTemp = m_pHead; pTemp != NULL; pTemp = pTemp->pNext) {
            if (pTemp->pNext == pNode) {
                pTemp->pNext = pNode->pNext;
                pNode->pNext = NULL;
                break;
            }
        }
        AssertMsg(pTemp != NULL, "Ensure that the node was found.");
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GSingleList<T>::Extract()
{
    T * pHead = m_pHead;
    m_pHead = NULL;
    return pHead;
}


#if DUSER_INCLUDE_SLIST

/***************************************************************************\
*****************************************************************************
*
* class GInterlockedList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GInterlockedList<T>::GInterlockedList()
{
    _RtlInitializeSListHead(&m_head);
}


//------------------------------------------------------------------------------
template <class T>
inline
GInterlockedList<T>::~GInterlockedList()
{
    //
    // The list should be cleaned up before being destroyed.  This is being
    // explicitly Assert'd here to help ensure this, since when it is not it is
    // most likely a programming error internal to DirectUser.
    //

    AssertMsg(IsEmptyNL(), "List data was not cleaned up");
}


//------------------------------------------------------------------------------
template <class T>
inline BOOL
GInterlockedList<T>::IsEmptyNL() const
{
    return _RtlFirstEntrySList(&m_head) == NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GInterlockedList<T>::CheckAlignment() const
{
    //
    // SList are a special beast because the pNext field MUST be the first
    // member of the structure.  If it is not, then we can't do an 
    // InterlockedCompareExchange64.
    //

    const size_t nOffsetNode    = offsetof(T, pNext);
    const size_t nOffsetEntry   = offsetof(SINGLE_LIST_ENTRY, Next);
    const size_t nDelta         = nOffsetNode - nOffsetEntry;

    AssertMsg(nDelta == 0, "pNext MUST be the first member of the structure");
}


//------------------------------------------------------------------------------
template <class T>
inline void
GInterlockedList<T>::AddHeadNL(T * pNode)
{
    CheckAlignment();
    _RtlInterlockedPushEntrySList(&m_head, (SLIST_ENTRY *) pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GInterlockedList<T>::RemoveHeadNL()
{
    return (T *) _RtlInterlockedPopEntrySList(&m_head);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GInterlockedList<T>::ExtractNL()
{
    return (T *) _RtlInterlockedFlushSList(&m_head);
}


#endif // DUSER_INCLUDE_SLIST

#endif // BASE__List_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\matrix.h ===
/***************************************************************************\
*
* File: Matrix.h
*
* Description:
* Matrix.h defines common Matrix and Vector operations.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__Matrix_h__INCLUDED)
#define BASE__Matrix_h__INCLUDED
#pragma once

//------------------------------------------------------------------------------
class Vector3
{
public:
    inline  Vector3();
    inline  Vector3(const Vector3 & src);
    inline  Vector3(float fl0, float fl1, float fl2);

    inline  float       Get(int x) const;
    inline  void        Set(int x, float fl);
    inline  void        Set(float flA, float flB, float flC);
    inline  float       operator[](int x) const;

    inline  void        Empty();

#if DBG
            void        Dump() const;
#endif // DBG

protected:
            float       m_rgfl[3];
};


//------------------------------------------------------------------------------
class Matrix3
{
public:
    inline  Matrix3(bool fInit = true);

            void        ApplyLeft(const XFORM * pxfLeft);
            void        ApplyLeft(const Matrix3 & mLeft);
            void        ApplyRight(const Matrix3 & mRight);

            void        Execute(POINT * rgpt, int cPoints) const;

            enum EHintBounds
            {
                hbInside,                   // Round pixels on the border inside
                hbOutside                   // Round pixels on the border outside
            };

            void        ComputeBounds(RECT * prcBounds, const RECT * prcLogical, EHintBounds hb) const;
            int         ComputeRgn(HRGN hrgnDest, const RECT * prcLogical, SIZE sizeOffsetPxl) const;

    inline  float       Get(int y, int x) const;
    inline  void        Set(int y, int x, float fl);

            void        Get(XFORM * pxf) const;

    inline  const Vector3 & operator[](int y) const;

            void        SetIdentity();
            void        Rotate(float flRotationRad);
            void        Translate(float flOffsetX, float flOffsetY);
            void        Scale(float flScaleX, float flScaleY);

#if DBG
            void        Dump() const;
#endif // DBG

protected:
            Vector3     m_rgv[3];           // Each vector is a row
            BOOL        m_fIdentity:1;      // Identity matrix
            BOOL        m_fOnlyTranslate:1; // Only translations have been applied
};


#include "Matrix.inl"

#endif // BASE__Matrix_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Public_h__INCLUDED)
#define BASE__Public_h__INCLUDED

// Standard
#include "BitHelp.h"
#include "BaseObject.h"

// Synchronization
#include "Locks.h"

// Collections
#include "Array.h"
#include "List.h"
#include "TreeNode.h"

// Resources
#include "SimpleHeap.h"
#include "AllocPool.h"
#include "TempHeap.h"

// Objects
#include "Rect.h"
#include "GfxHelp.h"
#include "StringHelp.h"
#include "Matrix.h"

#endif // BASE__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\rect.h ===
#if !defined(BASE__Rect_h_INCLUDED)
#define BASE__Rect_h_INCLUDED
#pragma once

inline  bool    InlinePtInRect(const RECT * prcCheck, POINT pt);
inline  bool    InlineIsRectEmpty(const RECT * prcCheck);
inline  bool    InlineIsRectNull(const RECT * prcCheck);
inline  bool    InlineIsRectNormalized(const RECT * prcCheck);
inline  void    InlineZeroRect(RECT * prc);
inline  void    InlineOffsetRect(RECT * prc, int xOffset, int yOffset);
inline  void    InlineInflateRect(RECT * prc, int xIncrease, int yIncrease);
inline  void    InlineCopyRect(RECT * prcDest, const RECT * prcSrc);
inline  void    InlineCopyZeroRect(RECT * prcDest, const RECT * prcSrc);
inline  void    InlineSetRectEmpty(RECT * prcDest);
inline  bool    InlineIntersectRect(RECT * prcDst, const RECT * prcSrc1, const RECT * prcSrc2);
inline  bool    InlineEqualRect(const RECT * prc1, const RECT * prc2);

#include "Rect.inl"

#endif // BASE__Rect_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\matrix.inl ===
/***************************************************************************\
*
* File: Matrix.inl
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__Matrix_inl__INCLUDED)
#define BASE__Matrix_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class Vector3
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
Vector3::Vector3()
{

}


//------------------------------------------------------------------------------
inline  
Vector3::Vector3(const Vector3 & src)
{
    m_rgfl[0] = src.m_rgfl[0];
    m_rgfl[1] = src.m_rgfl[1];
    m_rgfl[2] = src.m_rgfl[2];
}


//------------------------------------------------------------------------------
inline  
Vector3::Vector3(float fl0, float fl1, float fl2)
{
    m_rgfl[0] = fl0;
    m_rgfl[1] = fl1;
    m_rgfl[2] = fl2;
}


//------------------------------------------------------------------------------
inline float   
Vector3::operator[](int x) const
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    return m_rgfl[x]; 
}


//------------------------------------------------------------------------------
inline float   
Vector3::Get(int x) const
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    return m_rgfl[x]; 
}


//------------------------------------------------------------------------------
inline void    
Vector3::Set(int x, float fl)
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    m_rgfl[x] = fl;
}


//------------------------------------------------------------------------------
inline void    
Vector3::Set(float flA, float flB, float flC)
{
    m_rgfl[0] = flA;
    m_rgfl[1] = flB;
    m_rgfl[2] = flC;
}


//------------------------------------------------------------------------------
inline void
Vector3::Empty()
{
    m_rgfl[0] = 0.0f;
    m_rgfl[1] = 0.0f;
    m_rgfl[2] = 0.0f;
}


/***************************************************************************\
*****************************************************************************
*
* class Matrix3
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Matrix3::Matrix3(bool fInit)
{
    if (fInit) {
        m_rgv[0].Set(1.0f, 0.0f, 0.0f);
        m_rgv[1].Set(0.0f, 1.0f, 0.0f);
        m_rgv[2].Set(0.0f, 0.0f, 1.0f);

        m_fIdentity         = TRUE;
        m_fOnlyTranslate    = TRUE;
    }
}


//------------------------------------------------------------------------------
inline const Vector3 & 
Matrix3::operator[](int y) const
{
    AssertMsg((y < 3) && (y >= 0), "Ensure valid index");
    return m_rgv[y]; 
}


//------------------------------------------------------------------------------
inline float   
Matrix3::Get(int y, int x) const 
{
    return m_rgv[y][x]; 
}


//------------------------------------------------------------------------------
inline void    
Matrix3::Set(int y, int x, float fl)
{ 
    m_rgv[y].Set(x, fl); 

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}

#endif // BASE__Matrix_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\matrix.cpp ===
/***************************************************************************\
*
* File: Matrix.cpp
*
* Description:
* Matrix.cpp implements common Matrix and Vector operations.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Base.h"
#include "Matrix.h"

#include "Rect.h"

/***************************************************************************\
*****************************************************************************
*
* class Vector3
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void        
Vector3::Dump() const
{
    Trace("  | %6.2f, %6.2f, %6.2f |\n", m_rgfl[0], m_rgfl[1], m_rgfl[2]);
}

#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* class Matrix3
*
*****************************************************************************
\***************************************************************************/

/*
    //
    // Standard multiplication of A by the current Matrix.  This can be used
    // as a template to be optimized for different cases.
    //

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(A[0][0] * rgvT0[0] + A[0][1] * rgvT1[0] + A[0][2] * rgvT2[0],
                 A[0][0] * rgvT0[1] + A[0][1] * rgvT1[1] + A[0][2] * rgvT2[1],
                 A[0][0] * rgvT0[2] + A[0][1] * rgvT1[2] + A[0][2] * rgvT2[2]);

    m_rgv[1].Set(A[1][0] * rgvT0[0] + A[1][1] * rgvT1[0] + A[1][2] * rgvT2[0],
                 A[1][0] * rgvT0[1] + A[1][1] * rgvT1[1] + A[1][2] * rgvT2[1],
                 A[1][0] * rgvT0[2] + A[1][1] * rgvT1[2] + A[1][2] * rgvT2[2]);

    m_rgv[2].Set(A[2][0] * rgvT0[0] + A[2][1] * rgvT1[0] + A[2][2] * rgvT2[0],
                 A[2][0] * rgvT0[1] + A[2][1] * rgvT1[1] + A[2][2] * rgvT2[1],
                 A[2][0] * rgvT0[2] + A[2][1] * rgvT1[2] + A[2][2] * rgvT2[2]);
*/


/***************************************************************************\
*
* Matrix3::ApplyLeft
*
* ApplyLeft() left-multiples the given GDI matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = pxfLeft * mCurrent
*
\***************************************************************************/

void 
Matrix3::ApplyLeft(
    IN  const XFORM * pxfLeft)      // GDI matrix to left-multiply
{
    const XFORM * pxf = pxfLeft;

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(pxf->eM11 * rgvT0[0] + pxf->eM12 * rgvT1[0],
                 pxf->eM11 * rgvT0[1] + pxf->eM12 * rgvT1[1],
                 pxf->eM11 * rgvT0[2] + pxf->eM12 * rgvT1[2]);

    m_rgv[1].Set(pxf->eM21 * rgvT0[0] + pxf->eM22 * rgvT1[0],
                 pxf->eM21 * rgvT0[1] + pxf->eM22 * rgvT1[1],
                 pxf->eM21 * rgvT0[2] + pxf->eM22 * rgvT1[2]);

    m_rgv[2].Set(pxf->eDx * rgvT0[0] + pxf->eDy * rgvT1[0] + rgvT2[0],
                 pxf->eDx * rgvT0[1] + pxf->eDy * rgvT1[1] + rgvT2[1],
                 pxf->eDx * rgvT0[2] + pxf->eDy * rgvT1[2] + rgvT2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyLeft
*
* ApplyLeft() left-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = mLeft * mCurrent
*
\***************************************************************************/

void        
Matrix3::ApplyLeft(
    IN  const Matrix3 & mLeft)      // Matrix to left-multiply
{
    if (mLeft.m_fIdentity) {
        return;
    }

    if (m_fOnlyTranslate && mLeft.m_fOnlyTranslate) {
        m_rgv[2].Set(0, m_rgv[2][0] + mLeft.m_rgv[2][0]);
        m_rgv[2].Set(1, m_rgv[2][1] + mLeft.m_rgv[2][1]);

        m_fIdentity = FALSE;
        return;
    }

    const Vector3 & A0 = mLeft.m_rgv[0];
    const Vector3 & A1 = mLeft.m_rgv[1];
    const Vector3 & A2 = mLeft.m_rgv[2];

    Vector3 B0 = m_rgv[0];
    Vector3 B1 = m_rgv[1];
    Vector3 B2 = m_rgv[2];

    m_rgv[0].Set(A0[0] * B0[0] + A0[1] * B1[0] + A0[2] * B2[0],
                 A0[0] * B0[1] + A0[1] * B1[1] + A0[2] * B2[1],
                 A0[0] * B0[2] + A0[1] * B1[2] + A0[2] * B2[2]);

    m_rgv[1].Set(A1[0] * B0[0] + A1[1] * B1[0] + A1[2] * B2[0],
                 A1[0] * B0[1] + A1[1] * B1[1] + A1[2] * B2[1],
                 A1[0] * B0[2] + A1[1] * B1[2] + A1[2] * B2[2]);

    m_rgv[2].Set(A2[0] * B0[0] + A2[1] * B1[0] + A2[2] * B2[0],
                 A2[0] * B0[1] + A2[1] * B1[1] + A2[2] * B2[1],
                 A2[0] * B0[2] + A2[1] * B1[2] + A2[2] * B2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyRight
*
* ApplyRight() right-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = mCurrent * mRight
*
\***************************************************************************/

void        
Matrix3::ApplyRight(
    IN  const Matrix3 & mRight)     // Matrix to right-multiply
{
    if (mRight.m_fIdentity) {
        return;
    }

    if (m_fOnlyTranslate && mRight.m_fOnlyTranslate) {
        m_rgv[2].Set(0, m_rgv[2][0] + mRight.m_rgv[2][0]);
        m_rgv[2].Set(1, m_rgv[2][1] + mRight.m_rgv[2][1]);

        m_fIdentity = FALSE;
        return;
    }

    Vector3 A0 = m_rgv[0];
    Vector3 A1 = m_rgv[1];
    Vector3 A2 = m_rgv[2];

    const Vector3 & B0 = mRight.m_rgv[0];
    const Vector3 & B1 = mRight.m_rgv[1];
    const Vector3 & B2 = mRight.m_rgv[2];

    m_rgv[0].Set(A0[0] * B0[0] + A0[1] * B1[0] + A0[2] * B2[0],
                 A0[0] * B0[1] + A0[1] * B1[1] + A0[2] * B2[1],
                 A0[0] * B0[2] + A0[1] * B1[2] + A0[2] * B2[2]);

    m_rgv[1].Set(A1[0] * B0[0] + A1[1] * B1[0] + A1[2] * B2[0],
                 A1[0] * B0[1] + A1[1] * B1[1] + A1[2] * B2[1],
                 A1[0] * B0[2] + A1[1] * B1[2] + A1[2] * B2[2]);

    m_rgv[2].Set(A2[0] * B0[0] + A2[1] * B1[0] + A2[2] * B2[0],
                 A2[0] * B0[1] + A2[1] * B1[1] + A2[2] * B2[1],
                 A2[0] * B0[2] + A2[1] * B1[2] + A2[2] * B2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyRight
*
* ApplyRight() right-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
\***************************************************************************/

void        
Matrix3::Get(
    OUT XFORM * pxf                 // GDI matrix to receive information
    ) const
{
    pxf->eM11 = m_rgv[0][0];
    pxf->eM12 = m_rgv[0][1];
    pxf->eM21 = m_rgv[1][0];
    pxf->eM22 = m_rgv[1][1];
    pxf->eDx  = m_rgv[2][0];
    pxf->eDy  = m_rgv[2][1];
}


/***************************************************************************\
*
* Matrix3::Execute
*
* Execute() applies to given matrix on the collection of points, 
* transforming each appropriately.
*
\***************************************************************************/

void 
Matrix3::Execute(
    IN OUT POINT * rgpt,            // Points to apply matrix on
    IN  int cPoints) const          // Number of points
{
    if (m_fIdentity) {
        return;
    }

    POINT ptT, ptN;
    POINT * pptCur = rgpt;

    if (m_fOnlyTranslate) {
        //
        // Only have translated so far, so can just offset the points without
        // going through an entire transformation.
        //

        while (cPoints-- > 0) {
            ptT = *pptCur;

            ptN.x = ptT.x + (int) m_rgv[2][0];
            ptN.y = ptT.y + (int) m_rgv[2][1];

            *pptCur++ = ptN;
        }
    } else {
        while (cPoints-- > 0) {
            ptT = *pptCur;

            ptN.x = (int) (ptT.x * m_rgv[0][0] + ptT.y * m_rgv[1][0] + m_rgv[2][0] + 0.5f);
            ptN.y = (int) (ptT.x * m_rgv[0][1] + ptT.y * m_rgv[1][1] + m_rgv[2][1] + 0.5f);

            *pptCur++ = ptN;
        }
    }
}


/***************************************************************************\
*
* Matrix3::ComputeBounds
*
* ComputeBounds() computes the bounding box that will contain the given
* transformed rectangle.
*
\***************************************************************************/

void 
Matrix3::ComputeBounds(
    OUT RECT * prcBounds,           // The bound of the transformation
    IN  const RECT * prcLogical,    // The logical rectangle to transform
    IN  EHintBounds hb              // Hinting for border pixels
    ) const
{
    if (m_fIdentity) {
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");
        *prcBounds = *prcLogical;
        return;
    }

    if (m_fOnlyTranslate) {
        //
        // Only have translated, so the bounding 
        //
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");

        *prcBounds = *prcLogical;
        InlineOffsetRect(prcBounds, (int) m_rgv[2][0], (int) m_rgv[2][1]);
        return;
    }


    POINT rgpt[4];
    rgpt[0].x = prcLogical->left;
    rgpt[0].y = prcLogical->top;
    rgpt[1].x = prcLogical->right;
    rgpt[1].y = prcLogical->top;

    rgpt[2].x = prcLogical->right;
    rgpt[2].y = prcLogical->bottom;
    rgpt[3].x = prcLogical->left;
    rgpt[3].y = prcLogical->bottom;

    Execute(rgpt, _countof(rgpt));

    prcBounds->left   = min(min(rgpt[0].x, rgpt[1].x), min(rgpt[2].x, rgpt[3].x));
    prcBounds->top    = min(min(rgpt[0].y, rgpt[1].y), min(rgpt[2].y, rgpt[3].y));
    prcBounds->right  = max(max(rgpt[0].x, rgpt[1].x), max(rgpt[2].x, rgpt[3].x));
    prcBounds->bottom = max(max(rgpt[0].y, rgpt[1].y), max(rgpt[2].y, rgpt[3].y));

    if (hb == hbOutside) {
        //
        // Just converted from int to float back to int, so we may have rounding
        // errors.  To compensate, need to inflate the given rectangle so that
        // it overlaps these errors.
        //

        InlineInflateRect(prcBounds, 1, 1);
    }
}


/***************************************************************************\
*
* Matrix3::ComputeRgn
*
* ComputeRgn() builds a region for the quadrilateral generated by applying 
* this matrix to the given rectangle.
*
\***************************************************************************/

int
Matrix3::ComputeRgn(
    IN  HRGN hrgnDest, 
    IN  const RECT * prcLogical,
    IN  SIZE sizeOffsetPxl
    ) const
{
    AssertMsg(hrgnDest != NULL, "Must specify a valid (real) region");

    if (m_fIdentity || m_fOnlyTranslate){
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");

        RECT rcBounds = *prcLogical;
        InlineOffsetRect(&rcBounds, 
                ((int) m_rgv[2][0]) + sizeOffsetPxl.cx, 
                ((int) m_rgv[2][1]) + sizeOffsetPxl.cy);
        BOOL fSuccess = SetRectRgn(hrgnDest, rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom);
        return fSuccess ? SIMPLEREGION : ERROR;
    }


    POINT rgpt[4];
    rgpt[0].x = prcLogical->left;
    rgpt[0].y = prcLogical->top;
    rgpt[1].x = prcLogical->right;
    rgpt[1].y = prcLogical->top;

    rgpt[2].x = prcLogical->right;
    rgpt[2].y = prcLogical->bottom;
    rgpt[3].x = prcLogical->left;
    rgpt[3].y = prcLogical->bottom;

    Execute(rgpt, _countof(rgpt));

    HRGN hrgnTemp = CreatePolygonRgn(rgpt, _countof(rgpt), WINDING);
    if (hrgnTemp == NULL) {
        return ERROR;
    }
    int nResult;
    nResult = OffsetRgn(hrgnTemp, sizeOffsetPxl.cx, sizeOffsetPxl.cy);
    AssertMsg((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION),
            "Just successfully created region should be either simple or complex");

    nResult = CombineRgn(hrgnDest, hrgnTemp, NULL, RGN_COPY);
    DeleteObject(hrgnTemp);

    return nResult;
}


/***************************************************************************\
*
* Matrix3::SetIdentity
*
* SetIdentity() resets the matrix to the identity matrix.
*
\***************************************************************************/

void 
Matrix3::SetIdentity()
{
    m_rgv[0].Set(1.0f, 0.0f, 0.0f);
    m_rgv[1].Set(0.0f, 1.0f, 0.0f);
    m_rgv[2].Set(0.0f, 0.0f, 1.0f);

    m_fIdentity         = TRUE;
    m_fOnlyTranslate    = TRUE;
}


/***************************************************************************\
*
* Matrix3::Rotate
*
* Rotate() rotates the matrix by the specified angle.  The specific 
* orientation of clockwise or counterclockwise depends on how the matrix
* is being applied.  For MM_TEXT, this is clockwise.
*
\***************************************************************************/

void 
Matrix3::Rotate(
    IN  float flRotationRad)        // Rotation angle in radians
{
    float flCos = (float) cos(flRotationRad);
    float flSin = (float) sin(flRotationRad);
    float flSinN = - flSin;

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(flCos * rgvT0[0] + flSin * rgvT1[0],
                 flCos * rgvT0[1] + flSin * rgvT1[1],
                 flCos * rgvT0[2] + flSin * rgvT1[2]);

    m_rgv[1].Set(flSinN * rgvT0[0] + flCos * rgvT1[0],
                 flSinN * rgvT0[1] + flCos * rgvT1[1],
                 flSinN * rgvT0[2] + flCos * rgvT1[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::Translate
*
* Translate() offsets the matrix.
*
\***************************************************************************/

void 
Matrix3::Translate(
    IN  float flOffsetX,            // Horizontal offset
    IN  float flOffsetY)            // Vertical offset
{
    if (m_fOnlyTranslate) {
        AssertMsg(fabs(m_rgv[2][2] - 1.0f) < 0.00001f, "Should still be 1.0f");

        m_rgv[2].Set(m_rgv[2][0] + flOffsetX,
                     m_rgv[2][1] + flOffsetY,
                     1.0f);

        m_fIdentity = FALSE;
        return;
    }

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[2].Set(flOffsetX * rgvT0[0] + flOffsetY * rgvT1[0] + rgvT2[0],
                 flOffsetX * rgvT0[1] + flOffsetY * rgvT1[1] + rgvT2[1],
                 flOffsetX * rgvT0[2] + flOffsetY * rgvT1[2] + rgvT2[2]);

    m_fIdentity = FALSE;
}


/***************************************************************************\
*
* Matrix3::Scale
*
* Scale() scales the matrix.
*
\***************************************************************************/

void 
Matrix3::Scale(
    IN  float flScaleX,             // Horizontal scaling
    IN  float flScaleY)             // Vertical scaling
{
    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(flScaleX * rgvT0[0],
                 flScaleX * rgvT0[1],
                 flScaleX * rgvT0[2]);

    m_rgv[1].Set(flScaleY * rgvT1[0],
                 flScaleY * rgvT1[1],
                 flScaleY * rgvT1[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


#if DBG

//------------------------------------------------------------------------------
void        
Matrix3::Dump() const
{
    m_rgv[0].Dump();
    m_rgv[1].Dump();
    m_rgv[2].Dump();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\rect.inl ===
#if !defined(BASE__Rect_inl_INCLUDED)
#define BASE__Rect_inl_INCLUDED
#pragma once


/***************************************************************************\
*
* InlinePtInRect
*
* InlinePtInRect() provides a inline version of PtInRect().  This uses the
* exact same comparisons as PtInRect (>= and <), so don't change this unless
* PtInRect() changes.
*
\***************************************************************************/

__forceinline bool 
InlinePtInRect(const RECT * prcCheck, POINT pt)
{
    return (pt.x >= prcCheck->left) && (pt.x < prcCheck->right) &&
            (pt.y >= prcCheck->top) && (pt.y < prcCheck->bottom);
}


/***************************************************************************\
*
* InlineIsRectEmpty
*
* InlineIsRectEmpty() returns if a rect has a non-negative height and/or 
* width.  This is different than InlineIsRectNull() which checks if the rect
* is all 0's.
*
\***************************************************************************/

__forceinline bool
InlineIsRectEmpty(const RECT * prcCheck)
{
    return ((prcCheck->left >= prcCheck->right) || (prcCheck->top >= prcCheck->bottom));
}


/***************************************************************************\
*
* InlineIsRectNull
*
* InlineIsRectNull() returns if a rect is all 0's.
*
\***************************************************************************/

__forceinline bool
InlineIsRectNull(const RECT * prcCheck)
{
    return (prcCheck->left == 0) && (prcCheck->top == 0) && 
            (prcCheck->right == 0) && (prcCheck->bottom == 0);
}


/***************************************************************************\
*
* InlineIsRectNormalized
*
* InlineIsRectNormalized() returns if a rect is properly normalized so that
* the upper-left corner is able the lower-right corner.  This is different
* than !IsRectEmpty() because the rectangle may still be empty.
*
\***************************************************************************/

__forceinline bool    
InlineIsRectNormalized(const RECT * prcCheck)
{
    return (prcCheck->left <= prcCheck->right) && (prcCheck->top <= prcCheck->bottom);
}


/***************************************************************************\
*
* InlineZeroRect
*
* InlineZeroRect() moves a rect to (0, 0)
*
\***************************************************************************/

__forceinline void    
InlineZeroRect(RECT * prc)
{
    prc->right  -= prc->left;
    prc->bottom -= prc->top;
    prc->left    = 0;
    prc->top     = 0;
}


/***************************************************************************\
*
* InlineOffsetRect
*
* InlineOffsetRect() offsets a rect by a given amount.
*
\***************************************************************************/

__forceinline void    
InlineOffsetRect(RECT * prc, int xOffset, int yOffset)
{
    prc->left   += xOffset;
    prc->top    += yOffset;
    prc->right  += xOffset;
    prc->bottom += yOffset;
}


/***************************************************************************\
*
* InlineInflateRect
*
* InlineInflateRect() moves the corners of the rectangle out from the center
* by a given amount.
*
\***************************************************************************/

__forceinline void    
InlineInflateRect(RECT * prc, int xIncrease, int yIncrease)
{
    prc->left   -= xIncrease;
    prc->top    -= yIncrease;
    prc->right  += xIncrease;
    prc->bottom += yIncrease;
}


/***************************************************************************\
*
* InlineCopyRect
*
* InlineCopyRect() copies a rectangle.
*
\***************************************************************************/

__forceinline void    
InlineCopyRect(RECT * prcDest, const RECT * prcSrc)
{
    prcDest->left   = prcSrc->left;
    prcDest->top    = prcSrc->top;
    prcDest->right  = prcSrc->right;
    prcDest->bottom = prcSrc->bottom;
}


/***************************************************************************\
*
* InlineCopyZeroRect
*
* InlineCopyZeroRect() copies a rectangle and moves it to (0, 0)
*
\***************************************************************************/

__forceinline void    
InlineCopyZeroRect(RECT * prcDest, const RECT * prcSrc)
{
    prcDest->left   = 0;
    prcDest->top    = 0;
    prcDest->right  = prcSrc->right - prcSrc->left;
    prcDest->bottom = prcSrc->bottom - prcSrc->top;
}


//------------------------------------------------------------------------------
__forceinline void    
InlineSetRectEmpty(
    OUT RECT * prcDest)
{
    prcDest->left = prcDest->top = prcDest->right = prcDest->bottom = 0;
}


//------------------------------------------------------------------------------
__forceinline bool 
InlineIntersectRect(
    OUT RECT * prcDst,
    IN  const RECT * prcSrc1,
    IN  const RECT * prcSrc2)
{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return true;        // not empty
        }
    }

    /*
     * empty rect
     */
    InlineSetRectEmpty(prcDst);

    return false;
}


//------------------------------------------------------------------------------
__forceinline bool    
InlineEqualRect(
    IN  const RECT * prc1, 
    IN  const RECT * prc2)
{
    return (prc1->left == prc2->left) && (prc1->top == prc2->top) && 
           (prc1->right == prc2->right) && (prc1->bottom == prc2->bottom);
}


#endif // BASE__Rect_inl_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\simpleheap.cpp ===
/***************************************************************************\
*
* File: SimpleHelp.cpp
*
* Description:
* SimpleHeap.cpp implements the heap operations used throughout DirectUser.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "SimpleHeap.h"

#include "List.h"
#include "Locks.h"


DWORD       g_tlsHeap   = (DWORD) -1;
HANDLE      g_hHeap     = NULL;
DUserHeap * g_pheapProcess;


/***************************************************************************\
*****************************************************************************
*
* class DUserHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DUserHeap::DUserHeap()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
void
DUserHeap::Lock()
{
    SafeIncrement(&m_cRef);
}


//------------------------------------------------------------------------------
BOOL
DUserHeap::Unlock()
{
    AssertMsg(m_cRef > 0, "Must have an outstanding referenced");
    if (SafeDecrement(&m_cRef) == 0) {
        placement_delete(this, DUserHeap);
        HeapFree(g_hHeap, 0, this);

        return FALSE;  // Heap is no longer valid
    }

    return TRUE;  // Heap is still valid
}


#ifdef _DEBUG  // Needs DEBUG CRT's

/***************************************************************************\
*****************************************************************************
*
* class CrtDbgHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class CrtDbgHeap : public DUserHeap
{
// Construction    
public:    
    virtual ~CrtDbgHeap();
            

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);
};


//------------------------------------------------------------------------------
CrtDbgHeap::~CrtDbgHeap()
{
    
}


//------------------------------------------------------------------------------
void *
CrtDbgHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    void * pvMem = _malloc_dbg(cbSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
    if ((pvMem != NULL) && fZero) {
        ZeroMemory(pvMem, cbSize);
    }
    return pvMem;
}


//------------------------------------------------------------------------------
void *
CrtDbgHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    void * pvNewMem = _realloc_dbg(pvMem, cbNewSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
    return pvNewMem;
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    int idx = 0;
    while (idx < cItems) {
        prgAlloc[idx] = _malloc_dbg(cbSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
        if (prgAlloc[idx] == NULL) {
            break;
        }
        idx++;
    }

    *pnActual = idx;
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::Free(void * pvMem)
{
    _free_dbg(pvMem, _NORMAL_BLOCK);
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    UNREFERENCED_PARAMETER(cbSize);

    for (int idx = 0; idx < cItems; idx++) {
        _free_dbg(prgAlloc[idx], _NORMAL_BLOCK);
    }
}

#endif // _DEBUG


/***************************************************************************\
*****************************************************************************
*
* class NtHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class NtHeap : public DUserHeap
{
// Construction    
public:    
    inline  NtHeap();
    virtual ~NtHeap();
            HRESULT     Create(BOOL fSerialize);
    inline  void        Destroy();
    inline  void        Attach(HANDLE hHeap, BOOL fPassOwnership);
    inline  HANDLE      Detach();
            

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);

// Implementation
protected:
    inline  DWORD       GetFlags(DWORD dwExtra = 0) const;
    
// Data
protected:    
            HANDLE      m_hHeap;
            BOOL        m_fOwnHeap:1;
            BOOL        m_fSerialize:1;
};


//------------------------------------------------------------------------------
inline
NtHeap::NtHeap()
{
    m_hHeap         = NULL;
    m_fOwnHeap      = FALSE;
    m_fSerialize    = FALSE;
}


//------------------------------------------------------------------------------
NtHeap::~NtHeap()
{
    Destroy();
}


//------------------------------------------------------------------------------
HRESULT
NtHeap::Create(BOOL fSerialize)
{
    AssertMsg(m_hHeap == NULL, "Can not re-create heap");

    m_hHeap = HeapCreate(fSerialize ? 0 : HEAP_NO_SERIALIZE, 256 * 1024, 0);
    if (m_hHeap != NULL) {
        m_fOwnHeap      = TRUE;
        m_fSerialize    = fSerialize;
    }

    return m_hHeap != NULL ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
inline void
NtHeap::Destroy()
{
    if (m_fOwnHeap && (m_hHeap != NULL)) {
        HeapDestroy(m_hHeap);
        m_hHeap         = NULL;
        m_fOwnHeap      = FALSE;
        m_fSerialize    = FALSE;
    }
}


//------------------------------------------------------------------------------
inline void
NtHeap::Attach(HANDLE hHeap, BOOL fPassOwnership)
{
    AssertMsg(hHeap != NULL, "Must specify valid heap");
    AssertMsg(m_hHeap == NULL, "Can re-attach heap");

    m_hHeap         = hHeap;
    m_fOwnHeap      = fPassOwnership;
    m_fSerialize    = TRUE;
}


//------------------------------------------------------------------------------
inline HANDLE
NtHeap::Detach()
{
    HANDLE hHeap    = m_hHeap;

    m_hHeap         = NULL;
    m_fOwnHeap      = FALSE;
    m_fSerialize    = FALSE;

    return hHeap;
}


//------------------------------------------------------------------------------
inline DWORD
NtHeap::GetFlags(DWORD dwExtra) const
{
    return dwExtra | (m_fSerialize ? 0 : HEAP_NO_SERIALIZE);
}


//------------------------------------------------------------------------------
void *
NtHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    
    return HeapAlloc(m_hHeap, GetFlags(fZero ? HEAP_ZERO_MEMORY : 0), cbSize);
}


//------------------------------------------------------------------------------
void *
NtHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    DWORD dwFlags = GetFlags(HEAP_ZERO_MEMORY);
    
    if (pvMem == NULL) {
        return HeapAlloc(m_hHeap, dwFlags, cbNewSize);
    } else {
        return HeapReAlloc(m_hHeap, dwFlags, pvMem, cbNewSize);
    }
}


//------------------------------------------------------------------------------
void 
NtHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    DWORD dwFlags = GetFlags();
    
    int idx = 0;
    while (idx < cItems) {
        prgAlloc[idx] = HeapAlloc(m_hHeap, dwFlags, cbSize);
        if (prgAlloc[idx] == NULL) {
            break;
        }
        idx++;
    }

    *pnActual = idx;
}


//------------------------------------------------------------------------------
void 
NtHeap::Free(void * pvMem)
{
    if (pvMem != NULL) {
        HeapFree(m_hHeap, 0, pvMem);
    }
}


//------------------------------------------------------------------------------
void 
NtHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    UNREFERENCED_PARAMETER(cbSize);

    DWORD dwFlags = GetFlags(0);
    for (int idx = 0; idx < cItems; idx++) {
        if (prgAlloc[idx] != NULL) {
            HeapFree(m_hHeap, dwFlags, prgAlloc[idx]);
        }
    }
}


/***************************************************************************\
*****************************************************************************
*
* class RockAllHeap
* 
*****************************************************************************
\***************************************************************************/

#if USE_ROCKALL

#include <Rockall.hpp>

#pragma comment(lib, "RAHeap.lib")
#pragma comment(lib, "RALibrary.lib")
#pragma comment(lib, "Rockall.lib")


//------------------------------------------------------------------------------
class RockAllHeap : public DUserHeap
{
// Construction
public:
            RockAllHeap(BOOL fSerialize);
            HRESULT     Create();

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);

// Implementation
protected:
    class CustomHeap : public ROCKALL
    {
    // Construction
    public:
                CustomHeap(bool ThreadSafe=true, int MaxFreeSpace=4194304, bool Recycle=true, bool SingleImage=false);
    };

// Data
protected:
            CustomHeap  m_heap;
};


//------------------------------------------------------------------------------
RockAllHeap::RockAllHeap(BOOL fSerialize) : m_heap(!!fSerialize)
{

}


//------------------------------------------------------------------------------
HRESULT
RockAllHeap::Create()
{
    return m_heap.Corrupt() ? E_OUTOFMEMORY : S_OK;
}



//------------------------------------------------------------------------------
void * 
RockAllHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    return m_heap.New(cbSize, NULL, fZero);
}


//------------------------------------------------------------------------------
void * 
RockAllHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    return m_heap.Resize(pvMem, cbNewSize);
}


//------------------------------------------------------------------------------
void
RockAllHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    m_heap.MultipleNew(pnActual, prgAlloc, cItems, cbSize, NULL, false);
}


//------------------------------------------------------------------------------
void 
RockAllHeap::Free(void * pvMem)
{
    m_heap.Delete(pvMem);
}


//------------------------------------------------------------------------------
void
RockAllHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    m_heap.MultipleDelete(cItems, prgAlloc, cbSize);
}


const int FindCacheSize         = 4096;
const int FindCacheThreshold    = 0;
const int FindSize              = 2048;
const int Stride1               = 8;
const int Stride2               = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/


//
// NOTE: DUser needs to ensure that all memory is allocated on 8 byte 
// boundaries.  This is used be several external components, including
// S-Lists.  To ensure this, the smallest "Bucket Size" must be >= 8 bytes.
//

static ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{       16,      128,     4096,     4096 },
		{       24,       64,     4096,     4096 },
		{       32,       64,     4096,     4096 },
		{       40,      256,     4096,     4096 },
		{       64,      256,     4096,     4096 },
		{       80,      256,     4096,     4096 },
		{      128,       32,     4096,     4096 },
		{      256,       16,     4096,     4096 },
		{      512,        4,     4096,     4096 },
		{ 0,0,0,0 }
	};

static ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

static int NewPageSizes[] = { 1,4,16,64,128,0 };

//------------------------------------------------------------------------------
RockAllHeap::CustomHeap::CustomHeap(bool ThreadSafe, int MaxFreeSpace, bool Recycle, bool SingleImage) :
		ROCKALL(Caches1, Caches2, FindCacheSize, FindCacheThreshold, FindSize,
			    MaxFreeSpace, NewPageSizes, Recycle, SingleImage, 
                Stride1, Stride2, ThreadSafe)
{ 
    
}


#endif // USE_ROCKALL


//------------------------------------------------------------------------------
HRESULT
CreateProcessHeap()
{
    AssertMsg(g_pheapProcess == NULL, "Only should init process heap once");
    
    g_tlsHeap = TlsAlloc();
    if (g_tlsHeap == (DWORD) -1) {
        return E_OUTOFMEMORY;
    }
    
    g_hHeap = GetProcessHeap();

    DUserHeap * pNewHeap;
#ifdef _DEBUG
    pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(CrtDbgHeap));
#else
    pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(NtHeap));
#endif
    if (pNewHeap == NULL) {
        return E_OUTOFMEMORY;
    }

#ifdef _DEBUG
    placement_new(pNewHeap, CrtDbgHeap);
#else
    placement_new(pNewHeap, NtHeap);
    ((NtHeap *) pNewHeap)->Attach(g_hHeap, FALSE /* Don't pass ownership */);
#endif

    g_pheapProcess = pNewHeap;
    
    return S_OK;
}


//------------------------------------------------------------------------------
void
DestroyProcessHeap()
{
    if (g_pheapProcess != NULL) {
        g_pheapProcess->Unlock();
        g_pheapProcess = NULL;
    }

    if (g_tlsHeap == (DWORD) -1) {
        TlsFree(g_tlsHeap);
        g_tlsHeap   = (DWORD) -1;
    }
    
    g_hHeap     = NULL;
}


/***************************************************************************\
*
* CreateContextHeap
*
* CreateContextHeap() initializes the thread-specific heap to either an 
* existing heap or a new heap.  All threads in the same Context should be
* initialized with the same heap so that they can safely shared data between
* threads.  When the Context is finally destroyed, call DestroyContextHeap()
* to cleanup the heap.
*
\***************************************************************************/

HRESULT
CreateContextHeap(
    IN  DUserHeap * pLinkHeap,          // Existing heap to share
    IN  BOOL fThreadSafe,               // Heap mode
    IN  DUserHeap::EHeap id,            // Heap type
    OUT DUserHeap ** ppNewHeap)         // New heap (OPTIONAL)
{
    HRESULT hr;
    
    if (ppNewHeap != NULL) {
        *ppNewHeap = NULL;
    }


    //
    // Check if a heap already exists.
    //
    // NOTE: This will occur on the starting thread because the initial heap 
    // must be initialized so that we can create new objects.
    //
    DUserHeap * pNewHeap = reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap));
    if (pNewHeap == NULL) {
        if (pLinkHeap == NULL) {
            //
            // Need to create a new heap.
            //

            switch (id)
            {
            case DUserHeap::idProcessHeap:
            case DUserHeap::idNtHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(NtHeap));
                break;
                
#ifdef _DEBUG
            case DUserHeap::idCrtDbgHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(CrtDbgHeap));
                break;
#endif
                
#if USE_ROCKALL
            case DUserHeap::idRockAllHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(RockAllHeap));
                break;
#endif

            default:
                AssertMsg(0, "Unknown heap type");
            }
            if (pNewHeap == NULL) {
                return E_OUTOFMEMORY;
            }

            hr = E_FAIL;
            switch (id)
            {
            case DUserHeap::idProcessHeap:
                placement_new(pNewHeap, NtHeap);
                ((NtHeap *) pNewHeap)->Attach(g_hHeap, FALSE /* Don't pass ownership */);
                hr = S_OK;
                break;
                
            case DUserHeap::idNtHeap:
                placement_new(pNewHeap, NtHeap);
                hr = ((NtHeap *) pNewHeap)->Create(fThreadSafe);
                break;
                
#ifdef _DEBUG
            case DUserHeap::idCrtDbgHeap:
                placement_new(pNewHeap, CrtDbgHeap);
                hr = S_OK;
                break;
#endif
                
#if USE_ROCKALL
            case DUserHeap::idRockAllHeap:
                placement_new1(pNewHeap, RockAllHeap, fThreadSafe);
                hr = ((RockAllHeap *) pNewHeap)->Create();
                break;
#endif

            default:
                AssertMsg(0, "Unknown heap type");
            }
            if (FAILED(hr)) {
                pNewHeap->Unlock();
                return hr;
            }
        } else {
            pLinkHeap->Lock();
            pNewHeap = pLinkHeap;
        }

        Verify(TlsSetValue(g_tlsHeap, pNewHeap));
    }

    if (ppNewHeap != NULL) {
        *ppNewHeap = pNewHeap;
    }
    return S_OK;
}


/***************************************************************************\
*
* DestroyContextHeap
*
* DestroyContextHeap() frees resources used by a Context's shared heap.
*
\***************************************************************************/

void        
DestroyContextHeap(
    IN  DUserHeap * pHeapDestroy)      // Heap to destroy
{
    if (pHeapDestroy != NULL) {
        pHeapDestroy->Unlock();
    }

    DUserHeap * pHeap = reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap));
    if (pHeapDestroy == pHeap) {
        Verify(TlsSetValue(g_tlsHeap, NULL));
    }
}


/***************************************************************************\
*
* ForceSetContextHeap
*
* ForceSetContextHeap() is called during shutdown when it is necessary to
* "force" the current thread to use a different thread's heap so that the
* objects can be properly destroyed.
*
* NOTE: This function must be VERY carefully called since it directly 
* changes the heap for a thread.  It should only be called from the
* ResourceManager when destroying threads.
*
\***************************************************************************/

void        
ForceSetContextHeap(
    IN  DUserHeap * pHeapThread)        // Heap to use on this Thread
{
    Verify(TlsSetValue(g_tlsHeap, pHeapThread));
}


#if DBG

//------------------------------------------------------------------------------
void 
DumpData(
    IN  void * pMem,
    IN  int nLength)
{
    int row = 4;
    char * pszData = (char *) pMem;
    int cbData = min(16, nLength);
    int cbTotal = 0;

    //
    // For each row, we will dump up to 16 characters in both hexidecimal
    // and if an actual character, their displayed character.
    //

    while ((row-- > 0) && (cbTotal < nLength)) {
        int cb = cbData;
        char * pszDump = pszData;
        Trace("0x%p: ", pszData);

        int cbTemp = cbTotal;
        while (cb-- > 0) {
            cbTemp++;
            if (cbTemp > nLength) {
                Trace("   ");
            } else {
                Trace("%02x ", (unsigned char) (*pszDump++));
            }
        }

        Trace("   ");

        cb = cbData;
        while (cb-- > 0) {
            char ch = (unsigned char) (*pszData++);
            Trace("%c", IsCharAlphaNumeric(ch) ? ch : '.');

            cbTotal++;
            if (cbTotal > nLength) {
                break;
            }
        }

        Trace("\n");
    }
    Trace("\n");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\stringhelp.cpp ===
#include "stdafx.h"
#include "Base.h"
#include "StringHelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\stdafx.h ===
#if !defined(BASE__StdAfx_h__INCLUDED)
#define BASE__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // BASE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\simpleheap.h ===
/***************************************************************************\
*
* File: SimpleHelp.h
*
* Description:
* SimpleHeap.h defines the heap operations used throughout DirectUser.  See
* below for a description of the different heaps.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__SimpleHeap_h__INCLUDED)
#define BASE__SimpleHeap_h__INCLUDED

#ifdef _X86_
#define USE_ROCKALL         1       // Use RockAll Research heap
#endif

#define USE_DYNAMICTLS      1       // Use Dynamic TLS using TlsAlloc()

/***************************************************************************\
*****************************************************************************
*
* Common memory management
*
*****************************************************************************
\***************************************************************************/

//
// DirectUser supports multiple heaps used in different situations:
// - Default:   Heap shared by all threads within a common Context
// - Context:   Explicit heap for a (potentially different) Context- used cross-Context
// - Process:   Shared heap available by all Context's within the process.
//
// NOTE: It is VERY important that the Alloc() and Free() calls are properly
// matched so that the memory is properly freed from the correct heap.  If this
// is not done, the memory will not be freed and will result in memory leaks
// or potential process faults.
//

#if DBG
#define DBG_HEAP_PARAMS , const char * pszFileName, int idxLineNum
#define DBG_HEAP_USE    do { pszFileName; idxLineNum; } while (0);
#else
#define DBG_HEAP_PARAMS
#define DBG_HEAP_USE
#endif

class DUserHeap
{
// Construction    
public:
            DUserHeap();
    virtual ~DUserHeap() { }

    enum EHeap
    {
        idProcessHeap   = 0,
        idNtHeap        = 1,
#ifdef _DEBUG
        idCrtDbgHeap    = 2,
#endif
#if USE_ROCKALL
        idRockAllHeap   = 3,
#endif
    };

// Operations
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS) PURE;
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS) PURE;
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS) PURE;
    
    virtual void        Free(void * pvMem) PURE;
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize) PURE;

    public:
                void        Lock();
                BOOL        Unlock();

// Data:
protected:
                long    m_cRef;
};


HRESULT     CreateProcessHeap();
void        DestroyProcessHeap();
HRESULT     CreateContextHeap(DUserHeap * pLinkHeap, BOOL fThreadSafe, DUserHeap::EHeap id, DUserHeap ** ppNewHeap);
void        DestroyContextHeap(DUserHeap * pHeapDestroy);
void        ForceSetContextHeap(DUserHeap * pHeapThread);


extern DUserHeap *      g_pheapProcess;
extern DWORD            g_tlsHeap;

#define pProcessHeap    g_pheapProcess
#define pContextHeap    (reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap)))


#if DBG

#define ClientAlloc(a)              pContextHeap->Alloc(a, true, __FILE__, __LINE__)
#define ClientAlloc_(a,b)           pContextHeap->Alloc(a, b, __FILE__, __LINE__)
#define ClientFree(a)               pContextHeap->Free(a)
#define ClientRealloc(a,b)          pContextHeap->Realloc(a, b, __FILE__, __LINE__)
#define ClientMultiAlloc(a,b,c,d)   pContextHeap->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ClientMultiFree(a,b,c)      pContextHeap->MultiFree(a,b,c)

#define ContextAlloc(p, a)          p->Alloc(a, true, __FILE__, __LINE__)
#define ContextAlloc_(p, a, b)      p->Alloc(a, b, __FILE__, __LINE__)
#define ContextFree(p, a)           p->Free(a)
#define ContextRealloc(p, a, b)     p->Realloc(a, b, __FILE__, __LINE__)
#define ContextMultiAlloc(p,a,b,c,d) p->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ContextMultiFree(p,a, b, c) p->MultiFree(a,b,c)

#define ProcessAlloc(a)             pProcessHeap->Alloc(a, true, __FILE__, __LINE__)
#define ProcessAlloc_(a, b)         pProcessHeap->Alloc(a, b, __FILE__, __LINE__)
#define ProcessFree(a)              pProcessHeap->Free(a)
#define ProcessRealloc(a, b)        pProcessHeap->Realloc(a, b, __FILE__, __LINE__)
#define ProcessMultiAlloc(a,b,c,d)  pProcessHeap->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ProcessMultiFree(a, b, c)   pProcessHeap->MultiFree(a,b,c)

void            DumpData(void * pMem, int nLength);


#else  // DBG


#define ClientAlloc(a)              pContextHeap->Alloc(a, true)
#define ClientAlloc_(a,b)           pContextHeap->Alloc(a, b)
#define ClientFree(a)               pContextHeap->Free(a)
#define ClientRealloc(a,b)          pContextHeap->Realloc(a, b)
#define ClientMultiAlloc(a,b,c,d)   pContextHeap->MultiAlloc(a, b, c, d)
#define ClientMultiFree(a,b,c)      pContextHeap->MultiFree(a,b,c)

#define ContextAlloc(p, a)          p->Alloc(a, true)
#define ContextAlloc_(p, a, b)      p->Alloc(a, b)
#define ContextFree(p, a)           p->Free(a)
#define ContextRealloc(p, a, b)     p->Realloc(a, b)
#define ContextMultiAlloc(p,a,b,c,d) p->MultiAlloc(a, b, c, d)
#define ContextMultiFree(p,a, b, c) p->MultiFree(a,b,c)

#define ProcessAlloc(a)             pProcessHeap->Alloc(a, true)
#define ProcessAlloc_(a, b)         pProcessHeap->Alloc(a, b)
#define ProcessFree(a)              pProcessHeap->Free(a)
#define ProcessRealloc(a, b)        pProcessHeap->Realloc(a, b)
#define ProcessMultiAlloc(a,b,c,d)  pProcessHeap->MultiAlloc(a, b, c, d)
#define ProcessMultiFree(a, b, c)   pProcessHeap->MultiFree(a,b,c)


#endif // DBG


/***************************************************************************\
*****************************************************************************
*
* operator new overloading
*
*****************************************************************************
\***************************************************************************/

#ifndef _INC_NEW
#include <new.h>
#endif

#if DBG

//
//  Use this instead of the usual placement new syntax to avoid conflicts when
//  'new' is re-defined to provide memory leak tracking (below)

#define placement_new(pv, Class)            PlacementNewImpl0<Class>(pv)
#define placement_new1(pv, Class, p1)       PlacementNewImpl1<Class>(pv, p1)
#define placement_copynew(pv, Class, src)   PlacementCopyNewImpl0<Class>(pv, src)
#define placement_delete(pv, Class) (((Class *)(pv))->~Class())

#ifdef new
#undef new
#endif

template <class T>
inline T *
PlacementNewImpl0(void *pv)
{
    return new(pv) T;
};

template <class T, class Param1>
inline T *
PlacementNewImpl1(void *pv, Param1 p1)
{
    return new(pv) T(p1);
};

template <class T>
inline T *
PlacementCopyNewImpl0(void *pv, const T & t)
{
    return new(pv) T(t);
};

#else  // DBG

#define DEBUG_NEW new
#define placement_new(pv, Class)            new(pv) Class
#define placement_new1(pv, Class, p1)       new(pv) Class(p1)
#define placement_copynew(pv, Class, src)   new(pv) Class(src)
#define placement_delete(pv, Class) (((Class *)(pv))->~Class())

#endif // DBG


inline void * __cdecl operator new(size_t nSize)
{
    void * pv = ClientAlloc(nSize);
    return pv;
}

inline void __cdecl operator delete(void * pvMem)
{
    ClientFree(pvMem);
}

#if DBG
template <class type>   inline type *   DoProcessNewDbg(const char * pszFileName, int idxLineNum);
template <class type>   inline type *   DoClientNewDbg(const char * pszFileName, int idxLineNum);
template <class type>   inline type *   DoContextNewDbg(DUserHeap * pHeap, const char * pszFileName, int idxLineNum);
#else
template <class type>   inline type *   DoProcessNew();
template <class type>   inline type *   DoClientNew();
template <class type>   inline type *   DoContextNew(DUserHeap * pHeap);
#endif
template <class type>   inline void     DoProcessDelete(type * pMem);
template <class type>   inline void     DoClientDelete(type * pMem);
template <class type>   inline void     DoContextDelete(DUserHeap * pHeap, type * pMem);

#if DBG
#define ProcessNew(t)           DoProcessNewDbg<t>(__FILE__, __LINE__)
#define ClientNew(t)            DoClientNewDbg<t>(__FILE__, __LINE__)
#define ContextNew(t,p)         DoContextNewDbg<t>(p, __FILE__, __LINE__)
#else
#define ProcessNew(t)           DoProcessNew<t>()
#define ClientNew(t)            DoClientNew<t>()
#define ContextNew(t,p)         DoContextNew<t>(p)
#endif
#define ProcessDelete(t,p)      DoProcessDelete<t>(p)
#define ClientDelete(t,p)       DoClientDelete<t>(p)
#define ContextDelete(t,h,p)    DoContextDelete<t>(p)



//
// To allocate memory on the stack that is aligned on an 8-byte boundary
// we need to allocate an extra 4 bytes.  All stack allocations are on
// 4 byte boundaries.
//

#define STACK_ALIGN8_ALLOC(cb) \
    ((void *) ((((UINT_PTR) _alloca(cb + 4)) + 7) & ~0x07))

#include "SimpleHeap.inl"

#endif // BASE__SimpleHeap_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Base.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\simpleheap.inl ===
/***************************************************************************\
*
* File: SimpleHelp.inl
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__SimpleHeap_inl__INCLUDED)
#define BASE__SimpleHeap_inl__INCLUDED
#pragma once

class ProcessHeap
{
public:
    static DUserHeap * GetHeap()
    {
        return pProcessHeap;
    }
};


class ContextHeap
{
public:
    static DUserHeap * GetHeap()
    {
        return pContextHeap;
    }
};


#if DBG

//------------------------------------------------------------------------------
template <class type>
inline type *
DoProcessNewDbg(const char * pszFileName, int idxLineNum)
{
    void * pvMem = pProcessHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoClientNewDbg(const char * pszFileName, int idxLineNum)
{
    void * pvMem = pContextHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoContextNewDbg(DUserHeap * pHeap, const char * pszFileName, int idxLineNum)
{
    void * pvMem = pHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}

#else // DBG

//------------------------------------------------------------------------------
template <class type>
inline type *
DoProcessNew()
{
    void * pvMem = pProcessHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoClientNew()
{
    void * pvMem = pContextHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoContextNew(DUserHeap * pHeap)
{
    void * pvMem = pHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}

#endif // DBG

//------------------------------------------------------------------------------
template <class type>
inline void
DoProcessDelete(type * pMem)
{
    if (pMem != NULL) {
#if ENABLE_DUMPDELETE
        Trace("Start ProcessFree(0x%p), size=%d\n", pMem, sizeof(type));
#endif // ENABLE_DUMPDELETE

        placement_delete(pMem, type);

#if ENABLE_DUMPDELETE
        Trace("Dump  ProcessFree(0x%p), size=%d\n", pMem, sizeof(type));
        DumpData(pMem, sizeof(type));
#endif // ENABLE_DUMPDELETE

        pProcessHeap->Free(pMem);
    }
}


//------------------------------------------------------------------------------
template <class type>
inline void
DoClientDelete(type * pMem)
{
    if (pMem != NULL) {
        placement_delete(pMem, type);
        pContextHeap->Free(pMem);
    }
}



//------------------------------------------------------------------------------
template <class type>
inline void
DoContextDelete(DUserHeap * pHeap, type * pMem)
{
    if (pMem != NULL) {
        placement_delete(pMem, type);
        pHeap->Free(pMem);
    }
}


#if !DBG

//------------------------------------------------------------------------------
inline void 
DumpData(
    IN  void * pMem,
    IN  int nLength)
{
    UNREFERENCED_PARAMETER(pMem);
    UNREFERENCED_PARAMETER(nLength);
}

#endif // DBG


#endif // BASE__SimpleHeap_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\stringhelp.h ===
#if !defined(BASE__String_h__INCLUDED)
#define BASE__String_h__INCLUDED
#pragma once

inline  void        CopyString(WCHAR * pszDest, const WCHAR * pszSrc, int cchMax);

#include "StringHelp.inl"

#endif // BASE__String_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\stringhelp.inl ===
#if !defined(BASE__String_inl__INCLUDED)
#define BASE__String_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline void        
CopyString(WCHAR * pszDest, const WCHAR * pszSrc, int cchMax)
{
    wcsncpy(pszDest, pszSrc, cchMax);
    pszDest[cchMax - 1] = '\0';
}


#endif // BASE__String_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\tempheap.cpp ===
/***************************************************************************\
*
* File: TempHelp.cpp
*
* Description:
* TempHelp.h implements a "lightweight heap", designed to continuously grow 
* until all memory is freed.  This is valuable as a temporary heap that can
* be used to "collect" data and processed slightly later.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "TempHeap.h"

#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* class TempHeap
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
TempHeap::TempHeap(int cbPageAlloc, int cbLargeThreshold)
{
    m_ppageCur          = NULL;
    m_ppageLarge        = NULL;
    m_pbFree            = NULL;
    m_cbFree            = 0;
    m_cbPageAlloc       = cbPageAlloc;
    m_cbLargeThreshold  = cbLargeThreshold;
}


//------------------------------------------------------------------------------
void *      
TempHeap::Alloc(int cbAlloc)
{
    AssertMsg(cbAlloc > 0, "Must specify a valid allocation size");

    if (cbAlloc > m_cbLargeThreshold) {
        //
        // Allocating a very large block, so allocate it directly.
        //

        Page * pageNew = (Page *) ClientAlloc(sizeof(Page) + cbAlloc);
        if (pageNew == NULL) {
            return NULL;
        }

        pageNew->pNext  = m_ppageLarge;
        m_ppageLarge     = pageNew;
        return pageNew->GetData();
    }

    if ((m_ppageCur == NULL) || (cbAlloc > m_cbFree)) {
        Page * pageNew = (Page *) ClientAlloc(sizeof(Page) + m_cbPageAlloc);
        if (pageNew == NULL) {
            return NULL;
        }

        pageNew->pNext  = m_ppageCur;
        m_ppageCur       = pageNew;
        m_cbFree        = m_cbPageAlloc;
        m_pbFree        = pageNew->GetData();
    }

    AssertMsg(m_cbFree >= cbAlloc, "Should have enough space to allocate by now");

    void * pvNew = m_pbFree;
    m_cbFree -= cbAlloc;
    m_pbFree += cbAlloc;

    return pvNew;
}


//------------------------------------------------------------------------------
void        
TempHeap::FreeAll(BOOL fComplete)
{
    Page * pageNext;
    Page * pageTemp;

    //
    // Free large-block allocations
    //

    pageTemp = m_ppageLarge;
    while (pageTemp != NULL) {
        pageNext = pageTemp->pNext;
        ClientFree(pageTemp);
        pageTemp = pageNext;
    }
    m_ppageLarge = NULL;


    //
    // Free small-block allocations
    //
    pageTemp = m_ppageCur;
    while (pageTemp != NULL) {
        pageNext = pageTemp->pNext;
        if ((pageNext == NULL) && (!fComplete)) {
            //
            // Don't free the first block, since we will immediately turn around
            // and allocate it again.  Instead, renew it.
            //

            m_ppageCur  = pageTemp;
            m_cbFree    = m_cbPageAlloc;
            m_pbFree    = pageTemp->GetData();
            break;
        }

        ClientFree(pageTemp);
        pageTemp = pageNext;
    }

    if (fComplete) {
        m_ppageCur  = NULL;
        m_pbFree    = NULL;
        m_cbFree    = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\tempheap.inl ===
/***************************************************************************\
*
* File: TempHelp.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__TempHeap_inl__INCLUDED)
#define BASE__TempHeap_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class TempHeap
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
TempHeap::~TempHeap()
{
    Destroy();
}


//------------------------------------------------------------------------------
inline void
TempHeap::Destroy()
{
    FreeAll(TRUE /* Complete */);
}


//------------------------------------------------------------------------------
inline BOOL       
TempHeap::IsCompletelyFree() const
{
    return (m_ppageCur == NULL) && (m_ppageLarge == NULL);
}


//------------------------------------------------------------------------------
inline void
TempHeap::Lock()
{
    m_cLocks++;
}


//------------------------------------------------------------------------------
inline void
TempHeap::Unlock()
{
    AssertMsg(m_cLocks > 0, "Must have an outstanding lock");
    if (--m_cLocks == 0) {
        FreeAll(FALSE);
    }
}


#endif // BASE__TempHeap_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\treenode.cpp ===
/***************************************************************************\
*
* File: TreeNode.cpp
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Base.h"
#include "TreeNode.h"

/***************************************************************************\
*****************************************************************************
*
* class TreeNode
*
*****************************************************************************
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\tempheap.h ===
/***************************************************************************\
*
* File: TempHelp.h
*
* Description:
* TempHelp.h defines a "lightweight heap", designed to continuously grow 
* until all memory is freed.  This is valuable as a temporary heap that can
* be used to "collect" data and processed slightly later.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__TempHeap_h__INCLUDED)
#define BASE__TempHeap_h__INCLUDED
#pragma once

class TempHeap
{
// Construction
public:
            TempHeap(int cbPageAlloc = 8000, int cbLargeThreshold = 512);
    inline  ~TempHeap();
    inline  void        Destroy();

// Operations
public:
            void *      Alloc(int cbAlloc);
    inline  BOOL        IsCompletelyFree() const;
    inline  void        Lock();
    inline  void        Unlock();

// Implementation
protected:
            void        FreeAll(BOOL fComplete = FALSE);

// Data
protected:
    struct Page
    {
        Page *      pNext;

        inline  BYTE *  GetData()
        {
            return (BYTE *) (((BYTE *) this) + sizeof(Page));
        }
    };

            long        m_cLocks;
            BYTE *      m_pbFree;
            Page *      m_ppageCur;
            Page *      m_ppageLarge;

            int         m_cbFree;           // Free space on current page
            int         m_cbPageAlloc;      // Allocation size of new pages
            int         m_cbLargeThreshold; // Threshold for allocating large pages
};

#include "TempHeap.inl"

#endif // BASE__TempHeap_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\treenode.inl ===
/***************************************************************************\
*
* File: TreeNode.inl
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__TreeNode_inl__INCLUDED)
#define BASE__TreeNode_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class TreeNode
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline 
TreeNodeT<T>::TreeNodeT()
{

}


//------------------------------------------------------------------------------
template <class T>
inline
TreeNodeT<T>::~TreeNodeT()
{

}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetTopSibling() const
{
    T * pTreeNode = const_cast<T *> (this);

    while (pTreeNode->m_ptnPrev != NULL) {
        pTreeNode = pTreeNode->m_ptnPrev;
    }

    return pTreeNode;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetBottomSibling() const
{
    TreeNodeT<T> * pTreeNode = const_cast<TreeNodeT<T> *> (this);

    while (pTreeNode->m_ptnNext != NULL) {
        pTreeNode = pTreeNode->m_ptnNext;
    }

    return (T *) pTreeNode;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetParent() const
{
    return (T *) m_ptnParent;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetPrev() const
{
    return (T *) m_ptnPrev;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetNext() const
{
    return (T *) m_ptnNext;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetTopChild() const
{
    return (T *) m_ptnChild;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetBottomChild() const
{
    if (m_ptnChild != NULL) {
        return GetTopChild()->GetBottomSibling();
    } else {
        return NULL;
    }
}


/***************************************************************************\
*
* TreeNodeT::DoLink
*
* DoLink chains _this_ node into the tree.  A sibling and a parent (may) be 
* given as reference, depending on the situation.  This node (the one 
* being linked) _must_ have already been unlinked previously.
*
\***************************************************************************/

template <class T>
void    
TreeNodeT<T>::DoLink(
    IN  T * ptnParent,              // New parent
    IN  T * ptnSibling,             // Node to link to this (unlinked) Node
    IN  ELinkType lt)               // Position of ptn relative to this
{
    // Check parameters
    AssertWritePtr(ptnParent);

    // Verify the TreeNode is unlinked
    Assert((m_ptnNext == NULL) && (m_ptnPrev == NULL) && (m_ptnParent == NULL));

    //
    // Link this TreeNode to the parent.
    //

    m_ptnParent                 = ptnParent;
    TreeNodeT<T> * ptnOldChild  = ptnParent->m_ptnChild;
    if (ptnOldChild == NULL) {
        //
        // Simple case, no siblings so just do it.
        //
        AssertMsg(ptnSibling == NULL, "Parent doesn't have any children");

        ptnParent->m_ptnChild   = this;
    } else {
        //
        // Uggh- complex case, so need to Link this TreeNode to its new siblings
        //

        switch (lt) {
        case ltBefore:
            AssertWritePtr(ptnSibling);
            m_ptnNext               = ptnSibling;
            m_ptnPrev               = ptnSibling->m_ptnPrev;
            ptnSibling->m_ptnPrev   = this;
            if (m_ptnPrev != NULL) {
                m_ptnPrev->m_ptnNext = this;
            }
            break;

        case ltBehind:
            AssertWritePtr(ptnSibling);
            m_ptnPrev               = ptnSibling;
            m_ptnNext               = ptnSibling->m_ptnNext;
            ptnSibling->m_ptnNext   = this;
            if (m_ptnNext != NULL) {
                m_ptnNext->m_ptnPrev = this;
            }
            break;

        case ltAny:
        case ltTop:
            ptnParent->m_ptnChild   = this;
            m_ptnNext               = ptnOldChild;
            if (ptnOldChild != NULL) {
                ptnOldChild->m_ptnPrev = this;
            }
            break;

        case ltBottom:
            ptnOldChild             = ptnOldChild->GetBottomSibling();
            ptnOldChild->m_ptnNext  = this;
            m_ptnPrev               = ptnOldChild;
            break;

        default:
            AssertMsg(0, "Unknown link type");
        }
    }
}


/***************************************************************************\
*
* TreeNode::DoUnlink
*
* DoUnlink() removes this TreeNode from the TreeNode tree.  The parents and 
* siblings of the TreeNode are properly modified.
*
\***************************************************************************/

template <class T>
void    
TreeNodeT<T>::DoUnlink()
{
    //
    // Unlink from the parent
    //

    if (m_ptnParent != NULL) {
        if (m_ptnParent->m_ptnChild == this) {
            m_ptnParent->m_ptnChild = m_ptnNext;
        }
    }

    //
    // Unlink from siblings
    //

    if (m_ptnNext != NULL) {
        m_ptnNext->m_ptnPrev = m_ptnPrev;
    }

    if (m_ptnPrev != NULL) {
        m_ptnPrev->m_ptnNext = m_ptnNext;
    }

    m_ptnParent   = NULL;
    m_ptnNext     = NULL;
    m_ptnPrev     = NULL;
}


#if DBG

template <class T>
inline BOOL
TreeNodeT<T>::DEBUG_IsChild(const TreeNodeT<T> * pChild) const
{
    TreeNodeT<T> * pCur = m_ptnChild;
    while (pCur != NULL) {
        if (pCur == pChild) {
            return TRUE;
        }
        pCur = pCur->m_ptnNext;
    }

    return FALSE;
}


/***************************************************************************\
*
* TreeNodeT<T>::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

template <class T>
void
TreeNodeT<T>::DEBUG_AssertValid() const
{
    if (m_ptnParent != NULL) {
        Assert(m_ptnParent->DEBUG_IsChild(this));
    }

    if (m_ptnNext != NULL) {
        Assert(m_ptnNext->m_ptnPrev == this);
    }

    if (m_ptnPrev != NULL) {
        Assert(m_ptnPrev->m_ptnNext == this);
    }

    if (m_ptnChild != NULL) {
        Assert(m_ptnChild->m_ptnParent == this);
    }
}

#endif // DBG

#endif // BASE__TreeNode_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\basegadget.cpp ===
/***************************************************************************\
*
* File: BaseGadget.cpp
*
* Description:
* BaseGadget.cpp implements the "EventGadget" object that provides event
* notifications to any derived objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "BaseGadget.h"


/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget
*
*****************************************************************************
\***************************************************************************/

#if DBG_CHECK_CALLBACKS
DuEventGadget::~DuEventGadget()
{
    GetContext()->m_cLiveObjects--;
}
#endif    


/***************************************************************************\
*
* DuEventGadget::AddMessageHandler
*
* AddMessageHandler() attaches the given Gadget to the set of 
* "message handlers" for this Gadget.
*
* NOTE: Every time 1 DuEventGadget becomes dependent on 2, 2 is added to 1's 
* list.  This means that there may be duplicates, but that is by design 
* since it lets us keep track of the dependency count.
*
* NOTE: This function is designed to be used with DuEventPool::AddHandler() 
* to maintain a list of "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::AddMessageHandler(
    IN  MSGID idEvent,              // Event to handle
    IN  DuEventGadget * pdgbHandler)   // DuEventGadget to handle event
{
    //
    // Dont allow hooking up during destruction.  The Gadgets will NOT receive
    // the proper destruction messages and will have problems properly shutting
    // down.
    //

    if (IsStartDelete() || pdgbHandler->IsStartDelete()) {
        return DU_E_STARTDESTROY;
    }


    //
    // When pdgbHandler can handle events from this DuEventGadget, it is added 
    // to the handler list.  This DuEventGadget must also be added into 
    // pdgbHandler->m_arDepend because pdgbHandler is dependent on this 
    // DuEventGadget.

    switch (m_epEvents.AddHandler(idEvent, pdgbHandler))
    {
    case DuEventPool::aExisting:
        //
        // Already existing, so don't need to do anything (and DON'T add to 
        // m_arDepend or will get out of sync).
        //

        return S_OK;
    
    case DuEventPool::aAdded:
        if (pdgbHandler->m_arDepend.Add(this) >= 0) {
            // Successfully added relationship
            return S_OK;
        } else {
            //
            // Unable to add dependency, so have to remove handler if it 
            // was just added.
            //

            HRESULT hr = m_epEvents.RemoveHandler(idEvent, pdgbHandler);
            VerifyHR(hr);
            return hr;
        }

    
    default:
    case DuEventPool::aFailed:
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuEventGadget::AddMessageHandler
*
* AddMessageHandler() attaches the given delegate to the set of 
* "message handlers" for this Gadget.
*
* NOTE: Every time 1 DuEventGadget becomes dependent on 2, 2 is added to 1's 
* list.  This means that there may be duplicates, but that is by design 
* since it lets us keep track of the dependency count.
*
* NOTE: This function is designed to be used with DuEventPool::AddHandler() 
* to maintain a list of "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::AddMessageHandler(
    IN  MSGID idEvent,              // Event to handle
    IN  DUser::EventDelegate ed)    // Delegate
{
    //
    // Dont allow hooking up during destruction.  The Gadgets will NOT receive
    // the proper destruction messages and will have problems properly shutting
    // down.
    //

    if (IsStartDelete()) {
        return DU_E_STARTDESTROY;
    }


    //
    // When (pvData, pfnHandler) can handle events from this DuEventGadget, it 
    // is added to the handler list.  This DuEventGadget must also be added into 
    // pdgbHandler->m_arDepend because pdgbHandler is dependent on this 
    // DuEventGadget.

    switch (m_epEvents.AddHandler(idEvent, ed))
    {
    case DuEventPool::aExisting:
    case DuEventPool::aAdded:
        return S_OK;
    
    default:
    case DuEventPool::aFailed:
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuEventGadget::RemoveMessageHandler
*
* RemoveMessageHandler() searches for and removes one instance of the given 
* Gadget from the set of "message handlers" for this Gadget.  Both the
* idEvent and pdgbHandler must match.
*
* NOTE: This function is designed to be used with DuEventPool::RemoveHandler()
* and CleanupMessageHandlers() to maintain a list of "message handlers" 
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::RemoveMessageHandler(
    IN  MSGID idEvent,              // Event being handled
    IN  DuEventGadget * pdgbHandler)   // DuEventGadget handling the event
{
    HRESULT hr = DU_E_GENERIC;
    
    hr = m_epEvents.RemoveHandler(idEvent, pdgbHandler);
    if (SUCCEEDED(hr)) {
        if (pdgbHandler->m_arDepend.Remove(this)) {
            hr = S_OK;
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuEventGadget::RemoveMessageHandler
*
* RemoveMessageHandler() searches for and removes one instance of the given 
* delegate from the set of "message handlers" for this Gadget.  Both the
* idEvent and pdgbHandler must match.
*
* NOTE: This function is designed to be used with DuEventPool::RemoveHandler()
* and CleanupMessageHandlers() to maintain a list of "message handlers" 
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::RemoveMessageHandler(
    IN  MSGID idEvent,              // Event being handled
    IN  DUser::EventDelegate ed)    // Delegate
{
    return m_epEvents.RemoveHandler(idEvent, ed);
}


/***************************************************************************\
*
* DuEventGadget::CleanupMessageHandlers
*
* CleanupMessageHandlers() goes through and detaches all "message handlers"
* attached to this Gadget.  This function is called as a part of Gadget
* destruction when a Gadget is removed from the tree and its 
* "message handlers" need to be notified of the Gadget's destruction.
*
* NOTE: This function does NOT callback and notify the Gadget that it is
* being removed.  This is VERY important because the object may no longer 
* be setup for callbacks.  Therefore, the object needs to be notified before
* this point.  This normally happens by the MessageHandler Gadgets watching 
* GM_DESTROY messages that are marked as GMF_EVENT.
*
\***************************************************************************/

void
DuEventGadget::CleanupMessageHandlers()
{
    //
    // Go through all DuEventGadgets that this DuEventGadget is dependent on and remove the
    // dependency.  If the same DuEventGadget appears in m_arDepend multiple times, it
    // be removed from the corresponding m_epEvents multiple times.
    //

    while (!m_arDepend.IsEmpty()) {
        int cItems = m_arDepend.GetSize();
        for (int idx = 0; idx < cItems; idx++) {
            DuEventGadget * pdgbCur = m_arDepend[idx];
            VerifyMsgHR(pdgbCur->m_epEvents.RemoveHandler(this), "Handler should exist");
        }
        m_arDepend.RemoveAll();
    }


    //
    // Go through and remove all event handlers of this DuEventGadget from m_epEvents.
    //

    m_epEvents.Cleanup(this);
}


/***************************************************************************\
*
* DuEventGadget::RemoveDependency
*
* RemoveDependency() removes a single "message handler" dependency from the
* set of "message handlers".  This function is called back from the 
* DuEventPool for each "message handler" during processing of 
* CleanupMessageHandlers().
*
\***************************************************************************/

void
DuEventGadget::RemoveDependency(
    IN  DuEventGadget * pdgbDependency)    // Dependency to be removed
{
    int idxDepend = m_arDepend.Find(pdgbDependency);
    if (idxDepend >= 0) {
        m_arDepend.RemoveAt(idxDepend);
    } else {
        AssertMsg(0, "Can not find dependency");
    }
}


//------------------------------------------------------------------------------
void
DuEventGadget::SetFilter(UINT nNewFilter, UINT nMask)
{
    m_cb.SetFilter(nNewFilter, nMask);
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiOnEvent(EventMsg * pmsg)
{
    return m_cb.xwCallGadgetProc(GetHandle(), pmsg);
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiGetFilter(EventGadget::GetFilterMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, m_pContext);

    pmsg->nFilter = (GetFilter() & GMFI_VALID);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiSetFilter(EventGadget::SetFilterMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nNewFilter, GMFI_VALID);
    CHECK_MODIFY();

    SetFilter(pmsg->nNewFilter, pmsg->nMask);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiAddHandlerG(EventGadget::AddHandlerGMsg * pmsg)
{
    DuEventGadget * pdgbHandler;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_EVENTGADGET(pmsg->pgbHandler, pdgbHandler);
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = AddMessageHandler(pmsg->nEventMsg, pdgbHandler);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiAddHandlerD(EventGadget::AddHandlerDMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    if (pmsg->ed.m_pfn == NULL) {
        PromptInvalid("Must specify valid delegate");
        goto ErrorExit;
    }
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = AddMessageHandler(pmsg->nEventMsg, pmsg->ed);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiRemoveHandlerG(EventGadget::RemoveHandlerGMsg * pmsg)
{
    DuEventGadget * pdgbHandler;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_EVENTGADGET(pmsg->pgbHandler, pdgbHandler);
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = RemoveMessageHandler(pmsg->nEventMsg, pdgbHandler);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiRemoveHandlerD(EventGadget::RemoveHandlerDMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    if (pmsg->ed.m_pfn == NULL) {
        PromptInvalid("Must specify valid delegate");
        goto ErrorExit;
    }
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = RemoveMessageHandler(pmsg->nEventMsg, pmsg->ed);

    END_API();
}


#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\basegadget.h ===
/***************************************************************************\
*
* File: BaseGadget.h
*
* Description:
* BaseGadget.h defines the fundamental Gadget object that all Gadgets are 
* derived from.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__BaseGadget_h__INCLUDED)
#define CORE__BaseGadget_h__INCLUDED
#pragma once

#include "Callback.h"
#include "EventPool.h"

class Context;

struct CREATE_INFO
{
    GADGETPROC  pfnProc;
    void *      pvData;
};

/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget defines the fundamental object that all Gadget 
* implementations derived from.
*
*****************************************************************************
\***************************************************************************/

class DuEventGadget : 
#if ENABLE_MSGTABLE_API
        public EventGadgetImpl<DuEventGadget, MsgObject>
#else
        public MsgObject
#endif
{
// Construction
public:
    inline  DuEventGadget();
#if DBG_CHECK_CALLBACKS
    virtual ~DuEventGadget();
#endif

// BaseObject
public:
    inline  HGADGET     GetHandle() const;
    virtual UINT        GetHandleMask() const { return hmMsgObject | hmEventGadget; }

// DuEventGadget Interface
public:
    inline  Context *   GetContext() const;

    inline  UINT        GetFilter() const;
    virtual void        SetFilter(UINT nNewFilter, UINT nMask);

    inline  const GPCB& GetCallback() const;
    inline  const DuEventPool& GetDuEventPool() const;

            HRESULT     AddMessageHandler(MSGID idEvent, DuEventGadget * pdgbHandler);
            HRESULT     AddMessageHandler(MSGID idEvent, DUser::EventDelegate ed);
            HRESULT     RemoveMessageHandler(MSGID idEvent, DuEventGadget * pdgbHandler);
            HRESULT     RemoveMessageHandler(MSGID idEvent, DUser::EventDelegate ed);

            void        RemoveDependency(DuEventGadget * pdgbDependency);

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(EventGadget);
    static HRESULT CALLBACK
    PromoteEventGadget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData) 
    {
        return MsgObject::PromoteInternal(pfnCS, hclCur, pgad, pciData);
    }

    devent  HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetFilter(EventGadget::GetFilterMsg * pmsg);
    dapi    HRESULT     ApiSetFilter(EventGadget::SetFilterMsg * pmsg);
    dapi    HRESULT     ApiAddHandlerG(EventGadget::AddHandlerGMsg * pmsg);
    dapi    HRESULT     ApiAddHandlerD(EventGadget::AddHandlerDMsg * pmsg);
    dapi    HRESULT     ApiRemoveHandlerG(EventGadget::RemoveHandlerGMsg * pmsg);
    dapi    HRESULT     ApiRemoveHandlerD(EventGadget::RemoveHandlerDMsg * pmsg);

#endif // ENABLE_MSGTABLE_API

// Internal Implementation
public:
            void        CleanupMessageHandlers();

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    // 
    // MsgObject:       4 DWORD's (v-table, lock count, pMT, rpgThis)
    //

            Context *   m_pContext;         // (1D) Object context

            GPCB        m_cb;               // (3D) Callback to outside-window "implementation"
                                            // (Debug + 1D)
            DuEventPool   m_epEvents;         // (1D) Event pool
            GArrayS<DuEventGadget *> m_arDepend;   // (1D) Dependencies of this DuVisual (may have duplicates)

    //
    // Current size:    10  DWORD's      (Debug = 11 DWORD's)
    //                  40 bytes         (Debug = 44 bytes)
    //
};

#include "BaseGadget.inl"

#endif // CORE__BaseGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\base\treenode.h ===
/***************************************************************************\
*
* File: TreeNode.h
*
* Description:
* TreeNode describes a low-level tree designed to be used to maintain a 
* window hierarchy.  Specific classes that use this tree should be derived
* from TreeNodeT to safely cast the pointers to its specific type.
*
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__TreeNode_h__INCLUDED)
#define BASE__TreeNode_h__INCLUDED
#pragma once

//------------------------------------------------------------------------------
class TreeNode
{
// Implementation
protected:
            enum ELinkType
            {
                ltAny       = 0,
                ltBefore    = 1,
                ltBehind    = 2,
                ltTop       = 3,
                ltBottom    = 4,
            };
};


//------------------------------------------------------------------------------
template <class T>
class TreeNodeT : public TreeNode
{
// Construction
public:
            TreeNodeT();
            ~TreeNodeT();

// Operations
public:
    inline  T *         GetParent() const;
    inline  T *         GetPrev() const;
    inline  T *         GetNext() const;
    inline  T *         GetTopSibling() const;
    inline  T *         GetBottomSibling() const;
    inline  T *         GetTopChild() const;
    inline  T *         GetBottomChild() const;

// Implementation
protected:
            void        DoLink(T * ptnParent, T * ptnSibling = NULL, ELinkType lt = ltAny);
            void        DoUnlink();

#if DBG
public:
    inline  BOOL        DEBUG_IsChild(const TreeNodeT<T> * pChild) const;
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    //

            TreeNodeT<T> *  m_ptnParent;
            TreeNodeT<T> *  m_ptnChild;
            TreeNodeT<T> *  m_ptnNext;
            TreeNodeT<T> *  m_ptnPrev;
};

#include "TreeNode.inl"

#endif // BASE__TreeNode_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\basegadget.inl ===
/***************************************************************************\
*
* File: BaseGadget.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__BaseGadget_inl__INCLUDED)
#define CORE__BaseGadget_inl__INCLUDED

#include "Context.h"

/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuEventGadget * 
CastBaseGadget(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmEventGadget)) {
        return (DuEventGadget *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuEventGadget * 
CastBaseGadget(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmEventGadget)) {
        return (const DuEventGadget *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuEventGadget * 
ValidateBaseGadget(HGADGET hgad)
{
    return CastBaseGadget(MsgObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline DuEventGadget * 
ValidateBaseGadget(EventGadget * pgb)
{
    return (DuEventGadget *) MsgObject::CastMsgObject(pgb);
}


//------------------------------------------------------------------------------
inline  
DuEventGadget::DuEventGadget()
{
    m_pContext  = ::GetContext();
    AssertMsg(m_pContext != NULL, "Context must already exist");

#if DBG_CHECK_CALLBACKS
    GetContext()->m_cLiveObjects++;
#endif    
}


//------------------------------------------------------------------------------
inline HGADGET     
DuEventGadget::GetHandle() const
{
    return (HGADGET) MsgObject::GetHandle();
}


//------------------------------------------------------------------------------
inline Context *   
DuEventGadget::GetContext() const
{
    AssertMsg(m_pContext != NULL, "Must have a valid Context");
    return m_pContext;
}


//------------------------------------------------------------------------------
inline UINT        
DuEventGadget::GetFilter() const
{
    return m_cb.GetFilter();
}


//------------------------------------------------------------------------------
inline const GPCB & 
DuEventGadget::GetCallback() const
{
    return m_cb;
}


//------------------------------------------------------------------------------
inline const DuEventPool &
DuEventGadget::GetDuEventPool() const
{
    return m_epEvents;
}


#endif // CORE__BaseGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\callback.cpp ===
/***************************************************************************\
*
* File: Callback.cpp
*
* Description:
* Callback.cpp wraps the standard DirectUser DuVisual callbacks into
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Callback.h"

#include "TreeGadget.h"
#include "MessageGadget.h"

/***************************************************************************\
*
* SimpleEventProc (Internal)
*
* SimpleEventProc() provides a stub GadgetProc used when pfnProc is NULL.
* This allows the core to always assume a non-NULL proc and not have to
* perform a comparison.
*
\***************************************************************************/

HRESULT CALLBACK
SimpleEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
	UNREFERENCED_PARAMETER(hgadCur);
	UNREFERENCED_PARAMETER(pvCur);
	UNREFERENCED_PARAMETER(pmsg);

	return DU_S_NOTHANDLED;
}


/***************************************************************************\
*****************************************************************************
*
* class GPCB
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GPCB::Create
*
* Create() initializes a newly constructed GPCB.
*
* NOTE: This function has a different prototype in DEBUG that takes an extra
* HGADGET parameter that is used to Verify against the passed HGADGET for
* the various Fire() functions.
*
\***************************************************************************/

void
GPCB::Create(
    IN  GADGETPROC pfnProc,         // Application defined callback
    IN  void * pvData               // Application defined data
#if DBG
    ,IN HGADGET hgadCheck           // Gadget to Verify proper hookup
#endif // DBG
    )
{
    Assert(hgadCheck != NULL);

	if (pfnProc == NULL) {
        //
        // Don't want to check for NULL's, so just give an "empty" GP if one
        // was not specified.
        //

		pfnProc     = SimpleEventProc;
		pvData      = NULL;
        m_nFilter   = 0;            // Don't need any messages
	}

    m_pfnProc   = pfnProc;
    m_pvData    = pvData;
#if DBG
    m_hgadCheck = hgadCheck;
#endif // DBG
}



/***************************************************************************\
*
* GPCB::Destroy
*
* Destroy() informs the GPCB that the last message has been fired and that
* no more callbacks should be made.  If any slip through, need to send them
* to SimpleEventProc so that they get "eaten".
*
\***************************************************************************/

void
GPCB::Destroy()
{
	m_pfnProc   = SimpleEventProc;
	m_pvData    = NULL;
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwCallOnEvent(const DuEventGadget * pg, EventMsg * pmsg)
{
#if ENABLE_MSGTABLE_API
    return Cast<EventGadget>(pg)->OnEvent(pmsg);
#else
    return pg->GetCallback().xwCallGadgetProc(pg->GetHandle(), pmsg);
#endif
}


/***************************************************************************\
*
* GPCB::xwInvokeRoute
*
* xwInvokeRoute routes a message from the top of the DuVisual sub-tree to 
* the specified gadget.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeRoute(
    IN  DuVisual * const * rgpgadCur, // DuVisual path to send messages to
    IN  int cItems,                     // Number of items in path
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    AssertMsg(GET_EVENT_DEST(pmsg) == GMF_ROUTED, "Must already mark as routed");
    AssertMsg(cItems >= 1, "Must have at least one item");

    BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
    HRESULT hrKeep  = DU_S_NOTHANDLED;

    for (int idx = 0; idx < cItems; idx++) {
        const DuVisual * pgadCur = rgpgadCur[idx];
        HRESULT hrT = xwCallOnEvent(pgadCur, pmsg);
        switch (hrT)
        {
        default:
            if (FAILED(hrT)) {
                return hrT;
            }
            // Else, fall-through
            
        case DU_S_NOTHANDLED:
            break;

        case DU_S_COMPLETE:
            if (fSendAll) {
                hrKeep = DU_S_COMPLETE;
            } else {
                return DU_S_COMPLETE;
            }
            break;

        case DU_S_PARTIAL:
            if (hrKeep == DU_S_NOTHANDLED) {
                hrKeep = DU_S_PARTIAL;
            }
            break;
        }
    }

    return hrKeep;
}


/***************************************************************************\
*
* GPCB::xwInvokeBubble
*
* xwInvokeBubble() walks up the DuVisual tree sending a message to each item.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeBubble(
    IN  DuVisual * const * rgpgadCur, // DuVisual path to send messages to
    IN  int cItems,                     // Number of items in path
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    AssertMsg(GET_EVENT_DEST(pmsg) == GMF_BUBBLED, "Must already mark as bubbled");
    AssertMsg(cItems >= 1, "Must have at least one item");

    BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
    HRESULT hrKeep  = DU_S_NOTHANDLED;

    for (int idx = cItems-1; idx >= 0; idx--) {
        const DuVisual * pgadCur = rgpgadCur[idx];
        HRESULT hrT = xwCallOnEvent(pgadCur, pmsg);
        switch (hrT)
        {
        default:
            if (FAILED(hrT)) {
                return hrT;
            }
            // Else, fall-through
            
        case DU_S_NOTHANDLED:
            break;

        case DU_S_COMPLETE:
            if (fSendAll) {
                hrKeep = DU_S_COMPLETE;
            } else {
                return DU_S_COMPLETE;
            }
            break;

        case DU_S_PARTIAL:
            if (hrKeep == DU_S_NOTHANDLED) {
                hrKeep = DU_S_PARTIAL;
            }
            break;
        }
    }

    return hrKeep;
}


//------------------------------------------------------------------------------
HRESULT 
xwInvoke(DUser::EventDelegate ed, EventMsg * pmsg)
{
    HRESULT hr;

    //
    // Need to guard around the callback to prevent DirectUser from becoming
    // completely toast if something goes wrong.
    //

    __try 
    {
        hr = ed.Invoke(pmsg);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

    return hr;
}


/***************************************************************************\
*
* GPCB::xwInvokeDirect
*
* xwInvokeDirect() implements the core message callback for direct (non-full)
* messages.  This includes the DuVisual itself and any MessageHandlers
* attached to the Gadget.
*
* NOTE: This function directly accesses data in DuEventPool to help
* performance and minimize the implementation exposure of DuEventPool to only
* this function.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeDirect(
    IN  const DuEventGadget * pgadMsg,   // DuVisual to send message to
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    //
    // "Prepare" the message and send to the Gadget.
    //

    pmsg->hgadMsg   = pgadMsg->GetHandle();
    pmsg->nMsgFlags = GMF_DIRECT;

    HRESULT hrKeep = xwCallOnEvent(pgadMsg, pmsg);
    if (FAILED(hrKeep)) {
        return hrKeep;
    }


    //
    // Send to all of the event handlers.  This is a little different than
    // normal iteractions.  We DON'T want to immediately return if we get
    // GPR_COMPLETE.  Instead, just mark it but continue to iterate through
    // and call ALL event handlers.
    //

    const DuEventPool & pool = pgadMsg->GetDuEventPool();

    if (!pool.IsEmpty()) {
        int cItems      = pool.GetCount();

        BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
        BOOL fReadOnly  = TestFlag(nInvokeFlags, ifReadOnly);

        //
        // To send the event to all MessageHandlers, need to:
        // - Copy and lock all MessageHandlers
        // - Fire the message
        // - Unlock all MessageHandlers
        //

        int idx;
        int cbAlloc = cItems * sizeof(DuEventPool::EventData);
        DuEventPool::EventData * rgDataCopy = (DuEventPool::EventData *) _alloca(cbAlloc);
        CopyMemory(rgDataCopy, pool.GetData(), cbAlloc);

        if (!fReadOnly) {
            for (idx = 0; idx < cItems; idx++) {
                if (rgDataCopy[idx].fGadget) {
                    rgDataCopy[idx].pgbData->Lock();
                }
            }
        }


        //
        // Iterate through our copy, firing on each of the MessageHandlers.
        // For Delegates, only fire if the MSGID's are a match
        // For Gadgets, fire if MSGID's are a match, or if signaled to send to all.
        //

        pmsg->nMsgFlags = GMF_EVENT;

        HRESULT hrT;
        for (idx = 0; idx < cItems; idx++) {
            int nID = rgDataCopy[idx].id;
            DuEventPool::EventData & data = rgDataCopy[idx];
            if ((nID == pmsg->nMsg) || 
                    (data.fGadget && (fSendAll || (nID == 0)))) {

                if (data.fGadget) {
                    hrT = xwCallOnEvent(data.pgbData, pmsg);
                } else {
                    hrT = xwInvoke(data.ed, pmsg);
                }
                switch (hrT) {
                default:
                case DU_S_NOTHANDLED:
                    break;

                case DU_S_COMPLETE:
                    hrKeep = DU_S_COMPLETE;

                case DU_S_PARTIAL:
                    if (hrKeep == DU_S_NOTHANDLED) {
                        hrKeep = DU_S_PARTIAL;
                    }
                    break;
                }
            }
        }


        //
        // Done firing, so cleanup our copy.
        //

        if (!fReadOnly) {
            for (idx = 0; idx < cItems; idx++) {
                if (rgDataCopy[idx].fGadget) {
                    rgDataCopy[idx].pgbData->xwUnlock();
                }
            }
        }
    }

    return hrKeep;
}


/***************************************************************************\
*
* GPCB::xwInvokeFull
*
* xwInvokeFull() implements the core message callback for "full" messages.
* This includes routing, direct, message handlers, and bubbling.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeFull(
    IN  const DuVisual * pgadMsg,   // DuVisual message is about
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    //
    // "Prepare" the message
    //

    pmsg->hgadMsg   = pgadMsg->GetHandle();
    pmsg->nMsgFlags = 0;


    //
    // Build the path that needs to be traversed when routing and bubbling.
    // We need to make a copy (and Lock()) all of these Gadgets so that they
    // are valid during the entire messaging process.
    //

    int cItems = 0;
    DuVisual * pgadCur = pgadMsg->GetParent();
    while (pgadCur != NULL) {
        pgadCur = pgadCur->GetParent();
        cItems++;
    }

    DuVisual ** rgpgadPath = NULL;
    if (cItems > 0) {
        BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
        BOOL fReadOnly  = TestFlag(nInvokeFlags, ifReadOnly);
        HRESULT hrKeep  = DU_S_NOTHANDLED;


        //
        // Store the path in an array with the Root in the first slot.
        //

        rgpgadPath = (DuVisual **) alloca(cItems * sizeof(DuVisual *));

        int idx = cItems;
        pgadCur = pgadMsg->GetParent();
        if (fReadOnly) {
            while (pgadCur != NULL) {
                rgpgadPath[--idx] = pgadCur;
                pgadCur = pgadCur->GetParent();
            }
        } else {
            while (pgadCur != NULL) {
                rgpgadPath[--idx] = pgadCur;
                pgadCur->Lock();
                pgadCur = pgadCur->GetParent();
            }
        }
        AssertMsg(idx == 0, "Should add every item");
        AssertMsg(rgpgadPath[0]->IsRoot(), "First item must be a Root");


        //
        // Route
        //

        pmsg->nMsgFlags = GMF_ROUTED;
        hrKeep = xwInvokeRoute(rgpgadPath, cItems, pmsg, nInvokeFlags);
        if ((hrKeep == DU_S_COMPLETE) && (!fSendAll)) {
            goto Finished;
        }


        //
        // Direct and MessageHandlers
        //

        hrKeep = xwInvokeDirect(pgadMsg, pmsg, nInvokeFlags);
        if (hrKeep == DU_S_COMPLETE) {
            goto Finished;
        }


        //
        // Bubble
        //

        pmsg->nMsgFlags = GMF_BUBBLED;
        hrKeep = xwInvokeBubble(rgpgadPath, cItems, pmsg, nInvokeFlags);

Finished:
        //
        // Finished processing, so walk through the array from the bottom of the
        // tree, Unlock()'ing each Gadget.
        //

        if (!fReadOnly) {
            idx = cItems;
            while (--idx >= 0) {
                rgpgadPath[idx]->xwUnlock();
            }
        }

        return hrKeep;
    } else {
        //
        // Direct and MessageHandlers
        //

        return xwInvokeDirect(pgadMsg, pmsg, nInvokeFlags);
    }
}


#if DBG

//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuEventGadget * pgad, BOOL fDestructionMsg) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");

    const DuVisual * pgadTree = CastVisual(pgad);
    if (pgadTree != NULL) {
        AssertMsg(fDestructionMsg || (!pgadTree->IsStartDelete()), 
                "Can not send messages in destruction");
    }
}


//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuVisual * pgad, BOOL fDestructionMsg) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");
    AssertMsg(fDestructionMsg || (!pgad->IsStartDelete()), 
            "Can not send messages in destruction");
}


//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuListener * pgad) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\callback.h ===
/***************************************************************************\
*
* File: Callback.h
*
* Description:
* Callback.h wraps the standard DirectUser DuVisual callbacks into 
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Callback_h__INCLUDED)
#define CORE__Callback_h__INCLUDED
#pragma once

// Forward declarations
class DuEventGadget;
class DuVisual;
class DuListener;
class DuEventPool;

//
// NOTE:
// There are different types of callback functions that are a natural extension
// of 'xxx' functions found in NT-USER:
//
// - xr: Read-only:  Only "read-only" API's are supported during this callback
// - xw: Read/Write: Any API is supported during this callback
// - xd: Delayed:    The callback is queued and will be called before returning
//                   from the API; any API is supported during this callback.
//
// TODO: Need to mark each of these functions with the appropriate signature
//       and propagate through the code.
//


//
// GPCB holds a GadgetProc Calback and is used to communicate with the 
// outside world.
//

class GPCB
{
// Construction
public:
    inline  GPCB();
#if DBG
            void        Create(GADGETPROC pfnProc, void * pvData, HGADGET hgadCheck);
#else // DBG
            void        Create(GADGETPROC pfnProc, void * pvData);
#endif // DBG
            void        Destroy();

// Operations
public:
    inline  UINT        GetFilter() const;
    inline  void        SetFilter(UINT nNewFilter, UINT nMask);

    inline  void        xwFireDestroy(const DuEventGadget * pgad, UINT nCode) const;

    inline  void        xrFirePaint(const DuVisual * pgad, HDC hdc, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const;
    inline  void        xrFirePaint(const DuVisual * pgad, Gdiplus::Graphics * pgpgr, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const;
    inline  void        xrFirePaintCache(const DuVisual * pgad, HDC hdcDraw, const RECT * prcGadgetPxl, 
                                BYTE * pbAlphaLevel, BYTE * pbAlphaFormat) const;

    inline  void        xrFireQueryHitTest(const DuVisual * pgad, POINT ptClientPxl, UINT * pnResult) const;
    inline  BOOL        xrFireQueryPadding(const DuVisual * pgad, RECT * prcPadding) const;

#if DBG_STORE_NAMES
    inline  BOOL        xrFireQueryName(const DuVisual * pgad, WCHAR ** ppszName, WCHAR ** ppszType) const;
#endif // DBG_STORE_NAMES

    inline  void        xdFireMouseMessage(const DuVisual * pgad, GMSG_MOUSE * pmsg) const;
    inline  void        xdFireKeyboardMessage(const DuVisual * pgad, GMSG_KEYBOARD * pmsg) const;
    inline  void        xdFireChangeState(const DuVisual * pgad, UINT nCode, HGADGET hgadLost, HGADGET hgadSet, UINT nCmd) const;
    inline  void        xdFireChangeRect(const DuVisual * pgad, const RECT * prc, UINT nFlags) const;
    inline  void        xdFireChangeStyle(const DuVisual * pgad, UINT nOldStyle, UINT nNewStyle) const;
    inline  void        xdFireSyncAdaptor(const DuVisual * pgad, UINT nCode) const;
    inline  void        xdFireDelayedMessage(const DuVisual * pgad, GMSG * pmsg, UINT nFlags) const;
    inline  void        xdFireDelayedMessage(const DuListener * pgad, GMSG * pmsg) const;

            enum InvokeFlags {
                ifSendAll       = 0x00000001,   // Message must be sent to all Gadgets
                ifReadOnly      = 0x00000002,   // Read-only callback
            };
            
            HRESULT     xwInvokeDirect(const DuEventGadget * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
			HRESULT     xwInvokeFull(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;

    inline  HRESULT     xwCallGadgetProc(HGADGET hgadCur, EventMsg * pmsg) const;

// Implementation
protected:

    inline  HRESULT     xwInvokeDirect(const DuListener * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
    inline  HRESULT     xwInvokeDirect(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
            HRESULT     xwInvokeRoute(DuVisual * const * rgpgadCur, int cItems, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
            HRESULT     xwInvokeBubble(DuVisual * const * rgpgadCur, int cItems, EventMsg * pmsg, UINT nInvokeFlags = 0) const;

    static  HRESULT     xwCallOnEvent(const DuEventGadget * pg, EventMsg * pmsg);

#if DBG
            void        DEBUG_CheckHandle(const DuEventGadget * pgad, BOOL fDestructionMsg = FALSE) const;
            void        DEBUG_CheckHandle(const DuVisual * pgad, BOOL fDestructionMsg = FALSE) const;
            void        DEBUG_CheckHandle(const DuListener * pgad) const;
#endif // DBG

// Data
protected:
            GADGETPROC  m_pfnProc;
            void *      m_pvData;
            UINT        m_nFilter;

#if DBG
            HGADGET     m_hgadCheck;    // DEBUGONLY: Check gadget
#endif // DBG
};

#include "Callback.inl"

#endif // CORE__Callback_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\context.cpp ===
/***************************************************************************\
*
* File: Context.cpp
*
* Description:
* This file implements the SubContext used by the DirectUser/Core project to
* maintain Context-specific data.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Context.h"

#include "ParkContainer.h"

#if ENABLE_MPH

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL CALLBACK 
MphProcessMessage(
    OUT MSG * pmsg,
    IN  HWND hwnd,
    IN  UINT wMsgFilterMin, 
    IN  UINT wMsgFilterMax,
    IN  UINT flags,
    IN  BOOL fGetMessage)
{
#if DBG_CHECK_CALLBACKS
    if (!IsInitThread()) {
        AlwaysPromptInvalid("DirectUser has been uninitialized before calling into MPH");
    }
#endif
    
    CoreSC * pSC = GetCoreSC();
    return pSC->xwProcessNL(pmsg, hwnd,
            wMsgFilterMin, wMsgFilterMax, flags, fGetMessage ? CoreSC::smGetMsg : 0);
}


//------------------------------------------------------------------------------
BOOL CALLBACK 
MphWaitMessageEx(
    IN  UINT fsWakeMask,
    IN  DWORD dwTimeOut)
{
#if DBG_CHECK_CALLBACKS
    if (!IsInitThread()) {
        AlwaysPromptInvalid("DirectUser has been uninitialized before calling into MPH");
    }
#endif

    
    //
    // Need to convert time-out value from WaitMessageEx() where 0 means
    // infinite delay to WaitForSingleObject() where 0 means no delay.  We do 
    // this here because this behavior is introduced by DirectUser since it uses
    // MsgWaitForMultipleObjects() to implement the MPH'd WaitMessageEx().
    //
        
    CoreSC * pSC = GetCoreSC();
    pSC->WaitMessage(fsWakeMask, dwTimeOut != 0 ? dwTimeOut : INFINITE);
    return TRUE;
}

#endif // ENABLE_MPH


/***************************************************************************\
*****************************************************************************
*
* class CoreSC
*
*****************************************************************************
\***************************************************************************/

IMPLEMENT_SUBCONTEXT(Context::slCore, CoreSC);

struct CoreData
{
    DuParkContainer conPark;
};

/***************************************************************************\
*
* CoreSC::~CoreSC
*
* ~CoreSC() cleans up resources associated with this SubContext.
*
\***************************************************************************/

CoreSC::~CoreSC()
{
#if DBG_CHECK_CALLBACKS
    if (m_fProcessing) {
        PromptInvalid("Cannot DeleteHandle(Context) while processing a DUser message");
    }
#endif
    
    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    AssertMsg(m_msgqSend.IsEmpty(), "All queues should be empty");
    AssertMsg(m_msgqPost.IsEmpty(), "All queues should be empty");

    if (m_hevQData != NULL) {
        CloseHandle(m_hevQData);
    }

    if (m_hevSendDone != NULL) {
        CloseHandle(m_hevSendDone);
    }

    ClientDelete(VisualPool, ppoolDuVisualCache);
}


/***************************************************************************\
*
* CoreSC::Create
*
* Create() is called by the ResourceManager to initialize this new SubContext
* when a new Context is being created.
*
\***************************************************************************/

HRESULT
CoreSC::Create(INITGADGET * pInit)
{
    HRESULT hr;

    //
    // Initialize the messaging subsystem for this CoreSC
    //

    switch (pInit->nMsgMode)
    {
    case IGMM_COMPATIBLE:
        //
        // Need to use timers and hooks to get into the messaging subsystem.
        //

        AssertMsg(0, "TODO: Implement IGMM_COMPATIBLE");
        return E_NOTIMPL;

#if ENABLE_MPH
    case IGMM_STANDARD:
#endif
    case IGMM_ADVANCED:
        break;

    default:
        AssertMsg(0, "Unsupported messaging subsystem mode");
        return E_INVALIDARG;
    }

    m_nMsgMode = pInit->nMsgMode;
    m_hevQData = CreateEvent(NULL, FALSE /* Automatic */, FALSE, NULL);
    if (m_hevQData == NULL) {
        return DU_E_OUTOFKERNELRESOURCES;
    }


    //
    // Determine the event to be signaled when the message has been 
    // processed.  Each thread has its own SendDone event since multiple 
    // threads in the same CoreSC may all send messages and would need to
    // notified independently that each of their messages has been 
    // processed.
    //
    // This event is cached so that it only needs to be created once per 
    // thread.  It is independent of the CoreSC so it doesn't get destroyed
    // when the CoreSC does.
    //
    // The event is an AUTOMATIC event so that that it will automatically 
    // reset after being signaled.  Since the event is only created one, 
    // this function ASSUMES that the event is left in an reset state.  This
    // is normally true since the function blocks on WaitForSingleObject().
    // If there are any other exit paths, they need to ensure that the event
    // is left in a reset state.
    //

    m_hevSendDone = CreateEvent(NULL, FALSE /* Automatic */, FALSE, NULL);
    if (m_hevSendDone == NULL) {
        return DU_E_OUTOFKERNELRESOURCES;
    }


    //
    // Initialize "global" CoreSC-specific data.  It is important to allocate 
    // these on the Process heap because the Context may be destroyed on a 
    // different thread during destruction.
    //

    m_pData = ProcessNew(CoreData);
    if (m_pData == NULL) {
        return E_OUTOFMEMORY;
    }

    ppoolDuVisualCache = ClientNew(VisualPool);
    if (ppoolDuVisualCache == NULL) {
        return E_OUTOFMEMORY;
    }

    pconPark = &m_pData->conPark;
    hr = m_pData->conPark.Create();
    if (FAILED(hr)) {
        return hr;
    }
    
    return S_OK;
}


/***************************************************************************\
*
* CoreSC::xwPreDestroyNL
*
* xwPreDestroyNL() gives this SubContext an opportunity to perform any cleanup 
* while the Context is still valid.  Any operations that involve callbacks
* MUST be done at this time.
*
\***************************************************************************/

void        
CoreSC::xwPreDestroyNL()
{
    //
    // There may be remaining messages in the queues, so we need to empty them
    // now.  This can happen if the more messages are generated after the
    // message pump was last processed.
    //

    do
    {
        //
        // When we callback to allow the SubContext's to destroy, we need to
        // grab a ContextLock so that we can defer messages.  When we leave 
        // this scope, all of these messages will be triggered.  This needs
        // to occur BEFORE the Context continues getting blown away.
        //

        {
            ContextLock cl;
            if (!cl.LockNL(ContextLock::edDefer, m_pParent)) {
                //
                // If the Context becomes orphaned, we need to exit this loop
                // since DllMain(DLL_PROCESS_DETACH) has been called and 
                // DirectUser has been unloaded.
                //
                
                break;
            }


            //
            // Pre-destroying the Parking Gadget may have generated messages, so
            // we want to handle these now.  If we don't objects may continue to 
            // live until the Context is fully destroyed.
            //

            InterlockedExchange((long *) &m_fQData, FALSE);
            AssertMsg(!m_fProcessing, "Another thread must NOT be processing during shutdown");
            xwProcessMsgQNL();


            //
            // Notify the Parking Gadget that the Context is getting wiped.  It 
            // needs to destroy any remaining Gadgets before the Context gets 
            // shutdown so that the Gadgets can use a still valid Context during 
            // their destruction.
            //

            if (pconPark != NULL) {
                pconPark->xwPreDestroy();
            }
        }

        //
        // The ContextLock is now destroyed, causing any delayed messages to
        // be fired.
        //
    } while (m_fQData);

    AssertMsg((pconPark == NULL) || (!pconPark->GetRoot()->HasChildren()), 
            "Parking Gadget should now be empty");
    AssertMsg(m_msgqSend.IsEmpty() && m_msgqPost.IsEmpty(),
            "Queues must now be empty");

#if DBG
    m_msgqSend.DEBUG_MarkStartDestroy();
    m_msgqPost.DEBUG_MarkStartDestroy();
#endif // DBG


    //
    // Everyone has had a chance to be destroyed, so destroy the dynamic data.
    //

    if (m_pData != NULL) {
        ProcessDelete(CoreData, m_pData);
    }
}


/***************************************************************************\
*
* CoreSC::CanProcessUserMsg
*
* CanProcessUserMsg() determines if DirectUser can "hook into" the 
* processing of the USER message and provide extra functionality.
*
\***************************************************************************/

UINT
CoreSC::CanProcessUserMsg(HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
{
    //
    // Considerations:
    //
    // We can only process differ from NTUSER's xxxInternalGetMessage() if the
    // application specifies PM_REMOVE.  If they specify PM_NOREMOVE, they are
    // just looking at the message and it can be very dangerous to process any
    // DirectUser messages at that time.
    //
    // We can also only process messages if there are no filters applied.  If
    // any filters are applied, we may massively change the DirectUser object 
    // state in the application by delivering messages at this time.
    //
    // The same is true for idle-time processing.
    //
    //
    // Requirements:
    // - mvpIdle:   No filter
    // - mvpDUser:  No filter, PM_REMOVE
    //
    
    UINT nValid = 0;

    if ((hWnd == NULL) && (wMsgFilterMin == 0) && (wMsgFilterMax == 0)) {
        SetFlag(nValid, mvpIdle);

        if (TestFlag(wRemoveMsg, PM_REMOVE)) {
            SetFlag(nValid, mvpDUser);
        }
    }

    return nValid;            
}


/***************************************************************************\
*
* CoreSC::WaitMessage
*
* WaitMessage() blocks a thread until a new DirectUser or USER message 
* becomes available.
*
\***************************************************************************/

void
CoreSC::WaitMessage(
    IN  UINT fsWakeMask,                // USER queue wake mask
    IN  DWORD dwTimeOutMax)             // Maximum timeout in millisec's or INFINITE
{
    DWORD dwStartTick, dwRemainTick;

    dwRemainTick = dwTimeOutMax;
    dwStartTick = 0;
    if (dwRemainTick != INFINITE) {
        dwStartTick = GetTickCount();
    }

    while (TRUE) {
        //
        // Check for existing DirectUser messages.
        //

        if (m_fQData) {
            return;
        }


        //
        // We DON'T check for existing USER messages, since the ::WaitMessage()
        // API function will only return when NEW USER messages have been added
        // to the queue.
        //
        // This also means that we will NOT use MWMO_INPUTAVAILABLE when we call
        // Wait().
        //


        //
        // No available messages, so perform idle-time processing and then 
        // wait for the next available message.  We need to perform idle-time
        // processing here, since an application may just call PeekMessage()
        // and WaitMessage(), and would otherwise never perform idle-time
        // processing.
        //

        DWORD dwNewTickOut = m_pParent->xwOnIdleNL();
        if (dwNewTickOut > dwRemainTick) {
            dwNewTickOut = dwRemainTick;
        }

        switch (Wait(fsWakeMask, dwNewTickOut, FALSE, TRUE /* process DUser messages */))
        {
        case wGMsgReady:
        case wUserMsgReady:
            return;

        case wTimeOut:
            //
            // There were no messages to process, so loop again.
            //

            break;

        case wError:
            // Got an unexpected return value, so just continue to wait
            AssertMsg(0, "Unexpected return from CoreSC::Wait()");
            return;
        }


        //
        // Compute how much time is left in the wait period.
        //

        if (dwRemainTick != INFINITE) {
            DWORD dwCurTick = GetTickCount();
            DWORD dwElapsed = dwCurTick - dwStartTick;
            if (dwElapsed < dwRemainTick) {
                dwRemainTick -= dwElapsed;
            } else {
                dwRemainTick = 0;
            }
        }
    }
}


/***************************************************************************\
*
* CoreSC::Wait
*
* Wait() blocks the current thread until new information has been added to
* either the USER queue or a DirectUser queue.  Because 
* WaitForMultipleObjects takes a non-trivial amount of time to potentially
* setup, even if one of the HANDLE's is signaled, we want to avoid calling
* this function while we have any more work to do.
*
\***************************************************************************/

CoreSC::EWait
CoreSC::Wait(
    IN  UINT fsWakeMask,                // USER queue wake mask
    IN  DWORD dwTimeOut,                // Timeout in millisec's or INFINITE
    IN  BOOL fAllowInputAvailable,      // Win2000,98: Use MWMO_INPUTAVAILABLE
    IN  BOOL fProcessDUser)             // Allow processing DUser events
{
    HANDLE  rgh[1];
    int cObj = 0;
    int result;
    DWORD dwFlags;

    //
    // No events were already ready, so need to wait.  This may take a while.
    // If we are running on Win98 or Win2000, specify the MWMO_INPUTAVAILABLE
    // flag to signal that we didn't (necessarily) process all of the User
    // messages.
    //
    // Win2000 USER is pretty smart.  If it sees that any messages are 
    // available, it won't call WaitForMultipleObjects and will instead directly
    // return.  
    //
    // The advantage of using MWMO_INPUTAVAILABLE if it is available is that
    // we don't need to call an extra PeekMessage() when processing a queue of
    // messages.
    //

    if (fProcessDUser) {
        rgh[0] = m_hevQData;
        cObj++;
    }
    dwFlags = 0;                    // Only wait for a single handle
    if (fAllowInputAvailable) {
        dwFlags |= MWMO_INPUTAVAILABLE;
    }


    //
    // If we are waiting up to 1 ms, don't really wait.  It is not worth the
    // cost of going to sleep.
    //

    if (dwTimeOut <= 1) {
        dwTimeOut = 0;
    }

    AssertMsg(cObj <= _countof(rgh), "Ensure don't overflow handle array");
    result = MsgWaitForMultipleObjectsEx(cObj, rgh, dwTimeOut, fsWakeMask, dwFlags);

    if (result == WAIT_OBJECT_0 + cObj) {
        return wUserMsgReady;
    } else if (result == WAIT_OBJECT_0) {
        return wGMsgReady;
    } else if ((result >= WAIT_ABANDONED_0) && (result < WAIT_ABANDONED_0 + cObj)) {
        return wOther;
    } else if (result == WAIT_TIMEOUT) {
        return wTimeOut;
    }
    
    return wError;
}


/***************************************************************************\
*
* CoreSC::xwProcessNL
*
* xwProcessNL() processes all messages in the queues, optionally blocking
* until a USER message becomes available to be processed.  
*
* This function is provides the replacement for GetMessage() and 
* PeekMessage().
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

BOOL
CoreSC::xwProcessNL(
    IN  LPMSG lpMsg,                    // Message information
    IN  HWND hWnd,                      // Filter window
    IN  UINT wMsgFilterMin,             // Filter first message
    IN  UINT wMsgFilterMax,             // Filter last message
    IN  UINT wRemoveMsg,                // Remove message (Peek only)
    IN  UINT nMsgFlag)                  // Messaging flags
{
    AssertMsg((TestFlag(nMsgFlag, smGetMsg) && (wRemoveMsg == PM_REMOVE)) ||
            (!TestFlag(nMsgFlag, smGetMsg)), "If GetMsg, must specify PM_REMOVE");


    UINT nProcessValid = CanProcessUserMsg(hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);


    //
    // We may need to directly jump to PeekMessage() instead of Wait()'ing
    // in a couple of situations:
    // - If we are running on a system that doesn't support MWMO_INPUTAVAILABLE
    // - If we are calling the !smGetMsg version (PeekMessageEx)
    //

    BOOL fInputAvailable = SupportQInputAvailable();
    BOOL fJumpPeek = (!fInputAvailable) || (!TestFlag(nMsgFlag, smGetMsg));
    DWORD dwTimeOut;

    while (TRUE) {
#if DBG_CHECK_CALLBACKS
        if (!IsInitThread()) {
            AlwaysPromptInvalid("DirectUser has been uninitialized between messages");
        }
#endif
        
        dwTimeOut = INFINITE;

        //
        // When coming to wait on an event, first check if there are any events 
        // already ready.  If so, just jump and process them directly so that we
        // don't even need to wait.
        //
        // Check for DUser messages before we check for USER messages because
        // we want to process them faster and checking for USER messages is
        // a large (unnecessary) speed-bump.
        //

        if (TestFlag(nProcessValid, mvpDUser) && InterlockedExchange((long *) &m_fQData, FALSE)) {
            goto ProcessMsgs;
        }

        //
        // If running on a system that doesn't support MWMO_INPUTAVAILABLE, we need
        // to finish eating the USER messages since MsgWaitForMultipleObjectsEx().
        // is expecting that behavior.
        //

        if (fJumpPeek) {
            goto ProcessPeekMessage;
        }


        //
        // Before waiting, but after performing any normal priority requests,
        // do any idle-time processing.
        //

        if (TestFlag(nProcessValid, mvpIdle)) {
            dwTimeOut = m_pParent->xwOnIdleNL();
        }


        //
        // We have had an opportunity to process all of the messages and are now
        // about to wait.  If we are not calling smGetMsg, just return 
        // immediately.
        //
      
        if (!TestFlag(nMsgFlag, smGetMsg)) {
            return FALSE;               // No messages are available
        }


        //
        // When processing GetMessage() / PeekMessage() like functionality, 
        // we want QS_ALLINPUT as the queue wake flags, as this provides similar
        // functionality.
        //

        switch (Wait(QS_ALLINPUT, dwTimeOut, fInputAvailable, TestFlag(nProcessValid, mvpDUser))) 
        {
        case wGMsgReady:
ProcessMsgs:
            AssertMsg(TestFlag(nProcessValid, mvpDUser),
                    "Only should be signaled if allowed to process DUser messages");
            xwProcessMsgQNL();
            break;

        case wUserMsgReady:
            {
ProcessPeekMessage:
                //
                // Got signaled to get a message from the USER queue.  This can 
                // return FALSE if the QS_EVENT was in the wait mask because USER
                // needed to be called back.
                //

                fJumpPeek = FALSE;

                BOOL fResult;
#if ENABLE_MPH
                if (m_nMsgMode == IGMM_STANDARD) {
                    //
                    // When in Standard messaging mode, we need to call back to 
                    // the "real" xxxInternalGetMessage() in NTUSER to process
                    // the message.  If we call PeekMessage(), we will enter a
                    // loop.
                    //
                    // Only do this if this thread is initialized as Standard.
                    // If the thread is setup with a different messaging model,
                    // the call to PeekMessage() will not loop, and is required
                    // to properly setup state.
                    //

                    AssertMsg(g_mphReal.pfnInternalGetMessage != NULL, "Must have valid callback");
                    fResult = (g_mphReal.pfnInternalGetMessage)(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, FALSE);
                } else {
#endif
                    if (TestFlag(nMsgFlag, smAnsi)) {
                        fResult = PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
                    } else {
                        fResult = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
                    }
#if ENABLE_MPH
                }
#endif

#if DBG_CHECK_CALLBACKS
                if (!IsInitThread()) {
                    AlwaysPromptInvalid("DirectUser has been uninitialized during PeekMessage()");
                }
#endif

                if (fResult) {
                    if ((lpMsg->message == WM_QUIT) && TestFlag(nMsgFlag, smGetMsg)) {
                        //
                        // GetMessage behavior is to return FALSE when seeing a 
                        // WM_QUIT message.
                        //

                        fResult = FALSE;
                    }
                    return fResult;
                }
            }
            break;

        case wTimeOut:
            //
            // There were no messages to process, so can do any 
            // idle-time processing here.
            //

            AssertMsg(TestFlag(nProcessValid, mvpIdle), 
                    "Only should be signaled if allowed to perform idle-time processing");
            dwTimeOut = m_pParent->xwOnIdleNL();
            break;

        case wError:
            // Got an unexpected return value, so just continue to wait
            AssertMsg(0, "Unexpected return from CoreSC::Wait()");
            return TRUE;
        }
    }
}


/***************************************************************************\
*
* CoreSC::xwProcessMsgQNL
*
* xwProcessMsgQNL() 
*
\***************************************************************************/

void
CoreSC::xwProcessMsgQNL()
{
    //
    // Only one thread can process messages that need to be 
    // synchronized.  This is because the application is expecting
    // these messages in a certain order (for example, key up after 
    // key down).  To ensure this, mark when a thread starts 
    // processing.
    //

    if (InterlockedCompareExchange((long *) &m_fProcessing, TRUE, FALSE) == FALSE) {
        //
        // A message is available in the CoreSC's queues.  To process the 
        // messages, extract the list inside the lock and then process the
        // messages outside the lock.  This allows more messages to be 
        // queued while the messages are being processed.
        //

        m_msgqSend.xwProcessNL();
        m_msgqPost.xwProcessNL();

        InterlockedExchange((long *) &m_fProcessing, FALSE);
    }
}


//------------------------------------------------------------------------------
HRESULT
CoreSC::xwFireMessagesNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  FGM_INFO * rgFGM,           // Collection of messsages to fire
    IN  int cMsgs,                  // Number of messages
    IN  UINT idQueue)               // Queue to send messages
{
    HRESULT hr = S_OK;
    BOOL fSend;
    SafeMsgQ * pmsgq;


    //
    // Determine which queue the messages are being pumped into
    //

    switch (idQueue)
    {
    case FGMQ_SEND:
        pmsgq = &psctxDest->m_msgqSend;
        fSend = TRUE;
        break;

    case FGMQ_POST:
        pmsgq = &psctxDest->m_msgqPost;
        fSend = FALSE;
        break;

    default:
        PromptInvalid("Unknown queue");
        return E_INVALIDARG;
    }

    if (!IsInitThread()) {
        PromptInvalid("Thread must be initialized with InitGadgets() to call this function()\n");
        return DU_E_NOCONTEXT;
    }

    Thread * pthrSend   = GetThread();

    int cPost = cMsgs;
    if (fSend) {
        if (this == psctxDest) {
            //
            // Sending into the same Context, so can just call directly.
            //

            for (int idx = 0; idx < cMsgs; idx++) {
                FGM_INFO & fgm          = rgFGM[idx];
                EventMsg * pmsg         = fgm.pmsg;
                DuEventGadget *pgadMsg   = (DuEventGadget *) fgm.pvReserved;
                const GPCB & cb         = pgadMsg->GetCallback();
                if (TestFlag(fgm.nFlags, SGM_FULL) && TestFlag(pgadMsg->GetHandleMask(), hmVisual)) {
                    fgm.hr = cb.xwInvokeFull((const DuVisual *) pgadMsg, pmsg, 0);
                } else {
                    fgm.hr = cb.xwInvokeDirect(pgadMsg, pmsg, 0);
                }
            }
            hr = S_OK;
        } else {
            //
            // Sending into a different Context, so need to use the queues.
            //


            //
            // Post messsages the initial messages, up until the last message.
            // We don't need to block waiting for each to return as we can prepare
            // the next message.
            //

            cPost--;
            for (int idx = 0; idx < cPost; idx++) {
                FGM_INFO & fgm          = rgFGM[idx];
                EventMsg * pmsg         = fgm.pmsg;
                DuEventGadget * pgadMsg  = (DuEventGadget *) fgm.pvReserved;
                UINT nFlags             = fgm.nFlags;

                hr = pmsgq->PostNL(pthrSend, pmsg, pgadMsg, GetProcessProc(pgadMsg, nFlags), nFlags);
                if (FAILED(hr)) {
                    goto ErrorExit;
                }
            }


            //
            // All of the previous messages have been posted, so we now need to send
            // the last message and wait for all of the results.
            //

            FGM_INFO & fgm = rgFGM[idx];
            EventMsg * pmsg = fgm.pmsg;
            DuEventGadget * pgadMsg = (DuEventGadget *) fgm.pvReserved;
            UINT nFlags = fgm.nFlags;

            fgm.hr = xwSendNL(psctxDest, pmsgq, pmsg, pgadMsg, nFlags);

            
            //
            // All of the messages have been processed, so copy the results from
            // the posted-messages GadgetProc's back.
            //

            // TODO: Copy the results back.  This is a little complicated since
            // they are stored in the MsgEntry and that is now already recycled.
            // Need to determine how to get these back or change 
            // FireMessagesNL() to not return these.
        }
    } else {
        //
        // Post all of the messsages.
        //

        for (int idx = 0; idx < cPost; idx++) {
            const FGM_INFO & fgm = rgFGM[idx];
            EventMsg * pmsg = fgm.pmsg;
            DuEventGadget * pgadMsg = (DuEventGadget *) fgm.pvReserved;
            UINT nFlags = fgm.nFlags;

            hr = pmsgq->PostNL(pthrSend, pmsg, pgadMsg, GetProcessProc(pgadMsg, nFlags), nFlags);
            if (FAILED(hr)) {
                goto ErrorExit;
            }
        }
    }

ErrorExit:
    return hr;
}


/***************************************************************************\
*
* CoreSC::xwSendNL
*
* xwSendNL sends a new message to the given Gadget.  If the Gadget is
* in the current Context, the message is immediately sent.  If the Gadget is
* on a different Context, the message is queued on that Context and this 
* thread is blocked until the message is processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the sending Gadget's CoreSC 
* and not the destination CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
CoreSC::xwSendNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  SafeMsgQ * pmsgq,           // Destination queue
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  UINT nFlags)                // Message flags
{
    ProcessMsgProc pfnProcess;
    HRESULT hr = DU_E_MESSAGEFAILED;
    int cbMsgSize;

    if (TestFlag(pmo->GetHandleMask(), hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        Context * pctxGad = pgad->GetContext();

        AssertMsg(pctxGad == psctxDest->m_pParent, "Must be called on the receiving Context");
        if (pctxGad == m_pParent) {
            AssertMsg(0, "Should never call CoreSC::xwSendNL() inside DirectUser for same context messages");
            return S_OK;
        }

        pfnProcess = GetProcessProc(pgad, nFlags);
    } else {
        pfnProcess = xwProcessMethod;
    }


    //
    // Destination Gadget is in a different CoreSC that the current 
    // CoreSC, so need to add the message to the SendMessage queue and wait
    // for a response.
    //

    //
    // Setup the MsgEntry.
    //

    MsgEntry * pEntry;
    BOOL fAlloc;
    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    if (pmsg->cbSize <= 256) {
        //
        // The message is pretty small, so just allocate memory on the stack.
        //

        pEntry      = (MsgEntry *) STACK_ALIGN8_ALLOC(cbAlloc);
        AssertMsg(pEntry != NULL, "Failed to allocate on stack- very bad");
        fAlloc      = FALSE;
    } else {
        //
        // The message is rather large, so allocate on the destination 
        // CoreSC's heap to be safe.  However, DON'T mark the entry as
        // SGM_ALLOC or the Entry will be deleted before we can get the
        // result from the message.
        //

        pEntry      = (MsgEntry *) ContextAlloc(m_pParent->GetHeap(), cbAlloc);
        if (pEntry == NULL) {
            hr      = E_OUTOFMEMORY;
            goto CleanUp;
        }
        fAlloc      = TRUE;
    }

    cbMsgSize = pmsg->cbSize;
    CopyMemory(pEntry->GetMsg(), pmsg, cbMsgSize);
    pEntry->pthrSender  = NULL;
    pEntry->pmo         = pmo;
    pEntry->pfnProcess  = pfnProcess;
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = m_hevSendDone;
    pEntry->nResult     = 0;

    pmsgq->AddNL(pEntry);
    psctxDest->MarkDataNL();

    //
    // We have added the event now and can not return until the event has 
    // been signaled or else the event may not be reset when we re-enter.
    //

    // TODO: Need to add another event that can be signaled if this thread
    // gets called back to process a message while waiting.  This allows two
    // threads to send messages back and forth.

    VerifyMsg(WaitForSingleObject(m_hevSendDone, INFINITE) == WAIT_OBJECT_0, 
            "WaitForSingleObject failed on event");

    CopyMemory(pmsg, pEntry->GetMsg(), cbMsgSize);
    hr = pEntry->nResult;

    if (fAlloc) {
        ContextFree(m_pParent->GetHeap(), pEntry);
    }

CleanUp:
    return hr;
}


/***************************************************************************\
*
* CoreSC::PostNL
*
* PostNL adds a new message to the Context of the given Gadget.  This
* function does not block waiting for the message to be processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the destination Gadget's CoreSC 
* and not the current CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
CoreSC::PostNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  SafeMsgQ * pmsgq,           // Destination queue
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  UINT nFlags)                // Message flags
{
    ProcessMsgProc pfnProcess;
    Thread * pthrSend = NULL;

    if (!TestFlag(nFlags, SGM_RECEIVECONTEXT) && IsInitThread()) {
        pthrSend = GetThread();
    }

    if (TestFlag(pmo->GetHandleMask(), hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        pfnProcess = GetProcessProc(pgad, nFlags);
    } else {
        pfnProcess = xwProcessMethod;
    }


    HRESULT hr = pmsgq->PostNL(pthrSend, pmsg, pmo, pfnProcess, nFlags);
    if (SUCCEEDED(hr)) {
        psctxDest->MarkDataNL();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\core.h ===
/***************************************************************************\
*
* File: Core.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Core_h__INCLUDED)
#define CORE__Core_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>

#define DEBUG_MARKDRAWN             0
#define DEBUG_DRAWSTATS             0

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Core Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // CORE__Core_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\context.inl ===
/***************************************************************************\
*
* File: Context.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__CoreSC_inl__INCLUDED)
#define CORE__CoreSC_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class CoreSC
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline CoreSC *   
GetCoreSC()
{
    return static_cast<CoreSC *> (GetContext()->GetSC(Context::slCore));
}


//------------------------------------------------------------------------------
inline CoreSC *    
GetCoreSC(Context * pContext)
{
    return static_cast<CoreSC *> (pContext->GetSC(Context::slCore));
}


//------------------------------------------------------------------------------
inline void   
CoreSC::MarkDataNL()
{
    if ((!m_fQData) && !InterlockedExchange((long *) &m_fQData, TRUE)) {
        SetEvent(m_hevQData);
    }
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::xwSendMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo)
{
    return xwSendNL(psctxDest, &psctxDest->m_msgqSend, pmsg, pmo, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::xwSendEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    return xwSendNL(psctxDest, &psctxDest->m_msgqSend, pmsg, reinterpret_cast<MsgObject *> (pgadMsg), nFlags);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::PostMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo)
{
    return PostNL(psctxDest, &psctxDest->m_msgqPost, pmsg, pmo, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::PostEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    return PostNL(psctxDest, &psctxDest->m_msgqPost, pmsg, reinterpret_cast<MsgObject *> (pgadMsg), nFlags);
}


#endif // CORE__CoreSC_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\container.cpp ===
/***************************************************************************\
*
* File: Container.cpp
*
* Description:
* Container.cpp implements the basic Gadget container used to host a 
* Gadget-Tree.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Container.h"

#include "RootGadget.h"

/***************************************************************************\
*****************************************************************************
*
* class DuContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuContainer::DuContainer()
{

}


//------------------------------------------------------------------------------
DuContainer::~DuContainer()
{

}


//------------------------------------------------------------------------------
DuRootGadget *    
DuContainer::GetRoot() const
{
    return m_pgadRoot;
}


//------------------------------------------------------------------------------
void    
DuContainer::xwDestroyGadget()
{
    if (m_pgadRoot != NULL) {
        m_pgadRoot->xwDeleteHandle();
    }
}


//------------------------------------------------------------------------------
void    
DuContainer::AttachGadget(DuRootGadget * playNew)
{
    Assert(playNew != NULL);
    DetachGadget();
    m_pgadRoot = playNew;
}


//------------------------------------------------------------------------------
void    
DuContainer::DetachGadget()
{
    m_pgadRoot = NULL;
}


//------------------------------------------------------------------------------
void
DuContainer::SetManualDraw(BOOL fManualDraw)
{
    m_fManualDraw = fManualDraw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\container.h ===
/***************************************************************************\
*
* File: Container.h
*
* Description:
* Container.h defines the basic Gadget DuContainer used to host a 
* Gadget-Tree.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuContainer_h__INCLUDED)
#define CORE__DuContainer_h__INCLUDED
#pragma once

class DuVisual;
class DuRootGadget;

//------------------------------------------------------------------------------
class DuContainer : public BaseObject
{
// Construction
public:
            DuContainer();
    virtual ~DuContainer();

// Operations
public:
            DuRootGadget * GetRoot() const;

            void        xwDestroyGadget();

            void        AttachGadget(DuRootGadget * playNew);
            void        DetachGadget();

// BaseObject
public:
    virtual UINT        GetHandleMask() const { return hmContainer; }

// DuContainer Interface
public:
    // Functions called from Root
    virtual void        OnGetRect(RECT * prcDesktopPxl) PURE;
    virtual void        OnInvalidate(const RECT * prcInvalidDuContainerPxl) PURE;
    virtual void        OnStartCapture() PURE;
    virtual void        OnEndCapture() PURE;
    virtual BOOL        OnTrackMouseLeave() PURE;
    virtual void        OnSetFocus() PURE;
    virtual void        OnRescanMouse(POINT * pptDuContainerPxl) PURE;

            void        SetManualDraw(BOOL fManualDraw);

    // Functions called from Outside
    enum EMsgFlags
    {
        mfForward       = 0x00000001,   // Message is being forwarded
    };
    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags) PURE;

// Data
protected:
            DuRootGadget *
                        m_pgadRoot;
            BOOL        m_fManualDraw;
};

class DuContainer;

//------------------------------------------------------------------------------
inline DuContainer * CastContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && TestFlag(pBase->GetHandleMask(), hmContainer)) {
        return (DuContainer *) pBase;
    }
    return NULL;
}


#endif // CORE__DuContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\callback.inl ===
/***************************************************************************\
*
* File: Callback.inl
*
* Description:
* Callback.inl wraps the standard DirectUser DuVisual callbacks into 
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Callback_inl__INCLUDED)
#define CORE__Callback_inl__INCLUDED

#include "Thread.h"

/***************************************************************************\
*
* GPCB::GPCB
*
* GPCB() builds but does not fully initialize a new GPCB.  The caller must
* call Create() to complete the initialization.
*
\***************************************************************************/

inline
GPCB::GPCB()
{
    //
    // Initially send no optional messages.  Destruction messages will always be
    // sent.
    //
    
    m_nFilter = 0;

#if DBG
    m_hgadCheck = (HGADGET) (INT_PTR) 0xABCD1234;
#endif // DBG
}


//------------------------------------------------------------------------------
inline UINT    
GPCB::GetFilter() const
{
    return m_nFilter;
}


//------------------------------------------------------------------------------
inline void    
GPCB::SetFilter(UINT nNewFilter, UINT nMask)
{
    ChangeFlag(m_nFilter, nNewFilter, nMask);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwInvokeDirect(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags) const
{
    return xwInvokeDirect(reinterpret_cast<const DuEventGadget *> (pgadMsg), pmsg, nInvokeFlags);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwInvokeDirect(const DuListener * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags) const
{
    return xwInvokeDirect(reinterpret_cast<const DuEventGadget *> (pgadMsg), pmsg, nInvokeFlags);
}


//------------------------------------------------------------------------------
inline void        
GPCB::xwFireDestroy(const DuEventGadget * pgad, UINT nCode) const
{
#if DBG
    DEBUG_CheckHandle(pgad, TRUE);
#endif // DBG

    GMSG_DESTROY msg;
    msg.cbSize      = sizeof(msg);
    msg.nMsg        = GM_DESTROY;
    msg.nCode       = nCode;

    xwInvokeDirect(pgad, &msg, ifSendAll);
}


inline const Gdiplus::RectF
Convert(const RECT * prc)
{
    Gdiplus::RectF rc(
        (float) prc->left, 
        (float) prc->top,
        (float) (prc->right - prc->left),
        (float) (prc->bottom - prc->top));

    return rc;
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaint(const DuVisual * pgad, HDC hdc, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_PAINT)) {
        GMSG_PAINTRENDERI msg;
        msg.cbSize          = sizeof(msg);
        msg.nMsg            = GM_PAINT;
        msg.nCmd            = GPAINT_RENDER;
        msg.nSurfaceType    = GSURFACE_HDC;
        msg.hdc             = hdc;
        msg.prcGadgetPxl    = prcGadgetPxl;
        msg.prcInvalidPxl   = prcInvalidPxl;

        xwInvokeDirect(pgad, &msg, ifReadOnly);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaint(const DuVisual * pgad, Gdiplus::Graphics * pgpgr, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_PAINT)) {
        Gdiplus::RectF rcGadgetPxl  = Convert(prcGadgetPxl);
        Gdiplus::RectF rcInvalidPxl = Convert(prcInvalidPxl);

        GMSG_PAINTRENDERF msg;
        msg.cbSize          = sizeof(msg);
        msg.nMsg            = GM_PAINT;
        msg.nCmd            = GPAINT_RENDER;
        msg.nSurfaceType    = GSURFACE_GPGRAPHICS;
        msg.pgpgr           = pgpgr;
        msg.prcGadgetPxl    = &rcGadgetPxl;
        msg.prcInvalidPxl   = &rcInvalidPxl;

        xwInvokeDirect(pgad, &msg, ifReadOnly);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaintCache(const DuVisual * pgad, HDC hdcDraw, const RECT * prcGadgetPxl, 
        BYTE * pbAlphaLevel, BYTE * pbAlphaFormat) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_PAINTCACHE msg;
    msg.cbSize          = sizeof(msg);
    msg.nMsg            = GM_PAINTCACHE;
    msg.hdc             = hdcDraw;
    msg.prcGadgetPxl    = prcGadgetPxl;
    msg.bAlphaLevel     = BLEND_OPAQUE;
    msg.bAlphaFormat    = 0;

    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *pbAlphaLevel   = msg.bAlphaLevel;
        *pbAlphaFormat  = msg.bAlphaFormat;
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFireQueryHitTest(const DuVisual * pgad, POINT ptClientPxl, UINT * pnResult) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    AssertWritePtr(pnResult);
    *pnResult           = GQHT_INSIDE;      // Default to inside

    GMSG_QUERYHITTEST msg;
    msg.cbSize          = sizeof(msg);
    msg.nMsg            = GM_QUERY;
    msg.nCode           = GQUERY_HITTEST;
    msg.ptClientPxl     = ptClientPxl;
    msg.nResultCode     = *pnResult;
    msg.pvResultData    = NULL;

    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *pnResult = msg.nResultCode;
    }
}


//------------------------------------------------------------------------------
inline BOOL        
GPCB::xrFireQueryPadding(const DuVisual * pgad, RECT * prcPadding) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    AssertWritePtr(prcPadding);
    ZeroMemory(prcPadding, sizeof(RECT));

    GMSG_QUERYPADDING msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize = sizeof(msg);
    msg.nMsg   = GM_QUERY;
    msg.nCode  = GQUERY_PADDING;
    
    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *prcPadding = msg.rcPadding;
        return TRUE;
    }

    return FALSE;
}


#if DBG_STORE_NAMES

//------------------------------------------------------------------------------
inline BOOL        
GPCB::xrFireQueryName(const DuVisual * pgad, WCHAR ** ppszName, WCHAR ** ppszType) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_QUERYDESC msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize      = sizeof(msg);
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (xwInvokeDirect(pgad, &msg, GPCB::ifReadOnly) == DU_S_COMPLETE) {
        if (ppszName != NULL) {
            *ppszName = _wcsdup(msg.szName);
        }
        if (ppszType != NULL) {
            *ppszType = _wcsdup(msg.szType);
        }
        return TRUE;
    }

    return FALSE;
}

#endif // DBG_STORE_NAMES


//------------------------------------------------------------------------------
inline void
GPCB::xdFireMouseMessage(const DuVisual * pgad, GMSG_MOUSE * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);

    UINT size;

    switch (pmsg->nCode) {
        case GMOUSE_DRAG:   size = sizeof(GMSG_MOUSEDRAG);  break;
        case GMOUSE_WHEEL:  size = sizeof(GMSG_MOUSEWHEEL); break;
        case GMOUSE_DOWN:
        case GMOUSE_UP:     size = sizeof(GMSG_MOUSECLICK); break;
        default:            size = sizeof(GMSG_MOUSE);      break;
    }
    AssertMsg(pmsg->cbSize == size, "Mouse Message has improperly set cbSize");
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE)) {
        pmsg->nMsg      = GM_INPUT;
        pmsg->nDevice   = GINPUT_MOUSE;

        GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireKeyboardMessage(const DuVisual * pgad, GMSG_KEYBOARD * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_INPUTKEYBOARD)) {
        pmsg->cbSize    = sizeof(GMSG_KEYBOARD);
        pmsg->nMsg      = GM_INPUT;
        pmsg->nDevice   = GINPUT_KEYBOARD;

        GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeState(const DuVisual * pgad, UINT nCode, HGADGET hgadLost, HGADGET hgadSet, UINT nCmd) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGESTATE)) {
        GMSG_CHANGESTATE msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGESTATE;
        msg.nCode       = nCode;
        msg.hgadLost    = hgadLost;
        msg.hgadSet     = hgadSet;
        msg.nCmd        = nCmd;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeRect(const DuVisual * pgad, const RECT * prc, UINT nFlags) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGERECT)) {
        GMSG_CHANGERECT msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGERECT;
        msg.rcNewRect   = *prc;
        msg.nFlags      = nFlags;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeStyle(const DuVisual * pgad, UINT nOldStyle, UINT nNewStyle) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGESTYLE)) {
        GMSG_CHANGESTYLE msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGESTYLE;
        msg.nOldStyle   = nOldStyle;
        msg.nNewStyle   = nNewStyle;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireSyncAdaptor(const DuVisual * pgad, UINT nCode) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_SYNCADAPTOR msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.nCode   = nCode;
    msg.nMsg    = GM_SYNCADAPTOR;

    GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireDelayedMessage(const DuVisual * pgad, GMSG * pmsg, UINT nFlags) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, nFlags);
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireDelayedMessage(const DuListener * pgad, GMSG * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwCallGadgetProc(HGADGET hgadCur, EventMsg * pmsg) const
{
#if DBG
    AssertMsg(m_hgadCheck == hgadCur, "Gadgets must match");
#endif // DBG

    HRESULT hr;

    //
    // Need to guard around the callback to prevent DirectUser from becoming
    // completely toast if something goes wrong.
    //

#if DBG_CHECK_CALLBACKS
    hr = E_FAIL;
    BEGIN_CALLBACK()
#endif

    __try 
    {
        hr = (m_pfnProc)(hgadCur, m_pvData, pmsg);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

#if DBG_CHECK_CALLBACKS
    END_CALLBACK()
#endif

    return hr;
}


#endif // CORE__Callback_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\context.h ===
/***************************************************************************\
*
* File: Context.h
*
* Description:
* This file declares the SubContext used by the DirectUser/Core project to
* maintain Context-specific data.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__CoreSC_h__INCLUDED)
#define CORE__CoreSC_h__INCLUDED
#pragma once

#include "MsgQ.h"

struct CoreData;
class CoreSC;

class DuParkContainer;
class DuRootGadget;
class DuVisual;


typedef struct tagPressTrack
{
    BYTE        bButton;        // pressed button
    LONG        lTime;          // time of button press
    POINT       ptLoc;          // location of button press
    DuVisual *
                pgadClick;      // Gadget clicked in
} PressTrack;

#define POOLSIZE_Visual 512


/***************************************************************************\
*****************************************************************************
*
* CoreSC contains Context-specific information used by the Core project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Context object.
*
*****************************************************************************
\***************************************************************************/

#pragma warning(disable:4324)  // structure was padded due to __declspec(align())

class CoreSC : public SubContext
{
// Construction
public:
            ~CoreSC();
            HRESULT     Create(INITGADGET * pInit);
    virtual void        xwPreDestroyNL();


// Operations
public:
    enum EMsgFlag
    {
        smAnsi          = 0x00000001,   // ANSI version of function
        smGetMsg        = 0x00000002,   // GetMessage behavior
    };

    enum EWait
    {
        wError          = -1,           // An error occurred
        wOther          = 0,            // Unexpected return from Wait() (mutex, etc)
        wGMsgReady,                     // DUser message is ready
        wUserMsgReady,                  // Win32 USER message is ready
        wTimeOut,                       // The specified timeout occurred
    };

    enum EMessageValidProcess
    {
        mvpDUser        = 0x00000001,   // Valid to process DUser messages
        mvpIdle         = 0x00000002,   // Valid to perform Idle-time processing
    };

            BOOL        xwProcessNL(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, UINT nMsgFlag);
            void        WaitMessage(UINT fsWakeMask = QS_ALLINPUT, DWORD dwTimeOutMax = INFINITE);

    inline  HRESULT     xwSendMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo);
    inline  HRESULT     xwSendEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
    inline  HRESULT     PostMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo);
    inline  HRESULT     PostEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
            HRESULT     xwFireMessagesNL(CoreSC * psctxDest, FGM_INFO * rgFGM, int cMsgs, UINT idQueue);
    static  UINT        CanProcessUserMsg(HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);

    inline  UINT        GetMsgMode() const { return m_nMsgMode; }


// CoreSC Data
public:
    // Tree management
            DuParkContainer *     
                        pconPark;       // Container for parked Gadgets

            class VisualPool : public AllocPoolNL<DuVisual, POOLSIZE_Visual>
            {
            };
            VisualPool * ppoolDuVisualCache;
                        

    // DuRootGadget management
            // Mouse position (enter / leave)
            DuRootGadget*
                        pgadRootMouseFocus;     // Root Gadget containing the mouse last
            DuVisual*   pgadMouseFocus;         // Actual Gadget containing the mouse last
            PressTrack  pressLast;              // last button press
            PressTrack  pressNextToLast;        // next to last button press
            UINT        cClicks;                // the number of times the button has been clicked in *quick* succession

            // Keyboard
            DuVisual*   pgadCurKeyboardFocus;   // Gadget with keyboard focus
            DuVisual*   pgadLastKeyboardFocus;  // Gadget previously with keyboard focus

            DuVisual*   pgadDrag;       // Gadget owning current drag
            POINT       ptDragPxl;      // Location that drag started
            BYTE        bDragButton;    // Button drag started with

            // Adaptors
            UINT        m_cAdaptors;    // Total number of adaptors in this Context

// Implementation
protected:
    inline  void        MarkDataNL();
            EWait       Wait(UINT fsWakeMask, DWORD dwTimeOut, BOOL fAllowInputAvailable, BOOL fProcessDUser);

            void        xwProcessMsgQNL();

            HRESULT     xwSendNL(CoreSC * psctxDest, SafeMsgQ * pmsgq, GMSG * pmsg, MsgObject * pmo, UINT nFlags);
            HRESULT     PostNL(CoreSC * psctxDest, SafeMsgQ * pmsgq, GMSG * pmsg, MsgObject * pmo, UINT nFlags);

// Data
protected:
            CoreData *  m_pData;        // CoreSC data

    volatile long       m_fQData;       // Data has been queued (NOT A BITFLAG)
    volatile long       m_fProcessing;  // Currently processing synchronized queues

            HANDLE      m_hevQData;     // Data has been queued
            HANDLE      m_hevSendDone;  // Sent data has been processed
            SafeMsgQ    m_msgqSend;     // Sent messages
            SafeMsgQ    m_msgqPost;     // Posted messages
            UINT        m_nMsgMode;     // Messaging mode
};

#pragma warning(default:4324)  // structure was padded due to __declspec(align())

inline  CoreSC *    GetCoreSC();
inline  CoreSC *    GetCoreSC(Context * pContext);

#include "Context.inl"

#endif // CORE__CoreSC_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\dynaset.cpp ===
/***************************************************************************\
*
* File: DynaSet.h
*
* Description:
* DynaSet.h implements a "dynamic set" that can be used to implement a 
* collection of "atom - data" property pairs.  This extensible, lightweight
* mechanism is optimized for small sets that have been created once and are
* read on occassion.  It is not a high-performance property system.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "DynaSet.h"

/***************************************************************************\
*****************************************************************************
*
* class AtomSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* AtomSet::AtomSet
*
* AtomSet() creates and initializes a new AtomSet.
*
\***************************************************************************/

AtomSet::AtomSet(
    IN  PRID idStartGlobal)         // Starting PRID to number from
{
    m_idNextPrivate = PRID_PrivateMin;
    m_idNextGlobal  = idStartGlobal;
    m_ptemGuid      = NULL;
}


/***************************************************************************\
*
* AtomSet::~AtomSet
*
* ~AtomSet() cleans up and frees resources associated with an AtomSet.
*
\***************************************************************************/

AtomSet::~AtomSet()
{
    Atom * ptemCur, * ptemNext;

    //
    // The list should be empty by now because we are destroying the desktop
    // and all of the applications should have Released their ID.  However, 
    // many apps are bad, so need to clean up anyway.
    //

    ptemCur = m_ptemGuid;
    while (ptemCur != NULL) {
        ptemNext = ptemCur->pNext;
        ProcessFree(ptemCur);
        ptemCur = ptemNext;
    }
}


/***************************************************************************\
*
* AtomSet::GetNextID
*
* GetNextID() returns the next ID to use for a new Atom.  The internal 
* counter to automatically advanced to the next available ID.
*
\***************************************************************************/

PRID    
AtomSet::GetNextID(
    IN  PropType pt)
{
    switch (pt)
    {
    case ptPrivate:
        // Private properties go down
        return m_idNextPrivate--;
        break;

    case ptGlobal:
        // Global properties go up
        return m_idNextGlobal++;
        break;

    default:
        AssertMsg(0, "Illegal property type");
        return PRID_Unused;
    }
}


/***************************************************************************\
*
* AtomSet::AddRefAtom
*
* AddRefAtom() adds a new property to the property list.  If the 
* property already exists, it increments a usage count.  The short-ID will 
* be determined from the type of property.
*
\***************************************************************************/

HRESULT
AtomSet::AddRefAtom(
    IN  const GUID * pguidAdd,          // Property to add
    IN  PropType pt,                    // Type of property
    OUT PRID * pprid)                   // Unique PRID for property
{
    GuidAtom * ptemCur, * ptemTail;
    ptemCur = FindAtom(pguidAdd, pt, &ptemTail);
    if (ptemCur != NULL) {
        ptemCur->cRefs++;
        *pprid = ptemCur->id;
        return S_OK;
    }

    //
    // Unable to find in registered list, so need to add to end.  Will need
    // to determine a new ID to use.
    //

    PRID idNew = GetNextID(pt);

    ptemCur = (GuidAtom *) ProcessAlloc(sizeof(GuidAtom));
    if (ptemCur == NULL) {
        *pprid = PRID_Unused;
        return E_OUTOFMEMORY;
    }

    ptemCur->cRefs  = 1;
    ptemCur->guid   = *pguidAdd;
    ptemCur->pNext  = NULL;
    ptemCur->id     = idNew;

    if (ptemTail == NULL) {
        // First node in list, so store directly
        m_ptemGuid = ptemCur;
    } else {
        // Already existing nodes, so add to end
        ptemTail->pNext = ptemCur;
    }

    *pprid = ptemCur->id;
    return S_OK;
}


/***************************************************************************\
*
* AtomSet::ReleaseAtom
*
* ReleaseAtom() decreases the reference count on the given Atom by one.
* When the reference count reaches 0, the Atom is destroyed.
*
\***************************************************************************/

HRESULT
AtomSet::ReleaseAtom(
    IN const GUID * pguidSearch,    // Property to release
    IN PropType pt)                 // Type of property
{
    GuidAtom * ptemCur, * ptemPrev;
    ptemCur = FindAtom(pguidSearch, pt, &ptemPrev);
    if (ptemCur != NULL) {
        ptemCur->cRefs--;
        if (ptemCur->cRefs <= 0) {
            if (ptemPrev != NULL) {
                //
                // In middle of list, so just splice this item out.
                //

                ptemPrev->pNext = ptemCur->pNext;
            } else {
                //
                // At beginning of list, so need to also update the head.
                //

                m_ptemGuid = (GuidAtom *) ptemCur->pNext;
            }

            ProcessFree(ptemCur);
        }

        return S_OK;
    }

    // Unable to find ID
    return E_INVALIDARG;
}


/***************************************************************************\
*
* AtomSet::FindAtom
*
* FindAtom() searches through the list of registered properties 
* and returns the corresponding short id.  If the ID is not found, returns 
* PRID_Unused.
*
\***************************************************************************/
AtomSet::GuidAtom *
AtomSet::FindAtom(
    IN const GUID * pguidSearch,    // Property to add
    IN PropType pt,                 // Type of property
    OUT GuidAtom ** pptemPrev       // Previous Atom, tail of list
    ) const
{
    GuidAtom * ptemCur, * ptemPrev;

    // Check parameters
    AssertReadPtr(pguidSearch);

    //
    // Search through the list of nodes searching for the ID.
    //

    ptemPrev = NULL;
    ptemCur = m_ptemGuid;
    while (ptemCur != NULL) {
        PropType ptCur = GetPropType(ptemCur->id);
        if ((ptCur == pt) && IsEqualGUID(*pguidSearch, ptemCur->guid)) {
            if (pptemPrev != NULL) {
                // Pass back the previous node
                *pptemPrev = ptemPrev;
            }
            return ptemCur;
        }

        ptemPrev = ptemCur;
        ptemCur = (GuidAtom *) ptemCur->pNext;
    }

    if (pptemPrev != NULL) {
        // Pass back the tail of the list
        *pptemPrev = ptemPrev;
    }
    return NULL;
}


/***************************************************************************\
*
* AtomSet::ValidatePrid
*
* ValidatePrid() checks that the ID range matches with the property 
* type.  This is how we keep DirectUser properties private.
*
\***************************************************************************/
BOOL 
AtomSet::ValidatePrid(
    IN PRID prid,                   // ID to check
    IN PropType pt)                 // Property type to validate
{
    switch (pt)
    {
    case ptPrivate:
        if (ValidatePrivateID(prid))
            return TRUE;
        break;

    case ptGlobal:
        if (ValidateGlobalID(prid))
            return TRUE;
        break;
    }

    return FALSE;
}


/***************************************************************************\
*****************************************************************************
*
* class DynaSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DynaSet::AddItem
*
* AddItem() adds a new data item.
*
\***************************************************************************/

BOOL
DynaSet::AddItem(
    IN  PRID id,                    // PRID of new item to add
    IN  void * pvData)              // Associated data for item
{
    DynaData dd;
    dd.pData    = pvData;
    dd.id       = id;

    return m_arData.Add(dd) >= 0;
}


/***************************************************************************\
*
* DynaDataSet::RemoveAt
*
* RemoveAt() removes the item at the specified index from the set.
*
\***************************************************************************/

void 
DynaSet::RemoveAt(
    IN  int idxData)               // Index to remove
{
    // Search data
#if DBG
    int cItems = GetCount();
    AssertMsg(cItems > 0, "Must have items to remove");
    AssertMsg((idxData < cItems) && (idxData >= 0), "Ensure valid index");
#endif // DBG

    m_arData.RemoveAt(idxData);
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with the specified PRID.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  PRID id                     // PRID of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if (dd.id == id) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with associated data value.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  void * pvData               // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if (dd.pData == pvData) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with both the given PRID and
* associated data value.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  PRID id,                    // PRID of item to find
    IN  void * pvData               // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if ((dd.id == id) && (dd.pData == pvData)) {
            return idx;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\eventpool.cpp ===
/***************************************************************************\
*
* File: EventPool.cpp
*
* Description:
* DuEventPool maintains a collection of event handlers for given event ID's.
* This is a many-to-many relationship.  Each event ID may have multiple 
* event handlers.
*
* DuEventPools can not be created and handed outside DirectUser/Core directly.  
* Instead, must derive some class from DuEventPool to add in BaseObject 
* support for public handles.  This is a little wierd, but it is because 
* DuEventPool is DESIGNED to be as small as possible.  It is ONLY 4 bytes.  
* There is no v-table, pointer to an "owner", etc.  
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "EventPool.h"

#include "BaseGadget.h"


/***************************************************************************\
*****************************************************************************
*
* class DuEventPool
*
*****************************************************************************
\***************************************************************************/

AtomSet     DuEventPool::s_asEvents(GM_REGISTER);   // Start giving out registered messages at GM_REGISTER
CritLock    DuEventPool::s_lock;


/***************************************************************************\
*
* DuEventPool::FindMessages
*
* FindMessages() looks up and determines the corresponding MSGID's for a 
* collection of unique message GUID's.
*
\***************************************************************************/

HRESULT
DuEventPool::FindMessages(
    IN  const GUID ** rgpguid,      // Array of GUID's to lookup
    OUT MSGID * rgnMsg,             // Corresponding MSGID's of items
    IN  int cMsgs,                  // Number of GUID's to lookup
    IN  PropType pt)                // Item property type
{
    HRESULT hr = S_OK;

    for (int idx = 0; idx < cMsgs; idx++) {
        const GUID * pguidSearch = rgpguid[idx];
        PRID prid = s_asEvents.FindAtomID(pguidSearch, pt);
        rgnMsg[idx] = prid;
        if (prid == 0) {
            //
            // Unable to find ID of one message, but continue searching.
            //

            hr = DU_E_CANNOTFINDMSGID;
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuEventPool::AddHandler
*
* AddHandler() adds the given handler to the set of handlers maintained by
* the event pool.  If an identical handler already exists, it will be used
* instead.
*
* NOTE: This function is designed to be used with 
* DuEventGadget::AddMessageHandler() to maintain a list of "message handlers"
* for a given Gadget.
*
\***************************************************************************/

DuEventPool::EAdd
DuEventPool::AddHandler(
    IN  MSGID nEvent,               // ID of message to handle
    IN  DuEventGadget * pgadHandler)   // Message handler
{
    //
    // Check if already has handler for this specific event
    //

    int idxHandler = FindItem(nEvent, pgadHandler);
    if (idxHandler >= 0) {
        return aExisting;
    }


    //
    // Add a new handler
    //

    EventData data;
    data.pgbData    = pgadHandler;
    data.id         = nEvent;
    data.fGadget    = TRUE;
    
    return m_arData.Add(data) >= 0 ? aAdded : aFailed;
}


//------------------------------------------------------------------------------
DuEventPool::EAdd
DuEventPool::AddHandler(
    IN  MSGID nEvent,                   // ID of message to handle
    IN  DUser::EventDelegate ed)        // Message handler to remove
{
    //
    // Check if already has handler for this specific event
    //

    int idxHandler = FindItem(nEvent, ed);
    if (idxHandler >= 0) {
        return aExisting;
    }


    //
    // Add a new handler
    //

    EventData data;
    data.ed         = ed;
    data.id         = nEvent;
    data.fGadget    = FALSE;

    return m_arData.Add(data) >= 0 ? aAdded : aFailed;
}
    


/***************************************************************************\
*
* DuEventPool::RemoveHandler
*
* RemoveHandler() removes the given handler to the set of handlers 
* maintained by the event pool.
*
* NOTE: This function is designed to be used with 
* DuEventGadget::RemoveMessageHandler() to maintain a list of "message handlers"
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventPool::RemoveHandler(
    IN  MSGID nEvent,                   // ID of message being handled
    IN  DuEventGadget * pgadHandler)     // Message handler
{
    int idxHandler = FindItem(nEvent, pgadHandler);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
HRESULT
DuEventPool::RemoveHandler(
    IN  MSGID nEvent,                   // ID of message being handled
    IN  DUser::EventDelegate ed)        // Message handler to remove
{
    int idxHandler = FindItem(nEvent, ed);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


/***************************************************************************\
*
* DuEventPool::RemoveHandler
*
* RemoveHandler() removes the given handler to the set of handlers 
* maintained by the event pool.
*
* NOTE: This function is designed to called directly from
* DuEventGadget::CleanupMessageHandlers() to maintain a list of 
* "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventPool::RemoveHandler(
    IN  DuEventGadget * pgadHandler)     // Message handler to remove
{
    int idxHandler = FindItem(pgadHandler);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


/***************************************************************************\
*
* DuEventPool::Cleanup
*
* Cleanup() is called from during the second stage of 
* DuEventGadget::CleanupMessageHandlers() to cleanup the Gadget depencency 
* graph.
*
\***************************************************************************/

void
DuEventPool::Cleanup(
    IN  DuEventGadget * pgadDependency)    // Gadget being cleaned up
{
    if (IsEmpty()) {
        return;
    }

    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arData[idx].fGadget) {
            DuEventGadget * pgadCur = m_arData[idx].pgbData;
            pgadCur->RemoveDependency(pgadDependency);
        }
    }
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  DuEventGadget * pgadHandler      // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if (dd.fGadget && (dd.pgbData == pgadHandler)) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with both the given MSGID and
* associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  MSGID id,                       // MSGID of item to find
    IN  DuEventGadget * pgadHandler      // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if (dd.fGadget && (dd.id == id) && (dd.pgbData == pgadHandler)) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with both the given MSGID and
* associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  MSGID id,                       // MSGID of item to find
    IN  DUser::EventDelegate ed         // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if ((!dd.fGadget) && (dd.id == id) && 
                (dd.ed.m_pvThis == ed.m_pvThis) && (dd.ed.m_pfn == ed.m_pfn)) {

            return idx;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\eventpool.h ===
/***************************************************************************\
*
* File: EventPool.h
*
* Description:
* DuEventPool maintains a collection of event handlers for given event ID's.
* This is a many-to-many relationship.  Each event ID may have multiple 
* event handlers.
*
* DuEventPools can not be created and handed outside DirectUser/Core 
* directly.  Instead, must derive some class from DuEventPool to add in 
* BaseObject support for public handles.  This is a little wierd, but it is 
* because DuEventPool is DESIGNED to be as small as possible.  It is 
* ONLY 4 bytes.  There is no v-table, pointer to an "owner", etc.  
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuEventPool_h__INCLUDED)
#define CORE__DuEventPool_h__INCLUDED
#pragma once

#include "DynaSet.h"

class DuEventGadget;
class GPCB;

//------------------------------------------------------------------------------
class DuEventPool
{
// Construction
public:
    DuEventPool();
    ~DuEventPool();

// Operations
public:
    static  HRESULT     RegisterMessage(const GUID * pguid, PropType pt, MSGID * pmsgid);
    static  HRESULT     RegisterMessage(LPCWSTR pszName, PropType pt, MSGID * pmsgid);
    static  HRESULT     UnregisterMessage(const GUID * pguid, PropType pt);
    static  HRESULT     UnregisterMessage(LPCWSTR pszName, PropType pt);
    static  HRESULT     FindMessages(const GUID ** rgpguid, MSGID * rgnMsg, int cMsgs, PropType pt);

    enum EAdd
    {
        aFailed         = -1,       // Adding the handler failed
        aAdded          = 0,        // A new handler was added
        aExisting       = 1,        // The handler already existed
    };

    struct EventData
    {
        union
        {
            DuEventGadget *  
                        pgbData;    // Gadget
            DUser::EventDelegate   
                        ed;         // Delegate
        };
        PRID        id;                 // (Short) Property ID
        BOOLEAN     fGadget;            // Delegate vs. Gadget
    };

    inline  BOOL        IsEmpty() const;
    inline  int         GetCount() const;
    inline  const EventData *
                        GetData() const;

            int         FindItem(DuEventGadget * pvData) const;
            int         FindItem(MSGID id, DuEventGadget * pvData) const;
            int         FindItem(MSGID id, DUser::EventDelegate ed) const;

            EAdd        AddHandler(MSGID nEvent, DuEventGadget * pgadHandler);
            EAdd        AddHandler(MSGID nEvent, DUser::EventDelegate ed);
            HRESULT     RemoveHandler(MSGID nEvent, DuEventGadget * pgadHandler);
            HRESULT     RemoveHandler(MSGID nEvent, DUser::EventDelegate ed);
            HRESULT     RemoveHandler(DuEventGadget * pgadHandler);

            void        Cleanup(DuEventGadget * pgadDependency);

// Implementation
protected:

// Data
protected:
    static  AtomSet     s_asEvents;
    static  CritLock    s_lock;

            GArrayS<EventData>
                        m_arData;         // Dynamic user data
};

#include "EventPool.inl"

#endif // CORE__DuEventPool_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\eventpool.inl ===
/***************************************************************************\
*
* File: EventPool.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuEventPool_inl__INCLUDED)
#define CORE__DuEventPool_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DuEventPool
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuEventPool::DuEventPool()
{
    AssertMsg(sizeof(MSGID) == sizeof(PRID), "Ensure sizes match");
}


//------------------------------------------------------------------------------
inline 
DuEventPool::~DuEventPool()
{

}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::RegisterMessage(const GUID * pguid, PropType pt, MSGID * pmsgid)
{
    s_lock.Enter();

    HRESULT hr = s_asEvents.AddRefAtom(pguid, pt, (PRID *) pmsgid);

    s_lock.Leave();
    return hr;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::RegisterMessage(LPCWSTR pszName, PropType pt, MSGID * pmsgid)
{
    AssertMsg(0, "TODO: Implement RegisterMessage(String)");

    UNREFERENCED_PARAMETER(pszName);
    UNREFERENCED_PARAMETER(pt);

    *pmsgid = 0;
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::UnregisterMessage(const GUID * pguid, PropType pt)
{
    s_lock.Enter();

    HRESULT hr = s_asEvents.ReleaseAtom(pguid, pt);

    s_lock.Leave();
    return hr;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::UnregisterMessage(LPCWSTR pszName, PropType pt)
{
    AssertMsg(0, "TODO: Implement UnregisterMessage(String)");

    UNREFERENCED_PARAMETER(pszName);
    UNREFERENCED_PARAMETER(pt);

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
inline BOOL
DuEventPool::IsEmpty() const
{
    return m_arData.IsEmpty();
}


//------------------------------------------------------------------------------
inline int
DuEventPool::GetCount() const
{
    return m_arData.GetSize();
}


//------------------------------------------------------------------------------
inline const DuEventPool::EventData *
DuEventPool::GetData() const
{
    return m_arData.GetData();
}


#endif // CORE__DuEventPool_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\dynaset.inl ===
/***************************************************************************\
*
* File: DynaSet.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DynaSet_inl__INCLUDED)
#define CORE__DynaSet_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline bool ValidatePrivateID(PRID id)
{
    return id <= PRID_PrivateMin;
}


//------------------------------------------------------------------------------
inline bool ValidateGlobalID(PRID id)
{
    return id >= PRID_GlobalMin;
}


//------------------------------------------------------------------------------
inline PropType GetPropType(PRID id)
{
    if (id <= PRID_PrivateMin) {
        return ptPrivate;
    } else if (id >= PRID_GlobalMin) {
        return ptGlobal;
    } else {
        AssertMsg(0, "Invalid property ID");
        return ptPrivate;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class AtomSet
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline PRID        
AtomSet::FindAtomID(LPCWSTR pszName, PropType pt) const
{
    AtomSet::StringAtom * psa = FindAtom(pszName, pt, NULL);
    if (psa != NULL) {
        return psa->id;
    } else {
        return 0;   // Unable to find ID
    }
}


//------------------------------------------------------------------------------
inline PRID        
AtomSet::FindAtomID(const GUID * pguidSearch, PropType pt) const
{
    AtomSet::GuidAtom * pga = FindAtom(pguidSearch, pt, NULL);
    if (pga != NULL) {
        return pga->id;
    } else {
        return 0;   // Unable to find ID
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DynaSet
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
DynaSet::DynaSet()
{

}


//------------------------------------------------------------------------------
inline  
DynaSet::~DynaSet()
{
#if DBG
    //
    // Check to make sure all private data has already been free'd.  If it has
    // not, this is a programming error in DirectUser/Core.
    //

    {
        int idx;
        int cItems = GetCount();
        for (idx = 0; idx < cItems; idx++) {
            if (m_arData[idx].id < 0) {
                Trace("DUSER Warning: Destroying server-allocated property %d\n", m_arData[idx].id);
                AssertMsg(0, "Destroying server-allocated property");
            }
        }
    }

#endif // DBG
}


//------------------------------------------------------------------------------
inline BOOL        
DynaSet::IsEmpty() const
{
    return m_arData.IsEmpty();
}


//------------------------------------------------------------------------------
inline int         
DynaSet::GetCount() const
{
    return m_arData.GetSize();
}


//------------------------------------------------------------------------------
inline void    
DynaSet::SetCount(int cNewItems)
{
    AssertMsg(cNewItems > 0, "Must specify a positive number of items");

    m_arData.SetSize(cNewItems);
}


#endif // CORE__DynaSet_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\dynaset.h ===
/***************************************************************************\
*
* File: DynaSet.h
*
* Description:
* DynaSet.h implements a "dynamic set" that can be used to implement a 
* collection of "atom - data" property pairs.  This extensible, lightweight
* mechanism is optimized for small sets that have been created once and are
* read on occassion.  It is not a high-performance property system.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DynaSet_h__INCLUDED)
#define CORE__DynaSet_h__INCLUDED
#pragma once

//
// DynaSets are dynamically allocated sets of extra properties that can be 
// attached to an object.  Each property has both a full ID and a short ID 
// (atom). The full ID (GUID) is always unique, even across sessions.  It is 
// used by the caller to "register" a new property.  However, because GUID's 
// are very expensive to compare and consume more memory, every property is 
// assigned an atom that is used for Get() and Set() operations.  Atoms can 
// be public or private to DirectUser/Core, depending on the caller.  An atom
// will never be reused within a single session.  
//
// NOTE: When an atom is finally Release()'d, any objects (windows) that use
// that property are currently not changed since there is no danger of new
// properties using the same ID.  However, properties should normally be 
// initialized once at the application startup and uninitialized at application
// shutdown.
//
// ID types:
//   Unused:        0
//   Private:       Always negative
//   Global:        Always positive
//

enum PropType
{
    ptPrivate   = 1,       // Private entry only available to DirectUser/Core
    ptGlobal    = 2,       // Public entry available to all applications
};

typedef int PRID;

const PRID PRID_Unused       = 0;
const PRID PRID_PrivateMin   = -1;
const PRID PRID_GlobalMin    = 1;

inline bool ValidatePrivateID(PRID id);
inline bool ValidateGlobalID(PRID id);
inline PropType GetPropType(PRID id);


//------------------------------------------------------------------------------
class AtomSet
{
// Construction
public:
            AtomSet(PRID idStartGlobal = PRID_GlobalMin);
            ~AtomSet();

// Operations
public:
            HRESULT     AddRefAtom(LPCWSTR pszName, PropType pt, PRID * pprid);
            HRESULT     ReleaseAtom(LPCWSTR pszName, PropType pt);

            HRESULT     AddRefAtom(const GUID * pguidAdd, PropType pt, PRID * pprid);
            HRESULT     ReleaseAtom(const GUID * pguidSearch, PropType pt);

            PRID        FindAtomID(LPCWSTR pszName, PropType pt) const;
            PRID        FindAtomID(const GUID * pguidSearch, PropType pt) const;

// Implementation
protected:
    struct Atom
    {
        enum AtomFlags
        {
            tfString    = 0x0000,       // Atom ID is a string
            tfGUID      = 0x0001,       // Atom ID is a GUID

            tfTYPE      = 0x0001
        };

        Atom *      pNext;              // Next node
        ULONG       cRefs;              // Number of references
        PRID        id;                 // Shortened ID (Used with SetData())
        WORD        nFlags;             // Flags on Atom

        inline AtomFlags GetType() const
        {
            return (AtomFlags) (nFlags & tfTYPE);
        }
    };

    struct GuidAtom : Atom
    {
        GUID        guid;               // ID
    };

    struct StringAtom : Atom
    {
        int         cch;                // Number of characters (not including '\0')
        WCHAR       szName[1];          // Property name
    };

            StringAtom* FindAtom(LPCWSTR pszName, PropType pt, StringAtom ** pptemPrev) const;
            GuidAtom *  FindAtom(const GUID * pguidSearch, PropType pt, GuidAtom ** pptemPrev) const;

            PRID        GetNextID(PropType pt);
            BOOL        ValidatePrid(PRID prid, PropType pt);

// Data
protected:
    StringAtom* m_ptemString;       // Head of String list
    GuidAtom *  m_ptemGuid;         // Head of GUID list
    PRID        m_idNextPrivate;    // Next Core-only short ID to use
    PRID        m_idNextGlobal;     // Next externally available global short ID to use
};


//------------------------------------------------------------------------------
class DynaSet
{
// Construction
public:
    inline  DynaSet();
    inline  ~DynaSet();

// Operations
public:

// Implementation
protected:
    inline  BOOL        IsEmpty() const;
    inline  int         GetCount() const;
    inline  void        SetCount(int cNewItems);
            BOOL        AddItem(PRID id, void * pvData);
            void        RemoveAt(int idxData);

            int         FindItem(PRID id) const;
            int         FindItem(void * pvData) const;
            int         FindItem(PRID id, void * pvData) const;

// Data
protected:
    struct DynaData
    {
        void *      pData;              // (User) data
        PRID        id;                 // (Short) Property ID
    };

    GArrayS<DynaData> m_arData;         // Dynamic user data
};

#include "DynaSet.inl"

#endif // CORE__DynaSet_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\gmouse.cpp ===
/***************************************************************************\
*
* File: GMouse.cpp
*
* Description:
* GMouse.cpp implements mouse-related functions on DuRootGadget.
*
*
* History:
*  7/27/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::xdHandleMouseMessage
*
* xdHandleMouseMessage() is the starting point for all mouse messages coming
* from the container.  This entry point updates all mouse information cached
* in the DuRootGadget, including dragging and focus.  As the message is
* processed, the mouse location will be translated from container pixels
* into client-pixels relative to the Gadget to handle the message.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleMouseMessage(
    IN  GMSG_MOUSE * pmsg,          // Mouse message
    IN  POINT ptContainerPxl)       // Location of mouse in container pixels
{
    CoreSC * pSC = GetCoreSC();

    //
    // Check if we have started destruction.  If so, stop sending mouse 
    // messages.
    //

    if (m_fFinalDestroy) {
        return FALSE;
    }


    //
    // Change the message around, depending on what the mouse is doing.
    //

    GMSG_MOUSEDRAG mde;
    POINT ptClientPxl = { 0, 0 };
    DuVisual * pgadMouse = pSC->pgadDrag;

    if ((pgadMouse != NULL) && (pmsg->nCode == GMOUSE_MOVE) && (!pgadMouse->m_fAdaptor)) {
        //
        // Update drag information: Need to *promote* mouse moves to drags and
        // add extra info for drag message (then change message pointer to
        // point to this new version of the message structure)
        //
        *((GMSG_MOUSE*) &mde) = *pmsg;
        mde.cbSize  = sizeof(GMSG_MOUSEDRAG);
        mde.nCode   = GMOUSE_DRAG;
        mde.bButton = pSC->bDragButton;

        RECT rc;
        pgadMouse->GetLogRect(&rc, SGR_CLIENT);
        pgadMouse->MapPoint(ptContainerPxl, &ptClientPxl);

        mde.fWithin = PtInRect(&rc, ptClientPxl);

        pmsg = &mde;
    }

    //
    // Check if we actually need to process
    //

    if ((pmsg->nCode == GMOUSE_MOVE) &&
        (!TestFlag(GetWantEvents(), DuVisual::weDeepMouseMove | DuVisual::weDeepMouseEnter))) {
        return FALSE;  // Not completely handled
    }


    //
    // A "normal" mouse message, so find the proper control and send a
    // message.  The no drag operation is going on, find the DuVisual at the
    // current point.  If a drag operation is going on, need to transform
    // the current point into one relative to that DuVisual.
    //

    if ((pgadMouse != NULL) &&
            ((pmsg->nCode == GMOUSE_DRAG) || ((pmsg->nCode == GMOUSE_UP) && (pmsg->bButton == pSC->bDragButton)))) {

        //
        // A drag operation is going on.  If the mouse is either dragging,
        // OR (the button was released AND the button is the same as when
        // dragging started), send this message to the Gadget where
        // dragging started.
        //

        if (pmsg->nCode != GMOUSE_DRAG) {
            //
            // for mouse drag, we've already set ptClientPxl
            //
            pgadMouse->MapPoint(ptContainerPxl, &ptClientPxl);
        }
    } else {
        pgadMouse = FindFromPoint(ptContainerPxl, GS_VISIBLE | GS_ENABLED | gspDeepMouseFocus, &ptClientPxl);
        xdUpdateMouseFocus(&pgadMouse, &ptClientPxl);
    }

    if (pgadMouse != NULL) {
        return xdProcessGadgetMouseMessage(pmsg, pgadMouse, ptClientPxl);
    }

    return FALSE;  // Not completely handled
}        


/***************************************************************************\
*
* DuRootGadget::xdProcessGadgetMouseMessage
*
* xdProcessGadgetMouseMessage() handles a mouse message that has been 
* determined to "belong" to a specific Gadget.  At this point, the message
* has already been formatted to this specific Gadget.
*
\***************************************************************************/

BOOL
DuRootGadget::xdProcessGadgetMouseMessage(
    IN  GMSG_MOUSE * pmsg,              // Mouse message
    IN  DuVisual * pgadMouse,       // Gadget "owning" message
    IN  POINT ptClientPxl)              // Location of mouse in Gadget client pixels
{
    AssertMsg(pgadMouse != NULL, "Must specify valid Gadget");
    AssertMsg(pgadMouse->IsParentChainStyle(GS_VISIBLE | GS_ENABLED),
            "Gadget must be visible & enabled");

    CoreSC * pSC = GetCoreSC();

    //
    // Process the mouse message and update drag information.  
    //
    // NOTE: We must not affect dragging for Adaptor Gadgets.  This is because 
    // dragging affects mouse capture, which means that the HWND will not get 
    // the mouse message.
    //

    BOOL fAdaptor = pgadMouse->m_fAdaptor;

    switch (pmsg->nCode)
    {
    case GMOUSE_DOWN:
        if (pSC->pgadDrag == NULL) {
            //
            // User was not already dragging when they clicked the mouse
            // button, so start a drag operation.
            //
            // NOTE: We can only drag and automatically update keyboard focus 
            // for Adaptors.
            //
            // TODO: Provide a mechanism to that allows the adaptor to specify
            // what it supports.  This is because not all adaptors are HWND's.
            //

            if (!fAdaptor) {
                DuVisual * pgadCur = GetKeyboardFocusableAncestor(pgadMouse);
                if (pgadCur) {
                    xdUpdateKeyboardFocus(pgadCur);
                }
            }


            //
            // Update the click-count by determining if the up can form a proper 
            // double-click.  This is done so that the "down" mouse event will 
            // have a cClicks = 0 if it is a "regular" click and not part of a 
            // double-click.
            //
            // One additional requirement is that the click occurs in the same
            // Gadget.  We don't need to check this for UP, since we will always
            // send an up to match the down since we capture the mouse to 
            // perform the drag.
            // 

            if ((pSC->pressLast.pgadClick != pgadMouse) ||
                    (pSC->pressLast.bButton != pmsg->bButton) ||
                    ((UINT) (pmsg->lTime - pSC->pressLast.lTime) > GetDoubleClickTime())) {

                pSC->cClicks = 0;
            }

            GMSG_MOUSECLICK * pmsgM = static_cast<GMSG_MOUSECLICK *>(pmsg);
            pmsgM->cClicks          = pSC->cClicks;


            //
            // Store information about this event to be used when determining clicking
            //

            pSC->pressNextToLast    = pSC->pressLast;

            pSC->pressLast.pgadClick= pgadMouse;
            pSC->pressLast.bButton  = pmsg->bButton;
            pSC->pressLast.lTime    = pmsg->lTime;
            pSC->pressLast.ptLoc    = ptClientPxl;

            pSC->pgadDrag           = pgadMouse;
            pSC->ptDragPxl          = ptClientPxl;
            pSC->bDragButton        = pmsg->bButton;


            //
            // If starting a drag, need to capture the mouse.  We can only do 
            // this if not in an adaptor.
            //
            // TODO: In the future, we need to distinguish between HWND adaptors
            // (which we can't capture) and other adaptors, where we may need to
            // capture.  Don't forget the corresponding OnEndCapture() in the
            // GMOUSE_UP case as well.
            //

            if (!fAdaptor) {
                m_fUpdateCapture = TRUE;
                GetContainer()->OnStartCapture();
                m_fUpdateCapture = FALSE;
            }
        } else {
            //
            // User clicked another mouse button while dragging.  Don't
            // stop dragging, but send this mouse message through.  This
            // behavior is consistent with dragging the title-bar in an
            // HWND.
            //
        }
        break;

    case GMOUSE_UP:
        //
        // Update drag information: On button release, need to release
        // capture and all.
        //
        // NOTE: It is VERY important that dragging information is reset
        // BEFORE calling OnEndCapture(), or else releasing the capture
        // will send another GMOUSE_UP message.
        //

        if ((pSC->pgadDrag != NULL) && (pmsg->bButton == pSC->bDragButton)) {
            pSC->pgadDrag      = NULL;
            pSC->bDragButton   = GBUTTON_NONE;

            if (!fAdaptor) {
                m_fUpdateCapture = TRUE;
                GetContainer()->OnEndCapture();
                m_fUpdateCapture = FALSE;
            }


            //
            // Update the click-count
            //

            GMSG_MOUSECLICK * pmsgM = static_cast<GMSG_MOUSECLICK *>(pmsg);

            RECT rc;
            pgadMouse->GetLogRect(&rc, SGR_CLIENT);

            if (PtInRect(&rc, ptClientPxl)) {
                //
                // The up occurred within the bounds of this gadget, so 
                // treat this as a click.
                //

                if ((pSC->pressNextToLast.bButton == pSC->pressLast.bButton) &&
                        (pSC->pressLast.bButton == pmsg->bButton) &&
                        ((UINT) (pmsg->lTime - pSC->pressNextToLast.lTime) <= GetDoubleClickTime()) &&
                        (abs(ptClientPxl.x - pSC->pressNextToLast.ptLoc.x) <= GetSystemMetrics(SM_CXDOUBLECLK)) &&
                        (abs(ptClientPxl.y - pSC->pressNextToLast.ptLoc.y) <= GetSystemMetrics(SM_CYDOUBLECLK))) {

                    // 
                    // All signs point to this is a quick succession click, 
                    // so update the click count
                    // 

                    pSC->cClicks++;
                } else {
                    pSC->cClicks = 1;
                }

                pmsgM->cClicks = pSC->cClicks;
            } else {
               pmsgM->cClicks = 0;
            }
        } else {
            pSC->cClicks = 0;
        }
        break;

    case GMOUSE_DRAG:
        {
            AssertMsg(pSC->pgadDrag == pgadMouse, "Gadget being dragged must have the mouse");
            //
            // When dragging, give offset from the last location.  This is
            // helpful if the window that is receiving the drag messages
            // is itself being moved.
            //

            SIZE sizeOffset;
            sizeOffset.cx   = ptClientPxl.x - pSC->ptDragPxl.x;
            sizeOffset.cy   = ptClientPxl.y - pSC->ptDragPxl.y;

            GMSG_MOUSEDRAG * pmsgD = (GMSG_MOUSEDRAG *) pmsg;
            pmsgD->sizeDelta.cx   = sizeOffset.cx;
            pmsgD->sizeDelta.cy   = sizeOffset.cy;
        }
        break;
    }

    BOOL fSend   = TRUE;
    UINT nEvents = pgadMouse->GetWantEvents();

    if ((!TestFlag(nEvents, DuVisual::weMouseMove | DuVisual::weDeepMouseMove)) && (pmsg->nCode == GMOUSE_MOVE)) {
        fSend = FALSE;
    }

    if (fSend) {
        pmsg->ptClientPxl = ptClientPxl;
        pgadMouse->m_cb.xdFireMouseMessage(pgadMouse, pmsg);

        //
        // When we delay a mouse message, we need to assume that it may be
        // handled.  This means that we need to report that the message is
        // handled and should not be passed on.
        //
        return TRUE;
    }

    return FALSE;
}



/***************************************************************************\
*
* DuRootGadget::xdHandleMouseLostCapture
*
* xdHandleMouseLostCapture() is called by the container when mouse capture
* is lost.  This provides the DuRootGadget an opportunity to update any cached 
* information including dragging and focus.
*
\***************************************************************************/

void
DuRootGadget::xdHandleMouseLostCapture()
{
    //
    // If in the middle of updating the capture information, don't process here
    // or we will throw everything away.
    //

    if (m_fUpdateCapture) {
        return;
    }


    //
    // Cancel any dragging operation
    //

    CoreSC * pSC = GetCoreSC();

    if (pSC->pgadDrag != NULL) {
        if (!pSC->pgadDrag->m_fAdaptor) {
            GMSG_MOUSECLICK msg;
            msg.cbSize      = sizeof(msg);
            msg.nCode       = GMOUSE_UP;
            msg.bButton     = pSC->bDragButton;
            msg.ptClientPxl = pSC->ptDragPxl;
            msg.cClicks     = 0;

            pSC->pgadDrag->m_cb.xdFireMouseMessage(pSC->pgadDrag, &msg);
        }
        pSC->pgadDrag   = NULL;
    }


    //
    // Update enter/leave information
    //

    if (pSC->pgadRootMouseFocus != NULL) {
        xdUpdateMouseFocus(NULL, NULL);
    }
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateMouseFocus
*
* xdUpdateMouseFocus() updates cached information about which Gadget the
* mosue cursor is currently hovering over.  This information is used to
* generate GM_CHANGESTATE: GSTATE_MOUSEFOCUS events.
*
\***************************************************************************/

void
DuRootGadget::xdUpdateMouseFocus(
    IN OUT DuVisual ** ppgadNew,    // New Gadget containing the mouse cursor
    IN OUT POINT * pptClientPxl)        // Point inside Gadget, in client coordinates
{
    CoreSC * pSC            = GetCoreSC();
    DuVisual * pgadLost = pSC->pgadMouseFocus;
    DuVisual * pgadNew  = ppgadNew != NULL ? *ppgadNew : NULL;


    //
    // If we have started destruction, don't continue to update the mouse focus.
    // Instead, push it to the Root and keep it there.
    //

    if (m_fFinalDestroy) {
        *ppgadNew = this;
        pptClientPxl = NULL;
    }


    //
    // Walk up the tree looking for the first Gadget that wants mouse focus.
    // We also need to convert the given point into new client coordinates for
    // each level.
    //

    if (pptClientPxl != NULL) {
        //
        // No point to translate, so just walk back up
        //

        while (pgadNew != NULL) {
            if (pgadNew->m_fMouseFocus) {
                //
                // Found a Gadget that wants mouse focus
                //

                break;
            }

            pgadNew->DoXFormClientToParent(pptClientPxl, 1);
            pgadNew = pgadNew->GetParent();
        }
    } else {
        //
        // No point to translate, so just walk back up
        //

        while (pgadNew != NULL) {
            if (pgadNew->m_fMouseFocus) {
                //
                // Found a Gadget that wants mouse focus
                //

                break;
            }
            pgadNew = pgadNew->GetParent();
        }
    }

    if (ppgadNew != NULL) {
        *ppgadNew = pgadNew;
    }


    //
    // Update which Gadget has mouse focus
    //

    if ((pSC->pgadRootMouseFocus != this) || (pgadLost != pgadNew)) {
        //
        // Send messages to the gadgets to notify them of the change.  Since 
        // these messages are deferred, we can only use the handles if the 
        // Gadgets have not started their destruction process.
        //

        xdFireChangeState(&pgadLost, &pgadNew, GSTATE_MOUSEFOCUS);
        if (ppgadNew != NULL) {
            *ppgadNew = pgadNew;
        }

        //
        // Update internal information about where we are and start mouse
        // capture so that we can find when we leave.
        //
        // NOTE: We DON'T want to track the mouse when we are actually in an
        // Adaptor.  This is because the mouse is actually in the Adaptor.
        //

        if (pgadNew != NULL) {
            pSC->pgadMouseFocus = pgadNew;

            if (pSC->pgadRootMouseFocus != this) {
                pSC->pgadRootMouseFocus  = this;

                if (!pgadNew->m_fAdaptor) {
                    GetContainer()->OnTrackMouseLeave();
                }
            }
        } else {
            pSC->pgadRootMouseFocus = NULL;
            pSC->pgadMouseFocus     = NULL;
        }
    }

    AssertMsg(((pgadNew == NULL) && (ppgadNew == NULL)) || 
            (pgadNew == *ppgadNew),
            "Ensure match");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\gkeyboard.cpp ===
/***************************************************************************\
*
* File: GKeyboard.cpp
*
* Description:
* GKeyboard.cpp implements keyboard-related functions on DuRootGadget.
*
*
* History:
*  7/27/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::xdHandleKeyboardFocus
*
* xdHandleKeyboardFocus() is called by the DuContainer to update keyboard 
* focus information inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleKeyboardFocus(
    IN  UINT nCmd)                  // Command to handle
{
    CoreSC * pSC = GetCoreSC();

    switch (nCmd)
    {
    case GSC_SET:
        //
        // When we get a request to set keyboard focus, we should not already
        // have keyboard focus.  This is because we should have already 
        // processed a message from when we last lost keyboard focus for either
        // the DuRootGadget or any nested Adaptors inside.
        //

        if (pSC->pgadCurKeyboardFocus != NULL) {
            if (pSC->pgadCurKeyboardFocus->m_fAdaptor) {
                PromptInvalid("Adaptor did not reset keyboard focus when lost");
//                pSC->pgadCurKeyboardFocus = NULL;
            }
        }

        AssertMsg(pSC->pgadCurKeyboardFocus == NULL, "Should not have any gadget already with focus");
        return xdUpdateKeyboardFocus(pSC->pgadLastKeyboardFocus);

    case GSC_LOST:
        //
        // We can loose keyboard focus both on the DuRootGadget or on any Adaptor
        // that is forwarding the message to be processed.  This is because an
        // Adaptor can not call SetGadgetFocus(NULL) to remove keyboard focus, 
        // so it needs to forward the WM_KILLFOCUS message to our DuRootGadget for
        // processing.  
        //
        // This is okay since if the DuRootGadget is receiving keyboard focus, it
        // will get the WM_SETFOCUS after the Adaptor has already sent its
        // WM_KILLFOCUS message.
        //

        return xdUpdateKeyboardFocus(NULL);

    default:
        AssertMsg(0, "Unknown value");
        return FALSE;
    }
}


/***************************************************************************\
*
* DuRootGadget::xdHandleKeyboardMessage
*
* xdHandleKeyboardMessage() is called by the DuContainer to process keyboard
* messages inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleKeyboardMessage(
    IN  GMSG_KEYBOARD * pmsg,       // Message to handle
    IN  UINT nMsgFlags)             // Message flags
{
    CoreSC * pSC = GetCoreSC();

    //
    // NOTE: 
    // 
    // For non-Adaptor Gadgets:
    // We need to signal that the message was NOT completely handled.  If we 
    // say that it isn't completely handled, the message will get sent again by
    // the original (non-subclassed) WNDPROC.  If was say the message was 
    // handled, then it won't be passed to the original WNDPROC.  If it isn't
    // sent to the original WNDPROC, this can mess things up for keyboard 
    // messages that the system handles, such as starting the menus.
    //
    // For Adaptor Gadgets:
    // Need to signal that the message is completely handled because we DON'T
    // want to forward the message to DefWindowProc() because it was originally
    // meant for the Adaptor window.
    //

    if (pSC->pgadCurKeyboardFocus != NULL) {
        BOOL fAdaptor = pSC->pgadCurKeyboardFocus->m_fAdaptor;

        if (fAdaptor && (!TestFlag(nMsgFlags, DuContainer::mfForward))) {
            //
            // Don't allow NON forwarded messages to be sent to an Adaptor.
            // These were originally sent to the DuRootGadget and should NOT be
            // forwarded outside.  If we do forward them to the Adaptor, this 
            // can (and often will) create an infinite loop of messages being
            // sent from a child Adaptor to the parentand then back to the 
            // child.
            //

            return FALSE;
        }

        pSC->pgadCurKeyboardFocus->m_cb.xdFireKeyboardMessage(pSC->pgadCurKeyboardFocus, pmsg);

        return fAdaptor;
    }

    return FALSE;  // Not completely handled
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateKeyboardFocus
*
* xdUpdateKeyboardFocus() simulates keyboard focus between different Gadgets 
* by updating where focus is "set".  A Gadget must have GS_KEYBOARDFOCUS 
* set to "receive" focus.
*
\***************************************************************************/

BOOL
DuRootGadget::xdUpdateKeyboardFocus(
    IN  DuVisual * pgadNew)       // New Gadget with focus
{
    if (m_fUpdateFocus) {
        return TRUE;
    }

    if (m_fFinalDestroy) {
        pgadNew = NULL;
    }

    m_fUpdateFocus          = TRUE;
    DuVisual * pgadCur    = pgadNew;

    //
    // First, check if loosing the focus (special case)
    //

    if (pgadNew == NULL) {
        goto Found;
    }

    //
    // Find keyboard focusable ancestor -- if none, then remove focus (indicated by pgadCur being NULL)
    //

    pgadCur = GetKeyboardFocusableAncestor(pgadCur);

Found:
    CoreSC * pSC            = GetCoreSC();
    if (pSC->pgadCurKeyboardFocus != pgadCur) {
        //
        // Found a candidate.  We need to do several things:
        // 1. Notify the old gadget that it no longer has focus.
        // 2. Notify the new gadget that it now has focus.
        // 3. Update the last gadget focus (this is used when our container
        //    gets a GM_CHANGEFOCUS message.
        //

        HGADGET hgadLost    = (HGADGET) ::GetHandle(pSC->pgadCurKeyboardFocus);
        HGADGET hgadSet     = (HGADGET) ::GetHandle(pgadCur);

        if (pSC->pgadCurKeyboardFocus != NULL) {
            pSC->pgadCurKeyboardFocus->m_cb.xdFireChangeState(pSC->pgadCurKeyboardFocus, GSTATE_KEYBOARDFOCUS, hgadLost, hgadSet, GSC_LOST);
            pSC->pgadLastKeyboardFocus = pSC->pgadCurKeyboardFocus;
        }

        pSC->pgadCurKeyboardFocus  = NULL;

        if (pgadCur != NULL) {
            if (!pgadCur->m_fAdaptor) {
                GetContainer()->OnSetFocus();
            }
            pgadCur->m_cb.xdFireChangeState(pgadCur, GSTATE_KEYBOARDFOCUS, hgadLost, hgadSet, GSC_SET);
            pSC->pgadLastKeyboardFocus = pgadCur;
        }

        pSC->pgadCurKeyboardFocus  = pgadCur;
    }

    m_fUpdateFocus = FALSE;

#if 0
    if (pgadNew != pgadCur) {
        Trace("WARNING: DUser: xdUpdateKeyboardFocus() requested 0x%p, got 0x%p\n", pgadNew, pgadCur);
        if (pgadNew != NULL) {
            Trace("  pgadNew: Adaptor: %d\n", pgadNew->m_fAdaptor);
        }
        if (pgadCur != NULL) {
            Trace("  pgadCur: Adaptor: %d\n", pgadCur->m_fAdaptor);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\gpaint.cpp ===
/***************************************************************************\
*
* File: GPaint.cpp
*
* Description:
* GPaint.cpp implements standard DuVisual drawing and painting functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

#define ENABLE_GdiplusAlphaLevel    0   // Use new GDI+ Graphics::AlphaLevel attribute

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL
GdDrawOutlineRect(DuSurface * psrf, const RECT * prcPxl, UINT idxColor, int nThickness)
{
    switch (psrf->GetType())
    {
    case DuSurface::stDC:
        return GdDrawOutlineRect(CastHDC(psrf), prcPxl, GetStdColorBrushI(idxColor), nThickness);

    case DuSurface::stGdiPlus:
        return GdDrawOutlineRect(CastGraphics(psrf), prcPxl, GetStdColorBrushF(idxColor), nThickness);

    default:
        AssertMsg(0, "Unsupported surface");
        return FALSE;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::DrawFill
*
* DrawFill() provides a wrapper used to fill a rectangle with the attached
* background fill.
*
\***************************************************************************/

void        
DuVisual::DrawFill(
    IN  DuSurface * psrf,             // Surface drawing into
    IN  const RECT * prcDrawPxl)    // Rectangle to fill
{
    AssertMsg(m_fBackFill, "Only call when filling");

    FillInfo * pfi;
    VerifyHR(m_pds.GetData(s_pridBackFill, (void **) &pfi));

    if (psrf->GetType() == pfi->type) {
        switch (pfi->type)
        {
        case DuSurface::stDC:
            {
                HDC hdcDraw = CastHDC(psrf);
                if (pfi->bAlpha != BLEND_OPAQUE) {
                    GdDrawBlendRect(hdcDraw, prcDrawPxl, pfi->hbrFill, pfi->bAlpha, pfi->sizeBrush.cx, pfi->sizeBrush.cy);
                } else {
                    FillRect(hdcDraw, prcDrawPxl, pfi->hbrFill);
                }
            }
            break;

        case DuSurface::stGdiPlus:
            {
                Gdiplus::Graphics * pgpgr = CastGraphics(psrf);
                Gdiplus::RectF rc = Convert(prcDrawPxl);
                pgpgr->FillRectangle(pfi->pgpbr, rc);
            }
            break;

        default:
            AssertMsg(0, "Unsupported surface");
        }
    }
}


#if DEBUG_DRAWSTATS
volatile static int s_cDrawEnter    = 0;
volatile static int s_cDrawVisible  = 0;
volatile static int s_cDrawDrawn    = 0;

class DumpDrawStats
{
public:
    ~DumpDrawStats()
    {
        char szBuffer[2048];
        wsprintf(szBuffer, "Draw Enter: %d,  Visible: %d,  Drawn: %d\n", 
                s_cDrawEnter, s_cDrawVisible, s_cDrawDrawn);

        OutputDebugString(szBuffer);
    }
} g_DumpDrawStats;
#endif // DEBUG_DRAWSTATS

#if DEBUG_MARKDRAWN
volatile BOOL g_fFlagDrawn   = FALSE;
#endif // DEBUG_MARKDRAWN


/***************************************************************************\
*
* DuVisual::xrDrawCore
*
* xrDrawCore() provides the core drawing loop for an individual Gadget and 
* its children.  It is assumed that the HDC and Matricies have already been
* properly setup with clipping, XForm, etc. information.
*
\***************************************************************************/

void        
DuVisual::xrDrawCore(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const RECT * prcGadgetPxl)  // Location of Gadget in logical pixels
{
#if DBG_STORE_NAMES
    if (m_DEBUG_pszName == NULL) {
        m_cb.xrFireQueryName(this, &m_DEBUG_pszName, &m_DEBUG_pszType);
    }
#endif // DBG_STORE_NAMES
    
#if ENABLE_OPTIMIZEDIRTY
    //
    // We only need to be painted if we are specifically marked as invalid.
    //

    if (ppi->fDirty) {
#endif

        DuSurface * psrfDraw = ppi->psrf;

        //
        // prcCurInvalidPxl has not yet always been clipped to this Gadget.
        // However, before handing it out to anyone, we should clip it to this
        // Gadget.  If we don't do this, bad things will happen since everyone 
        // assumes that the invalid pixels are "within" the Gadget.  They have 
        // already been properly offsetted into client coordinates.
        //

        RECT rcInvalidPxl;
        InlineIntersectRect(&rcInvalidPxl, prcGadgetPxl, ppi->prcCurInvalidPxl);


        //
        // Draw a background, if one is given.
        //

        if (m_fBackFill) {
            DrawFill(psrfDraw, &rcInvalidPxl);
        }


        //
        // Draw this node
        //

        switch (psrfDraw->GetType())
        {
        case DuSurface::stDC:
            m_cb.xrFirePaint(this, CastHDC(psrfDraw), prcGadgetPxl, &rcInvalidPxl);
            break;

        case DuSurface::stGdiPlus:
            m_cb.xrFirePaint(this, CastGraphics(psrfDraw), prcGadgetPxl, &rcInvalidPxl);
            break;

        default:
            AssertMsg(0, "Unsupported surface");
        }

#if ENABLE_OPTIMIZEDIRTY
    }
#endif

#if DBG
    if (s_DEBUG_pgadOutline == this) {
        GdDrawOutlineRect(psrfDraw, prcGadgetPxl, SC_MediumPurple, 2);
    }
#endif // DBG

#if DEBUG_MARKDRAWN
    if (m_fMarkDrawn) {
        GdDrawOutlineRect(psrfDraw, prcGadgetPxl, SC_SlateBlue);
    }
#endif
}


/***************************************************************************\
*
* DuVisual::DrawPrepareClip
*
* DrawPrepareClip() sets up a surface with clipping information for the 
* specifed Gadget.
*
\***************************************************************************/

int 
DuVisual::DrawPrepareClip(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const RECT * prcGadgetPxl,  // Location of Gadget in logical pixels
    OUT void ** ppvOldClip          // Previous clip region
    ) const
{
    *ppvOldClip = NULL;

    if (!m_fClipInside) {
        // No clipping, so just bypass.  Return a valid "psuedo-region" type.
        return SIMPLEREGION;
    }

    DuSurface * psrfDraw = ppi->psrf;
    switch (psrfDraw->GetType())
    {
    case DuSurface::stDC:
        {
            HDC hdcDraw = CastHDC(psrfDraw);
            GdiCache * pGdiCache = GetGdiCache();

            //
            // Backup the existing clipping region.  Do this by grabbing a temporary
            // region and storing the existing region.  
            //
            // NOTE: If there is not clipping region (nResult == 0), release the 
            // temporary region now.
            //

            HRGN hrgnOldClip = pGdiCache->GetTempRgn();
            if (hrgnOldClip == NULL) {
                return ERROR;
            }

            int nResult = GetClipRgn(hdcDraw, hrgnOldClip);
            if (nResult == -1) {
                //
                // An error occurred
                //
                
                pGdiCache->ReleaseTempRgn(hrgnOldClip);
                return ERROR;
            } else if (nResult == 0) {
                //
                // No clipping region
                //
                
                pGdiCache->ReleaseTempRgn(hrgnOldClip);
                hrgnOldClip = NULL;
            }
            *ppvOldClip = hrgnOldClip;


            //
            // Clip drawing inside this Gadget.  The clipping region must be in 
            // device coordinates, which means that our beautiful world transforms 
            // are ignored.
            //
            // Build the region and RGN_AND it with the current clipping region.  This 
            // way, we get the intersection of this Gadget's clipping region and its 
            // parent's clipping region.  Thus, the drawing will not "spill" outside of
            // all of the levels of containment.
            //
            // Since we do this AND'ing, we store the previous clipping region and 
            // restore it when finished.
            //

            HRGN hrgnClip = GetThread()->hrgnClip;
            ppi->pmatCurDC->ComputeRgn(hrgnClip, prcGadgetPxl, ppi->sizeBufferOffsetPxl);

            nResult = ExtSelectClipRgn(hdcDraw, hrgnClip, RGN_AND);

            return nResult;
        }

    case DuSurface::stGdiPlus:
        {
            Gdiplus::Graphics * pgpgr = CastGraphics(psrfDraw);

            //
            // Backup the old clipping region
            //

            Gdiplus::Region * pgprgnOldClip = new Gdiplus::Region();
            if (pgprgnOldClip == NULL) {
                return ERROR;
            }
            
            pgpgr->GetClip(pgprgnOldClip);
            *ppvOldClip = pgprgnOldClip;


            //
            // Setup a new clipping region.  Unlike GDI, GDI+ will apply 
            // XForm's to the region.
            //

            RECT rcClipPxl;
            InlineIntersectRect(&rcClipPxl, prcGadgetPxl, ppi->prcCurInvalidPxl);

            Gdiplus::RectF rcGadget(Convert(&rcClipPxl));

            pgpgr->SetClip(rcGadget, Gdiplus::CombineModeIntersect);

            if (pgpgr->IsClipEmpty()) {
                return NULLREGION;
            } else {
                return COMPLEXREGION;
            }
        }

    default:
        AssertMsg(0, "Unknown surface type");
        return ERROR;
    }
}


/***************************************************************************\
*
* DuVisual::DrawCleanupClip
*
* DrawCleanupClip() cleans up clipping information set on a DC during the
* drawing of a Gadget subtree.
*
\***************************************************************************/

void
DuVisual::DrawCleanupClip(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  void * pvOldClip            // Previous clip region
    ) const
{
    if (!m_fClipInside) {
        return;
    }

    DuSurface * psrfDraw = ppi->psrf;
    switch (psrfDraw->GetType())
    {
    case DuSurface::stDC:
        {
            HDC hdcDraw = CastHDC(psrfDraw);
            HRGN hrgnOldClip = reinterpret_cast<HRGN>(pvOldClip);

            //
            // Restore the original clipping region (the clipping region of this
            // Gadget's parent).
            //
            // NOTE: hrgnOldClip may be NULL if there was no original clipping region.
            // In this case, the clipping region has already been released, so don't 
            // need to do this again.
            //

            ExtSelectClipRgn(hdcDraw, hrgnOldClip, RGN_COPY);

            if (hrgnOldClip != NULL) {
                GetGdiCache()->ReleaseTempRgn(hrgnOldClip);
            }
        }
        break;

    case DuSurface::stGdiPlus:
        {
            Gdiplus::Graphics * pgpgr = CastGraphics(psrfDraw);
            Gdiplus::Region * pgprgn = reinterpret_cast<Gdiplus::Region *>(pvOldClip);

            pgpgr->SetClip(pgprgn);

            if (pgprgn != NULL) {
                delete pgprgn;
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
    }
}


/***************************************************************************\
*
* DuVisual::xrDrawStart
*
* xrDrawStart() kicks off the the drawing process by ensuring that 
* everything is ready.
*
\***************************************************************************/

void        
DuVisual::xrDrawStart(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  UINT nFlags)                // Drawing flags
{
#if DEBUG_DRAWSTATS
    s_cDrawEnter++;
#endif

    //
    // Skip out if the DuVisual is not visible and not forcably being 
    // rendered.
    //

    BOOL fOldVisible = m_fVisible;
    if (TestFlag(nFlags, GDRAW_SHOW)) {
        m_fVisible = TRUE;
    }

    ClearFlag(nFlags, GDRAW_SHOW);  // Only force shown for top level

    if (!IsVisible()) {
        goto Exit;
    }

    xrDrawFull(ppi);

    ResetInvalid();

Exit:
    m_fVisible = fOldVisible;
}


/***************************************************************************\
*
* DuVisual::DrawSetupBufferCommand
*
* DrawSetupBufferCommand() sets up the buffer to perform some buffering
* operation.
*
\***************************************************************************/

void
DuVisual::DrawSetupBufferCommand(
    IN  const RECT * prcBoundsPxl,
    OUT SIZE * psizeBufferOffsetPxl,
    OUT UINT * pnCmd
    ) const
{
    UINT nCmd = 0;

    //
    // TODO: If performing more complicated buffering operations (such as 
    // applying an alpha blend), need to setup here.
    //


    //
    // Need to copy the background over if:
    // - We are not opaque AND we are not doing some complex alpha-blending
    //   stuff.
    //


    //
    // Copy back remaining settings
    //

    psizeBufferOffsetPxl->cx = -prcBoundsPxl->left;
    psizeBufferOffsetPxl->cy = -prcBoundsPxl->top;
    *pnCmd = nCmd;
}


/***************************************************************************\
*
* DuVisual::xrDrawFull
*
* xrDrawFull() provides the low-level DuVisual drawing function to draw a 
* DuVisual and its subchildren.  This function should not be called 
* directly from outside.  Instead, external callers should use 
* DuRootGadget::xrDrawTree() to properly initialize drawing.
*
* As the DuVisual tree is walked in a depth-first manner, any DuVisual 
* XForm is applied to both the HDC and the PaintInfo.Matrix.  If a 
* DuVisual's bounding rectangle (logical rect with XForm's applied) is 
* applied and is determined to be outside the invalid rectangle, both that 
* DuVisual and its entire sub-tree are skipped.
*
\***************************************************************************/

void        
DuVisual::xrDrawFull(
    IN  PaintInfo * ppi)            // Painting information for this Gadget
{
#if DEBUG_DRAWSTATS
    s_cDrawEnter++;
#endif

    //
    // Check entry conditions
    //

    if (!m_fVisible) {
        return;  // DuVisual is still not visible, so don't draw.
    }
    AssertMsg(IsVisible(), "Should match just checking m_fVisible b/c recursive");
    AssertMsg(!IsRectEmpty(ppi->prcOrgInvalidPxl), "Must have non-empty invalid area to draw");

#if DEBUG_DRAWSTATS
    s_cDrawVisible++;
#endif


    //
    // Keep track of the different items that may need to be "popped" off the
    // stack at the end of this iteration.
    //

    PaintInfo piNew;
    HRESULT hr;

#if DBG
    memset(&piNew, 0xBA, sizeof(piNew));
#endif // DBG

    piNew.psrf                  = ppi->psrf;
    piNew.prcOrgInvalidPxl      = ppi->prcOrgInvalidPxl;
    piNew.fBuffered             = ppi->fBuffered;
    piNew.sizeBufferOffsetPxl   = ppi->sizeBufferOffsetPxl;
#if ENABLE_OPTIMIZEDIRTY
    piNew.fDirty                = ppi->fDirty | m_fInvalidDirty;
#endif


    //
    // Setup common operations for caching and buffering:
    // - Disable any world transformations on the destination.  We will draw 
    //   into the buffer with the world transformations, but we don't need
    //   to apply the world transformations on the buffer when we commit it to
    //   the destination.
    //

    //
    // Setup if cached
    // TODO: Need to totally rewrite this
    //

    BmpBuffer * pbufBmp = NULL;
    BOOL fNewBuffer = FALSE;
    BOOL fNewCache = FALSE;
#if ENABLE_GdiplusAlphaLevel
    BOOL fConstantAlpha = FALSE;
    float flOldAlphaLevel = 1.0f;       // Old alpha-level for this sub-tree
#endif

    if (m_fCached) {
SetupCache:
        BmpBuffer * pbufNew;
        hr = GetBufferManager()->GetCachedBuffer(ppi->psrf->GetType(), &pbufNew);
        if (FAILED(hr)) {
            //
            // If can't cache, can't draw.
            //
            // TODO: Need to figure out how to propagate error conditions 
            // during drawing.
            //
            return;
        }

        ppi->psrf->SetIdentityTransform();
        pbufBmp = pbufNew;


        //
        // Because we redraw everything inside a cache, we need to compute 
        // a new bounding box for the entire Gadget and new invalidation boxes
        // for this subtree.
        //

        //
        // TODO: Need to change invalidation to support caching.
        // - When a child of an GS_CACHED Gadget is invalidated, need to 
        //   invalidate the _entire_ cached Gadget.  This is because pixels can
        //   get moved all around (for example, with a convolution).
        // - Change painting so that if the GS_CACHED Gadget is dirty, it spawns
        //   off and redraws that Gadget.  When finished, commits the drawing 
        //   back.
        // - If not dirty, just directly copy without calling xrDrawCore() or
        //   drawing any children.
        //

        UINT nCmd;                  // Buffer drawing command
        RECT rcClientPxl;           // Size of this Gadget (sub-tree)
        RECT rcBoundsPxl;           // Bounding area (in Container pixels) of this sub-tree
        RECT rcDrawPxl;             // Destination area being redrawn
        SIZE sizeBufferOffsetPxl;   // New offset to account for buffer
        Matrix3 matThis;            // XForm's for this sub-tree

        GetLogRect(&rcClientPxl, SGR_CLIENT);
        BuildXForm(&matThis);
        matThis.ComputeBounds(&rcBoundsPxl, &rcClientPxl, HINTBOUNDS_Clip);

        rcDrawPxl = rcBoundsPxl;
        OffsetRect(&rcDrawPxl, ppi->sizeBufferOffsetPxl.cx, ppi->sizeBufferOffsetPxl.cy);

        DrawSetupBufferCommand(&rcBoundsPxl, &sizeBufferOffsetPxl, &nCmd);

        DuSurface * psrfNew;
        hr = pbufBmp->BeginDraw(ppi->psrf, &rcDrawPxl, nCmd, &psrfNew);
        if (FAILED(hr) || (psrfNew == NULL)) {
            GetBufferManager()->ReleaseCachedBuffer(pbufNew);
            return;
        }

        fNewCache       = TRUE;
        piNew.psrf      = psrfNew;
        piNew.fBuffered = TRUE;
        piNew.sizeBufferOffsetPxl = sizeBufferOffsetPxl;
    } else {
        //
        // Only can (need to) buffer if not cached.
        //
        // If not changing the alpha value, we only need to double-buffer this 
        // specific form if we haven't started double-buffering.
        //

        if (m_fBuffered) {
            if (!ppi->fBuffered) {
                UINT nCmd;                  // Buffer drawing command
                SIZE sizeBufferOffsetPxl;   // New offset to account for buffer
                const RECT * prcDrawPxl = ppi->prcCurInvalidPxl;

                AssertMsg((ppi->sizeBufferOffsetPxl.cx == 0) &&
                        (ppi->sizeBufferOffsetPxl.cy == 0), 
                        "Should still be at 0,0 because not yet buffering");

                DrawSetupBufferCommand(prcDrawPxl, &sizeBufferOffsetPxl, &nCmd);

                switch (ppi->psrf->GetType())
                {
                case DuSurface::stDC:
                    hr = GetBufferManager()->GetSharedBuffer(prcDrawPxl, (DCBmpBuffer **) &pbufBmp);
                    break;

                case DuSurface::stGdiPlus:
                    hr = GetBufferManager()->GetSharedBuffer(prcDrawPxl, (GpBmpBuffer **) &pbufBmp);
                    break;

                default:
                    AssertMsg(0, "Unsupported surface");
                    hr = DU_E_GENERIC;
                }

                //
                // Create a new surface for the buffer
                //

                if (SUCCEEDED(hr)) {
                    DuSurface * psrfNew;
                    ppi->psrf->SetIdentityTransform();
                    hr = pbufBmp->BeginDraw(ppi->psrf, prcDrawPxl, nCmd, &psrfNew);
                    if (SUCCEEDED(hr) && (psrfNew != NULL)) {
                        fNewBuffer      = TRUE;
                        piNew.psrf      = psrfNew;
                        piNew.fBuffered = TRUE;
                        piNew.sizeBufferOffsetPxl = sizeBufferOffsetPxl;
                    } else {
                        //
                        // Unable to successfully create the surface, we need to release
                        // the buffer
                        //

                        GetBufferManager()->ReleaseSharedBuffer(pbufBmp);
                        pbufBmp = NULL;
                    }
                }
            } else {
#if ENABLE_GdiplusAlphaLevel
            
                //
                // Using buffering to achieve fading.
                //
            
                const BUFFER_INFO * pbi = GetBufferInfo();

                switch (ppi->psrf->GetType())
                {
                case DuSurface::stDC:
                    //
                    // GDI doesn't support constant alpha on all operations, 
                    // so we need to draw into a buffer.
                    //
                    
                    if (pbi->bAlpha != BLEND_OPAQUE) {
                        //
                        // This Gadget is being buffered, but has a non-opaque
                        // alpha level.  To accomplish this, treat it the same as 
                        // if it was explicitely cached.
                        //

                        goto SetupCache;
                    }
                    break;

                case DuSurface::stGdiPlus:
                    {
                        //
                        // GDI+ supports constant alpha, so use that directly.
                        //

                        Gdiplus::Graphics * pgpgr = CastGraphics(piNew.psrf);
                        float flOldAlphaLevel = pgpgr->GetAlphaLevel();

                        int nAlpha = pbi->bAlpha;
                        if (nAlpha == 0) {
                            //
                            // Nothing to render
                            //
                            
                            return;
                        } else if (nAlpha == BLEND_OPAQUE) {
                            //
                            // No new alpha-level for this sub-tree
                            //
                        } else {
                            //
                            // Factor this sub-tree's alpha into the Graphics
                            //
                            
                            float flNewAlphaLevel = flOldAlphaLevel * (nAlpha / (float) BLEND_OPAQUE);
                            pgpgr->SetAlphaLevel(flNewAlphaLevel);
                            fConstantAlpha = TRUE;
                        }
                    }
                    break;

                default:
                    AssertMsg(0, "Unsupported surface");
                    hr = DU_E_GENERIC;
                }

#else // ENABLE_GdiplusAlphaLevel

                const BUFFER_INFO * pbi = GetBufferInfo();
                if (pbi->bAlpha != BLEND_OPAQUE) {
                    //
                    // This Gadget is being buffered, but has a non-opaque
                    // alpha level.  To accomplish this, treat it the same as 
                    // if it was explicitely cached.
                    //

                    goto SetupCache;
                }

#endif // ENABLE_GdiplusAlphaLevel

            }
        }
    }


    //
    // Prefill the new buffer
    //

    if (pbufBmp != NULL) {
        if (m_fBuffered) {
            const BUFFER_INFO * pbi = GetBufferInfo();
            if (TestFlag(pbi->nStyle, GBIS_FILL)) {
                pbufBmp->Fill(pbi->crFill);
            }
        }
    }


    //
    // Use positioning, transforms, etc. to determine where the DuVisual will
    // be drawn on the screen.
    //

    RECT rcGadgetPxl;
    GetLogRect(&rcGadgetPxl, SGR_PARENT);

    BOOL fTranslate = ((rcGadgetPxl.left != 0) || (rcGadgetPxl.top != 0));

    float flxGadgetOffset, flyGadgetOffset;
    flxGadgetOffset = (float) rcGadgetPxl.left;
    flyGadgetOffset = (float) rcGadgetPxl.top;

    XFormInfo * pxfi = NULL;

    //
    // New transformations must be first created independently, then
    // folded into the running matrix used to transform the invalid
    // rectangle.
    //
    // Order matters here.  It has to be the INVERSE of whatever 
    // GDI World Transforms we setup to draw with.  This is because we are 
    // applying the Matrix on invalid rectangle instead of the actually 
    // drawing.
    //

    Matrix3 matNewInvalid   = *ppi->pmatCurInvalid;
    piNew.pmatCurInvalid    = &matNewInvalid;
    if (m_fXForm) {
        pxfi = GetXFormInfo();

        Matrix3 matOp;
        pxfi->ApplyAnti(&matOp);
        matNewInvalid.ApplyRight(matOp);
    }

    if (fTranslate) {
        //
        // When we are only performing translation, so we don't need to use the
        // matrix to modify the invalid rect and perform hit testing.
        //

        matNewInvalid.Translate(-flxGadgetOffset, -flyGadgetOffset);
    } 


    //
    // Check if actually need to draw by computing the bounds of the DuVisual to
    // be drawn.  If this DuVisual intersects the invalid region, it should be
    // drawn.  We also intersect the bounds with the parents bounds to not 
    // include the portion of child DuVisuals that overflow outside their parents.
    //
    // Intersect the current DuVisual's rectangle with the invalid region to 
    // determine if we need to draw it.
    //

    bool fIntersect;
    RECT rcNewInvalidPxl;
    piNew.prcCurInvalidPxl = &rcNewInvalidPxl;
    if (m_fXForm) {    
        //
        // Since we are rotating or scaling, we need the full translation 
        // matrix to modify the invalid rect properly.  (No guessing).
        //

        matNewInvalid.ComputeBounds(&rcNewInvalidPxl, ppi->prcOrgInvalidPxl, HINTBOUNDS_Invalidate);
    } else {
        //
        // Perform a simple invalidation intersection without a Matrix
        // transformation.
        //

        rcNewInvalidPxl = *ppi->prcCurInvalidPxl;
        if (fTranslate) {
            InlineOffsetRect(&rcNewInvalidPxl, -rcGadgetPxl.left, -rcGadgetPxl.top);
        }
    }

    if (fTranslate) {
        InlineZeroRect(&rcGadgetPxl);
    }

    RECT rcDummy = rcNewInvalidPxl;
    fIntersect = InlineIntersectRect(&rcNewInvalidPxl, &rcDummy, &rcGadgetPxl);

    //
    // Draw this DuVisual if it intersects with the logical invalid area.
    //

#if DEBUG_MARKDRAWN
    if (g_fFlagDrawn) {
        m_fMarkDrawn = fIntersect;
    }
#endif

    BOOL fCleanedUp = FALSE;
    if (fIntersect) {
#if DEBUG_DRAWSTATS
        s_cDrawDrawn++;
#endif

        //
        // Set DC to be the same as the current Matrix.  We only do this if we
        // are actually going to draw this Gadget (and its children), which is
        // why we didn't do this when we were calculating the intersection 
        // matrix earlier.
        //
        // Right before calling the GDI operation to modify the DC, we need to 
        // also offset by the current buffer offset.  We do a similar thing 
        // when setting up the DC, but this is not reflected in pmatCurDC 
        // because it must be the last operation in the Matrix pipeline.
        //

        Matrix3 matNewDC    = *ppi->pmatCurDC;
        piNew.pmatCurDC     = &matNewDC;

        if (fTranslate) {
            matNewDC.Translate(flxGadgetOffset, flyGadgetOffset);
        }

        if (m_fXForm) {
            AssertMsg(pxfi != NULL, "pxfi must have previously been set");
            pxfi->Apply(&matNewDC);
        }

        XFORM xfNew;
        matNewDC.Get(&xfNew);

        xfNew.eDx += (float) piNew.sizeBufferOffsetPxl.cx;
        xfNew.eDy += (float) piNew.sizeBufferOffsetPxl.cy;

        if (TestFlag(m_cb.GetFilter(), GMFI_PAINT) || 
#if DBG
                (s_DEBUG_pgadOutline == this) ||
#endif // DBG
                m_fBackFill || 
                m_fDeepTrivial) {

            piNew.psrf->SetWorldTransform(&xfNew);
        }


        //
        // At this point, we should NOT use ppi any more because piNew has been
        // fully setup.  If we do use pi, we will be rendering into our parent.
        //

#if DBG
        ppi = (PaintInfo *) UIntToPtr(0xFADEFADE);
#endif // DBG


        //
        // Inner loop:
        // - Setup any clipping on the DC
        // - Draw the Gadget and its children
        //

        void * pvOldClip = NULL;
        int nResult = DrawPrepareClip(&piNew, &rcGadgetPxl, &pvOldClip);
        if ((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION)) {
            //
            // Save state
            //

            void * pvPaintSurfaceState = NULL;
            if (m_fDeepPaintState) {
                pvPaintSurfaceState = piNew.psrf->Save();
            }
#if DBG
            void * DEBUG_pvSurfaceState = NULL;
            if (s_DEBUG_pgadOutline == this) {
                DEBUG_pvSurfaceState = piNew.psrf->Save();
            }
#endif // DBG

            if (fNewCache) {
                pbufBmp->SetupClipRgn();
            }

            xrDrawCore(&piNew, &rcGadgetPxl);

            //
            // Draw each of the children from back to front
            //

            if (m_fDeepTrivial) {
                //
                // Since we are trivial, all of our children are trivial.  This 
                // means that we can optimize the rendering path.  We ourselves
                // could not be optimized because some of our siblings may not
                // have been trivial and may have done complicated things that
                // forced us to go through the full rendering path.
                //

                SIZE sizeOffsetPxl = { 0, 0 };
                DuVisual * pgadCur = GetBottomChild();
                while (pgadCur != NULL) {
                    pgadCur->xrDrawTrivial(&piNew, sizeOffsetPxl);
                    pgadCur = pgadCur->GetPrev();
                }
            } else {
                DuVisual * pgadCur = GetBottomChild();
                while (pgadCur != NULL) {
                    pgadCur->xrDrawFull(&piNew);
                    pgadCur = pgadCur->GetPrev();
                }
            }


            //
            // At this point, we can not do any more drawing on this Gadget 
            // because the DC is setup of one of this Gadget's grand-children.
            //

            //
            // Restore State
            //

#if DBG
            if (s_DEBUG_pgadOutline == this) {
                piNew.psrf->Restore(DEBUG_pvSurfaceState);
                GdDrawOutlineRect(piNew.psrf, &rcGadgetPxl, SC_Indigo, 1);
            }
#endif // DBG

            if (m_fDeepPaintState) {
                piNew.psrf->Restore(pvPaintSurfaceState);
            }

            //
            // Commit the results.  We need to do this before we exit the 
            // "drawing" area since the surfaces are "correctly" setup.
            //

            AssertMsg(((!fNewBuffer) ^ (!fNewCache)) ||
                    ((!fNewBuffer) && (!fNewCache)), 
                    "Can not have both a new buffer and a cache");

            fCleanedUp = TRUE;

            if (pbufBmp != NULL) {
                pbufBmp->PreEndDraw(TRUE /* Commit */);

                BYTE bAlphaLevel    = BLEND_OPAQUE;
                BYTE bAlphaFormat   = 0;
                if (fNewCache) {
                    if (m_fCached) {
                        m_cb.xrFirePaintCache(this, CastHDC(piNew.psrf), &rcGadgetPxl, &bAlphaLevel, &bAlphaFormat);
                    } else {
                        const BUFFER_INFO * pbi = GetBufferInfo();
                        bAlphaLevel = pbi->bAlpha;
                    }
                }

                pbufBmp->EndDraw(TRUE /* Commit */, bAlphaLevel, bAlphaFormat);
            }
        }

        if (nResult != ERROR) {
            DrawCleanupClip(&piNew, pvOldClip);
        }
    }

    //
    // Clean-up any created buffers
    //

#if ENABLE_GdiplusAlphaLevel
    if (fConstantAlpha) {
        CastGraphics(piNew.psrf)->SetAlphaLevel(flOldAlphaLevel);
    }
#endif    
    
    if (pbufBmp != NULL) {
        if (!fCleanedUp) {
            //
            // Clean-up:
            // Didn't actually draw for some reason, so don't need to commit the 
            // results.
            //

            pbufBmp->PreEndDraw(FALSE /* Don't commit */);
            pbufBmp->EndDraw(FALSE /* Don't commit */);
        }
        pbufBmp->PostEndDraw();

        if (fNewCache) {
            GetBufferManager()->ReleaseCachedBuffer((DCBmpBuffer *) pbufBmp);
        } else if (fNewBuffer) {
            GetBufferManager()->ReleaseSharedBuffer(pbufBmp);
        }

        piNew.psrf->Destroy();
    }


#if DEBUG_MARKDRAWN
    if (IsRoot()) {
        g_fFlagDrawn = FALSE;
    }
#endif
}


/***************************************************************************\
*
* DuVisual::xrDrawTrivial
*
* xrDrawTrivial provides an massively simplified code-path that can be 
* executed when an entire subtree is trivial.  Whenever this can be executed
* instead of xrDrawFull(), the rendering can be much faster.  This is 
* because we don't need to worry about expensive operations that force the
* rendering to recalculate its output coordinate system.
*
\***************************************************************************/

void
DuVisual::xrDrawTrivial(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const SIZE sizeOffsetPxl)
{
    AssertMsg(m_fDeepTrivial, "Entire subtree must be trivial");

    if (!m_fVisible) {
        return;
    }


    RECT rcGadgetPxl;
    GetLogRect(&rcGadgetPxl, SGR_PARENT);
    InlineOffsetRect(&rcGadgetPxl, sizeOffsetPxl.cx, sizeOffsetPxl.cy);

    RECT rcIntersectPxl;
    BOOL fIntersect = InlineIntersectRect(&rcIntersectPxl, &rcGadgetPxl, ppi->prcCurInvalidPxl);
    if (!fIntersect) {
        return;
    }

    void * pvOldClip;
    int nResult = DrawPrepareClip(ppi, &rcGadgetPxl, &pvOldClip);
    if ((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION)) {
        //
        // Save state
        //

        void * pvPaintSurfaceState = NULL;
        if (m_fDeepPaintState) {
            pvPaintSurfaceState = ppi->psrf->Save();
        }
#if DBG
        void * DEBUG_pvSurfaceState = NULL;
        if (s_DEBUG_pgadOutline == this) {
            DEBUG_pvSurfaceState = ppi->psrf->Save();
        }
#endif // DBG


        xrDrawCore(ppi, &rcGadgetPxl);

        //
        // Draw each of the children from back to front
        //

        DuVisual * pgadCur = GetBottomChild();
        while (pgadCur != NULL) {
            SIZE sizeNewOffsetPxl;
            sizeNewOffsetPxl.cx = rcGadgetPxl.left;
            sizeNewOffsetPxl.cy = rcGadgetPxl.top;

            pgadCur->xrDrawTrivial(ppi, sizeNewOffsetPxl);
            pgadCur = pgadCur->GetPrev();
        }


        //
        // Restore State
        //

#if DBG
        if (s_DEBUG_pgadOutline == this) {
            ppi->psrf->Restore(DEBUG_pvSurfaceState);
            GdDrawOutlineRect(ppi->psrf, &rcGadgetPxl, SC_Indigo, 1);
        }
#endif // DBG

        if (m_fDeepPaintState) {
            ppi->psrf->Restore(pvPaintSurfaceState);
        }
    }

    if (nResult != ERROR) {
        DrawCleanupClip(ppi, pvOldClip);
    }
}


/***************************************************************************\
*
* DuVisual::IsParentInvalid
*
* IsParentInvalid() returns if our parent has already been fully 
* invalidated.  When this occurs, we also have automatically been 
* invalidated.
*
\***************************************************************************/

BOOL
DuVisual::IsParentInvalid() const
{
    //
    // We can't use our m_fInvalidFull flag directly since we need to invalidate
    // every place we get moved to since we don't know if it is our final
    // destination.  We can use our parent's m_fInvalidFull flag since we will be 
    // automatically redrawn when our parent is redrawn because of composition.
    //

    DuVisual * pgadCur = GetParent();
    while (pgadCur != NULL) {
        if (pgadCur->m_fInvalidFull) {
            return TRUE;
        }
        pgadCur = pgadCur->GetParent();
    }

    return FALSE;
}


/***************************************************************************\
*
* DuVisual::Invalidate
*
* Invalidate() provides a convenient wrapper to invalidate an entire 
* DuVisual.
*
\***************************************************************************/

void        
DuVisual::Invalidate()
{
    //
    // Check state where we would not need to invalidate.
    //
    // NOTE: We can't use m_fInvalidFull because we need to invalidate our new
    // location so that we can actually be drawn there.
    //

    if (!IsVisible()) {
        return;
    }


    //
    // Mark this Gadget as completely invalid
    //

    m_fInvalidFull = TRUE;
    

    //
    // Before we actually invalidate this node, check if our parent is already
    // _fully_ invalid.  If this is the case, we don't need to actually 
    // invalidate.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
        if (IsParentInvalid()) {
            return;
        }
    }


    //
    // Do the invalidation.
    //

    RECT rcClientPxl;
    rcClientPxl.left    = 0;
    rcClientPxl.top     = 0;
    rcClientPxl.right   = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    rcClientPxl.bottom  = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    DoInvalidateRect(GetContainer(), &rcClientPxl, 1);
}


/***************************************************************************\
*
* DuVisual::InvalidateRects
*
* Invalidate() provides a convenient wrapper to invalidate a collection
* of areas in a DuVisual.
*
\***************************************************************************/

void        
DuVisual::InvalidateRects(
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    AssertReadPtr(rgrcClientPxl);
    Assert(cRects > 0);

    //
    // Check state where we would not need to invalidate.
    //
    // NOTE: We can't use m_fInvalidFull because we need to invalidate our new
    // location so that we can actually be drawn there.
    //

    if (!IsVisible()) {
        return;
    }


    //
    // We can't mark this Gadget as completely invalid because the rects may
    // not cover the entire area.
    //

    //
    // Before we actually invalidate this node, check if our parent is already
    // _fully_ invalid.  If this is the case, we don't need to actually 
    // invalidate.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
        if (IsParentInvalid()) {
            return;
        }
    }


    //
    // Intersect each rectangle with our boundaries and do the invalidation.
    //

    DuContainer * pcon = GetContainer();

    RECT rcClientPxl;
    rcClientPxl.left    = 0;
    rcClientPxl.top     = 0;
    rcClientPxl.right   = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    rcClientPxl.bottom  = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    RECT * rgrcClipPxl = (RECT *) _alloca(sizeof(RECT) * cRects);
    for (int idx = 0; idx < cRects; idx++) {
        InlineIntersectRect(&rgrcClipPxl[idx], &rcClientPxl, &rgrcClientPxl[idx]);


        //
        // Check if any resulting rectangle completely fills the entire Gadget.
        // We can optimize this to be the same as Invalidate().
        //

        if (InlineEqualRect(&rgrcClipPxl[idx], &rcClientPxl)) {
            m_fInvalidFull = TRUE;
            DoInvalidateRect(pcon, &rcClientPxl, 1);
            return;
        }
    }

    DoInvalidateRect(pcon, rgrcClipPxl, cRects);
}


/***************************************************************************\
*
* DuVisual::DoInvalidateRect
*
* DoInvalidateRect() is the worker function for invalidating a given 
* DuVisual.  The actually bounding rectangle is determined and is used to 
* invalidate the DuVisual.  This function is optimized for when invaliding 
* several DuVisuals at once inside a common container.
*
\***************************************************************************/

void        
DuVisual::DoInvalidateRect(
    IN  DuContainer * pcon,             // Container (explicit for perf reasons)
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    AssertMsg(IsVisible(), "DuVisual must be visible");
    AssertMsg(cRects > 0, "Must specify at least one rectangle");

    //
    // Need to check if pcon is NULL.  This will happen during shutdown when
    // the DuVisual tree is detached from the container.
    //

    if ((pcon == NULL) || 
        ((cRects == 1) && InlineIsRectEmpty(&rgrcClientPxl[0]))) {
        return;
    }

    AssertMsg(GetContainer() == pcon, "Containers must be the same");

    
    //
    // Compute a bounding rectangle that includes all XForms for the given
    // DuVisual.
    //
    // TODO: Need to change this so that we recursively walk up the tree 
    // applying a single XForm at each level.  This is necessary to support
    // Complex Gadgets which can prematurely stop the walk before it would
    // reach the container.
    //

    RECT * rgrcActualPxl = (RECT *) _alloca(cRects * sizeof(RECT));
    DoCalcClipEnumXForm(rgrcActualPxl, rgrcClientPxl, cRects);

    for (int idx = 0; idx < cRects; idx++) {
        //
        // Expand the rectangle out by one because XForms are inaccurate and 
        // sometimes are "off" by a 1 pixel in the upper left and 2 in the lower right
        //

        if (!InlineIsRectEmpty(&rgrcClientPxl[idx])) {
            RECT * prcCur = &rgrcActualPxl[idx];

            prcCur->left--;
            prcCur->top--;
            prcCur->right += 2;
            prcCur->bottom += 2;

            pcon->OnInvalidate(prcCur);
        }
    }


#if ENABLE_OPTIMIZEDIRTY
    //
    // Update m_fInvalidDirty.  We need to mark all of the parents and siblings 
    // as dirty until we hit an "opaque" node that will contain the 
    // invalidation.
    //

    for (DuVisual * pgadCur = this; pgadCur != NULL; pgadCur = pgadCur->GetParent()) {
        for (DuVisual * pgadSibling = pgadCur->GetPrev(); pgadSibling != NULL; pgadSibling = pgadSibling->GetPrev()) {
            pgadSibling->m_fInvalidDirty = TRUE;
        }

        pgadCur->m_fInvalidDirty = TRUE;
        if (pgadCur->m_fOpaque) {
            break;
        }

        for (DuVisual * pgadSibling = pgadCur->GetNext(); pgadSibling != NULL; pgadSibling = pgadSibling->GetNext()) {
            pgadSibling->m_fInvalidDirty = TRUE;
        }
    }
#endif
}

#if DBG
void
DuVisual::DEBUG_CheckResetInvalid() const
{
#if ENABLE_OPTIMIZEDIRTY
    AssertMsg((!m_fInvalidFull) && (!m_fInvalidChildren) && (!m_fInvalidDirty), 
            "Invalid must be reset");
#else
    AssertMsg((!m_fInvalidFull) && (!m_fInvalidChildren), 
            "Invalid must be reset");
#endif

    DuVisual * pgadCur = GetTopChild();
    while (pgadCur != NULL) {
        pgadCur->DEBUG_CheckResetInvalid();
        pgadCur = pgadCur->GetNext();
    }
}

#endif // DBG


/***************************************************************************\
*
* DuVisual::ResetInvalid
*
* ResetInvalid() walks the tree resetting the invalid painting bits, 
* m_fInvalidFull, m_fInvalidChildren, and m_fInvalidDirty, that are used 
* to indicate that a node has been invalidated.
*
\***************************************************************************/

void
DuVisual::ResetInvalid()
{
    m_fInvalidFull  = FALSE;
#if ENABLE_OPTIMIZEDIRTY
    m_fInvalidDirty = FALSE;
#endif

    if (m_fInvalidChildren) {
        m_fInvalidChildren = FALSE;

        DuVisual * pgadCur = GetTopChild();
        while (pgadCur != NULL) {
            pgadCur->ResetInvalid();
            pgadCur = pgadCur->GetNext();
        }
    }

#if DBG
    DEBUG_CheckResetInvalid();
#endif // DBG
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::GetBufferInfo(
    IN  BUFFER_INFO * pbi               // Buffer information
    ) const
{
    AssertWritePtr(pbi);
    AssertMsg(m_fBuffered, "Gadget must be buffered");

    BUFFER_INFO * pbiThis = GetBufferInfo();

    pbi->nMask      = GBIM_VALID;
    pbi->bAlpha     = pbiThis->bAlpha;
    pbi->crFill     = pbiThis->crFill;
    pbi->nStyle     = pbiThis->nStyle;
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::SetBufferInfo(
    IN  const BUFFER_INFO * pbi)        // New information
{
    AssertReadPtr(pbi);
    AssertMsg(m_fBuffered, "Gadget must be buffered");

    BUFFER_INFO * pbiThis = GetBufferInfo();

    int nMask = pbi->nMask;
    if (TestFlag(nMask, GBIM_ALPHA)) {
        pbiThis->bAlpha = pbi->bAlpha;
    }

    if (TestFlag(nMask, GBIM_FILL)) {
        pbiThis->crFill = pbi->crFill;
    }

    if (TestFlag(nMask, GBIM_STYLE)) {
        pbiThis->nStyle = pbi->nStyle;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::SetBuffered(
    IN  BOOL fBuffered)                 // New buffering mode
{
    HRESULT hr;

    if ((!fBuffered) == (!m_fBuffered)) {
        return S_OK;  // No change
    }

    if (fBuffered) {
        BUFFER_INFO * pbi;
        hr = m_pds.SetData(s_pridBufferInfo, sizeof(BUFFER_INFO), (void **) &pbi);
        if (FAILED(hr)) {
            return hr;
        }

        pbi->cbSize = sizeof(BUFFER_INFO);
        pbi->nMask  = GBIM_VALID;
        pbi->bAlpha = BLEND_OPAQUE;
    } else {
        //
        // Remove the existing XFormInfo
        //

        m_pds.RemoveData(s_pridBufferInfo, TRUE);
    }

    m_fBuffered = fBuffered;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::GetRgn(UINT nRgnType, HRGN hrgn, UINT nFlags) const
{
    AssertMsg(hrgn != NULL, "Must specify a valid region");
    UNREFERENCED_PARAMETER(nFlags);

    HRESULT hr = E_NOTIMPL;

    switch (nRgnType)
    {
    case GRT_VISRGN:
        {
            //
            // For right now, just return the bounding box.
            //
            // TODO: Need to be more accurate than this if any rotations are 
            // going on.
            //

            RECT rcClientPxl, rcContainerPxl;
            GetLogRect(&rcClientPxl, SGR_CLIENT);
            DoCalcClipEnumXForm(&rcContainerPxl, &rcClientPxl, 1);

            if (!SetRectRgn(hrgn, rcContainerPxl.left, rcContainerPxl.top,
                   rcContainerPxl.right, rcContainerPxl.bottom)) {

                hr = DU_E_OUTOFGDIRESOURCES;
                goto Exit;
            }

            hr = S_OK;
        }    
        break;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\init.h ===
#if !defined(CORE__Init_h__INCLUDED)
#define CORE__Init_h__INCLUDED
#pragma once

HRESULT InitCore();

#endif // CORE__Init_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\init.cpp ===
#include "stdafx.h"
#include "Core.h"
#include "Init.h"

#include "BaseGadget.h"
#include "MessageGadget.h"
#include "TreeGadget.h"
#include "RootGadget.h"

#if ENABLE_MSGTABLE_API

//
// Provide Implementations of classes.
//
// NOTE: We register BaseGadget by hand to ensure that messages are registered
// in a determined (and necessary) order.
//


DUser::MessageClassGuts EventGadgetImpl<DuEventGadget, MsgObject>::s_mc;
DUser::MessageInfoGuts EventGadgetImpl<DuEventGadget, MsgObject>::s_rgmi[] = {
    { DUser::Event<DuEventGadget, EventMsg>(DuEventGadget::ApiOnEvent), L"OnEvent" },
    { DUser::Method<DuEventGadget, EventGadget::GetFilterMsg>(DuEventGadget::ApiGetFilter), L"GetFilter" },
    { DUser::Method<DuEventGadget, EventGadget::SetFilterMsg>(DuEventGadget::ApiSetFilter), L"SetFilter" },
    { DUser::Method<DuEventGadget, EventGadget::AddHandlerGMsg>(DuEventGadget::ApiAddHandlerG), L"AddHandlerG" },
    { DUser::Method<DuEventGadget, EventGadget::AddHandlerDMsg>(DuEventGadget::ApiAddHandlerD), L"AddHandlerD" },
    { DUser::Method<DuEventGadget, EventGadget::RemoveHandlerGMsg>(DuEventGadget::ApiRemoveHandlerG), L"RemoveHandlerG" },
    { DUser::Method<DuEventGadget, EventGadget::RemoveHandlerDMsg>(DuEventGadget::ApiRemoveHandlerD), L"RemoveHandlerD" },
};

IMPLEMENT_GUTS_Listener(DuListener, DuEventGadget);
IMPLEMENT_GUTS_Visual(DuVisual, DuEventGadget);
IMPLEMENT_GUTS_Root(DuRootGadget, DuVisual);

#endif // ENABLE_MSGTABLE_API


HRESULT InitCore()
{
#if ENABLE_MSGTABLE_API

    if ((!DuEventGadget::InitEventGadget()) ||
        (!DuListener::InitListener()) ||
        (!DuVisual::InitVisual()) ||
        (!DuRootGadget::InitRoot())) {

        return E_OUTOFMEMORY;
    }

    DuEventGadget::MarkInternal();
    DuListener::MarkInternal();
    DuVisual::MarkInternal();
    DuRootGadget::MarkInternal();

#else
    if (FAILED(DuVisual::InitClass())) {
        return E_OUTOFMEMORY;
    }

#endif // ENABLE_MSGTABLE_API

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\gstate.cpp ===
/***************************************************************************\
*
* File: GState.cpp
*
* Description:
* GState.cpp implements standard DuVisual state-management functions.
*
*
* History:
*  2/04/2001: JStall:       Created
*
* Copyright (C) 2000-2001 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

/***************************************************************************\
*
* DuVisual::CheckIsTrivial
*
* CheckIsTrivial returns if this node qualifies for trivialness, ignoring
* its children.  
*
* NOTE: This callback function is intended to be called from 
* UpdateDeepAllState().
*
\***************************************************************************/

BOOL
DuVisual::CheckIsTrivial() const
{
    //
    // To be trivial, the following conditions must be met for this node and 
    // all of its children.  If these are not met, then we need to perform 
    // the standard (complicated) painting algorithms.
    // 
    // - fZeroOrigin:       FALSE
    // - fXForm:            FALSE
    // - fClipSiblings:     FALSE
    // - fBuffered:         FALSE
    // - fCached:           FALSE
    //

    return !TestFlag(m_nStyle, GS_ZEROORIGIN | gspXForm | GS_CLIPSIBLINGS | GS_BUFFERED | GS_CACHED);
}


/***************************************************************************\
*
* DuVisual::CheckIsWantMouseFocus
*
* CheckIsWantMouseFocus returns if this node wants mouse focus, ignoring
* its children.  
*
* NOTE: This callback function is intended to be called from 
* UpdateDeepAnyState().
*
\***************************************************************************/

BOOL
DuVisual::CheckIsWantMouseFocus() const
{
    return TestFlag(m_nStyle, GS_MOUSEFOCUS);
}


/***************************************************************************\
*
* DuVisual::UpdateDeepAllState
*
* UpdateDeepAllState() updates the deep state on the specified Gadget so that 
* it properly reflects the state of both this node and all of its children.  
* This function recursively walks up the tree, updating the state as
* necessary.
*
\***************************************************************************/

void
DuVisual::UpdateDeepAllState(
    IN  EUdsHint hint,                  // (Optional) hint from changing child
    IN  DeepCheckNodeProc pfnCheck,     // Callback checking function
    IN  UINT nStateMask)                // State mask
{
    BOOL fNewState = FALSE;

    switch (hint)
    {
    case uhFalse:
        //
        // Child changed to !State, so we must become !State
        //
        
        fNewState = FALSE;
        break;

    case uhTrue:
        //
        // Child changed to State, so we may be able to become State if 
        // everything qualifies.
        //
        // NOTE: We may already be State if this child was already State.
        //
        
        if (!TestFlag(m_nStyle, nStateMask)) {
            goto FullCheck;
        }
        fNewState = TRUE;
        break;
          
    case uhNone:
        {
FullCheck:
            fNewState = (this->*pfnCheck)();
            if (!fNewState) {
                goto NotifyParent;
            }
    
            //
            // Need to scan all of the children to determine what happened
            //

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (!TestFlag(pgadCur->m_nStyle, nStateMask)) {
                    fNewState = FALSE;
                    break;
                }
                pgadCur = pgadCur->GetNext();
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown hint");
        goto FullCheck;
    }


NotifyParent:
    if ((!fNewState) != (!TestFlag(m_nStyle, nStateMask))) {
        //
        // State has changed, so parent needs to update
        //

        EUdsHint hintParent;
        if (fNewState) {
            SetFlag(m_nStyle, nStateMask);
            hintParent = uhTrue;
        } else {
            ClearFlag(m_nStyle, nStateMask);
            hintParent = uhFalse;
        }

        DuVisual * pgadParent = GetParent();
        if (pgadParent != NULL) {
            pgadParent->UpdateDeepAllState(hintParent, pfnCheck, nStateMask);
        }
    }
}


/***************************************************************************\
*
* DuVisual::UpdateDeepAnyState
*
* UpdateDeepAnyState() updates the deep state on the specified Gadget so that 
* it properly reflects the state of (this node || any of its children).  
* This function recursively walks up the tree, updating the state as
* necessary.
*
* NOTE: This function is a mirror image of UpdateDeepAllState() where all of
* the logical has been reversed.
*
\***************************************************************************/

void
DuVisual::UpdateDeepAnyState(
    IN  EUdsHint hint,                  // (Optional) hint from changing child
    IN  DeepCheckNodeProc pfnCheck,     // Callback checking function
    IN  UINT nStateMask)                // State mask
{
    BOOL fNewState = TRUE;

    switch (hint)
    {
    case uhTrue:
        //
        // Child changed to State, so we must become State
        //
        
        fNewState = TRUE;
        break;

    case uhFalse:
        //
        // Child changed to !State, so we may be able to become !State if 
        // everything qualifies.
        //
        // NOTE: We may already be !State if this child was already !State.
        //
        
        if (TestFlag(m_nStyle, nStateMask)) {
            goto FullCheck;
        }
        fNewState = FALSE;
        break;
          
    case uhNone:
        {
FullCheck:
            fNewState = (this->*pfnCheck)();
            if (fNewState) {
                goto NotifyParent;
            }
    
            //
            // Need to scan all of the children to determine what happened
            //

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (TestFlag(pgadCur->m_nStyle, nStateMask)) {
                    fNewState = TRUE;
                    break;
                }
                pgadCur = pgadCur->GetNext();
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown hint");
        goto FullCheck;
    }


NotifyParent:
    if ((!fNewState) != (!TestFlag(m_nStyle, nStateMask))) {
        //
        // State has changed, so parent needs to update
        //

        EUdsHint hintParent;
        if (fNewState) {
            SetFlag(m_nStyle, nStateMask);
            hintParent = uhTrue;
        } else {
            ClearFlag(m_nStyle, nStateMask);
            hintParent = uhFalse;
        }

        DuVisual * pgadParent = GetParent();
        if (pgadParent != NULL) {
            pgadParent->UpdateDeepAnyState(hintParent, pfnCheck, nStateMask);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\messagegadget.cpp ===
/***************************************************************************\
*
* File: MessageGadget.cpp
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Core.h"
#include "MessageGadget.h"

/***************************************************************************\
*****************************************************************************
*
* class DuListener
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuListener::~DuListener()
{
    //
    // After notifying all event handlers that this DuVisual is being destroyed,
    // extract this DuVisual from the graph.
    //

    CleanupMessageHandlers();
}


/***************************************************************************\
*
* DuListener::Build
*
* Build() creates a new fully initialized DuListener.
*
\***************************************************************************/

HRESULT
DuListener::Build(
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuListener ** ppgadNew)  // New Gadget
{
    DuListener * pgadNew = ClientNew(DuListener);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

#if DBG
    pgadNew->m_cb.Create(pci->pfnProc, pci->pvData, pgadNew->GetHandle());
#else // DBG
    pgadNew->m_cb.Create(pci->pfnProc, pci->pvData);
#endif // DBG

    //
    // When creating as an HGADGET, we need to force initialization of the
    // MsgObject.
    //
    // TODO: Get rid of this
    //
#if ENABLE_MSGTABLE_API
    pgadNew->SetupInternal(s_mc.hclNew);
#endif

    *ppgadNew = pgadNew;
    return S_OK;
}


/***************************************************************************\
*
* DuListener::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
* NOTE: Gadgets are slightly different than other objects with callbacks in
* that their lifetime does NOT end when the application calls 
* ::DeleteHandle().  Instead, the object and its callback are completely
* valid until the GM_DESTROY message has been successfully sent.  This is 
* because a Gadget should receive any outstanding messages in both the 
* normal and delayed message queues before being destroyed.
*
\***************************************************************************/

BOOL
DuListener::xwDeleteHandle()
{
    //
    // Need to send GM_DESTROY(GDESTROY_START) as soon as the Gadget starts
    // the destruction process.
    //

    m_fStartDestroy = TRUE;
    m_cb.xwFireDestroy(this, GDESTROY_START);

    return DuEventGadget::xwDeleteHandle();
}


/***************************************************************************\
*
* DuListener::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
DuListener::IsStartDelete() const
{
    return m_fStartDestroy;
}


/***************************************************************************\
*
* DuListener::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void
DuListener::xwDestroy()
{
    xwBeginDestroy();

    DuEventGadget::xwDestroy();
}


/***************************************************************************\
*
* DuListener::xwBeginDestroy
*
* xwBeginDestroy() starts the destruction process for a given Gadget to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* xwBeginDestroy() is given an opportunity to clean up resources BEFORE the 
* destructors start tearing down the classes.  This is important especially
* for callbacks because the Gadgets will be partially uninitialized in the
* destructors and could have bad side-effects from other API calls during 
* the callbacks.
*
\***************************************************************************/

void        
DuListener::xwBeginDestroy()
{
    //
    // Send destroy notifications.  This needs to be done in a bottom-up 
    // order to ensure that the root DuVisual does not keep any handles 
    // to a DuVisual being destroyed.
    //

    m_cb.xwFireDestroy(this, GDESTROY_FINAL);


    //
    // At this point, the children have been cleaned up and the Gadget has
    // received its last callback.  From this point on, anything can be done,
    // but it is important to not callback.
    //

    m_cb.Destroy();
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuListener::PromoteListener(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData) 
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pciData);

    MsgObject ** ppmsoNew = reinterpret_cast<MsgObject **> (pgad);
    AssertMsg((ppmsoNew != NULL) && (*ppmsoNew == NULL), 
            "Internal objects must be given valid storage for the MsgObject");

    DuListener * pgadNew = ClientNew(DuListener);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

#if DBG
    pgadNew->m_cb.Create(NULL, NULL, pgadNew->GetHandle());
#else // DBG
    pgadNew->m_cb.Create(NULL, NULL);
#endif // DBG

    *ppmsoNew = pgadNew;
    return S_OK;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\gxform.cpp ===
/***************************************************************************\
*
* File: GXForm.cpp
*
* Description:
* GXForm.cpp interfaces GDI World Transforms into the DuVisual-Tree.  
* This file focuses on exposting transform information outside.  Actual 
* understanding of transforms are (necessarily) weaved throughout 
* DuVisual.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::GetScale
*
* GetScale() returns the current scaling factor assigned to this specific
* DuVisual.  Scaling factors of parents, siblings, and children are not 
* included.
*
\***************************************************************************/

void        
DuVisual::GetScale(
    OUT float * pflScaleX,              // X scaling factor
    OUT float * pflScaleY               // Y scaling factor
    ) const
{
    AssertWritePtr(pflScaleX);
    AssertWritePtr(pflScaleY);

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        *pflScaleX = pxfi->flScaleX;
        *pflScaleY = pxfi->flScaleY;
    } else {
        *pflScaleX = 1.0f;
        *pflScaleY = 1.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetScale
*
* xdSetScale() changes the current scaling factor assigned to this specific
* DuVisual.  Scaling factors of parents, siblings, and children are not 
* changed.
*
\***************************************************************************/

HRESULT        
DuVisual::xdSetScale(
    IN  float flScaleX,                 // New X scaling factor
    IN  float flScaleY)                 // New Y scaling factor
{
    HRESULT hr;

    //
    // Check parameters
    //

    if ((flScaleX <= 0.0f) || (flScaleY <= 0.0f)) {
        return E_INVALIDARG;
    }

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }

    if (!m_fXForm) {
        if (IsZero(flScaleX - 1.0f) && IsZero(flScaleY - 1.0f)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a scaling factor, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi = GetXFormInfo();
    if (IsZero(pxfi->flScaleX - flScaleX) && IsZero(pxfi->flScaleY - flScaleY)) {
        return S_OK;
    }


    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flScaleX   = flScaleX;
    pxfi->flScaleY   = flScaleY;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::GetRotation
*
* GetRotation() returns the current rotation angle (in radians) assigned 
* to this specific DuVisual.  Scaling factors of parents, siblings, and 
* children are not included.
*
\***************************************************************************/

float       
DuVisual::GetRotation() const
{
    if (m_fXForm) {
        AssertMsg(!IsRoot(), "Ensure not the root");

        XFormInfo * pxfi = GetXFormInfo();
        return pxfi->flRotationRad;
    } else {
        return 0.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetRotation
*
* xdSetRotation() changes the current rotation angle (in radians) assigned 
* to this specific DuVisual.  Scaling factors of parents, siblings, and 
* children are not changed.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetRotation(
    IN  float flRotationRad)            // New rotation factor in radians
{
    HRESULT hr;

    //
    // Not allowed to change the rotation of the root.  This is to ensure 
    // that the root always fully covers the entire container.
    //

    if (IsRoot()) {
        return E_INVALIDARG;
    }

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }


    if (!m_fXForm) {
        if (IsZero(flRotationRad)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a rotation, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi    = GetXFormInfo();
    if (IsZero(pxfi->flRotationRad - flRotationRad)) {
        return S_OK;
    }

    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flRotationRad = flRotationRad;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::GetCenterPoint
*
* GetCenterPoint() returns the current center-point that scaling and 
* rotation "pivot" for this specific DuVisual.  Center-points of parents, 
* siblings, and children are not included.
*
\***************************************************************************/

void        
DuVisual::GetCenterPoint(
    OUT float * pflCenterX,             // X center-point factor
    OUT float * pflCenterY              // Y center-point factor
    ) const
{
    AssertWritePtr(pflCenterX);
    AssertWritePtr(pflCenterY);

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        *pflCenterX = pxfi->flCenterX;
        *pflCenterY = pxfi->flCenterY;
    } else {
        *pflCenterX = 1.0f;
        *pflCenterY = 1.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetCenterPoint
*
* xdSetCenterPoint() changes the current center-point that scaling and 
* rotation "pivot" for this specific DuVisual.    Center-points of parents,
* siblings, and children are not changed.
*
\***************************************************************************/

HRESULT        
DuVisual::xdSetCenterPoint(
    IN  float flCenterX,                // New X scaling factor
    IN  float flCenterY)                // New Y scaling factor
{
    HRESULT hr;

    //
    // Check parameters
    //

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }

    if (!m_fXForm) {
        if (IsZero(flCenterX) && IsZero(flCenterY)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a scaling factor, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi = GetXFormInfo();
    if (IsZero(pxfi->flCenterX - flCenterX) && IsZero(pxfi->flCenterY - flCenterY)) {
        return S_OK;
    }


    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flCenterX = flCenterX;
    pxfi->flCenterY = flCenterY;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::SetEnableXForm
*
* SetEnableXForm() enables / disables the extra XFormInfo dynamic property
* used to store transform information.
*
\***************************************************************************/

HRESULT
DuVisual::SetEnableXForm(
    IN  BOOL fEnable)                   // Enable optional X-Form information 
{
    HRESULT hr;

    if ((!fEnable) == (!m_fXForm)) {
        return S_OK;  // No change
    }

    if (fEnable) {
        AssertMsg(SupportXForm(), "Only can set if XForm's are supported");

        //
        // Allocate and initialize a new XFormInfo.
        //

        XFormInfo * pxfi;
        hr = m_pds.SetData(s_pridXForm, sizeof(XFormInfo), (void **) &pxfi);
        if (FAILED(hr)) {
            return hr;
        }

        pxfi->flScaleX = 1.0f;
        pxfi->flScaleY = 1.0f;
    } else {
        //
        // Remove the existing XFormInfo
        //

        m_pds.RemoveData(s_pridXForm, TRUE);
    }

    m_fXForm = (fEnable != FALSE);
    UpdateTrivial(uhNone);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::BuildXForm
*
* BuildXForm() builds a matrix that contains all transformations from this
* DuVisual up to the root.  This matrix corresponds to the cumulative matrix 
* that gets applied when drawing the DuVisuals.
*
* This is used to take logical client coordinates for a specific DuVisual
* and convert them into container coordinates.
*
\***************************************************************************/

void        
DuVisual::BuildXForm(
    IN OUT Matrix3 * pmatCur            // Optional current matrix of all XForm's.
    ) const
{
    //
    // Walk up the tree
    //

    const DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->BuildXForm(pmatCur);
    }


    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcPxl.left;
        flOffsetY = (float) rcPxl.top;

        if (pmatCur != NULL) {
            pmatCur->Translate(flOffsetX, flOffsetY);
        }
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();

        if (pmatCur != NULL) {
            pxfi->Apply(pmatCur);
        }
    }
}


/***************************************************************************\
*
* DuVisual::BuildAntiXForm
*
* BuildAntiXForm() builds the opposite transform by following the same 
* traversal path down the DuVisual tree to the specified node as 
* BuildXForm(), but it applies the opposite transformation at each step.
*
* This is used to take container coordinates and convert them into logical
* coordinates for a specific DuVisual.
*
\***************************************************************************/

void        
DuVisual::BuildAntiXForm(
    IN OUT Matrix3 * pmatCur            // Current matrix of all XForm's.
    ) const
{
    AssertMsg(pmatCur != NULL, "Must specify a matrix to modify");

    //
    // Walk up the tree
    //

    const DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->BuildAntiXForm(pmatCur);
    }


    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->ApplyAnti(pmatCur);
    }

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcPxl.left;
        flOffsetY = (float) rcPxl.top;

        pmatCur->Translate(- flOffsetX, - flOffsetY);
    }
}


/***************************************************************************\
*
* DuVisual::DoCalcClipEnumXForm
*
* DoCalcClipEnumXForm() transforms a given client rectangle into container
* coordinates while clipping the rectangle inside each of its parents 
* boundaries.  
* 
* For example, this is useful during invalidation to ensure that the 
* invalidated rectangle is completely inside of its parent.
*
\***************************************************************************/

void
DuVisual::DoCalcClipEnumXForm(
    OUT RECT * rgrcFinalClipClientPxl,  // Final clip rectangle in client pixels
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects                      // Number of rects to convert
    ) const  
{
    if (GetParent() != NULL) {
        //
        // Have a parent, so walk up the tree converting the given rect into
        // (new) parent coordinates and clipping inside the new parent.
        //

        RECT * rgrcNewParentPxl     = (RECT *) _alloca(cRects * sizeof(RECT));
        RECT * rgrcClipParentPxl    = (RECT *) _alloca(cRects * sizeof(RECT));

        DoXFormClientToParent(rgrcNewParentPxl, rgrcClientPxl, cRects, HINTBOUNDS_Clip);

        RECT rcParentParentPxl;
        GetParent()->GetLogRect(&rcParentParentPxl, SGR_CLIENT);

        for (int idx = 0; idx < cRects; idx++) {
            IntersectRect(&rgrcClipParentPxl[idx], &rcParentParentPxl, &rgrcNewParentPxl[idx]);
        }

        GetParent()->DoCalcClipEnumXForm(rgrcFinalClipClientPxl, rgrcClipParentPxl, cRects);
    } else {
        //
        // No more parent, so just return directly.
        //

        CopyMemory(rgrcFinalClipClientPxl, rgrcClientPxl, cRects * sizeof(RECT));
    }
}


/***************************************************************************\
*
* DuVisual::DoXFormClientToParent
*
* DoXFormClientToParent() transforms a given client rectangle into parent
* coordinates by applying transformations and taking the BOUNDING rectangle.
* This function is called repeatedly by DoCalcClipEnumXForm() to transform
* a client rectangle into container cordinates.
* 
* NOTE: Unlike DoCalcClipEnumXForm(), this function does NOT clip the 
* resulting rectangle to the parent.
*
\***************************************************************************/

void
DuVisual::DoXFormClientToParent(
    OUT RECT * rgrcParentPxl,
    IN  const RECT * rgrcClientPxl,
    IN  int cRects,
    IN  Matrix3::EHintBounds hb
    ) const
{
    AssertMsg(cRects > 0, "Must specify a valid # of rectangles to compute");

    //
    // First, compute the translation matrix to convert from client coordinates
    // of this Gadget to client coordinates of our parent.
    //

    Matrix3 matStep;

    RECT rcThisParentPxl;
    GetLogRect(&rcThisParentPxl, SGR_PARENT);
    if ((rcThisParentPxl.left != 0) || (rcThisParentPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcThisParentPxl.left;
        flOffsetY = (float) rcThisParentPxl.top;

        matStep.Translate(flOffsetX, flOffsetY);
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->Apply(&matStep);
    }


    //
    // Now, zip through all rectangles converting from relative to us to 
    // relative to our parent.
    //
    // NOTE: This does NOT clip the resulting rectangle to inside the parent.
    //

    int idx = cRects; 
    while (idx-- > 0) {
        matStep.ComputeBounds(rgrcParentPxl, rgrcClientPxl, hb);
        rgrcParentPxl++;
        rgrcClientPxl++;
    }
}


/***************************************************************************\
*
* DuVisual::DoXFormClientToParent
*
* DoXFormClientToParent() transforms a given point into parent coordinates
* by applying transformations.
*
\***************************************************************************/

void
DuVisual::DoXFormClientToParent(
    IN OUT POINT * rgrcClientPxl,
    IN  int cPoints
    ) const
{
    AssertMsg(cPoints > 0, "Must specify a valid # of rectangles to compute");

    //
    // First, compute the translation matrix to convert from client coordinates
    // of this Gadget to client coordinates of our parent.
    //

    Matrix3 matStep;

    RECT rcThisParentPxl;
    GetLogRect(&rcThisParentPxl, SGR_PARENT);
    if ((rcThisParentPxl.left != 0) || (rcThisParentPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcThisParentPxl.left;
        flOffsetY = (float) rcThisParentPxl.top;

        matStep.Translate(flOffsetX, flOffsetY);
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->Apply(&matStep);
    }


    //
    // Now, zip through all points converting from relative to us to 
    // relative to our parent.
    //
    // NOTE: This does NOT clip the resulting point to inside the parent.
    //

    matStep.Execute(rgrcClientPxl, cPoints);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\grect.cpp ===
/***************************************************************************\
*
* File: GRect.cpp
*
* Description:
* GRect.cpp implements standard DuVisual location/placement functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::GetSize
*
* GetSize() provides fast access to return the logical (non XForm'd) size 
* of this DuVisual.
*
\***************************************************************************/

void        
DuVisual::GetSize(SIZE * psizeLogicalPxl) const
{
    AssertWritePtr(psizeLogicalPxl);

    psizeLogicalPxl->cx = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    psizeLogicalPxl->cy = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;
}


/***************************************************************************\
*
* DuVisual::GetLogRect
*
* GetLogRect() returns the logical rectangle for this DuVisual.
*
\***************************************************************************/

void        
DuVisual::GetLogRect(RECT * prcPxl, UINT nFlags) const
{
    AssertWritePtr(prcPxl);
    Assert((nFlags & SGR_RECTMASK) == nFlags);
    AssertMsg(!TestFlag(nFlags, SGR_ACTUAL), "Only supports logical");

    //
    // Get the information
    //

    switch (nFlags & SGR_RECTMASK)
    {
    default:
    case SGR_OFFSET:
    case SGR_PARENT:
        if (m_fRelative || IsRoot()) {
            //
            // Asking for parent (relative) and already relative, so just return out.
            //
            // NOTE: Unlike other coordinate types, if we don't have a parent, we can
            // still return relative coordinates!
            //

            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
        } else {
            //
            // Asking for parent (relative), but not relative, so get parent and offset
            //

            AssertMsg(GetParent() != NULL, "Must have a parent for this path");
            AssertMsg(!GetParent()->m_fRelative, "Parent can not be relative if we are not");
            
            const RECT & rcParentPxl = GetParent()->m_rcLogicalPxl;

            prcPxl->left    = m_rcLogicalPxl.left - rcParentPxl.left;
            prcPxl->top     = m_rcLogicalPxl.top - rcParentPxl.top ;
            prcPxl->right   = prcPxl->left + (m_rcLogicalPxl.right - m_rcLogicalPxl.left);
            prcPxl->bottom  = prcPxl->top + (m_rcLogicalPxl.bottom - m_rcLogicalPxl.top);
        }
        break;

    case SGR_CONTAINER:
        if (m_fRelative && (GetParent() != NULL)) {
            //
            // Asking for container rect and relative, so get container rect of
            // parent and offset us.
            //

            RECT rcParentPxl;
            GetParent()->GetLogRect(&rcParentPxl, SGR_CONTAINER);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcParentPxl.left, rcParentPxl.top);
        } else {
            //
            // Asking for container and not relative, so just return out
            //

            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
        }
        break;

    case SGR_DESKTOP:
        if (m_fRelative && (GetParent() != NULL)) {
            RECT rcParentPxl;
            GetParent()->GetLogRect(&rcParentPxl, SGR_DESKTOP);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcParentPxl.left, rcParentPxl.top);
        } else {
            RECT rcContainerPxl;
            GetContainer()->OnGetRect(&rcContainerPxl);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcContainerPxl.left, rcContainerPxl.top);
        }
        break;

    case SGR_CLIENT:
        InlineCopyZeroRect(prcPxl, &m_rcLogicalPxl);
        break;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetLogRect
*
* xdSetRect() changes the logical rectangle for this DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetLogRect(int x, int y, int w, int h, UINT nFlags)
{
    AssertMsg(!TestFlag(nFlags, SGR_ACTUAL), "Only supports logical");

    UINT nRectType      = nFlags & SGR_RECTMASK;
    BOOL fInvalidate    = !TestFlag(nFlags, SGR_NOINVALIDATE);

    BOOL fRoot = IsRoot();
    AssertMsg((!fRoot) || (!TestFlag(nFlags, SGR_MOVE)),
            "Can not move a root");

#if DBG
    if (TestFlag(nFlags, SGR_SIZE)) {
        AssertMsg((w >= 0) && (h >= 0), "Ensure non-negative size when resizing");
    }
#endif // DBG

    //
    // Change the information
    //

    RECT rcOldParentPxl, rcNewActualPxl;
    GetLogRect(&rcOldParentPxl, SGR_PARENT);
    InlineCopyRect(&rcNewActualPxl, &m_rcLogicalPxl);
    
    UINT nChangeFlags = 0;


    //
    // Change the position
    //

    if (TestFlag(nFlags, SGR_MOVE)) {
        switch (nRectType)
        {
        case SGR_PARENT:
            if (m_fRelative || IsRoot()) {
                rcNewActualPxl.left = x;
                rcNewActualPxl.top  = y;
            } else {
                RECT rcParentConPxl;
                GetParent()->GetLogRect(&rcParentConPxl, SGR_CONTAINER);
                rcNewActualPxl.left = x + rcParentConPxl.left;
                rcNewActualPxl.top  = y + rcParentConPxl.top;
            }
            break;

        case SGR_CONTAINER:
            if (m_fRelative && (GetParent() != NULL)) {
                RECT rcParentConPxl;
                GetParent()->GetLogRect(&rcParentConPxl, SGR_CONTAINER);
                rcNewActualPxl.left = x - rcParentConPxl.left;
                rcNewActualPxl.top  = y - rcParentConPxl.top;
            } else {
                rcNewActualPxl.left   = x;
                rcNewActualPxl.top    = y;
            }
            break;

        case SGR_DESKTOP:
            AssertMsg(0, "Not implemented");
            return E_NOTIMPL;

        case SGR_OFFSET:
            rcNewActualPxl.left += x;
            rcNewActualPxl.top  += y;
            break;

        case SGR_CLIENT:
            // Can't set using the client rect
            return E_INVALIDARG;

        default:
            return E_NOTIMPL;
        }

        if ((rcNewActualPxl.left != m_rcLogicalPxl.left) ||
            (rcNewActualPxl.top != m_rcLogicalPxl.top)) {

            //
            // Actually moved the Gadget
            //

            SetFlag(nChangeFlags, SGR_MOVE);
        }
    }


    //
    // Change the size
    //

    SIZE sizeOld;
    sizeOld.cx = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    sizeOld.cy = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    if (TestFlag(nFlags, SGR_SIZE) && ((w != sizeOld.cx) || (h != sizeOld.cy))) {
        SetFlag(nChangeFlags, SGR_SIZE);

        rcNewActualPxl.right  = rcNewActualPxl.left + w;
        rcNewActualPxl.bottom = rcNewActualPxl.top + h;
    } else {
        //
        // Not actually resizing the DuVisual, so just update the right and 
        // bottom from the original size.
        //

        rcNewActualPxl.right  = rcNewActualPxl.left + sizeOld.cx;
        rcNewActualPxl.bottom = rcNewActualPxl.top + sizeOld.cy;
    }


    if (nChangeFlags) {
        AssertMsg(!InlineEqualRect(&m_rcLogicalPxl, &rcNewActualPxl), 
                "Ensure recorded change actually occured");


        //
        // Check against wrap-around.  
        //
        // NOTE: This must be done after recomputing everything, since there are
        // many combinations of location / size changes that may cause a 
        // wrap-around.
        //

        if ((rcNewActualPxl.right < rcNewActualPxl.left) || (rcNewActualPxl.bottom < rcNewActualPxl.top)) {
            PromptInvalid("New location exceeds coordinate limits");
            return E_INVALIDARG;
        }
                

        //
        // Remember how much we moved
        //

        SIZE sizeDelta;
        sizeDelta.cx    = rcNewActualPxl.left - m_rcLogicalPxl.left;
        sizeDelta.cy    = rcNewActualPxl.top - m_rcLogicalPxl.top;


        //
        // Now that the new rectangle has been determined, need to commit it 
        // back.  
        //

        m_rcLogicalPxl = rcNewActualPxl;


        //
        // Need to go through all of children moving them if they are not relative 
        // and we are not relative.
        //
        if (TestFlag(nChangeFlags, SGR_MOVE) && (!m_fRelative)) {
            AssertMsg((sizeDelta.cx != 0) || (sizeDelta.cy != 0), 
                    "Must actually move if SGR_MOVE was set on nChangeFlags");

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (!pgadCur->m_fRelative) {
                    pgadCur->SLROffsetLogRect(&sizeDelta);
                }
                pgadCur = pgadCur->GetNext();
            }
        }


        //
        // Finally, if the rect was changed, notify the Gadget and 
        // invalidate / update the affected areas.
        //

        RECT rcNewParentPxl;
        GetLogRect(&rcNewParentPxl, SGR_PARENT);
        m_cb.xdFireChangeRect(this, &rcNewParentPxl, nChangeFlags | SGR_PARENT);

        if (fInvalidate && IsVisible()) {
            SLRUpdateBits(&rcOldParentPxl, &rcNewParentPxl, nChangeFlags);
        }

        xdUpdatePosition();
        xdUpdateAdaptors(GSYNC_RECT);
    } else {
        AssertMsg(InlineEqualRect(&m_rcLogicalPxl, &rcNewActualPxl), 
                "Rect change was not properly recorded");
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::SLRUpdateBits
*
* SLRUpdateBits() optimizes how invalidation and update of a Gadget after
* it has been repositioned or resized by xdSetLogRect().  There are a bunch
* of checks that can short-circuit what needs to be done to minimize the
* amount of repainting and flickering.
*
\***************************************************************************/

void
DuVisual::SLRUpdateBits(
    IN  RECT * prcOldParentPxl,         // Old location in parent pixels
    IN  RECT * prcNewParentPxl,         // New location in container pixels
    IN  UINT nChangeFlags)              // Change flags
{
    AssertMsg(IsVisible(), "Only should be called on visible Gadgets");

    //
    // If the parent has already been completely invalidated, we don't need 
    // to invalidate any children.
    //

    if (IsParentInvalid()) {
        return;
    }


    //
    // The rectangle is visible, so we need to invalidate both the old
    // and new positions.  These need to be computed in the current 
    // CLIENT coordinates so that any XForms can be properly taken into
    // account.
    //

    DuContainer * pcon = GetContainer();

#if DBG
    RECT rcBackupOldConPxl = *prcOldParentPxl;
    RECT rcBackupNewConPxl = *prcNewParentPxl;

    UNREFERENCED_PARAMETER(rcBackupOldConPxl);
    UNREFERENCED_PARAMETER(rcBackupNewConPxl);
#endif // DBG

#if ENABLE_OPTIMIZESLRUPDATE
    //
    // Let the optimizations begin!
    // 
    // NOTE: Remember that GDI coordinates are a little screwy.  Any time we
    // use left for right or right for left, we need to +1 or -1 appropriately.
    // (Same for top and bottom)
    //
    // At this point, this Gadget already has an updated position and size.
    // When calling DoInvalidateRect() to invalidate, the old position may 
    // be clipped inside the new position.  To fix, pass in coordinates on the
    // PARENT Gadget instead of the Gadget being moved.  This should give a
    // correct result.
    //

    if (nChangeFlags == SGR_SIZE) {
        //
        // Pure sizing optimizations:
        // Unless the XREDRAW flag is turned on specifying that the entire 
        // Gadget needs to repaint when resized, limit the invalid area to the 
        // difference between the two rectangles.
        //

        int xOffset = - prcNewParentPxl->left;
        int yOffset = - prcNewParentPxl->top;

        RECT * prcOldClientPxl = prcOldParentPxl;
        RECT * prcNewClientPxl = prcNewParentPxl;

        InlineOffsetRect(prcOldClientPxl, xOffset, yOffset);
        InlineOffsetRect(prcNewClientPxl, xOffset, yOffset);


        AssertMsg((prcOldClientPxl->left == prcNewClientPxl->left) &&
                (prcOldClientPxl->top == prcNewClientPxl->top), "Ensure position has not moved");

        if ((!m_fHRedraw) || (!m_fVRedraw)) {
            BOOL fChangeHorz    = (prcOldClientPxl->right != prcNewClientPxl->right);
            BOOL fChangeVert    = (prcOldClientPxl->bottom != prcNewClientPxl->bottom);

            RECT rgrcInvalidClientPxl[2];
            int idxCurRect = 0;

            BOOL fPadding = FALSE;
            RECT rcPadding = { 0, 0, 0, 0 };

            ReadOnlyLock rol;
            fPadding = m_cb.xrFireQueryPadding(this, &rcPadding);

            if (fChangeHorz && (!m_fHRedraw)) {
                RECT * prcCur   = &rgrcInvalidClientPxl[idxCurRect++];
                prcCur->left    = min(prcOldClientPxl->right, prcNewClientPxl->right) - 1;
                prcCur->right   = max(prcOldClientPxl->right, prcNewClientPxl->right);
                prcCur->top     = prcNewClientPxl->top;
                prcCur->bottom  = max(prcOldClientPxl->bottom, prcNewClientPxl->bottom);

                if (fPadding) {
                    prcCur->right -= rcPadding.right;
                    if (prcCur->right < prcCur->left) {
                        prcCur->right = prcCur->left;
                    }
                }

                fChangeHorz     = FALSE;
            }

            if (fChangeVert && (!m_fVRedraw)) {
                RECT * prcCur   = &rgrcInvalidClientPxl[idxCurRect++];
                prcCur->left    = prcNewClientPxl->left;
                prcCur->right   = max(prcOldClientPxl->right, prcNewClientPxl->right);
                prcCur->top     = min(prcOldClientPxl->bottom, prcNewClientPxl->bottom) - 1;
                prcCur->bottom  = max(prcOldClientPxl->bottom, prcNewClientPxl->bottom);

                if (fPadding) {
                    prcCur->bottom -= rcPadding.bottom;
                    if (prcCur->bottom < prcCur->top) {
                        prcCur->bottom = prcCur->top;
                    }
                }

                fChangeVert     = FALSE;
            }

            if (fChangeHorz || fChangeVert) {
                //
                // We were unable to remove all of the changes, so we need to 
                // invalidate the maximum area.
                //

                RECT rcMax;
                rcMax.left      = 0;
                rcMax.top       = 0;
                rcMax.right     = max(prcNewClientPxl->right, prcOldClientPxl->right);
                rcMax.bottom    = max(prcNewClientPxl->bottom, prcOldClientPxl->bottom);

                SLRInvalidateRects(pcon, &rcMax, 1);
                return;
            } else if (idxCurRect > 0) {
                //
                // We were able to optimize out the invalidate with H/VRedraw,
                // so invalidate the built rectangles.
                //

                SLRInvalidateRects(pcon, rgrcInvalidClientPxl, idxCurRect);
                return;
            }
        }
    }
#endif // ENABLE_OPTIMIZESLRUPDATE


    //
    // We were not able to optimize, so need to invalidate both the old and 
    // new locations so that everything gets properly redrawn.
    //


    //
    // Invalidate the old location.  We can NOT just call SLRInvalidateRects()
    // because this works off our current location.
    //
    // To invalidate the old location:
    // - Offset from parent to client
    // - Apply XForms to scale to the correct bounding area
    // - Offset back from client to parent
    // - Invalidate
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        RECT rcOldClientPxl, rcOldParentClientPxl;
        SIZE sizeDeltaPxl;

        InlineCopyZeroRect(&rcOldClientPxl, prcOldParentPxl);
        DoXFormClientToParent(&rcOldParentClientPxl, &rcOldClientPxl, 1, HINTBOUNDS_Invalidate);

        sizeDeltaPxl.cx = prcNewParentPxl->left - prcOldParentPxl->left;
        sizeDeltaPxl.cy = prcNewParentPxl->top - prcOldParentPxl->top;
        InlineOffsetRect(&rcOldParentClientPxl, -sizeDeltaPxl.cx, -sizeDeltaPxl.cy);

        pgadParent->DoInvalidateRect(pcon, &rcOldParentClientPxl, 1);
    }


    //
    // Invalidate the new location
    //

    RECT rcNewClientPxl;
    InlineCopyZeroRect(&rcNewClientPxl, prcNewParentPxl);
    SLRInvalidateRects(pcon, &rcNewClientPxl, 1);


    //
    // Mark this Gadget as completely invalid
    //

    m_fInvalidFull  = TRUE;
#if ENABLE_OPTIMIZEDIRTY
    m_fInvalidDirty = TRUE;
#endif
    
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
    }
}


/***************************************************************************\
*
* DuVisual::SLRInvalidateRects
*
* SLRInvalidateRects() invalidates a collection of client-relative rects
* that are now need to be updated as a result of xdSetLogRect().
* 
* NOTE: This is NOT a general purpose invalidation function and has been
* designed specifically for use in SLRUpdateBits();
*
\***************************************************************************/

void        
DuVisual::SLRInvalidateRects(
    IN  DuContainer * pcon,             // Container (explicit for perf reasons)
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    DuVisual * pgadParent = GetParent();
    if (pgadParent) {
        //
        // We have a parent, so pass the coordinates to invalid in as 
        // parent coordinates so that old positions don't get clipped 
        // by the new position.
        //

        RECT * rgrcParentPxl = (RECT *) _alloca(cRects * sizeof(RECT));
        DoXFormClientToParent(rgrcParentPxl, rgrcClientPxl, cRects, HINTBOUNDS_Invalidate);
        pgadParent->DoInvalidateRect(pcon, rgrcParentPxl, cRects);

    } else {
        DoInvalidateRect(pcon, rgrcClientPxl, cRects);
    }
}


/***************************************************************************\
*
* DuVisual::SLROffsetLogRect
*
* SLROffsetLogRect() deep walks through all non-relative child of a subtree,
* offsetting their position relative to their parent.  This function is 
* designed to be called from xdSetLogRect() when moving a non-relative Gadget.
*
* NOTE: Only the "top" Gadget will be notified that it has been moved.  Its
* children are not notified.  This is consistent with Win32 HWND's.  Also,
* SimpleGadget's will not be re-invalidated since their parent has already
* been invalidated.
*
\***************************************************************************/

void        
DuVisual::SLROffsetLogRect(const SIZE * psizeDeltaPxl)
{
    AssertMsg(GetParent() != NULL, "Should only call on children");
    AssertMsg((psizeDeltaPxl->cx != 0) || (psizeDeltaPxl->cy != 0), 
            "Ensure actually moving child Gadget");

    m_rcLogicalPxl.left     += psizeDeltaPxl->cx;
    m_rcLogicalPxl.top      += psizeDeltaPxl->cy;
    m_rcLogicalPxl.right    += psizeDeltaPxl->cx;
    m_rcLogicalPxl.bottom   += psizeDeltaPxl->cy;

    DuVisual * pgadCur = GetTopChild();
    while (pgadCur != NULL) {
        if (!pgadCur->m_fRelative) {
            pgadCur->SLROffsetLogRect(psizeDeltaPxl);
        }
        pgadCur = pgadCur->GetNext();
    }
}


/***************************************************************************\
*
* DuVisual::FindStepImpl
*
* FindStepImpl() processes a single step inside FindFromPoint()   A given 
* point will be properly transformed from its current parent coordinates 
* into coordinates for the specified DuVisual and compared against the logical 
* rectangle.
*
* This function should not be called directly and is designed to be called
* only from FindFromPoint() and is designed to have high-speed execution.
*
\***************************************************************************/

BOOL
DuVisual::FindStepImpl(
    IN  const DuVisual * pgadCur, // Current DuVisual
    IN  int xOffset,                // DuVisual X offset from parent
    IN  int yOffset,                // DuVisual Y offset from parent
    IN OUT POINT * pptFindPxl       // Point to apply modify for Find step
    ) const
{
    //
    // It is very important to apply these transformations in the correct
    // order, of the point that is computed will not match was was actually
    // drawn.
    //

    //
    // First, offset the origin on the DuVisual.  We need to do this before
    // applying the XForm matrix.  If we were using Matrix.Translate() to do
    // this, we would do this after applying any Scale() and Rotate().
    //

    pptFindPxl->x -= xOffset;
    pptFindPxl->y -= yOffset;


    //
    // Apply XForms to search point
    //

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();

        Matrix3 matTemp;
        pxfi->ApplyAnti(&matTemp);
        matTemp.Execute(pptFindPxl, 1);
    }


    //
    // We have a point, so determine use the bounding rectangle to determine
    // if this point is inside this DuVisual
    //

    RECT rcChildPxl;
    InlineCopyZeroRect(&rcChildPxl, &pgadCur->m_rcLogicalPxl);
    return InlinePtInRect(&rcChildPxl, *pptFindPxl);
}


/***************************************************************************\
*
* DuVisual::FindFromPoint
*
* FindFromPoint() walks a DuVisual-tree looking for a DuVisual that hit-tests
* with a given point in coordinate pixels.  
* 
* NOTE: This function has been written to directly take information 
* including relative coordinates and XForms into account to give better 
* performance.  This function is called very often (for every mouse move) 
* and needs to be very high-performance.
*
* The design of this algorithm is slightly different than how Win32k/User 
* searches.  In NT-User, all WND's are stored using absolute 
* desktop-relative positioning.  The search begins at the top of the tree 
* and flows down, performing flat PtInRect comparisons against each WND's
* rectangle.  The search point (ptContainerPxl) is NOT modified during the
* search.
*
* In DirectUser/Core, each DuVisual may be either relative or absolutely 
* positioned to its parent.  They may also have transformation information.
* To acheive high-performance, the point is modified into client coordinates
* for each DuVisual.  If the point is inside this DuVisual, ptContainerPxl is
* updated and the scan continues from that DuVisual.  If the point is not
* inside, it is restored to the previous point and searching continues along
* the siblings.  By modifying the point as it is traversed down the tree,
* only DuVisuals with actual transformations need to apply Matrix operations
* to transform the point.
*
\***************************************************************************/

DuVisual *      
DuVisual::FindFromPoint(
    IN  POINT ptThisClientPxl,      // Container point to start searching from
    IN  UINT nStyle,                // Required style
    OUT POINT * pptFoundClientPxl   // Optional resulting point in client pixels
    ) const
{
    if (pptFoundClientPxl != NULL) {
        pptFoundClientPxl->x = ptThisClientPxl.x;
        pptFoundClientPxl->y = ptThisClientPxl.y;
    }
    
    //
    // Check conditions
    //

    if (!TestAllFlags(m_nStyle, nStyle)) {
        return NULL;
    }
    
    
    //
    // Setup the point to search from.  If not at the top of the tree, 
    // need to build a XForm matrix to modify the point.
    //
    // Determine if the point is in the DuVisual that we are starting in.  If 
    // not, have a short-way out.  This has to be done after the point has 
    // already been setup.
    //

    POINT ptParentPxl, ptTest;
    if (!FindStepImpl(this, 0, 0, &ptThisClientPxl)) {
        return NULL;  // Point not inside root DuVisual
    }

    const DuVisual * pgadCur = this;

    
    //
    // Start continuously updated parent coordinates in upper left corner.  As
    // we find each successive containing DuVisual, these will be updated to the
    // new parent coordinates.
    //

    ptParentPxl.x   = 0;
    ptParentPxl.y   = 0;


    //
    // Scan down the tree, looking for intersections with this point and a
    // child's location.
    //

ScanChild:
    const DuVisual * pgadChild = pgadCur->GetTopChild();
    while (pgadChild != NULL) {
        //
        // Check if Gadget matches the specified flags.
        //


        if (!TestAllFlags(pgadChild->m_nStyle, nStyle)) {
            goto ScanNextSibling;
        }


        //
        // Check if point is "inside" the Gadget.
        //

        {
            int xOffset = pgadChild->m_rcLogicalPxl.left;
            int yOffset = pgadChild->m_rcLogicalPxl.top;

            if (!pgadChild->m_fRelative) {
                xOffset -= ptParentPxl.x;
                yOffset -= ptParentPxl.y;
            }

            ptTest = ptThisClientPxl;
            if (pgadChild->FindStepImpl(pgadChild, xOffset, yOffset, &ptTest)) {
                //
                // If the Gadget has an irregular shape, we need to callback 
                // and ask if the point is actually inside or not.
                //

                if (pgadChild->m_fCustomHitTest) {
                    //
                    // The application is not allowed to modify the tree while 
                    // we are calling back on each node to hit-test.
                    //

                    ReadOnlyLock rol;

                    POINT ptClientPxl;
                    ptClientPxl.x   = ptThisClientPxl.x - xOffset;
                    ptClientPxl.y   = ptThisClientPxl.y - yOffset;

                    UINT nResult;
                    pgadChild->m_cb.xrFireQueryHitTest(pgadChild, ptClientPxl, &nResult);
                    switch (nResult)
                    {
                    case GQHT_NOWHERE:
                        // Not inside this Gadget, so continue checking its sibling
                        goto ScanNextSibling;

                    default:
                    case GQHT_INSIDE:
                        // Inside this Gadget, so continue processing normally
                        break;

                    case GQHT_CHILD:
                        // We were directly given an HGADGET back, so validate it
                        // and continue processing from it.

                        // TODO: Implement this code.
                        break;
                    }
                }


                //
                // We now know that the point is inside the Gadget, so setup for
                // another loop to check our children.
                //

                if (pgadChild->m_fRelative) {
                    //
                    // Relative child intersects.  Update the "parent" 
                    // coordinates and scan this child.
                    //

                    ptParentPxl.x   = ptParentPxl.x + xOffset;
                    ptParentPxl.y   = ptParentPxl.y + yOffset;
                } else {
                    //
                    // Non-relative child intersects.  Update the "parent" 
                    // coordinates and scan this child.
                    //

                    ptParentPxl.x   = pgadChild->m_rcLogicalPxl.left;
                    ptParentPxl.y   = pgadChild->m_rcLogicalPxl.top;
                }

                pgadCur         = pgadChild;
                ptThisClientPxl = ptTest;
                goto ScanChild;
            }
        }

ScanNextSibling:
        pgadChild = pgadChild->GetNext();
    }

    
    //
    // Got all of the way without any child being hit.  This must be the 
    // correct DuVisual.
    //

    if (pptFoundClientPxl != NULL) {
        pptFoundClientPxl->x = ptThisClientPxl.x;
        pptFoundClientPxl->y = ptThisClientPxl.y;
    }

    return const_cast<DuVisual *> (pgadCur);
}


/***************************************************************************\
*
* DuVisual::MapPoint
*
* MapPoint() converts a given point from container-relative pixels into 
* client-relative pixels.  The DuVisual tree is walked down from the root with
* each node applying any transformation operation on the given pixel.  When
* the tree has been fully walked down to the starting node, the given point
* will be in client-relative pixels.
*
* This function is designed to work with other functions including 
* FindFromPoint() to convert from actual pixels given by the container into
* logical pixels that an individual DuVisual understands.  MapPoint() should 
* be called the point is being translated for a specific DuVisual (for example
* when the mouse is captured).  FindFromPoint() should be called to find a 
* DuVisual at a specific point.
*
\***************************************************************************/

void
DuVisual::MapPoint(
    IN OUT POINT * pptPxl            // IN: ContainerPxl, OUT: ClientPxl
    ) const
{
    //
    // Need to walk up the tree so that we apply any XForm's from the root.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MapPoint(pptPxl);
    }

    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        pptPxl->x -= rcPxl.left;
        pptPxl->y -= rcPxl.top;
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        Matrix3 mat;
        pxfi->ApplyAnti(&mat);
        mat.Execute(pptPxl, 1);
    }
}


//------------------------------------------------------------------------------
void
DuVisual::MapPoint(
    IN  POINT ptContainerPxl,       // Point to convert
    OUT POINT * pptClientPxl        // Converted point
    ) const
{
    *pptClientPxl = ptContainerPxl;
    MapPoint(pptClientPxl);
}


//------------------------------------------------------------------------------
void
DuVisual::MapPoints(
    IN  const DuVisual * pgadFrom, 
    IN  const DuVisual * pgadTo, 
    IN OUT POINT * rgptClientPxl, 
    IN  int cPts)
{
    AssertMsg(pgadFrom->GetRoot() == pgadTo->GetRoot(),
            "Must be in the same tree");

    //
    // Walk up the tree, converting at each stage from client pixels into the 
    // parent's client pixels
    //

    const DuVisual * pgadCur = pgadFrom;
    while (pgadCur != NULL) {
        if (pgadCur == pgadTo) {
            return;
        }

        pgadCur->DoXFormClientToParent(rgptClientPxl, cPts);
        pgadCur = pgadCur->GetParent();
    }


    //
    // Now, just map the point into the destination
    //

    Matrix3 mat;
    pgadTo->BuildAntiXForm(&mat);
    mat.Execute(rgptClientPxl, cPts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\msgq.h ===
/***************************************************************************\
*
* File: MsgQ.h
*
* Description:
* MsgQ defines a lightweight queue of Gadget messages.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__MsgQ_h__INCLUDED)
#define CORE__MsgQ_h__INCLUDED
#pragma once

class DuEventGadget;
class CoreST;
struct MsgEntry;

typedef HRESULT (CALLBACK * ProcessMsgProc)(MsgEntry * pEntry);

struct MsgEntry : public ReturnMem
{
    inline  GMSG *      GetMsg() const;

            Thread *    pthrSender; // Sending thread
            MsgObject * pmo;        // Gadget message is about
            UINT        nFlags;     // Flags modifying message
            HANDLE      hEvent;     // Event to notify when complete
            HRESULT     nResult;    // Result from GadgetProc()
            ProcessMsgProc
                        pfnProcess; // Message processing callback
};

#define SGM_ALLOC           0x80000000      // Allocated memory should be freed by receiver
#define SGM_RETURN          0x40000000      // Allocated memory should be returned to called

#define SGM_ENTIRE         (SGM_VALID | SGM_ALLOC | SGM_RETURN)

HRESULT CALLBACK   xwProcessDirect(MsgEntry * pEntry);
HRESULT CALLBACK   xwProcessFull(MsgEntry * pEntry);
HRESULT CALLBACK   xwProcessMethod(MsgEntry * pEntry);

void            xwInvokeMsgTableFunc(const MsgObject * pmo, MethodMsg * pmsg);
ProcessMsgProc  GetProcessProc(DuEventGadget * pdgb, UINT nFlags);


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ defines a light-weight queue of messages.  This class itself 
* is NOT thread-safe and is normally wrapped with another class like SafeMsgQ 
* that provides thread-safe operations.
*
*****************************************************************************
\***************************************************************************/

class BaseMsgQ
{
// Operations
public:
#if DBG
    inline  void        DEBUG_MarkStartDestroy();
#endif // DBG

// Implementation
protected:
            void        xwProcessNL(MsgEntry * pHead);
    static  void CALLBACK MsgObjectFinalUnlockProcNL(BaseObject * pobj, void * pvData);

// Data
protected:
#if DBG
            BOOL        m_DEBUG_fStartDestroy:1;
#endif // DBG
};


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ defines a customized queue that supports inter-thread
* messaging.
*
*****************************************************************************
\***************************************************************************/

class SafeMsgQ : public BaseMsgQ
{
// Construction
public:
            ~SafeMsgQ();

// Operations
public:
    inline  BOOL        IsEmpty() const;

    inline  void        AddNL(MsgEntry * pEntry);
            void        xwProcessNL();
            HRESULT     PostNL(Thread * pthrSender, GMSG * pmsg, MsgObject * pmo, ProcessMsgProc pfnProcess, UINT nFlags);

// Data
protected:
            GInterlockedList<MsgEntry> m_lstEntries;
};


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ defines a customized queue that supports additional 
* functionality for enqueing "delayed" messages.
*
*****************************************************************************
\***************************************************************************/

class DelayedMsgQ : protected BaseMsgQ
{
// Construction
public:
    inline  ~DelayedMsgQ();
    inline  void        Create(TempHeap * pheap);

// Operations
public:
    inline  BOOL        IsEmpty() const;

            void        xwProcessDelayedNL();
            HRESULT     PostDelayed(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags);

// Implementation
protected:
    inline  void        Add(MsgEntry * pEntry);

// Data
protected:
            GSingleList<MsgEntry> m_lstEntries;
            TempHeap *  m_pheap;
            BOOL        m_fProcessing:1;
};

#include "MsgQ.inl"

#endif // CORE__MsgQ_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\msgq.cpp ===
/***************************************************************************\
*
* File: MsgQ.h
*
* Description:
* MsgQ defines a lightweight queue of Gadget messages.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "MsgQ.h"

#include "BaseGadget.h"
#include "TreeGadget.h"

#define ENABLE_CHECKLOOP    0

#if ENABLE_CHECKLOOP
#include <conio.h>
#endif

/***************************************************************************\
*****************************************************************************
*
* Global functions
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* xwProcessDirect
*
* xwProcessDirect() provides a MsgEntry "process" callback to process
* "Direct Event" messages on a BaseGadget.  These messages were determined
* to be "direct" at the time that they were enqueued.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessDirect(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(TestFlag(pEntry->pmo->GetHandleMask(), hmEventGadget), 
            "Direct messages must be BaseGadget's");
    AssertMsg(pEntry->GetMsg()->nMsg >= GM_EVENT, "Must be an event");

    DuEventGadget * pdgbMsg = static_cast<DuEventGadget *>(pEntry->pmo);
    const GPCB & cb = pdgbMsg->GetCallback();
    return cb.xwInvokeDirect(pdgbMsg, (EventMsg *) pEntry->GetMsg());
}


/***************************************************************************\
*
* xwProcessFull
*
* xwProcessFull() provides a MsgEntry "process" callback to process
* "Full Event" messages on a BaseGadget.  These messages were determined
* to be "full" at the time that they were enqueued.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessFull(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(TestFlag(pEntry->pmo->GetHandleMask(), hmVisual), 
            "Direct messages must be Visual's");
    AssertMsg(pEntry->GetMsg()->nMsg >= GM_EVENT, "Must be an event");

    DuVisual * pdgvMsg = static_cast<DuVisual *>(pEntry->pmo);
    const GPCB & cb = pdgvMsg->GetCallback();
    return cb.xwInvokeFull(pdgvMsg, (EventMsg *) pEntry->GetMsg());
}


/***************************************************************************\
*
* xwProcessMethod
*
* xwProcessMethod() provides a MsgEntry "process" callback to process
* "Method" messages on any MsgObject.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessMethod(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(pEntry->GetMsg()->nMsg < GM_EVENT, "Must be a method");
    pEntry->pmo->InvokeMethod((MethodMsg *) pEntry->GetMsg());
    return DU_S_COMPLETE;
}


/***************************************************************************\
*
* GetProcessProc
*
* GetProcessProc() determines the "process" callback to use on a BaseGadget
* to process a specific Event message.  This function is called at the time
* the message is being enqueued when the "process" callback needs to be 
* determined.
*
\***************************************************************************/

ProcessMsgProc 
GetProcessProc(
    IN  DuEventGadget * pdgb,            // BaseGadget receiving message
    IN  UINT nFlags)                    // Send/Post GadgetEvent() flags
{
    if (TestFlag(nFlags, SGM_FULL)) {
        const DuVisual * pgadTree = CastVisual(pdgb);
        if (pgadTree != NULL) {
            return xwProcessFull;
        }
    }

    return xwProcessDirect;
}


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* BaseMsgQ::MsgObjectFinalUnlockProcNL
*
* MsgObjectFinalUnlockProcNL() is called by xwUnlockNL() if the specified 
* BaseObject is about to start the destruction process.  This provides the
* caller, in this case xwProcessNL, an opportunity to prepare for the 
* object's destruction, in this case by setting up a ContextLock.
*
\***************************************************************************/

void CALLBACK 
BaseMsgQ::MsgObjectFinalUnlockProcNL(
    IN  BaseObject * pobj,              // Object being destroyed
    IN  void * pvData)                  // ContextLock data
{
    ContextLock * pcl = reinterpret_cast<ContextLock *> (pvData);
    AssertMsg(pcl != NULL, "Must provide a valid ContextLock");

    DuEventGadget * pgad = CastBaseGadget(pobj);
    AssertMsg(pgad != NULL, "Must provide a valid Gadget");

    Verify(pcl->LockNL(ContextLock::edDefer, pgad->GetContext()));
}


/***************************************************************************\
*
* BaseMsgQ::xwProcessNL
*
* xwProcessNL() walks through a list and invokes each message.  Since
* we can't be inside a ContextLock during a callback, this function is an
* "NL" (No Context Lock) function.  It is also a "xw" function because we
* are making the callbacks right now, so everything needs to be properly 
* locked.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

void        
BaseMsgQ::xwProcessNL(
    IN  MsgEntry * pEntry)              // List of entries (FIFO)
{
    //
    // Walk through the list, processing and cleaning up each message.
    //
    // Each Gadget has already been Lock()'d when it was added to the queue,
    // so it is safe to call xwInvoke().  After the message is invoked,
    // Unlock() the Gadget.
    //

#if DBG_CHECK_CALLBACKS
    DWORD cMsgs = 0;
#endif

    MsgEntry * pNext;
    while (pEntry != NULL) {
#if DBG_CHECK_CALLBACKS
        cMsgs++;
        if (!IsInitThread()) {
            AutoTrace("Current message %d = 0x%p\n", cMsgs, pEntry);
            AlwaysPromptInvalid("DirectUser has been uninitialized while processing a message");
        }
#endif
        
        pNext = static_cast<MsgEntry *> (pEntry->pNext);
        UINT nFlags = pEntry->nFlags;
        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");
        AssertMsg(pEntry->pfnProcess, "Must specify pfnProcess when enqueuing message");
        
        MsgObject * pmo = pEntry->pmo;
        pEntry->nResult = (pEntry->pfnProcess)(pEntry);

        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

        HANDLE hevNotify = pEntry->hEvent;

        {
            //
            // If the Gadget gets finally unlocked and starts destruction, we 
            // may call a whole slew of non-NL functions that require the 
            // ContextLock.  To accomodate this, pass a special function that
            // will grab the ContextLock if the object is being destroyed.
            //

            ContextLock cl;
            pmo->xwUnlockNL(MsgObjectFinalUnlockProcNL, &cl);
        }

        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

        if (TestFlag(nFlags, SGM_RETURN)) {
            Thread * pthrReturn = pEntry->pthrSender;
            pthrReturn->ReturnMemoryNL(pEntry);
        } else if (TestFlag(nFlags, SGM_ALLOC)) {
            ProcessFree(pEntry);
        }

        if (hevNotify != NULL) {
            SetEvent(hevNotify);
        }

        pEntry = pNext;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
SafeMsgQ::~SafeMsgQ()
{
    AssertMsg(m_lstEntries.IsEmptyNL(), "All messages should already have been processed");

    //
    // If there are any message (for some unknown reason), we need to full
    // process them so that the Gadgets get unlocked, memory gets free'd, and
    // blocked threads get signaled.
    //

    xwProcessNL();
}


/***************************************************************************\
*
* SafeMsgQ::xwProcessNL
*
* xwProcessNL() walks through a list and invokes each message.  Since
* we can't be inside a ContextLock during a callback, this function is an
* "NL" (No Context Lock) function.  It is also a "xw" function because we
* are making the callbacks right now, so everything needs to be properly 
* locked.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

void
SafeMsgQ::xwProcessNL()
{
    //
    // Keep processing the list until it is empty.
    // Reverse the list so that the first entry is at the head.
    //
    // NOTE: Some callers (such as DelayedMsgQ) heavily rely on this behavior.
    //

    while (!IsEmpty()) {
        MsgEntry * pEntry = m_lstEntries.ExtractNL();
        ReverseSingleList(pEntry);
        BaseMsgQ::xwProcessNL(pEntry);
    }
}


/***************************************************************************\
*
* SafeMsgQ::PostNL
*
* PostNL adds a new message to the Q.  This function does not block 
* waiting for the message to be processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the destination Gadget's CoreSC 
* and not the current CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
SafeMsgQ::PostNL(
    IN  Thread * pthrSender,        // Sending thread
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  ProcessMsgProc pfnProcess,  // Message processing function
    IN  UINT nFlags)                // Message flags
{
    HRESULT hr = DU_E_GENERIC;
    AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    MsgEntry * pEntry;


    //
    // Determine the heap to use to allocate the message from.  If the sending
    // thread is initialized, use its heap.  Otherwise, we need to use the 
    // receiving thread's heap.  It is preferable to use the sending threads 
    // heap since the memory can be returned to us, giving better scalability
    // especially with producer / consumer situations.
    //

    if (pthrSender != NULL) {
        AssertMsg(!TestFlag(nFlags, SGM_RECEIVECONTEXT), 
                "If using the receiving context, can't pass a sending thread");
        pEntry = (MsgEntry *) pthrSender->AllocMemoryNL(cbAlloc);
        nFlags |= SGM_RETURN;
    } else {
        pEntry = (MsgEntry *) ProcessAlloc(cbAlloc);
        nFlags |= SGM_ALLOC;
    }

    if (pEntry == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //
    // Setup the message to be queued.
    //

    AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

    CopyMemory(pEntry->GetMsg(), pmsg, pmsg->cbSize);
    pEntry->pthrSender  = pthrSender;
    pEntry->pmo         = pmo;
    pEntry->pfnProcess  = pfnProcess;
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = NULL;
    pEntry->nResult     = 0;

    AddNL(pEntry);
    hr = S_OK;

Exit:
    return hr;
}


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DelayedMsgQ::PostDelayed
*
* PostDelayed() adds a new delayed message to the Q.  The memory for 
* this message will be freed when xwProcessDelayedNL() is called.
*
\***************************************************************************/

HRESULT     
DelayedMsgQ::PostDelayed(
    IN  GMSG * pmsg,                // Message to send
    IN  DuEventGadget * pgadMsg,     // Destination Gadget of message
    IN  UINT nFlags)                // Message flags
{
    AssertMsg(m_pheap != NULL, "Heap must be initialized");
    HRESULT hr = DU_E_GENERIC;

    BOOL fEmpty = IsEmpty();

    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    MsgEntry * pEntry = (MsgEntry *) m_pheap->Alloc(cbAlloc);
    if (pEntry == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //
    // If this is the first time we are adding a message to the temporary heap, 
    // we need to lock it so that the memory doesn't go away from under us.
    //
    // NOTE: It is VERY important that the Lock()'s and Unlock()'s are properly
    // paired, or the memory will never be reclaimed.  Since we automatically
    // Unlock() at the end of processing, and we stay processing if any messages
    // were added (even to an empty Q) during processing, only lock the heap if
    // there are no messages and we have not started processing.
    //

    if (fEmpty && (!m_fProcessing)) {
        m_pheap->Lock();
    }

    CopyMemory(pEntry->GetMsg(), pmsg, pmsg->cbSize);
    pEntry->pthrSender  = NULL;
    pEntry->pmo         = pgadMsg;
    pEntry->pfnProcess  = GetProcessProc(pgadMsg, nFlags);
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = NULL;
    pEntry->nResult     = 0;

    Add(pEntry);
    hr = S_OK;

Exit:
    return hr;
}


//------------------------------------------------------------------------------
void
DelayedMsgQ::xwProcessDelayedNL()
{
    AssertMsg(m_pheap != NULL, "Heap must be initialized");

    //
    // Processing the delayed messages is NOT re-entrant (even on the same 
    // thread).  Once started, xwProcessNL() will continue to process all
    // messages in the queue, even if more are adding during callbacks.  The key
    // is that we CAN NOT free the memory on our temporary heap until all of the
    // messages have been processed.
    //

    if (m_fProcessing) {
        return;
    }

    if (!IsEmpty()) {
        m_fProcessing = TRUE;


        //
        // Keep processing the list until it is empty.
        // Reverse the list so that the first entry is at the head.
        //
        // NOTE: Some callers (such as DelayedMsgQ) heavily rely on this behavior.
        //

        while (!IsEmpty()) {
            MsgEntry * pEntry = m_lstEntries.Extract();
            ReverseSingleList(pEntry);
            BaseMsgQ::xwProcessNL(pEntry);
        }

        m_pheap->Unlock();

        m_fProcessing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\messagegadget.h ===
/***************************************************************************\
*
* File: MessageGadget.h
*
* Description:
* DuListener defines a lightweight, "message-only" Gadget that can 
* send and receive GMSG's.  These can be used as Delegates.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuListener_h__INCLUDED)
#define CORE__DuListener_h__INCLUDED
#pragma once

#include "BaseGadget.h"

class DuListener : 
#if ENABLE_MSGTABLE_API
        public ListenerImpl<DuListener, DuEventGadget>
#else
        public DuEventGadget
#endif
{
// Construction
public:
    inline  DuListener();
            ~DuListener();
    static  HRESULT     Build(CREATE_INFO * pci, DuListener ** ppgadNew);
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Listener);
    static HRESULT CALLBACK
                        PromoteListener(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

#endif // ENABLE_MSGTABLE_API

// BaseObject Interface
public:
    virtual BOOL        IsStartDelete() const;
    virtual HandleType  GetHandleType() const { return htListener; }

// Implementation
protected:
            void        xwBeginDestroy();

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    // 
    // DuEventGadget:      10 DWORD's      (Debug = 11 DWORD's)
    //

            BOOL        m_fStartDestroy:1;  // 1 DWORD

    //
    // Current size:    11 DWORD's      (Debug = 11 DWORD's)
    //                  40 bytes        (Debug = 44 bytes)
    //
};

#include "MessageGadget.inl"

#endif // CORE__DuListener_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\messagegadget.inl ===
/***************************************************************************\
*
* File: MessageGadget.inl
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuListener_inl__INCLUDED)
#define CORE__DuListener_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class DuListener
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuListener * 
CastListener(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htListener)) {
        return (DuListener *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuListener * 
CastListener(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htListener)) {
        return (DuListener *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuListener * 
ValidateListener(HGADGET hgad)
{
    return CastListener(BaseObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline
DuListener::DuListener()
{

}


#endif // CORE__DuListener_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\msgq.inl ===
/***************************************************************************\
*
* File: MsgQ.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__MsgQ_inl__INCLUDED)
#define CORE__MsgQ_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* struct MsgEntry
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline GMSG *
MsgEntry::GetMsg() const
{
    return (GMSG *) (((BYTE *) this) + sizeof(MsgEntry));
}


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
inline void
BaseMsgQ::DEBUG_MarkStartDestroy()
{
    m_DEBUG_fStartDestroy = TRUE;
}

#endif // DBG


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL        
SafeMsgQ::IsEmpty() const
{
    return m_lstEntries.IsEmptyNL();
}


//------------------------------------------------------------------------------
inline void        
SafeMsgQ::AddNL(MsgEntry * pEntry)
{
    AssertMsg((pEntry->nFlags & SGM_ENTIRE) == pEntry->nFlags, "Ensure valid flags");
    AssertMsg(pEntry->pfnProcess, "Must specify pfnProcess when enqueuing message");
    AssertMsg(!m_DEBUG_fStartDestroy, "Must not have started final destruction");

    pEntry->pmo->Lock();
    m_lstEntries.AddHeadNL(pEntry);
}


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
DelayedMsgQ::~DelayedMsgQ()
{
    //
    // Deferred messages may be (legally) queued during the destruction process,
    // locking the Gadgets until they are properly processed.  We can't just 
    // ignore them because the Gadget's can shutdown until they are properly 
    // unlocked.
    //

    xwProcessDelayedNL();
}


//------------------------------------------------------------------------------
inline void
DelayedMsgQ::Create(TempHeap * pheap)
{
    AssertReadPtr(pheap);
    m_pheap = pheap;
}


//------------------------------------------------------------------------------
inline BOOL        
DelayedMsgQ::IsEmpty() const
{
    return m_lstEntries.IsEmpty();
}


//------------------------------------------------------------------------------
inline void        
DelayedMsgQ::Add(MsgEntry * pEntry)
{
    AssertMsg(!m_DEBUG_fStartDestroy, "Must not have started final destruction");

    pEntry->pmo->Lock();
    m_lstEntries.AddHead(pEntry);
}


#endif // CORE__MsgQ_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\parkcontainer.h ===
/***************************************************************************\
*
* File: ParkContainer.h
*
* Description:
* ParkContainer defines the "Parking Container" used to hold Gadgets that
* are in the process of being constructed.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__ParkContainer_h__INCLUDED)
#define CORE__ParkContainer_h__INCLUDED
#pragma once

#include "Container.h"
#include "RootGadget.h"

class DuParkGadget;
class DuParkContainer;

class DuParkGadget : public DuRootGadget
{
public:
    virtual ~DuParkGadget();
    static  HRESULT     Build(DuContainer * pconOwner, DuRootGadget ** ppgadNew);
    virtual void        xwDestroy();

    friend DuParkContainer;
};

class DuParkContainer : public DuContainer
{
// Construction
public:
			DuParkContainer();
	virtual ~DuParkContainer();
            HRESULT     Create();
            void        xwPreDestroy();

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htParkContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Data
protected:

    friend DuParkGadget;
};

//------------------------------------------------------------------------------
inline DuParkContainer * CastParkContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htParkContainer)) {
        return (DuParkContainer *) pBase;
    }
    return NULL;
}

DuParkContainer * GetParkContainer(DuVisual * pgad);

#endif // CORE__ParkContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\proplist.cpp ===
/***************************************************************************\
*
* File: PropList.cpp
*
* Description:
* PropList.cpp implements standard dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "PropList.h"

/***************************************************************************\
*****************************************************************************
*
* class PropSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* PropSet::GetData
* 
* GetData() searches through window-specific user-data for a specific
* data-element and returns the corresponding data.  If the data is not found,
* NULL is returned.
*
\***************************************************************************/

HRESULT
PropSet::GetData(
    IN PRID id,                     // Short ID to find
    OUT void ** ppnValue            // Value of property
    ) const
{
    // Check parameters
    AssertWritePtr(ppnValue);

    // Search data
    int idxData = FindItem(id);
    if (idxData >= 0) {
        *ppnValue = m_arData[idxData].pData;
        return S_OK;
    }

    *ppnValue = NULL;
    return E_INVALIDARG;
}


/***************************************************************************\
*
* PropSet::SetData
*
* SetDataImpl() searches through window-specific user-data for a specific
* data-element and changes the corresponding value.  If the data is not 
* found, a new data-element is added and the value is set.
*
\***************************************************************************/

HRESULT
PropSet::SetData(
    IN  PRID id,                    // Property to change / add
    IN  void * pNewData)            // New value of property
{
    //
    // Search for existing data.

    int idxData = FindItem(id);
    if (idxData >= 0) {
        m_arData[idxData].pData = pNewData;
        return S_OK;
    }


    //
    // Data not found, so need to add.  (don't forget to allocate for leading 
    // item count.)
    //

    return AddItem(id, pNewData) ? S_OK : E_OUTOFMEMORY;
}


/***************************************************************************\
*
* PropSet::SetData
*
* SetData() allocates and adds new data to the PDS.  If data with the same 
* PRID is found, it will be returned instead of new data being allocated.  
* If the old data is a different size than the new data, this will cause a 
* problem.
*
\***************************************************************************/

HRESULT
PropSet::SetData(
    IN  PRID id,                    // Property to change / add
    IN  int cbSize,                 // Size of data
    OUT void ** ppNewData)          // Memory for property
{
    AssertWritePtr(ppNewData);
    AssertMsg(cbSize > sizeof(void *), "Call SetData() directly for small allocations");


    //
    // Search for existing data.
    //
    
    int idxData = FindItem(id);
    if (idxData >= 0) {
        *ppNewData = m_arData[idxData].pData;
        return S_OK;
    }


    //
    // Data not found, so allocate and add.  (don't forget to allocate for 
    // leading item count.)
    //

    void * pvNew = ClientAlloc(cbSize);
    if (pvNew == NULL) {
        return E_OUTOFMEMORY;
    }

    if (AddItem(id, pvNew)) {
        *ppNewData = pvNew;
        return S_OK;
    }

    //
    // Unable to allocate storage for actual data
    //

    ClientFree(pvNew);
    return E_OUTOFMEMORY;
}


/***************************************************************************\
*
* PropSet::RemoveData
*
* RemoveData() searches through and removes a window-specific 
* user-data for a specific data-element.
*
\***************************************************************************/

void 
PropSet::RemoveData(
    IN PRID id,                     // Short ID to find
    IN BOOL fFree)                  // Free memory pointed to by item
{
    int idxData = FindItem(id);
    if (idxData >= 0) {
        AssertMsg(ValidatePrivateID(id) || (!fFree), "Can only free private data");

        if (fFree) {
            void * pvMem = m_arData[idxData].pData;
            ClientFree(pvMem);
        }

        RemoveAt(idxData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\parkcontainer.cpp ===
/***************************************************************************\
*
* File: ParkContainer.cpp
*
* Description:
* DuParkContainer implements the "Parking Container" used to hold Gadgets 
* that are in the process of being constructed.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Core.h"
#include "ParkContainer.h"

#include "TreeGadget.h"
#include "RootGadget.h"

/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkContainer * 
GetParkContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    DuParkContainer * pconPark = CastParkContainer(pcon);
    return pconPark;
}


/***************************************************************************\
*****************************************************************************
*
* class DuParkGadget
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkGadget::~DuParkGadget()
{
    //
    // Since DuParkGadget::xwDestroy() does nothing, the destructor has to 
    // implement key pieces of DuVisual::xwDestroy().
    //

    xwBeginDestroy();
}


//------------------------------------------------------------------------------
HRESULT
DuParkGadget::Build(DuContainer * pconOwner, DuRootGadget ** ppgadNew)
{
    DuParkGadget * pgadRoot = ClientNew(DuParkGadget);
    if (pgadRoot == NULL) {
        return E_OUTOFMEMORY;
    }


    CREATE_INFO ci;
    ZeroMemory(&ci, sizeof(ci));
    pgadRoot->Create(pconOwner, FALSE, &ci);

    *ppgadNew = pgadRoot;
    return S_OK;
}


//------------------------------------------------------------------------------
void        
DuParkGadget::xwDestroy()
{
    // The parking DuVisual can not be destroyed from some outside force.
}


/***************************************************************************\
*****************************************************************************
*
* class DuParkContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkContainer::DuParkContainer()
{

}


//------------------------------------------------------------------------------
DuParkContainer::~DuParkContainer()
{
    //
    // Need to destroy the DuVisual tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //
    // We can't use the normal DestroyDuVisual() call since the xwDestroy() 
    // method for DuParkGadget has been no-op'd out to prevent external callers 
    // from calling DestroyHandle() on it.
    //
    
    if (m_pgadRoot != NULL) {
        DuParkGadget * pgadPark = static_cast<DuParkGadget *> (m_pgadRoot);

        if (pgadPark->HasChildren()) {
            Trace("ERROR: DUser: Parking Gadget still has children upon destruction:\n");

#if DBG
            DuVisual * pgadCur = pgadPark->GetTopChild();
            while (pgadCur != NULL) {
                DuVisual * pgadNext = pgadCur->GetNext();

                //
                // Before blowing away, dump any information.
                //

                GMSG_QUERYDESC msg;
                msg.cbSize      = sizeof(msg);
                msg.hgadMsg     = pgadCur->GetHandle();
                msg.nMsg        = GM_QUERY;
                msg.nCode       = GQUERY_DESCRIPTION;
                msg.szName[0]   = '\0';
                msg.szType[0]   = '\0';

                if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
                    Trace("  HGADGET = 0x%p,  Name: %S,  Type: %S\n", 
                            pgadPark->GetHandle(), msg.szName, msg.szType);
                } else {
                    Trace("  HGADGET = 0x%p", pgadPark->GetHandle());
                }


                //
                // TODO: It is now too late for this Gadget to cleanup.  Need to
                // blow it away.
                //

                pgadCur = pgadNext;
            }
#endif // DBG
        }

        ClientDelete(DuParkGadget, pgadPark);
        m_pgadRoot = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuParkContainer::Create()
{
    return DuParkGadget::Build(this, &m_pgadRoot);
}


/***************************************************************************\
*
* DuParkContainer::xwPreDestroy
*
* xwPreDestroy() is called by the Core SubContext when the Context is 
* starting destruction.  This provides an opportunity for the DuParkContainer
* to cleanup before the Context destruction destroyed dependent components.
*
\***************************************************************************/

void
DuParkContainer::xwPreDestroy()
{
    if (m_pgadRoot != NULL) {
        DuParkGadget * pgadPark = static_cast<DuParkGadget *> (m_pgadRoot);

        //
        // Need to iterate through the children, removing each from the Parking 
        // Gadget using DeleteHandle().  The children may have been directly 
        // reparented into the Parking Gadget if they were not being used.  In 
        // this case, we want to give them a push to get destroyed.
        //
        // When this is finished, may need to flush the queues so that the 
        // children can be properly destroyed.
        //

        DuVisual * pgadCur = pgadPark->GetTopChild();
        while (pgadCur != NULL) {
            DuVisual * pgadNext = pgadCur->GetNext();
            pgadCur->xwDeleteHandle();
            pgadCur = pgadNext;
        }
    }
}


//------------------------------------------------------------------------------
void
DuParkContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void
DuParkContainer::OnGetRect(RECT * prcDesktopPxl)
{
    prcDesktopPxl->left     = 0;
    prcDesktopPxl->top      = 0;
    prcDesktopPxl->right    = 10000;
    prcDesktopPxl->bottom   = 10000;
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnStartCapture()
{
    
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnEndCapture()
{
    
}


//------------------------------------------------------------------------------
BOOL
DuParkContainer::OnTrackMouseLeave()
{
    return TRUE;
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnSetFocus()
{
    
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    pptContainerPxl->x  = -20000;
    pptContainerPxl->y  = -20000;
}


//------------------------------------------------------------------------------
BOOL        
DuParkContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    //
    // TODO: What exactly should happen to a message that gets sent to the 
    // parking container?  The DuVisuals inside are in a semi-suspended state
    // and are not expecting interaction with the outside world.
    //
    // For now, just throw everything away.
    //

    UNREFERENCED_PARAMETER(nMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pr);
    UNREFERENCED_PARAMETER(nMsgFlags);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\proplist.inl ===
/***************************************************************************\
*
* File: PropList.inl
*
* Description:
* PropList.inl implements standard dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__PropList_inl__INCLUDED)
#define CORE__PropList_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class PropSet
*
*****************************************************************************
\***************************************************************************/

#endif // CORE__PropList_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Public_h__INCLUDED)
#define CORE__Public_h__INCLUDED

#include "DynaSet.h"
#include "PropList.h"
#include "Context.h"
#include "Container.h"
#include "TreeGadget.h"
#include "MessageGadget.h"
#include "EventPool.h"
#include "RootGadget.h"
#include "ParkContainer.h"
#include "Init.h"
#include "Callback.h"

#endif // CORE__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\proplist.h ===
/***************************************************************************\
*
* File: PropList.h
*
* Description:
* PropList.h defines lighweight, dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__PropList_h__INCLUDED)
#define CORE__PropList_h__INCLUDED
#pragma once

#include "DynaSet.h"

/***************************************************************************\
*
* PropSet maintains a set of unique properties for a given item.  This
* is a one to (potentially) many relationship.  Each property only appears 
* once in the set.
*
\***************************************************************************/

//------------------------------------------------------------------------------
class PropSet : public DynaSet
{
// Operations
public:
            HRESULT     GetData(PRID id, void ** ppData) const;
            HRESULT     SetData(PRID id, void * pNewData);
            HRESULT     SetData(PRID id, int cbSize, void ** ppNewData);
            void        RemoveData(PRID id, BOOL fFree);
};

#include "PropList.inl"

#endif // CORE__PropList_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\rootgadget.cpp ===
/***************************************************************************\
*
* File: RootGadget.cpp
*
* Description:
* RootGadget.cpp defines the top-most node for a Gadget-Tree that interfaces
* to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#if ENABLE_FRAMERATE
#include <stdio.h>
#endif

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* Public API's
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GdxrDrawGadgetTree (API Implementation)
*
* GdxrDrawGadgetTree() draws the specified DuVisual sub-tree.
*
\***************************************************************************/

BOOL
GdxrDrawGadgetTree(
    IN  DuVisual * pgadDraw,    // Gadget sub-tree to draw
    IN  HDC hdcDraw,                // HDC to draw into
    IN  const RECT * prcDraw,       // Clipping area
    IN  UINT nFlags)                // Optional drawing flags
{
    RECT rcClient, rcDraw;
    AssertReadPtr(pgadDraw);

    DuRootGadget * pgadRoot = pgadDraw->GetRoot();
    if (pgadRoot == NULL) {
        return FALSE;
    }

    // TODO: Need to change this to SGR_ACTUAL
    pgadDraw->GetLogRect(&rcClient, SGR_CONTAINER);
    if (prcDraw == NULL) {
        prcDraw = &rcClient;
    }

    if (IntersectRect(&rcDraw, &rcClient, prcDraw)) {
#if ENABLE_OPTIMIZEDIRTY
        pgadRoot->xrDrawTree(pgadDraw, hdcDraw, &rcClient, nFlags, TRUE);
#else
        pgadRoot->xrDrawTree(pgadDraw, hdcDraw, &rcClient, nFlags);
#endif
    }

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::Create
*
* Create() initializes a new DuRootGadget.  Since both DuRootGadget and 
* ParkGadget will create new DuRootGadget's, it is important that common 
* initialization code appears here.
*
\***************************************************************************/

HRESULT
DuRootGadget::Create(
    IN  DuContainer * pconOwner,    // Container holding DuVisual tree
    IN  BOOL fOwn,                  // Destroy container when Gadget is destroyed
    IN  CREATE_INFO * pci)          // Creation information
{
#if ENABLE_FRAMERATE
    m_dwLastTime    = GetTickCount();
    m_cFrames       = 0;
    m_flFrameRate   = 0.0f;
#endif

    AssertMsg(m_fRelative, "Root MUST be relative or we will never have any relative children");
    m_fMouseFocus = TRUE;           // Root always has mouse information
    m_fRoot = TRUE;                 // Must mark as Root

    m_fOwnContainer = fOwn;

    HRESULT hr = CommonCreate(pci);
    if (FAILED(hr)) {
        return hr;
    }

    m_pconOwner = pconOwner;
    pconOwner->AttachGadget(this);

    RECT rcDesktopPxl;
    pconOwner->OnGetRect(&rcDesktopPxl);
    VerifyHR(xdSetLogRect(0, 0, rcDesktopPxl.right - rcDesktopPxl.left, rcDesktopPxl.bottom - rcDesktopPxl.top, SGR_SIZE | SGR_CONTAINER));

    return hr;
}


//------------------------------------------------------------------------------
DuRootGadget::~DuRootGadget()
{
    AssertMsg(m_arpgadAdaptors.IsEmpty(), "All Adaptors should have been removed by now");

    if (m_fOwnContainer && (m_pconOwner != NULL)) {
        //
        // Since already in the destructor, must first destach then destroy the
        // container.
        //

        m_pconOwner->DetachGadget();
        m_pconOwner->xwUnlock();
        m_pconOwner = NULL;
    }
}


/***************************************************************************\
*
* DuRootGadget::Build
*
* Build() creates a new DuRootGadget to be hosted inside of a generic
* container.
*
\***************************************************************************/

HRESULT
DuRootGadget::Build(
    IN  DuContainer * pconOwner,    // Container holding DuVisual tree
    IN  BOOL fOwn,                  // Destroy container when Gadget is destroyed
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuRootGadget ** ppgadNew)   // New Gadget
{
    if (pconOwner == NULL) {
        return E_INVALIDARG;
    }

    DuRootGadget * pgadNew = ClientNew(DuRootGadget);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pgadNew->Create(pconOwner, fOwn, pci);
    if (FAILED(hr)) {
        delete pgadNew;
        return hr;
    }

    *ppgadNew = pgadNew;
    return hr;
}


/***************************************************************************\
*
* DuRootGadget::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void        
DuRootGadget::xwDestroy()
{
    //
    // Even though a DuRootGadget is a DuVisual, it isn't allocated in its 
    // pool, so it needs to bypass the DuVisual::xwDestroy().
    //

    xwBeginDestroy();

    DuEventGadget::xwDestroy();
}



#if DEBUG_MARKDRAWN

/***************************************************************************\
*
* DuRootGadget::ResetFlagDrawn
*
* ResetFlagDrawn() marks a DuVisual subtree as not drawn.
*
\***************************************************************************/

extern volatile BOOL g_fFlagDrawn;

void
DuRootGadget::ResetFlagDrawn(DuVisual * pgad)
{
    pgad->m_fMarkDrawn = FALSE;

    DuVisual * pgadCur = pgad->GetTopChild();
    while (pgadCur != NULL) {
        ResetFlagDrawn(pgadCur);
        pgadCur = pgadCur->GetNext();
    }
}

#endif


/***************************************************************************\
*
* DuRootGadget::xrDrawTree
*
* xrDrawTree() initializes and begins the drawing of a Gadget sub-tree.  It 
* is important to call this function to begin drawing from instead of 
* directly calling DuVisual::xrDrawStart() so that the HDC and XForm Matric 
* get properly initialized.
*
\***************************************************************************/

void
DuRootGadget::xrDrawTree(
    IN  DuVisual * pgadStart,   // Gadget to start drawing from (NULL for root)
    IN  HDC hdcDraw,                // HDC to draw into
    IN  const RECT * prcInvalid,    // Area to draw / clip into
    IN  UINT nFlags                 // Optional drawing flags
#if ENABLE_OPTIMIZEDIRTY
    IN  ,BOOL fDirty)                // Initial "dirty" state
#else
    )
#endif
{
#if DEBUG_TraceDRAW
    Trace("START xrDrawTree(): %d,%d %dx%d      @ %d\n", 
            prcInvalid->left, prcInvalid->top, 
            prcInvalid->right - prcInvalid->left, prcInvalid->bottom - prcInvalid->top,
            GetTickCount());
#endif // DEBUG_TraceDRAW

    if (IsRectEmpty(prcInvalid)) {
        return;
    }


    //
    // The application is not allowed to modify the tree while we are calling
    // back on each node to draw.
    //

    ReadOnlyLock rol;


    //
    // Prepare the DC and initialize a PaintInfo to be used when painting.
    //

    int nOldMode = 0;
    if (SupportXForm()) {
        nOldMode = SetGraphicsMode(hdcDraw, GM_ADVANCED);
    }

    XFORM xfOld;
    OS()->PushXForm(hdcDraw, &xfOld);

    //
    // When not starting at the root, need to apply all of the matricies from
    // the root to this node.  This means we need to build _inverse_ XForm to
    // transform prcInvalid and build a normal XForm to transform the HDC.
    //

    RECT rcNewInvalid;
    if (pgadStart != NULL) {
        Matrix3 matStart;
        BuildXForm(&matStart);

        if (SupportXForm()) {
            XFORM xfStart;
            matStart.Get(&xfStart);
            SetWorldTransform(hdcDraw, &xfStart);
        } else {
            OS()->TranslateDC(hdcDraw, matStart[2][0], matStart[2][1]);
        }

        Matrix3 mat;
        BuildAntiXForm(&mat);
        mat.ComputeBounds(&rcNewInvalid, prcInvalid, HINTBOUNDS_Invalidate);
        prcInvalid = &rcNewInvalid;
    } else {
        pgadStart = this;
    }


    //
    // Draw the subtree
    //

    DuSurface * psrf = NULL;
    Gdiplus::Graphics * pgpgr = NULL;
    HPALETTE hpalOld = NULL;
    RECT rcNewInvalid2;
    int nExpandInvalid = 0;

    switch (m_ri.nSurface)
    {
    case GSURFACE_GPGRAPHICS:
        if (ResourceManager::IsInitGdiPlus()) {
            pgpgr = new Gdiplus::Graphics(hdcDraw);
            if (pgpgr != NULL) {
                DuGpSurface * psrfNew = NULL;
                if (SUCCEEDED(DuGpSurface::Build(pgpgr, &psrfNew))) {
                    psrf = psrfNew;

                    if (m_ri.pgppal != NULL) {
                        // TODO: Setup GDI+ palettes
                    }


                    //
                    // When building a Gdiplus Graphics, need to propagate the
                    // invalid region to help optimize the drawing.
                    //

                    Gdiplus::RectF gprcInvalid = Convert(prcInvalid);
                    pgpgr->SetClip(gprcInvalid);
                    
                    
                    //
                    // When using GDI+ with anti-aliasing, we need to expand
                    // the invalid region to accomodate for the overflow.
                    //

                    nExpandInvalid = 1;
                } else {
                    delete pgpgr;
                    pgpgr = NULL;
                }
            }
        }
        break;

    case GSURFACE_HDC:
        {
            DuDCSurface * psrfNew;
            if (SUCCEEDED(DuDCSurface::Build(hdcDraw, &psrfNew))) {
                psrf = psrfNew;

                //
                // Setup palettes
                //

                if (m_ri.hpal != NULL) {
                    hpalOld = SelectPalette(hdcDraw, m_ri.hpal, !m_fForeground);
                    RealizePalette(hdcDraw);
                }
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
        Assert(psrf == NULL);
    }


    //
    // Check if the invalid area needs to be "expanded" out.
    //

    if (nExpandInvalid != 0) {
        rcNewInvalid2.left      = prcInvalid->left - nExpandInvalid;
        rcNewInvalid2.top       = prcInvalid->top - nExpandInvalid;
        rcNewInvalid2.right     = prcInvalid->right + nExpandInvalid;
        rcNewInvalid2.bottom    = prcInvalid->bottom + nExpandInvalid;

        prcInvalid = &rcNewInvalid2;
    }


    //
    // Setup the PaintInfo and begin the painting operation
    //

    if (psrf) {
        PaintInfo pi;
        Matrix3 matInvalid, matDC;
        pi.psrf                 = psrf;
        pi.prcCurInvalidPxl     = prcInvalid;
        pi.prcOrgInvalidPxl     = prcInvalid;
        pi.pmatCurInvalid       = &matInvalid;
        pi.pmatCurDC            = &matDC;
        pi.fBuffered            = FALSE;
#if ENABLE_OPTIMIZEDIRTY
        pi.fDirty               = fDirty;
#endif
        pi.sizeBufferOffsetPxl.cx  = 0;
        pi.sizeBufferOffsetPxl.cy  = 0;

#if DEBUG_MARKDRAWN
        if (g_fFlagDrawn) {
            ResetFlagDrawn(this);
        }
#endif

        pgadStart->xrDrawStart(&pi, nFlags);


#if ENABLE_FRAMERATE
        //
        // Display the frame rate
        //
        TCHAR szFrameRate[40];

        m_cFrames++;
        DWORD dwCurTime = GetTickCount();
        DWORD dwDelta   = dwCurTime - m_dwLastTime;
        if (dwDelta >= 1000) {
            m_flFrameRate   = ((float) m_cFrames) * 1000.0f / (float) dwDelta;
            sprintf(szFrameRate, _T("Frame Rate: %5.1f at time 0x%x\n"), m_flFrameRate, dwCurTime);
            m_cFrames = 0;
            m_dwLastTime = dwCurTime;

            OutputDebugString(szFrameRate);
        }
#endif

        //
        // Cleanup from successful drawing
        //

        switch (m_ri.nSurface)
        {
        case GSURFACE_GPGRAPHICS:
            if (pgpgr) {
                delete pgpgr;
            }
            break;

        case GSURFACE_HDC:
            if (m_ri.hpal != NULL) {
                SelectPalette(hdcDraw, hpalOld, FALSE);
            }
            break;

        default:
            AssertMsg(0, "Unknown surface type");
            Assert(psrf == NULL);
        }



        psrf->Destroy();
    }


    //
    // Remaining cleanup
    //

    OS()->PopXForm(hdcDraw, &xfOld);

    if (SupportXForm()) {
        SetGraphicsMode(hdcDraw, nOldMode);
    }

#if DEBUG_TraceDRAW
    Trace("STOP  xrDrawTree(): %d,%d %dx%d      @ %d\n", 
            prcInvalid->left, prcInvalid->top, 
            prcInvalid->right - prcInvalid->left, prcInvalid->bottom - prcInvalid->top,
            GetTickCount());
#endif // DEBUG_TraceDRAW
}


/***************************************************************************\
*
* DuRootGadget::GetInfo
*
* GetInfo() gets optional / dynamic information for the DuRootGadget, 
* including how to render, etc.
*
\***************************************************************************/

void
DuRootGadget::GetInfo(
    IN  ROOT_INFO * pri             // Information
    ) const
{
    if (TestFlag(pri->nMask, GRIM_OPTIONS)) {
        pri->nOptions = m_ri.nOptions & GRIO_VALID;
    }

    if (TestFlag(pri->nMask, GRIM_SURFACE)) {
        pri->nSurface = m_ri.nSurface;
    }

    if (TestFlag(pri->nMask, GRIM_PALETTE)) {
        pri->pvData = m_ri.pvData;
    }
}


/***************************************************************************\
*
* DuRootGadget::SetInfo
*
* SetInfo() sets optional / dynamic information for the DuRootGadget, 
* including how to render, etc.
*
\***************************************************************************/

HRESULT
DuRootGadget::SetInfo(
    IN  const ROOT_INFO * pri)      // Information
{
    //
    // Update options
    //

    if (TestFlag(pri->nMask, GRIM_OPTIONS)) {
        m_ri.nOptions = pri->nOptions & GRIO_VALID;

        GetContainer()->SetManualDraw(TestFlag(m_ri.nOptions, GRIO_MANUALDRAW));
    }


    //
    // Update the default rendering surface type
    //

    if (TestFlag(pri->nMask, GRIM_SURFACE) && (m_ri.nSurface != pri->nSurface)) {
        m_ri.nSurface = pri->nSurface;

        //
        // Reset information that is surface specific.
        //

        m_ri.pvData = NULL;
    }


    //
    // Setup new information that is surface specific after we have determined
    // the surface type being used.
    //

    if (TestFlag(pri->nMask, GRIM_PALETTE)) {
        m_typePalette = DuDCSurface::GetSurfaceType(pri->nSurface);
        m_ri.pvData = pri->pvData;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
DuVisual *
DuRootGadget::GetFocus()
{
    CoreSC * pSC = GetCoreSC();
    return pSC->pgadCurKeyboardFocus;
}


/***************************************************************************\
*
* DuRootGadget::xdFireChangeState
*
* xdFireChangeState() prepares for and fires messages associated with a 
* GM_CHANGESTATE.  Since the message is deferred, it is very important not
* to pass a Gadget that has started destruction since it may not exist when
* the message is actually handled.
*
\***************************************************************************/

void
DuRootGadget::xdFireChangeState(
    IN OUT DuVisual ** ppgadLost,   // Gadget loosing state
    IN OUT DuVisual ** ppgadSet,    // Gadget gaining state
    IN  UINT nCmd)                      // State change
{
    HGADGET hgadLost, hgadSet;
    DuVisual * pgadLost = *ppgadLost;
    DuVisual * pgadSet = *ppgadSet;

    //
    // Determine the handles
    //

    if ((pgadLost != NULL) && (!pgadLost->m_fFinalDestroy)) {
        hgadLost = (HGADGET) pgadLost->GetHandle();
    } else {
        pgadLost = NULL;
        hgadLost = NULL;
    }
    if ((pgadSet != NULL) && (!pgadSet->m_fFinalDestroy)) {
        hgadSet = (HGADGET) pgadSet->GetHandle();
    } else {
        pgadSet = NULL;
        hgadSet = NULL;
    }


    //
    // Fire the messages
    //

    if (pgadLost != NULL) {
        pgadLost->m_cb.xdFireChangeState(pgadLost, nCmd, hgadLost, hgadSet, GSC_LOST);
    }
    if (pgadSet != NULL) {
        pgadSet->m_cb.xdFireChangeState(pgadSet, nCmd, hgadLost, hgadSet, GSC_SET);
    }

    *ppgadLost = pgadLost;
    *ppgadSet = pgadSet;
}


/***************************************************************************\
*
* DuRootGadget::NotifyDestroy
*
* NotifyDestroy() is called when a Gadget is destroyed.  This gives the
* DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void
DuRootGadget::NotifyDestroy(
    IN  const DuVisual * pgadDestroy) // Gadget being destroyed
{
    CoreSC * pSC = GetCoreSC();

#if DBG
    if (pSC->pgadDrag != NULL) {
        AssertMsg(!pSC->pgadDrag->IsDescendent(pgadDestroy), 
                "Should have already cleaned up drag");
    }

    if (pSC->pgadMouseFocus != NULL) {
        AssertMsg((pgadDestroy == this) || 
                (!pSC->pgadMouseFocus->IsDescendent(pgadDestroy)), 
                "Should have already cleaned up mouse focus");
    }
#endif // DBG

    if (pgadDestroy == pSC->pressLast.pgadClick) {
        pSC->pressLast.pgadClick = NULL;
    }        

    if (pgadDestroy == pSC->pressNextToLast.pgadClick) {
        pSC->pressNextToLast.pgadClick = NULL;
    }        

    if (pgadDestroy == pSC->pgadRootMouseFocus) {
        pSC->pgadRootMouseFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadMouseFocus) {
        pSC->pgadMouseFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadCurKeyboardFocus) {
        pSC->pgadCurKeyboardFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadLastKeyboardFocus) {
        pSC->pgadLastKeyboardFocus = NULL;
    }
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangeInvisible
*
* xdNotifyChangeInvisible() is called when a Gadget becomes invisible.  This 
* gives the DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void        
DuRootGadget::xdNotifyChangeInvisible(
    IN  const DuVisual * pgadChange)  // Gadget being changed
{
    AssertMsg(!pgadChange->m_fVisible, "Only call on invisible Gadget's");

    //
    // Check if the Gadget that we were dragging on has just disappeared.  We
    // need to cancel the drag operation.
    //

    CoreSC * pSC = GetCoreSC();
    if ((pSC->pgadDrag != NULL) && pgadChange->IsDescendent(pSC->pgadDrag)) {
        xdHandleMouseLostCapture();
    }


    //
    // When someone becomes invisible, there "position" has changed, so we
    // need to update mouse focus.
    //

    xdNotifyChangePosition(pgadChange);
}


/***************************************************************************\
*
* DuRootGadget::CheckCacheChange
*
* CheckCacheChange() checks if the changing Gadget is currently within a
* subtree represented by some cached data.  This is used to determine if we
* need to change the cached data.
*
\***************************************************************************/

BOOL
DuRootGadget::CheckCacheChange(
    IN  const DuVisual * pgadChange,  // Gadget being changed
    IN  const DuVisual * pgadCache    // Cached variable
    ) const
{
    //
    // A Gadget has moved, so we need to update the cached Gadget because
    // it may now be in a different Gadget.  This unfortunately is not cheap 
    // and needs to be called whenever any Gadget changes position.
    //
    // - Change is a descendent of the cached Gadget
    // - Change is a direct child of a some parent of the cached Gadget
    //

    if (pgadCache == NULL) {
        //
        // No one has mouse focus, so we are not even inside the Container.
        // Therefore, no one is going to have mouse focus, even after the 
        // change.
        //

        return FALSE;
    }

    if (pgadCache->IsDescendent(pgadChange)) {
        return TRUE;
    } else {
        //
        // Walk up the tree, checking if pgadChange is a direct child of one
        // of our parents.
        //

        const DuVisual * pgadCurParent    = pgadCache->GetParent();
        const DuVisual * pgadChangeParent = pgadChange->GetParent();

        while (pgadCurParent != NULL) {
            if (pgadChangeParent == pgadCurParent) {
                return TRUE;
            }
            pgadCurParent = pgadCurParent->GetParent();
        }
    }

    return FALSE;
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangePosition
*
* xdNotifyChangePosition() is called when a Gadget's position has changed.  
* This gives the DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void
DuRootGadget::xdNotifyChangePosition(
    IN  const DuVisual * pgadChange)  // Gadget being changed
{
    AssertMsg(pgadChange != NULL, "Must specify valid Gadget being changed");

    //
    // If started the destruction process, stop updating the mouse focus.
    //

    if (m_fFinalDestroy) {
        return;
    }


    //
    // Checked cached data
    // - We won't loose mouse focus if a drag operation is going on.
    // - Only care about updating the DropTarget if in "precise" mode.  In
    //   "fast" mode, we are relying on OLE2 to poll so this is unnecessary.
    //

    CoreSC * pSC = GetCoreSC();
    BOOL fMouseFocus = (pSC->pgadDrag == NULL) && CheckCacheChange(pgadChange, pSC->pgadMouseFocus);
    if (fMouseFocus) {
        POINT ptContainerPxl, ptClientPxl;
        GetContainer()->OnRescanMouse(&ptContainerPxl);
        DuVisual * pgadMouse = FindFromPoint(ptContainerPxl, 
                GS_VISIBLE | GS_ENABLED | gspDeepMouseFocus, &ptClientPxl);

        xdUpdateMouseFocus(&pgadMouse, &ptClientPxl);
    }
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangeRoot
*
* xdNotifyChangeRoot() is called when a Gadget is moved between Root's.
* This gives the old DuRootGadget an opportunity to update any cached states
* accordingly BEFORE the Gadget is actually moved.
*
\***************************************************************************/

void
DuRootGadget::xdNotifyChangeRoot(
    IN  const DuVisual * pgadChange)  // Gadget being reparented
{
    AssertMsg(pgadChange != NULL, "Must specify valid Gadget");
    AssertMsg(pgadChange->GetRoot() == this, "Must call before reparenting");
    AssertMsg(pgadChange != this, "Can not change Roots");

    CoreSC * pSC = GetCoreSC();


    //
    // If the current keyboard focus is a in the subtree being moved, need to
    // "push" keyboard focus up to the parent of the Gadget being moved.
    //

    if (pSC->pgadCurKeyboardFocus != NULL) {
        if (pgadChange->IsDescendent(pSC->pgadCurKeyboardFocus)) {
            xdUpdateKeyboardFocus(pgadChange->GetParent());
        }
    }

    if (pSC->pgadLastKeyboardFocus != NULL) {
        if (pgadChange->IsDescendent(pSC->pgadLastKeyboardFocus)) {
            pSC->pgadLastKeyboardFocus = NULL;
        }
    }


    //
    // Mouse state
    //

    if (pSC->pgadRootMouseFocus == this) {
        if ((pSC->pgadMouseFocus != NULL) && pgadChange->IsDescendent(pSC->pgadMouseFocus)) {
            DuVisual * pgadParent = pgadChange->GetParent();
            xdUpdateMouseFocus(&pgadParent, NULL);
        }

        if ((pSC->pgadDrag != NULL) && pgadChange->IsDescendent(pSC->pgadDrag)) {
            xdHandleMouseLostCapture();
        }
    }
}


/***************************************************************************\
*
* DuRootGadget::xdHandleActivate
*
* xdHandleActivate() is called by the Container to update window activation 
* inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleActivate(
    IN  UINT nCmd)                  // Command to handle
{
    if (nCmd == GSC_SET) {
        CoreSC * pSC = GetCoreSC();
        xdUpdateKeyboardFocus(pSC->pgadLastKeyboardFocus);
    }

    return FALSE;  // Not completely handled
}


/***************************************************************************\
*
* DuRootGadget::RegisterAdaptor
*
* RegisterAdaptor() adds an Adaptor from the list maintained on this Root.
*
\***************************************************************************/

HRESULT
DuRootGadget::RegisterAdaptor(DuVisual * pgadAdd)
{
    AssertMsg(pgadAdd->m_fAdaptor, "Adaptor must be marked as an Adaptor");
    int idxAdd = m_arpgadAdaptors.Find(pgadAdd);
    AssertMsg(idxAdd < 0, "Calling RegisterAdaptor on an already registered Adaptor");
    if (idxAdd < 0) {
        idxAdd = m_arpgadAdaptors.Add(pgadAdd);
    }

    if (idxAdd >= 0) {
        GetCoreSC()->m_cAdaptors++;
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuRootGadget::UnregisterAdaptor
*
* UnregisterAdaptor() removes an Adaptor from the list maintained on this
* Root.
*
\***************************************************************************/

void        
DuRootGadget::UnregisterAdaptor(
    IN  DuVisual * pgadRemove)        // Adaptor to remove
{
    AssertMsg(pgadRemove->m_fAdaptor, "Adaptor must still be marked as an Adaptor");
    if (m_arpgadAdaptors.Remove(pgadRemove)) {
        AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Must have an adaptor to remove");
        GetCoreSC()->m_cAdaptors--;
    } else {
        AssertMsg(0, "Could not find specified adaptor to remove");
    }
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateAdaptors
*
* xdUpdateAdaptors() is called, usually by DuVisual, when something occurs
* that requires the Adaptors to be notified so that they have a chance update
* their cached information.
*
* NOTE: It is somewhat expensive to find the Root to update Adaptors if none
* actually exist.  Therefore, before blindly calling this function, it is 
* best to check on the Context if any Adaptors actually exist.
*
\***************************************************************************/

void        
DuRootGadget::xdUpdateAdaptors(UINT nCode) const
{
    AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Only call when have adaptors");

    if (m_fFinalDestroy) {
        return;
    }

    int cAdaptors = m_arpgadAdaptors.GetSize();
    for (int idx = 0; idx < cAdaptors; idx++) {
        DuVisual * pgad = m_arpgadAdaptors[idx];
        AssertMsg(pgad->m_fAdaptor, "Adaptor must still be marked as an Adaptor");

        
        //
        // Only notify the adaptor of the change if it has not started the
        // destruction process.  We need to actually check this since it will
        // be sent updates during destruction when it is moved into the 
        // Parking Gadget.
        //

        if (!pgad->m_fFinalDestroy) {
            pgad->m_cb.xdFireSyncAdaptor(pgad, nCode);
        }
    }
}


/***************************************************************************\
*
* DuRootGadget::xdSynchronizeAdaptors
*
* xdSynchronizeAdaptors() is called when an Adaptor may have been moved 
* between different Roots and we need to synchronize cached data.
*
\***************************************************************************/

HRESULT
DuRootGadget::xdSynchronizeAdaptors()
{
    AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Only call when have adaptors");

    HRESULT hr = S_OK;

    //
    // Walk through the set of Adaptors and see if their Root's have changed.
    // If they have, remove them from us and add them to their new Root.
    //
    // NOTE: We need to walk the array BACKWARDS since we are removing 
    // adaptors that have moved from one tree to the other.
    //

    int cAdaptors = m_arpgadAdaptors.GetSize();
    for (int idx = cAdaptors - 1; idx >= 0; idx--) {
        DuVisual * pgadAdaptor = m_arpgadAdaptors[idx];
        AssertMsg(pgadAdaptor->m_fAdaptor, "Adaptor must still be marked as an Adaptor");

        DuRootGadget * pgadNewRoot = pgadAdaptor->GetRoot();
        if (pgadNewRoot != this) {
            UnregisterAdaptor(pgadAdaptor);
            if (pgadNewRoot != NULL) {
                HRESULT hrTemp = pgadNewRoot->RegisterAdaptor(pgadAdaptor);
                if (FAILED(hrTemp)) {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuRootGadget::PromoteRoot(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pciData);

    AssertMsg(0, "Creating a Root is not yet supported");
    
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiGetFocus(Root::GetFocusMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->pgvFocus = Cast<Visual>(GetFocus());
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiGetRootInfo(Root::GetRootInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_WRITE_STRUCT(pmsg->pri, ROOT_INFO);
    VALIDATE_FLAGS(pmsg->pri->nMask, GRIM_VALID);

    GetInfo(pmsg->pri);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiSetRootInfo(Root::SetRootInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_READ_STRUCT(pmsg->pri, ROOT_INFO);
    VALIDATE_FLAGS(pmsg->pri->nMask, GRIM_VALID);
    VALIDATE_FLAGS(pmsg->pri->nOptions, GRIO_VALID);
#pragma warning(disable: 4296)
    VALIDATE_RANGE(pmsg->pri->nSurface, GSURFACE_MIN, GSURFACE_MAX);
    VALIDATE_RANGE(pmsg->pri->nDropTarget, GRIDT_MIN, GRIDT_MAX);
#pragma warning(default: 4296)

    retval = SetInfo(pmsg->pri);

    END_API();
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\rootgadget.inl ===
/***************************************************************************\
*
* File: RootGadget.inl
*
* Description:
* RootGadget.inl implements the top-most node for a Gadget-Tree that 
* interfaces to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuRootGadget_inl__INCLUDED)
#define CORE__DuRootGadget_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline DuContainer *  
DuVisual::GetContainer() const
{
    return GetRoot()->m_pconOwner;
}


//------------------------------------------------------------------------------
inline 
DuRootGadget::DuRootGadget()
{
    AssertMsg(m_ri.nSurface == GSURFACE_HDC, "Must default to HDC");
    m_fForeground = TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
DuRootGadget::xdSetKeyboardFocus(DuVisual * pgadNew)
{
    return xdUpdateKeyboardFocus(pgadNew);
}


//------------------------------------------------------------------------------
inline void
DuRootGadget::xdHandleMouseLeaveMessage()
{
    //
    // The mouse is leaving us, so we need to update
    //

    xdUpdateMouseFocus(NULL, NULL);
}


//------------------------------------------------------------------------------
inline BOOL
DuRootGadget::HasAdaptors() const
{
    return !m_arpgadAdaptors.IsEmpty();
}


#endif // CORE__DuRootGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Core.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\thread.h ===
/***************************************************************************\
*
* File: Thread.h
*
* Description:
* This file declares the SubThread used by the DirectUser/Core project to
* maintain Thread-specific data.
*
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Thread_h__INCLUDED)
#define CORE__Thread_h__INCLUDED
#pragma once

#include "MsgQ.h"

/***************************************************************************\
*****************************************************************************
*
* CoreST contains Thread-specific information used by the Core project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Thread object.
*
*****************************************************************************
\***************************************************************************/

class CoreST : public SubThread
{
// Construction
public:
    virtual ~CoreST();
    virtual HRESULT     Create();

// Operations
public:
    inline  HRESULT     DeferMessage(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
    inline  void        xwProcessDeferredNL();
    virtual void        xwLeftContextLockNL();

// Implementation
protected:

// Data
protected:
            DelayedMsgQ m_msgqDefer;    // Deferred notifications
};

inline  CoreST *    GetCoreST();
inline  CoreST *    GetCoreST(Thread * pThread);

#include "Thread.inl"

#endif // CORE__Thread_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\stdafx.h ===
#if !defined(CORE__StdAfx_h__INCLUDED)
#define CORE__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // CORE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\rootgadget.h ===
/***************************************************************************\
*
* File: RootGadget.h
*
* Description:
* RootGadget.h defines the top-most node for a Gadget-Tree that interfaces
* to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(CORE__DuRootGadget_h__INCLUDED)
#define CORE__DuRootGadget_h__INCLUDED
#pragma once

#include "TreeGadget.h"

#define ENABLE_FRAMERATE    0       // Display current frame-rate to debug output

class DuRootGadget : 
#if ENABLE_MSGTABLE_API
        public RootImpl<DuRootGadget, DuVisual>
#else
        public DuVisual
#endif
{
// Construction
public:
    inline  DuRootGadget();
protected:
    virtual ~DuRootGadget();
            HRESULT     Create(DuContainer * pconOwner, BOOL fOwn, CREATE_INFO * pci);
public:
    static  HRESULT     Build(DuContainer * pconOwner, BOOL fOwn, CREATE_INFO * pci, DuRootGadget ** ppgadNew);
protected:
    virtual void        xwDestroy();

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Root);
    static HRESULT CALLBACK
                        PromoteRoot(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

    dapi    HRESULT     ApiGetFocus(Root::GetFocusMsg * pmsg);

    dapi    HRESULT     ApiGetRootInfo(Root::GetRootInfoMsg * pmsg);
    dapi    HRESULT     ApiSetRootInfo(Root::SetRootInfoMsg * pmsg);

#endif

// Operations
public:
#if ENABLE_OPTIMIZEDIRTY
            void        xrDrawTree(DuVisual * pgadStart, HDC hdcDraw, const RECT * prcInvalid, UINT nFlags, BOOL fDirty = FALSE);
#else
            void        xrDrawTree(DuVisual * pgadStart, HDC hdcDraw, const RECT * prcInvalid, UINT nFlags);
#endif
            void        GetInfo(ROOT_INFO * pri) const;
            HRESULT     SetInfo(const ROOT_INFO * pri);

            // Input management
            void        xdHandleMouseLostCapture();
            BOOL        xdHandleMouseMessage(GMSG_MOUSE * pmsg, POINT ptContainerPxl);
    inline  void        xdHandleMouseLeaveMessage();

            BOOL        xdHandleKeyboardMessage(GMSG_KEYBOARD * pmsg, UINT nMsgFlags);
            BOOL        xdHandleKeyboardFocus(UINT nCmd);
    static  DuVisual* GetFocus();
    inline  BOOL        xdSetKeyboardFocus(DuVisual * pgadNew);

            BOOL        xdHandleActivate(UINT nCmd);

            // Cached State management
            void        NotifyDestroy(const DuVisual * pgadDestroy);
            void        xdNotifyChangeInvisible(const DuVisual * pgadChange);
            void        xdNotifyChangePosition(const DuVisual * pgadChange);
            void        xdNotifyChangeRoot(const DuVisual * pgadChange);

            // Adaptors
            HRESULT     RegisterAdaptor(DuVisual * pgadAdd);
            void        UnregisterAdaptor(DuVisual * pgadRemove);
            void        xdUpdateAdaptors(UINT nCode) const;
    inline  BOOL        HasAdaptors() const;
            HRESULT     xdSynchronizeAdaptors();


// Implementation
protected:
            // Input management
            BOOL        CheckCacheChange(const DuVisual * pgadChange, const DuVisual * pgadCache) const;

            BOOL        xdUpdateKeyboardFocus(DuVisual * pgadNew);
            void        xdUpdateMouseFocus(DuVisual ** ppgadNew, POINT * pptClientPxl);
            BOOL        xdProcessGadgetMouseMessage(GMSG_MOUSE * pmsg, DuVisual * pgadMouse, POINT ptClientPxl);

            void        xdFireChangeState(DuVisual ** ppgadLost, DuVisual ** ppgadSet, UINT nCmd);

#if DEBUG_MARKDRAWN
            void        ResetFlagDrawn(DuVisual * pgad);
#endif

// Data
protected:
            DuContainer* m_pconOwner;
            BOOL        m_fOwnContainer:1;  // Destroy container when destroy this gadget
            BOOL        m_fUpdateFocus:1;   // In middle of updating focus
            BOOL        m_fUpdateCapture:1; // In middle of updating the mouse (capture)

#if ENABLE_FRAMERATE
            // Frame rate
            DWORD       m_dwLastTime;
            DWORD       m_cFrames;
            float       m_flFrameRate;
#endif

            // Adaptors
            GArrayF<DuVisual *>
                        m_arpgadAdaptors;   // Collect of adaptors in this tree

            // Root Information
            ROOT_INFO   m_ri;               // Root Information
            DuSurface::EType
                        m_typePalette;      // Surface type for palette
            BOOL        m_fForeground;      // This DuRootGadget is in foreground

    friend DuVisual;
};

#include "RootGadget.inl"

BOOL    GdxrDrawGadgetTree(DuVisual * pgadParent, HDC hdcDraw, const RECT * prcDraw, UINT nFlags);

#endif // CORE__DuRootGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\thread.inl ===
/***************************************************************************\
*
* File: Thread.inl
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Thread_inl__INCLUDED)
#define CORE__Thread_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class CoreST
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline CoreST *   
GetCoreST()
{
    SubThread * psub = GetThread()->GetST(Thread::slCore);
    return static_cast<CoreST *> (psub);
}


//------------------------------------------------------------------------------
inline CoreST *    
GetCoreST(Thread * pThread)
{
    return static_cast<CoreST *> (pThread->GetST(Thread::slCore));
}


//------------------------------------------------------------------------------
inline HRESULT     
CoreST::DeferMessage(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    AssertMsg(m_pParent->GetContext()->IsEnableDefer(), "Deferring must first be enabled");
    
    m_pParent->GetContext()->MarkPending();
    return m_msgqDefer.PostDelayed(pmsg, pgadMsg, nFlags);
}


//------------------------------------------------------------------------------
inline void        
CoreST::xwProcessDeferredNL()
{
    //
    // NOTE: The Context will not necessarily be marked as "EnableDefer" still
    // since this is reset while still _inside_ the ContextLock and the 
    // processing of the messages is done _outside_ the ContextLock.
    //
    
    m_msgqDefer.xwProcessDelayedNL();
}


#endif // CORE__Thread_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\thread.cpp ===
/***************************************************************************\
*
* File: Thread.cpp
*
* Description:
* This file implements the SubThread used by the DirectUser/Core project to
* maintain Thread-specific data.
*
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Thread.h"

#include "Context.h"

IMPLEMENT_SUBTHREAD(Thread::slCore, CoreST);

/***************************************************************************\
*****************************************************************************
*
* class CoreST
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
CoreST::~CoreST()
{
#if ENABLE_MPH
    Context * pctx = m_pParent->GetContext();
    CoreSC * pSC = GetCoreSC(pctx);
    if ((pSC != NULL) && (pSC->GetMsgMode() == IGMM_STANDARD)) {
        UninitMPH();
    }
#endif
}


//------------------------------------------------------------------------------
HRESULT
CoreST::Create()
{
    //
    // Initialize the deferred message queue to use to use the thread's 
    // temporary heap.
    //

    m_msgqDefer.Create(m_pParent->GetTempHeap());

    return S_OK;
}


//------------------------------------------------------------------------------
void        
CoreST::xwLeftContextLockNL()
{
    xwProcessDeferredNL();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\treegadget.cpp ===
/***************************************************************************\
*
* File: TreeGadget.cpp
*
* Description:
* TreeGadget.cpp implements the standard DuVisual-Tree management 
* functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"
#include "ParkContainer.h"

#pragma warning(disable: 4296)      // expression is always false


/***************************************************************************\
*****************************************************************************
*
* Global functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Visual *
GetVisual(DuVisual * pdgv)
{
    return static_cast<Visual *> (MsgObject::CastGadget(pdgv));
}


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

CritLock    DuVisual::s_lockProp;
AtomSet     DuVisual::s_ptsProp;
PRID        DuVisual::s_pridXForm         = PRID_Unused;
PRID        DuVisual::s_pridBackFill      = PRID_Unused;
PRID        DuVisual::s_pridBufferInfo    = PRID_Unused;
PRID        DuVisual::s_pridTicket        = PRID_Unused;

#if DBG
DuVisual* DuVisual::s_DEBUG_pgadOutline = NULL;
#endif // DBG


/***************************************************************************\
*
* DuVisual::DuVisual
*
* DuVisual() cleans up resources associated with the given DuVisual,
* including all children, attached items, and associated handles.
*
* NOTE: Because of C++ destructors being called from most-derived to 
* base-class, the Gadget has already started destruction and may be in a
* semi-stable state.  Therefore, it is VERY IMPORTANT that the destructor
* is never directly called and that the xwDestroy() function is called 
* instead.
*
\***************************************************************************/

DuVisual::~DuVisual()
{
    //
    // NOTE: No callbacks are allowed on this object past this point.  We have
    // already destroyed the GPCB.
    //

    AssertMsg(m_fFinalDestroy, "Must call xwBeginDestroy() to begin the destruction process");
    AssertMsg(!m_fDestroyed, "Only can be destroyed once");
    m_fDestroyed = TRUE;

    //
    // Notify the root that this Gadget is being destroyed so that it can 
    // update cached information
    //

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->NotifyDestroy(this);
    }

#if DBG
    if (s_DEBUG_pgadOutline == this) {
        s_DEBUG_pgadOutline = NULL;
    }
#endif // DBG


    //
    // After notifying all event handlers that this DuVisual is being 
    // destroyed, extract this DuVisual from the graph.
    //

    CleanupMessageHandlers();


    //
    // Unlink out of the tree
    //

    Unlink();


    //
    // Cleanup resources
    //

    VerifyHR(SetEnableXForm(FALSE));
    VerifyHR(SetFill((HBRUSH) NULL));
    VerifyHR(SetBuffered(FALSE));
    ClearTicket();


#if DBG_STORE_NAMES

    if (m_DEBUG_pszName != NULL) {
        free(m_DEBUG_pszName);
    }

    if (m_DEBUG_pszType != NULL) {
        free(m_DEBUG_pszType);
    }
    
#endif // DBG_STORE_NAMES
}


static const GUID GUID_XForm        = { 0x9451c768, 0x401d, 0x4bc1, { 0xa6, 0xbb, 0xaf, 0x7c, 0x52, 0x29, 0xad, 0x24 } }; // {9451C768-401D-4bc1-A6BB-AF7C5229AD24}
static const GUID GUID_Background   = { 0x4bab7597, 0x6aaf, 0x42ee, { 0xb1, 0x87, 0xcf, 0x7, 0x7e, 0xb7, 0xff, 0xb8 } };  // {4BAB7597-6AAF-42ee-B187-CF077EB7FFB8}
static const GUID GUID_BufferInfo   = { 0x2aeffe25, 0x1d8, 0x4992, { 0x8e, 0x29, 0xa6, 0xd7, 0xf9, 0x2e, 0x23, 0xd1 } };  // {2AEFFE25-01D8-4992-8E29-A6D7F92E23D1}
static const GUID GUID_Ticket       = { 0x5a8fa581, 0x2df4, 0x44c9, { 0x8e, 0x1a, 0xaa, 0xa7, 0x00, 0xbb, 0xda, 0xb7 } }; // {5A8FA581-2DF4-44C9-8E1A-AAA700BBDAB7}

/***************************************************************************\
*
* DuVisual::InitClass
*
* InitClass() is called during startup and provides an opportunity to 
* initialize common Gadget data, including properties.
*
\***************************************************************************/

HRESULT
DuVisual::InitClass()
{
    HRESULT hr;

    if (FAILED(hr = s_ptsProp.AddRefAtom(&GUID_XForm, ptPrivate, &s_pridXForm)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_Background, ptPrivate, &s_pridBackFill)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_BufferInfo, ptPrivate, &s_pridBufferInfo)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_Ticket, ptPrivate, &s_pridTicket))) {

        return hr;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::Build
*
* Build() creates and fully initializes a new DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::Build(
    IN  DuVisual * pgadParent,          // Optional parent
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuVisual ** ppgadNew,           // New Gadget
    IN  BOOL fDirect)                   // DuVisual is being created as a Visual
{
    //
    // Check parameters
    //

    Context * pctx;
    if (pgadParent != NULL) {
        if (pgadParent->m_fAdaptor) {
            PromptInvalid("Adaptors can not be parents");
            return E_INVALIDARG;
        }

        pctx = pgadParent->GetContext();
    } else {
        pctx = ::GetContext();
    }


    DuVisual * pgadNew = GetCoreSC(pctx)->ppoolDuVisualCache->New();
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }


    pgadNew->m_fInvalidFull     = TRUE;
#if ENABLE_OPTIMIZEDIRTY
    pgadNew->m_fInvalidDirty    = TRUE;
#endif

    HRESULT hr = pgadNew->CommonCreate(pci, fDirect);
    if (FAILED(hr)) {
        pgadNew->xwDestroy();
        return hr;
    }

    //
    // Perform special optimizations if there is not actual callback.  These
    // let us do better performance when the caller is simply creating a DuVisual
    // to be a container.
    //

    if (pci->pfnProc == NULL) {
        //
        // Set directly b/c don't want callback from xdSetStyle().
        //

        pgadNew->m_fZeroOrigin  = FALSE;
        pgadNew->m_fDeepTrivial = TRUE;
    }

    
    //
    // Setup the parent
    //

    if (pgadParent != NULL) {
        //
        // If our new parent is not relative, we must automatically also not
        // be relative.
        //

        if (!pgadParent->m_fRelative) {
            pgadNew->m_fRelative = FALSE;
        }

        //
        // Add the new node to the parent.
        //
        // NOTE: If the Gadget is marked as an Adaptor, it wasn't added to the 
        // cached list of adaptors when we set the style.  Therefore, we need 
        // to add it now.
        //

        pgadNew->Link(pgadParent);
        pgadNew->MarkInvalidChildren();

        if (pgadNew->m_fAdaptor) {
            DuRootGadget * pgadRoot = pgadNew->GetRoot();
            AssertMsg(pgadRoot != NULL, "Must have a root when initially created");
            hr = pgadRoot->RegisterAdaptor(pgadNew);
            if (FAILED(hr)) {
                pgadNew->xwDestroy();
                return hr;
            }
        }
    }

    *ppgadNew = pgadNew;
    return hr;
}


/***************************************************************************\
*
* DuVisual::CommonCreate
*
* CommonCreate() provides common creation across all DuVisual's.  This 
* function should be called in the Build() function for the derived 
* DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::CommonCreate(
    IN  CREATE_INFO * pci,          // Creation information
    IN  BOOL fDirect)               // DuVisual is being created as a Visual
{
    if (!fDirect) {
#if ENABLE_MSGTABLE_API
        if (!SetupInternal(s_mc.hclNew)) {
            return E_OUTOFMEMORY;
        }
#endif
    }

#if DBG
    m_cb.Create(pci->pfnProc, pci->pvData, GetHandle());
#else // DBG
    m_cb.Create(pci->pfnProc, pci->pvData);
#endif // DBG

    return S_OK;
}



#if DBG

/***************************************************************************\
*
* DuVisual::DEBUG_IsZeroLockCountValid
*
* DuVisuals allow a zero lock count during the destruction of a Gadget.
*
\***************************************************************************/

BOOL
DuVisual::DEBUG_IsZeroLockCountValid() const
{
    return m_fFinalDestroy;
}

#endif // DBG


/***************************************************************************\
*
* DuVisual::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
* NOTE: Gadgets are slightly different than other objects with callbacks in
* that their lifetime does NOT end when the application calls 
* ::DeleteHandle().  Instead, the object and its callback are completely
* valid until the GM_DESTROY message has been successfully sent.  This is 
* because a Gadget should receive any outstanding messages in both the 
* normal and delayed message queues before being destroyed.
*
\***************************************************************************/

BOOL
DuVisual::xwDeleteHandle()
{
    //
    // Don't allow deleting a handle that has already started to be destroyed.
    // If this happens, it is an application error.
    //

    if (m_fFinalDestroy) {
        PromptInvalid("Can not call DeleteHandle() on a Gadget that has already started final destruction");
        return FALSE;
    }


    m_cb.xwFireDestroy(this, GDESTROY_START);

    //
    // When an application explicitely calls ::DeleteHandle(), immediately 
    // hide and disable the Gadget.  The Gadget may be locked if there are
    // queued messages for it, but it will no longer be visible.
    //

    if (m_fVisible) {
        //
        // TODO: Need to invalidate the parent (and not this Gadget) when we
        // hide it.
        //

        Invalidate();
        m_fVisible  = FALSE;
    }
    m_fEnabled  = FALSE;

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdNotifyChangeInvisible(this);
    }

    return DuEventGadget::xwDeleteHandle();
}


/***************************************************************************\
*
* DuVisual::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
DuVisual::IsStartDelete() const
{
    return m_fFinalDestroy;
}


/***************************************************************************\
*
* DuVisual::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void
DuVisual::xwDestroy()
{
    //
    // Don't allow deleting a handle that has already started to be destroyed.
    // If this happens, it may be legitimate if we are locking and unlocking
    // a parent who is also being destroyed.
    //

    if (m_fFinalDestroy) {
        return;
    }


    //
    // Derived classes should ensure that DuVisual::xwBeginDestroy() 
    // is called.
    //

    CoreSC * pCoreSC = GetCoreSC(m_pContext);

    xwBeginDestroy();
    xwEndDestroy();

    pCoreSC->ppoolDuVisualCache->Delete(this);
}


/***************************************************************************\
*
* DuVisual::xwBeginDestroy
*
* xwBeginDestroy() starts the destruction process for a given Gadget to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* xwBeginDestroy() is given an opportunity to clean up resources BEFORE the 
* destructors start tearing down the classes.  This is important especially
* for callbacks because the Gadgets will be partially uninitialized in the
* destructors and could have bad side-effects from other API calls during 
* the callbacks.
*
\***************************************************************************/

void        
DuVisual::xwBeginDestroy()
{
    //
    // Make invisible while destroying
    //

    m_fFinalDestroy = TRUE;
    m_fVisible      = FALSE;
    m_fEnabled      = FALSE;

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdNotifyChangeInvisible(this);
    }


    //
    // Send destroy notifications.  This needs to be done in a bottom-up 
    // order to ensure that the root DuVisual does not keep any handles 
    // to a DuVisual being destroyed.
    //
    // We also need to remove ourself from the list of Adaptors that the
    // Root is maintaining since we are going away.
    //

    xwDestroyAllChildren();
    if (m_fAdaptor) {
        AssertMsg(pgadRoot == GetRoot(), 
                "Should not be able to reparent once start destruction");

        if (pgadRoot != NULL) {
            pgadRoot->UnregisterAdaptor(this);
        }
        m_fAdaptor = FALSE;
    }

    m_cb.xwFireDestroy(this, GDESTROY_FINAL);


    //
    // At this point, the children have been cleaned up and the Gadget has
    // received its last callback.  From this point on, anything can be done,
    // but it is important to not callback.
    //

    m_cb.Destroy();
}


/***************************************************************************\
*
* DuVisual::GetGadget
*
* GetGadget() returns the specified Gadget in the specified relationship.
*
\***************************************************************************/

DuVisual *
DuVisual::GetGadget(
    IN  UINT nCmd                   // Relationship
    ) const
{
    switch (nCmd)
    {
    case GG_PARENT:
        return GetParent();
    case GG_NEXT:
        return GetNext();
    case GG_PREV:
        return GetPrev();
    case GG_TOPCHILD:
        return GetTopChild();
    case GG_BOTTOMCHILD:
        return GetBottomChild();
    case GG_ROOT:
        return GetRoot();
    default:
        return NULL;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetStyle
*
* xdSetStyle() changes the style of the given Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetStyle(
    IN  UINT nNewStyle,             // New style of Gadget
    IN  UINT nMask,                 // Mask of what to change
    IN  BOOL fNotify)               // Notify the Gadget of changes
{
    //
    // Determine actual new style
    //

    AssertMsg((nNewStyle & GS_VALID) == nNewStyle, "Must set valid style");
    nNewStyle = (nNewStyle & nMask);
    UINT nOldStyle  = m_nStyle & GS_VALID;

    if (nNewStyle == nOldStyle) {
        return S_OK;
    }


    //
    // If have started destruction, only allowed to set / clear certain bits.
    //

    if (m_fFinalDestroy && ((nNewStyle & GS_VISIBLE) != 0)) {
        PromptInvalid("Not allowed to change this style after starting destruction");
        return E_INVALIDARG;
    }


    //
    // FIRST: Validate that the new style is valid.  If it is not, want to fail
    // out here.  Once we start changing, it could get pretty bad if we need to
    // bail in the middle.  We can't catch everything, but we this cuts down
    // on a lot of the problem.
    //

    //
    // Check if need to change from relative to absolute coordinates / etc.
    //
    bool fRelative = TestFlag(nNewStyle, GS_RELATIVE);

    if (TestFlag(nMask, GS_RELATIVE) && ((!m_fRelative) == fRelative)) {
        //
        // Want to change if using relative coordinates.  We can only do this
        // if we don't have any children.  We also can not become non-relative
        // if our parent is relative.
        //

        if (GetTopChild() != NULL) {
            return E_INVALIDARG;
        }

        if ((GetParent() != NULL) && (GetParent()->m_fRelative) && (!fRelative)) {
            return E_INVALIDARG;
        }
    }

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        if (IsRoot()) {
            return E_INVALIDARG;
        }
    }


    if (TestFlag(nMask, GS_ADAPTOR)) {
        if (GetParent() != NULL) {
            DuRootGadget * pgadRoot = GetRoot();
            if ((pgadRoot == NULL) || HasChildren()) {
                //
                // Already created, but not part of the tree, so in destruction.
                // We can't become an adaptor now.
                //

                return E_INVALIDARG;
            }
        }
    }


    //
    // SECOND: Everything appears valid, so start making changes.  If something
    // goes wrong, flag a failure.
    //

    HRESULT hr = S_OK;

    if (TestFlag(nMask, GS_RELATIVE) && ((!m_fRelative) == fRelative)) {
        m_fRelative = fRelative;
    }

    if (TestFlag(nMask, GS_KEYBOARDFOCUS)) {
        m_fKeyboardFocus = TestFlag(nNewStyle, GS_KEYBOARDFOCUS);
    }

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        AssertMsg(!IsRoot(), "Must not be a DuRootGadget"); 
        m_fMouseFocus = TestFlag(nNewStyle, GS_MOUSEFOCUS);
    }

    if (TestFlag(nMask, GS_VISIBLE)) {
        bool fVisible = TestFlag(nNewStyle, GS_VISIBLE);

        if (GetParent() != NULL) {
            if ((!fVisible) != (!IsVisible())) {
                /*
                 * Invalidate() both before and after the call since if the visibility
                 * is changing, only one of these calls will actually invalidate.
                 */

                if (m_fVisible) {
                    Invalidate();
                }

                m_fVisible = TestFlag(nNewStyle, GS_VISIBLE);

                if (m_fVisible) {
                    Invalidate();
                } else {
                    DuRootGadget * pgadRoot = GetRoot();
                    if (pgadRoot != NULL) {
                        pgadRoot->xdNotifyChangeInvisible(this);
                    }
                }
            }
        } else {
            m_fVisible = TestFlag(nNewStyle, GS_VISIBLE);
        }
    }

    if (TestFlag(nMask, GS_ENABLED)) {
        m_fEnabled = TestFlag(nNewStyle, GS_ENABLED);
    }

    if (TestFlag(nMask, GS_CLIPINSIDE)) {
        m_fClipInside = TestFlag(nNewStyle, GS_CLIPINSIDE);
    }

    if (TestFlag(nMask, GS_CLIPSIBLINGS)) {
        m_fClipSiblings = TestFlag(nNewStyle, GS_CLIPSIBLINGS);
    }

    if (TestFlag(nMask, GS_ZEROORIGIN)) {
        m_fZeroOrigin = TestFlag(nNewStyle, GS_ZEROORIGIN);
    }

    if (TestFlag(nMask, GS_HREDRAW)) {
        m_fHRedraw = TestFlag(nNewStyle, GS_HREDRAW);
    }

    if (TestFlag(nMask, GS_VREDRAW)) {
        m_fVRedraw = TestFlag(nNewStyle, GS_VREDRAW);
    }

    if (TestFlag(nMask, GS_CUSTOMHITTEST)) {
        m_fCustomHitTest = TestFlag(nNewStyle, GS_CUSTOMHITTEST);
    }

    if (TestFlag(nMask, GS_ADAPTOR)) {
        if (GetParent() != NULL) {
            //
            // Actually linked into the tree, so need to update the cached list
            // of adaptors for this tree.
            //

            DuRootGadget * pgadRoot = GetRoot();
            AssertMsg(pgadRoot != NULL, "Should have validated earlier that has Root");

            BOOL fOldAdaptor = m_fAdaptor;
            BOOL fNewAdaptor = TestFlag(nNewStyle, GS_ADAPTOR);
            if ((!m_fAdaptor) != (!fNewAdaptor)) {
                if (fNewAdaptor) {
                    m_fAdaptor = fNewAdaptor;
                    HRESULT hrTemp = pgadRoot->RegisterAdaptor(this);
                    if (FAILED(hrTemp)) {
                        hr = hrTemp;
                        m_fAdaptor = fOldAdaptor;
                    }
                } else {
                    pgadRoot->UnregisterAdaptor(this);
                    m_fAdaptor = fNewAdaptor;
                }
            }
        } else {
            //
            // Not yet part of the tree, so we can only mark this Gadget as an
            // adaptor for now.  When we call xdSetParent(), we will need to
            // add it into the cached list of adaptors then.
            //
            
            m_fAdaptor = TestFlag(nNewStyle, GS_ADAPTOR);
        }
    }


    //
    // Currently, both buffering and caching need the Gadget to be opaque.  
    // Since changing styles may fail, it may be necessary to call SetStyle
    // multiple times to successfully change the style.
    //
    
    if (TestFlag(nMask, GS_OPAQUE)) {
        BOOL fNewOpaque = TestFlag(nNewStyle, GS_OPAQUE);
        if ((!fNewOpaque) && (m_fBuffered || m_fCached)) {
            hr = E_NOTIMPL;
            goto Exit;
        }

        m_fOpaque = fNewOpaque;
    }

    if (TestFlag(nMask, GS_BUFFERED)) {
        BOOL fNewBuffered = TestFlag(nNewStyle, GS_BUFFERED);
        if (fNewBuffered && (!m_fOpaque)) {
            hr = E_NOTIMPL;
            goto Exit;
        }
        HRESULT hrTemp = SetBuffered(fNewBuffered);
        if (FAILED(hrTemp)) {
            hr = hrTemp;
        }
    }

    if (TestFlag(nMask, GS_CACHED)) {
        BOOL fNewCached = TestFlag(nNewStyle, GS_CACHED);
        if (fNewCached && (!m_fOpaque)) {
            hr = E_NOTIMPL;
            goto Exit;
        }

        m_fCached = fNewCached;
    }

    if (TestFlag(nMask, GS_DEEPPAINTSTATE)) {
        m_fDeepPaintState = TestFlag(nNewStyle, GS_DEEPPAINTSTATE);
    }


    //
    // Update the deep state if any relavant flags were affected
    //

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        UpdateWantMouseFocus(uhNone);
    }
    
    if (TestFlag(nMask, GS_CLIPSIBLINGS | GS_ZEROORIGIN | GS_BUFFERED | GS_CACHED)) {
        UpdateTrivial(uhNone);
    }
    

    //
    // Notify the Gadget that its style was changed.
    //

    if (fNotify) {
        UINT nTempStyle = m_nStyle & GS_VALID;
        if (nTempStyle != nOldStyle) {
            m_cb.xdFireChangeStyle(this, nOldStyle, nTempStyle);
        }

        xdUpdateAdaptors(GSYNC_STYLE);
    }

Exit:
    return hr;
}


/***************************************************************************\
*
* DuVisual::SetFill
*
* SetFill() sets the optional background fill of the Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::SetFill(
    IN  HBRUSH hbrFill,             // Brush to use
    IN  BYTE bAlpha,                // Alpha degree
    IN  int w,                      // Tiling width
    IN  int h)                      // Tiling height
{
    if (hbrFill == NULL) {
        //
        // Remove any existing fill
        //

        if (m_fBackFill) {
            m_pds.RemoveData(s_pridBackFill, TRUE);
            m_fBackFill = FALSE;
        }
    } else {
        //
        // Add a new fill
        //

        FillInfo * pfi;
        HRESULT hr = m_pds.SetData(s_pridBackFill, sizeof(FillInfo), (void **) &pfi);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Don't call DeleteObject() on hbrFill because this form does not own it.
        // (It may be a shared resource or a system brush)
        //

        m_fBackFill         = TRUE;

        pfi->type           = DuSurface::stDC;
        pfi->hbrFill        = hbrFill;
        pfi->sizeBrush.cx   = w;
        pfi->sizeBrush.cy   = h;
        pfi->bAlpha         = bAlpha;
    }

    return S_OK;
}

/***************************************************************************\
*
* DuVisual::SetFill
*
* SetFill() sets the optional background fill of the Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::SetFill(
    Gdiplus::Brush * pgpbr)         // Brush to use
{
    if (pgpbr == NULL) {
        //
        // Remove any existing fill
        //

        if (m_fBackFill) {
            m_pds.RemoveData(s_pridBackFill, TRUE);
            m_fBackFill = FALSE;
        }
    } else {
        //
        // Add a new fill
        //

        FillInfo * pfi;
        HRESULT hr = m_pds.SetData(s_pridBackFill, sizeof(FillInfo), (void **) &pfi);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Don't call DeleteObject() on hbrFill because this form does not own it.
        // (It may be a shared resource or a system brush)
        //

        m_fBackFill         = TRUE;

        pfi->type           = DuSurface::stGdiPlus;
        pfi->pgpbr          = pgpbr;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::xwDestroyAllChildren
*
* xwDestroyAllChildren() is called during a Gadget's destruction to 
* recursively xwDestroy() all children. 
*
* NOTE: This is an "xw" function, so we need to be VERY careful how we 
* enumerate our children.  Since new children could potentially be added to 
* us during the callback, we need to continue enumerating as long as we have 
* children.
*
\***************************************************************************/

void
DuVisual::xwDestroyAllChildren()
{
    //
    // DuVisual can have a list of children, so go through and destroy each of
    // those children.  
    //
    // Before each child is unlocked(), it needs to be unlinked from the 
    // tree to prevent it from further accessing its siblings or its parent 
    // which may be destroyed.  This can happen if the Gadget is has 
    // outstanding locks, for example in a MsgQ.
    //
    // NOTE: We can't just unlink the node into oblivion since it MUST still 
    // have a valid Root.  Instead, move it into the Parking Gadget.  This
    // somewhat stinks if we are going to just go away, but we can't risk 
    // leaving the Gadget floating nowhere.
    //

    while (HasChildren()) {
        DuVisual * pgadChild = GetTopChild();

        {
            ObjectLock ol(pgadChild);
            pgadChild->m_cb.xwFireDestroy(pgadChild, GDESTROY_START);
            pgadChild->xdSetParent(NULL, NULL, GORDER_ANY);
            pgadChild->xwUnlock();
        }
    }
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::xwEnumGadgets(GADGETENUMPROC pfnProc, void * pvData, UINT nFlags)
{
    if (TestFlag(nFlags, GENUM_MODIFYTREE)) {
        // Currently not implemented
        return E_NOTIMPL;
    }

    //
    // Enumerate this node
    //

    if (TestFlag(nFlags, GENUM_CURRENT)) {
        if (!(pfnProc)(GetHandle(), pvData)) {
            return DU_S_STOPPEDENUMERATION;
        }
    }

    //
    // Enumerate children
    //

    HRESULT hr;
    if (TestFlag(nFlags, GENUM_SHALLOWCHILD | GENUM_DEEPCHILD)) {
        UINT nCurFlags = nFlags;
        SetFlag(nCurFlags, GENUM_CURRENT);
        ClearFlag(nCurFlags, GENUM_SHALLOWCHILD);

        DuVisual * pgadCur = GetTopChild();
        while (pgadCur != NULL) {
            DuVisual * pgadNext = pgadCur->GetNext();

            hr = pgadCur->xwEnumGadgets(pfnProc, pvData, nCurFlags);
            if (hr != S_OK) {
                return hr;
            }

            pgadCur = pgadNext;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::AddChild
*
* AddChild() creates a new child Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::AddChild(
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuVisual ** ppgadNew)     // New child
{
    if (m_fFinalDestroy) {
        PromptInvalid("Can not add a Gadget to one that has started destruction");
        return DU_E_STARTDESTROY;
    }

    return DuVisual::Build(this, pci, ppgadNew, FALSE);
}


/***************************************************************************\
*
* DuVisual::IsDescendent
*
* IsDescendent() determines if a specified node is a descendent of this node.
*
\***************************************************************************/

BOOL
DuVisual::IsDescendent(
    IN  const DuVisual * pgadChild
    ) const
{
    AssertMsg(pgadChild != NULL, "Must have valid node");

    //
    // Walk up the tree, checking each parent to see if it matches.
    //

    const DuVisual * pgadCur = pgadChild;
    do {
        if (pgadCur == this) {
            return TRUE;
        }
        pgadCur = pgadCur->GetParent();
    } while (pgadCur != NULL);

    return FALSE;
}


/***************************************************************************\
*
* DuVisual::IsSibling
*
* IsSibling() determines if two specified nodes share a common (immediate)
* parent.
*
\***************************************************************************/

BOOL
DuVisual::IsSibling(const DuVisual * pgad) const
{
    AssertMsg(pgad != NULL, "Must have valid node");

    DuVisual * pgadParentA = GetParent();
    DuVisual * pgadParentB = pgad->GetParent();

    if ((pgadParentA == NULL) || (pgadParentA != pgadParentB)) {
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*
* DuVisual::xdSetParent
*
* xdSetParent() changes the Gadget's parent and z-order inside the sub-tree.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetParent(
    IN  DuVisual * pgadNewParent, // New parent
    IN  DuVisual * pgadOther,     // Gadget to moved relative to
    IN  UINT nCmd)                  // Relationship
{
    HRESULT hr = S_OK;
    DuVisual * pgadOldParent;
    DuVisual * pgadPark;

    pgadOldParent = GetParent();

    //
    // Check parameters- see if we even need to move
    //

    AssertMsg(!IsRoot(), "Can not change a DuRootGadget's parent");


    pgadPark = GetCoreSC()->pconPark->GetRoot();
    if ((pgadNewParent == NULL) || (pgadNewParent == pgadPark)) {
        pgadNewParent = pgadPark;

        if (pgadNewParent->m_fFinalDestroy) {
            //
            // The Parking Gadget has already started to be destroyed, so
            // we can't be reparented into it.
            //

            pgadNewParent = NULL;
        }
    }

    if ((nCmd == GORDER_ANY) && (pgadOldParent == pgadNewParent)) {
        return S_OK;
    }

    if (m_fFinalDestroy || 
            ((pgadNewParent != NULL) && pgadNewParent->m_fFinalDestroy)) {
        //
        // We have started to be destroyed, so we can't change our parent to
        // avoid destruction.  We also can be reparented to a Gadget that has
        // started destruction because we may not be properly destroyed.
        //

        PromptInvalid("Can not move a Gadget that has started destruction");
        return DU_E_STARTDESTROY;
    }

    if ((pgadNewParent != NULL) && (pgadNewParent->GetContext() != GetContext())) {
        //
        // Illegally trying to move the Gadget between Contexts.
        //

        PromptInvalid("Can not move a Gadget between Contexts");
        return E_INVALIDARG;
    }


    AssertMsg(GORDER_TOP == (int) TreeNode::ltTop, "Ensure enum's match");

    if ((pgadNewParent != NULL) && (pgadNewParent->m_fAdaptor)) {
        PromptInvalid("Adaptors can not be parents");
        return E_INVALIDARG;
    }


    //
    // When actually moving from one parent to another or changing sibling 
    // z-order, need to hide the Gadget while moving and invalidate the before
    // and after locations.  If the parent has changed, we also need to notify 
    // the DuRootGadget because the tree has changed around.
    //
    // NOTE: It may actually not be that important to notify the Root at all-
    // still need to determine the impact on dragging from changing the parent.
    //

    BOOL fVisible = m_fVisible;

    if (fVisible) {
        //
        // TODO: Need to fix how we mark the Gadget as not visible so that 
        // we properly invalidate the PARENT.
        //

        Invalidate();
        m_fVisible = FALSE;

        if (pgadNewParent != pgadOldParent) {
            GetRoot()->xdNotifyChangeInvisible(this);
        }
    }

    AssertMsg((pgadNewParent == NULL) || 
            ((!m_fRelative) == (!pgadNewParent->m_fRelative)),
            "If not a Root, relative setting for us and our parent must match");

    //
    // If reparenting across DuRootGadget's, need to notify the old 
    // DuRootGadget so that it can update its state.  Need to do this BEFORE
    // we move.
    //

    DuRootGadget * pgadOldRoot = pgadOldParent != NULL ? pgadOldParent->GetRoot() : NULL;
    DuRootGadget * pgadNewRoot = pgadNewParent != NULL ? pgadNewParent->GetRoot() : NULL;

    if (pgadOldRoot != pgadNewRoot) {
        pgadOldRoot->xdNotifyChangeRoot(this);
    }


    //
    // If moving forward or backward, determine the actual sibling and change 
    // the command into a TreeNode::ELinkType
    //

    switch (nCmd)
    {
    case GORDER_FORWARD:
        pgadOther   = GetPrev();
        if (pgadOther == NULL) {
            nCmd    = GORDER_TOP;
        } else {
            nCmd    = GORDER_BEFORE;
        }
        break;

    case GORDER_BACKWARD:
        pgadOther   = GetNext();
        if (pgadOther == NULL) {
            nCmd    = GORDER_BOTTOM;
        } else {
            nCmd    = GORDER_BEHIND;
        }
        break;
    }


    //
    // Move from the old Parent to the new Parent.
    //

    Unlink();
    if (pgadNewParent != NULL) {
        Link(pgadNewParent, pgadOther, (TreeNode::ELinkType) nCmd);
    }

    if (fVisible) {
        m_fVisible = fVisible;
        Invalidate();
    }


    if (pgadNewParent != NULL) {
        if (pgadNewParent != pgadOldParent) {
            //
            // Synchronize (newly inherited) invalidation state.
            //

#if ENABLE_OPTIMIZEDIRTY
            if (m_fInvalidFull || m_fInvalidDirty) {
#else
            if (m_fInvalidFull) {
#endif
                pgadNewParent->MarkInvalidChildren();
            }


            //
            // Update cached Adaptor information.  If we are moving an Adaptor, we
            // may need to notify the Roots.  Even if we are not moving an Adaptor,
            // if there are ANY Adaptors, they may need to recompute visrgn's, etc 
            // so they need to be notified.
            //
            // NOTE: We may end up moving an Adaptor by moving its parent, so we 
            // can't only just check the m_fAdaptor field.  We also need to check 
            // if the old DuRootGadget has any Adaptors and if so synchronize all of
            // them.  We also need to check the m_fAdaptor field because if the 
            // Gadget wasn't linked into a tree, it won't show up in the cached list
            // of adaptors.
            //

            hr = S_OK;
            if ((pgadOldParent == NULL) && m_fAdaptor) {
                //
                // The Gadget didn't have a parent, so it wasn't added to the cached
                // list of adaptors.  We need to add it now.
                //

                AssertMsg(pgadNewParent != NULL, "Must have a valid new parent");
                AssertMsg(GetRoot() == pgadNewParent->GetRoot(), "Roots should match");
                hr = GetRoot()->RegisterAdaptor(this);
            } else if (GetCoreSC()->m_cAdaptors > 0) {
                DuRootGadget * pgadOldRoot = pgadOldParent->GetRoot();
                if (pgadOldRoot->HasAdaptors()) {
                    hr = pgadOldRoot->xdSynchronizeAdaptors();
                }
            }

            if (FAILED(hr)) {
                //
                // This is really bad.  We are not able to add this adaptor to 
                // its new root.  There is not much that we can do because 
                // moving it back is just as likely to fail.  All that we can
                // do is report the failure.
                //
            }
        }

        xdUpdatePosition();
        xdUpdateAdaptors(GSYNC_PARENT);
    }

    return hr;
}


/***************************************************************************\
*
* DuVisual::SetFilter
*
* SetFilter() changes the message filter of the Gadget.
*
\***************************************************************************/

void        
DuVisual::SetFilter(
    IN  UINT nNewFilter,            // New message filter
    IN  UINT nMask)                 // Mask to change
{
    // TEMPORARY HACK TO ALLOW MOUSEMOVE's
    //
    // TODO: Need to traverse tree, rolling up and recomputing m_we.

    if (TestFlag(nMask, GMFI_INPUTMOUSEMOVE)) {
        if (TestFlag(nNewFilter, GMFI_INPUTMOUSEMOVE)) {
            m_we |= weMouseMove | weDeepMouseMove;
        } else {
            m_we &= ~(weMouseMove | weDeepMouseMove);
        }
    }

    DuEventGadget::SetFilter(nNewFilter, nMask);
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::RegisterPropertyNL(const GUID * pguid, PropType pt, PRID * pprid)
{
    s_lockProp.Enter();
    HRESULT hr = s_ptsProp.AddRefAtom(pguid, pt, pprid);
    s_lockProp.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::UnregisterPropertyNL(const GUID * pguid, PropType pt)
{
    s_lockProp.Enter();
    HRESULT hr = s_ptsProp.ReleaseAtom(pguid, pt);
    s_lockProp.Leave();

    return hr;
}


/***************************************************************************\
*
* DuVisual::xdUpdatePosition
*
* xdUpdatePosition() is called when something occurs that changes the 
* position of a Gadget.  When this happens, the Root needs to be notified so 
* that it can update cached information like mouse focus.
*
\***************************************************************************/

void        
DuVisual::xdUpdatePosition() const
{
    //
    // Only need to update the position if we are completely visible.
    //

    const DuVisual * pgadCur = this;
    const DuVisual * pgadParent;
    while (1) {
        if (!pgadCur->m_fVisible) {
            return;
        }

        pgadParent = pgadCur->GetParent();
        if (pgadParent == NULL) {
            AssertMsg(pgadCur->m_fRoot, "Top must be a DuRootGadget");
            DuRootGadget * pgadRoot = (DuRootGadget *) pgadCur;
            pgadRoot->xdNotifyChangePosition(this);
            return;
        }

        pgadCur = pgadParent;
    }
}


//------------------------------------------------------------------------------
void
DuVisual::xdUpdateAdaptors(UINT nCode) const
{
    if (GetCoreSC()->m_cAdaptors == 0) {
        return;  // No adaptors to notify
    }

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdUpdateAdaptors(nCode);
    }
}


/***************************************************************************\
*
* DuVisual::GetTicket
*
* The GetTicket function returns the ticket that can be used to 
* identify this gadget.
*
* <param name="pdwTicket">
*     [out] The storage for a copy of the ticket assigned to this gadget.
* </param>
*
* <return type="DWORD">
*     If the function succeeds, the return value is a 32-bit ticket that
*     can be used to identify the specified gadget.
*     If the function fails, the return value is zero.
* </return>
*
* <remarks>
*     Tickets are created to give an external identity to a gadget.  A
*     is guaranteed to be 32 bits on all platforms.  If no ticket is
*     currently associated with this gadget, one is allocated.
* </remarks>
*
* <see type="function">DuVisual::ClearTicket</>
* <see type="function">DuVisual::LookupTicket</>
*
\***************************************************************************/

HRESULT
DuVisual::GetTicket(OUT DWORD * pdwTicket)
{
    HRESULT hr = S_OK;

    if (NULL == pdwTicket) {
        return E_POINTER;
    } else {
        *pdwTicket = 0;
    }

    //
    // If we have already assigned this gadget a ticket, we should have it stored
    // in the gadget's dynamic data.
    //
    if (m_fTicket) {
        void * pTicket = NULL;

        hr = m_pds.GetData(s_pridTicket, (void**) &pTicket);
        AssertMsg(SUCCEEDED(hr), "Our state is out of sync!");

        if (SUCCEEDED(hr)) {
            *pdwTicket = PtrToUlong(pTicket);  // Yes, I am just casting the pointer!
        } else {
            //
            // Try to repair our state!
            //
            m_fTicket = FALSE;
            hr = S_OK;
        }
    }
    
    //
    // If we haven't assigned this gadget a ticket yet, get one from the global
    // ticket manager and store it in the gadget's dynamic data.
    //
    if (!m_fTicket) {
        hr = GetTicketManager()->Add(this, pdwTicket);
        if (SUCCEEDED(hr)) {
            hr = m_pds.SetData(s_pridTicket, ULongToPtr(*pdwTicket)); // Yes, I am just casting to a pointer!

            if (SUCCEEDED(hr)) {
                m_fTicket = TRUE;
            } else {
                GetTicketManager()->Remove(*pdwTicket, NULL);
                *pdwTicket = 0;
            }
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuVisual::ClearTicket
*
* The ClearTicket function remmoves the association between this\
* gadget and the current ticket.
*
* <return type="void">
* </return>
*
* <see type="function">DuVisual::GetTicket</>
* <see type="function">DuVisual::LookupTicket</>
*
\***************************************************************************/

void
DuVisual::ClearTicket()
{
    if (m_fTicket) {
        HRESULT hr;
        void * pTicket= NULL;
        DWORD dwTicket;

        hr = m_pds.GetData(s_pridTicket, (void**) &pTicket);
        if (SUCCEEDED(hr)) {
            dwTicket = PtrToUlong(pTicket);  // Yes, I am just casting the pointer!
            VerifyHR(GetTicketManager()->Remove(dwTicket, NULL));
        }

        m_pds.RemoveData(s_pridTicket, FALSE);
        m_fTicket = FALSE;
    }
}


/***************************************************************************\
*
* DuVisual::LookupTicket
*
* The LookupTicket function returns the gadget that is associated with
* the specified ticket.
*
* <param name="dwTicket">
*     [in] A ticket that has been associated with a gadget via the
*     DuVisual::GetTicket function.
* </param>
*
* <return type="HGADGET">
*     If the function succeeds, the return value is a handle to the gadget
*     associated with the ticket.
*     If the function fails, the return value is NULL.
* </return>
*
* <see type="function">DuVisual::GetTicket</>
* <see type="function">DuVisual::ClearTicket</>
*
\***************************************************************************/

HGADGET
DuVisual::LookupTicket(DWORD dwTicket)
{
    BaseObject * pObject = NULL;
    HGADGET hgad = NULL;
    HRESULT hr;

    hr = GetTicketManager()->Lookup(dwTicket, &pObject);
    if (SUCCEEDED(hr) && pObject != NULL) {
        hgad = (HGADGET) pObject->GetHandle();
    }

    return hgad;
}

#if DBG

//------------------------------------------------------------------------------
void        
DuVisual::DEBUG_SetOutline(DuVisual * pgadOutline)
{
    if (s_DEBUG_pgadOutline != NULL) {
        s_DEBUG_pgadOutline->Invalidate();
    }

    s_DEBUG_pgadOutline = pgadOutline;

    if (s_DEBUG_pgadOutline != NULL) {
        s_DEBUG_pgadOutline->Invalidate();
    }
}


//------------------------------------------------------------------------------
void
AppendName(WCHAR * & pszDest, const WCHAR * pszSrc, int & cchRemain, BOOL & fFirst)
{
    if (cchRemain <= 0) {
        return;
    }

    if (!fFirst) {
        if (cchRemain <= 2) {
            CopyString(pszDest, L"", cchRemain);
            cchRemain = 0;
            return;
        }

        CopyString(pszDest, L", ", cchRemain);
        cchRemain -= 2;
        pszDest += 2;
    }

    int cchCopy = (int) wcslen(pszSrc);
    CopyString(pszDest, pszSrc, cchRemain);

    cchRemain   -= cchCopy;
    pszDest     += cchCopy;

    fFirst = FALSE;
}


//------------------------------------------------------------------------------
void        
DuVisual::DEBUG_GetStyleDesc(LPWSTR pszDesc, int cchMax) const
{
    pszDesc[0] = '\0';

    int cchRemain = cchMax;
    WCHAR * pszDest = pszDesc;
    BOOL fFirst = TRUE;

    if (m_fAllowSubclass)
        AppendName(pszDest, L"AllowSubclass", cchRemain, fFirst);
    if (m_fAdaptor)
        AppendName(pszDest, L"Adaptor", cchRemain, fFirst);
    if (m_fBackFill)
        AppendName(pszDest, L"BackFill*", cchRemain, fFirst);
    if (m_fBuffered)
        AppendName(pszDest, L"Buffered", cchRemain, fFirst);
    if (m_fCached)
        AppendName(pszDest, L"Cache", cchRemain, fFirst);
    if (m_fClipInside)
        AppendName(pszDest, L"ClipInside", cchRemain, fFirst);
    if (m_fClipSiblings)
        AppendName(pszDest, L"ClipSiblings", cchRemain, fFirst);
    if (m_fDeepPaintState)
        AppendName(pszDest, L"DeepPaintState", cchRemain, fFirst);
    if (m_fDeepMouseFocus)
        AppendName(pszDest, L"DeepMouseFocus*", cchRemain, fFirst);
    if (m_fDeepTrivial)
        AppendName(pszDest, L"DeepTrivial*", cchRemain, fFirst);
    if (m_fDestroyed)
        AppendName(pszDest, L"Destroyed*", cchRemain, fFirst);
    if (m_fEnabled)
        AppendName(pszDest, L"Enabled", cchRemain, fFirst);
    if (m_fCustomHitTest)
        AppendName(pszDest, L"HitTest", cchRemain, fFirst);
    if (m_fHRedraw)
        AppendName(pszDest, L"H-Redraw", cchRemain, fFirst);
    if (m_fKeyboardFocus)
        AppendName(pszDest, L"KeyboardFocus", cchRemain, fFirst);
    if (m_fMouseFocus)
        AppendName(pszDest, L"MouseFocus", cchRemain, fFirst);
    if (m_fZeroOrigin)
        AppendName(pszDest, L"ZeroOrigin", cchRemain, fFirst);
    if (m_fOpaque)
        AppendName(pszDest, L"Opaque", cchRemain, fFirst);
    if (m_fRelative)
        AppendName(pszDest, L"Relative", cchRemain, fFirst);
    if (m_fVisible)
        AppendName(pszDest, L"Visible", cchRemain, fFirst);
    if (m_fVRedraw)
        AppendName(pszDest, L"V-Redraw", cchRemain, fFirst);
    if (m_fXForm)
        AppendName(pszDest, L"XForm*", cchRemain, fFirst);
}

#endif // DBG


//------------------------------------------------------------------------------
HRESULT CALLBACK DummyEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    UNREFERENCED_PARAMETER(pvCur);
    UNREFERENCED_PARAMETER(pMsg);

    return DU_S_NOTHANDLED;
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuVisual::PromoteVisual(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);

    Visual::VisualCI * pciVisual = static_cast<Visual::VisualCI *> (pciData);
    MsgObject ** ppmsoNew = reinterpret_cast<MsgObject **> (pgad);
    AssertMsg((ppmsoNew != NULL) && (*ppmsoNew == NULL), 
            "Internal objects must be given valid storage for the MsgObject");

    CREATE_INFO ci;
    ci.pfnProc  = DummyEventProc;   // Can't use NULL b'c SimpleGadgetProc turns too much off
    ci.pvData   = NULL;

    DuVisual * pgt;
    DuVisual * pgtParent = pciVisual->pgvParent != NULL ? 
            CastVisual(pciVisual->pgvParent) : GetCoreSC()->pconPark->GetRoot();
    HRESULT hr = Build(pgtParent, &ci, &pgt, TRUE);
    if (FAILED(hr)) {
        return hr;
    }

    *ppmsoNew = pgt;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetOrder(Visual::SetOrderMsg * pmsg)
{
    DuVisual * pdgvOther;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvOther, pdgvOther);
    CHECK_MODIFY();

    retval = xdSetOrder(pdgvOther, pmsg->nCmd);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetParent(Visual::SetParentMsg * pmsg)
{
    DuVisual * pdgvParent;
    DuVisual * pdgvOther;
    HRESULT hr;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvParent, pdgvParent);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvOther, pdgvOther);
    CHECK_MODIFY();

    if (IsRoot()) {
        PromptInvalid("Can not change a RootGadget's parent");
        retval = E_INVALIDARG;
        goto ErrorExit;
    }

    //
    // Check that can become a child of the specified parent
    //

    if ((!IsRelative()) && pdgvParent->IsRelative()) {
        PromptInvalid("Can not set non-relative child to a relative parent");
        retval = DU_E_BADCOORDINATEMAP;
        goto ErrorExit;
    }

    //
    // DuVisual::xdSetParent() handles if pgadParent is NULL and will move to the
    // parking window.
    //

    hr = xdSetParent(pdgvParent, pdgvOther, pmsg->nCmd);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetGadget(Visual::GetGadgetMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GG_MIN, GG_MAX);

    pmsg->pgv = GetVisual(GetGadget(pmsg->nCmd));
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetStyle(Visual::GetStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->nStyle = GetStyle();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetStyle(Visual::SetStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nNewStyle, GS_VALID);
    VALIDATE_FLAGS(pmsg->nMask, GS_VALID);
    CHECK_MODIFY();

    retval = xdSetStyle(pmsg->nNewStyle, pmsg->nMask);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetKeyboardFocus(Visual::SetKeyboardFocusMsg * pmsg)
{
    DuRootGadget * pdgvRoot;

    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    //
    // TODO: Do we need to only allow the app to change focus if on the same
    // thread?  USER does this.
    //

    pdgvRoot = GetRoot();
    if (pdgvRoot != NULL) {
        retval = pdgvRoot->xdSetKeyboardFocus(this) ? S_OK : DU_E_GENERIC;
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiIsParentChainStyle(Visual::IsParentChainStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_VALUE(pmsg->nFlags, 0);
    VALIDATE_FLAGS(pmsg->nStyle, GS_VALID);
    CHECK_MODIFY();

    pmsg->fResult = IsParentChainStyle(pmsg->nStyle);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetProperty(Visual::GetPropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    CHECK_MODIFY();

    retval = GetProperty(pmsg->id, &pmsg->pvValue);
       
    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetProperty(Visual::SetPropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetProperty(pmsg->id, pmsg->pvValue);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiRemoveProperty(Visual::RemovePropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    RemoveProperty(pmsg->id, FALSE /* Can't free memory for Global property*/);
    retval = S_OK;
    
    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiInvalidate(Visual::InvalidateMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    Invalidate();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiInvalidateRects(Visual::InvalidateRectsMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();
    VALIDATE_RANGE(pmsg->cRects, 1, 1024);
    VALIDATE_READ_PTR_(pmsg->rgrcClientPxl, sizeof(RECT) * pmsg->cRects);

    InvalidateRects(pmsg->rgrcClientPxl, pmsg->cRects);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetFillF(Visual::SetFillFMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetFill(pmsg->pgpgrFill);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetFillI(Visual::SetFillIMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetFill(pmsg->hbrFill, pmsg->bAlpha, pmsg->w, pmsg->h);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetScale(Visual::GetScaleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetScale(&pmsg->flX, &pmsg->flY);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetScale(Visual::SetScaleMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetScale(pmsg->flX, pmsg->flY);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetRotation(Visual::GetRotationMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->flRotationRad = GetRotation();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetRotation(Visual::SetRotationMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetRotation(pmsg->flRotationRad);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetCenterPoint(Visual::GetCenterPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetCenterPoint(&pmsg->flX, &pmsg->flY);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetCenterPoint(Visual::SetCenterPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetCenterPoint(pmsg->flX, pmsg->flY);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetBufferInfo(Visual::GetBufferInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_WRITE_STRUCT(pmsg->pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pmsg->pbi->nMask, GBIM_VALID);

    if (!IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        retval = DU_E_NOTBUFFERED;
        goto ErrorExit;
    }

    retval = GetBufferInfo(pmsg->pbi);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetBufferInfo(Visual::SetBufferInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_READ_STRUCT(pmsg->pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pmsg->pbi->nMask, GBIM_VALID);
    CHECK_MODIFY();

    if (!IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        retval = DU_E_NOTBUFFERED;
        goto ErrorExit;
    }

    retval = SetBufferInfo(pmsg->pbi);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetSize(Visual::GetSizeMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetSize(&pmsg->sizeLogicalPxl);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetRect(Visual::GetRectMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_FLAGS(pmsg->nFlags, SGR_VALID_GET);
 
    if (TestFlag(pmsg->nFlags, SGR_ACTUAL)) {
        AssertMsg(0, "TODO: Not Implemented");
    } else {
        GetLogRect(&pmsg->rcPxl, pmsg->nFlags);
        retval = S_OK;
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetRect(Visual::SetRectMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nFlags, SGR_VALID_SET);
    VALIDATE_READ_PTR_(pmsg->prcPxl, sizeof(RECT));
    CHECK_MODIFY();

    if (IsRoot()) {
        if (TestFlag(pmsg->nFlags, SGR_MOVE)) {
            PromptInvalid("Can not move a RootGadget");
            retval = E_INVALIDARG;
            goto ErrorExit;
        }
    }


    //
    // Ensure that size is non-negative
    //

    int x, y, w, h;
    x = pmsg->prcPxl->left;
    y = pmsg->prcPxl->top;
    w = pmsg->prcPxl->right - pmsg->prcPxl->left;
    h = pmsg->prcPxl->bottom - pmsg->prcPxl->top;

    if (TestFlag(pmsg->nFlags, SGR_SIZE)) {
        if (w < 0) {
            w = 0;
        }
        if (h < 0) {
            h = 0;
        }
    }

    if (TestFlag(pmsg->nFlags, SGR_ACTUAL)) {
//        AssertMsg(0, "TODO: Not Implemented");
        ClearFlag(pmsg->nFlags, SGR_ACTUAL);
        retval = xdSetLogRect(x, y, w, h, pmsg->nFlags);
    } else {
        retval = xdSetLogRect(x, y, w, h, pmsg->nFlags);
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiFindFromPoint(Visual::FindFromPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_FLAGS(pmsg->nStyle, GS_VALID);

    pmsg->pgvFound = GetVisual(FindFromPoint(pmsg->ptThisClientPxl, pmsg->nStyle, &pmsg->ptFoundClientPxl));
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiMapPoints(Visual::MapPointsMsg * pmsg)
{
    DuVisual * pdgvTo;

    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_VISUAL(pmsg->pgvTo, pdgvTo);
    VALIDATE_WRITE_PTR_(pmsg->rgptClientPxl, sizeof(POINT) * pmsg->cPts);

    if (GetRoot() != pdgvTo->GetRoot()) {
        PromptInvalid("Must be in the same tree");
        retval = E_INVALIDARG;
        goto ErrorExit;
    }

    DuVisual::MapPoints(this, pdgvTo, pmsg->rgptClientPxl, pmsg->cPts);
    retval = S_OK;

    END_API();
}

#endif // ENABLE_MSGTABLE_API


#if DBG

/***************************************************************************\
*
* DuVisual::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

void
DuVisual::DEBUG_AssertValid() const
{
#if ENABLE_MSGTABLE_API
    VisualImpl<DuVisual, DuEventGadget>::DEBUG_AssertValid();
#else
    DuEventGadget::DEBUG_AssertValid();
#endif

    TreeNodeT<DuVisual>::DEBUG_AssertValid();

    Assert(!m_fAllowSubclass);

    Assert(m_rcLogicalPxl.right >= m_rcLogicalPxl.left);
    Assert(m_rcLogicalPxl.bottom >= m_rcLogicalPxl.top);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\animation.h ===
#if !defined(CTRL__Animation_h__INCLUDED)
#define CTRL__Animation_h__INCLUDED
#pragma once

#include "Extension.h"

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuAnimation : 
    public AnimationImpl<DuAnimation, DuExtension>
{
// Construction
public:
    inline  DuAnimation();
            ~DuAnimation();
    static  HRESULT     InitClass();
    static  HRESULT     PreBuild(DUser::Gadget::ConstructInfo * pci);
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);
            void        Destroy(BOOL fFinal);

// Public API
public:
    dapi    HRESULT     ApiOnRemoveExisting(Animation::OnRemoveExistingMsg * pmsg);
    dapi    HRESULT     ApiOnDestroySubject(Animation::OnDestroySubjectMsg * pmsg);
    dapi    HRESULT     ApiOnAsyncDestroy(Animation::OnAsyncDestroyMsg * pmsg);

    dapi    HRESULT     ApiAddRef(Animation::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Animation::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiSetTime(Animation::SetTimeMsg * pmsg);

// Implementation
protected:
    static  void CALLBACK
                        RawActionProc(GMA_ACTIONINFO * pmai);
            void        ActionProc(GMA_ACTIONINFO * pmai);

            void        CleanupChangeGadget();

    inline  void        AddRef();
    inline  void        Release(); 

// Data
protected:
    static  MSGID       s_msgidComplete;

            HACTION     m_hact;
            Animation::ETime
                        m_time;         // Time when completed
            UINT        m_cRef;

            Interpolation *
                        m_pipol;
            Flow *      m_pgflow;

            BOOL        m_fStartDestroy:1;
            BOOL        m_fProcessing:1;

#if DBG
            UINT        m_DEBUG_cUpdates;
#endif
};


#endif // ENABLE_MSGTABLE_API

#include "Animation.inl"

#endif // CTRL__Animation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\treegadget.inl ===
/***************************************************************************\
*
* File: TreeGadget.inl
*
* Description:
* TreeGadget.inl implements lightweight common Gadget functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__TreeGadget_inl__INCLUDED)
#define CORE__TreeGadget_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuVisual * 
CastVisual(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmVisual)) {
#if DBG
        ((DuVisual *) pbase)->DEBUG_AssertValid();
#endif
        return (DuVisual *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuVisual * 
CastVisual(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmVisual)) {
#if DBG
        ((const DuVisual *) pbase)->DEBUG_AssertValid();
#endif
        return (const DuVisual *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuVisual *
CastVisual(DUser::Gadget * pg)
{
    DuVisual * pgad = (DuVisual *) MsgObject::CastMsgObject(pg);

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline DuVisual * 
ValidateVisual(HGADGET hgad)
{
    DuVisual * pgad = CastVisual(BaseObject::ValidateHandle(hgad));

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline DuVisual * 
ValidateVisual(Visual * pgv)
{
    DuVisual * pgad = (DuVisual *) MsgObject::CastMsgObject(pgv);

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline
DuVisual::DuVisual()
{
    // Make the default to be relative.  It is important to do this since only 
    // relative children can be added to a relative parent.  Also, the default 
    // behavior, whenever possible, should be to be relative unless the parent 
    // prevents us.
    //

    m_nStyle = GS_VISIBLE | GS_ENABLED | GS_RELATIVE;
    m_fDeepTrivial = TRUE;

    //
    // DuVisual's should have weDeepMouseEnter on by default so that 
    // GM_MOUSEENTER and GM_MOUSELEAVE can be processed.
    //
    // NOTE: This NEED's to be set AFTER m_nStyle has been set since m_we is
    // stored inside m_nStyle.
    //

    m_we = weDeepMouseEnter;
}


//------------------------------------------------------------------------------
inline DuRootGadget * 
DuVisual::GetRoot() const
{
    //
    // For the top level layout, need to have a DuRootGadget as its own owner.  
    // THIS IS VERY IMPORTANT, but it means that we need to be careful when 
    // using the owning layout b/c there is a circular link.  Use the parent 
    // tree when walking up to avoid this.
    //

    DuVisual * pgadCur = const_cast<DuVisual *> (this);
    while (pgadCur->GetParent() != NULL) {
        pgadCur = pgadCur->GetParent();
    }

    // Top level is always a DuRootGadget
    if (pgadCur->m_fRoot) {
        return (DuRootGadget *) pgadCur;
    } else {
        return NULL;
    }
}


//------------------------------------------------------------------------------
inline UINT
DuVisual::GetWantEvents() const
{
    return m_we;
}


//------------------------------------------------------------------------------
inline UINT        
DuVisual::GetStyle() const
{
    // Mask out bits that are not publicly exposed

    return m_nStyle & GS_VALID;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::GetEnableXForm() const
{
    return m_fXForm;
}


//------------------------------------------------------------------------------
inline XFormInfo *   
DuVisual::GetXFormInfo() const
{
    AssertMsg(m_fXForm, "Only can call if Trx are enabled");
    AssertMsg(SupportXForm(), "Only can set if XForm's are supported");

    XFormInfo * pti;
    VerifyHR(m_pds.GetData(s_pridXForm, (void **) &pti));
    return pti;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsRoot() const
{
    //
    // NOTE: A non-root Gadget may not yet have a parent during construction.
    // The called should be able to safely call IsRoot() during this time, but
    // is not allowed to call GetRoot() during this time.
    //

    return m_fRoot;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsRelative() const
{
    return m_fRelative;
}


//------------------------------------------------------------------------------
inline BOOL
DuVisual::IsParentChainStyle(UINT nStyle) const
{
    const DuVisual * pgadCur = this;
    while (pgadCur != NULL) {
        if ((pgadCur->m_nStyle & nStyle) != nStyle) {
            return FALSE;
        }

        pgadCur = pgadCur->GetParent();
    }

    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsVisible() const
{
    return IsParentChainStyle(GS_VISIBLE);
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsEnabled() const
{
    return IsParentChainStyle(GS_ENABLED);
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::HasChildren() const
{
    return m_ptnChild != NULL;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsBuffered() const
{
    return m_fBuffered;
}


//------------------------------------------------------------------------------
inline BUFFER_INFO *
DuVisual::GetBufferInfo() const
{
    AssertMsg(m_fBuffered, "Only call on buffered Gadgets");

    BUFFER_INFO * pbi;
    VerifyHR(m_pds.GetData(s_pridBufferInfo, (void **) &pbi));
    return pbi;
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::xdSetOrder(
    IN  DuVisual * pgadOther,     
    IN  UINT nCmd)
{
    return xdSetParent(GetParent(), pgadOther, nCmd);
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::GetProperty(PRID id, void ** ppValue) const
{
    return m_pds.GetData(id, (void **) ppValue);
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::SetProperty(PRID id, void * pValue)
{
    return m_pds.SetData(id, pValue);
}


//------------------------------------------------------------------------------
inline void
DuVisual::RemoveProperty(PRID id, BOOL fFree)
{
    m_pds.RemoveData(id, fFree);
}


//------------------------------------------------------------------------------
inline void
DuVisual::Link(DuVisual * pgadParent, DuVisual * pgadSibling, ELinkType lt)
{
    AssertMsg(GetParent() == NULL, "Must not already be linked");

    TreeNodeT<DuVisual>::DoLink(pgadParent, pgadSibling, lt);

    if (pgadParent != NULL) {
        pgadParent->UpdateTrivial(m_fDeepTrivial ? uhTrue : uhFalse);
        pgadParent->UpdateWantMouseFocus(m_fDeepMouseFocus ? uhTrue : uhFalse);
    }
}


//------------------------------------------------------------------------------
inline void
DuVisual::Unlink()
{
    DuVisual * pgadParent = GetParent();
    TreeNodeT<DuVisual>::DoUnlink();

    if (pgadParent != NULL) {
        pgadParent->UpdateTrivial(uhTrue /* Unlink is Trivial */);
        pgadParent->UpdateWantMouseFocus(uhTrue /* Unlink is Trivial */);
    }
}


//------------------------------------------------------------------------------
inline void
DuVisual::MarkInvalidChildren()
{
    //
    // Walk up the tree marking each parent as invalid
    //

    DuVisual * pgadCur = this;
    while ((pgadCur != NULL) && (!pgadCur->m_fInvalidChildren)) {
        pgadCur->m_fInvalidChildren = TRUE;
        pgadCur = pgadCur->GetParent();
    }
}


//------------------------------------------------------------------------------
inline DuVisual * 
DuVisual::GetKeyboardFocusableAncestor(
    IN DuVisual * pgadCur)
{
    //
    // Walk up the tree until we find a keyboard focusable gadget
    //

    while (pgadCur != NULL) {
        if (pgadCur->m_fKeyboardFocus && pgadCur->IsVisible() /*&& pgadCur->IsEnabled()*/) {
            return pgadCur;
        }

        pgadCur = pgadCur->GetParent();
    }

    return NULL;
}


//------------------------------------------------------------------------------
inline void
DuVisual::UpdateTrivial(EUdsHint hint)
{
    UpdateDeepAllState(hint, CheckIsTrivial, gspDeepTrivial);
}


//------------------------------------------------------------------------------
inline void
DuVisual::UpdateWantMouseFocus(EUdsHint hint)
{
    UpdateDeepAnyState(hint, CheckIsWantMouseFocus, gspDeepMouseFocus);
}


#endif // CORE__TreeGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\animation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Animation.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DUSER_API void WINAPI
DUserStopAnimation(Visual * pgvSubject, PRID pridAni)
{
    if (pgvSubject == NULL) {
        PromptInvalid("Invalid pgvSubject");
        return;
    }
    if (pridAni <= 0) {
        PromptInvalid("Invalid Animation pridAni");
        return;
    }

    DuExtension * pext = DuExtension::GetExtension(pgvSubject, pridAni);
    if (pext != NULL) {
        pext->GetStub()->OnRemoveExisting();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuAnimation
*
*****************************************************************************
\***************************************************************************/

MSGID       DuAnimation::s_msgidComplete = 0;

//------------------------------------------------------------------------------
DuAnimation::~DuAnimation()
{
    Destroy(TRUE);

    SafeRelease(m_pipol);
    SafeRelease(m_pgflow);

#if DEBUG_TRACECREATION
    Trace("STOP  Animation  0x%p    @ %d  (%d frames)\n", this, GetTickCount(), m_DEBUG_cUpdates);
#endif // DEBUG_TRACECREATION


    //
    // Ensure proper destruction
    //

    AssertMsg(m_hact == NULL, "Action should already be destroyed");
}


/***************************************************************************\
*
* DuAnimation::InitClass
*
* InitClass() is called during startup and provides an opportunity to 
* initialize common data.
*
\***************************************************************************/

HRESULT
DuAnimation::InitClass()
{
    s_msgidComplete = RegisterGadgetMessage(&_uuidof(Animation::evComplete));
    if (s_msgidComplete == 0) {
        return (HRESULT) GetLastError();
    }

    return S_OK;
}

//------------------------------------------------------------------------------
HRESULT
DuAnimation::PreBuild(DUser::Gadget::ConstructInfo * pci)
{
    //
    // Validate parameters
    //

    Animation::AniCI * pDesc = reinterpret_cast<Animation::AniCI *>(pci);
    if ((pDesc->pipol == NULL) || (pDesc->pgflow == NULL)) {
        PromptInvalid("Must provide valid Interpolation and Flow objects");
        return E_INVALIDARG;
    }

    PRID pridExtension = 0;
    VerifyHR(pDesc->pgflow->GetPRID(&pridExtension));
    if (pridExtension == 0) {
        PromptInvalid("Flow must register PRID");
        return E_INVALIDARG;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    //
    // Check parameters.  This should be validated in PreBuild().
    //

    Animation::AniCI * pDesc = reinterpret_cast<Animation::AniCI *>(pci);

    Assert(pDesc->pipol != NULL);
    Assert(pDesc->pgflow != NULL);


    //
    // Setup the Action
    //

    GMA_ACTION gma;
    ZeroMemory(&gma, sizeof(gma));
    gma.cbSize      = sizeof(gma);
    gma.flDelay     = pDesc->act.flDelay;
    gma.flDuration  = pDesc->act.flDuration;
    gma.flPeriod    = pDesc->act.flPeriod;
    gma.cRepeat     = pDesc->act.cRepeat;
    gma.dwPause     = pDesc->act.dwPause;
    gma.pfnProc     = RawActionProc;
    gma.pvData      = this;

    m_hact = CreateAction(&gma);
    if (m_hact == NULL) {
        return (HRESULT) GetLastError();
    }

    PRID pridExtension;
    VerifyHR(pDesc->pgflow->GetPRID(&pridExtension));
    HRESULT hr = DuExtension::Create(pDesc->pgvSubject, pridExtension, DuExtension::oAsyncDestroy);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Store the related objects
    //

    pDesc->pipol->AddRef();
    pDesc->pgflow->AddRef();

    m_pipol     = pDesc->pipol;
    m_pgflow    = pDesc->pgflow;


    //
    // Animations need to be AddRef()'d again (have a reference count of 2) 
    // because they need to outlive the initial call to Release() after the 
    // called has setup the animation returned from BuildAnimation().  
    //
    // This is because the Animation continues to life until it has fully 
    // executed (or has been aborted).
    //

    AddRef();

    return S_OK;
}


//------------------------------------------------------------------------------
void
DuAnimation::Destroy(BOOL fFinal)
{
    //
    // Mark that we have already started the destruction process and don't need
    // to start again.  We only want to post the destruction message once.
    //

    if (m_fStartDestroy) {
        return;
    }
    m_fStartDestroy = TRUE;


    if (m_pgvSubject != NULL) {
#if DBG
        DuAnimation * paniExist = static_cast<DuAnimation *> (GetExtension(m_pgvSubject, m_pridListen));
        if (paniExist != NULL) {
            AssertMsg(paniExist == this, "Animations must match");
        }
#endif // DBG

        CleanupChangeGadget();
    }


    //
    // Destroy the Animation
    //

    AssertMsg(!fFinal, "Object is already being destructed");
    if (fFinal) {
        GetStub()->OnAsyncDestroy();
    } else {
        PostAsyncDestroy();
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnAsyncDestroy(Animation::OnAsyncDestroyMsg *)
{
    AssertMsg(m_fStartDestroy, "Must call Destroy() to start the destruction process.");
    AssertMsg(!m_fProcessing, "Should not be processing when start destruction");

    AssertMsg(m_pgvSubject == NULL, "Animation should already have detached from Gadget");
    HACTION hact = m_hact;

    //
    // Set everything to NULL now.
    //

    m_hact = NULL;
    if (hact != NULL) {
        ::DeleteHandle(hact);
        hact = NULL;
    }

    Release();

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiSetTime(Animation::SetTimeMsg * pmsg)
{
    GMA_ACTIONINFO mai;

    //
    // TODO: Need to save these values from the last time so that they are 
    // valid.
    //

    mai.hact        = m_hact;
    mai.pvData      = this;
    mai.flDuration  = 0.0f;

    m_time = (Animation::ETime) pmsg->time;
    switch (pmsg->time)
    {
    case Animation::tComplete:
        // Don't do anything
        return S_OK;

    default:
    case Animation::tAbort:
    case Animation::tDestroy:
        goto Done;

    case Animation::tEnd:
        mai.flProgress  = 1.0f;
        break;

    case Animation::tReset:
        mai.flProgress  = 0.0f;
        break;
    }

    mai.cEvent      = 0;
    mai.cPeriods    = 0;
    mai.fFinished   = FALSE;

    m_fProcessing = TRUE;
    m_pgflow->OnAction(m_pgvSubject, m_pipol, mai.flProgress);
    Assert(m_fProcessing);
    m_fProcessing = FALSE;

Done:
    ::DeleteHandle(m_hact);
    
    return S_OK;    
}


//------------------------------------------------------------------------------
void
DuAnimation::CleanupChangeGadget()
{
    //
    // Give the derived Animation a chance to cleanup
    //
    // Check that we are still the Animation attached to this Gadget.  We need 
    // to remove this property immediately.  We can not wait for a posted 
    // message to be processed because we may need to set it right now if we are
    // creating a new Animation.
    //

    BOOL fStarted = FALSE;

    Animation::CompleteEvent msg;
    msg.cbSize  = sizeof(msg);
    msg.nMsg    = s_msgidComplete;
    msg.hgadMsg = GetHandle();
    msg.fNormal = IsStartDelete(m_pgvSubject->GetHandle(), &fStarted) && (!fStarted);

    DUserSendEvent(&msg, 0);


    Assert(m_pgvSubject != NULL);
    Assert(m_pridListen != 0);

    Verify(SUCCEEDED(m_pgvSubject->RemoveProperty(m_pridListen)));

    m_pgvSubject = NULL;
}

    
//------------------------------------------------------------------------------
void CALLBACK
DuAnimation::RawActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
    //
    // Need to AddRef while processing the Animation to ensure that it does not
    // get destroyed from under us, for example, during one of the callbacks.
    //

    DuAnimation * pani = (DuAnimation *) pmai->pvData;
    pani->AddRef();

    Assert(!pani->m_fProcessing);

#if DEBUG_TRACECREATION
    Trace("START RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    pani->ActionProc(pmai);

#if DEBUG_TRACECREATION
    Trace("STOP  RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    Assert(!pani->m_fProcessing);

    pani->Release();
}


//------------------------------------------------------------------------------
void
DuAnimation::ActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
#if DBG
    m_DEBUG_cUpdates++;
#endif // DBG

    if ((!m_fStartDestroy) && (m_pgvSubject != NULL)) {
        //
        // This ActionProc will be called when the Action is being destroyed, so
        // we only want to invoke the Action under certain circumstances.
        //

        switch (m_time)
        {
        case Animation::tComplete:
        case Animation::tEnd:
        case Animation::tReset:
            //
            // All of these are valid to complete.  If it isn't in this list, we
            // don't want to execute it during a shutdown.
            //

            m_fProcessing = TRUE;
            m_pgflow->OnAction(m_pgvSubject, m_pipol, pmai->flProgress);
            Assert(m_fProcessing);
            m_fProcessing = FALSE;
            break;
        }
    }

    if (pmai->fFinished) {
        m_hact = NULL;
        Destroy(FALSE);
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnRemoveExisting(Animation::OnRemoveExistingMsg *)
{
    GetStub()->SetTime(Animation::tDestroy);
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnDestroySubject(Animation::OnDestroySubjectMsg *)
{
    AddRef();

    if (m_pgvSubject != NULL) {
        CleanupChangeGadget();

        //
        // The Gadget that we are modifying is being destroyed, so we need
        // to stop animating it.
        //

        m_time = Animation::tDestroy;
        Destroy(FALSE);
    }

    Release();

    return S_OK;
}

#else

//------------------------------------------------------------------------------
DUSER_API void WINAPI
DUserStopAnimation(Visual * pgvSubject, PRID pridAni)
{
    UNREFERENCED_PARAMETER(pgvSubject);
    UNREFERENCED_PARAMETER(pridAni);

    PromptInvalid("Not implemented without MsgTable support");
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\treegadgetp.h ===
/***************************************************************************\
*
* File: TreeGadgetP.h
*
* Description:
* TreeGadgetP.h includes private definitions used internally to the 
* DuVisual class.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__TreeGadgetP_h__INCLUDED)
#define CORE__TreeGadgetP_h__INCLUDED

//
// XFormInfo contains information about GDI World Transforms for a specific
// DuVisual.
//

inline bool IsZero(float fl)
{
    return (fl < 0.00001f) && (fl > -0.00001f);
}

struct XFormInfo
{
    float       flScaleX;           // Horizontal scaling factor
    float       flScaleY;           // Vertical scaling factor
    float       flCenterX;          // Horizontal center-point
    float       flCenterY;          // Vertical center-point
    float       flRotationRad;      // Rotation around upper left corner in radians

    inline bool IsEmpty() const
    {
        return IsZero(flScaleX - 1.0f) && 
                IsZero(flScaleY - 1.0f) && 
                IsZero(flCenterX) && 
                IsZero(flCenterY) &&
                IsZero(flRotationRad);
    }

    void Apply(Matrix3 * pmat)
    {
        pmat->Translate(flCenterX, flCenterY);
        pmat->Rotate(flRotationRad);
        pmat->Scale(flScaleX, flScaleY);
        pmat->Translate(-flCenterX, -flCenterY);
    }

    void ApplyAnti(Matrix3 * pmat)
    {
        pmat->Translate(flCenterX, flCenterY);
        pmat->Scale(1.0f / flScaleX, 1.0f / flScaleY);
        pmat->Rotate(-flRotationRad);
        pmat->Translate(-flCenterX, -flCenterY);
    }
};


//
// FillInfo holds information used for filling the background with the
// specified brush.
//

struct FillInfo
{
    DuSurface::EType type;          // Surface type for brush
    union
    {
        struct
        {
            HBRUSH      hbrFill;        // (Background) fill brush
            BYTE        bAlpha;         // Use background brush for alpha on front
            SIZE        sizeBrush;      // Size of fill brush
        };
        struct
        {
            Gdiplus::Brush *
                        pgpbr;          // (Background) fill brush
        };
    };
};


//
// PaintInfo holds information used for painting requests
//

struct PaintInfo
{
    const RECT *    prcCurInvalidPxl;   // Invalid rectangle in XForm'ed coordinates
    const RECT *    prcOrgInvalidPxl;   // Original invalid rectangle in container coordinates
    DuSurface *     psrf;               // Surface to draw into
    Matrix3 *       pmatCurInvalid;     // Current invalid transformation matrix
    Matrix3 *       pmatCurDC;          // Current DC transformation matrix
    BOOL            fBuffered;          // Subtree drawing is being buffered
#if ENABLE_OPTIMIZEDIRTY
    BOOL            fDirty;             // Dirty state
#endif
    SIZE            sizeBufferOffsetPxl; // Forced offset b/c of Buffer
};


//
// Invalidation should edge outside any boundaries to ensure that the pixels
// on the edge are included in the invalidation.
//
// Clipping should edge inside any boundaries to ensure that pixels on the edge
// are not included.
//
// This is VERY important to setup correctly because of GDI world 
// transformations and rounding errors converting from floats to ints and back.
//

const Matrix3::EHintBounds  HINTBOUNDS_Invalidate = Matrix3::hbOutside;
const Matrix3::EHintBounds  HINTBOUNDS_Clip = Matrix3::hbInside;

#endif // CORE__TreeGadgetP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\core\treegadget.h ===
/***************************************************************************\
*
* File: TreeGadget.h
*
* Description:
* TreeGadget.h defines the base "DuVisual" used inside a 
* DuVisual-Tree for hosting objects inside a form.  There are several 
* derived classes that are optimized for hosting different types of objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(CORE__TreeGadget_h__INCLUDED)
#define CORE__TreeGadget_h__INCLUDED
#pragma once

#include "BaseGadget.h"
#include "PropList.h"

#define ENABLE_OPTIMIZESLRUPDATE    1   // Optimize xdSetLogRect updating bits
#define ENABLE_OPTIMIZEDIRTY        0   // Optimize dirty invalidation

// Forward declarations
class DuContainer;
class DuVisual;
class DuRootGadget;

struct XFormInfo;
struct FillInfo;
struct PaintInfo;

class DuVisual : 
#if ENABLE_MSGTABLE_API
        public VisualImpl<DuVisual, DuEventGadget>,
#else
        public DuEventGadget,
#endif
        public TreeNodeT<DuVisual>
{
// Construction
public:
    inline  DuVisual();
    virtual ~DuVisual();
    virtual BOOL        xwDeleteHandle();
    static  HRESULT     InitClass();
    static  HRESULT     Build(DuVisual * pgadParent, CREATE_INFO * pci, DuVisual ** ppgadNew, BOOL fDirect);
            HRESULT     CommonCreate(CREATE_INFO * pci, BOOL fDirect = FALSE);
protected:
    virtual void        xwDestroy();

// Public API
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Visual);
    static HRESULT CALLBACK
                        PromoteVisual(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

    dapi    HRESULT     ApiSetOrder(Visual::SetOrderMsg * pmsg);
    dapi    HRESULT     ApiSetParent(Visual::SetParentMsg * pmsg);

    dapi    HRESULT     ApiGetGadget(Visual::GetGadgetMsg * pmsg);
    dapi    HRESULT     ApiGetStyle(Visual::GetStyleMsg * pmsg);
    dapi    HRESULT     ApiSetStyle(Visual::SetStyleMsg * pmsg);
    dapi    HRESULT     ApiSetKeyboardFocus(Visual::SetKeyboardFocusMsg * pmsg);
    dapi    HRESULT     ApiIsParentChainStyle(Visual::IsParentChainStyleMsg * pmsg);

    dapi    HRESULT     ApiGetProperty(Visual::GetPropertyMsg * pmsg);
    dapi    HRESULT     ApiSetProperty(Visual::SetPropertyMsg * pmsg);
    dapi    HRESULT     ApiRemoveProperty(Visual::RemovePropertyMsg * pmsg);

    dapi    HRESULT     ApiInvalidate(Visual::InvalidateMsg * pmsg);
    dapi    HRESULT     ApiInvalidateRects(Visual::InvalidateRectsMsg * pmsg);
    dapi    HRESULT     ApiSetFillF(Visual::SetFillFMsg * pmsg);
    dapi    HRESULT     ApiSetFillI(Visual::SetFillIMsg * pmsg);
    dapi    HRESULT     ApiGetScale(Visual::GetScaleMsg * pmsg);
    dapi    HRESULT     ApiSetScale(Visual::SetScaleMsg * pmsg);
    dapi    HRESULT     ApiGetRotation(Visual::GetRotationMsg * pmsg);
    dapi    HRESULT     ApiSetRotation(Visual::SetRotationMsg * pmsg);
    dapi    HRESULT     ApiGetCenterPoint(Visual::GetCenterPointMsg * pmsg);
    dapi    HRESULT     ApiSetCenterPoint(Visual::SetCenterPointMsg * pmsg);

    dapi    HRESULT     ApiGetBufferInfo(Visual::GetBufferInfoMsg * pmsg);
    dapi    HRESULT     ApiSetBufferInfo(Visual::SetBufferInfoMsg * pmsg);

    dapi    HRESULT     ApiGetSize(Visual::GetSizeMsg * pmsg);
    dapi    HRESULT     ApiGetRect(Visual::GetRectMsg * pmsg);
    dapi    HRESULT     ApiSetRect(Visual::SetRectMsg * pmsg);

    dapi    HRESULT     ApiFindFromPoint(Visual::FindFromPointMsg * pmsg);
    dapi    HRESULT     ApiMapPoints(Visual::MapPointsMsg * pmsg);

#endif // ENABLE_MSGTABLE_API

// BaseObject Interface
public:
    virtual BOOL        IsStartDelete() const;
    virtual HandleType  GetHandleType() const { return htVisual; }
    virtual UINT        GetHandleMask() const { return hmMsgObject | hmEventGadget | hmVisual; }

#if DBG
protected:
    virtual BOOL        DEBUG_IsZeroLockCountValid() const;
#endif // DBG


// Operations
public:
    inline  UINT        GetStyle() const;
            HRESULT     xdSetStyle(UINT nNewStyle, UINT nMask, BOOL fNotify = FALSE);

            // Tree Operations
    inline  DuRootGadget* GetRoot() const;
    inline  DuContainer * GetContainer() const;

            DuVisual* GetGadget(UINT nCmd) const;
    inline  HRESULT     xdSetOrder(DuVisual * pgadOther, UINT nCmd);
            HRESULT     xdSetParent(DuVisual * pgadNewParent, DuVisual * pgadOther, UINT nCmd);
            HRESULT     xwEnumGadgets(GADGETENUMPROC pfnProc, void * pvData, UINT nFlags);
            HRESULT     AddChild(CREATE_INFO * pci, DuVisual ** ppgadNew);

    inline  BOOL        IsRoot() const;
    inline  BOOL        IsRelative() const;
    inline  BOOL        IsParentChainStyle(UINT nStyle) const;
    inline  BOOL        IsVisible() const;
    inline  BOOL        IsEnabled() const;
    inline  BOOL        HasChildren() const;
            BOOL        IsDescendent(const DuVisual * pgadChild) const;
            BOOL        IsSibling(const DuVisual * pgad) const;

            // Size, location, XForm Operations
            void        GetSize(SIZE * psizeLogicalPxl) const;
            void        GetLogRect(RECT * prcPxl, UINT nFlags) const;
            HRESULT     xdSetLogRect(int x, int y, int w, int h, UINT nFlags);

            void        GetScale(float * pflScaleX, float * pflScaleY) const;
            HRESULT     xdSetScale(float flScaleX, float flScaleY);
            float       GetRotation() const;
            HRESULT     xdSetRotation(float flRotationRad);
            void        GetCenterPoint(float * pflCenterX, float * pflCenterY) const;
            HRESULT     xdSetCenterPoint(float flCenterX, float flCenterY);

            DuVisual *
                        FindFromPoint(POINT ptThisClientPxl, UINT nStyle, POINT * pptFoundClientPxl) const;
            void        MapPoint(POINT * pptPxl) const;
            void        MapPoint(POINT ptContainerPxl, POINT * pptClientPxl) const;
    static  void        MapPoints(const DuVisual * pgadFrom, const DuVisual * pgadTo, POINT * rgptClientPxl, int cPts);


            // Painting Operations
            void        Invalidate();
            void        InvalidateRects(const RECT * rgrcClientPxl, int cRects);
            HRESULT     SetFill(HBRUSH hbrFill, BYTE bAlpha = BLEND_OPAQUE, int w = 0, int h = 0);
            HRESULT     SetFill(Gdiplus::Brush * pgpbr);
            HRESULT     GetRgn(UINT nRgnType, HRGN hrgn, UINT nFlags) const;

    inline  BOOL        IsBuffered() const;
            HRESULT     GetBufferInfo(BUFFER_INFO * pbi) const;
            HRESULT     SetBufferInfo(const BUFFER_INFO * pbi);

#if DBG
    static  void        DEBUG_SetOutline(DuVisual * pgadOutline);
            void        DEBUG_GetStyleDesc(LPWSTR pszDesc, int cchMax) const;
#endif // DBG

            // Messaging and Event Operations
            enum EWantEvent
            {
                weMouseMove     = 0x00000001,   // (Shallow) Mouse move
                weMouseEnter    = 0x00000002,   // Mouse enter and leave
                weDeepMouseMove = 0x00000004,   // (Deep) Mouse move (either me or my children)
                weDeepMouseEnter= 0x00000008,   // (Deep) Mouse enter and leave
            };

    inline  UINT        GetWantEvents() const;
    virtual void        SetFilter(UINT nNewFilter, UINT nMask);

    static  HRESULT     RegisterPropertyNL(const GUID * pguid, PropType pt, PRID * pprid);
    static  HRESULT     UnregisterPropertyNL(const GUID * pguid, PropType pt);

    inline  HRESULT     GetProperty(PRID id, void ** ppValue) const;
    inline  HRESULT     SetProperty(PRID id, void * pValue);
    inline  void        RemoveProperty(PRID id, BOOL fFree);

            // Tickets
            HRESULT     GetTicket(DWORD * pdwTicket);
            void        ClearTicket();
    static  HGADGET     LookupTicket(DWORD dwTicket);

// Internal Implementation
            // Creation / Destruction
protected:
            void        xwBeginDestroy();
            void        xwDestroyAllChildren();

            // Tree management
private:
    inline  void        Link(DuVisual * pgadParent, DuVisual * pgadSibling = NULL, ELinkType lt = ltTop);
    inline  void        Unlink();
    inline  DuVisual *GetKeyboardFocusableAncestor(DuVisual * pgad);

            void        xdUpdatePosition() const;
            void        xdUpdateAdaptors(UINT nCode) const;

            // Painting
protected:
            void        xrDrawStart(PaintInfo * ppi, UINT nFlags);
private:
            void        xrDrawFull(PaintInfo * ppi);
            void        DrawFill(DuSurface * psrf, const RECT * prcDrawPxl);
            void        xrDrawCore(PaintInfo * ppi, const RECT * prcGadgetPxl);
            void        xrDrawTrivial(PaintInfo * ppi, const SIZE sizeOffsetPxl);
            int         DrawPrepareClip(PaintInfo * ppi, const RECT * prcGadgetPxl, void ** ppvOldClip) const;
            void        DrawCleanupClip(PaintInfo * ppi, void * pvOldClip) const;
            void        DrawSetupBufferCommand(const RECT * prcBoundsPxl, SIZE * psizeBufferOffsetPxl, UINT * pnCmd) const;

    inline  BUFFER_INFO *
                        GetBufferInfo() const;
            HRESULT     SetBuffered(BOOL fBuffered);


            enum EUdsHint
            {
                uhNone,         // No hint
                uhTrue,         // A child changed to TRUE
                uhFalse         // A child changed to FALSE
            };

    typedef BOOL        (DuVisual::*DeepCheckNodeProc)() const;
            BOOL        CheckIsTrivial() const;
            BOOL        CheckIsWantMouseFocus() const;
                
    inline  void        UpdateTrivial(EUdsHint hint);
    inline  void        UpdateWantMouseFocus(EUdsHint hint);
            void        UpdateDeepAllState(EUdsHint hint, DeepCheckNodeProc pfnCheck, UINT nStateMask);
            void        UpdateDeepAnyState(EUdsHint hint, DeepCheckNodeProc pfnCheck, UINT nStateMask);


            // Invalidation
private:
            BOOL        IsParentInvalid() const;
            void        DoInvalidateRect(DuContainer * pcon, const RECT * rgrcClientPxl, int cRects);
    inline  void        MarkInvalidChildren();
            void        ResetInvalid();
#if DBG
            void        DEBUG_CheckResetInvalid() const;
#endif // DBG


            // XForms
protected:
            void        BuildXForm(Matrix3 * pmatCur) const;
            void        BuildAntiXForm(Matrix3 * pmatCur) const;
private:
    inline  BOOL        GetEnableXForm() const;
            HRESULT     SetEnableXForm(BOOL fEnable);
            XFormInfo * GetXFormInfo() const;
            void        DoCalcClipEnumXForm(RECT * rgrcFinalClipClientPxl, const RECT * rgrcClientPxl, int cRects) const;
            void        DoXFormClientToParent(RECT * rgrcParentPxl, const RECT * rgrcClientPxl, int cRects, Matrix3::EHintBounds hb) const;
            void        DoXFormClientToParent(POINT * rgptClientPxl, int cPoints) const;
            BOOL        FindStepImpl(const DuVisual * pgadCur, int xOffset, int yOffset, POINT * pptFindPxl) const;

            // Positioning
private:
            void        SLROffsetLogRect(const SIZE * psizeDeltaPxl);
            void        SLRUpdateBits(RECT * prcOldParentPxl, RECT * prcNewParentPxl, UINT nChangeFlags);
            void        SLRInvalidateRects(DuContainer * pcon, const RECT * rgrcClientPxl, int cRects);

#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
    static  CritLock    s_lockProp;         // Lock for s_ptsProp
    static  AtomSet     s_ptsProp;          // AtomSet for properties
    static  PRID        s_pridXForm;        // PRID: World Transform
    static  PRID        s_pridBackFill;     // PRID: Background Brush
    static  PRID        s_pridBufferInfo;   // PRID: Buffering information
    static  PRID        s_pridTicket;       // PRID: ticket


    //
    // NOTE: This data members are declared in order of importance to help with
    // cache alignment.
    //
    // DuEventGadget:   10 DWORD's       (Debug = 11 DWORD's)
    // TreeNode:        4 DWORD's
    //

            PropSet     m_pds;              // (1D) Dynamic property data set

    union {
            UINT        m_nStyle;           // (1D) Combined style

        struct {
            // Public flags exposed through GetStyle()
            BOOL        m_fRelative:1;      // Relative to parent positioning
            BOOL        m_fVisible:1;       // Visible
            BOOL        m_fEnabled:1;       // Enabled
            BOOL        m_fBuffered:1;      // Sub-tree drawing is buffered
            BOOL        m_fAllowSubclass:1; // Allow subclassing
            BOOL        m_fKeyboardFocus:1; // Can "accept" keyboard focus
            BOOL        m_fMouseFocus:1;    // Can "accept" mouse focus
            BOOL        m_fClipInside:1;    // Clip drawing inside this DuVisual
            BOOL        m_fClipSiblings:1;  // Clip siblings of this DuVisual
            BOOL        m_fHRedraw:1;       // Redraw entire Gadget if resized horizontally
            BOOL        m_fVRedraw:1;       // Redraw entire Gadget if resized vertically
            BOOL        m_fOpaque:1;        // HINT: Drawing is not composited
            BOOL        m_fZeroOrigin:1;    // Set origin to (0,0)
            BOOL        m_fCustomHitTest:1; // Requires custom hit-testing
            BOOL        m_fAdaptor:1;       // Requires extra notifications to host
            BOOL        m_fCached:1;        // Sub-tree drawing is cached
            BOOL        m_fDeepPaintState:1;// Sub-tree has paint state

            // Private flags used internally
            BOOL        m_fRoot:1;          // Root of a subtree (DuRootGadget)
            BOOL        m_fFinalDestroy:1;  // Started destruction of window
            BOOL        m_fDestroyed:1;     // Final stage of destruction
            BOOL        m_fXForm:1;         // Has world-transform information
            BOOL        m_fBackFill:1;      // Has background fill information
            BOOL        m_fTicket:1;        // Has ticket information
            BOOL        m_fDeepTrivial:1;   // Gadget sub-tree has "trivial" painting
            BOOL        m_fDeepMouseFocus:1; // Gadget sub-tree wants mouse focus
            BOOL        m_fInvalidFull:1;   // Gadget has been fully invalidated
            BOOL        m_fInvalidChildren:1; // Gadget has invalid children
#if ENABLE_OPTIMIZEDIRTY
            BOOL        m_fInvalidDirty:1;  // Gadget has been (at least) partially invalidated
#endif

#if DEBUG_MARKDRAWN
            BOOL        m_fMarkDrawn:1;     // DEBUG: Was drawn in last paint
#endif

            UINT        m_we:4;             // Want events
        };
    };

    enum EStyle {
        gspRoot =               0x00020000,
        gspFinalDestroy =       0x00040000,
        gspDestroyed =          0x00080000,
        gspXForm =              0x00100000,
        gspBackFill =           0x00200000,
        gspTicket =             0x00400000,
        gspDeepTrivial =        0x00800000,
        gspDeepMouseFocus =     0x01000000,
        gspInvalidFull =        0x02000000,
        gspInvalidChildren =    0x04000000,
    };

            RECT        m_rcLogicalPxl;     // (4D) Logical location (pixels)

#if DBG_STORE_NAMES
            WCHAR *     m_DEBUG_pszName;    // DEBUG: Name of Gadget
            WCHAR *     m_DEBUG_pszType;    // DEBUG: Type of Gadget
#endif // DBG_STORE_NAMES

#if DBG
    static  DuVisual* s_DEBUG_pgadOutline;// DEBUG: Outline Gadget after drawing
#endif // DBG

    //
    // Current size:    20 DWORD's      (Debug = 21 DWORD's)
    //                  80 bytes        (Debug = 84 bytes)
    //

    friend DuRootGadget;
};


#include "TreeGadget.inl"

#endif // CORE__TreeGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\ctrlstubs.cpp ===
#include "stdafx.h"
#include "Ctrl.h"

#define GADGET_ENABLE_CONTROLS

#include "OldInterpolation.h"
#include "OldAnimation.h"
#include "OldDragDrop.h"

inline void SetError(HRESULT hr)
{
    SetLastError((DWORD) hr);
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildInterpolation(UINT nIPolID, int nVersion, REFIID riid, void ** ppvUnk)
{
    if (nVersion != 0) {
        SetError(E_INVALIDARG);
        return FALSE;
    }

    HRESULT hr = E_INVALIDARG;

    switch (nIPolID) 
    {
    case INTERPOLATION_LINEAR:
        hr = OldInterpolationT<OldLinearInterpolation, ILinearInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_LOG:
        hr = OldInterpolationT<OldLogInterpolation, ILogInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_EXP:
        hr = OldInterpolationT<OldExpInterpolation, IExpInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_S:
        hr = OldInterpolationT<OldSInterpolation, ISInterpolation>::Build(riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildAnimation(UINT nAniID, int nVersion, GANI_DESC * pDesc, REFIID riid, void ** ppvUnk)
{
    HRESULT hr = E_INVALIDARG;
    if (nVersion != 0) {
        goto Error;
    }
    if (ppvUnk == NULL) {
        goto Error;
    }

    switch (nAniID) 
    {
    case ANIMATION_ALPHA:
        hr = OldAnimationT<OldAlphaAnimation, IAnimation, GANI_ALPHADESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_SCALE:
        hr = OldAnimationT<OldScaleAnimation, IAnimation, GANI_SCALEDESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_RECT:
        hr = OldAnimationT<OldRectAnimation, IAnimation, GANI_RECTDESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_ROTATE:
        hr = OldAnimationT<OldRotateAnimation, IAnimation, GANI_ROTATEDESC>::Build(pDesc, riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
Error:
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetAnimation(HGADGET hgad, UINT nAniID, REFIID riid, void ** ppvUnk)
{
    HRESULT hr = E_INVALIDARG;
    if (hgad == NULL) {
        goto Error;
    }
    if (ppvUnk == NULL) {
        goto Error;
    }

    switch (nAniID) 
    {
    case ANIMATION_ALPHA:
        hr = OldAnimationT<OldAlphaAnimation, IAnimation, GANI_ALPHADESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_SCALE:
        hr = OldAnimationT<OldScaleAnimation, IAnimation, GANI_SCALEDESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_RECT:
        hr = OldAnimationT<OldRectAnimation, IAnimation, GANI_RECTDESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_ROTATE:
        hr = OldAnimationT<OldRotateAnimation, IAnimation, GANI_ROTATEDESC>::GetInterface(hgad, riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
Error:
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildDropTarget(HGADGET hgadRoot, HWND hwnd)
{
    HRESULT hr = E_INVALIDARG;
    hgadRoot = GetGadget(hgadRoot, GG_ROOT);  // Ensure root

    if ((hgadRoot == NULL) || (!IsWindow(hwnd))) {
        goto Error;
    }

    OldDropTarget * pdt;
    hr = OldDropTarget::Build(hgadRoot, hwnd, &pdt);
    if (SUCCEEDED(hr)) {
        return TRUE;
    }

Error:
    SetError(hr);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\animation.inl ===
#if !defined(CTRL__Animation_inl__INCLUDED)
#define CTRL__Animation_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

#define DEBUG_TRACECREATION         0   // Trace Creation and destruction of animations

/***************************************************************************\
*****************************************************************************
*
* class DuAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuAnimation::DuAnimation()
{
    m_cRef = 1;
    m_time = Animation::tComplete;  // By default, completes normally

#if DEBUG_TRACECREATION
    Trace("START Animation  0x%p    @ %d\n", this, GetTickCount());
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
inline void
DuAnimation::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuAnimation::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Animation_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\ctrl.h ===
/***************************************************************************\
*
* File: Ctrl.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CTRL___Ctrl_h__INCLUDED)
#define CTRL___Ctrl_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_TRANSITIONS   // Actions
#include <DUser.h>
#include <DUserCtrl.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Ctrl Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // CTRL___Ctrl_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\dragdrop.inl ===
#if !defined(CORE__DragDrop_inl__INCLUDED)
#define CORE__DragDrop_inl__INCLUDED
#pragma once

#if 1

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class TargetLock
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
TargetLock::TargetLock()
{
    
}


//------------------------------------------------------------------------------
inline
TargetLock::~TargetLock() 
{
    if (m_fAddRef) {
        m_punk->Release();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuDropTarget
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuDropTarget::DuDropTarget()
{

}


//------------------------------------------------------------------------------
inline BOOL
DuDropTarget::HasSource() const
{
    return m_pdoSrc != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
DuDropTarget::HasTarget() const
{
    return m_pdtCur != NULL;
}

#endif // ENABLE_MSGTABLE_API

#endif

#endif // CORE__DragDrop_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\dragdrop.h ===
/***************************************************************************\
*
* File: DragDrop.h
*
* Description:
* DragDrop.h defines drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DragDrop_h__INCLUDED)
#define CORE__DragDrop_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

#include "Extension.h"

class TargetLock;

#if 1

class DuDropTarget : 
        public DropTargetImpl<DuDropTarget, DuExtension>,
        public IDropTarget
{
protected:
    inline  DuDropTarget();
            ~DuDropTarget();
public:
    static  HRESULT     InitClass();

// IDropTarget
public:
    STDMETHOD(DragEnter)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);

// Public API
public:
    dapi    HRESULT     ApiOnDestroySubject(DropTarget::OnDestroySubjectMsg * pmsg);

    static  HRESULT CALLBACK
                        PromoteDropTarget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pmicData);

    static  HCLASS CALLBACK
                        DemoteDropTarget(HCLASS hclCur, DUser::Gadget * pgad, void * pvData);

// Implementation
protected:
    inline  BOOL        HasSource() const;
    inline  BOOL        HasTarget() const;

            HRESULT     xwDragScan(POINTL ptDesktopPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(POINT ptContainerPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(Visual * pgvFound, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwDragEnter(POINT * pptClientPxl, DWORD * pdwEffect);
            void        xwDragLeave();

// Data
protected:
    static  const IID * s_rgpIID[];
            IDropTarget *
                        m_pdtCur;               // Current Gadget DuDropTarget
            IDataObject *
                        m_pdoSrc;               // Source's data object
            HWND        m_hwnd;                 // Containing HWND
            DWORD       m_grfLastKeyState;      // Last key state
            POINT       m_ptLastContainerPxl;   // Last container pixel
            Visual *    m_pgvDrop;              // Current DuDropTarget
    static  PRID        s_pridListen;           // PRID for DuDropTarget

    friend class TargetLock;
};


class TargetLock
{
public:
    inline  TargetLock();
    inline  ~TargetLock();
            BOOL        Lock(DuDropTarget * p, DWORD * pdwEffect, BOOL fAddRef = TRUE);

protected:
            IUnknown *      m_punk;
            BOOL            m_fAddRef;
};

#endif // ENABLE_MSGTABLE_API

#endif

#include "DragDrop.inl"

#endif // CORE__DragDrop_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\extension.h ===
#if !defined(CTRL__Extension_h__INCLUDED)
#define CTRL__Extension_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

class DuExtension :
        public ExtensionImpl<DuExtension, SListener>
{
// Construction
public:
    inline  DuExtension();
    virtual ~DuExtension();
    static  HRESULT     InitClass();

    enum EOptions
    {
        oUseExisting    = 0x00000001,   // Use existing Extension if already attached
        oAsyncDestroy   = 0x00000002,   // Use asynchronous destruction
    };

            HRESULT     Create(Visual * pgvChange, PRID pridExtension, UINT nOptions);
            void        Destroy();
            void        DeleteHandle();

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiOnRemoveExisting(Extension::OnRemoveExistingMsg * pmsg);
    dapi    HRESULT     ApiOnDestroySubject(Extension::OnDestroySubjectMsg * pmsg);
    dapi    HRESULT     ApiOnAsyncDestroy(Extension::OnAsyncDestroyMsg * pmsg);

// Operations
public:
    static  DuExtension* GetExtension(Visual * pgvSubject, PRID prid);

// Implementation 
protected:
            void        PostAsyncDestroy();

// Data
protected:
            Visual *    m_pgvSubject;   // Visual Gadget being "extended"
            PRID        m_pridListen;   // PRID for Extension
            BOOL        m_fAsyncDestroy:1;
                                        // Need to destroy asynchronously

    static  MSGID       s_msgidAsyncDestroy;
};

#endif // ENABLE_MSGTABLE_API

#include "Extension.inl"

#endif // CTRL__Extension_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\dragdrop.cpp ===
/***************************************************************************\
*
* File: DragDrop.cpp
*
* Description:
* DragDrop.cpp implements drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Ctrl.h"
#include "DragDrop.h"

#include <SmObject.h>

#if 1

#if ENABLE_MSGTABLE_API

static const GUID guidDropTarget = { 0x6a8bb3c8, 0xcbfc, 0x40d1, { 0x98, 0x1e, 0x3f, 0x8a, 0xaf, 0x99, 0x13, 0x7b } };  // {6A8BB3C8-CBFC-40d1-981E-3F8AAF99137B}

/***************************************************************************\
*****************************************************************************
*
* class TargetLock
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* TargetLock::Lock
*
* Lock() prepares for executing inside the Context when being called back
* from OLE's IDropTarget that was registered.
*
\***************************************************************************/

BOOL 
TargetLock::Lock(
    IN  DuDropTarget * p,           // DuDropTarget being used
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT if failure
    IN  BOOL fAddRef)               // Lock DT during use
{
    m_fAddRef   = fAddRef;
    m_punk      = static_cast<IUnknown *> (p);

    if (m_fAddRef) {
        m_punk->AddRef();
    }

    if (p->m_pgvSubject == NULL) {
        if (pdwEffect != NULL) {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return FALSE;
    }

    return TRUE;
}

    
/***************************************************************************\
*****************************************************************************
*
* class DuDropTarget
* 
* NOTE: With the current design and implementation, DuDropTarget can not be 
* "removed" from an object until the object is destroyed.  If this needs to 
* change, we need to revisit this.
* 
*****************************************************************************
\***************************************************************************/

const IID * DuDropTarget::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IDropTarget),
    NULL
};

PRID DuDropTarget::s_pridListen = 0;


//
// NOTE: We are calling back directly on the IDropTarget's, so we need to grab
// a read-only lock so that the tree doesn't get smashed.
//

/***************************************************************************\
*
* DuDropTarget::~DuDropTarget
*
* ~DuDropTarget() cleans up resources used by the DuDropTarget.
*
\***************************************************************************/

DuDropTarget::~DuDropTarget()
{
    TargetLock lt;
    lt.Lock(this, NULL, FALSE);
    xwDragLeave();
    SafeRelease(m_pdoSrc);
}


//------------------------------------------------------------------------------
HRESULT
DuDropTarget::InitClass()
{
    s_pridListen = RegisterGadgetProperty(&guidDropTarget);
    return s_pridListen != 0 ? S_OK : (HRESULT) GetLastError();
}


typedef SmObjectT<DuDropTarget, IDropTarget> DuDropTargetObj;

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuDropTarget::PromoteDropTarget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pmicData)
{
    HRESULT hr;

    DropTarget::DropCI * pciD = (DropTarget::DropCI *) pmicData;

    //
    // Check parameters
    //

    Visual * pgvRoot;
    if (pciD->pgvRoot == NULL) {
        return E_INVALIDARG;
    }

    hr = pciD->pgvRoot->GetGadget(GG_ROOT, &pgvRoot);
    if (FAILED(hr)) {
        return hr;
    }

    if ((pgvRoot == NULL) || (!IsWindow(pciD->hwnd))) {
        return E_INVALIDARG;
    }


    //
    // Setup a new DuDropTarget on this Gadget / HWND.
    //

    if (!GetComManager()->Init(ComManager::sOLE)) {
        return E_OUTOFMEMORY;
    }

    hr = (pfnCS)(DUser::Gadget::ccSuper, s_hclSuper, pgad, pmicData);
    if (FAILED(hr)) {
        return hr;
    }

    SmObjectT<DuDropTarget, IDropTarget> * pdt = new SmObjectT<DuDropTarget, IDropTarget>;
    if (pdt == NULL) {
        return NULL;
    }

    hr = (pfnCS)(DUser::Gadget::ccSetThis, hclCur, pgad, pdt);
    if (FAILED(hr)) {
        return hr;
    }

    pdt->m_hwnd = pciD->hwnd;
    pdt->m_pgad = pgad;
    pdt->AddRef();

    hr = GetComManager()->RegisterDragDrop(pciD->hwnd, static_cast<IDropTarget *> (pdt));
    if (FAILED(hr)) {
        pdt->Release();
        return hr;
    }
    //CoLockObjectExternal(pdt, TRUE, FALSE);


    hr = pdt->Create(pgvRoot, s_pridListen, DuExtension::oUseExisting);
    if ((hr == DU_S_ALREADYEXISTS) || FAILED(hr)) {
        GetComManager()->RevokeDragDrop(pciD->hwnd);
        pdt->Release();
        return hr;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HCLASS CALLBACK
DuDropTarget::DemoteDropTarget(HCLASS hclCur, DUser::Gadget * pgad, void * pvData)
{
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);

    DuDropTargetObj * pc = reinterpret_cast<DuDropTargetObj *> (pvData);
    delete pc;

    return DuDropTargetObj::s_hclSuper;
}


/***************************************************************************\
*
* DuDropTarget::DragEnter
*
* DragEnter() is called by OLE when entering the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragEnter(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    if (pdoSrc == NULL) {
        return E_INVALIDARG;
    }

    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }


    //
    // Cache the DataObject.
    //

    SafeRelease(m_pdoSrc);
    if (pdoSrc != NULL) {
        pdoSrc->AddRef();
        m_pdoSrc = pdoSrc;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::DragOver
*
* DragOver() is called by OLE during the drag operation to give feedback 
* while inside the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragOver(
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::DragLeave
*
* DragLeave() is called by OLE when leaving the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragLeave()
{
    TargetLock tl;
    if (!tl.Lock(this, NULL)) {
        return S_OK;
    }

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::Drop
*
* Drop() is called by OLE when the user has dropped while inside DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::Drop(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    if (!HasTarget()) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;


    //
    // Update to get the latest Gadget information.
    //

    POINT ptClientPxl;
    HRESULT hr = xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
    if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
        return hr;
    }

    AssertMsg(HasTarget(), "Must have a target if UpdateTarget() succeeds");


    //
    // Now that the state has been updated, execute the actual drop.
    //

    POINTL ptDrop = { ptClientPxl.x, ptClientPxl.y };
    m_pdtCur->Drop(pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::xwDragScan
*
* xwDragScan() is called from the various IDropTarget methods to process
* a request coming from outside.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwDragScan(
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    POINT ptContainerPxl;
    RECT rcDesktopPxl;

    GetClientRect(m_hwnd, &rcDesktopPxl);
    ClientToScreen(m_hwnd, (LPPOINT) &(rcDesktopPxl.left));

    ptContainerPxl.x = ptDesktopPxl.x - rcDesktopPxl.left;
    ptContainerPxl.y = ptDesktopPxl.y - rcDesktopPxl.top;;

    return xwUpdateTarget(ptContainerPxl, pdwEffect, pptClientPxl);
}

    
/***************************************************************************\
*
* DuDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwUpdateTarget(
    IN  POINT ptContainerPxl,       // Cursor location in container
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    AssertMsg(HasSource(), "Only call when have valid data source");
    AssertWritePtr(pdwEffect);
    AssertWritePtr(pptClientPxl);

    m_ptLastContainerPxl = ptContainerPxl;

    //
    // Determine the Gadget that is currently at the drop location.  We use this
    // as a starting point.
    //

    Visual * pgvFound = NULL;
    m_pgvSubject->FindFromPoint(ptContainerPxl, GS_VISIBLE | GS_ENABLED, pptClientPxl, &pgvFound);
    if (pgvFound == NULL) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    return xwUpdateTarget(pgvFound, pdwEffect, pptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwUpdateTarget(
    IN  Visual * pgvFound,          // Visual Gadget getting Drop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    IN  POINT * pptClientPxl)       // Cursor location in client
{
    HRESULT hr = S_OK;


    //
    // Check if the drop Gadget has changed.
    //

    if ((pgvFound != NULL) && (pgvFound != m_pgvDrop)) {
        //
        // Ask the new Gadget if he wants to participate in Drag & Drop.
        //

        GMSG_QUERYDROPTARGET msg;
        ZeroMemory(&msg, sizeof(msg));
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = GM_QUERY;
        msg.nCode   = GQUERY_DROPTARGET;
        msg.hgadMsg = DUserCastHandle(pgvFound);

        static int s_cSend = 0;
        Trace("Send Query: %d to 0x%p\n", s_cSend++, pgvFound);

        Visual * pgvNewDrop;
        HRESULT hr = DUserSendEvent(&msg, SGM_FULL);
        if (SUCCEEDED(hr) && (hr != DU_S_NOTHANDLED)) {
            pgvNewDrop = Visual::Cast(msg.hgadDrop);
            if ((pgvNewDrop != NULL) && (msg.pdt != NULL)) {
                if (pgvNewDrop != pgvFound) {
                    //
                    // The message returned a different to handle the DnD request,
                    // so we need to re-adjust.  We know that this Gadget is enabled
                    // and visible since it is in our parent chain and we are already
                    // enabled and visible.
                    //

#if DBG
                    BOOL fChain = FALSE;
                    pgvNewDrop->IsParentChainStyle(GS_VISIBLE | GS_ENABLED, &fChain, 0);
                    if (!fChain) {
                        Trace("WARNING: DUser: DropTarget: Parent chain for 0x%p is not fully visible and enabled.\n", pgvNewDrop);
                    }
#endif

                    pgvFound->MapPoints(pgvNewDrop, pptClientPxl, 1);
                }
            }
        } else {
            pgvNewDrop  = NULL;
            msg.pdt     = NULL;
        }


        //
        // Notify the old Gadget that the Drag operation has left him.
        // Update to new state
        // Notify the new Gadget that the Drag operation has entered him.
        //

        if (m_pgvDrop != pgvNewDrop) {
            xwDragLeave();

            m_pgvDrop   = pgvNewDrop;
            m_pdtCur    = msg.pdt;

            hr = xwDragEnter(pptClientPxl, pdwEffect);
            if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
                goto Exit;
            }
        } else {
            SafeRelease(msg.pdt);
            *pdwEffect = DROPEFFECT_NONE;
        }
    }


    //
    // Update the DropTarget
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        hr = m_pdtCur->DragOver(m_grfLastKeyState, ptDrop, pdwEffect);
    }

Exit:
    AssertMsg(FAILED(hr) || 
            ((*pdwEffect == DROPEFFECT_NONE) && !HasTarget()) ||
            HasTarget(),
            "Check valid return state");

    return hr;
}


/***************************************************************************\
*
* DuDropTarget::xwDragEnter
*
* xwDragEnter() is called when entering a new Gadget during a DnD operation.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwDragEnter(
    IN OUT POINT * pptClientPxl,    // Client location (updated)
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    AssertMsg(HasSource(), "Only call when have valid data source");

    //
    // Notify the new Gadget that the drop has entered him.
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        HRESULT hr = m_pdtCur->DragEnter(m_pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::xwDragLeave
*
* xwDragLeave() is called when leaving a Gadget during a DnD operation.
*
\***************************************************************************/

void
DuDropTarget::xwDragLeave()
{
    if (HasTarget()) {
        m_pdtCur->DragLeave();
        m_pdtCur->Release();
        m_pdtCur = NULL;

        m_pgvDrop = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuDropTarget::ApiOnDestroySubject(DropTarget::OnDestroySubjectMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);
    
    if (IsWindow(m_hwnd)) {
        GetComManager()->RevokeDragDrop(m_hwnd);
    }

    //CoLockObjectExternal(pdt, FALSE, TRUE);
    DuExtension::DeleteHandle();

    return S_OK;
}

#endif

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\extension.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Extension.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuExtension
*
*****************************************************************************
\***************************************************************************/

static const GUID guidAysncDestroy      = { 0xbfe02331, 0xc17d, 0x45ea, { 0x96, 0x35, 0xa0, 0x7a, 0x90, 0x37, 0xfe, 0x34 } };   // {BFE02331-C17D-45ea-9635-A07A9037FE34}
MSGID       DuExtension::s_msgidAsyncDestroy = 0;

/***************************************************************************\
*
* DuExtension::~DuExtension
*
* ~DuExtension() checks that resources were properly cleaned up before the
* DuExtension was destroyed.
*
\***************************************************************************/

DuExtension::~DuExtension()
{
    //
    // Ensure proper destruction
    //

}


//------------------------------------------------------------------------------
HRESULT
DuExtension::InitClass()
{
    s_msgidAsyncDestroy = RegisterGadgetMessage(&guidAysncDestroy);
    return s_msgidAsyncDestroy != 0 ? S_OK : (HRESULT) GetLastError();
}


/***************************************************************************\
*
* DuExtension::Create
*
* Create() initializes a new DuExtension and attaches it to the subject Gadget
* being modified.
*
\***************************************************************************/

HRESULT
DuExtension::Create(
    IN  Visual * pgvSubject,            // Gadget being "extended"
    IN  PRID pridExtension,             // Short ID for DuExtension
    IN  UINT nOptions)                  // Options
{
    AssertMsg(pridExtension > 0, "Must have valid PRID");


    //
    // Do not allow attaching a DuExtension to a Gadget that has already started 
    // the destruction process.
    //

    HGADGET hgadSubject = DUserCastHandle(pgvSubject);

    BOOL fStartDelete;
    if ((!IsStartDelete(hgadSubject, &fStartDelete)) || fStartDelete) {
        return DU_E_STARTDESTROY;
    }


    //
    // Setup options
    //

    m_fAsyncDestroy = TestFlag(nOptions, oAsyncDestroy);


    //
    // Determine if this DuExtension is already attached to the Gadget being 
    // extended.
    //

    DuExtension * pbExist;
    if (SUCCEEDED(pgvSubject->GetProperty(pridExtension, (void **) &pbExist))) {
        AssertMsg(pbExist != NULL, "Existing Extension must not be NULL");
        if (TestFlag(nOptions, oUseExisting)) {
            return DU_S_ALREADYEXISTS;
        } else {
            //
            // Already attached, but can't use the existing one.  We need to
            // remove the existing DuExtension before attaching the new one.  
            // After calling RemoveExisting(), the DuExtension should no longer 
            // be attached to the Gadget.
            //

            pbExist->GetStub()->OnRemoveExisting();
            Assert(FAILED(pgvSubject->GetProperty(pridExtension, (void **) &pbExist)));
        }
    }


    //
    // Setup a listener to be notifyed when the RootGadget is destroyed.
    //

    HRESULT hr      = S_OK;
    m_pgvSubject    = pgvSubject;
    m_pridListen    = pridExtension;

    if (FAILED(pgvSubject->SetProperty(pridExtension, this)) || 
            FAILED(pgvSubject->AddHandlerG(GM_DESTROY, GetStub()))) {

        hr = E_OUTOFMEMORY;
        goto Error;
    }


    //
    // Successfully created the DuExtension
    //

    return S_OK;

Error:
    return hr;
}


/***************************************************************************\
*
* DuExtension::Destroy
*
* Destroy() is called from the derived class to cleanup resources associated
* with the DuExtension.
*
\***************************************************************************/

void
DuExtension::Destroy()
{
    //
    // Since the DuExtension is being destroyed, need to ensure that it is no 
    // longer "attached" to the Gadget being extended
    //

    if ((m_pridListen != 0) && (m_pgvSubject != NULL)) {
        DuExtension * pb;
        if (SUCCEEDED(m_pgvSubject->GetProperty(m_pridListen, (void **) &pb))) {
            if (pb == this) {
                m_pgvSubject->RemoveProperty(m_pridListen);
            }
        }
    }

    Delete();
}


/***************************************************************************\
*
* DuExtension::DeleteHandle
*
* DeleteHandle() starts the destruction process for the DuExtension.
*
\***************************************************************************/

void
DuExtension::DeleteHandle()
{
    Delete();
}


//------------------------------------------------------------------------------
HRESULT
DuExtension::ApiOnEvent(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        if (m_fAsyncDestroy && (pmsg->nMsg == s_msgidAsyncDestroy)) {
            GetStub()->OnAsyncDestroy();
            return DU_S_PARTIAL;
        }
        break;

    case GMF_EVENT:
        if (pmsg->nMsg == GM_DESTROY) {
            if (((GMSG_DESTROY *) pmsg)->nCode == GDESTROY_FINAL) {
                GetStub()->OnDestroySubject();
                return DU_S_PARTIAL;
            }
        }
        break;
    }

    return SListener::ApiOnEvent(pmsg);
}


/***************************************************************************\
*
* DuExtension::ApiOnRemoveExisting
*
* ApiOnRemoveExisting() is called when creating a new DuExtension to remove 
* an existing DuExtension already attached to the subject Gadget.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnRemoveExisting(Extension::OnRemoveExistingMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::ApiOnDestroySubject
*
* ApiOnDestroySubject() notifies the derived DuExtension that the subject 
* Gadget being modified has been destroyed.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnDestroySubject(Extension::OnDestroySubjectMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::ApiOnAsyncDestroy
*
* ApiOnAsyncDestroy() is called when the DuExtension receives an asynchronous
* destruction message that was previously posted.  This provides the derived
* DuExtension an opportunity to start the destruction process without being
* nested several levels.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnAsyncDestroy(Extension::OnAsyncDestroyMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::PostAsyncDestroy
*
* PostAsyncDestroy() queues an asynchronous destruction message.  This 
* provides the derived DuExtension an opportunity to start the destruction 
* process without being nested several levels.
*
\***************************************************************************/

void
DuExtension::PostAsyncDestroy()
{
    AssertMsg(m_fAsyncDestroy, 
            "Must create DuExtension with oAsyncDestroy if want to destroy asynchronously");
    Assert(s_msgidAsyncDestroy != 0);
    EventMsg msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.hgadMsg = GetHandle();
    msg.nMsg    = s_msgidAsyncDestroy;

    DUserPostEvent(&msg, 0);
}


/***************************************************************************\
*
* DuExtension::GetExtension
*
* GetExtension() retrieves the DuExtension of a specific type currently 
* attached to the subject Gadget.
*
\***************************************************************************/

DuExtension *
DuExtension::GetExtension(Visual * pgvSubject, PRID prid)
{
    DuExtension * pbExist;
    if (SUCCEEDED(pgvSubject->GetProperty(prid, (void **) &pbExist))) {
        AssertMsg(pbExist != NULL, "Attached DuExtension must be valid");
        return pbExist;
    }
    
    return NULL;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\extension.inl ===
#if !defined(CTRL__Extension_inl__INCLUDED)
#define CTRL__Extension_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
inline DuExtension::DuExtension()
{

}

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Extension_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\flow.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Flow.h"

#if ENABLE_MSGTABLE_API

PRID        DuAlphaFlow::s_pridAlpha   = 0;
PRID        DuScaleFlow::s_pridScale   = 0;
PRID        DuRectFlow::s_pridRect     = 0;
PRID        DuRotateFlow::s_pridRotate = 0;

static const GUID guidAlphaFlow     = { 0x41a2e2f2, 0xf262, 0x41ae, { 0x89, 0xda, 0xb7, 0x9c, 0x8f, 0xf5, 0x94, 0xbb } };   // {41A2E2F2-F262-41ae-89DA-B79C8FF594BB}
static const GUID guidScaleFlow     = { 0xa5b1df84, 0xb9c0, 0x4305, { 0xb9, 0x3a, 0x5b, 0x80, 0x31, 0x86, 0x70, 0x69 } };   // {A5B1DF84-B9C0-4305-B93A-5B8031867069}
static const GUID guidRectFlow      = { 0x8e41c241, 0x3cdf, 0x432e, { 0xa1, 0xae, 0xf, 0x7b, 0x59, 0xdc, 0x82, 0xb } };     // {8E41C241-3CDF-432e-A1AE-0F7B59DC820B}
static const GUID guidRotateFlow    = { 0x78f16dd5, 0xa198, 0x4cd2, { 0xb1, 0x78, 0x31, 0x61, 0x3e, 0x32, 0x12, 0x54 } };   // {78F16DD5-A198-4cd2-B178-31613E321254}

/***************************************************************************\
*****************************************************************************
*
* Public API
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
PRID
DUserGetAlphaPRID()
{
    return DuAlphaFlow::s_pridAlpha;
}


//------------------------------------------------------------------------------
PRID
DUserGetRectPRID()
{
    return DuRectFlow::s_pridRect;
}


//------------------------------------------------------------------------------
PRID
DUserGetRotatePRID()
{
    return DuRotateFlow::s_pridRotate;
}


//------------------------------------------------------------------------------
PRID
DUserGetScalePRID()
{
    return DuScaleFlow::s_pridScale;
}


/***************************************************************************\
*****************************************************************************
*
* class DuFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    PromptInvalid("Derived Flow must override");

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    PromptInvalid("Derived Flow must override");

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    return E_NOTIMPL;
}


/***************************************************************************\
*****************************************************************************
*
* class DuAlphaFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::InitClass()
{
    s_pridAlpha = RegisterGadgetProperty(&guidAlphaFlow);
    return s_pridAlpha != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        UINT nStyle = 0;
        pgvSubject->GetStyle(&nStyle);

        if (!TestFlag(nStyle, GS_OPAQUE)) {
            PromptInvalid("AlphaFlow requires GS_OPAQUE");
            return E_INVALIDARG;
        }

        float flAlpha = 1.0f;
        if (TestFlag(nStyle, GS_BUFFERED)) {
            //
            // Gadget is already buffered, so use it current alpha value.
            //

            BUFFER_INFO bi;
            ZeroMemory(&bi, sizeof(bi));
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            HRESULT hr  = pgvSubject->GetBufferInfo(&bi);
            if (SUCCEEDED(hr)) {
                flAlpha = ((float) bi.bAlpha) / 255.0f;
            }
        }

        m_flStart   = flAlpha;
        m_flEnd     = flAlpha;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        m_flStart   = 1.0f;
        m_flEnd     = 1.0f;
    }

#if DEBUG_TRACECREATION
    Trace("DuAlphaFlow 0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(AlphaFlow::AlphaKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    AlphaFlow::AlphaKeyFrame * pkfA = static_cast<AlphaFlow::AlphaKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfA->flAlpha = m_flStart;
        return S_OK;

    case Flow::tEnd:
        pkfA->flAlpha = m_flEnd;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(AlphaFlow::AlphaKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const AlphaFlow::AlphaKeyFrame * pkfA = static_cast<const AlphaFlow::AlphaKeyFrame *>(pmsg->pkf);

    float flAlpha = BoxAlpha(pkfA->flAlpha);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flStart = flAlpha;
        return S_OK;

    case Flow::tEnd:
        m_flEnd = flAlpha;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT        
DuAlphaFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    float flResult = 0.0f;
    pmsg->pipol->Compute(pmsg->flProgress, m_flStart, m_flEnd, &flResult);
    SetVisualAlpha(pmsg->pgvSubject, flResult);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    SetVisualAlpha(pmsg->pgvSubject, m_flStart);

    return S_OK;
}


//------------------------------------------------------------------------------
void        
DuAlphaFlow::SetVisualAlpha(Visual * pgvSubject, float flAlpha)
{
    AssertMsg((flAlpha <= 1.0f) && (flAlpha >= 0.0f), "Ensure valid alpha");


    //
    // Setup Buffer state
    //

    BOOL fNewBuffered   = (flAlpha * 255.0f) <= 245;

    UINT nStyle = 0;
    VerifyHR(pgvSubject->GetStyle(&nStyle));
    BOOL fOldBuffered   = TestFlag(nStyle, GS_BUFFERED);

    if ((!fOldBuffered) != (!fNewBuffered)) {
        pgvSubject->SetStyle(fNewBuffered ? GS_BUFFERED : 0, GS_BUFFERED);
    }


    //
    // Set Alpha level
    //

    if (fNewBuffered) {
        BYTE bAlpha;
        if (flAlpha < 0.0f) {
            bAlpha = (BYTE) 0;
        } else if (flAlpha > 1.0f) {
            bAlpha = (BYTE) 255;
        } else {
            bAlpha = (BYTE) (flAlpha * 255.0f);
        }

        BUFFER_INFO bi;
        bi.cbSize   = sizeof(bi);
        bi.nMask    = GBIM_ALPHA;
        bi.bAlpha   = bAlpha;

        pgvSubject->SetBufferInfo(&bi);
    }
    pgvSubject->Invalidate();
}


/***************************************************************************\
*****************************************************************************
*
* class DuRectFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuRectFlow::InitClass()
{
    s_pridRect = RegisterGadgetProperty(&guidRectFlow);
    return s_pridRect != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        RECT rcGadget;
        HRESULT hr = pgvSubject->GetRect(SGR_PARENT, &rcGadget);
        if (FAILED(hr)) {
            return hr;
        }

        m_ptStart.x     = rcGadget.left;
        m_ptStart.y     = rcGadget.top;
        m_sizeStart.cx  = rcGadget.right - rcGadget.left;
        m_sizeStart.cy  = rcGadget.bottom - rcGadget.top;

        m_ptEnd         = m_ptStart;
        m_sizeEnd       = m_sizeStart;
        m_nChangeFlags  = 0;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        AssertMsg((m_ptEnd.x == 0) && (m_ptEnd.y == 0) && 
                (m_sizeEnd.cx == 0) && (m_sizeEnd.cy == 0) && (m_nChangeFlags == 0),
                "Ensure zero-init");
    }

#if DEBUG_TRACECREATION
    Trace("DuRectFlow  0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RectFlow::RectKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    RectFlow::RectKeyFrame * pkfR = static_cast<RectFlow::RectKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfR->rcPxl.left    = m_ptStart.x;
        pkfR->rcPxl.top     = m_ptStart.y;
        pkfR->rcPxl.right   = m_ptStart.x + m_sizeStart.cx;
        pkfR->rcPxl.bottom  = m_ptStart.y + m_sizeStart.cy;
        pkfR->nChangeFlags  = m_nChangeFlags;
        return S_OK;

    case Flow::tEnd:
        pkfR->rcPxl.left    = m_ptEnd.x;
        pkfR->rcPxl.top     = m_ptEnd.y;
        pkfR->rcPxl.right   = m_ptEnd.x + m_sizeEnd.cx;
        pkfR->rcPxl.bottom  = m_ptEnd.y + m_sizeEnd.cy;
        pkfR->nChangeFlags  = 0;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RectFlow::RectKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const RectFlow::RectKeyFrame * pkfR = static_cast<const RectFlow::RectKeyFrame *>(pmsg->pkf);
    if ((pkfR->nChangeFlags & SGR_VALID_SET) != pkfR->nChangeFlags) {
        PromptInvalid("Invalid change flags");
        return E_INVALIDARG;
    }

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_ptStart.x     = pkfR->rcPxl.left;
        m_ptStart.y     = pkfR->rcPxl.top;
        m_sizeStart.cx  = pkfR->rcPxl.right - pkfR->rcPxl.left;
        m_sizeStart.cy  = pkfR->rcPxl.bottom - pkfR->rcPxl.top;
        m_nChangeFlags  = pkfR->nChangeFlags;
        return S_OK;

    case Flow::tEnd:
        m_ptEnd.x       = pkfR->rcPxl.left;
        m_ptEnd.y       = pkfR->rcPxl.top;
        m_sizeEnd.cx    = pkfR->rcPxl.right - pkfR->rcPxl.left;
        m_sizeEnd.cy    = pkfR->rcPxl.bottom - pkfR->rcPxl.top;
        m_nChangeFlags  = pkfR->nChangeFlags;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    if (m_nChangeFlags != 0) {
        pmsg->pgvSubject->SetRect(m_nChangeFlags, m_ptStart.x, m_ptStart.y, m_sizeStart.cx, m_sizeStart.cy);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    if (m_nChangeFlags != 0) {
        POINT ptNew;
        SIZE sizeNew;

        ptNew.x     = Compute(pmsg->pipol, pmsg->flProgress, m_ptStart.x, m_ptEnd.x);
        ptNew.y     = Compute(pmsg->pipol, pmsg->flProgress, m_ptStart.y, m_ptEnd.y);
        sizeNew.cx  = Compute(pmsg->pipol, pmsg->flProgress, m_sizeStart.cx, m_sizeEnd.cx);
        sizeNew.cy  = Compute(pmsg->pipol, pmsg->flProgress, m_sizeStart.cy, m_sizeEnd.cy);

        pmsg->pgvSubject->SetRect(m_nChangeFlags, ptNew.x, ptNew.y, sizeNew.cx, sizeNew.cy);
    }

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class DuRotateFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::InitClass()
{
    s_pridRotate = RegisterGadgetProperty(&guidRotateFlow);
    return s_pridRotate != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        float flRotation;
        HRESULT hr = pgvSubject->GetRotation(&flRotation);
        if (FAILED(hr)) {
            return hr;
        }

        m_flRawStart    = flRotation;
        m_flRawEnd      = flRotation;
        m_flActualStart = flRotation;
        m_flActualEnd   = flRotation;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        AssertMsg((m_flRawStart == 0.0f) && (m_flRawEnd == 0.0f), 
                "Ensure zero-init");
    }

    m_nDir          = RotateFlow::dMin;

    MarkDirty();

#if DEBUG_TRACECREATION
    Trace("DuRotateFlow  0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RotateFlow::RotateKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    RotateFlow::RotateKeyFrame * pkfR = static_cast<RotateFlow::RotateKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfR->flRotation = m_flRawStart;
        pkfR->nDir = m_nDir;
        return S_OK;

    case Flow::tEnd:
        pkfR->flRotation = m_flRawEnd;
        pkfR->nDir = m_nDir;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RotateFlow::RotateKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const RotateFlow::RotateKeyFrame * pkfR = static_cast<const RotateFlow::RotateKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flRawStart = pkfR->flRotation;
        m_nDir = pkfR->nDir;
        MarkDirty();
        return S_OK;

    case Flow::tEnd:
        m_flRawEnd = pkfR->flRotation;
        m_nDir = pkfR->nDir;
        MarkDirty();
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    ComputeAngles();

    pmsg->pgvSubject->SetRotation(m_flActualStart);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    ComputeAngles();

    pmsg->pgvSubject->SetRotation(Compute(pmsg->pipol, pmsg->flProgress, m_flActualStart, m_flActualEnd));

    return S_OK;
}


/***************************************************************************\
*
* DuRotateFlow::ComputeAngles
*
* ComputeAngles() updates the angles to conform to the desired direction.
* This is lazily computed, allowing the application to specify the angles
* and direction in any order, then snapping the angles when actually needed.
*
\***************************************************************************/

void
DuRotateFlow::ComputeAngles()
{
    if (!m_fDirty) {
        return;
    }


    //
    // Adjust the starting and ending angles so that we "move" in the correct
    // direction.  We do this by adding or subtracting full rotations depending
    // on the "move" we are trying to accomplish.
    //

    m_flActualStart = m_flRawStart;
    m_flActualEnd = m_flRawEnd;

    switch (m_nDir)
    {
    case RotateFlow::dShort:
        if (m_flActualStart < m_flActualEnd) {
            while ((m_flActualEnd - m_flActualStart) > (float) PI) {
                m_flActualStart += (float) (2 * PI);
            }
        } else {
            while ((m_flActualStart - m_flActualEnd) > (float) PI) {
                m_flActualStart -= (float) (2 * PI);
            }
        }
        break;

    case RotateFlow::dLong:
        if (m_flActualStart < m_flActualEnd) {
            while ((m_flActualStart - m_flActualEnd) < (float) PI) {
                m_flActualEnd -= (float) (2 * PI);
            }
        } else {
            while ((m_flActualEnd - m_flActualStart) < (float) PI) {
                m_flActualEnd += (float) (2 * PI);
            }
        }
        break;

    case RotateFlow::dCW:
        while (m_flActualStart > m_flActualEnd) {
            m_flActualEnd += (float) (2 * PI);
        }
        break;

    case RotateFlow::dCCW:
        while (m_flActualStart < m_flActualEnd) {
            m_flActualStart += (float) (2 * PI);
        }
        break;
    }

    m_fDirty = FALSE;
}


/***************************************************************************\
*****************************************************************************
*
* class DuScaleFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::InitClass()
{
    s_pridScale = RegisterGadgetProperty(&guidScaleFlow);
    return s_pridScale != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        float flX, flY;
        HRESULT hr = pgvSubject->GetScale(&flX, &flY);
        if (FAILED(hr)) {
            return hr;
        }

        m_flStart   = flX;
        m_flEnd     = flX;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        m_flStart   = 1.0f;
        m_flEnd     = 1.0f;
    }


#if DEBUG_TRACECREATION
    Trace("DuScaleFlow 0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(ScaleFlow::ScaleKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    ScaleFlow::ScaleKeyFrame * pkfS = static_cast<ScaleFlow::ScaleKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfS->flScale = m_flStart;
        return S_OK;

    case Flow::tEnd:
        pkfS->flScale = m_flEnd;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(ScaleFlow::ScaleKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const ScaleFlow::ScaleKeyFrame * pkfS = static_cast<const ScaleFlow::ScaleKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flStart = pkfS->flScale;
        return S_OK;

    case Flow::tEnd:
        m_flEnd = pkfS->flScale;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    pmsg->pgvSubject->SetScale(m_flStart, m_flStart);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    float flx   = Compute(pmsg->pipol, pmsg->flProgress, m_flStart, m_flEnd);
    float fly   = flx;
    pmsg->pgvSubject->SetScale(flx, fly);

    return S_OK;
}


#else // ENABLE_MSGTABLE_API


/***************************************************************************\
*****************************************************************************
*
* Public API
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
PRID
DUserGetAlphaPRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetRectPRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetRotatePRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetScalePRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\flow.h ===
#if !defined(CTRL__Flow_h__INCLUDED)
#define CTRL__Flow_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuFlow : 
        public FlowImpl<DuFlow, DUser::SGadget>
{
// Construction
public:
    inline  DuFlow();

// Public API
public:
    dapi    HRESULT     ApiAddRef(Flow::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Flow::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = 0; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementation
protected:
    inline  void        AddRef();
    inline  void        Release(); 

// Data
protected:
            UINT        m_cRef;
};


//------------------------------------------------------------------------------
class DuAlphaFlow :
        public AlphaFlowImpl<DuAlphaFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridAlpha; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:
            void        SetVisualAlpha(Visual * pgvSubject, float flAlpha);
    inline  float       BoxAlpha(float flAlpha) const;

// Data
public:
    static  PRID        s_pridAlpha;
protected:
            float       m_flStart;
            float       m_flEnd;
};


//------------------------------------------------------------------------------
class DuRectFlow : 
        public RectFlowImpl<DuRectFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridRect; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:

// Data
public:
    static  PRID        s_pridRect;
protected:
            POINT       m_ptStart;
            POINT       m_ptEnd;
            SIZE        m_sizeStart;
            SIZE        m_sizeEnd;
            UINT        m_nChangeFlags;
};


//------------------------------------------------------------------------------
class DuRotateFlow : 
        public RotateFlowImpl<DuRotateFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridRotate; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:
            void        ComputeAngles();
    inline  void        MarkDirty();

// Data
public:
    static  PRID        s_pridRotate;
protected:
            float       m_flRawStart;   // User specified starting angle
            float       m_flRawEnd;
            float       m_flActualStart;// Actually computed starting angle
            float       m_flActualEnd;
            RotateFlow::EDirection
                        m_nDir;
            BOOL        m_fDirty;       // State has changed since last updated
};


//------------------------------------------------------------------------------
class DuScaleFlow : 
        public ScaleFlowImpl<DuScaleFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridScale; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:

// Data
public:
    static  PRID        s_pridScale;
protected:
            float       m_flStart;
            float       m_flEnd;
};


#endif // ENABLE_MSGTABLE_API

#include "Flow.inl"

#endif // CTRL__Flow_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\gdihelp.h ===
#if !defined(CTRL__GdiHelp_h__INCLUDED)
#define CTRL__GdiHelp_h__INCLUDED

HFONT       GdBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice);
COLORREF    GdGetColor(HBITMAP hbmp, POINT * pptPxl);

#endif // CTRL__GdiHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\init.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Init.h"

#if ENABLE_MSGTABLE_API

#include "Extension.h"
#include "DragDrop.h"
#include "Animation.h"
#include "Flow.h"
#include "Sequence.h"
#include "Interpolation.h"

IMPLEMENT_GUTS_Extension(DuExtension, SListener);
IMPLEMENT_GUTS_DropTarget(DuDropTarget, DuExtension);

IMPLEMENT_GUTS_Animation(DuAnimation, DuExtension);
IMPLEMENT_GUTS_Flow(DuFlow, DUser::SGadget);
IMPLEMENT_GUTS_AlphaFlow(DuAlphaFlow, DuFlow);
IMPLEMENT_GUTS_RectFlow(DuRectFlow, DuFlow);
IMPLEMENT_GUTS_RotateFlow(DuRotateFlow, DuFlow);
IMPLEMENT_GUTS_ScaleFlow(DuScaleFlow, DuFlow);
IMPLEMENT_GUTS_Sequence(DuSequence, SListener);

IMPLEMENT_GUTS_Interpolation(DuInterpolation, DUser::SGadget);
IMPLEMENT_GUTS_LinearInterpolation(DuLinearInterpolation, DuInterpolation);
IMPLEMENT_GUTS_LogInterpolation(DuLogInterpolation, DuInterpolation);
IMPLEMENT_GUTS_ExpInterpolation(DuExpInterpolation, DuInterpolation);
IMPLEMENT_GUTS_SCurveInterpolation(DuSCurveInterpolation, DuInterpolation);

#endif // ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT InitCtrl()
{
#if ENABLE_MSGTABLE_API

    if ((!DuExtension::InitExtension()) ||
        (!DuDropTarget::InitDropTarget()) ||
        (!DuAnimation::InitAnimation()) ||
        (!DuFlow::InitFlow()) ||
        (!DuAlphaFlow::InitAlphaFlow()) ||
        (!DuRectFlow::InitRectFlow()) ||
        (!DuRotateFlow::InitRotateFlow()) ||
        (!DuScaleFlow::InitScaleFlow()) ||
        (!DuSequence::InitSequence()) ||
        (!DuInterpolation::InitInterpolation()) ||
        (!DuLinearInterpolation::InitLinearInterpolation()) ||
        (!DuLogInterpolation::InitLogInterpolation()) ||
        (!DuExpInterpolation::InitExpInterpolation()) ||
        (!DuSCurveInterpolation::InitSCurveInterpolation())) {
        return E_OUTOFMEMORY;
    }

#endif // ENABLE_MSGTABLE_API

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\interpolation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Interpolation.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\init.h ===
#if !defined(CTRL__Init_h__INCLUDED)
#define CTRL__Init_h__INCLUDED
#pragma once

HRESULT InitCtrl();

#endif // CTRL__Init_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\flow.inl ===
#if !defined(CTRL__Flow_inl__INCLUDED)
#define CTRL__Flow_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API


/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline int
Round(float f)
{
    return (int) (f + 0.5);
}


//------------------------------------------------------------------------------
inline int     
Compute(Interpolation * pipol, float flProgress, int nStart, int nEnd)
{
    float flResult = 0.0f;
    VerifyHR(pipol->Compute(flProgress, (float) nStart, (float) nEnd, &flResult));
    return Round(flResult);
}


//------------------------------------------------------------------------------
inline float
Compute(Interpolation * pipol, float flProgress, float flStart, float flEnd)
{
    float flResult = 0.0f;
    VerifyHR(pipol->Compute(flProgress, flStart, flEnd, &flResult));
    return flResult;
}


/***************************************************************************\
*****************************************************************************
*
* class DuFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuFlow::DuFlow()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline void
DuFlow::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuFlow::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


/***************************************************************************\
*****************************************************************************
*
* class DuAlphaFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline float
DuAlphaFlow::BoxAlpha(float flAlpha) const
{
    if (flAlpha < 0.0f) {
        return 0.0f;
    } else if (flAlpha > 1.0f) {
        return 1.0f;
    } else {
        return flAlpha;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuScaleFlow
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*****************************************************************************
*
* class DuRectFlow
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*****************************************************************************
*
* class DuRotateFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
DuRotateFlow::MarkDirty()
{
    m_fDirty = TRUE;
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Flow_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\gdihelp.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "GdiHelp.h"

/***************************************************************************\
*
* GdBuildFont (API)
*
* GdBuildFont() is a helper function that assists in making fonts easier to
* create.
*
* This function is DESIGNED to work with Gadgets.  When FS_COMPATIBLE is not
* set, the font size will always be the same, regardless of when large-fonts
* is enabled or not.  When FS_COMPATIBLE is set, the font size will use the
* MSDN documented mechanism to compute the font size, taking large-fonts 
* into account.  
* 
* The problem with FS_COMPATIBLE is that the font gets larger, but nothing 
* else does.  DLU's try to fix this, but they have a lot of problems.
* Gadgets solve this by using GDI's World Transforms and having complete
* scaling of all drawing.
*
\***************************************************************************/

HFONT
GdBuildFont(
    IN  LPCWSTR pszName,            // Name of font
    IN  int idxDeciSize,            // Size in decipoints
    IN  DWORD nFlags,               // Font creation flags
    IN  HDC hdcDevice)              // Optional device (Display if NULL)
{
    LOGFONTW lf;

    int nLogPixelsY;
    if (hdcDevice != NULL) {
        nLogPixelsY = GetDeviceCaps(hdcDevice, LOGPIXELSY);
    } else if (TestFlag(nFlags, FS_COMPATIBLE)) {
        HDC hdcDesktop  = GetGdiCache()->GetTempDC();
        if (hdcDesktop == NULL) {
            return NULL;
        }

        nLogPixelsY = GetDeviceCaps(hdcDesktop, LOGPIXELSY);
        GetGdiCache()->ReleaseTempDC(hdcDesktop);
    } else {
        nLogPixelsY = 96;  // Hard code for normal fonts
    }

    ZeroMemory(&lf, sizeof(LOGFONT));

    wcscpy(lf.lfFaceName, pszName);
    lf.lfHeight         = -MulDiv(idxDeciSize, nLogPixelsY, 720);
    lf.lfWeight         = nFlags & FS_BOLD ? FW_BOLD : FW_NORMAL;
    lf.lfItalic         = (nFlags & FS_ITALIC) != 0;
    lf.lfUnderline      = (nFlags & FS_UNDERLINE) != 0;
    lf.lfStrikeOut      = (nFlags & FS_STRIKEOUT) != 0;
    lf.lfCharSet        = DEFAULT_CHARSET;
    lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lf.lfQuality        = ANTIALIASED_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;

    return OS()->CreateFontIndirect(&lf);
}


/***************************************************************************\
*
* GdGetColor
*
* GdGetColor gets the color of a pixel at the specified point in the bitmap.
* This utility function is designed to help when determining the transparent
* color of a bitmap.
*
\***************************************************************************/

COLORREF    
GdGetColor(HBITMAP hbmp, POINT * pptPxl)
{
    POINT ptTest;
    if (pptPxl != NULL) {
        ptTest = *pptPxl;
    } else {
        ptTest.x = 0;
        ptTest.y = 0;
    }


    HDC hdcBitmap   = GetGdiCache()->GetCompatibleDC();
    HBITMAP hbmpOld = (HBITMAP) SelectObject(hdcBitmap, hbmp);
    COLORREF crTr   = GetPixel(hdcBitmap, ptTest.x, ptTest.y);
    SelectObject(hdcBitmap, hbmpOld);
    GetGdiCache()->ReleaseCompatibleDC(hdcBitmap);

    return crTr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\interpolation.h ===
#if !defined(CTRL__Interpolation_h__INCLUDED)
#define CTRL__Interpolation_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuInterpolation :
        public InterpolationImpl<DuInterpolation, DUser::SGadget>
{
// Operations
public:
    inline DuInterpolation()
    {
        m_cRef = 1;
    }


    dapi HRESULT ApiAddRef(Interpolation::AddRefMsg *)
    {
        m_cRef++;
        return S_OK;
    }


    dapi HRESULT ApiRelease(Interpolation::ReleaseMsg *)
    {
        if (--m_cRef == 0) {
            DeleteHandle(GetHandle());
        }
        return S_OK;
    }


    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        pmsg->flResult = 0.0f;
        return S_OK;
    }

// Data
protected:
            ULONG       m_cRef;
};


/***************************************************************************\
*****************************************************************************
*
* class DuLinearInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuLinearInterpolation :
        public LinearInterpolationImpl<DuLinearInterpolation, DuInterpolation>
{
// Operations
public:
    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        pmsg->flResult = (1.0f - pmsg->flProgress) * pmsg->flStart + pmsg->flProgress * pmsg->flEnd;
        
        return S_OK;
    }
};

        
/***************************************************************************\
*****************************************************************************
*
* class DuLogInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuLogInterpolation :
        public LogInterpolationImpl<DuLogInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuLogInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        float flMax = (float) log10(m_flScale * 9.0f + 1.0f);
        float flT   = (float) log10(pmsg->flProgress * m_flScale * 9.0f + 1.0f) / flMax;
        pmsg->flResult = (1.0f - flT) * pmsg->flStart + flT * pmsg->flEnd;
        
        return S_OK;
    }

    dapi HRESULT ApiSetScale(LogInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;
        
        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};


/***************************************************************************\
*****************************************************************************
*
* class DuExpInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuExpInterpolation :
        public ExpInterpolationImpl<DuExpInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuExpInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        double dflProgress  = pmsg->flProgress;
        double dflStart     = pmsg->flStart;
        double dflEnd       = pmsg->flEnd;
        double dflScale     = m_flScale;

        double dflMax = (((10.0 * dflScale) - 1.0) / 9.0);
        double dflT   = (((pow(10.0 * dflScale, dflProgress) - 1.0) / 9.0) / dflMax);
        pmsg->flResult = (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);

        return S_OK;
    }

    dapi HRESULT ApiSetScale(ExpInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;

        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};

        
/***************************************************************************\
*****************************************************************************
*
* class DuSCurveInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuSCurveInterpolation :
        public SCurveInterpolationImpl<DuSCurveInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuSCurveInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        //
        // Slow - fast - slow
        //

        double dflProgress  = pmsg->flProgress;
        double dflStart     = pmsg->flStart;
        double dflEnd       = pmsg->flEnd;
        double dflScale     = m_flScale;
        double dflMax;
        double dflT;

        if (dflProgress < 0.5) {
            double dflPartProgress = dflProgress * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        } else {
            double dflPartProgress = (1.0 - dflProgress) * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = 1.0 - ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        }

        pmsg->flResult = (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);

        return S_OK;
    }

    dapi HRESULT ApiSetScale(SCurveInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;

        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Interpolation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldanimation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldAnimation.h"

PRID        OldAlphaAnimation::s_pridAlpha   = 0;
PRID        OldScaleAnimation::s_pridScale   = 0;
PRID        OldRectAnimation::s_pridRect     = 0;
PRID        OldRotateAnimation::s_pridRotate = 0;

static const GUID guidAlphaAnimation    = { 0x41a2e2f2, 0xf262, 0x41ae, { 0x89, 0xda, 0xb7, 0x9c, 0x8f, 0xf5, 0x94, 0xbb } };   // {41A2E2F2-F262-41ae-89DA-B79C8FF594BB}
static const GUID guidScaleAnimation    = { 0xa5b1df84, 0xb9c0, 0x4305, { 0xb9, 0x3a, 0x5b, 0x80, 0x31, 0x86, 0x70, 0x69 } };   // {A5B1DF84-B9C0-4305-B93A-5B8031867069}
static const GUID guidRectAnimation     = { 0x8e41c241, 0x3cdf, 0x432e, { 0xa1, 0xae, 0xf, 0x7b, 0x59, 0xdc, 0x82, 0xb } };     // {8E41C241-3CDF-432e-A1AE-0F7B59DC820B}
static const GUID guidRotateAnimation   = { 0x78f16dd5, 0xa198, 0x4cd2, { 0xb1, 0x78, 0x31, 0x61, 0x3e, 0x32, 0x12, 0x54 } };   // {78F16DD5-A198-4cd2-B178-31613E321254}


const IID * OldAlphaAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldScaleAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldRectAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldRotateAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};


/***************************************************************************\
*****************************************************************************
*
* class OldAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldAnimation::~OldAnimation()
{
#if DEBUG_TRACECREATION
    Trace("STOP  Animation  0x%p    @ %d  (%d frames)\n", this, GetTickCount(), m_DEBUG_cUpdates);
#endif // DEBUG_TRACECREATION


    //
    // Ensure proper destruction
    //

    AssertMsg(m_hact == NULL, "Action should already be destroyed");
}


//------------------------------------------------------------------------------
HRESULT
OldAnimation::Create(
    IN  const GUID * pguid, 
    IN OUT PRID * pprid, 
    IN  GANI_DESC * pDesc)              // Animation information
{
    if (pDesc->pipol != NULL) {
        pDesc->pipol->AddRef();
        m_pipol = pDesc->pipol;
    }

    if (pDesc->pcb != NULL) {
        pDesc->pcb->AddRef();
        m_pcb = pDesc->pcb;
    }

    GMA_ACTION gma;
    ZeroMemory(&gma, sizeof(gma));
    gma.cbSize      = sizeof(gma);
    gma.flDelay     = pDesc->act.flDelay;
    gma.flDuration  = pDesc->act.flDuration;
    gma.flPeriod    = pDesc->act.flPeriod;
    gma.cRepeat     = pDesc->act.cRepeat;
    gma.dwPause     = pDesc->act.dwPause;
    gma.pfnProc     = RawActionProc;
    gma.pvData      = this;

    m_hact = CreateAction(&gma);
    if (m_hact == NULL) {
        return (HRESULT) GetLastError();
    }

    HRESULT hr = OldExtension::Create(pDesc->hgadChange, pguid, pprid, OldExtension::oAsyncDestroy);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
void
OldAnimation::Destroy(BOOL fFinal)
{
    //
    // Mark that we have already started the destruction process and don't need
    // to start again.  We only want to post the destruction message once.
    //

    if (m_fStartDestroy) {
        return;
    }
    m_fStartDestroy = TRUE;


    //
    // Give the derived Animation a chance to cleanup
    //
    // Check that we are still the Animation attached to this Gadget.  We need 
    // to remove this property immediately.  We can not wait for a posted 
    // message to be processed because we may need to set it right now if we are
    // creating a new Animation.
    //

    if (m_hgadSubject != NULL) {
        OnComplete();

#if DBG
        OldAnimation * paniExist = static_cast<OldAnimation *> (GetExtension(m_hgadSubject, m_pridListen));
        if (paniExist != NULL) {
            AssertMsg(paniExist == this, "Animations must match");
        }
#endif // DBG

        CleanupChangeGadget();
    }


    //
    // Destroy the Animation
    //

    AssertMsg(!fFinal, "Object is already being destructed");
    if (fFinal) {
        OnAsyncDestroy();
    } else {
        PostAsyncDestroy();
    }
}


//------------------------------------------------------------------------------
void        
OldAnimation::OnAsyncDestroy()
{
    AssertMsg(m_fStartDestroy, "Must call Destroy() to start the destruction process.");
    AssertMsg(!m_fProcessing, "Should not be processing when start destruction");

    AssertMsg(m_hgadSubject == NULL, "Animation should already have detached from Gadget");
    HACTION hact = m_hact;

    //
    // Notify any callback that the Animation is finished
    //

    if (m_pcb != NULL) {
        IAnimation * paniI = static_cast<IAnimation *> (this);

        __try 
        {
            m_pcb->OnComplete(paniI, m_time);
        }
        __except(StdExceptionFilter(GetExceptionInformation()))
        {
            ExitProcess(GetExceptionCode());
        }
    }


    //
    // Set everything to NULL now.
    //

    m_hact = NULL;
    OldExtension::DeleteHandle();


    //
    // Stop the Action
    //

    if (hact != NULL) {
        ::DeleteHandle(hact);
        hact = NULL;
    }


    //
    // Release() our cached interfaces
    //

    SafeRelease(m_pipol);
    SafeRelease(m_pcb);
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetFunction(IInterpolation * pipol)
{
    AssertReadPtr(pipol);

    SafeRelease(m_pipol);
    pipol->AddRef();
    m_pipol = pipol;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetTime(IAnimation::ETime time)
{
    GMA_ACTIONINFO mai;

    //
    // TODO: Need to save these values from the last time so that they are 
    // valid.
    //

    mai.hact        = m_hact;
    mai.pvData      = this;
    mai.flDuration  = 0.0f;

    m_time = time;
    switch (time)
    {
    case IAnimation::tComplete:
        // Don't do anything
        return;

    default:
    case IAnimation::tAbort:
    case IAnimation::tDestroy:
        goto Done;

    case IAnimation::tEnd:
        mai.flProgress  = 1.0f;
        break;

    case IAnimation::tReset:
        mai.flProgress  = 0.0f;
        break;
    }

    mai.cEvent      = 0;
    mai.cPeriods    = 0;
    mai.fFinished   = FALSE;

    m_fProcessing = TRUE;
    Action(&mai);
    Assert(m_fProcessing);
    m_fProcessing = FALSE;

Done:
    if (m_pcb != NULL) {
        IAnimation * paniI = static_cast<IAnimation *> (this);
        m_pcb->OnSetTime(paniI, time);
    }

    ::DeleteHandle(m_hact);
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetCallback(IAnimationCallback * pcb)
{
    // pcb can be NULL

    SafeRelease(m_pcb);

    if (pcb != NULL) {
        pcb->AddRef();
        m_pcb = pcb;
    }
}


//------------------------------------------------------------------------------
HRESULT
OldAnimation::GetInterface(HGADGET hgad, PRID prid, REFIID riid, void ** ppvUnk)
{
    OldAnimation * paniExist = static_cast<OldAnimation *> (GetExtension(hgad, prid));
    if (paniExist != NULL) {
        if (IsEqualIID(riid, __uuidof(IAnimation))) {
            paniExist->AddRef();
            *ppvUnk = static_cast<IAnimation *> (paniExist);
            return S_OK;
        } else {
            return paniExist->QueryInterface(riid, ppvUnk);
        }
    }

    return DU_E_NOTFOUND;   // This Animation doesn't exist on this Gadget.
}


//------------------------------------------------------------------------------
void
OldAnimation::CleanupChangeGadget()
{
    Assert(m_hgadSubject != NULL);
    Assert(m_pridListen != 0);

    Verify(::RemoveGadgetProperty(m_hgadSubject, m_pridListen));

    m_hgadSubject = NULL;
}

    
//------------------------------------------------------------------------------
void CALLBACK
OldAnimation::RawActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
    OldAnimation * pani = (OldAnimation *) pmai->pvData;
    pani->AddRef();
    Assert(!pani->m_fProcessing);

#if DBG
    pani->m_DEBUG_cUpdates++;
#endif // DBG

#if DEBUG_TRACECREATION
    Trace("START RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    if ((!pani->m_fStartDestroy) && (pani->m_hgadSubject != NULL)) {
        //
        // This ActionProc will be called when the Action is being destroyed, so
        // we only want to invoke the Action under certain circumstances.
        //

        switch (pani->m_time)
        {
        case tComplete:
        case tEnd:
        case tReset:
            //
            // All of these are valid to complete.  If it isn't in this list, we
            // don't want to execute it during a shutdown.
            //

            pani->m_fProcessing = TRUE;
            pani->Action(pmai);
            Assert(pani->m_fProcessing);
            pani->m_fProcessing = FALSE;
            break;
        }
    }

    if (pmai->fFinished) {
        pani->m_hact = NULL;
        pani->Destroy(FALSE);
    }

#if DEBUG_TRACECREATION
    Trace("STOP  RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    Assert(!pani->m_fProcessing);
    pani->Release();
}


//------------------------------------------------------------------------------
void
OldAnimation::OnRemoveExisting()
{
    SetTime(IAnimation::tDestroy);
}


//------------------------------------------------------------------------------
void
OldAnimation::OnDestroyListener()
{
    AddRef();

    if (m_hgadListen != NULL) {
        //
        // TODO: Figure out when this case can actually occur.  This means that
        // the MessageGadget was destroyed, but the caller didn't go through
        // OldAnimation::Destroy() to do it.
        //

        m_hgadListen = NULL;
        Destroy(FALSE);
    }
    VerifyMsg(Release() > 0, "Must still have lock from beginning of function");

    Release();
}


//------------------------------------------------------------------------------
void
OldAnimation::OnDestroySubject()
{
    AddRef();

    if (m_hgadSubject != NULL) {
        CleanupChangeGadget();

        //
        // The Gadget that we are modifying is being destroyed, so we need
        // to stop animating it.
        //

        m_time = IAnimation::tDestroy;
        Destroy(FALSE);
    }

    Release();
}


/***************************************************************************\
*****************************************************************************
*
* class OldAlphaAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldAlphaAnimation::~OldAlphaAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldAlphaAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldAlphaAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidAlphaAnimation, &s_pridAlpha, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_ALPHADESC * pDescA = (GANI_ALPHADESC *) pDesc;
    m_nOnComplete           = pDescA->nOnComplete;
    m_fPushToChildren       = pDescA->fPushToChildren && 
            (::GetGadget(m_hgadSubject, GG_TOPCHILD) != NULL);

    BOOL fBuffered = TestFlag(::GetGadgetStyle(m_hgadSubject), GS_BUFFERED);

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart   = pDescA->flStart;
    } else {
        if (fBuffered) {
            //
            // Gadget is already buffered, so use it current alpha value.
            //

            BUFFER_INFO bi;
            ZeroMemory(&bi, sizeof(bi));
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            if (::GetGadgetBufferInfo(m_hgadSubject, &bi)) {
                m_flStart = ((float) bi.bAlpha) / 255.0f;
            } else {
                m_flStart = 1.0f;
            }
        } else {
            m_flStart = 1.0f;
        }
    }

    if (m_fPushToChildren) {
        //
        // If we are currently alpha blended, we need to turn this off.
        //
        
        if (fBuffered) {
            ::SetGadgetStyle(m_hgadSubject, 0, GS_BUFFERED);
            ::SetGadgetStyle(m_hgadSubject, 0, GS_OPAQUE);
        }
        
        
        //
        // Setup each direct child to be buffered for the alpha-blending
        //

        BYTE bAlpha = (BYTE) (m_flStart * 255.0f);

        HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
        while (hgadChild != NULL) {
            if (!::SetGadgetStyle(hgadChild, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE)) {
                return (HRESULT) GetLastError();
            }

            BUFFER_INFO bi;
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            bi.bAlpha   = bAlpha;
            if (!SetGadgetBufferInfo(hgadChild, &bi)) {
                return (HRESULT) GetLastError();
            }

            hgadChild = ::GetGadget(hgadChild, GG_NEXT);
        }
    } else if (!fBuffered) {
        //
        // Need to mark the Gadget as being buffered to perform alpha effects
        //

        if (!::SetGadgetStyle(m_hgadSubject, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE)) {
            return (HRESULT) GetLastError();
        }
    }

    m_flEnd = pDescA->flEnd;

#if DEBUG_TRACECREATION
    Trace("OldAlphaAnimation 0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldAlphaAnimation::GetID() const
{
    return ANIMATION_ALPHA;
}


//------------------------------------------------------------------------------
void        
OldAlphaAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flPr      = pmai->flProgress;
    float flAlpha   = m_pipol->Compute(flPr, m_flStart, m_flEnd);

    BYTE bAlpha;
    if (flAlpha < 0.0f) {
        bAlpha = (BYTE) 0;
    } else if (flAlpha > 1.0f) {
        bAlpha = (BYTE) 255;
    } else {
        bAlpha = (BYTE) (flAlpha * 255.0f);
    }

    BUFFER_INFO bi;
    bi.cbSize   = sizeof(bi);
    bi.nMask    = GBIM_ALPHA;
    bi.bAlpha   = bAlpha;

    if (m_fPushToChildren) {
        HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
        while (hgadChild != NULL) {
            SetGadgetStyle(hgadChild, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
            SetGadgetBufferInfo(hgadChild, &bi);
            InvalidateGadget(hgadChild);

            hgadChild = ::GetGadget(hgadChild, GG_NEXT);
        }
    } else {
        SetGadgetStyle(m_hgadSubject, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
        SetGadgetBufferInfo(m_hgadSubject, &bi);
        InvalidateGadget(m_hgadSubject);
    }
}


//------------------------------------------------------------------------------
void        
OldAlphaAnimation::OnComplete()
{
    if (TestFlag(m_nOnComplete, GANI_ALPHACOMPLETE_OPTIMIZE)) {
        if ((m_flEnd * 255.0f) >= 245) {
            if (m_fPushToChildren) {
                HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
                while (hgadChild != NULL) {
                    SetGadgetStyle(hgadChild, 0, GS_BUFFERED);
                    hgadChild = ::GetGadget(hgadChild, GG_NEXT);
                }
            } else {
                SetGadgetStyle(m_hgadSubject, 0, GS_BUFFERED);
            }
            InvalidateGadget(m_hgadSubject);
        }
    }
}


/***************************************************************************\
*****************************************************************************
*
* class OldScaleAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldScaleAnimation::~OldScaleAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldScaleAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldScaleAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidScaleAnimation, &s_pridScale, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_SCALEDESC * pDescS = (GANI_SCALEDESC *) pDesc;

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart   = pDescS->flStart;
    } else {
        float flX, flY;
        if (!::GetGadgetScale(m_hgadSubject, &flX, &flY)) {
            return (HRESULT) GetLastError();
        }

        m_flStart       = flX;
    }
    m_flEnd         = pDescS->flEnd;
    m_al            = pDescS->al;


    RECT rcParent;
    ::GetGadgetRect(m_hgadSubject, &rcParent, SGR_PARENT);
    m_ptStart.x     = rcParent.left;
    m_ptStart.y     = rcParent.top;
    m_sizeCtrl.cx   = rcParent.right - rcParent.left;
    m_sizeCtrl.cy   = rcParent.bottom - rcParent.top;

#if DEBUG_TRACECREATION
    Trace("OldScaleAnimation 0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldScaleAnimation::GetID() const
{
    return ANIMATION_SCALE;
}


//------------------------------------------------------------------------------
void        
OldScaleAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flPr  = pmai->flProgress;
    float flx   = m_pipol->Compute(flPr, m_flStart, m_flEnd);
    float fly   = flx;
    ::SetGadgetScale(m_hgadSubject, flx, fly);

    POINT ptNew;
    ptNew.x     = m_ptStart.x - (int) ((m_sizeCtrl.cx * flx - m_sizeCtrl.cx) / 2.0);
    ptNew.y     = m_ptStart.y - (int) ((m_sizeCtrl.cy * fly - m_sizeCtrl.cy) / 2.0);
    ::SetGadgetRect(m_hgadSubject, ptNew.x, ptNew.y, 0, 0, SGR_MOVE | SGR_PARENT);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRectAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldRectAnimation::~OldRectAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldRectAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldRectAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidRectAnimation, &s_pridRect, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_RECTDESC * pDescR = (GANI_RECTDESC *) pDesc;

    UINT nGetFlags = SGR_VALID_GET & pDescR->nChangeFlags;
    if (nGetFlags == 0) {
        return E_INVALIDARG;
    }

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_ptStart   = pDescR->ptStart;
        m_sizeStart = pDescR->sizeStart;
    } else {
        RECT rcGadget;
        if (!::GetGadgetRect(m_hgadSubject, &rcGadget, nGetFlags)) {
            return (HRESULT) GetLastError();
        }

        m_ptStart.x     = rcGadget.left;
        m_ptStart.y     = rcGadget.top;
        m_sizeStart.cx  = rcGadget.right - rcGadget.left;
        m_sizeStart.cy  = rcGadget.bottom - rcGadget.top;
    }

    m_ptEnd         = pDescR->ptEnd;
    m_sizeEnd       = pDescR->sizeEnd;
    m_nChangeFlags  = pDescR->nChangeFlags;

#if DEBUG_TRACECREATION
    Trace("OldRectAnimation  0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldRectAnimation::GetID() const
{
    return ANIMATION_RECT;
}


//------------------------------------------------------------------------------
void        
OldRectAnimation::Action(GMA_ACTIONINFO * pmai)
{
    POINT ptNew;
    SIZE sizeNew;
    float flProgress = pmai->flProgress;

    ptNew.x     = Compute(m_pipol, flProgress, m_ptStart.x, m_ptEnd.x);
    ptNew.y     = Compute(m_pipol, flProgress, m_ptStart.y, m_ptEnd.y);
    sizeNew.cx  = Compute(m_pipol, flProgress, m_sizeStart.cx, m_sizeEnd.cx);
    sizeNew.cy  = Compute(m_pipol, flProgress, m_sizeStart.cy, m_sizeEnd.cy);

    SetGadgetRect(m_hgadSubject, ptNew.x, ptNew.y, sizeNew.cx, sizeNew.cy, m_nChangeFlags);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRotateAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldRotateAnimation::~OldRotateAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldRotateAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldRotateAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidRotateAnimation, &s_pridRotate, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_ROTATEDESC * pDescR = (GANI_ROTATEDESC *) pDesc;

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart = pDescR->flStart;
    } else {
        if (!::GetGadgetRotation(m_hgadSubject, &m_flStart)) {
            return (HRESULT) GetLastError();
        }
    }

    m_flEnd = pDescR->flEnd;
    m_nDir  = pDescR->nDir;


    //
    // Adjust the starting and ending angles so that we "move" in the correct
    // direction.  We do this by adding or subtracting full rotations depending
    // on the "move" we are trying to accomplish.
    //

    switch (m_nDir)
    {
    case GANI_ROTATEDIRECTION_SHORT:
        if (m_flStart < m_flEnd) {
            while ((m_flEnd - m_flStart) > (float) PI) {
                m_flStart += (float) (2 * PI);
            }
        } else {
            while ((m_flStart - m_flEnd) > (float) PI) {
                m_flStart -= (float) (2 * PI);
            }
        }
        break;

    case GANI_ROTATEDIRECTION_LONG:
        if (m_flStart < m_flEnd) {
            while ((m_flStart - m_flEnd) < (float) PI) {
                m_flEnd -= (float) (2 * PI);
            }
        } else {
            while ((m_flEnd - m_flStart) < (float) PI) {
                m_flEnd += (float) (2 * PI);
            }
        }
        break;

    case GANI_ROTATEDIRECTION_CW:
        while (m_flStart > m_flEnd) {
            m_flEnd += (float) (2 * PI);
        }
        break;

    case GANI_ROTATEDIRECTION_CCW:
        while (m_flStart < m_flEnd) {
            m_flStart += (float) (2 * PI);
        }
        break;
    }


#if DEBUG_TRACECREATION
    Trace("OldRotateAnimation  0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldRotateAnimation::GetID() const
{
    return ANIMATION_ROTATE;
}


//------------------------------------------------------------------------------
void        
OldRotateAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flProgress    = pmai->flProgress;
    float flAngleNew = Compute(m_pipol, flProgress, m_flStart, m_flEnd);

    SetGadgetRotation(m_hgadSubject, flAngleNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldanimation.h ===
#if !defined(CTRL__OldAnimation_h__INCLUDED)
#define CTRL__OldAnimation_h__INCLUDED
#pragma once

#include "SmObject.h"
#include "OldExtension.h"

/***************************************************************************\
*****************************************************************************
*
* class OldAnimationT
*
* OldAnimationT defines a common implementation class for building
* Animations in DirectUser.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface, class desc>
class OldAnimationT : public SmObjectT<base, iface>
{
// Operations
public:
    static HRESULT
    Build(GANI_DESC * pDesc, REFIID riid, void ** ppv)
    {
        AssertWritePtr(ppv);

        if (pDesc->cbSize != sizeof(desc)) {
            return E_INVALIDARG;
        }

        OldAnimationT<base, iface, desc> * pObj = new OldAnimationT<base, iface, desc>;
        if (pObj != NULL) {
            pObj->m_cRef = 1;

            HRESULT hr = pObj->Create(pDesc);
            if (SUCCEEDED(hr)) {
                //
                // Animations need to be AddRef()'d again (have a reference 
                // count of 2) because they need to outlife the initial call 
                // to Release() after the called has setup the animation 
                // returned from BuildAnimation().  
                //
                // This is because the Animation continues to life until it 
                // has fully executed (or has been aborted).
                //

                hr = pObj->QueryInterface(riid, ppv);
            } else {
                pObj->Release();
            }
            return hr;
        } else {
            return E_OUTOFMEMORY;
        }
    }
};


//------------------------------------------------------------------------------
class OldAnimation : 
    public OldExtension,
    public IAnimation
{
// Construction
protected:
    inline  OldAnimation();
    virtual ~OldAnimation() PURE;
            HRESULT     Create(const GUID * pguidID, PRID * pprid, GANI_DESC * pDesc);
            void        Destroy(BOOL fFinal);

// Operations
public:
    STDMETHOD_(void,    SetFunction)(IInterpolation * pipol);
    STDMETHOD_(void,    SetTime)(IAnimation::ETime time);
    STDMETHOD_(void,    SetCallback)(IAnimationCallback * pcb);

// Implementation
protected:
    static  void CALLBACK
                        RawActionProc(GMA_ACTIONINFO * pmai);
    virtual void        Action(GMA_ACTIONINFO * pmai) PURE;

    static  HRESULT     GetInterface(HGADGET hgad, PRID prid, REFIID riid, void ** ppvUnk);

    virtual void        OnRemoveExisting();
    virtual void        OnDestroySubject();
    virtual void        OnDestroyListener();

    virtual void        OnComplete() { }
    virtual void        OnAsyncDestroy();

            void        CleanupChangeGadget();

// Data
protected:
            HACTION     m_hact;
            IInterpolation *
                        m_pipol;
            IAnimationCallback *
                        m_pcb;
            IAnimation::ETime
                        m_time;         // Time when completed
            BOOL        m_fStartDestroy:1;
            BOOL        m_fProcessing:1;

            UINT        m_DEBUG_cUpdates;
};


//------------------------------------------------------------------------------
class OldAlphaAnimation : public OldAnimation
{
// Construction
public:
    inline  OldAlphaAnimation();
    virtual ~OldAlphaAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);
    virtual void        OnComplete();

// Data
protected:
    static  PRID        s_pridAlpha;
    static  const IID * s_rgpIID[];
            float       m_flStart;
            float       m_flEnd;
            BOOL        m_fPushToChildren;
            UINT        m_nOnComplete;
};


//------------------------------------------------------------------------------
class OldScaleAnimation : public OldAnimation
{
// Construction
public:
    inline  OldScaleAnimation();
    virtual ~OldScaleAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridScale;
    static  const IID * s_rgpIID[];
            GANI_SCALEDESC::EAlignment  
                        m_al;
            float       m_flStart;
            float       m_flEnd;
            POINT       m_ptStart;
            SIZE        m_sizeCtrl;
};


//------------------------------------------------------------------------------
class OldRectAnimation : public OldAnimation
{
// Construction
public:
    inline  OldRectAnimation();
    virtual ~OldRectAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridRect;
    static  const IID * s_rgpIID[];
            POINT       m_ptStart;
            POINT       m_ptEnd;
            SIZE        m_sizeStart;
            SIZE        m_sizeEnd;
            UINT        m_nChangeFlags;
};


//------------------------------------------------------------------------------
class OldRotateAnimation : public OldAnimation
{
// Construction
public:
    inline  OldRotateAnimation();
    virtual ~OldRotateAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridRotate;
    static  const IID * s_rgpIID[];
            float       m_flStart;
            float       m_flEnd;
            UINT        m_nDir;
};


#include "OldAnimation.inl"

#endif // CTRL__OldAnimation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\olddragdrop.cpp ===
/***************************************************************************\
*
* File: DragDrop.cpp
*
* Description:
* DragDrop.cpp implements drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Ctrl.h"
#include "OldDragDrop.h"

#include <SmObject.h>


static const GUID guidDropTarget = { 0x6a8bb3c8, 0xcbfc, 0x40d1, { 0x98, 0x1e, 0x3f, 0x8a, 0xaf, 0x99, 0x13, 0x7b } };  // {6A8BB3C8-CBFC-40d1-981E-3F8AAF99137B}

/***************************************************************************\
*****************************************************************************
*
* class OldTargetLock
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* OldTargetLock::Lock
*
* Lock() prepares for executing inside the Context when being called back
* from OLE's IDropTarget that was registered.
*
\***************************************************************************/

BOOL 
OldTargetLock::Lock(
    IN  OldDropTarget * p,           // OldDropTarget being used
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT if failure
    IN  BOOL fAddRef)               // Lock DT during use
{
    m_fAddRef   = fAddRef;
    m_punk      = static_cast<IUnknown *> (p);

    if (m_fAddRef) {
        m_punk->AddRef();
    }

    if (p->m_hgadSubject == NULL) {
        if (pdwEffect != NULL) {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return FALSE;
    }

    return TRUE;
}

    
/***************************************************************************\
*****************************************************************************
*
* class OldDropTarget
* 
* NOTE: With the current design and implementation, OldDropTarget can not be 
* "removed" from an object until the object is destroyed.  If this needs to 
* change, we need to revisit this.
* 
*****************************************************************************
\***************************************************************************/

const IID * OldDropTarget::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IDropTarget),
    NULL
};

PRID OldDropTarget::s_pridListen = 0;


//
// NOTE: We are calling back directly on the IDropTarget's, so we need to grab
// a read-only lock so that the tree doesn't get smashed.
//

/***************************************************************************\
*
* OldDropTarget::~OldDropTarget
*
* ~OldDropTarget() cleans up resources used by the OldDropTarget.
*
\***************************************************************************/

OldDropTarget::~OldDropTarget()
{
    OldTargetLock lt;
    lt.Lock(this, NULL, FALSE);
    xwDragLeave();
    SafeRelease(m_pdoSrc);

    OldExtension::Destroy();
}


/***************************************************************************\
*
* OldDropTarget::Build
*
* Build() builds a new OldDropTarget instance.  This should only be called for
* a RootGadget that doesn't already have a DT.
*
\***************************************************************************/

HRESULT 
OldDropTarget::Build(
    IN  HGADGET hgadRoot,           // RootGadget
    IN  HWND hwnd,                  // Containing HWND
    OUT OldDropTarget ** ppdt)       // Newly created DT
{
    AssertMsg(hgadRoot != NULL, "Must have a valid root");

    //
    // Setup a new OldDropTarget on this Gadget / HWND.
    //

    if (!GetComManager()->Init(ComManager::sOLE)) {
        return E_OUTOFMEMORY;
    }

    SmObjectT<OldDropTarget, IDropTarget> * pdt = new SmObjectT<OldDropTarget, IDropTarget>;
    if (pdt == NULL) {
        return E_OUTOFMEMORY;
    }
    pdt->AddRef();

    HRESULT hr = GetComManager()->RegisterDragDrop(hwnd, static_cast<IDropTarget *> (pdt));
    if (FAILED(hr)) {
        pdt->Release();
        return E_OUTOFMEMORY;
    }
    //CoLockObjectExternal(pdt, TRUE, FALSE);


    hr = pdt->Create(hgadRoot, &guidDropTarget, &s_pridListen, OldExtension::oUseExisting);
    if ((hr == DU_S_ALREADYEXISTS) || FAILED(hr)) {
        GetComManager()->RevokeDragDrop(hwnd);
        pdt->Release();
        return hr;
    }

    pdt->m_hwnd         = hwnd;

    *ppdt = pdt;
    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::DragEnter
*
* DragEnter() is called by OLE when entering the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragEnter(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    if (pdoSrc == NULL) {
        return E_INVALIDARG;
    }

    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }


    //
    // Cache the DataObject.
    //

    SafeRelease(m_pdoSrc);
    if (pdoSrc != NULL) {
        pdoSrc->AddRef();
        m_pdoSrc = pdoSrc;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::DragOver
*
* DragOver() is called by OLE during the drag operation to give feedback 
* while inside the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragOver(
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::DragLeave
*
* DragLeave() is called by OLE when leaving the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragLeave()
{
    OldTargetLock tl;
    if (!tl.Lock(this, NULL)) {
        return S_OK;
    }

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::Drop
*
* Drop() is called by OLE when the user has dropped while inside DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::Drop(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    if (!HasTarget()) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;


    //
    // Update to get the latest Gadget information.
    //

    POINT ptClientPxl;
    HRESULT hr = xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
    if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
        return hr;
    }

    AssertMsg(HasTarget(), "Must have a target if UpdateTarget() succeeds");


    //
    // Now that the state has been updated, execute the actual drop.
    //

    POINTL ptDrop = { ptClientPxl.x, ptClientPxl.y };
    m_pdtCur->Drop(pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::xwDragScan
*
* xwDragScan() is called from the various IDropTarget methods to process
* a request coming from outside.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwDragScan(
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    POINT ptContainerPxl;
    RECT rcDesktopPxl;

    GetClientRect(m_hwnd, &rcDesktopPxl);
    ClientToScreen(m_hwnd, (LPPOINT) &(rcDesktopPxl.left));

    ptContainerPxl.x = ptDesktopPxl.x - rcDesktopPxl.left;
    ptContainerPxl.y = ptDesktopPxl.y - rcDesktopPxl.top;;

    return xwUpdateTarget(ptContainerPxl, pdwEffect, pptClientPxl);
}

    
/***************************************************************************\
*
* OldDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwUpdateTarget(
    IN  POINT ptContainerPxl,       // Cursor location in container
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    AssertMsg(HasSource(), "Only call when have valid data source");
    AssertWritePtr(pdwEffect);
    AssertWritePtr(pptClientPxl);

    m_ptLastContainerPxl = ptContainerPxl;

    //
    // Determine the Gadget that is currently at the drop location.  We use this
    // as a starting point.
    //

    HGADGET hgadFound = FindGadgetFromPoint(m_hgadSubject, ptContainerPxl, GS_VISIBLE | GS_ENABLED, pptClientPxl);
    if (hgadFound == NULL) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    return xwUpdateTarget(hgadFound, pdwEffect, pptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwUpdateTarget(
    IN  HGADGET hgadFound,          // Gadget getting Drop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    IN  POINT * pptClientPxl)       // Cursor location in client
{
    HRESULT hr = S_OK;


    //
    // Check if the drop Gadget has changed.
    //

    if ((hgadFound != NULL) && (hgadFound != m_hgadDrop)) {
        //
        // Ask the new Gadget if he wants to participate in Drag & Drop.
        //

        GMSG_QUERYDROPTARGET msg;
        ZeroMemory(&msg, sizeof(msg));
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = GM_QUERY;
        msg.nCode   = GQUERY_DROPTARGET;
        msg.hgadMsg = hgadFound;

        static int s_cSend = 0;
        Trace("Send Query: %d to 0x%p\n", s_cSend++, hgadFound);

        HRESULT hr = DUserSendEvent(&msg, SGM_FULL);
        if (IsHandled(hr)) {
            if ((msg.hgadDrop != NULL) && (msg.pdt != NULL)) {
                if (msg.hgadDrop != hgadFound) {
                    //
                    // The message returned a different to handle the DnD request,
                    // so we need to re-adjust.  We know that this Gadget is enabled
                    // and visible since it is in our parent chain and we are already
                    // enabled and visible.
                    //

#if DBG
                    BOOL fChain = FALSE;
                    IsGadgetParentChainStyle(msg.hgadDrop, GS_VISIBLE | GS_ENABLED, &fChain, 0);
                    if (!fChain) {
                        Trace("WARNING: DUser: DropTarget: Parent chain for 0x%p is not fully visible and enabled.\n", msg.hgadDrop);
                    }
#endif

                    MapGadgetPoints(hgadFound, msg.hgadDrop, pptClientPxl, 1);
                }
            }
        } else {
            msg.hgadDrop    = NULL;
            msg.pdt         = NULL;
        }


        //
        // Notify the old Gadget that the Drag operation has left him.
        // Update to new state
        // Notify the new Gadget that the Drag operation has entered him.
        //

        if (m_hgadDrop != msg.hgadDrop) {
            xwDragLeave();

            m_hgadDrop  = msg.hgadDrop;
            m_pdtCur    = msg.pdt;

            hr = xwDragEnter(pptClientPxl, pdwEffect);
            if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
                goto Exit;
            }
        } else {
            SafeRelease(msg.pdt);
            *pdwEffect = DROPEFFECT_NONE;
        }
    }


    //
    // Update the DropTarget
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        hr = m_pdtCur->DragOver(m_grfLastKeyState, ptDrop, pdwEffect);
    }

Exit:
    AssertMsg(FAILED(hr) || 
            ((*pdwEffect == DROPEFFECT_NONE) && !HasTarget()) ||
            HasTarget(),
            "Check valid return state");

    return hr;
}


/***************************************************************************\
*
* OldDropTarget::xwDragEnter
*
* xwDragEnter() is called when entering a new Gadget during a DnD operation.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwDragEnter(
    IN OUT POINT * pptClientPxl,    // Client location (updated)
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    AssertMsg(HasSource(), "Only call when have valid data source");

    //
    // Notify the new Gadget that the drop has entered him.
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        HRESULT hr = m_pdtCur->DragEnter(m_pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::xwDragLeave
*
* xwDragLeave() is called when leaving a Gadget during a DnD operation.
*
\***************************************************************************/

void
OldDropTarget::xwDragLeave()
{
    if (HasTarget()) {
        m_pdtCur->DragLeave();
        m_pdtCur->Release();
        m_pdtCur = NULL;

        m_hgadDrop = NULL;
    }
}


//------------------------------------------------------------------------------
void
OldDropTarget::OnDestroyListener()
{
    Release();
}


//------------------------------------------------------------------------------
void
OldDropTarget::OnDestroySubject()
{
    if (IsWindow(m_hwnd)) {
        GetComManager()->RevokeDragDrop(m_hwnd);
    }

    //CoLockObjectExternal(pdt, FALSE, TRUE);
    OldExtension::DeleteHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\olddragdrop.h ===
/***************************************************************************\
*
* File: DragDrop.h
*
* Description:
* DragDrop.h defines drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__OldDragDrop_h__INCLUDED)
#define CORE__OldDragDrop_h__INCLUDED
#pragma once

#include "OldExtension.h"

class OldTargetLock;

class OldDropTarget : 
        public OldExtension,
        public IDropTarget
{
protected:
    inline  OldDropTarget();
            ~OldDropTarget();
public:
    static  HRESULT Build(HGADGET hgadRoot, HWND hwnd, OldDropTarget ** ppdt);

// IDropTarget
public:
    STDMETHOD(DragEnter)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);

// Operations
public:

// Implementation
protected:
    inline  BOOL        HasSource() const;
    inline  BOOL        HasTarget() const;

            HRESULT     xwDragScan(POINTL ptDesktopPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(POINT ptContainerPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(HGADGET hgadFound, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwDragEnter(POINT * pptClientPxl, DWORD * pdwEffect);
            void        xwDragLeave();

    virtual void        OnDestroyListener();
    virtual void        OnDestroySubject();

// Data
protected:
    static  const IID * s_rgpIID[];
            IDropTarget *
                        m_pdtCur;               // Current Gadget OldDropTarget
            IDataObject *
                        m_pdoSrc;               // Source's data object
            HWND        m_hwnd;                 // Containing HWND
            DWORD       m_grfLastKeyState;      // Last key state
            POINT       m_ptLastContainerPxl;   // Last container pixel
            HGADGET     m_hgadDrop;             // Current OldDropTarget
    static  PRID        s_pridListen;           // PRID for OldDropTarget

    friend class OldTargetLock;
};


class OldTargetLock
{
public:
    inline  OldTargetLock();
    inline  ~OldTargetLock();
            BOOL        Lock(OldDropTarget * p, DWORD * pdwEffect, BOOL fAddRef = TRUE);

protected:
            IUnknown *      m_punk;
            BOOL            m_fAddRef;
};


#include "OldDragDrop.inl"

#endif // CORE__OldDragDrop_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldanimation.inl ===
#if !defined(CTRL__OldAnimation_inl__INCLUDED)
#define CTRL__OldAnimation_inl__INCLUDED
#pragma once

#define DEBUG_TRACECREATION         0   // Trace Creation and destruction of animations

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline int
Round(float f)
{
    return (int) (f + 0.5);
}


//------------------------------------------------------------------------------
inline int     
Compute(IInterpolation * pipol, float flProgress, int nStart, int nEnd)
{
    return Round(pipol->Compute(flProgress, (float) nStart, (float) nEnd));
}


//------------------------------------------------------------------------------
inline float
Compute(IInterpolation * pipol, float flProgress, float flStart, float flEnd)
{
    return pipol->Compute(flProgress, flStart, flEnd);
}


/***************************************************************************\
*****************************************************************************
*
* class OldAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldAnimation::OldAnimation()
{
    m_time = IAnimation::tComplete;  // By default, completes normally

#if DEBUG_TRACECREATION
    Trace("START Animation  0x%p    @ %d\n", this, GetTickCount());
#endif // DEBUG_TRACECREATION
}


/***************************************************************************\
*****************************************************************************
*
* class OldAlphaAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldAlphaAnimation::OldAlphaAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldAlphaAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridAlpha, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldScaleAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldScaleAnimation::OldScaleAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldScaleAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridScale, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRectAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldRectAnimation::OldRectAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldRectAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridRect, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRotateAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldRotateAnimation::OldRotateAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldRotateAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridRotate, riid, ppvUnk);
}


#endif // CTRL__OldAnimation_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\olddragdrop.inl ===
#if !defined(CORE__OldDragDrop_inl__INCLUDED)
#define CORE__OldDragDrop_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class OldTargetLock
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
OldTargetLock::OldTargetLock()
{
    
}


//------------------------------------------------------------------------------
inline
OldTargetLock::~OldTargetLock() 
{
    if (m_fAddRef) {
        m_punk->Release();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class OldDropTarget
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldDropTarget::OldDropTarget()
{

}


//------------------------------------------------------------------------------
inline BOOL
OldDropTarget::HasSource() const
{
    return m_pdoSrc != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
OldDropTarget::HasTarget() const
{
    return m_pdtCur != NULL;
}


#endif // CORE__OldDragDrop_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldextension.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldExtension.h"

/***************************************************************************\
*****************************************************************************
*
* class OldExtension
*
*****************************************************************************
\***************************************************************************/

static const GUID guidAysncDestroy      = { 0xbfe02331, 0xc17d, 0x45ea, { 0x96, 0x35, 0xa0, 0x7a, 0x90, 0x37, 0xfe, 0x34 } };   // {BFE02331-C17D-45ea-9635-A07A9037FE34}
MSGID       OldExtension::s_msgidAsyncDestroy = 0;

/***************************************************************************\
*
* OldExtension::~OldExtension
*
* ~OldExtension() checks that resources were properly cleaned up before the
* OldExtension was destroyed.
*
\***************************************************************************/

OldExtension::~OldExtension()
{
    //
    // Ensure proper destruction
    //

    AssertMsg(m_hgadListen == NULL, "Gadget should already be destroyed");
}


/***************************************************************************\
*
* OldExtension::Create
*
* Create() initializes a new OldExtension and attaches it to the subject Gadget
* being modified.
*
\***************************************************************************/

HRESULT
OldExtension::Create(
    IN  HGADGET hgadSubject,            // Gadget being "extended"
    IN  const GUID * pguid,             // Unique ID of OldExtension
    IN OUT PRID * pprid,                // Short ID for OldExtension
    IN  UINT nOptions)                  // Options
{
    AssertWritePtr(pprid);


    //
    // Do not allow attaching a OldExtension to a Gadget that has already started 
    // the destruction process.
    //

    BOOL fStartDelete;
    if ((!IsStartDelete(hgadSubject, &fStartDelete)) || fStartDelete) {
        return DU_E_STARTDESTROY;
    }


    //
    // Setup information necessary for asynchronous destruction.
    //

    m_fAsyncDestroy = TestFlag(nOptions, oAsyncDestroy);
    if (m_fAsyncDestroy) {
        if (s_msgidAsyncDestroy == 0) {
            s_msgidAsyncDestroy = RegisterGadgetMessage(&guidAysncDestroy);
            if (s_msgidAsyncDestroy == 0) {
                return (HRESULT) GetLastError();
            }
        }
    }


    //
    // Determine if this OldExtension is already attached to the Gadget being 
    // extended.
    //

    if (*pprid == 0) {
        *pprid = RegisterGadgetProperty(pguid);
        if (*pprid == 0) {
            return GetLastError();
        }
    }
    PRID prid = *pprid;

    OldExtension * pbExist;
    if (GetGadgetProperty(hgadSubject, prid, (void **) &pbExist) != NULL) {
        if (TestFlag(nOptions, oUseExisting)) {
            return DU_S_ALREADYEXISTS;
        } else {
            //
            // Already attached, but can't use the existing one.  We need to
            // remove the existing OldExtension before attaching the new one.  After
            // calling RemoveExisting(), the OldExtension should no longer be 
            // attached to the Gadget.
            //

            pbExist->OnRemoveExisting();
            Assert(!GetGadgetProperty(hgadSubject, prid, (void **) &pbExist));
        }
    }


    //
    // Setup a listener to be notifyed when the RootGadget is destroyed.
    //

    HRESULT hr = S_OK;
    m_hgadListen = CreateGadget(NULL, GC_MESSAGE, ListenProc, this);
    if (m_hgadListen == NULL) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    m_hgadSubject   = hgadSubject;
    m_pridListen    = prid;

    if (!SetGadgetProperty(hgadSubject, prid, this) || 
            (!AddGadgetMessageHandler(hgadSubject, GM_DESTROY, m_hgadListen))) {

        DeleteObject(m_hgadListen);
        m_hgadListen = NULL;
        hr = E_OUTOFMEMORY;
        goto Error;
    }


    //
    // Successfully created the OldExtension
    //

    return S_OK;

Error:
    Destroy();
    return hr;
}


/***************************************************************************\
*
* OldExtension::Destroy
*
* Destroy() is called from the derived class to cleanup resources associated
* with the OldExtension.
*
\***************************************************************************/

void
OldExtension::Destroy()
{
    //
    // Since the OldExtension is being destroyed, need to ensure that it is no 
    // longer "attached" to the Gadget being extended
    //

    if ((m_pridListen != 0) && (m_hgadSubject != NULL)) {
        OldExtension * pb;
        if (GetGadgetProperty(m_hgadSubject, m_pridListen, (void **) &pb)) {
            if (pb == this) {
                RemoveGadgetProperty(m_hgadSubject, m_pridListen);
            }
        }
    }

    if (m_hgadListen != NULL) {
        ::DeleteHandle(m_hgadListen);
        m_hgadListen = NULL;
    }
}


/***************************************************************************\
*
* OldExtension::DeleteHandle
*
* DeleteHandle() starts the destruction process for the OldExtension.
*
\***************************************************************************/

void
OldExtension::DeleteHandle()
{
    if (m_hgadListen != NULL) {
        HGADGET hgad = m_hgadListen;
        m_hgadListen = NULL;
        ::DeleteHandle(hgad);
    }
}


/***************************************************************************\
*
* OldExtension::ListenProc
*
* ListenProc() is called on the MessageGadget Listener attached to the
* RootGadget.
*
\***************************************************************************/

HRESULT
OldExtension::ListenProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    OldExtension * pb = (OldExtension *) pvCur;

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        if (pmsg->nMsg == GM_DESTROY) {
            GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
            if (pmsgD->nCode == GDESTROY_FINAL) {
                pb->OnDestroyListener();
                return DU_S_PARTIAL;
            }
        } else if (pb->m_fAsyncDestroy && (pmsg->nMsg == s_msgidAsyncDestroy)) {
            pb->OnAsyncDestroy();
            return DU_S_PARTIAL;
        }
        break;

    case GMF_EVENT:
        if (pmsg->nMsg == GM_DESTROY) {
            if (((GMSG_DESTROY *) pmsg)->nCode == GDESTROY_FINAL) {
                pb->OnDestroySubject();
                return DU_S_PARTIAL;
            }
        }
        break;
    }

    return DU_S_NOTHANDLED;
}


/***************************************************************************\
*
* OldExtension::OnRemoveExisting
*
* OnRemoveExisting() is called when creating a new OldExtension to remove an
* existing OldExtension already attached to the subject Gadget.
*
\***************************************************************************/

void
OldExtension::OnRemoveExisting()
{

}


/***************************************************************************\
*
* OldExtension::OnDestroySubject
*
* OnDestroySubject() notifies the derived OldExtension that the subject Gadget
* being modified has been destroyed.
*
\***************************************************************************/

void
OldExtension::OnDestroySubject()
{

}


/***************************************************************************\
*
* OldExtension::OnDestroyListener
*
* OnDestroyListener() notifies the derived OldExtension that the internal
* "Listener" Gadget has been destroyed and that the OldExtension should start
* its destruction process.
*
\***************************************************************************/

void
OldExtension::OnDestroyListener()
{

}


/***************************************************************************\
*
* OldExtension::OnAsyncDestroy
*
* OnAsyncDestroy() is called when the OldExtension receives an asynchronous
* destruction message that was previously posted.  This provides the derived
* OldExtension an opportunity to start the destruction process without being
* nested several levels.
*
\***************************************************************************/

void
OldExtension::OnAsyncDestroy()
{

}


/***************************************************************************\
*
* OldExtension::PostAsyncDestroy
*
* PostAsyncDestroy() queues an asynchronous destruction message.  This 
* provides the derived OldExtension an opportunity to start the destruction 
* process without being nested several levels.
*
\***************************************************************************/

void
OldExtension::PostAsyncDestroy()
{
    AssertMsg(m_fAsyncDestroy, 
            "Must create OldExtension with oAsyncDestroy if want to destroy asynchronously");
    Assert(s_msgidAsyncDestroy != 0);
    AssertMsg(m_hgadListen, "Must still have a valid Listener");

    EventMsg msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.hgadMsg = m_hgadListen;
    msg.nMsg    = s_msgidAsyncDestroy;

    DUserPostEvent(&msg, 0);
}


/***************************************************************************\
*
* OldExtension::GetExtension
*
* GetExtension() retrieves the OldExtension of a specific type currently 
* attached to the subject Gadget.
*
\***************************************************************************/

OldExtension *
OldExtension::GetExtension(HGADGET hgadSubject, PRID prid)
{
    OldExtension * pbExist;
    if (GetGadgetProperty(hgadSubject, prid, (void **) &pbExist)) {
        AssertMsg(pbExist != NULL, "Attached OldExtension must be valid");
        return pbExist;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldextension.inl ===
#if !defined(CTRL__Extension_inl__INCLUDED)
#define CTRL__Extension_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline OldExtension::OldExtension()
{

}


#endif // CTRL__Extension_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldextension.h ===
#if !defined(CTRL__OldExtension_h__INCLUDED)
#define CTRL__OldExtension_h__INCLUDED
#pragma once

class OldExtension
{
// Construction
public:
    inline  OldExtension();
    virtual ~OldExtension();

    enum EOptions
    {
        oUseExisting    = 0x00000001,   // Use existing Extension if already attached
        oAsyncDestroy   = 0x00000002,   // Use asynchronous destruction
    };

            HRESULT     Create(HGADGET hgadChange, const GUID * pguid, PRID * pprid, UINT nOptions);
            void        Destroy();
            void        DeleteHandle();

// Implementation
protected:
    virtual void        OnRemoveExisting();
    virtual void        OnDestroySubject();
    virtual void        OnDestroyListener();
    virtual void        OnAsyncDestroy();

            void        PostAsyncDestroy();
    static  OldExtension * GetExtension(HGADGET hgadSubject, PRID prid);

private:
    static  HRESULT CALLBACK
                        ListenProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg);

// Data
protected:
            HGADGET     m_hgadSubject;  // Gadget being "extended"
            HGADGET     m_hgadListen;   // Listener for destruction
            PRID        m_pridListen;   // PRID for Extension
            BOOL        m_fAsyncDestroy:1;
                                        // Need to destroy asynchronously

    static  MSGID       s_msgidAsyncDestroy;
};


#include "OldExtension.inl"

#endif // CTRL__OldExtension_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldinterpolation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldInterpolation.h"

const IID * OldLinearInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ILinearInterpolation),
    NULL
};

const IID * OldLogInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ILogInterpolation),
    NULL
};

const IID * OldExpInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(IExpInterpolation),
    NULL
};

const IID * OldSInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ISInterpolation),
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CTRL__Public_h__INCLUDED)
#define CTRL__Public_h__INCLUDED

#include "Init.h"
#include "GdiHelp.h"

#endif // CTRL__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\sequence.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Sequence.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL
IsSameTime(float flA, float flB)
{
    float flDelta = flA - flB;
    return ((flDelta < 0.005f) && (flDelta > -0.005f));
}


/***************************************************************************\
*****************************************************************************
*
* class DuSequence
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuSequence::ApiOnEvent
*
* ApiOnEvent() processes events.
*
\***************************************************************************/

HRESULT
DuSequence::ApiOnEvent(EventMsg * pmsg)
{
    if (pmsg->nMsg == GM_DESTROY) {
        GMSG_DESTROY * pmsgD = static_cast<GMSG_DESTROY *>(pmsg);
        switch (GET_EVENT_DEST(pmsgD))
        {
        case GMF_DIRECT:
            //
            // We are being destroyed.
            //

            Stop();
            return DU_S_COMPLETE;

        case GMF_EVENT:
            //
            // Our Subject is being destroyed
            //

            Stop();
            return DU_S_PARTIAL;
        }
    }

    return SListener::ApiOnEvent(pmsg);
}


/***************************************************************************\
*
* DuSequence::ApiGetLength
*
* ApiGetLength() returns the length of a sequence, not including the initial
* delay.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetLength(Sequence::GetLengthMsg * pmsg)
{
    int cItems = m_arSeqData.GetSize();
    if (cItems <= 0) {
        pmsg->flLength = 0.0f;
    } else {
        pmsg->flLength = m_arSeqData[cItems - 1].flTime;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetDelay
*
* ApiGetDelay() returns the delay to wait before starting the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetDelay(Sequence::GetDelayMsg * pmsg)
{
    pmsg->flDelay = m_flDelay;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetDelay
*
* ApiSetDelay() changes the delay to wait before starting the sequence.
*
\***************************************************************************/

HRESULT        
DuSequence::ApiSetDelay(Sequence::SetDelayMsg * pmsg)
{
    if (pmsg->flDelay < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    m_flDelay = pmsg->flDelay;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetFlow
*
* ApiGetFlow() returns the Flow being used through-out the sequence to 
* modify a given Subject.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetFlow(Sequence::GetFlowMsg * pmsg)
{
    SafeAddRef(m_pflow);
    pmsg->pflow = m_pflow;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetFlow
*
* ApiSetFlow() changes the Flow being used through-out the sequence to 
* modify a given Subject.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetFlow(Sequence::SetFlowMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    SafeRelease(m_pflow);
    SafeAddRef(pmsg->pflow);
    m_pflow = pmsg->pflow;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetFramePause
*
* ApiGetFramePause() returns the default "dwPause" value used for 
* Animations during playback.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetFramePause(Sequence::GetFramePauseMsg * pmsg)
{
    pmsg->dwPause = m_dwFramePause;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetFramePause
*
* ApiSetFramePause() changes the default "dwPause" value used for 
* Animations during playback.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetFramePause(Sequence::SetFramePauseMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    m_dwFramePause = pmsg->dwPause;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetKeyFrameCount
*
* ApiGetKeyFrameCount() return the number of KeyFrames used in the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetKeyFrameCount(Sequence::GetKeyFrameCountMsg * pmsg)
{
    pmsg->cFrames = m_arSeqData.GetSize();
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiAddKeyFrame
*
* ApiAddKeyFrame() adds a new KeyFrame at the specified time.  If a KeyFrame
* already exists at the given time, that KeyFrame will be returned.
*
\***************************************************************************/

HRESULT
DuSequence::ApiAddKeyFrame(Sequence::AddKeyFrameMsg * pmsg)
{
    if (pmsg->flTime < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Search the sequence to determine what slot to insert the new data in.  We
    // want to keep all time in order.
    //

    int cItems = m_arSeqData.GetSize();
    int idxAdd = cItems;
    for (int idx = 0; idx < cItems; idx++) {
        if (IsSameTime(m_arSeqData[idx].flTime, pmsg->flTime)) {
            pmsg->idxKeyFrame = idx;
            return S_OK;
        }

        if (m_arSeqData[idx].flTime > pmsg->flTime) {
            idxAdd = idx;
        }
    }


    //
    // Add a new KeyFrame at this time
    //

    SeqData data;
    data.flTime = pmsg->flTime;
    data.pkf    = NULL;
    data.pipol  = NULL;

    if (!m_arSeqData.InsertAt(idxAdd, data)) {
        return E_OUTOFMEMORY;
    }

    pmsg->idxKeyFrame = idxAdd;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiRemoveKeyFrame
*
* ApiRemoveKeyFrame() removes the specified KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiRemoveKeyFrame(Sequence::RemoveKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    ClientFree(data.pkf);
    SafeRelease(data.pipol);

    m_arSeqData.RemoveAt(pmsg->idxKeyFrame);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiRemoveAllKeyFrames
*
* ApiRemoveAllKeyFrames() removes all KeyFrames.
*
\***************************************************************************/

HRESULT
DuSequence::ApiRemoveAllKeyFrames(Sequence::RemoveAllKeyFramesMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    RemoveAllKeyFrames();

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiFindKeyFrame
*
* ApiFindKeyFrame() finds the KeyFrame at the given time.
*
\***************************************************************************/

HRESULT
DuSequence::ApiFindKeyFrame(Sequence::FindKeyFrameMsg * pmsg)
{
    FindAtTime(pmsg->flTime, &pmsg->idxKeyFrame);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetTime
*
* ApiGetTime() returns the time at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetTime(Sequence::GetTimeMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    pmsg->flTime = m_arSeqData[pmsg->idxKeyFrame].flTime;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetTime
*
* ApiSetTime() changes the time of a given KeyFrame.  This function will
* reorder keyframes to maintain proper time order.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetTime(Sequence::SetTimeMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (pmsg->flTime < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    m_arSeqData[pmsg->idxKeyFrame].flTime = pmsg->flTime;


    //
    // We have changed the time of one of the KeyFrames, so we need to re-sort.
    //

    SortKeyFrames();

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetKeyFrame
*
* ApiGetKeyFrame() returns Flow-specific data at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetKeyFrame(Sequence::GetKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    if (data.pkf == NULL) {
        PromptInvalid("KeyFrame has not been set");
        return E_INVALIDARG;
    }

    if (pmsg->pkf->cbSize < data.pkf->cbSize) {
        PromptInvalid("cbSize is not large enough to store KeyFrame");
        return E_INVALIDARG;
    }

    CopyMemory(pmsg->pkf, data.pkf, data.pkf->cbSize);
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetKeyFrame
*
* ApiSetKeyFrame() changes Flow-specific data at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetKeyFrame(Sequence::SetKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (pmsg->pkfSrc->cbSize <= 0) {
        PromptInvalid("cbSize must be set");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Copy and store the KeyFrame
    //
    
    int cbAlloc = pmsg->pkfSrc->cbSize;
    DUser::KeyFrame * pkfCopy = reinterpret_cast<DUser::KeyFrame *> (ClientAlloc(cbAlloc));
    if (pkfCopy == NULL) {
        return E_OUTOFMEMORY;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    ClientFree(data.pkf);
    CopyMemory(pkfCopy, pmsg->pkfSrc, cbAlloc);
    data.pkf = pkfCopy;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetInterpolation
*
* ApiGetInterpolation() returns the Interpolation used to move to the next
* keyframe.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetInterpolation(Sequence::GetInterpolationMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    SafeAddRef(data.pipol);
    pmsg->pipol = data.pipol;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetInterpolation
*
* ApiSetInterpolation() changes the Interpolation used to move to the next
* keyframe.
*
\***************************************************************************/

HRESULT     
DuSequence::ApiSetInterpolation(Sequence::SetInterpolationMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Copy and store the KeyFrame
    //

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    SafeRelease(data.pipol);
    SafeAddRef(pmsg->pipol);
    data.pipol = pmsg->pipol;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::Play
*
* ApiPlay() executes the Animation sequence for the given Visual.  A
* Sequence only supports animating a single Visual at a given time.  
* Multiple sequences may be created to animate multiple Visuals 
* simultaneously.
*
\***************************************************************************/

HRESULT
DuSequence::ApiPlay(Sequence::PlayMsg * pmsg)
{
    Assert(DEBUG_IsProperTimeOrder());

    //
    // Setup for animation:
    // - Validate all information is filled in.
    // - Ensure no existing Animation.
    // - Determine parameters for Animation.
    //

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }

    Stop();
    AssertMsg(m_arAniData.GetSize() == 0, "Must not have pending Animations");


    //
    // Setup for Animation
    // - Attach as a Listener
    // - Allocate information necessary to create the Animations.
    // - Add a reference to allow the Sequence to fully play.
    //

    hr = pmsg->pgvSubject->AddHandlerG(GM_DESTROY, GetStub());
    if (FAILED(hr)) {
        return hr;
    }
    m_pgvSubject = pmsg->pgvSubject;


    int cItems = m_arSeqData.GetSize();
    if (cItems == 0) {
        return S_OK;
    }
    if (!m_arAniData.SetSize(cItems - 1)) {
        return E_OUTOFMEMORY;
    }

    AddRef();


    //
    // Queue all animations
    //

    for (int idx = 0; idx < cItems - 1; idx++) {
        hr = QueueAnimation(idx);
        if (FAILED(hr)) {
            return hr;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiStop
*
* ApiStop() stops any executing Animation sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiStop(Sequence::StopMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);
    
    Stop(TRUE);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiStop
*
* ApiStop() stops any executing Animation sequence.
*
\***************************************************************************/

void
DuSequence::Stop(BOOL fKillAnimations)
{
    if (IsPlaying()) {
        //
        // To prevent re-entrancy, mark that we are no longer playing.  However,
        // don't remove ourself as a listener until we are done.
        //

        Visual * pgvSubject = m_pgvSubject;
        m_pgvSubject = NULL;


        //
        // Stop any queued Animations.  When doing this, set 
        // m_arAniData[idx].hact to NULL to signal to the Action to not
        // create the Animation.  We need to do this since every Action will
        // get called back.
        //

        if (fKillAnimations) {
            PRID prid = 0;
            VerifyHR(m_pflow->GetPRID(&prid));
            Animation::Stop(pgvSubject, prid);

            int cItems = m_arAniData.GetSize();
            for (int idx = 0; idx < cItems; idx++) {
                HACTION hact = m_arAniData[idx].hact;
                if (hact != NULL) {
                    DeleteHandle(hact);
                    AssertMsg(m_arAniData[idx].hact == NULL, "Ensure Action is destroyed");
                }
            }
        }

        AssertMsg(m_cQueuedAni == 0, "All queued animations should be destroyed");
        m_arAniData.RemoveAll();


        //
        // Notify any listeners that this sequence has completed.
        //

        MSGID msgid = 0;
        const GUID * rgMsg[] = { &__uuidof(Animation::evComplete) };
        if (!FindGadgetMessages(rgMsg, &msgid, 1)) {
            AssertMsg(0, "Animations have not been properly registered");
        }
        
        Animation::CompleteEvent msg;
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = msgid;
        msg.hgadMsg = GetStub()->GetHandle();
        msg.fNormal = !fKillAnimations;
        DUserSendEvent(&msg, 0);


        //
        // Remove ourself as a Listener
        //

        VerifyHR(pgvSubject->RemoveHandlerG(GM_DESTROY, GetStub()));


        //
        // Release outstanding reference from when started Play().
        //

        Release();
    }
}


/***************************************************************************\
*
* DuSequence::QueueAnimation
*
* QueueAnimation() queues an Action to be fired when the specified segment
* of the overall sequence is to be animated.  Since an Animation can only
* animate a single segment, we will build multiple Animations to play the
* entire sequence.
*
\***************************************************************************/

HRESULT
DuSequence::QueueAnimation(
    IN  int idxKeyFrame)                // KeyFrame to setup
{
    AssertMsg((idxKeyFrame < m_arAniData.GetSize()) && (idxKeyFrame >= 0),
            "Must have valid, non-final keyframe");


    SeqData & data1 = m_arSeqData[idxKeyFrame];
    AniData & ad    = m_arAniData[idxKeyFrame];
    ad.pseq         = this;
    ad.idxFrame     = idxKeyFrame;

    //
    // Setup the segment.  If successful, increment m_cQueuedAni to reflect 
    // that the animation has been "enqueued".  We need to wait until all
    // are dequeued before we can "stop" the Animation and allow applications
    // to modify the Sequence.
    //

    HRESULT hr;
    if (IsSameTime(data1.flTime, 0.0f)) {
        //
        // This segment immediate occurs, so directly build the Animation.
        //

        ad.hact = NULL;     // No action
        hr = BuildAnimation(idxKeyFrame);
        if (SUCCEEDED(hr)) {
            m_cQueuedAni++;
        }
    } else {
        //
        // This segment occurs in the future, so build a new Action that will 
        // be signaled when to begin the Animation between the specified 
        // keyframes.
        //

        GMA_ACTION act;
        ZeroMemory(&act, sizeof(act));
        act.cbSize      = sizeof(act);
        act.flDelay     = data1.flTime;
        act.flDuration  = 0.0;
        act.flPeriod    = 0.0;
        act.cRepeat     = 0;
        act.dwPause     = (DWORD) -1;
        act.pfnProc     = DuSequence::ActionProc;
        act.pvData      = &(m_arAniData[idxKeyFrame]);

        if ((ad.hact = CreateAction(&act)) != NULL) {
            m_cQueuedAni++;
            hr = S_OK;
        } else {
            hr = (HRESULT) GetLastError();
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuSequence::BuildAnimation
*
* BuildAnimation() builds the actual Animation for a given segment of the
* sequence.  This function is called by QueueAnimation() (for immediate 
* segments) and ActionProc() (as future segments become ready).
*
\***************************************************************************/

HRESULT
DuSequence::BuildAnimation(
    IN  int idxKeyFrame)                // KeyFrame to animate
{
    //
    // Setup the actual Animation.
    //

    SeqData & data1     = m_arSeqData[idxKeyFrame];
    SeqData & data2     = m_arSeqData[idxKeyFrame + 1];
    float flDuration    = data2.flTime - data1.flTime;

    AssertMsg(m_pflow != NULL, "Must have valid Flow");
    m_pflow->SetKeyFrame(Flow::tBegin, data1.pkf);
    m_pflow->SetKeyFrame(Flow::tEnd, data2.pkf);

    Animation::AniCI aci;
    ZeroMemory(&aci, sizeof(aci));
    aci.cbSize          = sizeof(aci);
    aci.act.flDuration  = flDuration;
    aci.act.flPeriod    = 1;
    aci.act.cRepeat     = 0;
    aci.act.dwPause     = m_dwFramePause;
    aci.pgvSubject      = m_pgvSubject;
    aci.pipol           = data1.pipol;
    aci.pgflow          = m_pflow;

    Animation * pani = Animation::Build(&aci);
    if (pani != NULL) {
        MSGID msgid = 0;
        const GUID * rgMsg[] = { &__uuidof(Animation::evComplete) };
        if (!FindGadgetMessages(rgMsg, &msgid, 1)) {
            AssertMsg(0, "Animations have not been properly registered");
        }

        VerifyHR(pani->AddHandlerD(msgid, EVENT_DELEGATE(this, OnAnimationComplete)));
        pani->Release();
        return S_OK;
    } else {
        //
        // Unable to build the Animation, so stop any future Animations.
        //

        Stop();
        return (HRESULT) GetLastError();
    }
}


/***************************************************************************\
*
* DuSequence::ActionProc
*
* ActionProc() is called when the Animation for a given segment is supposed
* to begin.
*
\***************************************************************************/

void CALLBACK
DuSequence::ActionProc(
    IN  GMA_ACTIONINFO * pmai)          // Action Information
{
    AniData * pad       = reinterpret_cast<AniData *>(pmai->pvData);
    DuSequence * pseq   = pad->pseq;
    if (pmai->fFinished) {
        if (pad->hact != NULL) {
            //
            // The Animation was never built, so we need to decrement the
            // number of outstanding Animations.
            //

            pad->hact = NULL;

            AssertMsg(pseq->m_cQueuedAni > 0, "Must have an outstanding Animation");
            if (--pseq->m_cQueuedAni == 0) {
                pseq->Stop(FALSE);
            }
        }
        return;
    }

    pad->hact = NULL;
    pseq->BuildAnimation(pad->idxFrame);
}


/***************************************************************************\
*
* DuSequence::OnAnimationComplete
*
* OnAnimationComplete() is called when an Animation has been completed and
* is no longer attached to the subject.
*
\***************************************************************************/

UINT CALLBACK
DuSequence::OnAnimationComplete(EventMsg * pmsg)
{
    //
    // If all outstanding Animations have ended, then stop the playback.
    //

    UNREFERENCED_PARAMETER(pmsg);

    AssertMsg(m_cQueuedAni > 0, "Must have an outstanding Animation");
    if (--m_cQueuedAni == 0) {
        Stop(FALSE);
    }

    return DU_S_COMPLETE;
}


/***************************************************************************\
*
* DuSequence::ApiReset
*
* ApiReset() resets the given Visual to the beginning of the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiReset(Sequence::ResetMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_arSeqData.GetSize() > 0) {
        ResetSubject(pmsg->pgvSubject, 0);
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGotoTime
*
* ApiGotoTime() applies all keyframes to the given Visual that would applied
* at a given time.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGotoTime(Sequence::GotoTimeMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Find the keyframe before the time
    //

    int cItems = m_arSeqData.GetSize();
    if (cItems == 0) {
        //
        // No key frames, so nothing to do.
        //

        return S_OK;
    } else if (cItems == 1) {
        //
        // Only one keyframe, so just reset the object
        //

        ResetSubject(pmsg->pgvSubject, 0);
    } else {
        //
        // Multiple keyframes- need to determine the closest keyframe.
        // - If land on a keyframe, then "exact"
        // - If before all keyframes, idxFrame = -1;
        // - If after all keyframes, idxFrame = cItems
        // - If in the middle, idxFrame = first frame
        //

        int idxFrame    = -1;
        BOOL fExact     = FALSE;
        int cItems      = m_arSeqData.GetSize();

        if (pmsg->flTime > m_arSeqData[cItems - 1].flTime) {
            idxFrame = cItems;
        } else {
            for (int idx = 0; idx < cItems; idx++) {
                SeqData & data = m_arSeqData[idx];
                if (data.pkf != NULL) {
                    if (IsSameTime(data.flTime, pmsg->flTime)) {
                        idxFrame    = idx;
                        fExact      = TRUE;
                        break;
                    } else if (data.flTime > pmsg->flTime) {
                        idxFrame    = idx - 1;
                        fExact      = FALSE;
                        break;
                    }
                }
            }
        }


        if (fExact) {
            //
            // Exactly landed on a keyframe, so set directly
            //

            ResetSubject(pmsg->pgvSubject, idxFrame);
        } else {
            //
            // Interpolate between two keyframes.  Since this wasn't an exact
            // match, we need to cap the keyframes.
            //

            if (idxFrame < 0) {
                ResetSubject(pmsg->pgvSubject, 0);
            } else if (idxFrame >= cItems) {
                ResetSubject(pmsg->pgvSubject, cItems - 1);
            } else {
                SeqData & dataA     = m_arSeqData[idxFrame];
                SeqData & dataB     = m_arSeqData[idxFrame + 1];

                float flTimeA       = dataA.flTime;
                float flTimeB       = dataB.flTime;
                float flProgress    = (pmsg->flTime - flTimeA) / (flTimeB - flTimeA);
                if (flProgress > 1.0f) {
                    flProgress = 1.0f;
                }

                m_pflow->SetKeyFrame(Flow::tBegin, dataA.pkf);
                m_pflow->SetKeyFrame(Flow::tEnd, dataB.pkf);

                m_pflow->OnAction(pmsg->pgvSubject, dataA.pipol, flProgress);
            }
        }
    }
    
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::RemoveAllKeyFrames
*
* RemoveAllKeyFrames() removes all KeyFrames.
*
\***************************************************************************/

void
DuSequence::RemoveAllKeyFrames()
{
    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        SeqData & data = m_arSeqData[idx];
        ClientFree(data.pkf);
        SafeRelease(data.pipol);
    }

    m_arSeqData.RemoveAll();
}


/***************************************************************************\
*
* DuSequence::ResetSubject
*
* ResetSubject() resets the given subject to the beginning of the Sequence.
*
\***************************************************************************/

void 
DuSequence::ResetSubject(Visual * pgvSubject, int idxFrame)
{
    m_pflow->SetKeyFrame(Flow::tBegin, m_arSeqData[idxFrame].pkf);
    m_pflow->OnReset(pgvSubject);
}


/***************************************************************************\
*
* DuSequence::CompareItems
*
* CompareItems() is called from SortKeyFrames() to sort two individual
* KeyFrames by time.
*
\***************************************************************************/

int
DuSequence::CompareItems(
    IN  const void * pva,               // First SeqData
    IN  const void * pvb)               // Second SeqData
{
    float flTimeA = ((SeqData *) pva)->flTime;
    float flTimeB = ((SeqData *) pvb)->flTime;

    if (flTimeA < flTimeB) {
        return -1;
    } else if (flTimeA > flTimeB) {
        return 1;
    } else {
        return 0;
    }
}


/***************************************************************************\
*
* DuSequence::FindAtTime
*
* FindAtTime() finds the KeyFrame at the given time.
*
\***************************************************************************/

void
DuSequence::FindAtTime(
    IN  float flTime,                   // Time of KeyFrame
    OUT int * pidxKeyFrame              // KeyFrame, if found
    ) const
{
    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        SeqData & data = m_arSeqData[idx];
        if (data.pkf != NULL) {
            if (IsSameTime(data.flTime, flTime)) {
                *pidxKeyFrame = idx;
                return;
            }
        }
    }

    *pidxKeyFrame = -1; // Not found
}


/***************************************************************************\
*
* DuSequence::CheckComplete
*
* CheckComplete() determines if all information for the Sequence has been 
* filled in.  This is necessary when use the sequence to play animations.
*
\***************************************************************************/

HRESULT
DuSequence::CheckComplete() const
{
    if (m_pflow == NULL) {
        PromptInvalid("Flow has not been specified");
        return E_INVALIDARG;
    }

    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arSeqData[idx].pkf == NULL) {
            PromptInvalid("KeyFrame information has not been specified");
            return E_INVALIDARG;
        }
        if (m_arSeqData[idx].pipol == NULL) {
            PromptInvalid("Interpolation has not been specified");
            return E_INVALIDARG;
        }
    }

    return S_OK;
}


#if DBG

/***************************************************************************\
*
* DuSequence::DEBUG_IsProperTimeOrder
*
* DEBUG_IsProperTimeOrder() validates that all keyframes are in increasing
* time order.
*
\***************************************************************************/

BOOL
DuSequence::DEBUG_IsProperTimeOrder() const
{
    float flTime = 0;

    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arSeqData[idx].flTime < flTime) {
            return FALSE;
        }

        flTime = m_arSeqData[idx].flTime;
    }

    return TRUE;
}

#endif // DBG

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\sequence.h ===
#if !defined(CTRL__Sequence_h__INCLUDED)
#define CTRL__Sequence_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuSequence :
        public SequenceImpl<DuSequence, SListener>
{
// Construction
public:
    inline  DuSequence();
    inline  ~DuSequence();

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiAddRef(Sequence::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Sequence::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiGetLength(Sequence::GetLengthMsg * pmsg);
    dapi    HRESULT     ApiGetDelay(Sequence::GetDelayMsg * pmsg);
    dapi    HRESULT     ApiSetDelay(Sequence::SetDelayMsg * pmsg);
    dapi    HRESULT     ApiGetFlow(Sequence::GetFlowMsg * pmsg);
    dapi    HRESULT     ApiSetFlow(Sequence::SetFlowMsg * pmsg);
    dapi    HRESULT     ApiGetFramePause(Sequence::GetFramePauseMsg * pmsg);
    dapi    HRESULT     ApiSetFramePause(Sequence::SetFramePauseMsg * pmsg);

    dapi    HRESULT     ApiGetKeyFrameCount(Sequence::GetKeyFrameCountMsg * pmsg);
    dapi    HRESULT     ApiAddKeyFrame(Sequence::AddKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiRemoveKeyFrame(Sequence::RemoveKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiRemoveAllKeyFrames(Sequence::RemoveAllKeyFramesMsg * pmsg);
    dapi    HRESULT     ApiFindKeyFrame(Sequence::FindKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiGetTime(Sequence::GetTimeMsg * pmsg);
    dapi    HRESULT     ApiSetTime(Sequence::SetTimeMsg * pmsg);
    dapi    HRESULT     ApiGetKeyFrame(Sequence::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Sequence::SetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiGetInterpolation(Sequence::GetInterpolationMsg * pmsg);
    dapi    HRESULT     ApiSetInterpolation(Sequence::SetInterpolationMsg * pmsg);

    dapi    HRESULT     ApiPlay(Sequence::PlayMsg * pmsg);
    dapi    HRESULT     ApiStop(Sequence::StopMsg * pmsg);
    dapi    HRESULT     ApiReset(Sequence::ResetMsg * pmsg);
    dapi    HRESULT     ApiGotoTime(Sequence::GotoTimeMsg * pmsg);

// Implementation
protected:
    inline  void        AddRef();
    inline  void        Release(); 

            void        RemoveAllKeyFrames();

    inline  void        SortKeyFrames();
    static  int __cdecl CompareItems(const void * pva, const void * pvb);
            void        FindAtTime(float flTime, int * pidxKeyFrame) const;
            void        ResetSubject(Visual * pgvSubject, int idxFrame);

    inline  BOOL        IsPlaying() const;
            HRESULT     QueueAnimation(int idxKeyFrame);
            HRESULT     BuildAnimation(int idxKeyFrame);
            void        Stop(BOOL fKillAnimations = TRUE);
    static  void CALLBACK  
                        ActionProc(GMA_ACTIONINFO * pmai);
            UINT CALLBACK 
                        OnAnimationComplete(EventMsg * pmsg);

            HRESULT     CheckComplete() const;
#if DBG
            BOOL        DEBUG_IsProperTimeOrder() const;
#endif

// Data
protected:
    struct SeqData
    {
        float           flTime;         // Time of current keyframe
        DUser::KeyFrame *
                        pkf;            // Information for this KeyFrame
        Interpolation * pipol;          // Interpolation to next KeyFrame
    };

    struct AniData
    {
        DuSequence *    pseq;           // Owning Sequence
        int             idxFrame;       // 1st KeyFrame of specific Animation
        HACTION         hact;           // Action of outstanding Animation
    };

            UINT        m_cRef;         // Reference count
            float       m_flDelay;      // Delay before starting animation
            Flow *      m_pflow;        // Flow used between keyframes
            Visual *    m_pgvSubject;   // Visual being animated
            int         m_cQueuedAni;   // Outstanding queued animations
            DWORD       m_dwFramePause; // Generic frame pause

            GArrayF<SeqData>
                        m_arSeqData;
            GArrayF<AniData>
                        m_arAniData;
};

#endif // ENABLE_MSGTABLE_API

#include "Sequence.inl"

#endif // CTRL__Sequence_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\sequence.inl ===
#if !defined(CTRL__Sequence_inl__INCLUDED)
#define CTRL__Sequence_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuSequence
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuSequence::DuSequence()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline
DuSequence::~DuSequence()
{
    Stop();
    RemoveAllKeyFrames();

    SafeRelease(m_pflow);
}


//------------------------------------------------------------------------------
inline void
DuSequence::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuSequence::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


//------------------------------------------------------------------------------
inline void
DuSequence::SortKeyFrames()
{
    qsort(m_arSeqData.GetData(), m_arSeqData.GetSize(), sizeof(SeqData), CompareItems);
}


//------------------------------------------------------------------------------
inline BOOL
DuSequence::IsPlaying() const
{
    return m_pgvSubject != NULL;
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Sequence_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(CTRL__StdAfx_h__INCLUDED)
#define CTRL__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // CTRL__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\oldinterpolation.h ===
#if !defined(CTRL__OldInterpolation_h__INCLUDED)
#define CTRL__OldInterpolation_h__INCLUDED
#pragma once

#include "SmObject.h"

/***************************************************************************\
*****************************************************************************
*
* class OldInterpolationT
*
* OldInterpolationT defines a common implementation class for building
* Interpolation functions that can be used with Animations in DirectUser.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface>
class OldInterpolationT : public SmObjectT<base, iface>
{
// Operations
public:
    static HRESULT
    Build(REFIID riid, void ** ppv)
    {
        OldInterpolationT<base, iface> * pObj = new OldInterpolationT<base, iface>;
        if (pObj != NULL) {
            pObj->m_cRef = 0;
            
            HRESULT hr = pObj->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                delete pObj;
            }
            return hr;
        } else {
            return E_OUTOFMEMORY;
        }
    }
};


/***************************************************************************\
*****************************************************************************
*
* class OldLinearInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldLinearInterpolation : public ILinearInterpolation
{
public:
    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        return (1.0f - flProgress) * flStart + flProgress * flEnd;
    }

protected:
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldLogInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldLogInterpolation : public ILogInterpolation
{
// Operations
public:
    inline  OldLogInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        float flMax = (float) log10(m_flScale * 9.0f + 1.0f);
        float flT   = (float) log10(flProgress * m_flScale * 9.0f + 1.0f) / flMax;
        return (1.0f - flT) * flStart + flT * flEnd;
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldExpInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldExpInterpolation : public IExpInterpolation
{
// Operations
public:
    inline  OldExpInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        double dflProgress = flProgress;
        double dflStart = flStart;
        double dflEnd = flEnd;
        double dflScale = m_flScale;

        double dflMax = (((10.0 * dflScale) - 1.0) / 9.0);
        double dflT   = (((pow(10.0 * dflScale, dflProgress) - 1.0) / 9.0) / dflMax);
        return (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldSInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldSInterpolation : public ISInterpolation
{
// Operations
public:
    inline  OldSInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        //
        // Slow - fast - slow
        //

        double dflProgress = flProgress;
        double dflStart = flStart;
        double dflEnd = flEnd;
        double dflScale = m_flScale;
        double dflMax;
        double dflT;

        if (dflProgress < 0.5) {
            double dflPartProgress = dflProgress * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        } else {
            double dflPartProgress = (1.0 - dflProgress) * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = 1.0 - ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        }

        return (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


#endif // CTRL__OldInterpolation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\guids.c ===
#pragma warning(disable: 4514)      // unreferenced inline/local function has been removed
#pragma warning(push, 3)

#include <objbase.h>
#include <dxtguid.c>
#include <initguid.h>
#include <ddraw.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\duser.cpp ===
// DUser.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "_DUser.h"

#pragma comment(lib, "GdiPlus")

//
// Downlevel delay load support (need to link to dload.lib)
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
Downlevel_DelayLoadFailureHook(
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = Downlevel_DelayLoadFailureHook;


extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved);
extern "C" BOOL WINAPI RawDllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved);

extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;


/***************************************************************************\
*
* DllMain
*
* DllMain() is called after the CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // At this point, all global objects have been fully constructed.
        //

        if (FAILED(ResourceManager::Create())) {
            return FALSE;
        }

        if (FAILED(InitCore()) ||
            FAILED(InitCtrl())) {

            return FALSE;
        }

        {
            InitStub is;
        }

        break;
        
    case DLL_PROCESS_DETACH:
        //
        // At this point, no global objects have been destructed.
        //

        ResourceManager::xwDestroy();
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        //
        // NOTE: We can NOT call ResourceManager::xwNotifyThreadDestroyNL() to
        // post clean-up, since we are now in the "Loader Lock" and can not 
        // safely perform the cleanup because of deadlocks.
        //
        
        break;
    }

    return TRUE;
}


/***************************************************************************\
*
* RawDllMain
*
* RawDllMain() is called after the before CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
RawDllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // At this point, no global objects have been constructed.
        //

        g_hDll = (HINSTANCE) hModule;

        if (FAILED(CreateProcessHeap())) {
            return FALSE;
        }

        break;
        
    case DLL_PROCESS_DETACH:
        //
        // At this point, all global objects have been destructed.
        //

        DestroyProcessHeap();


        //
        // Dump any CRT memory leaks here.  When using a shared CRT DLL, we only
        // want to dump memory leaks when everything has had a chance to clean 
        // up.  We do this in a common place in AutoUtil.
        //
        // When using private static-linked CRT, GREEN_STATIC_CRT will be 
        // defined, allowing each individual module to dump their own memory 
        // leaks.
        //

#if DBG
        _CrtDumpMemoryLeaks();
#endif // DBG
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\ctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Ctrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\stdafx.h ===
#if !defined(DUSER__StdAfx_h__INCLUDED)
#define DUSER__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // DUSER__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DUser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DUser.rc
//
#define IDD_DLG                         100
#define IDB_SPYICON                     101
#define IDD_Assert                      101
#define IDC_ebcFileName                 1000
#define IDC_ebcExpression               1001
#define IDC_ebcLineNum                  1002
#define IDC_IGNORE                      1003
#define IDC_COPY                        1004
#define IDC_lvcCallStack                1005
#define IDC_DEBUG                       1008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\duser\_duser.h ===
#if !defined(DUSER__DUser_h__INCLUDED)
#define DUSER__DUser_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserMotionP.h>
#include <DUserCtrlP.h>

#endif // DUSER__DUser_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\hwndcontainer.h ===
#if !defined(WINAPI__HWndContainer_h__INCLUDED)
#define WINAPI__HWndContainer_h__INCLUDED
#pragma once

class HWndContainer : public DuContainer
{
// Construction
public:
			HWndContainer();
	virtual ~HWndContainer();
    static  HRESULT     Build(HWND hwnd, HWndContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htHWndContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Implementation
protected:

// Data
protected:
            HWND        m_hwndOwner;
            SIZE        m_sizePxl;
            BOOL        m_fEnableDragDrop:1;
};


//------------------------------------------------------------------------------
inline HWndContainer * CastHWndContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htHWndContainer)) {
        return (HWndContainer *) pBase;
    }
    return NULL;
}

HWndContainer * GetHWndContainer(DuVisual * pgad);

#endif // WINAPI__HWndContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\hwndcontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "HWndContainer.h"

#include "MsgHelp.h"
#include "Spy.h"

#define PROFILE_DRAW    0

#if PROFILE_DRAW
#include <icecap.h>
#endif

#if DBG
UINT g_uMsgEnableSpy    = RegisterWindowMessage(TEXT("GadgetSpy Enable"));
UINT g_uMsgFindGadget   = RegisterWindowMessage(TEXT("GadgetSpy FindGadget"));
#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HWndContainer * 
GetHWndContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    HWndContainer * pconHWND = CastHWndContainer(pcon);
    return pconHWND;
}


/***************************************************************************\
*****************************************************************************
*
* class HWndContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HWndContainer::HWndContainer()
{
    m_hwndOwner = NULL;
}


//------------------------------------------------------------------------------
HWndContainer::~HWndContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    ContextLock cl;
    Verify(cl.LockNL(ContextLock::edDefer));
    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
HWndContainer::Build(HWND hwnd, HWndContainer ** ppconNew)
{
    // Check parameters
    if (!ValidateHWnd(hwnd)) {
        return E_INVALIDARG;
    }

    // Create a new container
    HWndContainer * pconNew = ClientNew(HWndContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_hwndOwner    = hwnd;

    RECT rcClient;
    GetClientRect(hwnd, &rcClient);
    pconNew->m_sizePxl.cx   = rcClient.right;
    pconNew->m_sizePxl.cy   = rcClient.bottom;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
HWndContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    if ((!InlineIsRectEmpty(prcInvalidContainerPxl)) &&
        (prcInvalidContainerPxl->left <= m_sizePxl.cx) &&
        (prcInvalidContainerPxl->top <= m_sizePxl.cy) &&
        (prcInvalidContainerPxl->right >= 0) &&
        (prcInvalidContainerPxl->bottom >= 0)) {

        // TODO: How do we handle multiple layers / background?

#if 0
        Trace("HWndContainer::OnInvalidate(): %d, %d, %d, %d\n", 
                prcInvalidContainerPxl->left, prcInvalidContainerPxl->top,
                prcInvalidContainerPxl->right, prcInvalidContainerPxl->bottom);
#endif
        InvalidateRect(m_hwndOwner, prcInvalidContainerPxl, TRUE);
    }
}


//------------------------------------------------------------------------------
void
HWndContainer::OnGetRect(RECT * prcDesktopPxl)
{
    GetClientRect(m_hwndOwner, prcDesktopPxl);
    ClientToScreen(m_hwndOwner, (LPPOINT) &(prcDesktopPxl->left));
    ClientToScreen(m_hwndOwner, (LPPOINT) &(prcDesktopPxl->right));
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnStartCapture()
{
    SetCapture(m_hwndOwner);
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnEndCapture()
{
    ReleaseCapture();
}


//------------------------------------------------------------------------------
BOOL
HWndContainer::OnTrackMouseLeave()
{
    TRACKMOUSEEVENT tme;
    tme.cbSize          = sizeof(tme);
    tme.dwFlags         = TME_LEAVE | TME_HOVER;
    tme.dwHoverTime     = HOVER_DEFAULT;
    tme.hwndTrack       = m_hwndOwner;

    return TrackMouseEvent(&tme);
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnSetFocus()
{
    if (GetFocus() != m_hwndOwner) {
        //
        // Setting focus is a little more complicated than pure HWND's.  This is
        // because Gadgets greatly simplify several things
        //
        // 1. SetFocus
        // 2. Setup caret, if any
        //

        //Trace("HWndContainer::OnSetFocus()\n");
        SetFocus(m_hwndOwner);
    }
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    POINT ptCursor;
    if (!GetCursorPos(&ptCursor)) {
        ptCursor.x  = -20000;
        ptCursor.y  = -20000;
    }

    ScreenToClient(m_hwndOwner, &ptCursor);
    *pptContainerPxl = ptCursor;
}


//------------------------------------------------------------------------------
BOOL        
HWndContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    POINT ptContainerPxl;
    *pr = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            GMSG_MOUSECLICK msg;
            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEWHEEL:
        {
            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            // unlike every other mouse message, the x,y params for the
            // mouse wheel are in *screen* coordinates, not *client*
            // coordinates -- convert 'em here to "play along"
            ScreenToClient(m_hwndOwner, &ptContainerPxl);

            GMSG_MOUSEWHEEL msg;
            GdConvertMouseWheelMessage(&msg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEMOVE:
    case WM_MOUSEHOVER:
        {
            GMSG_MOUSE msg;
            GdConvertMouseMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSELEAVE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLeaveMessage();
                return TRUE;
            }
            break;
        }

    case WM_CAPTURECHANGED:
        if (m_hwndOwner != (HWND) lParam) {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLostCapture();
            }
        }
        break;

    //
    // WM_SETFOCUS and WM_KILLFOCUS will restore and save (respectively) Gadget focus only
    // if we are gaining for losing focus from an HWND outside our tree.
    //

    case WM_SETFOCUS:
        {
            if ((m_hwndOwner != (HWND)wParam) && (IsChild(m_hwndOwner, (HWND)wParam) == FALSE)) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    return m_pgadRoot->xdHandleKeyboardFocus(GSC_SET);
                }
            }
            break;
        }

    case WM_KILLFOCUS:
        {
            if ((m_hwndOwner != (HWND)wParam) && (IsChild(m_hwndOwner, (HWND)wParam) == FALSE)) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    return m_pgadRoot->xdHandleKeyboardFocus(GSC_LOST);
                }
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            GMSG_KEYBOARD msg;
            GdConvertKeyboardMessage(&msg, nMsg, wParam, lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardMessage(&msg, nMsgFlags);
            }
            break;
        }

    case WM_ERASEBKGND:
        return TRUE;

    case WM_PAINT:
        if ((!m_fManualDraw) && (m_pgadRoot != NULL)) {
            PAINTSTRUCT ps;
            if (BeginPaint(m_hwndOwner, &ps) != NULL) {

#if PROFILE_DRAW
                StartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif

                {
                    ContextLock cl;
                    if (cl.LockNL(ContextLock::edNone)) {
                        m_pgadRoot->xrDrawTree(NULL, ps.hdc, &ps.rcPaint, 0);
                    }
                }

#if PROFILE_DRAW
                StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif

                EndPaint(m_hwndOwner, &ps);
            }
            return TRUE;
        }
        break;

    case WM_WINDOWPOSCHANGED:
        {
            WINDOWPOS * pwp = (WINDOWPOS *) lParam;

            UINT nFlags = 0;
            if (!TestFlag(pwp->flags, SWP_NOSIZE)) {
                RECT rcClient;
                GetClientRect(m_hwndOwner, &rcClient);

                nFlags |= SGR_SIZE;
                m_sizePxl.cx = rcClient.right;
                m_sizePxl.cy = rcClient.bottom;
            }

            //
            // Even if the window has moved, we don't need to change the 
            // root gadget since it is relative to the container and that
            // has not changed.
            //

            // TODO: Need to change this to SGR_ACTUAL

            if (nFlags != 0) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    VerifyHR(m_pgadRoot->xdSetLogRect(0, 0, m_sizePxl.cx, m_sizePxl.cy, nFlags));
                }
            }
        }
        break;

    case WM_PARENTNOTIFY:

        // TODO: Need to notify the root gadget that an HWND has been created
        //       or destroyed so that it can create an adapter gadget to back
        //       it.

        break;

    case WM_GETROOTGADGET:
        if (m_pgadRoot != NULL) {
            *pr = (LRESULT) m_pgadRoot->GetHandle();
            return TRUE;
        }
        break;
        
#if DBG
    default:
        if (nMsg == g_uMsgEnableSpy) {
            if (m_pgadRoot != NULL) {
                HGADGET hgadSelect = (HGADGET) lParam;
                HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                ContextLock cl;
                if (cl.LockNL(ContextLock::edNone)) {
                    Spy::BuildSpy(m_hwndOwner, m_pgadRoot->GetHandle(), hgadSelect);
                    SetCursor(hcurOld);
                }
            }
        } else if (nMsg == g_uMsgFindGadget) {
            POINT ptFindScreenPxl;
            ptFindScreenPxl.x = GET_X_LPARAM(lParam);
            ptFindScreenPxl.y = GET_Y_LPARAM(lParam);
            ScreenToClient(m_hwndOwner, &ptFindScreenPxl);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edNone)) {
                POINT ptClientPxl;
                DuVisual * pgadFound = m_pgadRoot->FindFromPoint(ptFindScreenPxl, GS_VISIBLE, &ptClientPxl);
                if (wParam) {
                    DuVisual::DEBUG_SetOutline(pgadFound);
                }

                if (pgadFound != NULL) {
                    *pr = (LRESULT) pgadFound->GetHandle();
                    return TRUE;
                }
            }
        }
#endif // DBG
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\hwndhelp.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "HWndHelp.h"

/***************************************************************************\
*****************************************************************************
*
* WindowProc thunks provide a mechanism of attaching a new WNDPROC to an
* existing HWND.  This does not require you to derive from any classes,
* does not use any HWND properties, and can be applied multiple times on the
* same HWND.
*
* Taken from ATLWIN.H
*
*****************************************************************************
\***************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(WNDPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

#define DUSERUNSUBCLASSMESSAGE "DUserUnSubClassMessage"

class WndBridge
{
// Construction
public:
            WndBridge();
            ~WndBridge();
    static  HRESULT     Build(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi);
            HRESULT     Detach(BOOL fForceCleanup);

// Operations
public:
    static  LRESULT CALLBACK
                    RawWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

// Data
protected:
    CWndProcThunk   m_thunkUs;
    ATTACHWNDPROC   m_pfnDelegate;
    void *          m_pvDelegate;
    HWND            m_hwnd;
    WNDPROC         m_pfnOldWndProc;
    BOOL            m_fAnsi;
    UINT            m_msgUnSubClass;

private:
    ULONG           AddRef();
    ULONG           Release();
    LONG            m_cRefs;
    BOOL            m_fAttached;
};


//------------------------------------------------------------------------------
WndBridge::WndBridge()
{
    m_thunkUs.Init(RawWndProc, this);
    m_msgUnSubClass = RegisterWindowMessage(DUSERUNSUBCLASSMESSAGE);
    m_cRefs         = 0;
    m_fAttached     = TRUE;
    m_pvDelegate = m_pfnDelegate = NULL;
}

//------------------------------------------------------------------------------
WndBridge::~WndBridge()
{
    AssertMsg(!m_fAttached, "WndBridge still attached at destruction!");
}

//------------------------------------------------------------------------------
HRESULT
WndBridge::Build(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi)
{
    WndBridge * pBridge = ProcessNew(WndBridge);

    if (pBridge == NULL) {
        return E_OUTOFMEMORY;
    } else if (pBridge->m_msgUnSubClass == 0) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pBridge->m_pvDelegate = pvDelegate;
    pBridge->m_pfnDelegate = pfnDelegate;
    pBridge->m_hwnd = hwnd;
    pBridge->m_fAnsi = fAnsi;

    WNDPROC pProc = (WNDPROC)(pBridge->m_thunkUs.thunk.pThunk);
    WNDPROC pfnOldWndProc = NULL;

    if (fAnsi) {
        pfnOldWndProc = (WNDPROC)::SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LPARAM)pProc);
    } else {
        pfnOldWndProc = (WNDPROC)::SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LPARAM)pProc);
    }

    if (pfnOldWndProc == NULL) {
        //
        // Didn't have a previous WNDPROC, so the call to SWLP failed.
        //

        ProcessDelete(WndBridge, pBridge);
        return E_OUTOFMEMORY;
    }

    pBridge->m_pfnOldWndProc = pfnOldWndProc;

    //
    // Once successfully created, the reference count starts at 1.
    //
    pBridge->m_cRefs = 1;

    return S_OK;
}


//------------------------------------------------------------------------------
LRESULT
WndBridge::RawWndProc(HWND hwndThis, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    WndBridge * pThis = (WndBridge *) hwndThis;

    //
    // Addref the WndBridge object so that we keep it around while we are
    // processing this message.
    //
    pThis->AddRef();

    //
    // Cache these values because we may delete our WndBridge object during
    // the processing of certain messages.
    //

    HWND hwnd = pThis->m_hwnd;
    WNDPROC pfnOldWndProc = pThis->m_pfnOldWndProc;
    BOOL fAnsi = pThis->m_fAnsi;

    LRESULT lRet = 0;
    BOOL fHandled = FALSE;

    if (nMsg == pThis->m_msgUnSubClass) {
        //
        // We received our special message to detach.  Make sure it is intended
        // for us (by matching proc and additional param).
        //
        if (wParam == (WPARAM)pThis->m_pfnDelegate && lParam == (LPARAM)pThis->m_pvDelegate) {
            lRet = (S_OK == pThis->Detach(FALSE)) ? TRUE :  FALSE;
            fHandled = TRUE;
        }
    } else {
        //
        // Pass this message to our delegate function.
        //
        if (pThis->m_pfnDelegate != NULL) {
            fHandled = pThis->m_pfnDelegate(pThis->m_pvDelegate, hwnd, nMsg, wParam, lParam, &lRet);
        }

        //
        // Handle WM_NCDESTROY explicitly to forcibly clean up.
        //
        if (nMsg == WM_NCDESTROY) {
            //
            // The fact that we received this message means that we are still
            // in the call chain.  This is our last chance to clean up, and
            // no other message should be received by this window proc again.
            // It is OK to force a cleanup now.
            //
            pThis->Detach(TRUE);


            //
            // Always pass the WM_NCDESTROY message down the chain!
            //
            fHandled = FALSE;
        }
    }

    //
    // If our delegate function didn't handle this message, pass it on down the chain.
    //
    if (!fHandled) {
        if (fAnsi) {
            lRet = CallWindowProcA(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
        } else {
            lRet = CallWindowProcW(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
        }
    }

    //
    // Release our reference.  The WndBridge object may evaporate after this.
    //
    pThis->Release();

    return lRet;
}

//------------------------------------------------------------------------------
// S_OK -> not attached
// S_FALSE -> still attached
HRESULT
WndBridge::Detach(BOOL fForceCleanup)
{
    HRESULT hr = S_FALSE;
    BOOL fCleanup = fForceCleanup;

    //
    // If we have already detached, return immediately.
    //

    if (!m_fAttached) {
        return S_OK;
    }

    //
    // When we detach, we simply break our connection to the delegate proc.
    //

    m_pfnDelegate  = NULL;
    m_pvDelegate   = NULL;

    if (!fForceCleanup) {
        //
        // Get the pointers to our thunk proc and the current window proc.
        //

        WNDPROC pfnThunk = (WNDPROC)m_thunkUs.thunk.pThunk;
        WNDPROC pfnWndProc = NULL;
        if (m_fAnsi) {
            pfnWndProc = (WNDPROC)::GetWindowLongPtrA(m_hwnd, GWLP_WNDPROC);
        } else {
            pfnWndProc = (WNDPROC)::GetWindowLongPtrW(m_hwnd, GWLP_WNDPROC);
        }
        AssertMsg(pfnWndProc != NULL, "Must always have a window proc!");

        //
        // If the current window proc is our own thunk proc, then we can
        // clean up more completely.
        //

        fCleanup = (pfnWndProc == pfnThunk);
    }

    if (fCleanup) {
        if (m_fAnsi) {
            ::SetWindowLongPtrA(m_hwnd, GWLP_WNDPROC, (LPARAM)m_pfnOldWndProc);
        } else {
            ::SetWindowLongPtrW(m_hwnd, GWLP_WNDPROC, (LPARAM)m_pfnOldWndProc);
        }

        m_fAttached = FALSE;
        Release();
        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
ULONG WndBridge::AddRef()
{
    return InterlockedIncrement(&m_cRefs);
}

//------------------------------------------------------------------------------
ULONG WndBridge::Release()
{
    ULONG cRefs = InterlockedDecrement(&m_cRefs);

    if (cRefs == 0) {
        ProcessDelete(WndBridge, this);
    }

    return cRefs;
}

//------------------------------------------------------------------------------
HRESULT
GdAttachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi)
{
    return WndBridge::Build(hwnd, pfnDelegate, pvDelegate, fAnsi);
}

//------------------------------------------------------------------------------
HRESULT
GdDetachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate)
{
    UINT msgUnSubClass = RegisterWindowMessage(DUSERUNSUBCLASSMESSAGE);

    if (msgUnSubClass == 0) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (SendMessage(hwnd, msgUnSubClass, (WPARAM) pfnDelegate, (LPARAM) pvDelegate)) {
        return S_OK;
    } else {
        PromptInvalid("Unable to find subclass.");
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\dxcontainer.h ===
#if !defined(WINAPI__DxContainer_h__INCLUDED)
#define WINAPI__DxContainer_h__INCLUDED
#pragma once

class DxContainer : public DuContainer
{
// Construction
public:
            DxContainer();
    virtual ~DxContainer();
    static  HRESULT     Build(const RECT * prcContainerPxl, DxContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htDxContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Data
protected:
    RECT        m_rcContainerPxl;
    RECT        m_rcClientPxl;
};


//------------------------------------------------------------------------------
inline DxContainer * CastDxContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htDxContainer)) {
        return (DxContainer *) pBase;
    }
    return NULL;
}

DxContainer * GetDxContainer(DuVisual * pgad);

#endif // WINAPI__DxDrawContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\dxcontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "DxContainer.h"

#include "MsgHelp.h"


/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxContainer * 
GetDxContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    DxContainer * pconDX = CastDxContainer(pcon);
    return pconDX;
}


//------------------------------------------------------------------------------
HRESULT
GdCreateDxRootGadget(
    IN  const RECT * prcContainerPxl,
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)
{
    HRESULT hr;

    DxContainer * pconNew;
    hr = DxContainer::Build(prcContainerPxl, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    hr = DuRootGadget::Build(pconNew, TRUE, pci, ppgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    //
    // Don't setup an initial brush when using DirectX
    //

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class DxContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxContainer::DxContainer()
{

}


//------------------------------------------------------------------------------
DxContainer::~DxContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
DxContainer::Build(const RECT * prcContainerPxl, DxContainer ** ppconNew)
{
    AssertReadPtr(prcContainerPxl);
    DxContainer * pconNew = ClientNew(DxContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_rcContainerPxl = *prcContainerPxl;

    pconNew->m_rcClientPxl.left     = 0;
    pconNew->m_rcClientPxl.top      = 0;
    pconNew->m_rcClientPxl.right    = pconNew->m_rcContainerPxl.right - pconNew->m_rcContainerPxl.left;
    pconNew->m_rcClientPxl.bottom   = pconNew->m_rcContainerPxl.bottom - pconNew->m_rcContainerPxl.top;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void        
DxContainer::OnGetRect(RECT * prcDesktopPxl)
{
    AssertWritePtr(prcDesktopPxl);
    *prcDesktopPxl = m_rcContainerPxl;
}


//------------------------------------------------------------------------------
void        
DxContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void        
DxContainer::OnStartCapture()
{

}


//------------------------------------------------------------------------------
void        
DxContainer::OnEndCapture()
{

}


//------------------------------------------------------------------------------
BOOL        
DxContainer::OnTrackMouseLeave()
{
    return FALSE;
}


//------------------------------------------------------------------------------
void  
DxContainer::OnSetFocus()
{

}


//------------------------------------------------------------------------------
void        
DxContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    pptContainerPxl->x  = -20000;
    pptContainerPxl->y  = -20000;
}


//------------------------------------------------------------------------------
BOOL        
DxContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    //
    // NOTE: All messages that come into the DxContainer are coming through the
    // ForwardGadgetMessage() API which has already taken a Context lock.  
    // Therefore, we don't need to take the Context lock in this function again.
    // Other Containers do NOT necessarily have this behavior.
    //

    POINT ptContainerPxl;

    *pr = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            GMSG_MOUSECLICK msg;
            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEWHEEL:
        {
            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            GMSG_MOUSEWHEEL msg;
            GdConvertMouseWheelMessage(&msg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEMOVE:
    case WM_MOUSEHOVER:
        {
            GMSG_MOUSE msg;
            GdConvertMouseMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSELEAVE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLeaveMessage();
                return TRUE;
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            GMSG_KEYBOARD msg;
            GdConvertKeyboardMessage(&msg, nMsg, wParam, lParam);
            BOOL fResult = m_pgadRoot->xdHandleKeyboardMessage(&msg, nMsgFlags);
            return fResult;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\hwndhelp.h ===
#if !defined(LAVA__HWndHelp_h__INCLUDED)
#define LAVA__HWndHelp_h__INCLUDED
#pragma once

HRESULT     GdAttachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi);
HRESULT     GdDetachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate);

#endif // LAVA__HWndHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\lava.h ===
/***************************************************************************\
*
* File: Lava.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(LAVA__Lava_h__INCLUDED)
#define LAVA__Lava_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserMotionP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Lava Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // LAVA__Lava_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\msghelp.h ===
#if !defined(LAVA__MsgHelp_h__INCLUDED)
#define LAVA__MsgHelp_h__INCLUDED

void            GdConvertMouseMessage(GMSG_MOUSE * pmsg, UINT nMsg, WPARAM wParam);
void            GdConvertKeyboardMessage(GMSG_KEYBOARD * pmsg, UINT nMsg, WPARAM wParam, LPARAM lParam);

void            GdConvertMouseClickMessage(GMSG_MOUSECLICK * pmsg, UINT nMsg, WPARAM wParam);
void            GdConvertMouseWheelMessage(GMSG_MOUSEWHEEL * pmsg, WPARAM wParam);

#endif // LAVA__MsgHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\msghelp.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "MsgHelp.h"

/***************************************************************************\
*
* GdConvertMouseMessage (Public)
*
* GdConvertMouseMessage converts from an HWND mouse event into a Gadget 
* mouse event.
*
\***************************************************************************/

void
SetStandardInputFields(
    IN OUT GMSG_INPUT * pmsg,
    IN     UINT cbSize)
{
    ZeroMemory(pmsg, cbSize);
    pmsg->cbSize     = cbSize;
    pmsg->lTime      = GetMessageTime();
    pmsg->nModifiers = 0;

    //
    // todo -- measure perf
    //
    BYTE bKeys[256];
    if (GetKeyboardState(bKeys)) {
        if (bKeys[VK_LBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_LBUTTON;
        if (bKeys[VK_RBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_RBUTTON;
        if (bKeys[VK_MBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_MBUTTON;
        if (bKeys[VK_LSHIFT]   & 0x80)  pmsg->nModifiers |= GMODIFIER_LSHIFT;
        if (bKeys[VK_RSHIFT]   & 0x80)  pmsg->nModifiers |= GMODIFIER_RSHIFT;
        if (bKeys[VK_LCONTROL] & 0x80)  pmsg->nModifiers |= GMODIFIER_LCONTROL;
        if (bKeys[VK_RCONTROL] & 0x80)  pmsg->nModifiers |= GMODIFIER_RCONTROL;
        if (bKeys[VK_LMENU]    & 0x80)  pmsg->nModifiers |= GMODIFIER_LALT;
        if (bKeys[VK_RMENU]    & 0x80)  pmsg->nModifiers |= GMODIFIER_RALT;
    }
}


void 
GdConvertMouseClickMessage(
    IN OUT GMSG_MOUSECLICK * pmsg,
    IN     UINT nMsg,
    IN     WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSECLICK));
    pmsg->nFlags        = LOWORD(wParam);
    pmsg->cClicks       = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        pmsg->bButton   = GBUTTON_LEFT;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
        pmsg->bButton   = GBUTTON_RIGHT;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
        pmsg->bButton   = GBUTTON_MIDDLE;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_LBUTTONUP:
        pmsg->bButton   = GBUTTON_LEFT;
        pmsg->nCode     = GMOUSE_UP;
        break;

    case WM_RBUTTONUP:
        pmsg->bButton   = GBUTTON_RIGHT;
        pmsg->nCode     = GMOUSE_UP;
        break;

    case WM_MBUTTONUP:
        pmsg->bButton   = GBUTTON_MIDDLE;
        pmsg->nCode     = GMOUSE_UP;
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}

void 
GdConvertMouseWheelMessage(
    IN OUT GMSG_MOUSEWHEEL * pmsg,
    IN     WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSEWHEEL));
    pmsg->nCode         = GMOUSE_WHEEL;
    pmsg->bButton       = GBUTTON_NONE;
    pmsg->nFlags        = LOWORD(wParam);
    pmsg->sWheel        = GET_WHEEL_DELTA_WPARAM(wParam);
}


void 
GdConvertMouseMessage(
    IN OUT GMSG_MOUSE * pmsg,
    UINT nMsg,
    WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSE));
    pmsg->nFlags        = LOWORD(wParam);
    
    switch (nMsg)
    {
    case WM_MOUSEMOVE:
        pmsg->bButton   = GBUTTON_NONE;
        pmsg->nCode     = GMOUSE_MOVE;
        break;

    case WM_MOUSEHOVER:
        pmsg->bButton   = GBUTTON_NONE;
        pmsg->nCode     = GMOUSE_HOVER;
        break;
    
    case WM_MOUSELEAVE:
        AssertMsg(0, "Must call RootGadget::xdHandleMouseLeaveMessage() directly");
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}


/***************************************************************************\
*
* GdConvertKeyboardMessage (Public)
*
* GdConvertKeyboardMessage converts from an HWND keyboard event into a 
* Gadget mouse event.
*
\***************************************************************************/

void            
GdConvertKeyboardMessage(
    IN OUT GMSG_KEYBOARD * pmsg,
    IN     UINT nMsg,
    IN     WPARAM wParam,
    IN     LPARAM lParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_KEYBOARD));
    pmsg->ch            = (WCHAR) wParam;
    pmsg->cRep          = LOWORD(lParam);
    pmsg->wFlags        = HIWORD(lParam);
    
    switch (nMsg)
    {
    case WM_CHAR:
        pmsg->nCode     = GKEY_CHAR;
        break;

    case WM_KEYDOWN:
        pmsg->nCode     = GKEY_DOWN;
        break;

    case WM_KEYUP:
        pmsg->nCode     = GKEY_UP;
        break;

    case WM_SYSCHAR:
        pmsg->nCode     = GKEY_SYSCHAR;
        break;

    case WM_SYSKEYDOWN:
        pmsg->nCode     = GKEY_SYSDOWN;
        break;

    case WM_SYSKEYUP:
        pmsg->nCode     = GKEY_SYSUP;
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\nccontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "NcContainer.h"

#include "MsgHelp.h"


/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
NcContainer * 
GetNcContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    NcContainer * pconHWND = CastNcContainer(pcon);
    return pconHWND;
}


/***************************************************************************\
*
* GdCreateNcRootGadget (Public)
*
* GdCreateNcRootGadget() creates a new RootGadget for an existing HWND's
* non-client area.
*
\***************************************************************************/

HRESULT
GdCreateNcRootGadget(
    IN  HWND hwndContainer,             // Window to be hosted inside
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)         // New Root Gadget
{
    HRESULT hr;

    //
    // Build a new container and top gadget
    //

    NcContainer * pconNew;
    hr = NcContainer::Build(hwndContainer, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    hr = DuRootGadget::Build(pconNew, FALSE, pci, ppgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    //
    // Don't setup an initial brush when using Non-Client
    //

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class NcContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
NcContainer::NcContainer()
{
    m_hwndOwner = NULL;
}


//------------------------------------------------------------------------------
NcContainer::~NcContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
NcContainer::Build(HWND hwnd, NcContainer ** ppconNew)
{
    // Check parameters
    if (!ValidateHWnd(hwnd)) {
        return E_INVALIDARG;
    }

    // Create a new container
    NcContainer * pconNew = ClientNew(NcContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_hwndOwner    = hwnd;

    RECT rcWin;
    GetWindowRect(hwnd, &rcWin);
    pconNew->m_sizePxl.cx   = rcWin.right - rcWin.left;
    pconNew->m_sizePxl.cy   = rcWin.bottom - rcWin.top;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
NcContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void
NcContainer::OnGetRect(RECT * prcDesktopPxl)
{
    GetWindowRect(m_hwndOwner, prcDesktopPxl);
}


//------------------------------------------------------------------------------
void        
NcContainer::OnStartCapture()
{
    
}


//------------------------------------------------------------------------------
void        
NcContainer::OnEndCapture()
{
    
}


//------------------------------------------------------------------------------
BOOL
NcContainer::OnTrackMouseLeave()
{
    return FALSE;
}


//------------------------------------------------------------------------------
void        
NcContainer::OnSetFocus()
{
    if (GetFocus() != m_hwndOwner) {
        //
        // Setting focus is a little more complicated than pure HWND's.  This is
        // because Gadgets greatly simplify several things
        //
        // 1. SetFocus
        // 2. Setup caret, if any
        //

        Trace("NcContainer::OnSetFocus()\n");
        SetFocus(m_hwndOwner);
    }
}


//------------------------------------------------------------------------------
void        
NcContainer::OnRescanMouse(POINT * pptContainerPxl)
{
//    Trace("%p OnRescanMouse\n", GetTickCount());

    POINT ptCursor;
    if (!GetCursorPos(&ptCursor)) {
        ptCursor.x  = -20000;
        ptCursor.y  = -20000;
    }

    ScreenToClient(m_hwndOwner, &ptCursor);
    *pptContainerPxl = ptCursor;
}


//------------------------------------------------------------------------------
BOOL        
NcContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    UNREFERENCED_PARAMETER(nMsgFlags);

    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    POINT ptContainerPxl;

    *pr = 0;

    Trace("NcContainer::HandleMessage: msg: 0x%x\n", nMsg);

    switch (nMsg)
    {
    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
    case WM_NCMBUTTONDOWN:
    case WM_NCLBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:
    case WM_NCMBUTTONDBLCLK:
    case WM_NCLBUTTONUP:
    case WM_NCRBUTTONUP:
    case WM_NCMBUTTONUP:
        ptContainerPxl.x = GET_X_LPARAM(lParam);
        ptContainerPxl.y = GET_Y_LPARAM(lParam);

        if ((GetCapture() == m_hwndOwner) && 
            (ChildWindowFromPointEx(m_hwndOwner, ptContainerPxl, CWP_SKIPINVISIBLE) != m_hwndOwner)) {
           
            ReleaseCapture();
        }

        {
            GMSG_MOUSECLICK msg;
            nMsg += WM_LBUTTONDOWN - WM_NCLBUTTONDOWN;

            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_NCMOUSEMOVE:
        ptContainerPxl.x = GET_X_LPARAM(lParam);
        ptContainerPxl.y = GET_Y_LPARAM(lParam);

        if ((GetCapture() == m_hwndOwner) && 
            (ChildWindowFromPointEx(m_hwndOwner, ptContainerPxl, CWP_SKIPINVISIBLE) != m_hwndOwner)) {
           
            ReleaseCapture();
        }

        {
            GMSG_MOUSE msg;
            nMsg += WM_LBUTTONDOWN - WM_NCLBUTTONDOWN;

            GdConvertMouseMessage(&msg, nMsg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_CAPTURECHANGED:
        if (m_hwndOwner != (HWND) lParam) {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLostCapture();
            }
        }
        break;

    case WM_SETFOCUS:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardFocus(GSC_SET);
            }
            break;
        }

    case WM_KILLFOCUS:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardFocus(GSC_LOST);
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            Trace("NcContainer::xdHandleMessage(Keyboard=0x%x)\n", nMsg);
        }
        break;

    case WM_NCACTIVATE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleActivate(wParam ? GSC_LOST : GSC_SET);
            }
            break;
        }
        // Fall through to WM_NCPAINT

    case WM_NCPAINT:
        if ((!m_fManualDraw) && (m_pgadRoot != NULL)) {
//            HDC hdc = GetDCEx(m_hwndOwner, (HRGN) wParam, DCX_WINDOW | DCX_INTERSECTRGN);
            HDC hdc = GetWindowDC(m_hwndOwner);
            RECT rcInvalid;
            {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edNone)) {
                    m_pgadRoot->GetLogRect(&rcInvalid, SGR_CLIENT);
                    m_pgadRoot->xrDrawTree(NULL, hdc, &rcInvalid, 0);
                }
            }
            ReleaseDC(m_hwndOwner, hdc);
            return TRUE;
        }
        break;

    case WM_WINDOWPOSCHANGED:
        {
            WINDOWPOS * pwp = (WINDOWPOS *) lParam;
            if (!TestFlag(pwp->flags, SWP_NOSIZE)) {
                RECT rcWin;
                GetWindowRect(m_hwndOwner, &rcWin);
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    VerifyHR(m_pgadRoot->xdSetLogRect(0, 0, rcWin.right - rcWin.left, rcWin.bottom - rcWin.top, SGR_SIZE));
                }
                break;
            }
        }
        break;

    case WM_GETROOTGADGET:
        if (m_pgadRoot != NULL) {
            *pr = (LRESULT) m_pgadRoot->GetHandle();
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\spy.inl ===
#if !defined(LAVA__Spy_inl__INCLUDED)
#define LAVA__Spy_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class Spy
*
*****************************************************************************
\***************************************************************************/

#if DBG

#endif // DBG

#endif // LAVA__Spy_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\nccontainer.h ===
#if !defined(WINAPI__NcContainer_h__INCLUDED)
#define WINAPI__NcContainer_h__INCLUDED
#pragma once

class NcContainer : public DuContainer
{
// Construction
public:
			NcContainer();
	virtual ~NcContainer();
    static  HRESULT     Build(HWND hwnd, NcContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htNcContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Implementation
protected:

// Data
protected:
    HWND        m_hwndOwner;
    SIZE        m_sizePxl;
    UINT        m_nFlags;
};


//------------------------------------------------------------------------------
inline NcContainer * CastNcContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htNcContainer)) {
        return (NcContainer *) pBase;
    }
    return NULL;
}

NcContainer * GetNcContainer(DuVisual * pgad);

#endif // WINAPI__NcContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(LAVA__Public_h__INCLUDED)
#define LAVA__Public_h__INCLUDED

#include "DxContainer.h"
#include "HWndContainer.h"
#include "NcContainer.h"
#include "HWndHelp.h"

#endif // LAVA__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\spy.h ===
#if !defined(LAVA__Spy_h__INCLUDED)
#define LAVA__Spy_h__INCLUDED
#pragma once

#include <commctrl.h>

#if DBG
class Spy : public ListNodeT<Spy>
{
// Construction
public:
            Spy();
            ~Spy();

// Operations
public:
    static  BOOL        BuildSpy(HWND hwndParent, HGADGET hgadRoot, HGADGET hgadSelect);

// Implementation
protected:
    static  LRESULT CALLBACK
                        RawSpyWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);
            LRESULT     SpyWndProc(UINT nMsg, WPARAM wParam, LPARAM lParam);

    static  HRESULT CALLBACK
                        RawEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg);
            HRESULT     EventProc(EventMsg * pmsg);

        struct EnumData
        {
            Spy *       pspy;
            HTREEITEM   htiParent;
            int         nLevel;
        };

    static  BOOL CALLBACK 
                        EnumAddList(HGADGET hgad, void * pvData);
    static  BOOL CALLBACK 
                        EnumRemoveLink(HGADGET hgad, void * pvData);


        struct CheckIsChildData
        {
            HGADGET     hgadCheck;
            BOOL        fChild;
        };

    static  BOOL CALLBACK 
                        EnumCheckIsChild(HGADGET hgad, void * pvData);

        enum EImage
        {
            iGadget     = 0,
        };

            void        SelectGadget(HGADGET hgad);
    
            HGADGET     GetGadget(HTREEITEM hti);
            HTREEITEM   InsertTreeItem(HTREEITEM htiParent, HGADGET hgad);
            void        DisplayContextMenu(BOOL fViaKbd);

            void        UpdateTitle();
            void        UpdateDetails();
            void        UpdateLayout();
            void        UpdateLayoutDesc(BOOL fForceLayoutDesc);
            
            // Painting
            void        OnPaint(HDC hdc);

            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCTSTR pszText, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCWSTR pszText, BOOL fMultiline = FALSE, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, int nValue, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, void * pvValue, HFONT hfnt = NULL);

            int         NumLines(int cyPxl) const;

// Data
protected:
            HWND        m_hwnd;
            HWND        m_hwndTree;
            HIMAGELIST  m_hilc;
    static  HBRUSH      s_hbrOutline;
    static  HFONT       s_hfntDesc;
    static  HFONT       s_hfntDescBold;

            HGADGET     m_hgadMsg;      // Common MessageHandler attached to each Gadget
            HGADGET     m_hgadRoot;     // Root of tree
            HGADGET     m_hgadDetails;  // Current Gadget displayed in Details
            int         m_cItems;       // Number of Gadgets in tree
            TCHAR       m_szRect[128];  // Cached position
            WCHAR       m_szName[128];  // Cached name
            WCHAR       m_szType[128];  // Cached type
            WCHAR       m_szStyle[1024];// Style description
            BOOL        m_fShowDesc:1;  // Whether to show the description area
            BOOL        m_fValid:1;     // Set TRUE when Tree is completely valid
            SIZE        m_sizeWndPxl;   // Size of frame window
    static  int         s_cyLinePxl;    // Height of each line in the description area
            int         m_cLines;       // Number of lines
            int         m_cyDescPxl;    // Height of description area in pixels

    static  DWORD       g_tlsSpy;       // TLS Slot for Spy
    static  PRID        s_pridLink;
    static  ATOM        s_atom;
    static  CritLock    s_lockList;     // Lock for list of Spies
    static  GList<Spy>  s_lstSpys;      // List of all open Spies
};

#endif // DBG

#include "Spy.inl"

#endif // LAVA__Spy_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\stdafx.h ===
#if !defined(LAVA__StdAfx_h__INCLUDED)
#define LAVA__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // LAVA__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\spy.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "Spy.h"

#include "..\DUser\resource.h"

#if DBG

const UINT  IDC_GADGETTREE  = 1;
const int   cxValue         = 80;
const int   cxBorder        = 5;
const int   cyBorder        = 5;

/***************************************************************************\
*****************************************************************************
*
* class Spy
*
*****************************************************************************
\***************************************************************************/

PRID        Spy::s_pridLink     = 0;
ATOM        Spy::s_atom         = NULL;
HFONT       Spy::s_hfntDesc     = NULL;
HFONT       Spy::s_hfntDescBold = NULL;
HBRUSH      Spy::s_hbrOutline   = NULL;
int         Spy::s_cyLinePxl    = 0;
DWORD       Spy::g_tlsSpy       = (DWORD) -1;
CritLock    Spy::s_lockList;
GList<Spy>  Spy::s_lstSpys;

static const GUID guidLink = { 0xd5818900, 0xaf18, 0x4c98, { 0x87, 0x20, 0x5a, 0x32, 0x47, 0xa3, 0x1, 0x78 } }; // {D5818900-AF18-4c98-8720-5A3247A30178}

//------------------------------------------------------------------------------
Spy::Spy()
{

}


//------------------------------------------------------------------------------
Spy::~Spy()
{
    s_lockList.Enter();
    s_lstSpys.Unlink(this);
    s_lockList.Leave();
}


//------------------------------------------------------------------------------
BOOL
Spy::BuildSpy(HWND hwndParent, HGADGET hgadRoot, HGADGET hgadSelect)
{
    BOOL fSuccess = FALSE;
    Spy * pSpy, * pSpyCur;

    s_lockList.Enter();


    //
    // Perform first-time initialization for Spy
    //

    if (g_tlsSpy == -1) {
        //
        // Allocate a TLS slot for Spy.  This is DEBUG only, so we don't worry about
        // the extra cost.  However, if this ever becomes on in RETAIL, we need to
        // create a SubTread for Lava and add a Spy slot.
        //

        g_tlsSpy = TlsAlloc();
        if (g_tlsSpy == -1) {
            goto Exit;
        }


        //
        // Initialize CommCtrl.
        //

        INITCOMMONCONTROLSEX icc;
        icc.dwSize  = sizeof(icc);
        icc.dwICC   = ICC_TREEVIEW_CLASSES;

        if (!InitCommonControlsEx(&icc)) {
            goto Exit;
        }
    }


    AssertMsg(::GetGadget(hgadRoot, GG_PARENT) == NULL, "Ensure Root Gadget");

    //
    // Each Gadget subtree can only be spied on once because there are
    // back-pointers from each Gadget to the corresponding HTREEITEM's.  Need to
    // check if this Gadget subtree is already is being spied on.
    //

    pSpyCur = s_lstSpys.GetHead();
    while (pSpyCur != NULL) {
        if (pSpyCur->m_hgadRoot == hgadRoot) {
            //
            // Already exists, so don't open another Spy.
            //

            SetForegroundWindow(pSpyCur->m_hwnd);
            goto Exit;
        }

        pSpyCur = pSpyCur->GetNext();
    }


    //
    // Register a WNDCLASS to use
    //

    if (s_atom == NULL) {
        WNDCLASSEX wcex;

        ZeroMemory(&wcex, sizeof(wcex));
        wcex.cbSize = sizeof(WNDCLASSEX);

        wcex.style			= CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc	= RawSpyWndProc;
        wcex.hInstance		= g_hDll;
        wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground	= (HBRUSH)(COLOR_3DFACE + 1);
        wcex.lpszClassName	= "GadgetSpy (Inside)";

        s_atom = RegisterClassEx(&wcex);
        if (s_atom == NULL) {
            goto Exit;
        }
    }


    //
    // Create GDI objects used in painting
    //

    if (s_hfntDesc == NULL) {
        s_hfntDesc = UtilBuildFont(L"Tahoma", 85, FS_NORMAL, NULL);

        HDC hdc = GetGdiCache()->GetCompatibleDC();
        HFONT hfntOld = (HFONT) SelectObject(hdc, s_hfntDesc);

        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        s_cyLinePxl = tm.tmHeight;

        SelectObject(hdc, hfntOld);
        GetGdiCache()->ReleaseCompatibleDC(hdc);
    }

    if (s_hfntDescBold == NULL) {
        s_hfntDescBold = UtilBuildFont(L"Tahoma", 85, FS_BOLD, NULL);
    }

    if (s_hbrOutline == NULL) {
        s_hbrOutline = CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
    }

    if (s_pridLink == 0) {
        s_pridLink = RegisterGadgetProperty(&guidLink);
    }


    //
    // Create a new Spy instance and HWND
    //

    pSpy = ProcessNew(Spy);
    if (pSpy == NULL) {
        goto Exit;
    }

    pSpy->m_hgadMsg     = CreateGadget(NULL, GC_MESSAGE, RawEventProc, pSpy);
    pSpy->m_hgadRoot    = hgadRoot;
    Verify(TlsSetValue(g_tlsSpy, pSpy));

    {
        RECT rcParentPxl;
        GetWindowRect(hwndParent, &rcParentPxl);

        HWND hwndSpy = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_CLIENTEDGE,
                (LPCTSTR) s_atom, NULL,
                WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, rcParentPxl.left + 20, rcParentPxl.top + 20,
                300, 500, hwndParent, NULL, g_hDll, NULL);
        if (hwndSpy == NULL) {
            ProcessDelete(Spy, pSpy);
            goto Exit;
        }

        pSpy->UpdateTitle();

        ShowWindow(hwndSpy, SW_SHOW);
        UpdateWindow(hwndSpy);
    }


    //
    // Select the specified Gadget as a starting point.  We want to check
    // if this HGADGET is actually a valid child since it may have been
    // "grabbed" at an earlier time and no longer be valid.
    //

    if (hgadSelect) {
        CheckIsChildData cicd;
        cicd.hgadCheck  = hgadSelect;
        cicd.fChild     = FALSE;

        Verify(EnumGadgets(hgadRoot, EnumCheckIsChild, &cicd, GENUM_DEEPCHILD));

        if (cicd.fChild) {
            HTREEITEM htiSelect;
            if (GetGadgetProperty(hgadSelect, s_pridLink, (void **) &htiSelect)) {
                AssertMsg(htiSelect != NULL, "Must have valid HTREEITEM");
                if (!TreeView_SelectItem(pSpy->m_hwndTree, htiSelect)) {
                    Trace("SPY: Unable to select default Gadget\n");
                }
            }
        }
    }

    s_lstSpys.Add(pSpy);

    fSuccess = TRUE;
Exit:
    s_lockList.Leave();

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumCheckIsChild(HGADGET hgad, void * pvData)
{
    CheckIsChildData * pcicd = (CheckIsChildData *) pvData;

    if (hgad == pcicd->hgadCheck) {
        pcicd->fChild = TRUE;
        return FALSE;  // No longer need to enumerate
    }

    return TRUE;
}


//------------------------------------------------------------------------------
void
Spy::UpdateTitle()
{
    TCHAR szTitle[256];
    wsprintf(szTitle, "Root HGADGET = 0x%p, %d Gadgets", m_hgadRoot, m_cItems);

    SetWindowText(m_hwnd, szTitle);
}


//------------------------------------------------------------------------------
LRESULT CALLBACK
Spy::RawSpyWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    Spy * pSpy = (Spy *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pSpy == NULL) {
        //
        // Creating a new Spy HWND, so hook up to the Spy object that was
        // previously created.
        //

        pSpy = reinterpret_cast<Spy *> (TlsGetValue(g_tlsSpy));
        AssertMsg(pSpy != NULL, "Ensure already created new Spy instance");
        TlsSetValue(g_tlsSpy, NULL);
        pSpy->m_hwnd = hwnd;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pSpy);
    }

    AssertMsg(pSpy->m_hwnd == hwnd, "Ensure HWND's match");
    return pSpy->SpyWndProc(nMsg, wParam, lParam);
}


//------------------------------------------------------------------------------
LRESULT
Spy::SpyWndProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    switch (nMsg)
    {
    case WM_CREATE:
        if (DefWindowProc(m_hwnd, nMsg, wParam, lParam) == -1) {
            return -1;
        }

        //
        // Setup the window
        //

        AssertMsg(m_hgadRoot != NULL, "Must already have specified Gadget");

        RECT rcClient;
        GetClientRect(m_hwnd, &rcClient);

        m_hwndTree = CreateWindowEx(0, _T("SysTreeView32"),
                NULL, WS_CHILD | WS_VISIBLE | TVS_HASBUTTONS | TVS_HASLINES | TVS_SHOWSELALWAYS,
                0, 0, rcClient.right, rcClient.bottom, m_hwnd, (HMENU)((UINT_PTR)IDC_GADGETTREE), g_hDll, NULL);

        m_hilc = ImageList_LoadImage(g_hDll, MAKEINTRESOURCE(IDB_SPYICON),
                16, 1, RGB(128, 0, 128), IMAGE_BITMAP, LR_SHARED);
        if ((m_hwndTree == NULL) || (m_hilc == NULL)) {
            return -1;
        }

        TreeView_SetImageList(m_hwndTree, m_hilc, TVSIL_NORMAL);

        EnumData ed;
        ed.pspy         = this;
        ed.htiParent    = InsertTreeItem(TVI_ROOT, m_hgadRoot);
        ed.nLevel       = 1;
        Verify(EnumGadgets(m_hgadRoot, EnumAddList, &ed, GENUM_SHALLOWCHILD));
        m_fValid        = TRUE;

        TreeView_Expand(m_hwndTree, ed.htiParent, TVE_EXPAND);
        m_hgadDetails = m_hgadRoot;
        UpdateDetails();

        break;

    case WM_DESTROY:
        SelectGadget(NULL);
        ::DeleteHandle(m_hgadMsg);
        break;

    case WM_NCDESTROY:
        ProcessDelete(Spy, this);
        goto CallDWP;

    case WM_SIZE:
        if ((wParam == SIZE_MAXIMIZED) || (wParam == SIZE_RESTORED)) {
            UpdateLayout();
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(m_hwnd, &ps);
            OnPaint(hdc);
            EndPaint(m_hwnd, &ps);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_GADGETTREE) {
            NMHDR * pnm = (NMHDR *) lParam;
            if (pnm->code == TVN_SELCHANGED) {
                NMTREEVIEW * pnmtv = (NMTREEVIEW *) lParam;
                if (m_fValid) {
                    SelectGadget(GetGadget(pnmtv->itemNew.hItem));
                }
                break;
            } else if (pnm->code == TVN_KEYDOWN) {
                NMTVKEYDOWN * pnmtvkd = (NMTVKEYDOWN *) lParam;
                if (pnmtvkd->wVKey == VK_APPS) {
                    DisplayContextMenu(TRUE);
                }
            } else if (pnm->code == NM_RCLICK) {
                DisplayContextMenu(FALSE);
            }
        }
        goto CallDWP;

    default:
CallDWP:
        return DefWindowProc(m_hwnd, nMsg, wParam, lParam);
    }

    return 0;
}


//------------------------------------------------------------------------------
HRESULT CALLBACK
Spy::RawEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
    UNREFERENCED_PARAMETER(hgadCur);

    Spy * pSpy = (Spy *) pvCur;
    return pSpy->EventProc(pmsg);
}


//------------------------------------------------------------------------------
BOOL
IsDescendant(
    HGADGET hgadParent,
    HGADGET hgadChild)
{
    AssertMsg(hgadParent != NULL, "Must have valid parent");

    if (hgadChild == hgadParent) {
        return TRUE;
    } if (hgadChild == NULL) {
        return FALSE;
    } else {
        return IsDescendant(hgadParent, ::GetGadget(hgadChild, GG_PARENT));
    }
}


//------------------------------------------------------------------------------
HRESULT
Spy::EventProc(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        //
        // Our Listener is being destroyed.  We need to detach from everything.
        //

        if (m_hgadRoot != NULL) {
            Trace("SPY: Destroying Spy MsgGadget\n");
            Verify(EnumGadgets(m_hgadRoot, EnumRemoveLink, NULL, GENUM_DEEPCHILD));
            m_hgadRoot = NULL;
        }
        break;

    case GMF_EVENT:
        switch (pmsg->nMsg)
        {
        case GM_DESTROY:
            {
                GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
                if (pmsgD->nCode == GDESTROY_START) {
                    //
                    // Gadget is being destroyed
                    //

                    Trace("SPY: Destroying Gadget 0x%p\n", pmsg->hgadMsg);
                    HTREEITEM hti;
                    if (GetGadgetProperty(pmsg->hgadMsg, s_pridLink, (void **) &hti)) {
                        AssertMsg(hti != NULL, "Must have valid HTREEITEM");
                        Verify(EnumGadgets(pmsg->hgadMsg, EnumRemoveLink, NULL, GENUM_DEEPCHILD));
                        TreeView_DeleteItem(m_hwndTree, hti);
                    }
                }
            }
            break;

        case GM_CHANGERECT:
            if (IsDescendant(pmsg->hgadMsg, m_hgadDetails)) {
                UpdateDetails();
            }
            break;
        }
    }

    return DU_S_NOTHANDLED;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumAddList(HGADGET hgad, void * pvData)
{
    EnumData * ped      = (EnumData *) pvData;
    Spy * pSpy          = ped->pspy;
    HTREEITEM htiNew    = pSpy->InsertTreeItem(ped->htiParent, hgad);

    pSpy->m_cItems++;

    if (::GetGadget(hgad, GG_TOPCHILD) != NULL) {
        EnumData ed;
        ed.pspy         = pSpy;
        ed.htiParent    = htiNew;
        ed.nLevel       = ped->nLevel + 1;
        Verify(EnumGadgets(hgad, EnumAddList, &ed, GENUM_SHALLOWCHILD));

        if (ped->nLevel <= 2) {
            TreeView_Expand(pSpy->m_hwndTree, htiNew, TVE_EXPAND);
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumRemoveLink(HGADGET hgad, void * pvData)
{
    UNREFERENCED_PARAMETER(pvData);

    RemoveGadgetProperty(hgad, s_pridLink);
    return TRUE;
}


//------------------------------------------------------------------------------
void
Spy::SelectGadget(HGADGET hgad)
{
    m_hgadDetails = hgad;

    {
        //
        // We are bypassinging the normal API's to directly call a
        // DEBUG-only function.  Need to lock the Context and do FULL handle
        // validation.
        //

        ContextLock cl;
        if (!cl.LockNL(ContextLock::edDefer)) {
            return;
        }
        
        DuVisual * pgadTree = ValidateVisual(hgad);
        DuVisual::DEBUG_SetOutline(pgadTree);
    }

    UpdateDetails();
}


//------------------------------------------------------------------------------
HTREEITEM
Spy::InsertTreeItem(HTREEITEM htiParent, HGADGET hgad)
{
    TCHAR szName[1024];

    GMSG_QUERYDESC msg;
    msg.cbSize      = sizeof(msg);
    msg.hgadMsg     = hgad;
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
        if (msg.szName[0] != '\0') {
            wsprintf(szName, "0x%p %S: \"%S\"", hgad, msg.szType, msg.szName);
        } else {
            wsprintf(szName, "0x%p %S", hgad, msg.szType);
        }
    } else {
        wsprintf(szName, "0x%p", hgad);
    }

    TVINSERTSTRUCT tvis;
    tvis.hParent        = htiParent;
    tvis.hInsertAfter   = TVI_LAST;
    tvis.item.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE;
    tvis.item.pszText   = szName;
    tvis.item.iImage    = iGadget;
    tvis.item.lParam    = (LPARAM) hgad;

    HTREEITEM htiNew = TreeView_InsertItem(m_hwndTree, &tvis);
    if (htiNew != NULL) {
        if (AddGadgetMessageHandler(hgad, 0, m_hgadMsg)) {
            Verify(SetGadgetProperty(hgad, s_pridLink, htiNew));
        } else {
            Trace("WARNING: Spy unable to attach handler on 0x%p\n", hgad);
        }
    }
    return htiNew;
}


//------------------------------------------------------------------------------
HGADGET
Spy::GetGadget(HTREEITEM hti)
{
    TVITEM tvi;
    tvi.hItem   = hti;
    tvi.mask    = TVIF_PARAM | TVIF_HANDLE;

    if (TreeView_GetItem(m_hwndTree, &tvi)) {
        HGADGET hgadItem = (HGADGET) tvi.lParam;
        AssertMsg(hgadItem != NULL, "All items in the tree should have a Gadget");

        return hgadItem;
    }

    return NULL;
}


//------------------------------------------------------------------------------
void
Spy::DisplayContextMenu(BOOL fViaKbd)
{
    //
    // Locate TreeView item
    //
    
    POINT ptPopup;
    ZeroMemory(&ptPopup, sizeof(ptPopup));

    HTREEITEM hti;

    if (fViaKbd) {
        //
        // Keyboard driven
        //

        hti = TreeView_GetSelection(m_hwndTree);
        if (hti != NULL) {
            RECT rc;

            TreeView_GetItemRect(m_hwndTree, hti, &rc, TRUE);

            ptPopup.x = rc.left;
            ptPopup.y = rc.bottom;
            ClientToScreen(m_hwndTree, &ptPopup);
        }
    } else {
        //
        // Mouse driven
        //

        TVHITTESTINFO tvht;

        DWORD dwPos = GetMessagePos();

        ptPopup.x = GET_X_LPARAM(dwPos);
        ptPopup.y = GET_Y_LPARAM(dwPos);

        tvht.pt = ptPopup;
        ScreenToClient(m_hwndTree, &tvht.pt);

        hti = TreeView_HitTest(m_hwndTree, &tvht);
    }


    //
    // Now have tree item and popup position
    //

    if (hti != NULL) {
        //
        // Get Gadget associated with this item
        //
        
        HGADGET hgad = GetGadget(hti);
        
        
        //
        // Create popup menu template
        //
        
        HMENU hMenu = CreatePopupMenu();
        if (hMenu != NULL) {

            BOOL fRes;

            const int cmdDetails = 10;

            fRes = AppendMenu(hMenu, MF_STRING, cmdDetails, "Details...");
            if (fRes) {

                UINT nCmd = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_RIGHTBUTTON, ptPopup.x, ptPopup.y, 0, m_hwndTree, NULL);

                DestroyMenu(hMenu);


                //
                // Invoke commands
                //

                switch (nCmd)
                {
                case cmdDetails:
                    {
                        GMSG_QUERYDETAILS msg;
                        msg.cbSize      = sizeof(msg);
                        msg.hgadMsg     = hgad;
                        msg.nMsg        = GM_QUERY;
                        msg.nCode       = GQUERY_DETAILS;
                        msg.nType       = GQDT_HWND;
                        msg.hOwner      = m_hwndTree;

                        DUserSendEvent(&msg, 0);
                    }
                    break;
                }
            }
        }
    }
}


//------------------------------------------------------------------------------
int
Spy::NumLines(int cyPxl) const
{
    return (cyPxl - 1) / s_cyLinePxl + 1;
}


//------------------------------------------------------------------------------
void
Spy::UpdateDetails()
{
    if (m_hgadDetails == NULL) {
        return;
    }

    RECT rcPxl;
    GetGadgetRect(m_hgadDetails, &rcPxl, SGR_CONTAINER);

    wsprintf(m_szRect, "(%d, %d)-(%d, %d) %d %d",
            rcPxl.left, rcPxl.top, rcPxl.right, rcPxl.bottom,
            rcPxl.right - rcPxl.left, rcPxl.bottom - rcPxl.top);


    GMSG_QUERYDESC msg;
    msg.cbSize      = sizeof(msg);
    msg.hgadMsg     = m_hgadDetails;
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
        CopyString(m_szName, msg.szName, _countof(m_szName));
        CopyString(m_szType, msg.szType, _countof(m_szType));
    } else {
        m_szName[0] = '\0';
        m_szType[0] = '\0';
    }


    //
    // We are bypassinging the normal API's to directly call a
    // DEBUG-only function.  Need to lock the Context and do FULL handle
    // validation.
    //

    ContextLock cl;
    if (cl.LockNL(ContextLock::edNone)) {
        DuVisual * pgadTree = ValidateVisual(m_hgadDetails);
        AssertMsg(pgadTree != NULL, "Should be a valid DuVisual for Spy");
        pgadTree->DEBUG_GetStyleDesc(m_szStyle, _countof(m_szStyle));

        UpdateLayoutDesc(FALSE);
        InvalidateRect(m_hwnd, NULL, TRUE);
    }
}


//------------------------------------------------------------------------------
void
Spy::UpdateLayout()
{
    RECT rcClient;
    GetClientRect(m_hwnd, &rcClient);
    m_sizeWndPxl.cx = rcClient.right;
    m_sizeWndPxl.cy = rcClient.bottom;

    UpdateLayoutDesc(TRUE);
}


//------------------------------------------------------------------------------
void
Spy::UpdateLayoutDesc(BOOL fForceLayoutDesc)
{
    //
    // Compute the number of needed lines
    //

    int cOldLines = m_cLines;
    m_cLines = 4;

    RECT rcStyle;
    rcStyle.left    = cxBorder + cxValue;
    rcStyle.top     = 0;
    rcStyle.right   = m_sizeWndPxl.cx - cxBorder;
    rcStyle.bottom  = 10000;

    HDC hdc = GetGdiCache()->GetTempDC();
    HFONT hfntOld = (HFONT) SelectObject(hdc, s_hfntDesc);
    int nHeight = OS()->DrawText(hdc, m_szStyle, (int) wcslen(m_szStyle), &rcStyle,
            DT_CALCRECT | DT_LEFT | DT_TOP | DT_WORDBREAK);
    SelectObject(hdc, hfntOld);
    GetGdiCache()->ReleaseTempDC(hdc);

    m_cLines += NumLines(nHeight);


    //
    // Move the Tree to provide space for the description
    //

    if ((cOldLines != m_cLines) || fForceLayoutDesc) {
        m_cyDescPxl = s_cyLinePxl * m_cLines + 10;
        m_fShowDesc = m_sizeWndPxl.cy > m_cyDescPxl;

        SIZE sizeTree;
        sizeTree.cx = m_sizeWndPxl.cx;
        sizeTree.cy = m_fShowDesc ? (m_sizeWndPxl.cy - m_cyDescPxl) : m_sizeWndPxl.cy;

        MoveWindow(m_hwndTree, 0, 0, sizeTree.cx, sizeTree.cy, TRUE);
    }
}


//------------------------------------------------------------------------------
void
Spy::OnPaint(HDC hdc)
{
    HFONT hfntOld   = (HFONT) SelectObject(hdc, s_hfntDesc);
    int nOldMode    = SetBkMode(hdc, TRANSPARENT);

    RECT rcOutline;
    rcOutline.left      = 2;
    rcOutline.top       = m_sizeWndPxl.cy - m_cyDescPxl + 2;
    rcOutline.right     = m_sizeWndPxl.cx - 1;
    rcOutline.bottom    = m_sizeWndPxl.cy - 1;
    GdDrawOutlineRect(hdc, &rcOutline, s_hbrOutline);

    POINT pt;
    pt.x = cxBorder;
    pt.y = m_sizeWndPxl.cy - m_cyDescPxl + cyBorder;

    // NOTE: m_cLines should equal the number of lines displayed here

    PaintLine(hdc, &pt, "HGADGET: ",    m_hgadDetails);
    PaintLine(hdc, &pt, "Name: ",       m_szName,       FALSE, s_hfntDescBold);
    PaintLine(hdc, &pt, "Type: ",       m_szType);
    PaintLine(hdc, &pt, "Rectangle: ",  m_szRect);
    PaintLine(hdc, &pt, "Style: ",      m_szStyle,      TRUE);

    SetBkMode(hdc, nOldMode);
    SelectObject(hdc, hfntOld);
}


class CTempSelectFont
{
public:
    CTempSelectFont(HDC hdc, HFONT hfnt)
    {
        m_hdc       = hdc;
        m_fSelect   = (hfnt != NULL);
        if (m_fSelect) {
            m_hfntOld = (HFONT) SelectObject(m_hdc, hfnt);
        }
    }

    ~CTempSelectFont()
    {
        if (m_fSelect) {
            SelectObject(m_hdc, m_hfntOld);
        }
    }

    BOOL    m_fSelect;
    HDC     m_hdc;
    HFONT   m_hfntOld;
};

//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCTSTR pszText, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, pszText, (int) _tcslen(pszText));

    pptOffset->y += s_cyLinePxl;
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCWSTR pszText, BOOL fMultiline, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);

    if (fMultiline) {
        RECT rcStyle;
        rcStyle.left    = pptOffset->x + cxValue;
        rcStyle.top     = pptOffset->y;
        rcStyle.right   = m_sizeWndPxl.cx - cxBorder;
        rcStyle.bottom  = 10000;

        int nHeight = OS()->DrawText(hdc, pszText, (int) wcslen(pszText), &rcStyle,
                DT_LEFT | DT_TOP | DT_WORDBREAK);
        pptOffset->y += NumLines(nHeight) * s_cyLinePxl;
    } else {
        OS()->TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, pszText, (int) wcslen(pszText));
        pptOffset->y += s_cyLinePxl;
    }
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, int nValue, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TCHAR szValue[20];
    _itot(nValue, szValue, 10);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, szValue, (int) _tcslen(szValue));

    pptOffset->y += s_cyLinePxl;
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, void * pvValue, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TCHAR szValue[20];
    wsprintf(szValue, "0x%p", pvValue);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, szValue, (int) _tcslen(szValue));

    pptOffset->y += s_cyLinePxl;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\lava\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Lava.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\colors.h ===
#if !defined(UTIL__Colors_h_INCLUDED)
#define UTIL__Colors_h_INCLUDED
#pragma once

class ColorInfo
{
// Operations
public:
    inline  LPCWSTR     GetName() const;
    inline  COLORREF    GetColorI() const;
    inline  Gdiplus::Color
                        GetColorF() const;


// Data: These must be public so that we can preinitialize them.  However, it
//       is VERY important not to directly access them.
public:
            LPCWSTR     m_pszName;
            COLORREF    m_cr;
};

inline  const ColorInfo * 
                    GdGetColorInfo(UINT c);
        UINT        GdFindStdColor(LPCWSTR pszName);
        HPALETTE    GdGetStdPalette();

#include "Colors.inl"

#endif // UTIL__Colors_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\action.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Action.h"


/***************************************************************************\
*****************************************************************************
*
* class Action
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
Action::Action()
{
    m_cEventsInPeriod   = 0;
    m_cPeriods          = 0;
    m_fPresent          = FALSE;
    m_fDestroy          = FALSE;
    m_flLastProgress    = 0.0f;
    m_pThread           = ::GetThread();
}


//---------------------------------------------------------------------------
Action::~Action()
{
    AssertMsg(!m_DEBUG_fInFire, "Can't destroy if should be locked for Schedule::xwFireNL()\n");

    //
    // We need to notify the application that it needs to cleanup, so we 
    // can't take the Scheduler lock.
    //
    // We also need to directly setup the "Last" members so that xwFireNL() 
    // will signal the application that the Action is being destroyed.
    //

    xwFireFinalNL();

    if (m_plstParent != NULL) {
        m_plstParent->Unlink(this);
    }
}


/***************************************************************************\
*
* Action::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
\***************************************************************************/

BOOL        
Action::xwDeleteHandle()
{
    if (m_fDestroy) {
        PromptInvalid("Can not call DeleteHandle() on an Action after the final callback");
        return FALSE;
    }


    //
    // When the user calls DeleteHandle() on an Action, we need to remove it
    // from the Scheduler's lists.  It may also already be in a callback list
    // currently be processed, but that is okay.  The important thing is to
    // Unlock() the Scheduler's reference so that we can properly be destroyed.
    //

    if (m_plstParent) {
        //
        // Still in a Scheduler list, so the Scheduler still has a valid lock.
        //

        m_plstParent->Unlink(this);
        m_plstParent = NULL;
        VerifyMsg(xwUnlock(), "Should still be valid after the Scheduler Unlock()");
    }


    //
    // If the object isn't destroyed, we need to clear out the callback 
    // right now since the object that is being called is no longer valid.
    //
    // Unlike Gadgets, we actually clear out the callback here since Actions
    // are usually "simple" objects without complicated callbacks.  They do
    // guarantee that to receive all callbacks before being destroyed.  They
    // only guarentee to receive a "destroy" message when the Action is 
    // actually destroyed.
    //

    BOOL fValid = BaseObject::xwDeleteHandle();
    if (fValid) {
        //
        // The Action may still be valid if it is in a Scheduler callback list.
        //

        xwFireFinalNL();
    }

    return fValid;
}


//---------------------------------------------------------------------------
Action * 
Action::Build(
    IN  GList<Action> * plstParent,     // List containing Action
    IN  const GMA_ACTION * pma,         // Timing information
    IN  DWORD dwCurTick,                // Current time
    IN  BOOL fPresent)                  // Action is already present
{
    AssertMsg(plstParent != NULL, "Must specify a parent");

    Action * pact = ClientNew(Action);
    if (pact == NULL) {
        return NULL;
    }

    
    //
    // Copy the Action information over and determine the amount of time between
    // timeslices.
    //
    // For the default time (0), use 10 ms.
    // For no time (-1), use 0 ms.
    //
    
    pact->m_ma = *pma;
    pact->m_dwLastProcessTick = dwCurTick;

    if (pact->m_ma.dwPause == 0) {
        pact->m_ma.dwPause = 10;
    } else if (pact->m_ma.dwPause == (DWORD) -1) {
        pact->m_ma.dwPause = 0;
    }


    //
    // When creating the new Action, it needs to be in the future or the
    // beginning part of the Action may be clipped.  However, if it is actually
    // in the present, set the starting time to right now so that it doesn't
    // get delayed.
    //

    pact->m_fSingleShot = IsPresentTime(pma->flDuration);
    pact->m_plstParent  = plstParent;

    if (fPresent) {
        pact->ResetPresent(dwCurTick);
    } else {
        pact->ResetFuture(dwCurTick, TRUE);
    }
    pact->SetPresent(fPresent);

    return pact;
}


//---------------------------------------------------------------------------
void
Action::Process(DWORD dwCurTime, BOOL * pfFinishedPeriod, BOOL * pfFire)
{
    AssertWritePtr(pfFinishedPeriod);
    AssertWritePtr(pfFire);

#if DBG
    m_DEBUG_fFireValid  = FALSE;
#endif // DBG

    *pfFire             = FALSE;
    *pfFinishedPeriod   = FALSE;

    if (IsPresent()) {
        //
        // Processing a present action, so determine our progress through the
        // action and callback.
        //

        if (m_fSingleShot) {
            //
            // Single-shot Action
            //

            m_dwLastProcessTick = dwCurTime;
            m_flLastProgress    = 1.0f;
            *pfFinishedPeriod   = TRUE;
            *pfFire             = TRUE;
        } else {
            //
            // Continuous Action
            //

            int nElapsed     = ComputePastTickDelta(dwCurTime, m_dwStartTick);
            float flProgress = (nElapsed / m_ma.flDuration) / 1000.0f;
            if (flProgress > 1.0f) {
                flProgress = 1.0f;
            }

            int nDelta = ComputeTickDelta(dwCurTime, m_dwLastProcessTick + GetPauseTimeOut());
            *pfFire = nDelta > 0;  // Full pause has elapsed
            if (*pfFire) {
                 m_dwLastProcessTick = dwCurTime;
            }

            *pfFinishedPeriod   = (flProgress >= 1.0f);
            m_flLastProgress    = flProgress;
        }

#if DBG
        m_DEBUG_fFireValid  = *pfFire;
#endif // DBG
        AssertMsg(!m_fDestroy, "Should not be marked as being destroyed yet");
    } else {
        //
        // Processing a future action, so advance counters
        //

        int nElapsed        = ComputeTickDelta(dwCurTime, m_dwStartTick);
        if (nElapsed >= 0) {
            //
            // The action is now ready to be executed.
            //

            *pfFinishedPeriod = TRUE;
        }
    }
}


//---------------------------------------------------------------------------
void
Action::xwFireNL()
{
    //
    // NOTE: xwFireNL() expects that m_flLastProgress and m_fDestroy were
    // properly filled in from the last call to Process().
    //

    AssertMsg(m_DEBUG_fFireValid, "Only valid if last call to Process() returned fFire");

    GMA_ACTIONINFO mai;
    mai.hact        = (HACTION) GetHandle();
    mai.pvData      = m_ma.pvData;
    mai.flDuration  = m_ma.flDuration;
    mai.flProgress  = m_flLastProgress;
    mai.cEvent      = m_cEventsInPeriod++;
    mai.fFinished   = m_fDestroy;

#if DBG_CHECK_CALLBACKS
    BEGIN_CALLBACK()
#endif

    __try 
    {
        (m_ma.pfnProc)(&mai);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

#if DBG_CHECK_CALLBACKS
    END_CALLBACK()
#endif


    //
    // If the Action is complete and has not been manually destroyed, destroy
    // it now.  The Action will still exist until the Scheduler actually 
    // Unlock()'s it.
    //

    if ((!m_fDestroy) && m_fDeleteInFire) {
        AssertMsg(IsComplete(), "Must be complete to destroy");
        VerifyMsg(xwDeleteHandle(), "Should still be valid.");
    }
}


/***************************************************************************\
*
* Action::xwFireFinalNL
*
* xwFireFinalNL() fires the final notification to the Action.  Any 
* notifications that the Action fires after this point will be sent to
* EmptyActionProc().  This function can be called both by the destructor as
* well as xwDeleteHandle() when the object doesn't finally go away.
*
\***************************************************************************/

void
Action::xwFireFinalNL()
{
    if (m_fDestroy) {
        return;
    }

#if DBG
    m_DEBUG_fFireValid  = TRUE;
#endif // DBG

    m_flLastProgress    = 1.0f;
    m_fDestroy          = TRUE;

    xwFireNL();

    m_ma.pfnProc = EmptyActionProc;
}


//---------------------------------------------------------------------------
void
Action::EndPeriod()
{
    if ((m_ma.cRepeat != 0) && (m_ma.cRepeat != (UINT) -1)) {
        m_ma.cRepeat--;
    }
}


//---------------------------------------------------------------------------
void
Action::EmptyActionProc(GMA_ACTIONINFO * pmai)
{
    UNREFERENCED_PARAMETER(pmai);
}


#if DBG

//---------------------------------------------------------------------------
void
Action::DEBUG_MarkInFire(BOOL fInFire)
{
    AssertMsg(!fInFire != !m_DEBUG_fInFire, "Must be switching states");

    m_DEBUG_fInFire = fInFire;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\action.inl ===
#if !defined(MOTION__Action_inl__INCLUDED)
#define MOTION__Action_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

/*
 * ComputeTickDelta: PORTED FROM NT-USER
 *
 * ComputeTickDelta computes a time delta between two times.  The
 * delta is defined as a 31-bit, signed value.  It is best to think of time as
 * a clock that wraps around.  The delta is the minimum distance on this circle
 * between two different places on the circle.  If the delta goes
 * counter-clockwise, it is looking at a time in the PAST and is POSITIVE.  If
 * the delta goes clockwise, it is looking at a time in the FUTURE and is
 * negative.
 *
 * It is IMPORTANT to realize that the (dwCurTime >= dwLastTime) comparison does
 * not determine the delta's sign, but only determines the operation to compute
 * the delta without an overflow occuring.
 */

//---------------------------------------------------------------------------
inline
int ComputeTickDelta(
    IN DWORD dwCurTick,
    IN DWORD dwLastTick)
{
    return (int) (dwCurTick - dwLastTick);
}


//---------------------------------------------------------------------------
inline
int ComputePastTickDelta(
    IN DWORD dwCurTick,
    IN DWORD dwLastTick)
{
    int nDelta = ComputeTickDelta(dwCurTick, dwLastTick);
    AssertMsg(nDelta >= 0, "Ensure delta occurs in the past");
    return nDelta;
}


/***************************************************************************\
*****************************************************************************
*
* class Action
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Action * CastAction(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htAction)) {
        return (Action *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline bool IsPresentTime(float fl)
{
    return (fl < 0.01f);
}


//------------------------------------------------------------------------------
inline BOOL
Action::IsPresent() const
{
    AssertMsg((!m_fPresent) || IsPresentTime(m_ma.flDelay), "Ensure delay matches if present");
    return m_fPresent;
}


//------------------------------------------------------------------------------
inline BOOL
Action::IsComplete() const
{
    return (m_ma.cRepeat == 0);
}


//------------------------------------------------------------------------------
inline DWORD       
Action::GetStartTime() const
{
    return m_dwStartTick;
}


//------------------------------------------------------------------------------
inline float       
Action::GetStartDelay() const
{
    float flDelay = m_ma.flPeriod - m_ma.flDuration;
    if (flDelay < 0.0f) {
        flDelay = 0.0f;
    }

    return flDelay;
}


//------------------------------------------------------------------------------
inline Thread *    
Action::GetThread() const
{
    return m_pThread;
}


//------------------------------------------------------------------------------
inline void        
Action::SetPresent(BOOL fPresent)
{
    m_fPresent   = fPresent;
    if (fPresent) {
        m_ma.flDelay = 0.0f;
    }
}


//---------------------------------------------------------------------------
inline void        
Action::SetParent(GList<Action> * plstParent)
{
    m_plstParent = plstParent;
}


/***************************************************************************\
*
* Action::ResetPresent
*
* ResetPresent() resets the Action's counters to be called immediately.
*
\***************************************************************************/

inline void        
Action::ResetPresent(DWORD dwCurTick)
{
    m_dwStartTick = dwCurTick;
}


/***************************************************************************\
*
* Action::ResetFuture
*
* ResetFuture() resets the Action's counters into the future for the next
* time the Action will be called.
*
\***************************************************************************/

inline void        
Action::ResetFuture(DWORD dwCurTick, BOOL fInit)
{
    float flDelay = GetStartDelay();
    if (fInit) {
        flDelay += m_ma.flDelay;
    }
    m_dwStartTick = dwCurTick + (int) (flDelay * 1000.0f);
}


//---------------------------------------------------------------------------
inline DWORD
Action::GetIdleTimeOut(DWORD dwCurTick) const
{
    //
    // Return the amount of time needed before this Action starts to get 
    // processed.  The Future is the reverse of the normal ComputeTickDelta().
    // We also need to make sure that the time returned is never in the past.
    //

    int nFuture = -ComputeTickDelta(dwCurTick, m_dwStartTick);
    return nFuture >= 0 ? (DWORD) (nFuture) : 0;
}


//---------------------------------------------------------------------------
inline DWORD
Action::GetPauseTimeOut() const
{
    //
    // Return the amount of time that the Action requests before its next
    // timeslice.  This is used to keep long-lived Actions from taking all of
    // the CPU time, but is different than IdleTimeOut which is the amount of
    // time before the Action needs to execute again.
    //

    return m_ma.dwPause;
}


//---------------------------------------------------------------------------
inline void
Action::MarkDelete(BOOL fDelete)
{
    AssertMsg(!m_fDeleteInFire, "Only should be marked to be deleted once");
    m_fDeleteInFire = fDelete;
}


#endif // MOTION__Action_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\colors.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Colors.h"

ColorInfo g_rgciStd[] = {
    { L"AliceBlue",             RGB(240,248,255)    },
    { L"AntiqueWhite",          RGB(250,235,215)    },
    { L"Aqua",                  RGB(0,255,255)      },
    { L"Aquamarine",            RGB(127,255,212)    },
    { L"Azure",                 RGB(240,255,255)    },
    { L"Beige",                 RGB(245,245,220)    },
    { L"Bisque",                RGB(255,228,196)    },
    { L"Black",                 RGB(0,0,0)          },
    { L"BlanchedAlmond",        RGB(255,235,205)    },
    { L"Blue",                  RGB(0,0,255)        },
    { L"BlueViolet",            RGB(138,43,226)     },
    { L"Brown",                 RGB(165,42,42)      },
    { L"BurlyWood",             RGB(222,184,135)    },
    { L"CadetBlue",             RGB(95,158,160)     },
    { L"Chartreuse",            RGB(127,255,0)      },
    { L"Chocolate",             RGB(210,105,30)     },
    { L"Coral",                 RGB(255,127,80)     },
    { L"CornflowerBlue",        RGB(100,149,237)    },
    { L"Cornsilk",              RGB(255,248,220)    },
    { L"Crimson",               RGB(220,20,60)      },
    { L"Cyan",                  RGB(0,255,255)      },
    { L"DarkBlue",              RGB(0,0,139)        },
    { L"DarkCyan",              RGB(0,139,139)      },
    { L"DarkGoldenrod",         RGB(184,134,11)     },
    { L"DarkGray",              RGB(169,169,169)    },
    { L"DarkGreen",             RGB(0,100,0)        },
    { L"DarkKhaki",             RGB(189,183,107)    },
    { L"DarkMagenta",           RGB(139,0,139)      },
    { L"DarkOliveGreen",        RGB(85,107,47)      },
    { L"DarkOrange",            RGB(255,140,0)      },
    { L"DarkOrchid",            RGB(153,50,204)     },
    { L"DarkRed",               RGB(139,0,0)        },
    { L"DarkSalmon",            RGB(233,150,122)    },
    { L"DarkSeaGreen",          RGB(143,188,143)    },
    { L"DarkSlateBlue",         RGB(72,61,139)      },
    { L"DarkSlateGray",         RGB(47,79,79)       },
    { L"DarkTurquoise",         RGB(0,206,209)      },
    { L"DarkViolet",            RGB(148,0,211)      },
    { L"DeepPink",              RGB(255,20,147)     },
    { L"DeepSkyBlue",           RGB(0,191,255)      },
    { L"DimGray",               RGB(105,105,105)    },
    { L"DodgerBlue",            RGB(30,144,255)     },
    { L"FireBrick",             RGB(178,34,34)      },
    { L"FloralWhite",           RGB(255,250,240)    },
    { L"ForestGreen",           RGB(34,139,34)      },
    { L"Fuchsia",               RGB(255,0,255)      },
    { L"Gainsboro",             RGB(220,220,220)    },
    { L"GhostWhite",            RGB(248,248,255)    },
    { L"Gold",                  RGB(255,215,0)      },
    { L"Goldenrod",             RGB(218,165,32)     },
    { L"Gray",                  RGB(128,128,128)    },
    { L"Green",                 RGB(0,128,0)        },
    { L"GreenYellow",           RGB(173,255,47)     },
    { L"Honeydew",              RGB(240,255,240)    },
    { L"HotPink",               RGB(255,105,180)    },
    { L"IndianRed",             RGB(205,92,92)      },
    { L"Indigo",                RGB(75,0,130)       },
    { L"Ivory",                 RGB(255,255,240)    },
    { L"Khaki",                 RGB(240,230,140)    },
    { L"Lavender",              RGB(230,230,250)    },
    { L"LavenderBlush",         RGB(255,240,245)    },
    { L"LawnGreen",             RGB(124,252,0)      },
    { L"LemonChiffon",          RGB(255,250,205)    },
    { L"LightBlue",             RGB(173,216,230)    },
    { L"LightCoral",            RGB(240,128,128)    },
    { L"LightCyan",             RGB(224,255,255)    },
    { L"LightGoldenrodYellow",  RGB(250,250,210)    },
    { L"LightGreen",            RGB(144,238,144)    },
    { L"LightGrey",             RGB(211,211,211)    },
    { L"LightPink",             RGB(255,182,193)    },
    { L"LightSalmon",           RGB(255,160,122)    },
    { L"LightSeaGreen",         RGB(32,178,170)     },
    { L"LightSkyBlue",          RGB(135,206,250)    },
    { L"LightSlateGray",        RGB(119,136,153)    },
    { L"LightSteelBlue",        RGB(176,196,222)    },
    { L"LightYellow",           RGB(255,255,224)    },
    { L"Lime",                  RGB(0,255,0)        },
    { L"LimeGreen",             RGB(50,205,50)      },
    { L"Linen",                 RGB(250,240,230)    },
    { L"Magenta",               RGB(255,0,255)      },
    { L"Maroon",                RGB(128,0,0)        },
    { L"MediumAquamarine",      RGB(102,205,170)    },
    { L"MediumBlue",            RGB(0,0,205)        },
    { L"MediumOrchid",          RGB(186,85,211)     },
    { L"MediumPurple",          RGB(147,112,219)    },
    { L"MediumSeaGreen",        RGB(60,179,113)     },
    { L"MediumSlateBlue",       RGB(123,104,238)    },
    { L"MediumSpringGreen",     RGB(0,250,154)      },
    { L"MediumTurquoise",       RGB(72,209,204)     },
    { L"MediumVioletRed",       RGB(199,21,133)     },
    { L"MidnightBlue",          RGB(25,25,112)      },
    { L"MintCream",             RGB(245,255,250)    },
    { L"MistyRose",             RGB(255,228,225)    },
    { L"Moccasin",              RGB(255,228,181)    },
    { L"NavajoWhite",           RGB(255,222,173)    },
    { L"Navy",                  RGB(0,0,128)        },
    { L"OldLace",               RGB(253,245,230)    },
    { L"Olive",                 RGB(128,128,0)      },
    { L"OliveDrab",             RGB(107,142,35)     },
    { L"Orange",                RGB(255,165,0)      },
    { L"OrangeRed",             RGB(255,69,0)       },
    { L"Orchid",                RGB(218,112,214)    },
    { L"PaleGoldenrod",         RGB(238,232,170)    },
    { L"PaleGreen",             RGB(152,251,152)    },
    { L"PaleTurquoise",         RGB(175,238,238)    },
    { L"PaleVioletRed",         RGB(219,112,147)    },
    { L"PapayaWhip",            RGB(255,239,213)    },
    { L"PeachPuff",             RGB(255,218,185)    },
    { L"Peru",                  RGB(205,133,63)     },
    { L"Pink",                  RGB(255,192,203)    },
    { L"Plum",                  RGB(221,160,221)    },
    { L"PowderBlue",            RGB(176,224,230)    },
    { L"Purple",                RGB(128,0,128)      },
    { L"Red",                   RGB(255,0,0)        },
    { L"RosyBrown",             RGB(188,143,143)    },
    { L"RoyalBlue",             RGB(65,105,225)     },
    { L"SaddleBrown",           RGB(139,69,19)      },
    { L"Salmon",                RGB(250,128,114)    },
    { L"SandyBrown",            RGB(244,164,96)     },
    { L"SeaGreen",              RGB(46,139,87)      },
    { L"Seashell",              RGB(255,245,238)    },
    { L"Sienna",                RGB(160,82,45)      },
    { L"Silver",                RGB(192,192,192)    },
    { L"SkyBlue",               RGB(135,206,235)    },
    { L"SlateBlue",             RGB(106,90,205)     },
    { L"SlateGray",             RGB(112,128,144)    },
    { L"Snow",                  RGB(255,250,250)    },
    { L"SpringGreen",           RGB(0,255,127)      },
    { L"SteelBlue",             RGB(70,130,180)     },
    { L"Tan",                   RGB(210,180,140)    },
    { L"Teal",                  RGB(0,128,128)      },
    { L"Thistle",               RGB(216,191,216)    },
    { L"Tomato",                RGB(255,99,71)      },
    { L"Turquoise",             RGB(64,224,208)     },
    { L"Violet",                RGB(238,130,238)    },
    { L"Wheat",                 RGB(245,222,179)    },
    { L"White",                 RGB(255,255,255)    },
    { L"WhiteSmoke",            RGB(245,245,245)    },
    { L"Yellow",                RGB(255,255,0)      },
    { L"YellowGreen",           RGB(154,205,50)     },
};


//------------------------------------------------------------------------------
UINT
GdFindStdColor(LPCWSTR pszName)
{
    //
    // TODO: Change this to do a more efficient search:
    // - Convert name to lower-case before starting
    // - Create a hash code
    // - Perform a binary search comparing hashes
    //

    for (int idx = 0; idx <= SC_MAXCOLORS; idx++) {
        if (_wcsicmp(g_rgciStd[idx].GetName(), pszName) == 0) {
            //
            // Found match
            //

            return idx;
        }
    }

    // Can't find anything
    return (UINT) -1;
}


//------------------------------------------------------------------------------
HPALETTE    
GdGetStdPalette()
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\colors.inl ===
#if !defined(UTIL__Colors_inl__INCLUDED)
#define UTIL__Colors_inl__INCLUDED

extern ColorInfo g_rgciStd[];

//------------------------------------------------------------------------------
inline LPCWSTR     
ColorInfo::GetName() const
{
    return m_pszName;
}


//------------------------------------------------------------------------------
inline COLORREF    
ColorInfo::GetColorI() const
{
    return m_cr;
}


//------------------------------------------------------------------------------
inline Gdiplus::Color
ColorInfo::GetColorF() const
{
    return Gdiplus::Color(GetRValue(m_cr), GetGValue(m_cr), GetBValue(m_cr));
}


//------------------------------------------------------------------------------
inline const ColorInfo * 
GdGetColorInfo(UINT c)
{
    AssertMsg(c <= SC_MAXCOLORS, "Ensure valid index");
    return &g_rgciStd[c];
}


#endif // UTIL__Colors_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\action.h ===
#if !defined(MOTION__Action_h__INCLUDED)
#define MOTION__Action_h__INCLUDED

/***************************************************************************\
*
* class Action
*
* Action maintains a single action to be called by the Scheduler at the
* appointed time.
*
\***************************************************************************/

class Action : public BaseObject, public ListNodeT<Action>
{
// Construction
public:
            Action();
    virtual ~Action();          // Must use xwUnlock() to remove
protected:
    virtual BOOL        xwDeleteHandle();
public:
    static  Action *    Build(GList<Action> * plstParent, const GMA_ACTION * pma,
                                DWORD dwCurTick, BOOL fPresent);

// Operations
public:
    inline  BOOL        IsPresent() const;
    inline  BOOL        IsComplete() const;
    inline  DWORD       GetStartTime() const;

    inline  void        SetPresent(BOOL fPresent);
    inline  void        SetParent(GList<Action> * plstParent);

    inline  float       GetStartDelay() const;
    inline  DWORD       GetIdleTimeOut(DWORD dwCurTick) const;
    inline  DWORD       GetPauseTimeOut() const;
    inline  Thread *    GetThread() const;

    inline  void        ResetPresent(DWORD dwCurTick);
    inline  void        ResetFuture(DWORD dwCurTick, BOOL fInit);
            void        Process(DWORD dwCurTick, BOOL * pfFinishedPeriod, BOOL * pfFire);
            void        EndPeriod();

            void        xwFireNL();
            void        xwFireFinalNL();

    inline  void        MarkDelete(BOOL fDelete);

#if DBG
            void        DEBUG_MarkInFire(BOOL fInFire);
#endif // DBG

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htAction; }
    virtual UINT        GetHandleMask() const { return 0; }

// Implementation
protected:
    static  void CALLBACK 
                        EmptyActionProc(GMA_ACTIONINFO * pmai);


// Data
protected:
            Thread *    m_pThread;
            GMA_ACTION  m_ma;
            GList<Action> * m_plstParent;
            UINT        m_cEventsInPeriod;
            UINT        m_cPeriods;
            DWORD       m_dwStartTick;
            DWORD       m_dwLastProcessTick;
            BOOL        m_fPresent:1;
            BOOL        m_fSingleShot:1;
            BOOL        m_fDestroy:1;       // Action is being destroyed
            BOOL        m_fDeleteInFire:1;  // Action should be deleted during
                                            // the next xwFire().


            // Cache some data from last call to Process() to be used in 
            // xwFire().
#if DBG
            BOOL        m_DEBUG_fFireValid;
            BOOL        m_DEBUG_fInFire;
#endif // DBG

            float       m_flLastProgress;

    // Need to make the collection classes friends to give access to destructor.
    // NOTE: These lists should never actually destroy the objects.
    friend GList<Action>;
};

#include "Action.inl"

#endif // MOTION__Action_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\context.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Context.h"

#include "Action.h"


/***************************************************************************\
*****************************************************************************
*
* class MotionSC
*
*****************************************************************************
\***************************************************************************/

IMPLEMENT_SUBCONTEXT(Context::slMotion, MotionSC);


//------------------------------------------------------------------------------
MotionSC::~MotionSC()
{
    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    for (UINT idx = 0; idx < SC_MAXCOLORS; idx++) {
        if (m_rghbrStd[idx] != NULL) {
            DeleteObject(m_rghbrStd[idx]);
        }
        if (m_rghpenStd[idx] != NULL) {
            DeleteObject(m_rghpenStd[idx]);
        }
        if (m_rgpgpbrStd[idx] != NULL) {
            delete m_rgpgpbrStd[idx];
        }
        if (m_rgpgppenStd[idx] != NULL) {
            delete m_rgpgppenStd[idx];
        }
    }
}

    
/***************************************************************************\
*
* MotionSC::OnIdle
*
* OnIdle() gives this SubContext an opportunity to perform any idle-time
* processing.  This is time when there are no more messages to process.
*
\***************************************************************************/

DWORD
MotionSC::xwOnIdleNL()
{
    int nDelta;
    DWORD dwDelay, dwCurTick;

    dwCurTick = ::GetTickCount();
    nDelta = ComputeTickDelta(dwCurTick, m_dwLastTimeslice + m_dwPauseTimeslice);
    if (nDelta >= 0) {
        //
        // The timeslice is up again, so let the Scheduler process the Actions.
        //

        dwDelay = m_sch.xwProcessActionsNL();
        m_dwLastTimeslice = dwCurTick;
    } else {
        dwDelay = (DWORD) (-nDelta);
    }

    return dwDelay;
}


/***************************************************************************\
*
* MotionSC::xwPreDestroyNL
*
* xwPreDestroyNL() gives this SubContext an opportunity to perform any cleanup 
* while the Context is still valid.  Any operations that involve callbacks
* MUST be done at this time.
*
\***************************************************************************/

void        
MotionSC::xwPreDestroyNL()
{
    //
    // When we callback to allow the SubContext's to destroy, we need to
    // grab a ContextLock so that we can defer messages.  When we leave 
    // this scope, all of these messages will be triggered.  This needs
    // to occur BEFORE the Context continues getting blown away.
    //

    ContextLock cl;
    Verify(cl.LockNL(ContextLock::edDefer, m_pParent));

    m_sch.xwPreDestroy();
}


//------------------------------------------------------------------------------
Gdiplus::Brush *
MotionSC::GetBrushF(UINT idxBrush) const
{
    AssertMsg(idxBrush <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rgpgpbrStd[idxBrush] == NULL) {
        if (!ResourceManager::IsInitGdiPlus()) {
            return NULL;
        }

        m_rgpgpbrStd[idxBrush] = new Gdiplus::SolidBrush(GdGetColorInfo(idxBrush)->GetColorF());
    }

    return m_rgpgpbrStd[idxBrush];
}


//------------------------------------------------------------------------------
Gdiplus::Pen *
MotionSC::GetPenF(UINT idxPen) const
{
    AssertMsg(idxPen <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rgpgppenStd[idxPen] == NULL) {
        if (!ResourceManager::IsInitGdiPlus()) {
            return NULL;
        }

        m_rgpgppenStd[idxPen] = new Gdiplus::Pen(GdGetColorInfo(idxPen)->GetColorF());
    }

    return m_rgpgppenStd[idxPen];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\context.h ===
#if !defined(MOTION__Context_h__INCLUDED)
#define MOTION__Context_h__INCLUDED
#pragma once

#include "Scheduler.h"

/***************************************************************************\
*****************************************************************************
*
* MotionSC contains Context-specific information used by the Motion project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Context object.
*
*****************************************************************************
\***************************************************************************/

class MotionSC : public SubContext
{
// Construction
public:
    inline  MotionSC();
    virtual ~MotionSC();
    virtual void        xwPreDestroyNL();

// Operations
public:
    inline  Scheduler * GetScheduler();
    inline  DWORD       GetTimeslice();
    inline  void        SetTimeslice(DWORD dwTimeslice);

    inline  HBRUSH      GetBrushI(UINT idxBrush) const;
            Gdiplus::Brush *
                        GetBrushF(UINT idxBrush) const;
    inline  HPEN        GetPenI(UINT idxPen) const;
            Gdiplus::Pen *
                        GetPenF(UINT idxPen) const;

    virtual DWORD       xwOnIdleNL();

// Data
protected:
            Scheduler   m_sch;
            DWORD       m_dwLastTimeslice;
            DWORD       m_dwPauseTimeslice;

    //
    // NOTE: Both GDI and GDI+ lock the brush / pen objects when they are 
    // being used.  This means that if multiple threads try to use the same 
    // brush, the function calls may fail.
    //

    mutable HBRUSH      m_rghbrStd[SC_MAXCOLORS];
    mutable HPEN        m_rghpenStd[SC_MAXCOLORS];
    mutable Gdiplus::SolidBrush * 
                        m_rgpgpbrStd[SC_MAXCOLORS];
    mutable Gdiplus::Pen * 
                        m_rgpgppenStd[SC_MAXCOLORS];

};
                    
inline  MotionSC *  GetMotionSC();
inline  MotionSC *  GetMotionSC(Context * pContext);

#include "Context.inl"

#endif // MOTION__Context_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\context.inl ===
#if !defined(MOTION__Context_inl__INCLUDED)
#define MOTION__Context_inl__INCLUDED
#pragma once

#include "Colors.h"

//------------------------------------------------------------------------------
inline MotionSC *   
GetMotionSC()
{
    return static_cast<MotionSC *> (GetContext()->GetSC(Context::slMotion));
}


//------------------------------------------------------------------------------
inline MotionSC *    
GetMotionSC(Context * pContext)
{
    return static_cast<MotionSC *> (pContext->GetSC(Context::slMotion));
}


//------------------------------------------------------------------------------
inline
MotionSC::MotionSC()
{
    m_dwLastTimeslice = ::GetTickCount();
    m_dwPauseTimeslice = 0;
}


//------------------------------------------------------------------------------
inline Scheduler * 
MotionSC::GetScheduler()
{
    return &m_sch;
}


//------------------------------------------------------------------------------
inline DWORD
MotionSC::GetTimeslice()
{
    return m_dwPauseTimeslice;
}


//------------------------------------------------------------------------------
inline void
MotionSC::SetTimeslice(DWORD dwTimeslice)
{
    m_dwPauseTimeslice = dwTimeslice;
}


//------------------------------------------------------------------------------
inline HBRUSH
MotionSC::GetBrushI(UINT idxBrush) const
{
    AssertMsg(idxBrush <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rghbrStd[idxBrush] == NULL) {
        m_rghbrStd[idxBrush] = CreateSolidBrush(GdGetColorInfo(idxBrush)->GetColorI());
    }

    return m_rghbrStd[idxBrush];
}


//------------------------------------------------------------------------------
inline HPEN
MotionSC::GetPenI(UINT idxPen) const
{
    AssertMsg(idxPen <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rghpenStd[idxPen] == NULL) {
        m_rghpenStd[idxPen] = CreatePen(PS_SOLID, 1, GdGetColorInfo(idxPen)->GetColorI());
    }

    return m_rghpenStd[idxPen];
}


#endif // MOTION__Context_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\dxform3drmtrx.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "DXForm3DRMTrx.h"


//**************************************************************************************************
//
// class DXForm3DRMTrx
//
//**************************************************************************************************

//------------------------------------------------------------------------------
DXForm3DRMTrx::DXForm3DRMTrx()
{

}


//------------------------------------------------------------------------------
DXForm3DRMTrx::~DXForm3DRMTrx()
{

}


//------------------------------------------------------------------------------
BOOL        
DXForm3DRMTrx::Create(const GTX_DXTX3DRM_TRXDESC * ptxData)
{
    //
    // Need to setup DxXForm's for Retained Mode before creating the actual
    // transform.
    //

    HRESULT hr;
    hr = GetDxManager()->GetTransformFactory()->SetService(SID_SDirect3DRM, ptxData->pRM, FALSE);
    if (FAILED(hr)) {
        return FALSE;
    }

    GTX_DXTX2D_TRXDESC td;
    td.tt               = GTX_TYPE_DXFORM2D;
    td.clsidTransform   = ptxData->clsidTransform;
    td.flDuration       = ptxData->flDuration;
    td.pszCopyright     = ptxData->pszCopyright;

    if (!DXFormTrx::Create(&td)) {
        return FALSE;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
DXForm3DRMTrx * 
DXForm3DRMTrx::Build(const GTX_DXTX3DRM_TRXDESC * ptxData)
{
    DXForm3DRMTrx * ptrx = ClientNew(DXForm3DRMTrx);
    if (ptrx == NULL) {
        return NULL;
    }

    if (!ptrx->Create(ptxData)) {
        ClientDelete(DXForm3DRMTrx, ptrx);
        return NULL;
    }

    return ptrx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\dxformtrx.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "DXFormTrx.h"

//**************************************************************************************************
//
// class DXFormTrx
//
//**************************************************************************************************

//------------------------------------------------------------------------------
DXFormTrx::DXFormTrx()
{
    m_pdxTransform  = NULL;
    m_pdxEffect     = NULL;
}


//------------------------------------------------------------------------------
DXFormTrx::~DXFormTrx()
{
    SafeRelease(m_pdxTransform);
    SafeRelease(m_pdxEffect);
}


/***************************************************************************\
*
* DXFormTrx::Build
*
* Build() creates an initializes a new instance of DXFormTrx.
*
\***************************************************************************/

DXFormTrx *   
DXFormTrx::Build(const GTX_DXTX2D_TRXDESC * ptxData)
{
    DXFormTrx * ptrx = ClientNew(DXFormTrx);
    if (ptrx == NULL) {
        return NULL;
    }

    if (!ptrx->Create(ptxData)) {
        ClientDelete(DXFormTrx, ptrx);
        return NULL;
    }

    return ptrx;
}


//------------------------------------------------------------------------------
BOOL 
DXFormTrx::Create(const GTX_DXTX2D_TRXDESC * ptxData)
{
    // Check parameters and state
    Assert(m_pdxTransform == NULL);
    Assert(m_pdxEffect == NULL);

    //
    // Create the DX Transform
    //

    HRESULT hr;

    m_flDuration = ptxData->flDuration;

    hr = GetDxManager()->GetTransformFactory()->CreateTransform(NULL, 0, NULL, 0, 
            NULL, NULL, ptxData->clsidTransform, IID_IDXTransform, (void **)&m_pdxTransform);
    if (FAILED(hr) || (m_pdxTransform == NULL)) {
        goto Error;
    }

    hr = m_pdxTransform->QueryInterface(IID_IDXEffect, (void **)&m_pdxEffect);
    if (FAILED(hr) || (m_pdxEffect == NULL)) {
        goto Error;
    }


    m_pdxEffect->put_Duration(m_flDuration);


    //
    // Set any copyright information.  To do this, use IDispatch to at runtime 
    // search for any "Copyright" property to set.  
    //
    // Yes, this is a lot to do b/c IDispatch::Invoke() stinks.
    //

    if (ptxData->pszCopyright != NULL) {
        if (GetComManager()->Init(ComManager::sAuto)) {
            IDispatch * pdis = NULL;
            HRESULT hr = m_pdxTransform->QueryInterface(IID_IDispatch, (void **) &pdis);
            if (SUCCEEDED(hr)) {
                DISPID dispid;
                LPWSTR szMember = L"Copyright";
                hr = pdis->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                if (SUCCEEDED(hr)) {
                    BSTR bstrCP = GetComManager()->SysAllocString(ptxData->pszCopyright);
                    if (bstrCP != NULL) {
                        DISPPARAMS dp;
                        VARIANTARG rgvarg[1];

                        GetComManager()->VariantInit(&rgvarg[0]);
                        rgvarg[0].vt        = VT_BSTR;
                        rgvarg[0].bstrVal   = bstrCP;

                        DISPID dispidArg        = DISPID_PROPERTYPUT;
                        dp.rgvarg               = rgvarg;
                        dp.rgdispidNamedArgs    = &dispidArg;
                        dp.cArgs                = 1;
                        dp.cNamedArgs           = 1;

                        UINT nArgErr = 0;
                        hr = pdis->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
                                DISPATCH_PROPERTYPUT, &dp, NULL, NULL, &nArgErr);
                        GetComManager()->VariantClear(&rgvarg[0]);
                    }
                }

                pdis->Release();
            }
        } else {
            // Unable to initialize OLE-automation, so fail
            goto Error;
        }
    }

    return TRUE;

Error:
    SafeRelease(m_pdxTransform);
    SafeRelease(m_pdxEffect);
    return FALSE;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::CopyGadget(DxSurface * psurDest, HGADGET hgadSrc)
{
    BOOL fSuccess = FALSE;

    SIZE sizePxl;
    GetGadgetSize(hgadSrc, &sizePxl);

    //
    // Render the selected gadget directly onto the DxSurface.
    //

    IDXSurface * prawSur = psurDest->GetSurface();
    IDXDCLock * pdxLock = NULL;
    HRESULT hr = prawSur->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (SUCCEEDED(hr) && (pdxLock != NULL)) {
        HDC hdc = pdxLock->GetDC();

        RECT rcClient;
        rcClient.left   = 0;
        rcClient.top    = 0;
        rcClient.right  = sizePxl.cx;
        rcClient.bottom = sizePxl.cy;
        DrawGadgetTree(hgadSrc, hdc, &rcClient, GDRAW_SHOW);

        pdxLock->Release();
        fSuccess = TRUE;
    }
    
    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::InitTrx(const GTX_PLAY * pgx)
{
    HRESULT hr;

    DxSurface * psurIn0 = m_pbufTrx->GetSurface(0);
    DxSurface * psurIn1 = m_pbufTrx->GetSurface(1);
    DxSurface * psurOut = m_pbufTrx->GetSurface(2);

    if ((psurIn0 == NULL) || (psurIn1 == NULL) || (psurOut == NULL)) {
        return FALSE;
    }

    //
    // Initialize input surfaces
    //

    int cSurIn = 0;
    if (!InitTrxInputItem(&pgx->rgIn[0], psurIn0, cSurIn)) {
        goto Error;
    }
    if (!InitTrxInputItem(&pgx->rgIn[1], psurIn1, cSurIn)) {
        goto Error;
    }

    if (cSurIn <= 0) {
        goto Error;
    }


    //
    // Initialize the output surface
    //

    if (!InitTrxOutputItem(&pgx->gxiOut)) {
        goto Error;
    }

    //
    // Setup the transform
    //

    IUnknown *  rgIn[2];
    IUnknown *  rgOut[1];
    rgIn[0]     = psurIn0->GetSurface();
    rgIn[1]     = psurIn1->GetSurface();
    rgOut[0]    = psurOut->GetSurface();

    hr = m_pdxTransform->Setup(rgIn, cSurIn, rgOut, _countof(rgOut), 0);
    if (FAILED(hr)) {
        goto Error;
    }


    return TRUE;
Error:
    return FALSE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::InitTrxInputItem(const GTX_ITEM * pgxi, DxSurface * psur, int & cSurfaces)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        ;
        break;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmp            = (HBITMAP) pgxi->pvData;
            const RECT * prcCrop    = TestFlag(pgxi->nFlags, GTX_IF_CROP) ? &pgxi->rcCrop : NULL;

            if (!psur->CopyBitmap(hbmp, prcCrop)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_HDC:
        {
            HDC hdcSrc = (HDC) pgxi->pvData;

            RECT rcCrop;
            if (TestFlag(pgxi->nFlags, GTX_IF_CROP)) {
                rcCrop = pgxi->rcCrop;
            } else {
                rcCrop.left     = m_ptOffset.x;
                rcCrop.top      = m_ptOffset.y;
                rcCrop.right    = m_ptOffset.x + m_sizePxl.cx;
                rcCrop.bottom   = m_ptOffset.y + m_sizePxl.cy;
            }

            if (!psur->CopyDC(hdcSrc, rcCrop)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_HWND:
        AssertMsg(0, "TODO: Use PrintWindow to get bitmap");
        cSurfaces++;
        break;

    case GTX_ITEMTYPE_GADGET:
        {
            // TODO: Support GTX_IF_CROP flag

            HGADGET hgad = (HGADGET) pgxi->pvData;
            if (!CopyGadget(psur, hgad)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        AssertMsg(0, "TODO: Copy source from DX Surface");
        cSurfaces++;
        break;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::InitTrxOutputItem(const GTX_ITEM * pgxi)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        return FALSE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmpSrc = (HBITMAP) pgxi->pvData;
            if (hbmpSrc == NULL) {
                return FALSE;
            }
            HDC hdcBmp = GetGdiCache()->GetCompatibleDC();
            if (hdcBmp == NULL) {
                return FALSE;
            }
            m_hbmpOutOld = (HBITMAP) SelectObject(hdcBmp, hbmpSrc);

            m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
            m_gxiOutput.pvData  = hdcBmp;
        }
        break;

    case GTX_ITEMTYPE_HDC:
        m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
        m_gxiOutput.pvData  = pgxi->pvData;
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd = (HWND) pgxi->pvData;
            if (hwnd == NULL) {
                return FALSE;
            }

            m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
            m_gxiOutput.pvData  = GetDC(hwnd);
        }
        break;

    case GTX_ITEMTYPE_GADGET:
        AssertMsg(0, "Outputing directly to a Gadget is not yet supported");
        return FALSE;

    case GTX_ITEMTYPE_DXSURFACE:
        m_gxiOutput.it      = GTX_ITEMTYPE_DXSURFACE;
        m_gxiOutput.pvData  = NULL;
        break;
    }

    AssertMsg((m_gxiOutput.it == GTX_ITEMTYPE_HDC) || 
            (m_gxiOutput.it == GTX_ITEMTYPE_DXSURFACE), "Check output is supported");
    return TRUE;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::UninitTrx(const GTX_PLAY * pgx)
{
    //
    // When unitializing, it is very important call IDXTransform::Setup() and 
    // have the DXForm Release() the DXSurface buffers, or they will stick 
    // around for a long time and potentially have "memory leaks".
    //

    BOOL fSuccess = TRUE;
        
    if (!UninitTrxOutputItem(&pgx->gxiOut)) {
        fSuccess = FALSE;
    }

    HRESULT hr = m_pdxTransform->Setup(NULL, 0, NULL, 0, 0);
    if (FAILED(hr)) {
        fSuccess = FALSE;
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::UninitTrxOutputItem(const GTX_ITEM * pgxi)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    case GTX_ITEMTYPE_HDC:
    case GTX_ITEMTYPE_DXSURFACE:
    case GTX_ITEMTYPE_GADGET:
    default:
        // Nothing to do

        return TRUE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HDC hdcBmp = (HDC) m_gxiOutput.pvData;

            SelectObject(hdcBmp, m_hbmpOutOld);
            GetGdiCache()->ReleaseCompatibleDC(hdcBmp);
        }
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd   = (HWND) pgxi->pvData; 
            HDC hdc     = (HDC) m_gxiOutput.pvData;
           
            ReleaseDC(hwnd, hdc);
        }
        break;
    }

    AssertMsg((m_gxiOutput.it == GTX_ITEMTYPE_HDC) || 
            (m_gxiOutput.it == GTX_ITEMTYPE_DXSURFACE), "Check output is supported");
    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::DrawFrame(float fProgress, DxSurface * psurOut)
{
    //
    // Setup the positions used for drawing.  Always draw into the upper-left
    // corner of the DX-Surfaces, but remember to offset them properly when
    // copying to the final destination.
    //

    DXVEC Placement = { DXBT_DISCRETE, 0 };
    if (FAILED(m_pdxEffect->put_Progress(fProgress))) {
        return FALSE;
    }

    CDXDBnds bnds;
    bnds.SetXYSize(m_sizePxl.cx, m_sizePxl.cy);

    if (FAILED(m_pdxTransform->Execute(NULL, &bnds, &Placement))) {
        return FALSE;
    }

    switch (m_gxiOutput.it)
    {
    case GTX_ITEMTYPE_HDC:
        {
            HDC hdcDest = (HDC) m_gxiOutput.pvData;
            DXSrcCopy(hdcDest, m_ptOffset.x, m_ptOffset.y, m_sizePxl.cx, m_sizePxl.cy, 
                    psurOut->GetSurface(), 0, 0);
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        AssertMsg(0, "TODO: Implement support");

        //
        // Probably just stuff the IDirectDrawSurface7 into some pointer and
        // allow the caller to copy the bits directly.
        //

        break;

    default:
    AssertMsg(0, "Unsupported output type");
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::ComputeSizeItem(const GTX_ITEM * pgxi, SIZE & sizePxl) const
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        return FALSE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmp;
            BITMAP bmp;
            hbmp = (HBITMAP) pgxi->pvData;
            if (GetObject(hbmp, sizeof(bmp), &bmp) > 0) {
                sizePxl.cx = bmp.bmWidth;
                sizePxl.cy = bmp.bmHeight;
            }
        }
        break;

    case GTX_ITEMTYPE_HDC:
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd = (HWND) pgxi->pvData;
            RECT rcClient;
            GetClientRect(hwnd, &rcClient);
            sizePxl.cx = rcClient.right;
            sizePxl.cy = rcClient.bottom;
        }
        break;

    case GTX_ITEMTYPE_GADGET:
        {
            HGADGET hgad = (HGADGET) pgxi->pvData;
            GetGadgetSize(hgad, &sizePxl);
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        {
            // TODO: Need to query which surface type and call GetSurface() to
            // determine the dimensions

            AssertMsg(0, "TODO");
        }
        break;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL   
DXFormTrx::ComputeSize(const GTX_PLAY * pgx)
{
    SIZE sizeTempPxl;

    //
    // Start off at the full desktop size.  We really want to get smaller than 
    // this, but we need to include everything.
    //

    m_ptOffset.x    = 0;
    m_ptOffset.y    = 0;
    m_sizePxl.cx    = GetSystemMetrics(SM_CXVIRTUALSCREEN);;
    m_sizePxl.cy    = GetSystemMetrics(SM_CYVIRTUALSCREEN);;


    //
    // Check if an output crop was given.  This is the most important since it
    // can radically cut down the size.
    //

    if (TestFlag(pgx->gxiOut.nFlags, GTX_IF_CROP)) {
        const RECT & rcCrop = pgx->gxiOut.rcCrop;

        m_ptOffset.x    = rcCrop.left;
        m_ptOffset.y    = rcCrop.top;
        m_sizePxl.cx    = rcCrop.right - rcCrop.left;
        m_sizePxl.cy    = rcCrop.bottom - rcCrop.top;
    }

    //
    // Determine the minimum size from the inputs and outputs
    //

    if (pgx->gxiOut.it != GTX_ITEMTYPE_HDC) {
        //
        // Not an HDC, so can potentially compute and trim the size
        //

        sizeTempPxl = m_sizePxl;
        if (!ComputeSizeItem(&pgx->gxiOut, sizeTempPxl)) {
            return FALSE;
        }
        m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
        m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);
    }

    sizeTempPxl = m_sizePxl;
    if (!ComputeSizeItem(&pgx->rgIn[0], sizeTempPxl)) {
        return FALSE;
    }
    m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
    m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);

    if (pgx->rgIn[1].it != GTX_ITEMTYPE_NONE) {
        sizeTempPxl = m_sizePxl;
        if (!ComputeSizeItem(&pgx->rgIn[1], sizeTempPxl)) {
            m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
            m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Play(const GTX_PLAY * pgx)
{
    //
    // Check if already playing.
    //

    if (m_fPlay) {
        return FALSE;
    }


    BOOL fSuccess   = FALSE;
    m_pbufTrx       = NULL;

    if (!ComputeSize(pgx)) {
        return FALSE;
    }

    m_pbufTrx;
    HRESULT hr = GetBufferManager()->BeginTransition(m_sizePxl, 3, TRUE, &m_pbufTrx);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    if (!InitTrx(pgx)) {
        goto Cleanup;
    }

    //
    // Perform the transition
    //

    {
        DxSurface * psurOut = m_pbufTrx->GetSurface(2);

        DWORD dwStartTick   = GetTickCount();
        DWORD dwCurTick     = dwStartTick;
        DWORD dwDuration    = (DWORD) (m_flDuration * 1000.0f);
        m_fBackward         = (pgx->nFlags & GTX_EXEC_DIR) == GTX_EXEC_BACKWARD;
        float   fProgress;
    
        while ((dwCurTick - dwStartTick) <= dwDuration) {
            fProgress = ((float) dwCurTick - dwStartTick) / (float) dwDuration;
            if (m_fBackward) {
                fProgress = 1.0f - fProgress;
            }

            if (!DrawFrame(fProgress, psurOut)) {
                goto Cleanup;
            }
            dwCurTick = GetTickCount();
        }

        //
        // Never properly end on the dot, so force the issue.
        //

        if (m_fBackward) {
            fProgress = 0.0f;
        } else {
            fProgress = 1.0f;
        }

        if (!DrawFrame(fProgress, psurOut)) {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:
    UninitTrx(pgx);
    if (m_pbufTrx != NULL) {
        GetBufferManager()->EndTransition(m_pbufTrx, TestFlag(pgx->nFlags, GTX_EXEC_CACHE));
        m_pbufTrx = NULL;
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::GetInterface(IUnknown ** ppUnk)
{
    AssertWritePtr(ppUnk);

    if (m_pdxTransform != NULL) {
        m_pdxTransform->AddRef();
        *ppUnk = m_pdxTransform;
        return TRUE;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Begin(const GTX_PLAY * pgx)
{
    //
    // Check if already playing.
    //

    if (m_fPlay) {
        return FALSE;
    }


    m_pbufTrx = NULL;

    if (!ComputeSize(pgx)) {
        return FALSE;
    }

    m_pbufTrx;
    HRESULT hr = GetBufferManager()->BeginTransition(m_sizePxl, 3, TRUE, &m_pbufTrx);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (!InitTrx(pgx)) {
        GetBufferManager()->EndTransition(m_pbufTrx, FALSE);
        m_pbufTrx = NULL;
        return FALSE;
    }

    m_fBackward = (pgx->nFlags & GTX_EXEC_DIR) == GTX_EXEC_BACKWARD;
    m_fPlay     = TRUE;

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Print(float fProgress)
{
    //
    // Ensure already playing.
    //

    if (!m_fPlay) {
        return FALSE;
    }

    if (m_fBackward) {
        fProgress = 1.0f - fProgress;
    }

    DxSurface * psurOut = m_pbufTrx->GetSurface(2);
    return DrawFrame(fProgress, psurOut);
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::End(const GTX_PLAY * pgx)
{
    //
    // Ensure already playing.
    //

    if (!m_fPlay) {
        return FALSE;
    }

    UninitTrx(pgx);
    if (m_pbufTrx != NULL) {
        GetBufferManager()->EndTransition(m_pbufTrx, TestFlag(pgx->nFlags, GTX_EXEC_CACHE));
        m_pbufTrx = NULL;
    }

    m_fPlay = FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\dxform3drmtrx.h ===
#if !defined(MOTION__DXForm3DRMTrx_h__INCLUDED)
#define MOTION__DXForm3DRMTrx_h__INCLUDED

#include "DXFormTrx.h"

class DXForm3DRMTrx : public DXFormTrx
{
// Construction
public:
            DXForm3DRMTrx();
    virtual ~DXForm3DRMTrx();
protected:
            BOOL        Create(const GTX_DXTX3DRM_TRXDESC * ptxData);
public:
    static  DXForm3DRMTrx * Build(const GTX_DXTX3DRM_TRXDESC * ptxData);
};

#endif // MOTION__DXForm3DRMTrx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\dxformtrx.h ===
#if !defined(MOTION__DXFormTrx_h__INCLUDED)
#define MOTION__DXFormTrx_h__INCLUDED

#include "Transitions.h"

/***************************************************************************\
*
* class DXFormTrx
*
* DXFormTrx implements a DirectTransform Transition.
*
\***************************************************************************/

class DXFormTrx : public Transition
{
// Construction
public:
            DXFormTrx();
    virtual ~DXFormTrx();
protected:
            BOOL        Create(const GTX_DXTX2D_TRXDESC * ptxData);
public:
    static  DXFormTrx * Build(const GTX_DXTX2D_TRXDESC * ptxData);

// Transition Interface
protected:
    virtual BOOL        Play(const GTX_PLAY * pgx);
    virtual BOOL        GetInterface(IUnknown ** ppUnk);

    virtual BOOL        Begin(const GTX_PLAY * pgx);
    virtual BOOL        Print(float fProgress);
    virtual BOOL        End(const GTX_PLAY * pgx);

// Implementation
protected:
            BOOL        InitTrx(const GTX_PLAY * pgx);
            BOOL        InitTrxInputItem(const GTX_ITEM * pgxi, DxSurface * psur, int & cSurfaces);
            BOOL        InitTrxOutputItem(const GTX_ITEM * pgxi);
            BOOL        UninitTrx(const GTX_PLAY * pgx);
            BOOL        UninitTrxOutputItem(const GTX_ITEM * pgxi);
            BOOL        ComputeSize(const GTX_PLAY * pgx);
            BOOL        ComputeSizeItem(const GTX_ITEM * pgxi, SIZE & sizePxl) const;
            BOOL        DrawFrame(float fProgress, DxSurface * psurOut);
            BOOL        CopyGadget(DxSurface * psurDest, HGADGET hgadSrc);

// Data
protected:
            IDXTransform * m_pdxTransform;
            IDXEffect * m_pdxEffect;
            TrxBuffer * m_pbufTrx;      // Trx Buffer when playing

            float       m_flDuration;
            BOOL        m_fCache;       // Cached surfaces when finished

            POINT       m_ptOffset;
            SIZE        m_sizePxl;
            GTX_ITEM    m_gxiOutput;
            HBITMAP     m_hbmpOutOld;   // Bitmap needed to restore SelectObject()
};

#endif // MOTION__DXFormTrx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\motion.h ===
/***************************************************************************\
*
* File: Motion.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Motion_h__INCLUDED)
#define MOTION__Motion_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Motion Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // MOTION__Motion_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\scheduler.inl ===
#if !defined(MOTION__Scheduler_inl__INCLUDED)
#define MOTION__Scheduler_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline void        
Scheduler::Enter()
{
    m_lock.Enter();

#if DBG
    InterlockedExchange(&m_DEBUG_fLocked, TRUE);
#endif // DBG
}


//------------------------------------------------------------------------------
inline void        
Scheduler::Leave()
{
#if DBG
    InterlockedExchange(&m_DEBUG_fLocked, FALSE);
#endif // DBG

    m_lock.Leave();
}


#endif // MOTION__Scheduler_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\scheduler.cpp ===
/***************************************************************************\
*
* File: Scheduler.cpp
*
* Description:
* Scheduler.cpp maintains a collection of timers that are created and used
* by the application for notifications.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Motion.h"
#include "Scheduler.h"
#include "Action.h"

#include "Context.h"

/***************************************************************************\
*****************************************************************************
*
* class Scheduler
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
Scheduler::Scheduler()
{
#if DBG
    m_DEBUG_fLocked = FALSE;
#endif // DBG
}


//---------------------------------------------------------------------------
Scheduler::~Scheduler()
{
    AssertMsg(m_fShutdown, "Scheduler must be manually shutdown before destruction");
}


/***************************************************************************\
*
* Scheduler::xwPreDestroy
*
* xwPreDestroy() prepares the Scheduler for destruction while it is still
* valid to callback into the application.
*
\***************************************************************************/

void        
Scheduler::xwPreDestroy()
{
    m_fShutdown = TRUE;
    xwRemoveAllActions();
}


/***************************************************************************\
*
* Scheduler::AddAction
*
* AddAction() creates and adds a new Action, using the specified information.
*
\***************************************************************************/

Action *
Scheduler::AddAction(
    IN  const GMA_ACTION * pma)         // Action information
{
    //
    // Check if shutting down and don't allow any new Actions to be created.
    //

    if (m_fShutdown) {
        return NULL;
    }

    Action * pact;
    Enter();

    //
    // Determine which list to add the action to and add it.
    //

    GList<Action> * plstParent = NULL;
    bool fPresent = IsPresentTime(pma->flDelay);
    if (fPresent) {
        plstParent = &m_lstacPresent;
    } else {
        plstParent = &m_lstacFuture;
    }

    DWORD dwCurTick = GetTickCount();
    pact = Action::Build(plstParent, pma, dwCurTick, fPresent);
    if (pact == NULL) {
        goto Exit;
    }

    plstParent->Add(pact);


    //
    // Returning out the Action, so we need to lock the HACTION that we are 
    // giving back.
    //

    pact->Lock();

Exit:
    Leave();
    return pact;
}


/***************************************************************************\
*
* Scheduler::xwRemoveAllActions
*
* xwRemoveAllActions() removes all Actions still "owned" by the Scheduler.
*
\***************************************************************************/

void
Scheduler::xwRemoveAllActions()
{
    GArrayF<Action *>   aracFire;

    //
    // NOTE: We can not fire any notifications while inside the Scheduler lock,
    // or the Scheduler could get messed up.  Instead, we need to remember all
    // of the Actions to fire, and then fire them when we leave the lock.
    //
    
    Enter();

    int cItems = m_lstacPresent.GetSize() + m_lstacFuture.GetSize();
    aracFire.SetSize(cItems);
    
    int idxAdd = 0;
    while (!m_lstacPresent.IsEmpty()) {
        Action * pact = m_lstacPresent.UnlinkHead();
        VerifyMsg(pact->xwUnlock(), "Action should still be valid");
        
        pact->SetParent(NULL);
        aracFire[idxAdd++] = pact;
    }

    while (!m_lstacFuture.IsEmpty()) {
        Action * pact = m_lstacFuture.UnlinkHead();
        VerifyMsg(pact->xwUnlock(), "Action should still be valid");
        
        pact->SetParent(NULL);
        aracFire[idxAdd++] = pact;
    }

    AssertMsg(idxAdd == cItems, "Should have added all items");

    Leave();


    //
    // Don't fire from processing when removing the Actions.  Instead, only
    // have the destructors fire when the Action finally gets cleaned up.
    //

    xwFireNL(aracFire, FALSE);
}


/***************************************************************************\
*
* Scheduler::xwProcessActionsNL
*
* xwProcessActionsNL() processes the Actions for one iteration, moving 
* between queues and firing notifications.
*
\***************************************************************************/

DWORD
Scheduler::xwProcessActionsNL()
{
    DWORD dwCurTime = ::GetTickCount();

    //
    // NOTE: We need to leave the lock when calling back as part of the
    // Action::Fire() mechanism.  To accomplish this, we store up all of the
    // Actions to callback during processing and callback after leaving the
    // lock.
    //
    // NOTE: We can not use a GList to store the actions to fire because they
    // are already stored in a list and the ListNode's would conflict.  So,
    // we use an Array instead.
    //

    GArrayF<Action *>   aracFire;

    Enter();

    Thread * pCurThread = GetThread();
    BOOL fFinishedPeriod, fFire;

    //
    // Go through and pre-process all future actions.  If a future actions 
    // time has come up, move it to the present actions list.
    //

    Action * pactCur = m_lstacFuture.GetHead();
    while (pactCur != NULL) {
        Action * pactNext = pactCur->GetNext();
        if (pactCur->GetThread() == pCurThread) {
            AssertMsg(!pactCur->IsPresent(), "Ensure action not yet present");
            pactCur->Process(dwCurTime, &fFinishedPeriod, &fFire);
            AssertMsg(! fFire, "Should not fire future Actions");
            if (fFinishedPeriod) {
                //
                // Action has reached the present
                //

                m_lstacFuture.Unlink(pactCur);
                pactCur->SetPresent(TRUE);
                pactCur->ResetPresent(dwCurTime);

                pactCur->SetParent(&m_lstacPresent);
                m_lstacPresent.Add(pactCur);
            }
        }
        pactCur = pactNext;
    }


    //
    // Go through and process all present actions
    //

    pactCur = m_lstacPresent.GetHead();
    while (pactCur != NULL) {
        Action * pactNext = pactCur->GetNext();
        if (pactCur->GetThread() == pCurThread) {
            pactCur->Process(dwCurTime, &fFinishedPeriod, &fFire);
            if (fFire) {
                //
                // The Action should be fired, so lock it and add it to the
                // delayed set of Actions to fire.  It is important to lock
                // it if the Action is finished so that it doesn't get 
                // destroyed.
                //

                pactCur->Lock();
                if (aracFire.Add(pactCur) < 0) {
                    // TODO: Unable to add the Action.  This is pretty bad.
                    // Need to figure out how to handle this situation,
                    // especially if fFinishedPeriod or the app may leak resources.
                }
            }

            if (fFinishedPeriod) {
                pactCur->SetParent(NULL);
                m_lstacPresent.Unlink(pactCur);

                pactCur->EndPeriod();

                //
                // The action has finished this round.  If it is not periodic, it
                // will be destroyed during its callback.  If it is periodic, 
                // need to re-add it to the correct (present or future) list.
                //

                if (pactCur->IsComplete()) {
                    pactCur->MarkDelete(TRUE);
                    VerifyMsg(pactCur->xwUnlock(), "Should still have HANDLE lock");
                } else {
                    GList<Action> * plstParent = NULL;
                    float flWait = pactCur->GetStartDelay();
                    BOOL fPresent = IsPresentTime(flWait);
                    if (fPresent) {
                        pactCur->ResetPresent(dwCurTime);
                        plstParent = &m_lstacPresent;
                    } else {
                        pactCur->ResetFuture(dwCurTime, FALSE);
                        plstParent = &m_lstacFuture;
                    }

                    pactCur->SetPresent(fPresent);
                    pactCur->SetParent(plstParent);
                    plstParent->Add(pactCur);
                }
            }
        }

        pactCur = pactNext;
    }


    //
    // Now that everything has been determined, determine how long until Actions
    // need to be processed again.
    //
    // NOTE: To keep Actions from overwhelming CPU and giving other tasks some
    // time to accumulate and process, we normally limit the granularity to 
    // 10 ms.  We actually should allow Actions to specify there own granularity 
    // and provide a default, probably of 10 ms for continuous Actions.
    //
    // NOTE: Is is very important that this number is not too high, because it
    // will severly limit the framerate to 1000 / delay.  After doing 
    // significant profiling work, 10 ms was found to be ideal which gives an
    // upper bound of about 100 fps.
    //

    DWORD dwTimeOut = INFINITE;
    if (m_lstacPresent.IsEmpty()) {
        //
        // There are no present Actions, so check over the future Actions to 
        // determine when the next one executes.
        //

        Action * pactCur = m_lstacFuture.GetHead();
        while (pactCur != NULL) {
            Action * pactNext = pactCur->GetNext();
            if (pactCur->GetThread() == pCurThread) {
                AssertMsg(!pactCur->IsPresent(), "Ensure action not yet present");

                DWORD dwNewTimeOut = pactCur->GetIdleTimeOut(dwCurTime);
                AssertMsg(dwTimeOut > 0, "If Action has no TimeOut, should already be present.");
                if (dwNewTimeOut < dwTimeOut) {
                    dwTimeOut = dwNewTimeOut;
                }
            }

            pactCur = pactNext;
        }
    } else {
        //
        // There are present Actions, so query their PauseTimeOut().
        //

        Action * pactCur = m_lstacPresent.GetHead();
        while (pactCur != NULL) {
            Action * pactNext = pactCur->GetNext();

            DWORD dwNewTimeout = pactCur->GetPauseTimeOut();
            if (dwNewTimeout < dwTimeOut) {
                dwTimeOut = dwNewTimeout;
                if (dwTimeOut == 0) {
                    break;
                }
            }

            pactCur = pactNext;
        }
    }


    Leave();

    xwFireNL(aracFire, TRUE);


    //
    // After actually execution the Actions, compute how much time to wait until
    // processing the next batch.  We want to subtract the time we spent 
    // processing the Actions, since if we setup timers on 50 ms intervals and
    // the processing takes 20 ms, we should only wait 30 ms.
    //
    // NOTE we need to do this AFTER calling xwFireNL(), since this fires the
    // actual notifications and does the processing.  If we compute before this,
    // the majority of the work will not be included.
    //

    DWORD dwOldCurTime  = dwCurTime;

    dwCurTime           = ::GetTickCount();  // Update the current time
    DWORD dwProcessTime = ComputeTickDelta(dwCurTime, dwOldCurTime);
    
    if (dwProcessTime < dwTimeOut) {
        dwTimeOut -= dwProcessTime;
    } else {
        dwTimeOut = 0;
    }

    return dwTimeOut;
}


//---------------------------------------------------------------------------
#if DBG
void
DEBUG_CheckValid(const GArrayF<Action *> & aracFire, int idxStart)
{
    int cActions = aracFire.GetSize();
    for (int i = idxStart; i < cActions; i++) {
        DWORD * pdw = (DWORD *) aracFire[i];
        AssertMsg(*pdw != 0xfeeefeee, "Should still be valid");
    }
}
#endif // DBG


/***************************************************************************\
*
* Scheduler::xwFireNL
*
* xwFireNL() fires notifications for the specified Actions, updating Action
* state as it is fired.
*
\***************************************************************************/

void        
Scheduler::xwFireNL(
    IN  GArrayF<Action *> & aracFire,   // Actions to notify
    IN  BOOL fFire                      // "Fire" the notification (or just update)
    ) const
{
#if DBG
    //
    // Check that each Action is only in the list once.
    //

    {
        int cActions = aracFire.GetSize();
        for (int i = 0; i < cActions; i++) {
            aracFire[i]->DEBUG_MarkInFire(TRUE);

            for (int j = i + 1; j < cActions; j++) {
                AssertMsg(aracFire[i] != aracFire[j], "Should only be in once");
            }

        }

        DEBUG_CheckValid(aracFire, 0);
    }

#endif // DBG

    //
    // Outside of the lock, so can fire the callbacks.
    //
    // NOTE: We may actually be locked by a different thread, but that's okay.
    //

    int cActions = aracFire.GetSize();
    for (int idx = 0; idx < cActions; idx++) {
        Action * pact = aracFire[idx];

#if DBG
        DEBUG_CheckValid(aracFire, idx);
#endif // DBG

        if (fFire) {
            pact->xwFireNL();
        }

#if DBG
        aracFire[idx]->DEBUG_MarkInFire(FALSE);
#endif // DBG

        pact->xwUnlock();

#if DBG
        aracFire[idx] = NULL;
#endif // DBG
    }

    //
    // NOTE: Since we pass in a Action * array, we don't need to worry about
    // the destructors getting called and the Actions being incorrectly 
    // destroyed.
    //
}


/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
HACTION
GdCreateAction(const GMA_ACTION * pma)
{
    return (HACTION) GetHandle(GetMotionSC()->GetScheduler()->AddAction(pma));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Public_h__INCLUDED)
#define MOTION__Public_h__INCLUDED

#include "Transitions.h"
#include "Scheduler.h"
#include "Colors.h"
#include "Context.h"

#endif // MOTION__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Motion.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\transitions.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Transitions.h"
#include "DXFormTrx.h"
#include "DXForm3DRMTrx.h"

//**************************************************************************************************
//
// class Transition
//
//**************************************************************************************************

//------------------------------------------------------------------------------
Transition::Transition()
{
    m_fPlay     = FALSE;
    m_fBackward = FALSE;
}


//------------------------------------------------------------------------------
Transition::~Transition()
{

}


//**************************************************************************************************
//
// Public API Functions
//
//**************************************************************************************************

//------------------------------------------------------------------------------
Transition *
GdCreateTransition(const GTX_TRXDESC * ptx)
{
    // Check parameters
    if (ptx == NULL) {
        return FALSE;
    }

    //
    // Create a new transition
    //
    switch (ptx->tt)
    {
    case GTX_TYPE_DXFORM2D: 
        return DXFormTrx::Build((const GTX_DXTX2D_TRXDESC *) ptx);

    case GTX_TYPE_DXFORM3DRM:
        return DXForm3DRMTrx::Build((const GTX_DXTX3DRM_TRXDESC *) ptx);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
#define AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_

#pragma once

#include "CommonStdAfx.h"

#endif // !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\scheduler.h ===
/***************************************************************************\
*
* File: Scheduler.h
*
* Description:
* Scheduler.h maintains a collection of timers that are created and used
* by the application for notifications.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Scheduler_h__INCLUDED)
#define MOTION__Scheduler_h__INCLUDED
#pragma once

// Forward declarations
class Action;

/***************************************************************************\
*
* class Scheduler
*
* Scheduler maintains lists of actions that are both occuring now and will
* occur in the future.
*
\***************************************************************************/

class Scheduler
{
// Construction
public:
            Scheduler();
            ~Scheduler();
            void        xwPreDestroy();

// Operations
public:
            Action *    AddAction(const GMA_ACTION * pma);
            DWORD       xwProcessActionsNL();

// Implementation
protected:
            void        xwRemoveAllActions();

    inline  void        Enter();
    inline  void        Leave();

            void        xwFireNL(GArrayF<Action *> & aracFire, BOOL fFire) const;

// Data
protected:
            CritLock        m_lock;
            GList<Action>   m_lstacPresent;
            GList<Action>   m_lstacFuture;

#if DBG
            long        m_DEBUG_fLocked;
#endif // DBG

            BOOL        m_fShutdown:1;  // Have started shutdown
};

HACTION     GdCreateAction(const GMA_ACTION * pma);

#include "Scheduler.inl"

#endif // MOTION__Scheduler_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\transitions.h ===
#if !defined(MOTION__Transitions_h__INCLUDED)
#define MOTION__Transitions_h__INCLUDED

class DxSurface;
class TrxBuffer;

/***************************************************************************\
*
* class Transition
*
* Transition defines a base class that is used for transitions.
*
\***************************************************************************/

class Transition : public BaseObject
{
// Construction
protected:
            Transition();
    virtual ~Transition();

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htTransition; }
    virtual UINT        GetHandleMask() const { return 0; }

// Transition Interface
public:
    virtual BOOL        Play(const GTX_PLAY * pgx) PURE;
    virtual BOOL        GetInterface(IUnknown ** ppUnk) PURE;

    virtual BOOL        Begin(const GTX_PLAY * pgx) PURE;
    virtual BOOL        Print(float fProgress) PURE;
    virtual BOOL        End(const GTX_PLAY * pgx) PURE;

// Data
protected:
            BOOL        m_fPlay:1;      // Transition is playing
            BOOL        m_fBackward:1;  // Playing backward
};


Transition* GdCreateTransition(const GTX_TRXDESC * ptx);

#include "Transitions.inl"

#endif // MOTION__Transitions_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\motion\transitions.inl ===
#if !defined(MOTION__Transition_inl__INCLUDED)
#define MOTION__Transition_inl__INCLUDED


//------------------------------------------------------------------------------
inline Transition * CastTransition(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htTransition)) {
        return (Transition *) pbase;
    }
    return NULL;
}


#endif // MOTION__Transition_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\classlibrary.h ===
/***************************************************************************\
*
* File: ClassLibrary.h
*
* Description:
* ClassLibrary.h defines the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__ClassLibrary_h__INCLUDED)
#define MSG__ClassLibrary_h__INCLUDED
#pragma once

class MsgClass;

class ClassLibrary
{
// Construction
public:
            ClassLibrary();
            ~ClassLibrary();

// Operations
public:
            HRESULT     RegisterGutsNL(DUser::MessageClassGuts * pmcInfo, MsgClass ** ppmc);
            HRESULT     RegisterStubNL(DUser::MessageClassStub * pmcInfo, MsgClass ** ppmc);
            HRESULT     RegisterSuperNL(DUser::MessageClassSuper * pmcInfo, MsgClass ** ppmc);
            void        MarkInternal(HCLASS hcl);

            const MsgClass *  
                        FindClass(ATOM atomName) const;

// Implementation
protected:
            HRESULT     BuildClass(LPCWSTR pszClassName, MsgClass ** ppmc);

// Data
protected:
            CritLock    m_lock;
            GList<MsgClass> 
                        m_lstClasses;
};

ClassLibrary *
            GetClassLibrary();

#include "ClassLibrary.inl"

#endif // MSG__ClassLibrary_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\classlibrary.inl ===
/***************************************************************************\
*
* File: ClassLibrary.inl
*
* Description:
* ClassLibrary.inl implements the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__ClassLibrary_inl__INCLUDED)
#define MSG__ClassLibrary_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class ClassLibrary
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
ClassLibrary::ClassLibrary()
{

}


#endif // MSG__ClassLibrary_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\classlibrary.cpp ===
/***************************************************************************\
*
* File: ClassLibrary.cpp
*
* Description:
* ClassLibrary.h implements the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "ClassLibrary.h"

#include "MsgClass.h"
#include "MsgObject.h"


/***************************************************************************\
*****************************************************************************
*
* class ClassLibrary
* 
*****************************************************************************
\***************************************************************************/

ClassLibrary g_cl;

ClassLibrary *
GetClassLibrary()
{
    return &g_cl;
}


/***************************************************************************\
*
* ClassLibrary::~ClassLibrary
*
* ~ClassLibrary() cleans up resources used by a ClassLibrary.
* 
\***************************************************************************/

ClassLibrary::~ClassLibrary()
{
    //
    // Need to directly destroy the MsgClass's since they are allocated in
    // process memory.
    //

    while (!m_lstClasses.IsEmpty()) {
        MsgClass * pmc = m_lstClasses.UnlinkHead();
        ProcessDelete(MsgClass, pmc);
    }
}


/***************************************************************************\
*
* ClassLibrary::RegisterGutsNL
*
* RegisterGutsNL() registers the implementation of a MsgClass so that it can
* be instantiated.  The MsgClass may already exist if it was previously
* registered, but can not be instantiated until the implementation has also
* been registered.  The implementation can only be registered once.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterGutsNL(
    IN OUT DUser::MessageClassGuts * pmcInfo, // Guts information
    OUT MsgClass ** ppmc)                   // OPTIONAL Class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterGuts(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::RegisterStubNL
*
* RegisterStubNL() registers a Stub to use a MsgClass.  Many Stubs may
* register the same MsgClass, but they can not instantiate a new instance
* until the implementation has also been registered.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterStubNL(
    IN OUT DUser::MessageClassStub * pmcInfo, // Stub information
    OUT MsgClass ** ppmc)                   // OPTIONAL Class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterStub(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::RegisterSuperNL
*
* RegisterSuperNL() registers a Super to use a MsgClass.  Many Supers may
* register the same MsgClass, but they can not instantiate a new instance
* until the implementation has also been registered.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterSuperNL(
    IN OUT DUser::MessageClassSuper * pmcInfo, // Super information
    OUT MsgClass ** ppmc)                   // OPTIONAL class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterSuper(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::MarkInternal
*
* MarkInternal() marks a class as being internally implemented inside DUser.
* 
\***************************************************************************/

void
ClassLibrary::MarkInternal(
    IN  HCLASS hcl)                     // Class to mark internal
{
    MsgClass * pmc = ValidateMsgClass(hcl);
    AssertMsg(pmc != NULL, "Must give a valid class");
    pmc->MarkInternal();

#if DBG
    if (pmc->GetSuper() != NULL) {
        AssertMsg(pmc->GetSuper()->IsInternal(), "Super class must also be internal");
    }
#endif
}


/***************************************************************************\
*
* ClassLibrary::FindClass
*
* FindClass() finds a class by name already in the library.  If the class is
* not found, NULL is returned.
* 
\***************************************************************************/

const MsgClass *  
ClassLibrary::FindClass(
    IN  ATOM atomName                   // Name of class
    ) const
{
    if (atomName == 0) {
        return NULL;
    }


    //
    // First, see if the class already exists.
    //

    MsgClass * pmcCur = m_lstClasses.GetHead();
    while (pmcCur != NULL) {
        if (pmcCur->GetName() == atomName) {
            return pmcCur;
        }

        pmcCur = pmcCur->GetNext();
    }

    return NULL;
}


/***************************************************************************\
*
* ClassLibrary::BuildClass
*
* BuildClass() adds a MsgClass into the library.  If the MsgClass already
* is in the library, the existing implementation is returned.
* 
\***************************************************************************/

HRESULT     
ClassLibrary::BuildClass(
    IN  LPCWSTR pszClassName,           // Class information
    OUT MsgClass ** ppmc)               // MsgClass
{
    //
    // Search for the class
    //

    MsgClass * pmcNew = const_cast<MsgClass *> (FindClass(FindAtomW(pszClassName)));
    if (pmcNew != NULL) {
        *ppmc = pmcNew;
        return S_OK;
    }


    //
    // Build a new class
    //

    HRESULT hr = MsgClass::Build(pszClassName, &pmcNew);
    if (FAILED(hr)) {
        return hr;
    }

    m_lstClasses.Add(pmcNew);
    *ppmc = pmcNew;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msg.h ===
/***************************************************************************\
*
* File: Msg.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__Msg_h__INCLUDED)
#define MSG__Msg_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Msg Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // MSG__Msg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgclass.h ===
/***************************************************************************\
*
* File: MsgClass.h
*
* Description:
* MsgClass.h defines the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgClass_h__INCLUDED)
#define MSG__MsgClass_h__INCLUDED
#pragma once

class MsgTable;
class MsgObject;

class MsgClass : 
    public BaseObject,
    public ListNodeT<MsgClass>
{
// Construction
public:
    inline  MsgClass();
            ~MsgClass();
    static  HRESULT     Build(LPCWSTR pszClassName, MsgClass ** ppmcNew);
    virtual BOOL        xwDeleteHandle();

// BaseObject
public:
    virtual HandleType  GetHandleType() const { return htMsgClass; }
    virtual UINT        GetHandleMask() const { return 0; }
    inline  HCLASS      GetHandle() const;

// Operations
public:
    inline  ATOM        GetName() const;
    inline  const MsgTable *  
                        GetMsgTable() const;
    inline  const MsgClass *
                        GetSuper() const;
    inline  BOOL        IsGutsRegistered() const;
    inline  BOOL        IsInternal() const;
    inline  void        MarkInternal();

            HRESULT     RegisterGuts(DUser::MessageClassGuts * pmcInfo);
            HRESULT     RegisterStub(DUser::MessageClassStub * pmcInfo);
            HRESULT     RegisterSuper(DUser::MessageClassSuper * pmcInfo);

            HRESULT     xwBuildObject(MsgObject ** ppmoNew, DUser::Gadget::ConstructInfo * pciData) const;
            void        xwTearDownObject(MsgObject * pmoNew) const;

// Implementation
protected:
    static  HRESULT CALLBACK 
                        xwConstructCB(DUser::Gadget::ConstructCommand cmd, HCLASS hclCur, DUser::Gadget * pgad, void * pvData);
            HRESULT     xwBuildUpObject(MsgObject * pmoNew, DUser::Gadget::ConstructInfo * pciData) const;
            HRESULT     FillStub(DUser::MessageClassStub * pmcInfo) const;
            void        FillSuper(DUser::MessageClassSuper * pmcInfo) const;

// Data
protected:
            ATOM        m_atomName;
            LPCWSTR     m_pszName;
            int         m_nVersion;
            const MsgClass *  
                        m_pmcSuper;
            MsgTable *  m_pmt;
            DUser::PromoteProc 
                        m_pfnPromote;
            DUser::DemoteProc  
                        m_pfnDemote;

            GArrayS<DUser::MessageClassStub *, ProcessHeap>
                        m_arStubs;
            GArrayS<DUser::MessageClassSuper *, ProcessHeap>
                        m_arSupers;

            BOOL        m_fInternal:1;
};

#include "MsgClass.inl"

#endif // MSG__MsgClass_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgclass.cpp ===
/***************************************************************************\
*
* File: MsgClass.h
*
* Description:
* MsgClass.h implements the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgClass.h"

#include "MsgTable.h"
#include "MsgObject.h"
#include "ClassLibrary.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgClass
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgClass::~MsgClass
* 
* ~MsgClass() cleans up resources associated with a specific message class.
*
\***************************************************************************/

MsgClass::~MsgClass()
{
    //
    // Clean up internal resources
    //

    if (m_pmt != NULL) {
        m_pmt->Destroy();
    }

    DeleteAtom(m_atomName);
}


/***************************************************************************\
*
* MsgClass::Build
* 
* Build() creates a placeholder MsgClass so that we can register Stubs to be
* setup after the implementation is registered.  
*
* NOTE: We can NOT instantiate MsgObject's until the implementation has also
* been registered.
*
\***************************************************************************/

HRESULT
MsgClass::Build(
    IN  LPCWSTR pszClassName,           // Class information
    OUT MsgClass ** ppmcNew)            // New MsgClass
{
    //
    // Allocate the new MsgClass
    //

    ATOM atomName = AddAtomW(pszClassName);
    if (atomName == 0) {
        return E_OUTOFMEMORY;
    }

    MsgClass * pmcNew = ProcessNew(MsgClass);
    if (pmcNew == NULL) {
        return E_OUTOFMEMORY;
    }
    pmcNew->m_pszName   = pszClassName;
    pmcNew->m_atomName  = atomName;

    *ppmcNew = pmcNew;
    return S_OK;
}


/***************************************************************************\
*
* MsgClass::xwDeleteHandle
* 
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.  
*
\***************************************************************************/

BOOL
MsgClass::xwDeleteHandle()
{
    //
    // MsgClass's can not be deleted externally.  Once registered, they exist
    // for the lifetime of the process.  The reason is that we don't keep track
    // of how many already created objects may be using the MsgTable owned by
    // the MsgClass.  We also would need to ensure that no classes derive from
    // this class.
    //

    return TRUE;
}


/***************************************************************************\
*
* MsgClass::RegisterGuts
* 
* RegisterGuts() is called by the implementation class to provide the "guts"
* of a MsgClass.  This fills in the outstanding information required to be
* able to actually instantiate the MsgClass.
*
\***************************************************************************/

HRESULT
MsgClass::RegisterGuts(
    IN OUT  DUser::MessageClassGuts * pmcInfo) 
                                        // Class information
{
    AssertWritePtr(pmcInfo);

    if (IsGutsRegistered()) {
        PromptInvalid("The implementation has already been registered");
        return DU_E_CLASSALREADYREGISTERED;
    }


    //
    // Find the super
    //

    const MsgClass * pmcSuper = NULL;
    if ((pmcInfo->pszSuperName != NULL) && (pmcInfo->pszSuperName[0] != '\0')) {
        pmcSuper = GetClassLibrary()->FindClass(FindAtomW(pmcInfo->pszSuperName));
        if (pmcSuper == NULL) {
            PromptInvalid("The specified super class was not found");
            return DU_E_NOTFOUND;
        }

        // TODO: Remove this requirement that the Super's guts must be 
        // registered before this class's guts can be registered.
        if (!pmcSuper->IsGutsRegistered()) {
            PromptInvalid("The super class's implementation to be registered first");
            return DU_E_CLASSNOTIMPLEMENTED;
        }
    }


    m_pmcSuper      = pmcSuper;
    m_nVersion      = pmcInfo->nClassVersion;
    m_pfnPromote    = pmcInfo->pfnPromote;
    m_pfnDemote     = pmcInfo->pfnDemote;


    //
    // Build the MsgTable for the new MsgClass
    //

    MsgTable * pmtNew;
    HRESULT hr = MsgTable::Build(pmcInfo, this, &pmtNew);
    if (FAILED(hr)) {
        return hr;
    }

    m_pmt = pmtNew;


    //
    // Return out the new MsgClass and the Super.  These are used by the
    // caller to create instances of the object.
    //

    pmcInfo->hclNew     = GetHandle();
    pmcInfo->hclSuper   = pmcSuper != NULL ? pmcSuper->GetHandle() : NULL;


    //
    // Now that the Guts are registered, we can backfill all of the Stubs
    // and Supers.  After this, we no longer need to store them.
    //

    int idx;
    int cStubs = m_arStubs.GetSize();
    for (idx = 0; idx < cStubs; idx++) {
        FillStub(m_arStubs[idx]);
    }
    m_arStubs.RemoveAll();

    int cSupers = m_arSupers.GetSize();
    for (idx = 0; idx < cSupers; idx++) {
        FillSuper(m_arSupers[idx]);
    }
    m_arSupers.RemoveAll();

    return S_OK;
}


/***************************************************************************\
*
* MsgClass::RegisterStub
*
* RegisterStub() starts the lookup process for a Stub.  If the class is 
* already setup, we can fill in immediately.  If the class isn't already 
* setup, we need to wait until it is setup and then we call post-fill-in.
* 
\***************************************************************************/

HRESULT
MsgClass::RegisterStub(
    IN OUT DUser::MessageClassStub * pmcInfo) // Stub information to be filled in
{
    //
    // NOTE: ONLY fill in the Stub if the caller is requesting the messages to
    // be filled in.  If cMsgs == 0, they are probably just preregistering the
    // class (for a Super) and have allocated pmcInfo on the stack.  In this
    // case, it is very important not to backfill it since we will trash the
    // memory.
    //

    if (pmcInfo->cMsgs > 0) {
        if (IsGutsRegistered()) {
            return FillStub(pmcInfo);
        } else {
            return m_arStubs.Add(pmcInfo) >= 0 ? S_OK : E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* MsgClass::RegisterSuper
*
* RegisterSuper() starts the lookup process for a Super.  If the class is 
* already setup, we can fill in immediately.  If the class isn't already 
* setup, we need to wait until it is setup and then we call post-fill-in.
* 
\***************************************************************************/

HRESULT
MsgClass::RegisterSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo) // Stub information to be filled in
{
    if (IsGutsRegistered()) {
        FillSuper(pmcInfo);
        return S_OK;
    } else {
        return m_arSupers.Add(pmcInfo) >= 0 ? S_OK : E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* MsgClass::xwConstructCB
* 
* xwConstructCB() is called back by a pfnPromoteClass function to 
* initialize a super class's portion of a MsgObject.  This allows the 
* specific pfnPromoteClass to decide what implementation classes to actually
* implement and which to delegate.  
* 
* The caller passes in the super-class to actually construct.
*
\***************************************************************************/

HRESULT CALLBACK 
MsgClass::xwConstructCB(
    IN  DUser::Gadget::ConstructCommand cmd, // Construction code
    IN  HCLASS hclCur,                  // Class being initialized
    IN  DUser::Gadget * pgad,           // Object being initialized
    IN  void * pvData)                  // Construction information
{
    //
    // Validate parameters.
    // NOTE: We NEED to check if hclSuper == NULL when passed in since this is
    //       LEGAL (if we don't need a super-class generated).  
    //       ValidateMsgClass() will set pmcSuper == NULL if there is a 
    //       validation error.
    //

    if (hclCur == NULL) {
        return S_OK;
    }

    const MsgClass * pmcCur = ValidateMsgClass(hclCur);
    if (pmcCur == NULL) {
        PromptInvalid("Given invalid HCLASS during xwConstructSuperCB()");
        return E_INVALIDARG;
    }

    MsgObject * pmoNew = MsgObject::CastMsgObject(pgad);
    if (pmoNew == NULL) {
        return E_INVALIDARG;
    }


    HRESULT hr;
    switch (cmd)
    {
    case DUser::Gadget::ccSuper:
        //
        // pmcCur specifies the super-class that is being asked to build its 
        // object.
        //

        hr = pmcCur->xwBuildUpObject(pmoNew, reinterpret_cast<DUser::Gadget::ConstructInfo *>(pvData));
        break;

    case DUser::Gadget::ccSetThis:
        //
        // pmcCur specifies the class to start filling the this pointers.
        //

        {
            int idxStartDepth   = pmoNew->GetBuildDepth();
            int idxEndDepth     = pmcCur->m_pmt->GetDepth();
            pmoNew->FillThis(idxStartDepth, idxEndDepth, pvData, pmcCur->m_pmt);
            hr = S_OK;
        }
        break;

    default:
        PromptInvalid("Unknown dwCode to ConstructProc()");
        hr = E_INVALIDARG;
    }

    return hr;
}


/***************************************************************************\
*
* MsgClass::xwBuildUpObject
*
* xwBuildUpObject() builds up an newly constructed MsgObject by calling
* the most-derived Promotion function to initialize the MsgObject.  This
* Promotion function will usually callback to xwConstructCB() to 
* initialize base classes that are not provided in that implementation.
* 
* As each Promotion function is called, xwBuildUpObject() will be called
* from xwConstructCB() to construct the super-classes.  As each Super
* finishes construction, the "this array" on the MsgObject is updated.
* 
\***************************************************************************/

HRESULT
MsgClass::xwBuildUpObject(
    IN  MsgObject * pmoNew,             // Object being constructed / promoted
    IN  DUser::Gadget::ConstructInfo * pciData // Construction information
    ) const
{
    //
    // For non-internally implemented classes, we need to callback to get the
    // "this" pointer to use.  The callback is responsible for calling 
    // ConstructProc(CONSTRUCT_SETTHIS) to Promote the object and set the 
    // "this" pointers.  For internally implemented classes, we use the 
    // MsgObject to directly Promote the object.
    // 
    //

    HRESULT hr;
    if (IsInternal()) {
        hr = S_OK;
    } else {
        //
        // Callback to this Super to give a chance to construct.  This is done
        // from the most derived class and relies on callbacks to initialize 
        // super-classes.
        //

        DUser::Gadget * pgad   
                    = pmoNew->GetGadget();
        HCLASS hcl  = GetHandle();
        hr          = (m_pfnPromote)(xwConstructCB, hcl, pgad, pciData);
    }

#if DBG
    if (SUCCEEDED(hr)) {
        //
        // Check that the Promotion function properly set the this pointer.
        //

        int idxObjectDepth  = pmoNew->GetDepth();
        int idxSuperDepth   = m_pmt->GetDepth();

        if (idxObjectDepth <= idxSuperDepth) {
            PromptInvalid("The PromoteProc() function did not call ConstructProc(CONSTRUCT_SETTHIS).");
        }

        if (pmoNew->GetThis(idxSuperDepth) == ULongToPtr(0xA0E20000 + idxSuperDepth)) {
            PromptInvalid("The PromoteProc() function did not call ConstructProc(CONSTRUCT_SETTHIS).");
        }
    }
#endif // DBG

    return hr;
}


/***************************************************************************\
*
* MsgClass::xwBuildObject
*
* xwBuildObject() builds and initializes a new MsgObject.
* 
\***************************************************************************/

HRESULT
MsgClass::xwBuildObject(
    OUT MsgObject ** ppmoNew,           // New MsgObject
    IN  DUser::Gadget::ConstructInfo * pciData // Construction information
    ) const
{
    //
    // Allocate a new object:
    // 1. Walk up the inheritance chain to determine the DUser object to build
    //    that will provide MsgObject functionality.
    // 2. While walking up, Verify that the guts of all classes have been 
    //    properly registered.
    // 3. Kick off the build-up process.
    //

    HRESULT hr;
    MsgObject * pmoNew              = NULL;
    const MsgClass * pmcInternal    = this;
    while (pmcInternal != NULL) {
        if (!pmcInternal->IsGutsRegistered()) {
            PromptInvalid("The implementation of the specified class has not been provided");
            return DU_E_CLASSNOTIMPLEMENTED;
        }

        if (pmcInternal->IsInternal()) {
            AssertMsg(pmoNew == NULL, "Must be NULL for internal Promote() functions");
            hr = (pmcInternal->m_pfnPromote)(NULL, pmcInternal->GetHandle(), (DUser::Gadget *) &pmoNew, pciData);
            if (FAILED(hr)) {
                return E_OUTOFMEMORY;
            }
            AssertMsg(pmoNew != NULL, "Internal objects must fill in the MsgObject");
            AssertMsg(pmoNew->GetHandleType() != htNone, "Must have a valid handle type");
            break;
        }

        pmcInternal = pmcInternal->GetSuper();
    }

    if (pmoNew == NULL) {
        AssertMsg(pmcInternal == NULL, "Internal classes must have already allocated the MsgObject");

        pmoNew = ClientNew(MsgObject);
        if (pmoNew == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    hr = pmoNew->PreAllocThis(m_pmt->GetDepth() + 1);
    if (FAILED(hr)) {
        goto Error;
    }
    if (pmcInternal != NULL) {
        int cObjectDepth = pmcInternal->m_pmt->GetDepth();
        pmoNew->FillThis(0, cObjectDepth, pmoNew, pmcInternal->m_pmt);
    }

    hr = xwBuildUpObject(pmoNew, pciData);
    if (FAILED(hr)) {
        goto Error;
    }

    *ppmoNew = pmoNew;
    return S_OK;

Error:
    if (pmoNew != NULL) {
        xwTearDownObject(pmoNew);
    }
    return hr;
}


/***************************************************************************\
*
* MsgClass::xwTearDownObject
*
* xwTearDownObject() tears down a MsgObject as part of the destruction 
* process.  This gives each of the implentation classes an opportunity to
* cleanup resources, similar to having a destructor in C++.
* 
\***************************************************************************/

void
MsgClass::xwTearDownObject(
    IN  MsgObject * pmoNew              // Object being destroyed.
    ) const
{
    DUser::Gadget * pgad 
                = pmoNew->GetGadget();
    int idxThis = m_pmt->GetDepth();

    const MsgClass * pmcCur = this;
    const MsgClass * pmcNext, * pmcTest;
    while (pmcCur != NULL) {
        HCLASS hcl = pmcCur->GetHandle();
        void * pvThis = pmoNew->GetThis(idxThis);
        hcl = (pmcCur->m_pfnDemote)(hcl, pgad, pvThis);


        //
        // Determine how many class to remove by how far up the chain this 
        // MsgClass is.
        // - TODO: Need to check that returned class is actually in the chain.
        //

        pmcNext = ValidateMsgClass(hcl);
        if ((hcl != NULL) && (pmcNext == NULL)) {
            PromptInvalid("Incorrect HCLASS returned from Demote function.  Object will not be properly destroyed.");
        }

        pmcTest = pmcCur;
        int cDepth = 0;
        while ((pmcTest != NULL) && (pmcTest != pmcNext)) {
            cDepth++;
            pmcTest = pmcTest->m_pmcSuper;
        }

        pmoNew->Demote(cDepth);
        idxThis -= cDepth;

        pmcCur = pmcNext;
    }
}


/***************************************************************************\
*
* MsgClass::FillStub
*
* FillStub() provides the calling stub with information about a previously
* registered MsgClass.
* 
\***************************************************************************/

HRESULT
MsgClass::FillStub(
    IN OUT DUser::MessageClassStub * pmcInfo // Stub information to be filled in
    ) const
{
    HRESULT hr = S_OK;

    ATOM atomMsg;
    int idxSlot;
    int cbBeginOffset = sizeof(MsgTable);

    DUser::MessageInfoStub * rgMsgInfo = pmcInfo->rgMsgInfo;
    int cMsgs = pmcInfo->cMsgs;
    for (int idx = 0; idx < cMsgs; idx++) {
        if (((atomMsg = FindAtomW(rgMsgInfo[idx].pszMsgName)) == 0) || 
                ((idxSlot = m_pmt->FindIndex(atomMsg)) < 0)) {

            //
            // Could not find the function, so store a -1 to signal that this
            // slot with the error.
            //

            PromptInvalid("Unable to find message during lookup");
            hr = DU_E_MESSAGENOTFOUND;
            rgMsgInfo[idx].cbSlotOffset = -1;
        } else {
            //
            // Successfully found the function.  We need to store the offset
            // to the slot so that it can be directly accessed without any math
            // or special knowledge of our internals.
            //

            int cbSlotOffset = idxSlot * sizeof(MsgSlot) + cbBeginOffset;
            rgMsgInfo[idx].cbSlotOffset = cbSlotOffset;
        }
    }

    return hr;
}


/***************************************************************************\
*
* MsgClass::FillSuper
*
* FillStub() provides the calling super with information about a previously
* registered MsgClass.
* 
\***************************************************************************/

void
MsgClass::FillSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo // Super information to be filled in
    ) const
{
    pmcInfo->pmt = m_pmt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgtable.h ===
/***************************************************************************\
*
* File: MsgTable.h
*
* Description:
* MsgTable.h defines the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgTable_h__INCLUDED)
#define MSG__MsgTable_h__INCLUDED
#pragma once

//
// NOTE: MsgSlot NEEDS to have data packed on 8-byte boundaries since it will
// be directly accessed on Win64.
//

struct MsgSlot
{
    void *      pfn;            // Implementation function
    int         cbThisOffset;   // "this" offset in arpThis
    ATOM        atomNameID;     // Unique ID for message
};

class MsgClass;

class MsgTable
{
// Construction
public:
    inline  MsgTable();
    inline  ~MsgTable();
    static  HRESULT     Build(const DUser::MessageClassGuts * pmc, const MsgClass * pmcPeer, MsgTable ** ppmt);
    inline  void        Destroy();

// Operations
public:
    inline  int         GetCount() const;
    inline  int         GetDepth() const;
    inline  const MsgClass *
                        GetClass() const;
    inline  const MsgSlot *
                        GetMsgSlot(int nMsg) const;
            const MsgSlot *
                        Find(ATOM atomNameID) const;
            int         FindIndex(ATOM atomNameID) const;

// Implementation
protected:
    inline  MsgSlot *   GetSlots();
    inline  const MsgSlot *
                        GetSlots() const;

// Data
protected:
            const MsgTable *  
                        m_pmtSuper;
            const MsgClass * 
                        m_pmcPeer;
            int         m_cMsgs;
};


#include "MsgTable.inl"

#endif // MSG__MsgTable_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgclass.inl ===
/***************************************************************************\
*
* File: MsgClass.inl
*
* Description:
* MsgClass.inl implements the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgClass_inl__INCLUDED)
#define MSG__MsgClass_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class MsgClass
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline MsgClass * 
CastMsgClass(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htMsgClass)) {
        return (MsgClass *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const MsgClass * 
CastMsgClass(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htMsgClass)) {
        return (const MsgClass *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline MsgClass * 
ValidateMsgClass(HCLASS hgad)
{
    return CastMsgClass(BaseObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline 
MsgClass::MsgClass()
{

}


//------------------------------------------------------------------------------
inline HCLASS
MsgClass::GetHandle() const
{
    return (HCLASS) BaseObject::GetHandle();
}


//------------------------------------------------------------------------------
inline ATOM
MsgClass::GetName() const
{
    return m_atomName;
}


//------------------------------------------------------------------------------
inline const MsgTable *
MsgClass::GetMsgTable() const
{
    return m_pmt;
}


//------------------------------------------------------------------------------
inline const MsgClass *
MsgClass::GetSuper() const
{
    return m_pmcSuper;
}


//------------------------------------------------------------------------------
inline BOOL
MsgClass::IsGutsRegistered() const
{
    return m_pmt != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
MsgClass::IsInternal() const
{
    return m_fInternal;
}


//------------------------------------------------------------------------------
inline void
MsgClass::MarkInternal()
{
    m_fInternal = TRUE;
}


#endif // MSG__MsgClass_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
#define AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_

#pragma once

#include "CommonStdAfx.h"

#endif // !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgobject.cpp ===
/***************************************************************************\
*
* File: MsgObject.cpp
*
* Description:
* MsgObject.cpp implements the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgObject.h"

#include "MsgTable.h"
#include "MsgClass.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgObject
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgObject::xwDestroy
*
* xwDestroy() is called when the object reaches the final xwUnlock(), giving
* the MsgObject a chance to hook into properly tear-down the external object.
*
\***************************************************************************/

void
MsgObject::xwDestroy()
{
    xwEndDestroy();

    BaseObject::xwDestroy();
}


/***************************************************************************\
*
* MsgObject::xwEndDestroy
*
* xwEndDestroy() ends the destruction process for a given MsgObject to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* Any class that derives from MsgObject and overrides xwDestroy() without
* calling MsgObject::xwDestroy() MUST call xwEndDestroy().  This allows 
* derived classes to use special pool allocators, but still properly 
* tear down the "attached" objects.  
*
\***************************************************************************/

void
MsgObject::xwEndDestroy()
{
    if (m_emo.m_pmt != NULL) {
        //
        // Need to "demote" the object all of the way down.
        //

        m_emo.m_pmt->GetClass()->xwTearDownObject(this);
        AssertMsg(m_emo.m_arpThis.GetSize() == 0, 
                "After TearDown, should not have any remaining 'this' pointers");

#if DBG
        // DEBUG: Stuff pMT with a bogus value to help identify destroyed object
        m_emo.m_pmt = (const MsgTable *) ULongToPtr(0xA0E2A0E2);
#endif
    }
}


/***************************************************************************\
*
* MsgObject::PromoteInternal
*
* PromoteInternal() provides an empty promotion function that can be used
* to build internal objects.  This promotion function WILL NOT actually 
* allocate the object and can only be used to prevent the creation of a
* base class that can not be directly created.
*
\***************************************************************************/

HRESULT CALLBACK
MsgObject::PromoteInternal(
    IN  DUser::ConstructProc pfnCS,     // Creation callback function
    IN  HCLASS hclCur,                  // Class to promote to
    IN  DUser::Gadget * pgad,           // Object being promoted
    IN  DUser::Gadget::ConstructInfo * pciData) // Construction parameters
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pciData);


    //
    // Not allowed to directly create this object.  Derived classes must provide
    // their own Promotion function.
    //

    return S_OK;
}


/***************************************************************************\
*
* MsgObject::DemoteInternal
*
* DemoteInternal() provides an empty demotion function that can be used
* to tear-down internal objects.  Since there is rarely anything to do for
* demotion of internal objects, this demotion function may be safely used
* for internal objects.
*
\***************************************************************************/

HCLASS CALLBACK
MsgObject::DemoteInternal(
    IN  HCLASS hclCur,                  // Class of Gadget being destroyed
    IN  DUser::Gadget * pgad,           // Gadget being destroyed
    IN  void * pvData)                  // Implementation data on object
{
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pvData);

    return NULL;
}


#if 1

/***************************************************************************\
*
* MsgObject::SetupInternal
*
* SetupInternal() sets up an internal object that is being created as a 
* handle (legacy object).  This function should not be called on objects 
* that are being created as "Gadget's".
*
* TODO: Try to remove this function
*
\***************************************************************************/

BOOL
MsgObject::SetupInternal(
    IN  HCLASS hcl)                     // Internal class being setup
{
    MsgClass * pmcThis = ValidateMsgClass(hcl);
    AssertMsg((pmcThis != NULL) && pmcThis->IsInternal(), "Must be a valid internal class");

    int cLevels = 0;
    const MsgClass * pmcCur = pmcThis;
    while (pmcCur != NULL) {
        cLevels++;
        pmcCur = pmcCur->GetSuper();
    }

    VerifyMsg(m_emo.m_arpThis.GetSize() == 0, "Must not already be initialized");
    if (!m_emo.m_arpThis.SetSize(cLevels)) {
        return FALSE;
    }

    for (int idx = 0; idx < cLevels; idx++) {
        m_emo.m_arpThis[idx] = this;
    }

    m_emo.m_pmt = pmcThis->GetMsgTable();
    AssertMsg(m_emo.m_pmt != NULL, "Must now have a valid MT");
    return TRUE;
}
#endif


/***************************************************************************\
*
* MsgObject::InstanceOf
*
* InstanceOf() checks if the MsgObject is an "instance of" a specified class
* by traversing the inheritance heirarchy.
*
\***************************************************************************/

BOOL
MsgObject::InstanceOf(
    IN  const MsgClass * pmcTest        // Class checking for instance
    ) const
{
    AssertMsg(pmcTest != NULL, "Must have a valid MsgClass");

    const MsgClass * pmcCur = m_emo.m_pmt->GetClass();
    while (pmcCur != NULL) {
        if (pmcCur == pmcTest) {
            return TRUE;
        }

        pmcCur = pmcCur->GetSuper();
    }

    return FALSE;
}


/***************************************************************************\
*
* MsgObject::GetGutsData
*
* GetGutsData() retreives the implementation-specific data for the specified
* class on the given object.  
*
* NOTE: This operation has been highly optimized for speed and will not 
* validate that the object is of the specified class type.  If the caller is
* uncertain, they must call InstanceOf() or CastClass() to properly 
* determine the object's type.
*
\***************************************************************************/

void *
MsgObject::GetGutsData(
    IN  const MsgClass * pmcData        // Class of guts data
    ) const
{
#if DBG
    if (!InstanceOf(pmcData)) {
        PromptInvalid("The Gadget is not the specified class");
    }
#endif

    int cDepth = pmcData->GetMsgTable()->GetDepth();
#if DBG
    if ((cDepth < 0) || (cDepth >= m_emo.m_arpThis.GetSize())) {
        PromptInvalid("The Gadget does not have data for the specified class");
    }
#endif

    return m_emo.m_arpThis[cDepth];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Motion.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgtable.inl ===
/***************************************************************************\
*
* File: MsgTable.inl
*
* Description:
* MsgTable.inl implements the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgTable_inl__INCLUDED)
#define MSG__MsgTable_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class MsgTable
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
MsgTable::MsgTable()
{

}


//------------------------------------------------------------------------------
inline 
MsgTable::~MsgTable()
{
    
}


//------------------------------------------------------------------------------
inline void
MsgTable::Destroy()
{
    placement_delete(this, MsgTable);
    ProcessFree(this);
}


//------------------------------------------------------------------------------
inline int
MsgTable::GetCount() const
{
    return m_cMsgs;
}


//------------------------------------------------------------------------------
inline int
MsgTable::GetDepth() const
{
    int cDepth = 0;
    const MsgTable * pmt = m_pmtSuper;
    while (pmt != NULL) {
        cDepth++;
        pmt = pmt->m_pmtSuper;
    }

    return cDepth;
}


//------------------------------------------------------------------------------
inline const MsgClass *
MsgTable::GetClass() const
{
    return m_pmcPeer;
}


//------------------------------------------------------------------------------
inline MsgSlot *
MsgTable::GetSlots()
{
    BYTE * pb = reinterpret_cast<BYTE *> (this);
    pb += sizeof(MsgTable);
    return reinterpret_cast<MsgSlot *> (pb);
}


//------------------------------------------------------------------------------
inline const MsgSlot *
MsgTable::GetSlots() const
{
    BYTE * pb = reinterpret_cast<BYTE *> (const_cast<MsgTable *> (this));
    pb += sizeof(MsgTable);
    return reinterpret_cast<const MsgSlot *> (pb);
}


//------------------------------------------------------------------------------
inline const MsgSlot *
MsgTable::GetMsgSlot(
    IN  int nMsg                        // Method to invoke
    ) const
{
    AssertMsg(nMsg < GM_EVENT, "Must be a method");
    AssertMsg(nMsg >= sizeof(MsgTable), "Must properly offset from the beginning");
    AssertMsg((nMsg - sizeof(MsgTable)) % sizeof(MsgSlot) == 0,
            "Must point to the beginning on a slot");

    BYTE * pb = reinterpret_cast<BYTE *> (const_cast<MsgTable *> (this));
    pb += nMsg;
    return reinterpret_cast<const MsgSlot *> (pb);
}


#endif // MSG__MsgTable_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgobject.inl ===
/***************************************************************************\
*
* File: MsgObject.inl
*
* Description:
* MsgObject.inl implements the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgObject_inl__INCLUDED)
#define MSG__MsgObject_inl__INCLUDED
#pragma once

#include "MsgTable.h"

/***************************************************************************\
*****************************************************************************
*
* class MsgObject
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline MsgObject * 
CastMsgObject(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmMsgObject)) {
        return (MsgObject *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const MsgObject * 
CastMsgObject(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmMsgObject)) {
        return (const MsgObject *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline MsgObject * 
ValidateMsgObject(HGADGET hgad)
{
    return CastMsgObject(BaseObject::ValidateHandle(hgad));
}




//------------------------------------------------------------------------------
inline
MsgObject::MsgObject()
{

}


//------------------------------------------------------------------------------
inline
MsgObject::~MsgObject()
{

}


//------------------------------------------------------------------------------
inline MsgObject * 
MsgObject::RawCastMsgObject(DUser::Gadget * pg)
{
    Assert(pg != NULL);
    return reinterpret_cast<MsgObject *> (((BYTE *) pg) - offsetof(MsgObject, m_emo));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *    
MsgObject::RawCastGadget(MsgObject * pmo)
{
    Assert(pmo != NULL);
    return reinterpret_cast<DUser::Gadget *> (((BYTE *) pmo) + offsetof(MsgObject, m_emo));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastGadget(HGADGET hgad)
{
    return CastGadget(ValidateMsgObject(hgad));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastGadget(MsgObject * pmo)
{
    if (pmo == NULL) {
        return NULL;
    } else {
        return RawCastGadget(pmo);
    }
}


//------------------------------------------------------------------------------
inline HGADGET
MsgObject::CastHandle(DUser::Gadget * pg)
{
    if (pg == NULL) {
        return NULL;
    } else {
        return (HGADGET) RawCastMsgObject(pg)->GetHandle();
    }
}


//------------------------------------------------------------------------------
inline HGADGET
MsgObject::CastHandle(MsgObject * pmo)
{
    if (pmo == NULL) {
        return NULL;
    } else {
        return (HGADGET) pmo->GetHandle();
    }
}


//------------------------------------------------------------------------------
inline MsgObject *
MsgObject::CastMsgObject(DUser::Gadget * pg)
{
    if (pg == NULL) {
        return NULL;
    } else {
        return RawCastMsgObject(pg);
    }
}


//------------------------------------------------------------------------------
inline MsgObject *
MsgObject::CastMsgObject(HGADGET hgad)
{
    return ValidateMsgObject(hgad);
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::GetGadget() const
{
    return RawCastGadget(const_cast<MsgObject *>(this));
}


//------------------------------------------------------------------------------
inline HRESULT
MsgObject::PreAllocThis(int cSlots)
{
#if DBG
    AssertMsg(m_emo.m_arpThis.GetSize() == 0, "Only can preallocate once");
#endif

    BOOL fSuccess = m_emo.m_arpThis.SetSize(cSlots);

#if DBG
    if (fSuccess) {
        for (int idxSlot = 0 ; idxSlot < cSlots; idxSlot++) {
            m_emo.m_arpThis[idxSlot] = ULongToPtr(0xA0E20000 + idxSlot);
        }
    }
#endif

    return fSuccess ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
inline void
MsgObject::FillThis(int idxSlotStart, int idxSlotEnd, void * pvThis, const MsgTable * pmtNew)
{
    AssertMsg(idxSlotStart <= idxSlotEnd, "Must give valid indicies");
    AssertMsg(idxSlotEnd < m_emo.m_arpThis.GetSize(), "Must preallocate this array");

    for (int idxSlot = idxSlotStart; idxSlot <= idxSlotEnd; idxSlot++) {
        AssertMsg(m_emo.m_arpThis[idxSlot] == ULongToPtr(0xA0E20000 + idxSlot), 
                "Slot must not be already set");
        m_emo.m_arpThis[idxSlot] = pvThis;
    }
    m_emo.m_pmt = pmtNew;
}


//------------------------------------------------------------------------------
inline HRESULT
MsgObject::Promote(void * pvThis, const MsgTable * pmtNew)
{
    int idxAdd = m_emo.m_arpThis.Add(pvThis);
    if (idxAdd < 0) {
        return E_OUTOFMEMORY;
    }

    m_emo.m_pmt = pmtNew;
    return S_OK;
}


//------------------------------------------------------------------------------
inline void
MsgObject::Demote(int cLevels)
{
    int cThis = m_emo.m_arpThis.GetSize();
    AssertMsg(cThis >= 1, "Must have been previously promoted");
    AssertMsg(cLevels <= cThis, "Can only remove as many levels as available");

    Verify(m_emo.m_arpThis.SetSize(cThis - cLevels));
}


//------------------------------------------------------------------------------
inline void * 
MsgObject::GetThis(int idxThis) const
{
    return m_emo.m_arpThis[idxThis];
}


//------------------------------------------------------------------------------
inline int
MsgObject::GetDepth() const
{
    return m_emo.m_arpThis.GetSize();
}


//------------------------------------------------------------------------------
inline int
MsgObject::GetBuildDepth() const
{
    return m_emo.m_pmt != NULL ? m_emo.m_pmt->GetDepth() + 1 : 0;
}


//------------------------------------------------------------------------------
inline void
MsgObject::InvokeMethod(
    IN  MethodMsg * pmsg                // Method to invoke
    ) const
{
    GetGadget()->CallStubMethod(pmsg);
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastClass(const MsgClass * pmcTest) const
{
    if (InstanceOf(pmcTest)) {
        return GetGadget();
    } else {
        return NULL;
    }
}


#endif // MSG__MsgObject_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  8/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__Public_h__INCLUDED)
#define MSG__Public_h__INCLUDED

#include "MsgTable.h"
#include "MsgClass.h"
#include "MsgObject.h"
#include "ClassLibrary.h"

#endif // MSG__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgobject.h ===
/***************************************************************************\
*
* File: MsgObject.h
*
* Description:
* MsgObject.h defines the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgObject_h__INCLUDED)
#define MSG__MsgObject_h__INCLUDED
#pragma once

class MsgTable;
class MsgClass;

struct ExposedMsgObject
{
    const MsgTable *    m_pmt;
    GArrayS<void *>     m_arpThis;
};

class MsgObject : public BaseObject
{
// Construction
public:
    inline  MsgObject();
    inline  ~MsgObject();
protected:
    virtual void        xwDestroy();
            void        xwEndDestroy();

// BaseObject
public:
    virtual HandleType  GetHandleType() const { return htMsgObject; }
    virtual UINT        GetHandleMask() const { return hmMsgObject; }
    
// Operations
public:
    static  DUser::Gadget *    
                        CastGadget(HGADGET hgad);
    static  DUser::Gadget *    
                        CastGadget(MsgObject * pmo);
    static  HGADGET     CastHandle(DUser::Gadget * pg);
    static  HGADGET     CastHandle(MsgObject * pmo);
    static  MsgObject * CastMsgObject(DUser::Gadget * pg);
    static  MsgObject * CastMsgObject(HGADGET hgad);
    inline  DUser::Gadget *    
                        GetGadget() const;

            BOOL        InstanceOf(const MsgClass * pmcTest) const;
    inline  DUser::Gadget *    
                        CastClass(const MsgClass * pmcTest) const;
            void *      GetGutsData(const MsgClass * pmcData) const;

    inline  HRESULT     PreAllocThis(int cSlots);
    inline  void        FillThis(int idxSlotStart, int idxSlotEnd, void * pvThis, const MsgTable * pmtNew);

    inline  HRESULT     Promote(void * pvThis, const MsgTable * pmtNew);
    inline  void        Demote(int cLevels);
    inline  void *      GetThis(int idxThis) const;
    inline  int         GetDepth() const;
    inline  int         GetBuildDepth() const;

    inline  void        InvokeMethod(MethodMsg * pmsg) const;

#if 1
            BOOL        SetupInternal(HCLASS hcl);
#endif

// Implementation
protected:
    static  MsgObject * RawCastMsgObject(DUser::Gadget * pg);
    static  DUser::Gadget *    
                        RawCastGadget(MsgObject * pmo);

public:
    static  HRESULT CALLBACK
                        PromoteInternal(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);
    static  HCLASS CALLBACK
                        DemoteInternal(HCLASS hclCur, DUser::Gadget * pgad, void * pvData);


// Data
private:
            ExposedMsgObject    
                        m_emo;          // Actual data
public:
    static  HCLASS      s_hclSuper;     // DUMMY data used by IMPL classes
};


#define DECLARE_INTERNAL(name) \
    static HCLASS CALLBACK \
    Demote##name(HCLASS hclCur, DUser::Gadget * pgad, void * pvData) \
    { \
        return DemoteInternal(hclCur, pgad, pvData); \
    } \
    \
    static void MarkInternal() \
    { \
        GetClassLibrary()->MarkInternal(s_mc.hclNew); \
    } \

template <class T>
inline T * 
Cast(const MsgObject * pmo)
{
    return static_cast<T *> (const_cast<MsgObject *> (pmo)->GetGadget());
}


#include "MsgObject.inl"

#endif // MSG__MsgObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\msg\msgtable.cpp ===
/***************************************************************************\
*
* File: MsgTable.cpp
*
* Description:
* MsgTable.cpp implements the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgTable.h"

#include "MsgClass.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgTable
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgTable::Build
*
* Build() builds and fully initializes a new MsgTable.
* 
\***************************************************************************/

HRESULT
MsgTable::Build(
    IN  const DUser::MessageClassGuts * pmcInfo, 
                                        // Implementation information
    IN  const MsgClass * pmcPeer,       // "Owning" MsgClass
    OUT MsgTable ** ppmtNew)            // Newly built MsgTable
{
    AssertMsg(pmcPeer != NULL, "Must have a valid MsgClass peer");
    HRESULT hr = S_OK;

    //
    // Compute how much memory the MsgTable will take
    // - Find the Super
    // - Determine the number of messages.  This is the number of messages 
    //   defined in the super + the number of _new_ (not overridden) messages.
    //

    int cSuperMsgs = 0, cNewMsgs = 0;
    const MsgClass * pmcSuper = pmcPeer->GetSuper();
    const MsgTable * pmtSuper = NULL;
    if (pmcSuper != NULL) {
        pmtSuper = pmcSuper->GetMsgTable();
        cSuperMsgs = pmtSuper->GetCount();
        for (int idx = 0; idx < pmcInfo->cMsgs; idx++) {
            if ((pmcInfo->rgMsgInfo[idx].pfn != NULL) &&
                (pmtSuper->Find(FindAtomW(pmcInfo->rgMsgInfo[idx].pszMsgName)) == 0)) {

                cNewMsgs++;
            }
        }
    } else {
        cNewMsgs = pmcInfo->cMsgs;
    }


    //
    // Allocate the new MsgTable
    //

    int cTotalMsgs      = cSuperMsgs + cNewMsgs;
    int cbAlloc         = sizeof(MsgTable) + cTotalMsgs * sizeof(MsgSlot);
    if ((cbAlloc > GM_EVENT) || (cTotalMsgs > 1024)) {
        PromptInvalid("MsgTable will contain too many methods.");
        return E_INVALIDARG;
    }

    void * pvAlloc      = ProcessAlloc(cbAlloc);
    if (pvAlloc == NULL) {
        return E_OUTOFMEMORY;
    }
    MsgTable * pmtNew   = placement_new(pvAlloc, MsgTable);
    pmtNew->m_cMsgs     = cTotalMsgs;
    pmtNew->m_pmcPeer   = pmcPeer;
    pmtNew->m_pmtSuper  = pmtSuper;


    //
    // Setup message entries
    // - Copy messages from super-class
    // - Override and add messages from new class
    //
    // NOTE: We are using GArrayS<> to store the array of this pointers.  The
    // data stored in here points to the beginning of the array of data.  
    // Before this array, we store the size, but we don't need to worry about 
    // that here.
    //

    if (cTotalMsgs > 0) {
        MsgSlot * rgmsDest  = pmtNew->GetSlots();
        int cThisDepth      = pmtSuper != NULL ? pmtSuper->GetDepth() + 1 : 0;
        int cbThisOffset    = cThisDepth * sizeof(void *);
        int idxAdd = 0;

        if (pmtSuper != NULL) {
            const MsgSlot * rgmsSrc = pmtSuper->GetSlots();
            for (idxAdd = 0; idxAdd < cSuperMsgs; idxAdd++) {
                rgmsDest[idxAdd] = rgmsSrc[idxAdd];
            }
        }
        Assert(idxAdd == cSuperMsgs);

        for (int idx = 0; idx < pmcInfo->cMsgs; idx++) {
            const DUser::MessageInfoGuts * pmi = &pmcInfo->rgMsgInfo[idx];
            ATOM atomMsg    = 0;
            int idxMsg      = -1;

            if (pmi->pfn == NULL) {
                continue;  // Just skip this slot
            }

            if ((pmtSuper == NULL) ||                               // No super
                ((atomMsg = FindAtomW(pmi->pszMsgName)) == 0) ||    // Message not yet defined
                ((idxMsg = pmtSuper->FindIndex(atomMsg)) < 0)) {    // Message not in super

                //
                // Function is defined, so it should be added.
                //

                atomMsg = AddAtomW(pmi->pszMsgName);
                idxMsg  = idxAdd++;
            }

            MsgSlot & ms    = rgmsDest[idxMsg];
            ms.atomNameID   = atomMsg;
            ms.cbThisOffset = cbThisOffset;
            ms.pfn          = pmi->pfn;
        }

        AssertMsg(idxAdd == cTotalMsgs, "Should have added all messages");


        //
        // Check to see if any messages were not properly setup.
        //

        BOOL fMissing = FALSE;
        for (idx = 0; idx < cTotalMsgs; idx++) {
            if (rgmsDest[idx].pfn == NULL) {
                //
                // Function is not defined and is not in the super.  This is
                // an error because it is being declared "new" and not being
                // defined.
                //

                WCHAR szMsgName[256];
                GetAtomNameW(rgmsDest[idx].atomNameID, szMsgName, _countof(szMsgName));

                Trace("ERROR: DUser: %S::%S() was not properly setup.\n", 
                        pmcInfo->pszClassName, szMsgName);
                fMissing = TRUE;
            }
        }

        if (fMissing) {
            PromptInvalid("Class registration does not have all functions properly setup.");
            hr = DU_E_MESSAGENOTIMPLEMENTED;
            goto ErrorExit;
        }
    }


    //
    // Done building- return out
    //

    *ppmtNew = pmtNew;
    return S_OK;

ErrorExit:
    delete pmtNew;
    return hr;
}


/***************************************************************************\
*
* MsgTable::FindIndex
*
* FindIndex() finds the corresponding index for the specified 
* method / message.
* 
\***************************************************************************/

int
MsgTable::FindIndex(
    IN  ATOM atomNameID                 // Method to find
    ) const
{
    const MsgSlot * rgSlots = GetSlots();
    for (int idx = 0; idx < m_cMsgs; idx++) {
        if (rgSlots[idx].atomNameID == atomNameID) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* MsgTable::Find
*
* Find() finds the corresponding MsgSlot for the specified method / message.
* 
\***************************************************************************/

const MsgSlot *
MsgTable::Find(
    IN  ATOM atomNameID                 // Method to find
    ) const
{
    int idx = FindIndex(atomNameID);
    if (idx >= 0) {
        return &(GetSlots()[idx]);
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
#define AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_

#pragma once

#include "CommonStdAfx.h"
#include <atlconv.h>            // String conversion routines

#endif // !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these files directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*   9/7/2000:  JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(OBJECTAPI__Public_h__INCLUDED)
#define OBJECTAPI__Public_h__INCLUDED

#define GADGET_ENABLE_ALL
#define GADGET_ENABLE_GDIPLUS
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_DX
#define GADGET_ENABLE_TRANSITIONS

#include "DUser.h"
#include "DUserCore.h"
#include "DUserMotion.h"
#include "DUserCtrl.h"

#include "Stub.h"
#include "Super.h"
#include "Validate.h"

#endif // OBJECTAPI__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\objectapi.h ===
/***************************************************************************\
*
* File: ObjectAPI.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(OBJECTAPI__ObjectApi_h__INCLUDED)
#define OBJECTAPI__ObjectApi_h__INCLUDED
#pragma once

#include "Public.h"

#include <DUserBaseP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/ObjectAPI Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // OBJECTAPI__ObjectApi_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\sources.inc ===
!IF 0

Module Name:  Shared sources.inc file for RockAll projects.

Abstract:

Author:
        JStall

!ENDIF

SOURCES_USED=..\sources.inc

MSC_WARNING_LEVEL=-W4

USE_MSVCRT=1
USE_IOSTREAM=1
MSC_OPTIMIZATION=/Oxt

C_DEFINES=$(C_DEFINES) -DWIN32 -D_MBCS -DNO_DEFAULT_HEAP -DROCKALL_DIRECTUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser -I..\..\inc\public DUser.gidl DUserCtrl.gidl DUser.gh DUserCtrl.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml

$(O)\super.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser -I..\..\inc\public DUser.gidl DUserCtrl.gidl DUser.gh DUserCtrl.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\bucket.hpp ===
#ifndef _BUCKET_HPP_
#define _BUCKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Connections.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A collection of pages.                                         */
    /*                                                                  */
    /*   A bucket is a collection of pages capable of allocating        */
    /*   fixed sized memory elements.  The pages are allocated from     */
    /*   from larger buckets and are stored in a linked list in         */
    /*   order of ascending of page addresses.                          */
    /*                                                                  */
    /********************************************************************/

class BUCKET : public CONNECTIONS
    {
		//
		//   Private type definitions.
		//
		//   All allocations are registered in bit vectors.
		//   Here we have some prototypes for seriously  
		//   optimized functions to do address to bit 
		//   vector computations.
		//
		typedef VOID *(BUCKET::*COMPUTE_ADDRESS)
			( 
			CHAR					  *Address,
			SBIT32					  Offset 
			);

		typedef SBIT32 (BUCKET::*COMPUTE_OFFSET)
			( 
			SBIT32					  Displacement,
			BOOLEAN					  *Found 
			);

		//
		//   Private data.
		//
		//   A bucket owns all the memory of a given size
		//   and manages it.  Above it is a cache to 
		//   protect it from huge number of calls and
		//   below it are the connections to various 
		//   other classes.  The 'AllocationSize' is the
		//   buckets allocation size.  The 'ChunkSize' is
		//   chunking size which is typically half way
		//   between the 'AllocationSize' and the 'PageSize'.
		//   The 'PageSize' is the size of the bucket
		//   where this bucket gets its space.
		//   
		//
		SBIT32                        AllocationSize;
		SBIT32						  ChunkSize;
		SBIT32						  PageSize;

		//
		//   It is the job of the bucket to keep track of
		//   all the information relating to allocations
		//   of a given 'AllocationSize'.  The 'ActivePages'
		//   keeps track of the number of available pages
		//   in the 'BucketList'.  The 'BucketList' is a
		//   linked list of pages that have available space.
		//   The 'CurrentPage' contains the highest address
		//   of the first page in the 'BucketList'.
		//
		SBIT32						  ActivePages;
		LIST						  BucketList;
		VOID						  *CurrentPage;

		//
		//   A bucket needs to be able to quickly convert
		//   bit vector offsets to addresses (and vice versa).
		//   The 'AllocationShift' is set when the 
		//   'AllocationSize' is a power of two to avoid 
		//   any divides.  The 'ComputeAddressFunction'
		//   and 'ComputeOffsetFunction' point to optimized
		//   functions to do conversions that are selected
		//   by the constructor.
		//
		SBIT32						  AllocationShift;
		COMPUTE_ADDRESS				  ComputeAddressFunction;
		COMPUTE_OFFSET				  ComputeOffsetFunction;

		//
		//   A bucket typically contains a collection of
		//   pages.  As all pages are the same data that
		//   should really be stored in page descriptions
		//   is instead stored in the bucket to save space.
		//   The 'NumberOfElements' contains the number of
		//   elements in each pages bit vector.  The 
		//   'SizeOfChunks' contains the pre-computed chunk
		//   size.  The 'SizeOfElements' contains the number
		//   of words in the pages bit vector.  The 'SizeKey'
		//   contains an index which selects the size of the
		//   bit vector when a new page is created.
		//
		SBIT16						  NumberOfElements;
		SBIT16						  SizeOfChunks;
		SBIT16						  SizeOfElements;
		SBIT16						  SizeKey;

   public:
		//
		//   Public functions.
		//
		//   The functionality provided by this class pretty
		//   much matches the external API.  Nonetheless, these
		//   APIs are protected from excessive calls by a fast
		//   cache that is derived from this class.
		//
        BUCKET
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize 
			);

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteFromBucketList( PAGE *Page );

		VOID InsertInBucketList( PAGE *Page );

		BOOLEAN MultipleDelete
			( 
			ADDRESS_AND_PAGE		  *Array,
			SBIT32					  *Deleted,
			SBIT32					  Size 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		VOID UpdateBucket
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~BUCKET( VOID );

		//
		//   Public inline functions.
		//
		//   It saves a significant amount of space by putting
		//   common information in the bucket instead of a 
		//   separate copy in each page description.  Nonetheless,
		//   it means that both classes are very much dependent
		//   upon each other.
		//
		INLINE VOID *ComputeAddress( CHAR *Address,SBIT32 Offset )
			{ return (this ->* ComputeAddressFunction)( Address,Offset ); }

		INLINE SBIT32 ComputeOffset( SBIT32 Displacement,BOOLEAN *Found )
			{ return (this ->* ComputeOffsetFunction)( Displacement,Found ); }

		INLINE SBIT32 GetAllocationSize( VOID )
			{ return AllocationSize; }

		INLINE SBIT32 GetChunkSize( VOID )
			{ return ChunkSize; }

		VOID *GetCurrentPage( VOID )
			{ return CurrentPage; }

		INLINE SBIT16 GetNumberOfElements( VOID )
			{ return NumberOfElements; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE SBIT16 GetSizeOfChunks( VOID )
			{ return SizeOfChunks; }

		INLINE SBIT16 GetSizeOfElements( VOID )
			{ return SizeOfElements; }

		INLINE SBIT16 GetSizeKey( VOID )
			{ return SizeKey; }

	private:
		//
		//   Private functions.
		//
		//   When we need to convert an address to a bit 
		//   offset (or vice versa) we use one of the following 
		//   functions.
		//
		VOID *ComputeAddressWithShift( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWithMultiply( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWithDivide( CHAR *Address,SBIT32 Offset );

		SBIT32 ComputeOffsetWithShift( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWithMultiply( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWithDivide( SBIT32 Displacement,BOOLEAN *Found );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BUCKET( CONST BUCKET & Copy );

        VOID operator=( CONST BUCKET & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\objectapi\validate.h ===
#if !defined(OBJECTAPI__Validate_h__INCLUDED)
#define OBJECTAPI__Validate_h__INCLUDED
#pragma once

#if DBG

// AutoDebug functions that are only available in DEBUG builds

inline BOOL IsBadCode(const void * pv)
{
    return IsBadCodePtr((FARPROC) pv);
}

template <class T>
inline BOOL IsBadRead(const void * pv, T cb)
{
    return IsBadReadPtr(pv, (UINT_PTR) cb);
}

template <class T>
inline BOOL IsBadWrite(void * pv, T cb)
{
    return IsBadWritePtr(pv, (UINT_PTR) cb);
}

inline BOOL IsBadString(LPCTSTR pv, int cb)
{
    return IsBadStringPtr(pv, (UINT_PTR) cb);
}

inline BOOL IsBadStringA(LPCSTR pv, int cb)
{
    return IsBadStringPtrA(pv, (UINT_PTR) cb);
}

inline BOOL IsBadStringW(LPCWSTR pv, int cb)
{
    return IsBadStringPtrW(pv, (UINT_PTR) cb);
}

#else // DBG

inline BOOL IsBadCode(const void * pv)
{
    UNREFERENCED_PARAMETER(pv);
    return FALSE;
}

template <class T>
inline BOOL IsBadRead(const void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

template <class T>
inline BOOL IsBadWrite(void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadString(LPCTSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadStringA(LPCSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadStringW(LPCWSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

#endif // DBG



//
// API Entry / Exit setup rountines
//

#if DBG

#define BEGIN_API(defermsg, pctx)               \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \
        Context * pctxThread = pctx;            \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg, pctxThread)) { \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \
        AssertInstance(pctxThread);            \
                                                \
        if (pctx != ::RawGetContext()) {        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            retval = DU_E_INVALIDCONTEXT;       \
            goto ErrorExit;                     \
        }                                       \
        if (pmsg == NULL) {                     \
            PromptInvalid("Must specify a valid message"); \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \

#else // DBG

#define BEGIN_API(defermsg, pctx)               \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \
        Context * pctxThread = pctx;            \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg, pctxThread)) { \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \
                                                \
        if (pmsg == NULL) {                     \
            PromptInvalid("Must specify a valid message"); \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \

#endif // DBG

#define END_API()                               \
        goto ErrorExit;                         \
ErrorExit:                                      \
        /* Unlocks the Context here */          \
        ;                                       \
    }                                           \
    return retval;


#define BEGIN_API_NOLOCK()                      \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \


#define END_API_NOLOCK()                        \
        goto ErrorExit;                         \
ErrorExit:                                      \
        ;                                       \
    }                                           \
    return retval;



#define BEGIN_API_NOCONTEXT()                   \
    HRESULT retval = DU_E_GENERIC;              \


#define END_API_NOCONTEXT()                     \
    goto ErrorExit;                             \
ErrorExit:                                      \
    return retval;



#define CHECK_MODIFY()                          \
    if (pctxThread->IsReadOnly()) {             \
        PromptInvalid("Can not call modifying function while in read-only state / callback"); \
        retval = DU_E_READONLYCONTEXT;          \
        goto ErrorExit;                         \
    }                                           \


//
// Individual parameter validation rountines
//

#define VALIDATE_GADGETCONTEXT(v)                           \
    {                                                       \
        Context * pctxGad = (v)->GetContext();              \
        if (pctxThread != pctxGad) {                        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            retval = DU_E_INVALIDCONTEXT;                   \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VALUE(x, v)                                \
    if (x != v) {                                           \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_HWND(wnd)                                  \
    if ((h##wnd == NULL) || (!IsWindow(h##wnd))) {          \
        PromptInvalid("Handle is not a valid Window");     \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_REGION(rgn)                                \
    if (h##rgn == NULL) {                                   \
        PromptInvalid("Handle is not a valid region");     \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_OBJECT(r, v)                               \
    {                                                       \
        v = BaseObject::ValidateHandle(r);                  \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid object"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_EVENTGADGET(r, v)                          \
    {                                                       \
        v = ValidateBaseGadget(r);                          \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(v)                           \
    }

#define VALIDATE_EVENTGADGET_NOCONTEXT(r, v)                \
    {                                                       \
        v = ValidateBaseGadget(r);                          \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VISUAL(r, v)                               \
    {                                                       \
        v = ValidateVisual(r);                              \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(v)                           \
    }

#define VALIDATE_ROOTGADGET(r, v)                           \
    {                                                       \
        {                                                   \
            DuVisual * pgadTemp = ValidateVisual(r);        \
            if (pgadTemp == NULL) {                         \
                PromptInvalid("Handle is not a valid Gadget"); \
                retval = E_INVALIDARG;                      \
                goto ErrorExit;                             \
            }                                               \
            if (!pgadTemp->IsRoot()) {                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(pgadTemp)                \
            v = (DuRootGadget *) pgadTemp;                  \
        }                                                   \
    }

#define VALIDATE_VISUAL_OR_NULL(r, v)                       \
    {                                                       \
        if (r == NULL) {                                    \
            v = NULL;                                       \
        } else {                                            \
            v = ValidateVisual(r);                          \
            if (v == NULL) {                                \
                PromptInvalid("Handle is not a valid Gadget"); \
                retval = E_INVALIDARG;                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(v)                       \
        }                                                   \
    }

#define VALIDATE_TRANSITION(trx)                            \
    {                                                       \
        BaseObject * pbase##trx = BaseObject::ValidateHandle(h##trx); \
        p##trx = CastTransition(pbase##trx);                \
        if (p##trx == NULL) {                               \
            PromptInvalid("Handle is not a valid Transition"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_FLAGS(f, m)                                \
    if ((f & m) != f) {                                     \
        PromptInvalid("Specified flags are invalid");      \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_RANGE(i, a, b)                             \
    if (((i) < (a)) || ((i) > (b))) {                       \
        PromptInvalid("Value is outside expected range");  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR(p)                                \
    if ((p == NULL) || IsBadCode(p)) {                      \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR_OR_NULL(p)                        \
    if ((p != NULL) && IsBadCode((FARPROC) p)) {            \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR(p)                                \
    if ((p == NULL) || IsBadRead(p, sizeof(char *))) {      \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_(p, b)                            \
    if ((p == NULL) || IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL_(p, b)                    \
    if ((p != NULL) && IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_STRUCT(p, s)                          \
    if ((p == NULL) || IsBadRead(p, sizeof(s))) {           \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_WRITE_PTR(p)                               \
    if ((p == NULL) || IsBadWrite(p, sizeof(char *))) {     \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_(p, b)                           \
    if ((p == NULL) || IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_OR_NULL_(p, b)                   \
    if ((p != NULL) && IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_STRUCT(p, s)                         \
    if ((p == NULL) || IsBadWrite(p, sizeof(s))) {          \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_STRING_PTR(p, cch)                         \
    if ((p == NULL) || IsBadString(p, cch)) {               \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGA_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringA(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGW_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringW(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \





#endif // OBJECTAPI__Validate_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\bucket.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Bucket.hpp"
#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here relate the compuation of the       */
    /*   current active page address range.                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HighestAddress			  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation bucket and prepare it for use.         */
    /*   We need to be sure to carefully check everything we have       */
    /*   been supplied as it has come indirectly from the user.         */
    /*                                                                  */
    /********************************************************************/

BUCKET::BUCKET
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize 
		)
    {
	//
	//   We want to make sure that the bucket configuration
	//   appears to make basic sense.  If not we have no 
	//   alternative than to throw an expection.
	//
	if
			(
			(NewAllocationSize > 0)
				&&
			(NewChunkSize >= NewAllocationSize)
				&&
			(NewChunkSize <= NewPageSize)
				&&
			PowerOfTwo( NewPageSize )
			)
		{
		//
		//   Create the bucket and prepare it for use.
		//   Pre-compute any information we can here to
		//   save work later.
		//
		AllocationSize = NewAllocationSize;
		ChunkSize = NewChunkSize;
		PageSize = NewPageSize;

		ActivePages = 0;
		AllocationShift = 0;

		//
		//   Compute the optimization level from the
		//   available bucket information.  The highest
		//   level means everything is a power of two
		//   (just shifts - yipee !!).  The next means
		//   means no chunks (just multiplies and one 
		//   divide).  The final alternative is not even
		//   pleasant to think about.
		//   
		if ( ConvertDivideToShift( AllocationSize,& AllocationShift ) )
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{
				ComputeAddressFunction = ComputeAddressWithShift;
				ComputeOffsetFunction = ComputeOffsetWithShift;
				}
			else
				{ 
				ComputeAddressFunction = ComputeAddressWithDivide;
				ComputeOffsetFunction = ComputeOffsetWithDivide;
				}
			}
		else
			{
			//
			//   If we are not using chunking we can ship the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{ 
				ComputeAddressFunction = ComputeAddressWithMultiply;
				ComputeOffsetFunction = ComputeOffsetWithMultiply;
				}
			else
				{ 
				ComputeAddressFunction = ComputeAddressWithDivide;
				ComputeOffsetFunction = ComputeOffsetWithDivide;
				}
			}

		//
		//   Compute all the information that will be
		//   needed later to describe the allocation
		//   pages.
		//
		NumberOfElements = 
			((SBIT16) ((PageSize / ChunkSize) * (ChunkSize / AllocationSize)));
		SizeOfChunks = (SBIT16)
			((SBIT16) (ChunkSize / AllocationSize));
		SizeOfElements = (SBIT16)
			((SBIT16) (((NumberOfElements-1) / OverheadBitsPerWord) + 1));
		SizeKey = NoSizeKey;
		}
	else
		{ Failure( "Configuration in constructor for BUCKET" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithShift( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset << AllocationShift))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithMultiply( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset * AllocationSize))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithDivide( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber * ChunkSize)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithShift( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;

	ArrayOffset = (Displacement >> AllocationShift);

	(*Found) = (Displacement == (ArrayOffset << AllocationShift));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithShift" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithMultiply( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;

	ArrayOffset = (Displacement / AllocationSize);

	(*Found) = (Displacement == (ArrayOffset * AllocationSize));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithMultiply" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithDivide( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement / ChunkSize);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber * ChunkSize);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithDivide" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a single memory allocation from a bucket.    */
    /*   We do this by passing the request on to the page.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	AUTO SEARCH_PAGE Details;

	//
	//   When we delete an allocation we need to ensure 
	//   the page has not radically changed since we found
	//   it.  Hence, we compare the current page version  
	//   number with the one we found earlier.  If all is 
	//   well we get the details relating to the allocation
	//   and then delete it.
	//
	return
		(
		((Page -> GetVersion()) == Version)
			&&
		(Page -> FindPage( Address,& Details,False ) != NULL)
			&&
		(Page -> Delete( & Details ))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page from the bucket list.                            */
    /*                                                                  */
    /*   When a page becomes full it is removed from the bucket list    */
    /*   so it will be no longer inspected when looking for free space. */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::DeleteFromBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	if ( (-- ActivePages) >= 0 )
		{
		//
		//   Delete the page from the bucket list as it is 
		//   no longer needed.  There are two cases when this 
		//   happens.  When the page is full and when the page 
		//   is about to be deleted.
		//
		Page -> DeleteFromBucketList( & BucketList );

		//
		//   Compute the highest address on the first page.  We 
		//   use this information to figure out whether to 
		//   recycle an allocation or pass it along for deletion
		//   in the cache.
		//
		Page = (PAGE::FirstInBucketList( & BucketList ));
		
		if ( ! Page -> EndOfBucketList() )
			{
			CurrentPage =
				(
				((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
				);
			}
		else
			{ CurrentPage = ((VOID*) HighestAddress); }
		}
	else
		{ Failure( "Active page count in DeleteFromBucketList" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a page into the bucket list.                            */
    /*                                                                  */
    /*   When a page is created or when it changes from being full      */
    /*   to having at least one free slot it is added to the bucket     */
    /*   list so that it can be used to allocate space.                 */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::InsertInBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	ActivePages ++;

	//
	//   We insert pages into the list in ascending address
	//   order.  This ensures that we always allocate the 
	//   lowest addresses first.  This is done to try to keep 
	//   the working set small and compact.
	//
	if ( ! BucketList.EndOfList() )
		{
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER PAGE *Last = (Page -> LastInBucketList( & BucketList ));

		//
		//   We are about to walk the entire page list
		//   trying to find where to insert this page.
		//   Lets see if the page needs to be inserted
		//   at the end of the list.  If so have saved
		//   ourseleves a lot of work and we can exit 
		//   early.
		//   
		if ( Address < (Last -> GetAddress()) )
			{
			REGISTER PAGE *Current;

			//
			//   Well it looks like we need to walk along 
			//   the entire page list to find the correct 
			//   place to insert this element.
			//
			for 
					( 
					Current = (Page -> FirstInBucketList( & BucketList ));
					! Current -> EndOfBucketList();
					Current = Current -> NextInBucketList() 
					)
				{
				//
				//   While the current address is lower 
				//   than ours we need to keep on walking.
				//
				if ( Address < (Current -> GetAddress()) )
					{
					//
					//   We have found the spot so insert 
					//   the bucket just before the current 
					//   bucket.
					//
					Current -> InsertBeforeInBucketList( & BucketList,Page );

					break;
					}
				}
			}
		else
			{
			//
			//   The page has the highest address so insert
			//   it at the end of the list.
			//
			Last -> InsertAfterInBucketList( & BucketList,Page );
			}
		}
	else
		{ Page -> InsertInBucketList( & BucketList ); }

	//
	//   Compute the highest address on the first page.  We can
	//   use this information to figure out whether to recycle an
	//   allocation or pass it along for deletion in the cache.
	//
	Page = (PAGE::FirstInBucketList( & BucketList ));
	
	CurrentPage =
		(
		((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When the delete cache becomes full we complete any pending     */
    /*   delete requests.  We also flush the delete cache when if       */
    /*   we need to allocate additional memory unless recycling is      */
    /*   enabled in which case we just steal it directly from the       */
    /*   delete cache.                                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleDelete
		( 
		ADDRESS_AND_PAGE			  *Array,
		SBIT32						  *Deleted,
		SBIT32						  Size 
		)
	{
	AUTO SEARCH_PAGE Details;
	REGISTER SBIT32 Count;

	//
	//   Zero the count of deleted items.
	//
	(*Deleted) = 0;

	//
	//   Delete each element one at a time.  We would love to
	//   delete them all at once but we haven't got a clue where
	//   they have come from so we have to do it one at a time. 
	//   
	for ( Count=0;Count < Size;Count ++ )
		{
		REGISTER ADDRESS_AND_PAGE *Current = & Array[ Count ];
		REGISTER PAGE *Page = Current -> Page;

		//
		//   It may see like a waste of time to batch up all
		//   the deletions.  Why not do them as they arrive.
		//   There are a number of reasons.  The deletes can
		//   be recycled, batchs of deletes is faster than
		//   single deletes (due to cache effects) and so on.
		//
		if
				(
				(Current -> Version == Page -> GetVersion())
					&&
				(Page -> FindPage( Current -> Address,& Details,False ) != NULL)
					&&
				(Page -> Delete( & Details ))
				)
			{ (*Deleted) ++; }
		}

	return ((*Deleted) == Size);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We need to make a multiple memory allocation from this			*/
    /*   bucket so walk the bucket list allocating any available        */
    /*   space and return it to the caller.                             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested 
		)
    {
	//
	//   Zero the count of allocated elements.
	//
	(*Actual) = 0;

	//
	//   We walk the sorted list of pages with available
	//   allocations searching for elements to allocate.
	//
	do
		{
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = NextPage
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   Lets find the next page now as the current 
			//   bucket may be removed from the bucket list
			//   by the following allocation call.
			//
			NextPage = Page -> NextInBucketList();

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the standard size then skip it.
			//
			if ( (ActualSize == NoSize) || (ActualSize == PageSize) )
				{
				//
				//   We try allocate all the space we need 
				//   from each page in the bucket list.  If 
				//   the page has enough space we can exit 
				//   early if not we go round the loop and
				//   try the next page.
				//
				if ( Page -> MultipleNew( Actual,Array,Requested ) )
					{ return True; }
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( (CACHE*) this )
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We see if we managed to allocate all the elements
	//   we wanted.  If so we are happy and we can get out 
	//   of here.
	//
	if ( (*Actual) < Requested )
		{
		//
		//   We see if we managed to allocate any elements 
		//   at all.  If not we fail the request.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 Delta = ((Requested) - (*Actual));

			//
			//   We are very naughty when we allocate multiple
			//   elements in that we put them in the array in
			//   reverse order.  The logic is that this is just
			//   what we want when we allocate out of the cache.
			//   However, if we are unable to allocate all the
			//   elements we needed then we have to move the 
			//   pointers down to the base of the array.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ Array[ Count ] = Array[ (Count + Delta) ]; }
			}
		else
			{ return False; }
		}

	return True;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We need to make a new memory allocation from this bucket       */
    /*   so search the page list of available space and return a        */
    /*   free element.                                                  */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::New( BOOLEAN SubDivided,SBIT32 NewSize )
    {
	do
		{
		REGISTER PAGE *Page;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = Page -> NextInBucketList()
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the correct size then skip it.
			//
			if 
					( 
					(ActualSize == NoSize) 
						|| 
					(ActualSize == ((NewSize == NoSize) ? PageSize : NewSize))
					)
				{
				//
				//   We know that any page that appears in 
				//   the bucket list will have at least one 
				//   free element available.  So if we find
				//   that the bucket list a suitable page 
				//   then we know that we can allocate something.
				//
				return (Page -> New( SubDivided ));
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( ((CACHE*) this),NewSize ) 
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We were unable to find anything we could allocate
	//   so fail the request.
	//
	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::ReleaseSpace( SBIT32 MaxActivePages )
    {
	REGISTER SBIT32 Current = ActivePages;

	//
	//   We only bother to try to trim the number of
	//   active pages if we are over the limit.
	//
	if ( Current > MaxActivePages )
		{
		REGISTER PAGE *NextPage;
		REGISTER PAGE *Page;

		//
		//   Walk the backwards along the bucket list 
		//   and delete the highest addressed free pages
		//   if we are over the limit.
		//
		for 
				( 
				Page = (PAGE::LastInBucketList( & BucketList ));
				(Current > MaxActivePages) 
					&& 
				(! Page -> EndOfBucketList());
				Page = NextPage
				)
			{
			//
			//   We are walking backwards down the bucket
			//   list looking for empty pages to delete.
			//   However, if we find a page we can remove
			//   it will be automatically removed from the
			//   list so we need to get the next pointer
			//   before this happens.
			//
			NextPage = Page -> PreviousInBucketList();

			//
			//   We can only release a page if it is empty
			//   if not we must skip it.
			//
			if ( Page -> Empty() )
				{
				Current --;

				DeletePage( Page ); 
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data we need.                                   */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::UpdateBucket
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	REGISTER SBIT16 NewSizeKey = (NewPages -> FindSizeKey( NumberOfElements ));

	//
	//   We compute and verify the size key to make sure
	//   it is suitable for all the pages that we will
	//   create after the heap constructor is completed.
	//
	if ( NewSizeKey != NoSizeKey )
		{
		//
		//   Update the size key and the connections.
		//
		SizeKey = NewSizeKey;

		UpdateConnections
			( 
			NewFind,
			NewHeap,
			NewPages,
			NewParentCache 
			);
		}
	else
		{ Failure( "Bucket can't get a size key in UpdateBucket" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the allocation bucket.                                 */
    /*                                                                  */
    /********************************************************************/

BUCKET::~BUCKET( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\cache.hpp ===
#ifndef _CACHE_HPP_
#define _CACHE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Bucket.hpp"
#include "Find.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The allocation cache.                                          */
    /*                                                                  */
    /*   The memory allocation cache consists of two stacks.  The       */
    /*   first stack contains preallocated elements which are           */
    /*   available for use.  The second stack contains elements         */
    /*   which have been deallocated and are about to be recycled.      */
    /*                                                                  */
    /********************************************************************/

class CACHE : public BUCKET
    {
		//
		//   Private data.
		//
		//   A cache sits on top of a bucket and shields 
		//   it from being swamped by calls.  The 'Active'
		//   flag is set when the cache is active.  The
		//   'Stealing' flag indicates that deallocated
		//   memory can be stolen and reallocated.  The
		//   'ThreadSafe' flag indicates that locking is
		//   required.
		//
		BOOLEAN						  Active;
		BOOLEAN						  Stealing;
		BOOLEAN						  ThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   When we are collecting statistics we enable 
		//   the following variables.  The 'CacheFills' 
		//   count keeps track of the number of times
		//   the cache was filled from the bucket.  The
		//   'CacheFlushes' count keeps track of the 
		//   number of times the cache flushed deleted
		//   elements to the bucket.  The 'HighTide' count  
		//   keeps track the the highest number of outstanding
		//   allocations since the last "DeleteAll()'.  The 
		//   'HighWater' count keeps track of the maximum 
		//   number of allocations at any point.  The
		//   'InUse' counts the the current number of outstanding 
		//   allocations.
		//
		SBIT32						  CacheFills;
		SBIT32						  CacheFlushes;
		SBIT32						  HighTide;
		SBIT32						  HighWater;
		SBIT32						  InUse;
#endif

		//
		//   A cache can be controlled by the user.  The
		//   'CacheSize' controls the number of allocations
		//   that can be preallocated or queued for 
		//   deletion.  The 'NumberOfChildren' is a count
		//   of the number of caches that allocate space
		//   from this cache.
		//
		SBIT16						  CacheSize;
		SBIT16						  FillSize;
		SBIT16						  NumberOfChildren;

		//
		//   The cache consists of two stacks.  The
		//   'DeleteStack' contains elements that are 
		//   waiting to be deleted.  The 'NewStack' 
		//   contains elements waiting to be allocated.
		//
		ADDRESS_AND_PAGE			  *DeleteStack;
		VOID						  **NewStack;

		//
		//   The top of the deleted stack is kept in
		//   'TopOfDeleteStack' and the top of the new
		//   stack is kept in 'TopOfNewStack'.
		//
		SBIT32						  TopOfDeleteStack;
		SBIT32						  TopOfNewStack;

		//
		//   The 'Spinlock' is a fast lock employed to
		//   make the cache multi-threaded if 'ThreadSafe'
		//   is true.
		//   
		SPINLOCK					  Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The cacahe is a subset of the full haep interface
		//   a certain calls simply bypass it.  However, there
		//   are a few additional functions for cases where the
		//   cache needs to be notified of significant heap
		//   events.
		//
        CACHE
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewCacheSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize,
			BOOLEAN					  NewStealing,
			BOOLEAN					  NewThreadSafe
			);

		VOID *CreateDataPage( VOID );

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteAll( VOID );

		BOOLEAN DeleteDataPage( VOID *Address );

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( VOID );

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		BOOLEAN SearchCache( VOID *Address );

		BOOLEAN Truncate( VOID );

		VOID UpdateCache
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CACHE( VOID );

		//
		//   Public inline functions.
		//
		//   A cache just like its parent bucket is closely
		//   coupled to various other classes and provides
		//   then is vital information.
		//
		INLINE VOID ClaimCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE PAGE *FindChildPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetAllocationSize()-1))),
				(CACHE*) this
				); 
			}

		INLINE PAGE *FindParentPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetPageSize()-1))),
				ParentCache
				); 
			}

		INLINE SBIT16 GetCacheSize( VOID )
			{ return CacheSize; }

		INLINE SBIT32 GetNumberOfChildren( VOID )
			{ return NumberOfChildren; }

		INLINE VOID ReleaseCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE BOOLEAN Walk( SEARCH_PAGE *Details )
			{ return NewPage -> Walk( Details ); }
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Cache statistics.
		//
		//   A cache has a collection statistics which it
		//   uses to measure how it is doing.  It is possible
		//   to get access to this data for the purpose of
		//   outputing various reports.
		//
		INLINE SBIT32 GetCacheFills( VOID )
			{ return CacheFills; }

		INLINE SBIT32 GetCacheFlushes( VOID )
			{ return CacheFlushes; }

		INLINE SBIT32 GetHighWater( VOID )
			{ return HighWater; }
#endif

	private:
		//
		//   Private functions.
		//
		//   A cache is initially inactive.  If at least one
		//   allocation request is made it will spring into
		//   life, allocate any space needed and prepare itself
		//   for use.
		//
		VOID CreateCacheStacks( VOID );
#ifdef ENABLE_HEAP_STATISTICS

		VOID ComputeHighWater( SBIT32 Size );
#endif

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        CACHE( CONST CACHE & Copy );

        VOID operator=( CONST CACHE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\cache.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the maximum size of        */
    /*   the cache.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxCacheSize			  = ((2 << 16)-1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation cache and prepare it for use.  A       */
    /*   is inactive until the first request is received at which       */
    /*   time it springs into life.                                     */
    /*                                                                  */
    /********************************************************************/

CACHE::CACHE
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewCacheSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize,
		BOOLEAN						  NewStealing,
		BOOLEAN						  NewThreadSafe
		) :
		//
		//   Call the constructors for the contained classes.
		//
		BUCKET( NewAllocationSize,NewChunkSize,NewPageSize )
    {
	//
	//   We need to be very careful with the configuration
	//   information as it has come indirectly from the
	//   user and my be bogus.
	//
	if ( (NewCacheSize >= 0) && (NewCacheSize < MaxCacheSize) )
		{
		//
		//   Setup the cache and mark it as inactive.
		//
		Active = False;
		Stealing = NewStealing;
		ThreadSafe = NewThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		CacheFills = 0;
		CacheFlushes = 0;
		HighTide = 0;
		HighWater = 0;
		InUse = 0;
#endif

		CacheSize = ((SBIT16) NewCacheSize);
		FillSize = 1;
		NumberOfChildren = 0;

		//
		//   The stacks that may later contain allocations
		//   are set to zero just to be neat.
		//
		DeleteStack = NULL;
		NewStack = NULL;

		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	else
		{ Failure( "Cache size in constructor for CACHE" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create the cache stacks.                                       */
    /*                                                                  */
    /*   A cache is created on demand.  We do this when we get the      */
    /*   first allocation or deallocation request.                      */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::CreateCacheStacks( VOID )
	{
	//
	//   We allocate the cache stacks from the internal
	//   new page allocator if we have not done it already.
	//
	if ( DeleteStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(ADDRESS_AND_PAGE));

		DeleteStack = 
			((ADDRESS_AND_PAGE*) (NewPage -> NewCacheStack( Size )));
		}

	if ( NewStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(VOID*));

		NewStack = 
			((VOID**) (NewPage -> NewCacheStack( Size )));
		}

	//
	//   We can now activate the cache as long as we 
	//   were able to allocate both stacks.
	//
	if ( (NewStack != NULL ) && (DeleteStack != NULL ) )
		{
		//
		//   We have completed creating the cache so set
		//   various flags and zero various counters.
		//
		Active = True;

		//
		//   Setup the fill size.
		//
		FillSize = 1;

		//
		//   Zero the stack tops.
		//
		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new data page.                                        */
    /*                                                                  */
    /*   When we create a new page we also need to allocate some        */
    /*   memory to hold the associated data.                            */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::CreateDataPage( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Create a data page.
	//
	NewMemory = ((BUCKET*) this) -> New( True );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Compute high water.                                            */
    /*                                                                  */
    /*   Compute the high water mark for the current cache.             */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ComputeHighWater( SBIT32 Size )
	{
	//
	//   Update the usage statistics.
	//
	if ( (InUse += Size) > HighTide )
		{ 
		HighTide = InUse;
		
		if ( HighTide > HighWater )
			{ HighWater = HighTide; }
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   A memory deallocation cache.                                   */
    /*                                                                  */
    /*   We cache memory deallocation requests to improve performance.  */
    /*   We do this by stacking requests until we have a batch.         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   If recycling is allowed and the address is
		//   on the current page or a previous page and
		//   there is space on the new stack then put the
		//   element in the new stack for immediate reuse.
		//
		if 
				(
				(Stealing)
					&&
				(Address < GetCurrentPage())
					&&
				(TopOfNewStack < CacheSize)
				)
			{
			//
			//   The address is suitable for immediate
			//   reuse.  So put it on the stack of new
			//   elements.
			//
			NewStack[ (TopOfNewStack ++) ] = Address;

			Result = True;
			}
		else
			{
			REGISTER ADDRESS_AND_PAGE *Current = 
				(& DeleteStack[ TopOfDeleteStack ++ ]);

			//
			//   The address would best be deleted before
			//   being reused.
			//
			Current -> Address = Address;
			Current -> Page = Page;
			Current -> Version = Version;

			//
			//   When the delete stack is full we flush it.
			//
			if ( TopOfDeleteStack >= CacheSize )
				{
				AUTO SBIT32 Deleted;

				//
				//   Flush the delete stack.
				//
				Result = 
					(
					((BUCKET*) this) -> MultipleDelete
						(
						DeleteStack,
						& Deleted,
						TopOfDeleteStack 
						)
					);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				CacheFlushes ++;
				
				InUse += (TopOfDeleteStack - Deleted);
#endif

				//
				//   Zero the top of the stack.
				//
				TopOfDeleteStack = 0;
				}
			else
				{ Result = True; }
			}
		}
	else
		{
		//
		//   Delete the element.
		//
		Result = 
			(((BUCKET*) this) -> Delete( Address,Page,Version )); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	if ( Result )
		{ InUse --; }
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   The entire heap is about to be deleted under our feet.  We     */
    /*   need to prepare for this by disabling the cache as its         */
    /*   contents will disappear as well.                               */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::DeleteAll( VOID )
	{
	//
	//   Disable the cache if needed.
	//
	Active = False;
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Zero the statistics.
	//
	HighTide = 0;
	InUse = 0;
#endif

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Zero the top of stacks.
	//
	TopOfDeleteStack = 0;
	TopOfNewStack = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a data page.                                            */
    /*                                                                  */
    /*   Delete a data page that was associated with a smaller cache    */
    /*   so its space can be reused.                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::DeleteDataPage( VOID *Address )
	{
	AUTO SEARCH_PAGE Details;
	REGISTER BOOLEAN Result;
	REGISTER PAGE *Page;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Find the description of the data page we need to 
	//   delete and make sure it is valid.
	//
	Find -> ClaimFindShareLock();

	Page = FindParentPage( Address );

	if ( Page != NULL )
		{ Page = (Page -> FindPage( Address,& Details,False )); }

	Find -> ReleaseFindShareLock();

	//
	//   Delete the data page.
	//
	if ( Page != NULL )
		{ Result = (Page -> Delete( & Details )); }
	else
		{ Failure( "No data page in DeleteDataPage" ); }

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We have been asked to allocalte multiple
		//   new elements.  If it appears that we don't  
		//   have enough elements available but stealing 
		//   is allowed we can try raiding the deleted 
		//   stack.
		//
		if ( (Requested > TopOfNewStack) && (Stealing) )
			{
			while ( (TopOfDeleteStack > 0) && (TopOfNewStack < CacheSize) )
				{
				NewStack[ (TopOfNewStack ++) ] = 
					(DeleteStack[ (-- TopOfDeleteStack) ].Address);
				}
			}

		//
		//   We will allocate from the cache if requested 
		//   size is smaller than the number of available 
		//   elements.
		//
		if ( Requested <= TopOfNewStack )
			{
			REGISTER SBIT32 Count;

			//
			//   We need to copy the elements out of the
			//   cache into the callers array.
			//
			for ( Count=0;Count < Requested;Count ++ )
				{ Array[ Count ] = NewStack[ (-- TopOfNewStack) ]; }

			(*Actual) = Requested;

			Result = True;
			}
		else
			{
			REGISTER BUCKET *Bucket = ((BUCKET*) this);

			//
			//   We don't have enough elements in the cache 
			//   so we allocate directly from the bucket.
			//
			Result =
				(
				Bucket -> MultipleNew
					( 
					Actual,
					Array,
					Requested
					)
				);

			//
			//   We fill up the cache so we have a good 
			//   chance of dealing with any following 
			//   requests if it is less than half full.
			//
			if ( TopOfNewStack <= (CacheSize / 2) )
				{
				AUTO SBIT32 NewSize;
				REGISTER SBIT32 MaxSize = (CacheSize - TopOfNewStack);

				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   Bulk load the cache with new
				//   elements.
				//
				Bucket -> MultipleNew
					( 
					& NewSize, 
					& NewStack[ TopOfNewStack ],
					((FillSize < MaxSize) ? FillSize : MaxSize)
					);
#ifdef ENABLE_HEAP_STATISTICS

				CacheFills ++;
#endif
				TopOfNewStack += NewSize;
				}
			}
		}
	else
		{
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		Result = ((BUCKET*) this) -> MultipleNew
			( 
			Actual,
			Array,
			Requested
			);
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (*Actual) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We first try the stack for new allocations
		//   to see if there are any available elements.
		//
		if ( TopOfNewStack > 0 )
			{ NewMemory = (NewStack[ (-- TopOfNewStack) ]); }
		else
			{
			//
			//   When stealing is allowed we will recycle
			//   elements from the top of the deleted stack.
			//
			if ( (TopOfDeleteStack > 0) && (Stealing) )
				{ NewMemory = (DeleteStack[ (-- TopOfDeleteStack) ].Address); }
			else
				{
				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   We need to bulk load some new  
				//   memory from the heap.
				//
				if 
						( 
						((BUCKET*) this) -> MultipleNew
							( 
							& TopOfNewStack,
							NewStack,
							FillSize
							) 
						)
					{
					//
					//   Update the statistics and return
					//   the top element on the stack.
					//
#ifdef ENABLE_HEAP_STATISTICS
					CacheFills ++;
#endif
					NewMemory = NewStack[ (-- TopOfNewStack) ]; 
					}
				else
					{
					//
					//   Update the statistics and fail
					//   the request for memeory.
					//
					NewMemory = ((VOID*) AllocationFailure);
					}
				}
			}
		}
	else
		{ 
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		NewMemory = ((BUCKET*) this) -> New( False ); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	//
	//   Prefetch the first cache line if we are running
	//   a Pentium III or better.
	//
	Prefetch.L1( ((CHAR*) NewMemory),1 );

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation for non-standard sizes.                      */
    /*                                                                  */
    /*   A non standard sized allocation simply by-passes the cache     */
    /*   but it still needs to hold the lock to prevent failure on      */
    /*   SMP systems.                                                   */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( BOOLEAN SubDivided,SBIT32 NewSize )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Allocate a non-standard sized block.
	//
	NewMemory = ((BUCKET*) this) -> New( SubDivided,NewSize );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ReleaseSpace( SBIT32 MaxActivePages )
	{
	//
	//   When there is a potential for multiple threads 
	//   we claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Release the free space from the backet.
	//
	((BUCKET*) this) -> ReleaseSpace( MaxActivePages );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search the cacahe for an allocation.                           */
    /*                                                                  */
    /*   We sometimes need to search the cache to see if an             */
    /*   allocation is currently in the cacahe awaiting allocation      */
    /*   or release.                                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::SearchCache( VOID *Address )
	{
	REGISTER BOOLEAN Result = False;

	//
	//   We check to see if the cache is active.
	//
	if ( Active )
		{
		//
		//   When there is a potential for multiple 
		//   threads we claim the cache lock.
		//
		ClaimCacheLock();

		//
		//   We check to see if the cache is still 
		//   active.
		//
		if ( Active )
			{
			REGISTER SBIT32 Count;

			//
			//   Search the allocated cache.
			//
			for ( Count=(TopOfNewStack-1);Count >= 0;Count -- )
				{ 
				if ( Address == NewStack[ Count ] )
					{
					Result = True;
					break;
					}
				}

			//
			//   If it has not been found yet then try
			//   the deleted cache.
			//
			if ( ! Result )
				{
				//
				//   Search the deleted cache.
				//
				for ( Count=(TopOfDeleteStack-1);Count >= 0;Count -- )
					{ 
					if ( Address == DeleteStack[ Count ].Address )
						{
						Result = True;
						break;
						}
					}
				}
			}

		//
		//   Release any lock we may have claimed earlier.
		//
		ReleaseCacheLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   Flush the cache to release the maximum amount of space back    */
    /*   to the operating system.  This is slow but may be very         */
    /*   valuable in some situations.                                   */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Truncate( VOID )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Disable the cache if needed.
	//
	Active = False;

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Flush any elements in the delete cache.
	//   We do this now because we need to use 
	//   the delete cache below.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}
	
	//
	//   Flush any elements in the new cache by
	//   copying them over to the delete cache
	//   and adding the additional information
	//   required.
	//
	if ( TopOfNewStack > 0 )
		{
		//
		//   We need to find the data page for each  
		//   allocation we have in the new cache.
		//   Claim the lock here to make things a
		//   little more efficient.
		//
		Find -> ClaimFindShareLock();

		//
		//   We copy each allocation across and 
		//   add the associated page information.
		//
		for ( TopOfNewStack --;TopOfNewStack >= 0;TopOfNewStack -- )
			{
			REGISTER VOID *Address = (NewStack[ TopOfNewStack ]);
			REGISTER PAGE *Page = (ParentCache -> FindChildPage( Address ));

			//
			//   You would think that any memory in the
			//   new cache had to be valid.   Well it
			//   does except in the case when we have
			//   'Recycle' set and somebody does a double
			//   delete on a valid heap address.
			//
			if ( Page != NULL )
				{
				REGISTER ADDRESS_AND_PAGE *Current = 
					(& DeleteStack[ TopOfDeleteStack ++ ]);

				//
				//   We need to find the allocation page
				//   where the memory was allocated from
				//   so we can delete it.
				//
				Current -> Address = Address;
				Current -> Page = Page;
				Current -> Version = Page -> GetVersion();
				}
			else
				{ 
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				InUse ++;

#endif
				Result = False; 
				}
			}

		//
		//   Release the lock.
		//
		Find -> ReleaseFindShareLock();
		}

	//
	//   Flush the delete cache again to delete
	//   any new elements that we added to it
	//   above.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data it needs.                                  */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::UpdateCache
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   Notify the parent cache that it has a new
	//   child.
	//
	if ( NewParentCache != ((CACHE*) GlobalRoot) )
		{ NewParentCache -> NumberOfChildren ++; }

	//
	//   Update the allocation bucket.
	//
	UpdateBucket
		( 
		NewFind,
		NewHeap,
		NewPages,
		NewParentCache 
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the cache and ensure it is disabled.                   */
    /*                                                                  */
    /********************************************************************/

CACHE::~CACHE( VOID )
	{
	if ( Active )
		{ Failure( "Cache active in destructor for CACHE" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\find.hpp ===
#ifndef _FIND_HPP_
#define _FIND_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "List.hpp"
#include "Page.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Find a memory allocation.                                      */
    /*                                                                  */
    /*   When a memory allocation is released all we are given is .     */
    /*   the allocation address.  This is not very helpful as the       */
    /*   allocation information is not stored relative to this          */
    /*   address.  Instead we use a hash table to map the allocation    */
    /*   address to the allocation information.                         */
    /*                                                                  */
    /********************************************************************/

class FIND : public ENVIRONMENT, public COMMON
    {
		//
		//   Private type specifications.
		//
		//   We need to do a recursive search in the find 
		//   table in order to locate the associated page
		//   from an address.  As this is expensive there
		//   is also a cache that slaves common translations
		//   to improve performance.
		//
		typedef struct
			{
			VOID					  *Address;
			PAGE					  *Page;
#ifdef DEBUGGING
			SBIT32					  Version;
#endif
			}
		LOOK_ASIDE;

		//
		//   Private data.
		//
		//   All the page descriptions are stored in the 
		//   hash table so they can be quickly found.  The
		//   key is the address of the first byte on the
		//   page.  The 'MaxHash' is the number of elements
		//   in the hash table and is always a power of two.
		//   The 'HashMask' is a bit mask to remove any 
		//   unwanted part of the hash key.  The 'HashShift'
		//   is the number of bits required to shift and is
		//   as a substitute for divide.  The 'Resize' flag
		//   indicates whether the hash table is permitted 
		//   to grow.
		//
		SBIT32						  MaxHash;

		SBIT32						  HashMask;
		SBIT32						  HashShift;
		BOOLEAN						  Resize;

		//
		//   The hash table allows addresses to be mapped to
		//   page descriptions quickly.  Nonetheless, it is 
		//   not fast enough.  To enhance performance a look
		//   aside cache slaves the hottest translations.  The
		//   'MaxLookAside' is the number of elements in the
		//   cache.  The 'MaxAddressMask' is a mask that removes 
		//   low order bits of an address and represents the
		//   span of each cache entry.  The 'LookAsideActions'
		//   is a simple count of requests to the cache.  The
		//   'LookAsideMask' and 'LookAsideShift' parallel the
		//   fields above in the hash table.  The 'LookAsideThreshold'
		//   determines at what point the cache will become 
		//   active.  The 'ThreadSafe' flag indicates whether
		//   locking is required.
		//
		SBIT32						  MaxLookAside;

		BIT32						  MaxAddressMask;
		BIT32						  MinAddressMask;

		SBIT32						  LookAsideActions;
		SBIT32						  LookAsideMask;
		SBIT32						  LookAsideShift;
		SBIT32						  LookAsideThreshold;
		BOOLEAN						  ThreadSafe;

		//
		//   When a request is made to translate an address to
		//   a page description the cache is the first port of
		//   call.  If the translation is not found then the
		//   hash table is tried.  The 'Hash' points to the hash
		//   table.  The 'LookAside' points to the lookaside
		//   hash table.  The 'Rockall' points to the external API
		//   to give access to the low level external allocation
		//   functions.  
		//
		LIST						  *Hash;
		LOOK_ASIDE					  *LookAside;
		ROCKALL						  *Rockall;

		//
		//   The translation of addresses to page descriptions
		//   is very common.  So care has been taken to ensure
		//   it is not a bottleneck when locking is enabled.  The
		//   'Sharelock' is a fast reader/writer lock and is used
		//   almost all the time.  The 'Spinlock' is an exclusive
		//   lock and is only used when the 'Hash' and 'LookAside'
		//   tables are resized.
		//
		PREFETCH					  Prefetch;
		SHARELOCK					  Sharelock;
		SPINLOCK					  Spinlock;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   There is a concern with any hash table about
		//   poor hashing keys and poor performance.  The
		//   statistics monitor various data so as to allow
		//   the performance metrics to be monitored.  The
		//   'Fills' counter keeps track of the number of
		//   cache fills.  The 'Hits' counter monitors the
		//   number of cache hits.  The 'MaxPages' counter
		//   is the high water mark of hash table entries.
		//   The 'MaxTests' is the max number of compares 
		//   done while searching an entry.  The 'Misses' 
		//   counter keeps track of the number of cache misses.
		//   The 'Scans' counter monitors the number of hash
		//   table searches.  The 'Tests' counter is the 
		//   total number of tests performed while searching
		//   for entries.
		//
		SBIT32						  Fills;
		SBIT32						  Hits;
		SBIT32						  MaxPages;
		SBIT32						  MaxTests;
		SBIT32						  Misses;
		SBIT32						  Scans;
		SBIT32						  Tests;
#endif
		SBIT32						  Used;
#ifndef ENABLE_RECURSIVE_LOCKS

		//
		//   Static private data.
		//
		//   It is not uncommon for developers to have some
		//   form of bias.  I dislike recursive locks so here
		//   I introduce a TLS value to indicate whether the
		//   current thread has a global lock.  If so all
		//   locking in the other classes is disabled.
		//
		STATIC THREAD_LOCAL_STORE	  LockCount;
#endif

   public:
		//
		//   Public functions.
		//
		//   The translation functionality supplied by this
		//   class is only applicable after an allocation
		//   has been made.  Hence, all of the APIs supported
		//   relate to the need to translate an allocation
		//   address to the host page description.
		//
        FIND
			( 
			SBIT32					  NewMaxHash,
			SBIT32					  NewMaxLookAside,
			SBIT32					  NewFindThreshold,
			ROCKALL					  *NewRockall,
			BOOLEAN					  NewResize,
			BOOLEAN					  NewThreadSafe 
			);

		BOOLEAN Delete( VOID *Address,CACHE *ParentCache );

		VOID DeleteFromFindList( PAGE *Page );

		BOOLEAN Details
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		PAGE *FindPage( VOID *Address,CACHE *ParentCache );

		VOID InsertInFindList( PAGE *Page );

		BOOLEAN KnownArea( VOID *Address,CACHE *ParentCache );

		VOID ReleaseFindShareLockAndUpdate
			( 
			VOID					  *Address,
			PAGE					  *Page,
			SBIT32					  Version 
			);

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		VOID UpdateFind
			( 
			BIT32					  NewMaxAddressMask,
			BIT32					  NewMinAddressMask
			);

        ~FIND( VOID );

		//
		//   Public inline functions.
		//
		//   Although this class is perhaps the most self
		//   contained.  Nonetheless, there is still lots
		//   of situations when other classes need to 
		//   interact and get information about the current
		//   situation.
		//
		INLINE VOID ClaimFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimExclusiveLock(); } 
			}

		INLINE VOID ClaimFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimShareLock(); } 
			}

		INLINE VOID DeleteAll( VOID )
			{ LookAsideActions = 0; }

		INLINE VOID ReleaseFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseExclusiveLock(); } 
			}

		INLINE VOID ReleaseFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseShareLock(); } 
			}

		//
		//   Static public inline functions.
		//
		//   There is a strong case for removing the lock
		//   count functionality from this class.  However,
		//   as it consists of a single declaration and the
		//   following inline functions I have not been
		//   driven to fix this yet.  Maybe some day. 
		//
#ifndef ENABLE_RECURSIVE_LOCKS
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) - 1))
				);
			}

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return ((SBIT32) LockCount.GetPointer()); }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) + 1))
				);
			}
#else
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return 0; }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ /* void */ }
#endif

#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Public inline statistic functions.
		//
		//   The statistics are typically provided in 
		//   debug builds to provide good information  
		//   about allocation patterns.  
		//
		INLINE SBIT32 AverageHashLength( VOID )
			{ return (Tests / ((Scans > 0) ? Scans : 1)); }

		INLINE SBIT32 CacheFills( VOID )
			{ return Fills; }

		INLINE SBIT32 CacheHits( VOID )
			{ return Hits; }

		INLINE SBIT32 CacheMisses( VOID )
			{ return Misses; }

		INLINE SBIT32 MaxHashLength( VOID )
			{ return MaxTests; }

		INLINE SBIT32 MaxHashSize( VOID )
			{ return MaxHash; }

		INLINE SBIT32 MaxLookAsideSize( VOID )
			{ return MaxLookAside; }

		INLINE SBIT32 MaxUsage( VOID )
			{ return ((MaxPages * 100) / MaxHash); }

		INLINE SBIT32 TotalScans( VOID )
			{ return Scans; }
#endif

	private:
		//
		//   Private functions.
		//
		//   Although the hashed lookup functionality is 
		//   externally visable the look aside cache is 
		//   hidden from view along with the ability to
		//   resize the hash table.
		//
		BOOLEAN FindLookAside( VOID *Address,PAGE **Page );

		VOID ResizeHashTable( VOID );

		//
		//   Private inline functions.
		//
		//   Although I am not keen on code in the headers
		//   certain functions are so small or so hot that
		//   I have to submit to the desire to do it. 
		//
		INLINE VOID ChangeToExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ChangeSharedLockToExclusiveLock(); } 
			}

		INLINE LIST *FindHashHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& Hash[ ((Value >> HashShift) & HashMask) ]); 
			}

		INLINE LOOK_ASIDE *FindLookAsideHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& LookAside[ ((Value >> LookAsideShift) & LookAsideMask) ]); 
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND( CONST FIND & Copy );

        VOID operator=( CONST FIND & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\connections.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Connections.hpp"
#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   There are a variety of connections that need to be made        */
    /*   after all the classes are ready for use.  However, we          */
    /*   initially zero all these connection pointers until we are      */
    /*   ready to link everything.                                      */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the connections.                                        */
    /*                                                                  */
    /*   When we create an allocator there is some information that     */
    /*   is not available.  Here we update the connection information   */
    /*   so we can locate the correct instances of various other        */
    /*   classes.                                                       */
    /*                                                                  */
    /********************************************************************/

VOID CONNECTIONS::UpdateConnections
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   We typically only need to update the connections once
	//   but in some situations multiple updates can occur.  If
	//   this is the case we carefully check the update is 
	//   consistent with the previous update.
	//
	if ( ! Active )
		{
		//
		//   We now have the information we need to update the 
		//   connections.
		//
		Active = True;
		Find = NewFind;
		Heap = NewHeap;
		NewPage = NewPages;
		ParentCache = NewParentCache;
		}
	else
		{
		//
		//   Nasty, we have already updated the connections once.  
		//   Since we have been called again we know this node 
		//   must be shared between two heaps.  We can deal with  
		//   this as long as selected pointers are the same.
		//
		if 
				(
				(Find != NewFind)
					||
				(NewPage != NewPages)
					||
				(ParentCache != NewParentCache)
				)
			{ Failure( "Sharing violation in UpdateConnections" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the connections.                                       */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::~CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\find.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the size of the hash       */
    /*   table and other related features.                              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinHash				  = 1024;
CONST SBIT32 MinHashSpace			  = (100/25);
CONST SBIT32 MinLookAside			  = 128;

CONST BIT32 NoAddressMask			  = ((BIT32) -1);
CONST SBIT32 NoCacheEntry			  = -1;

#ifndef ENABLE_RECURSIVE_LOCKS
    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

THREAD_LOCAL_STORE FIND::LockCount;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create the hash table and initialize it ready for use. The     */
    /*   configuration information supplied from the parameters needs   */
    /*   to be carefully checked as it has come indirectly from the     */
    /*   user and may be bogus.                                         */
    /*                                                                  */
    /********************************************************************/

FIND::FIND
		( 
		SBIT32						  NewMaxHash,
		SBIT32						  NewMaxLookAside,
		SBIT32						  NewFindThreshold,
		ROCKALL						  *NewRockall,
		BOOLEAN						  NewResize, 
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 AlignMask = (NewRockall -> NaturalSize()-1);

	//
	//   We need to make sure that the size of the hash table
	//   makes sense.  The hash table size needs to be a reasonable
	//   size (say 1k or larger) and a power of 2 (so we don't need
	//   to do any divides).
	//   
	if 
			(
			PowerOfTwo( (AlignMask+1) )
				&&
			(NewFindThreshold >= 0 )
				&&
			(NewMaxHash >= MinHash) 
				&&
			(ConvertDivideToShift( NewMaxHash,& HashMask ))
				&& 
			(NewMaxLookAside >= MinLookAside) 
				&& 
			(ConvertDivideToShift( NewMaxLookAside,& LookAsideMask ))
			)
		{
		REGISTER SBIT32 HashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   Set up the hash table.
		//
		MaxHash = NewMaxHash;

		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);
		Resize = NewResize;

		//
		//   Set up the lookaside table.
		//
		MaxLookAside = NewMaxLookAside;

		MaxAddressMask = NoAddressMask;
		MinAddressMask = NoAddressMask;

		LookAsideActions = 0;
		LookAsideShift = (32-LookAsideMask);
		LookAsideMask = ((1 << LookAsideMask)-1);
		LookAsideThreshold = NewFindThreshold;

		ThreadSafe = NewThreadSafe;

		//
		//   Create some space for the find table and the 
		//   look aside table.
		//
		Hash = ((LIST*) NewRockall -> NewArea( AlignMask,TotalSize,False ));
		LookAside = ((LOOK_ASIDE*) & Hash[ MaxHash ]);
		Rockall = NewRockall;

		//
		//   If the memory allocation request for the hash
		//   table fails we are doomed.  If it works we need
		//   to call the constructor for each linked list
		//   head node.
		//
		if ( Hash != ((LIST*) AllocationFailure) )
			{
			REGISTER SBIT32 Count;

			//
			//   Call the constructor for each hash table
			//   linked list header.
			//
			for ( Count=0;Count < NewMaxHash;Count ++ )
				{ PLACEMENT_NEW( & Hash[ Count ],LIST ); }

			//
			//   Zero the look aside structures.  We need
			//   to do this to ensure they do not match a
			//   valid allocation address later.
			//
			for ( Count=0;Count < MaxLookAside;Count ++ )
				{
				REGISTER LOOK_ASIDE *Current = & LookAside[ Count ];

				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Zero the statistics information.
			//
			Fills = 0;
			Hits = 0;
			MaxPages = 0;
			MaxTests = 0;
			Misses = 0;
			Scans = 0;
			Tests = 0;
#endif
			Used = 0;
			}
		else
			{ Failure( "Create hash fails in constructor for FIND" ); }
		}
	else
		{ Failure( "Hash table size in constructor for FIND" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a particular memory allocation.  All         */
    /*   we have is an address.  We use this to find the largest        */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation we need to delete.                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Delete( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the details we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,NULL,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we put the deleted 
	//   element back in the associated cache.
	//
	if ( Page != ((PAGE*) NULL) )
 		{
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Original = (Page -> GetVersion());

		//
		//   Prefetch the class data if we are running a
		//   Pentium III or better with locks.  We do this
		//   because prefetching hot SMP data structures
		//   really helps.  However, if the structures are
		//   not shared (i.e. no locks) then it is worthless
		//   overhead.
		//
		if ( ThreadSafe )
			{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

		//
		//   Release the lock if we claimed it earlier and
		//   update the lookaside if needed.
		//
		if ( Update )
			{ ReleaseFindShareLockAndUpdate( Address,Page,Original ); }
		else
			{ ReleaseFindShareLock(); }

		//
		//   We have found the associated page description
		//   so pass the delete request along to the cache
		//   and get out of here.
		//
		return (Cache -> Delete( Address,Page,Original ));
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock();

		return False; 
		}
  }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an item from the find table.                            */
    /*                                                                  */
    /*   We need to delete page from the find list.  We expect          */
    /*   this to take quite a while as multiple threads can be          */
    /*   using this class at the same time.                             */
    /*                                                                  */
    /********************************************************************/

VOID FIND::DeleteFromFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   hash and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Delete the page from the hash table.
	//
	Page -> DeleteFromFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various look aside entries
		//   and delete any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we delete an entry from the hash table
		//   the lookaside is potentially corrupt.  So we 
		//   need to delete any look aside entries relating
		//   to this page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Delete the look aside entry if it is stale.
			//
			if ( Segment == Current -> Address )
				{
				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
			}
		}

	//
	//   Update the statistics.
	//
	Used --;

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Details
		( 
		VOID						  *Address,
		SEARCH_PAGE					  *Details,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the deatils we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}
	else
		{
		//
		//   We may need to provide the all the details of the
		//   allocation for some reason.
		//
		if ( Details != NULL )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we extract the 
	//   information we want.
	//
	if ( Result = (Page != ((PAGE*) NULL)) )
 		{
		//
		//   Compute the size.  We would normally expect
		//   this to be the cache size.  However, there
		//   are some weird pages that sometimes have
		//   other sizes.
		//
		(*Size) = (Page -> ActualSize());
		}

	//
	//   Release the lock if we claimed it earlier and 
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Address,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find in the look aside.                                        */
    /*                                                                  */
    /*   We need to find a particular page in the look aside.  So we    */
    /*   try a simple look up (no lists or chains).                     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::FindLookAside( VOID *Address,PAGE **Page )
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Address );

		//
		//   We have hashed to a lookaside slot.  Maybe
		//   it contains what we want or maybe not.
		//
		if ( Address == Current -> Address )
			{
#ifdef DEBUGGING
			if ( Current -> Version == (Current -> Page -> GetVersion()) )
				{
#endif
				//
				//   We hit the lookaside and the 
				//   contents are valid.
				//
				(*Page) = (Current -> Page);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Hits ++;
#endif

				return True;
#ifdef DEBUGGING
				}
			else
				{ Failure( "Deleted page in FindLookAside" ); }
#endif
			}
		}
	else
		{
		//
		//   We update number of times we tried to
		//   use the lookaside and it was disabled.  
		//   After a while this will lead to the 
		//   lookaside being enabled.
		//
		LookAsideActions ++; 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   We missed the lookaside so update the 
	//   statistics to reflect our misfortune.
	//
	Misses ++;
#endif

	return False; 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find a page.                                                   */
    /*                                                                  */
    /*   We need to find a particular page in the hash table.  So we    */
    /*   scan along the associated linked list looking for a match.     */
    /*                                                                  */
    /********************************************************************/

PAGE *FIND::FindPage( VOID *Address,CACHE *ParentCache )
    {
#ifdef ENABLE_HEAP_STATISTICS
	REGISTER SBIT32 Cycles = 0;
	REGISTER PAGE *Result = NULL;
#endif
	REGISTER PAGE *Page;

	//
	//   Find the associated hash bucket and then walk
	//   along the linked list for this looking for
	//   the correct page description.
	//
	for 
			( 
			Page = PAGE::FirstInFindList( FindHashHead( Address ) );
			! Page -> EndOfFindList();
			Page = Page -> NextInFindList()
			)
		{
#ifdef ENABLE_HEAP_STATISTICS
		//
		//   Count the number of iterations in when we
		//   are recording statistics so we can calculate
		//   the average chain length.
		//
		Cycles ++;

#endif
		//
		//   We can identify the the target page by two key
		//   characteristics.  These are the start address and
		//   the parent page.   Although we may have sub-divided
		//   a page into various chunks each chunk will have
		//   a different parent (although its start address
		//   may sometimes be the same).
		//
		if 
				( 
				(Address == (Page -> GetAddress())) 
					&& 
				(ParentCache == (Page -> GetParentPage()))
				)
			{
#ifdef ENABLE_HEAP_STATISTICS
			//
			//   We have found the target page.  So return it
			//   to the caller.
			//
			if ( Page -> ValidPage() )
				{
				Result = Page;
				break;
				}
			else
				{ Failure( "Deleted page in FindPage" ); }
#else
			return Page;
#endif
			}
		}

#ifdef ENABLE_HEAP_STATISTICS
	//
	//   When we are in statistics mode we need to update the
	//   information so we can output it at the end of the
	//   run.
	//
	if ( MaxTests < Cycles )
		{ MaxTests = Cycles; }

	Tests += Cycles;

	Scans ++;

	return Result;
#else
	return NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Insert an item into the find table.                            */
    /*                                                                  */
    /*   We need to insert a new page into the find table.  We expect   */
    /*   this to take quite a while as multiple threads can be using    */
    /*   this class at the same time.                                   */
    /*                                                                  */
    /********************************************************************/

VOID FIND::InsertInFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   find table and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Insert a new page into the find table.
	//
	Page -> InsertInFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various lookaside entries
		//   and update any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we add an entry from the find table
		//   the lookaside is potentially corrupt.  So we 
		//   need to update any lookaside entries relating
		//   to the page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Add the new page to the lookaside as we
			//   expect it to get hit pretty soon one way
			//   or another.
			//
			Current -> Address = Segment;
			Current -> Page = Page;
#ifdef DEBUGGING
			Current -> Version = Page -> GetVersion();
#endif
			}
		}

	//
	//   Update the statistics and resize the find
	//   table if it is over 75% full.
	//
	if ( ((++ Used) + (MaxHash / MinHashSpace)) > MaxHash )
		{ ResizeHashTable(); }
#ifdef ENABLE_HEAP_STATISTICS

	if ( Used > MaxPages )
		{ MaxPages = Used; }
#endif

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out if it is known to the current heap.             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::KnownArea( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Find out if the address belongs to this heap
	//   or any other heap of which we are aware (i.e.
	//   when single image is active).
	//
	Page = (ParentCache -> FindParentPage( Address ));

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindShareLock();

	return (Page != ((PAGE*) NULL));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock and update.                              */
    /*                                                                  */
    /*   We have been asked to insert a page into the lookaside.        */
    /*   We assume the caller already has a share lock which we         */
    /*   release when we are finished.                                  */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ReleaseFindShareLockAndUpdate
		( 
		VOID						  *Address,
		PAGE						  *Page,
		SBIT32						  Version
		)
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		//
		//   Claim an exclusive lock so we can update the 
		//   lookaside as needed.
		//
		ChangeToExclusiveLock();

#ifdef DEBUGGING
		if ( Page -> ValidPage() )
			{
#endif
			if ( Version == (Page -> GetVersion()) )
				{
				REGISTER LONG Base = (((LONG) Address) & ~MinAddressMask);
				REGISTER VOID *Segment = ((VOID*) Base);
				REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Segment );

				//
				//   Overwrite any existing information.
				//
				Current -> Address = Segment;
				Current -> Page = Page;
#ifdef DEBUGGING
				Current -> Version = Page -> GetVersion();
#endif
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Fills ++;
#endif
				}
#ifdef DEBUGGING
			}
		else
			{ Failure( "Deleted page in ReleaseFindShareLockAndUpdate" ); }
#endif

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock(); 
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the find table.                                         */
    /*                                                                  */
    /*   We need to grow the hash table as it appears to be a little    */
    /*   small given the number of pages that have been created.        */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ResizeHashTable( VOID )
    {
	AUTO SBIT32 NewHashMask;
	AUTO SBIT32 NewLookAsideMask;

	//
	//   When we need to resize the hash table it is a
	//   straight race.  The first thread to claim the
	//   lock gets to do the work.  Everyone else just
	//   exits.
	//
	if ( (Resize) && (Spinlock.ClaimLock(0)) )
		{
		REGISTER SBIT32 AlignMask = (Rockall -> NaturalSize()-1);
		REGISTER SBIT32 NewMaxHash = (MaxHash * ExpandStore);
		REGISTER SBIT32 NewMaxLookAside = (MaxLookAside * ExpandStore);
		REGISTER SBIT32 NewHashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 NewLookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 NewTotalSize = (NewHashSize + NewLookAsideSize);
		REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   It is actually possible for a thread to get
		//   delayed for so long that it thinks the hash 
		//   table still needs to be resized long after the 
		//   work has been completed.  Additionally, we want
		//   to make sure that all the new values are sane.
		//
		if 
				(
				PowerOfTwo( (AlignMask+1) )
					&&
				(NewMaxHash > 0)
					&&
				(ConvertDivideToShift( NewMaxHash,& NewHashMask ))
					&&
				(NewMaxLookAside > 0)
					&& 
				(ConvertDivideToShift( NewMaxLookAside,& NewLookAsideMask ))
					&&
				((Used + (MaxHash / MinHashSpace)) > MaxHash)
				)
			{
			REGISTER LIST *NewHash;
			REGISTER LOOK_ASIDE *NewLookAside;

			//
			//   We have been picked as the victim who
			//   needs to resize the hash table.  We are
			//   going to call the external allocator 
			//   to get more memory.  As we know this is 
			//   likely to to nail us we drop the lock to 
			//   allow other threads to continue.
			//
			ReleaseFindExclusiveLock();

			//
			//   We know that allocating a new table and 
			//   initializing it is going to take ages.
			//   Well at least everyone else gets to carry
			//   on in the mean time.
			//
			NewHash = 
				((LIST*) Rockall -> NewArea( AlignMask,NewTotalSize,False ));

			NewLookAside = 
				((LOOK_ASIDE*) & NewHash[ NewMaxHash ]);

			//
			//   If the memory allocation request for the hash
			//   table fails we exit and try again later. 
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;

				//
				//   Call the constructor for each hash table
				//   linked list header.
				//
				for ( Count=0;Count < NewMaxHash;Count ++ )
					{ PLACEMENT_NEW( & NewHash[ Count ],LIST ); }

				//
				//   Zero the look aside structure.
				//
				for ( Count=0;Count < NewMaxLookAside;Count ++ )
					{
					REGISTER LOOK_ASIDE *Current = & NewLookAside[ Count ];

					Current -> Address = ((VOID*) NoCacheEntry);
					Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
					Current -> Version = ((SBIT32) NoCacheEntry);
#endif
					}
				}

			//
			//   Claim an exclusive lock so we can resize  
			//   the hash table.
			//
			ClaimFindExclusiveLock();

			//
			//   If we have allocated the new find table
			//   we can now rehash the existing entries.
			//   If not we are out of here.
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;
				REGISTER SBIT32 MaxOldHash = MaxHash;
				REGISTER LIST *OldHash = Hash;

				//
				//   Update the control information 
				//   for the new hash table.
				//
				MaxHash = NewMaxHash;
				HashShift = (32-NewHashMask);
				HashMask = ((1 << NewHashMask)-1);

				MaxLookAside = NewMaxLookAside;
				LookAsideShift = (32-NewLookAsideMask);
				LookAsideMask = ((1 << NewLookAsideMask)-1);

				Hash = NewHash;
				LookAside = NewLookAside;

				//
				//   Delete all the existing records
				//   from the old hash table and insert
				//   them into the new hash table.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{
					REGISTER LIST *Current = & OldHash[ Count ];

					//
					//   Walk along each hash bucket 
					//   deleting the records and inserting
					//   them into the new hash table.
					//
					while ( ! Current -> EndOfList() )
						{
						REGISTER PAGE *Page = PAGE::FirstInFindList( Current );
						REGISTER VOID *Address = (Page -> GetAddress());

						Page -> DeleteFromFindList( Current );

						Page -> InsertInFindList( FindHashHead( Address ) );
						}
					}

				//
				//   Time to do more operating system work
				//   so lets drop the lock again.
				//
				ReleaseFindExclusiveLock();

				//
				//   Delete all the list heads and return the
				//   original allocation to the operating system.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{ PLACEMENT_DELETE( & OldHash[ Count ],LIST ); }

				//
				//   Deallocate the old extent.
				//
				Rockall -> DeleteArea( ((VOID*) OldHash),TotalSize,False );

				//
				//   We are finished so reclaim the lock
				//   so we can exit.
				//
				ClaimFindExclusiveLock();
				}
			else
				{ Resize = False; }
			}

		Spinlock.ReleaseLock();
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the find table.                                         */
    /*                                                                  */
    /*   We need to update the find table with certain information      */
    /*   to ensure it is used correctly and consistently.               */
    /*                                                                  */
    /********************************************************************/

VOID FIND::UpdateFind( BIT32 NewMaxAddressMask,BIT32 NewMinAddressMask )
    {
	//
	//   When we have a single heap image all the 'TopCache' sizes
	//   must be the same.
	//
	if 
			( 
			(MaxAddressMask == NoAddressMask) 
				|| 
			(MaxAddressMask == NewMaxAddressMask) 
			)
		{
		//
		//   If we need to be thread safe then claim a sharable lock
		//   on the hash table to stop it being changed under our feet.
		//
		ClaimFindExclusiveLock();

		//
		//   Update the max address mask if it is not the current
		//   value but yet consistent.
		//
		MaxAddressMask = NewMaxAddressMask;

		//
		//   Update the address mask is the new heap has a smaller
		//   parent than all of the other heaps.
		//
		if ( MinAddressMask > NewMinAddressMask )
			{ MinAddressMask = NewMinAddressMask; }

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ Failure( "Different 'TopCache' sizes with 'SingleImage'" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER VOID *Memory = (*Address);
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   When the address is null we need to set up the heap
	//   walk.  In all other cases we just extract the next
	//   allocation in the list.
	//
	if ( Memory != NULL )
		{
		AUTO SEARCH_PAGE Details;

		//
		//   Lets try the lookaside table.  There is a pretty
		//   good chance that we will have the details we need 
		//   already in the cache.  If not we need to find it
		//   the hard way.  During the process we add the mapping
		//   into the lookaside for next time.
		//
		if
				(
				Update =
					( 
					! FindLookAside
						( 
						((VOID*) (((LONG) Memory) & ~MinAddressMask)),
						& Page 
						) 
					)
				)
			{
			//
			//   Find the allocation page and get the details of entry.
			//   We do this by finding the parent of the top cache.
			//   We  know that this is the global root and will find
			//   the correct page even if it is on another heap (as
			//   long as the find table is globally shared).
			//
			Page = (ParentCache -> FindParentPage( Memory ));
			}

		//
		//   We now compute all the details relating to the address
		//   so we can find any subsequent allocation.
		//
		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Memory,& Details,True )); }

		//
		//   We may have failed to find the address  .If so
		//   we simply fail the call.  If not we find the next
		//   allocation in the heap.
		//
		if ( Result = ((Page != ((PAGE*) NULL)) && (Details.Found)) )
 			{
			//
			//   We need to walk the heap to get te details
			//   of the next allocation.
			//
			if ( Result = (Page -> Walk( & Details )) )
				{
				REGISTER BIT32 AllocationBit =
					((*Details.VectorWord) & Details.AllocationMask);

				(*Active) = (AllocationBit != 0);
				(*Address) = Details.Address;
				(*Size) = (Details.Page -> ActualSize());

				//
				//   If we are considering putting something
				//   in the lookaside lets make sure that
				//   we will get to hit the cache entry at
				//   least once.  If not lets forget putting
				//   it in the cache.
				//
				if ( Update )
					{
					Update =
						(
						(((LONG) Memory) & ~MinAddressMask)
							==
						(((LONG) Details.Address) & ~MinAddressMask)
						);
					}
				}
			}
		}
	else
		{
		AUTO SEARCH_PAGE Details;

		//
		//   We start a heap walk by setting the initial 
		//   address to the value null.
		//
		Details.Address = NULL;
		Details.Cache = ParentCache;
		Details.Page = NULL;

		Page = NULL;
		Update = False;

		//
		//   We walk the heap to get te details of the
		//   first heap allocation.
		//
		if ( Result = (Page -> Walk( & Details )) )
			{
			REGISTER BIT32 AllocationBit =
				((*Details.VectorWord) & Details.AllocationMask);

			(*Active) = (AllocationBit != 0);
			(*Address) = Details.Address;
			(*Size) = (Details.Page -> ActualSize());
			}
		}

	//
	//   Release the lock if we claimed it earlier and
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Memory,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Delete the hash table and release all the associated memory.   */
    /*                                                                  */
    /********************************************************************/

FIND::~FIND( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
	REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
	REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

	//
	//   Call the destructor for each hash table
	//   linked list header.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{ PLACEMENT_DELETE( & Hash[ Count ],LIST ); }

	//
	//   Deallocate the area.
	//
	Rockall -> DeleteArea( ((VOID*) Hash),TotalSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\bucketlist.hpp ===
#ifndef _BUCKET_LIST_HPP_
#define _BUCKET_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The bucket list.                                               */
    /*                                                                  */
    /*   All allocation buckets have a linked list of pages with        */
    /*   available space in ascending order of address.                 */
    /*                                                                  */
    /********************************************************************/

class BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  BucketList;

   public:
        //
        //   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
        //
        BUCKET_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromBucketList( LIST *HeadOfList )
			{ BucketList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfBucketList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> First()); }

		INLINE VOID InsertInBucketList( LIST *HeadOfList )
			{ BucketList.Insert( HeadOfList ); }

		INLINE VOID InsertAfterInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertAfter( HeadOfList,(LIST*) Page ); }

		INLINE VOID InsertBeforeInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertBefore( HeadOfList,(LIST*) Page ); }

		STATIC INLINE PAGE *LastInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> Last()); }

		INLINE PAGE *NextInBucketList( VOID )
			{ return ((PAGE*) BucketList.Next()); }

		INLINE PAGE *PreviousInBucketList( VOID )
			{ return ((PAGE*) BucketList.Previous()); }

        ~BUCKET_LIST( VOID )
			{ /* void */ };

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        BUCKET_LIST( CONST BUCKET_LIST & Copy );

        VOID operator=( CONST BUCKET_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\connections.hpp ===
#ifndef _CONNECTIONS_HPP_
#define _CONNECTIONS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   At the top level the parent of all caches is a constant        */
    /*   called 'GlobalRoot'.                                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 GlobalRoot				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;
class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   We communicate between a page and the associated cache         */
    /*   using an address pointer, page pointer and version triple.     */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	PAGE							  *Page;
	SBIT32							  Version;
	}
ADDRESS_AND_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Connections to other classes.                                  */
    /*                                                                  */
    /*   The connections between the various classes in the memory      */
    /*   allocator is a twisted mess.  The root cause is that at a      */
    /*   fundamental level.  Every part depends on every other part.    */
    /*   Nonetheless, a significant effort has been made to seperate    */
    /*   the parts as best as possible.  The various classes are        */
    /*   linked here so every part can find the correct instance of     */
    /*   every other part.                                              */
    /*                                                                  */
    /********************************************************************/

class CONNECTIONS : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		BOOLEAN						  Active;

   public:
		//
		//   Public data.
		//
		//   All the classes that inherit this class get
		//   pointers to related classes they need to call
		//   from time to time. 
		//
		FIND                          *Find;
		HEAP                          *Heap;
		NEW_PAGE					  *NewPage;
		CACHE						  *ParentCache;

		//
		//   The 'Prefetch' is a class that will trigger
		//   a cache fetch if the CPU supports it.
		//   
		PREFETCH					  Prefetch;

        //
        //   Public functions.
		//
		//   The sole job of this class is to provide 
		//   pointers to related classes.  These pointers
		//   are unknown until after the heap has been
		//   created and this need to be dynamically
		//   linked during the execution of the top 
		//   level heap constructor.
        //
        CONNECTIONS( VOID );

		VOID UpdateConnections
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CONNECTIONS( VOID );

		//
		//   Public inline functions.
		//
		//   The complex linkages in the heap sometimes 
		//   lead to the case where a class has a pointer
		//   to it's cache but not to the class it needs
		//   to call.  Thus, to avoid replicating large
		//   numbers of pointers we export call interfaces
		//   from here to allow the required calls to be
		//   made indirectly.
		//
		INLINE VOID DeleteFromFindList( PAGE *Page )
			{ Find -> DeleteFromFindList( Page ); }

		INLINE VOID DeletePage( PAGE *Page )
			{ NewPage -> DeletePage( Page ); }

		INLINE HEAP *GetHeap( VOID )
			{ return Heap; }

		INLINE CACHE *GetParentCache( VOID )
			{ return ParentCache; }

		INLINE VOID InsertInFindList( PAGE *Page )
			{ Find -> InsertInFindList( Page ); }

		INLINE BOOLEAN TopCache( VOID )
			{ return (ParentCache == ((CACHE*) GlobalRoot)); }

	private:
        //
        //   Disabled operations.
        //
        CONNECTIONS( CONST CONNECTIONS & Copy );

        VOID operator=( CONST CONNECTIONS & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\findlist.hpp ===
#ifndef _FIND_LIST_HPP_
#define _FIND_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "BucketList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The find list.                                                 */
    /*                                                                  */
    /*   The find list links all the pages in the same hash bucket      */
    /*   together so that the correct page can be found.                */
    /*                                                                  */
    /********************************************************************/

class FIND_LIST : public BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  FindList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        FIND_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromFindList( LIST *HeadOfList )
			{ FindList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfFindList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInFindList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInFindList( LIST *HeadOfList )
			{ FindList.Insert( HeadOfList ); }

		INLINE PAGE *NextInFindList( VOID )
			{ return ComputePageAddress( ((CHAR*) FindList.Next()) ); }

        ~FIND_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(BUCKET_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND_LIST( CONST FIND_LIST & Copy );

        VOID operator=( CONST FIND_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\heappch.hpp ===
#ifndef _HEAP_PCH_HPP_
#define _HEAP_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Bucket.hpp"
#include "BucketList.hpp"
#include "Cache.hpp"
#include "Connections.hpp"
#include "Find.hpp"
#include "FindList.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "NewPageList.hpp"
#include "Page.hpp"
#include "Rockall.hpp"

#include "LibraryPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\heappch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\heap.hpp ===
#ifndef _HEAP_HPP_
#define _HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class BUCKET;
class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The heap interface.                                            */
    /*                                                                  */
    /*   The traditional memory allocation interface only supports      */
    /*   a single allocation heap.  This memory allocator supports      */
    /*   multiple allocation heaps.  However, the interface nicely      */
    /*   hides this so at this point we are back to the traditional     */
    /*   single heap interface.                                         */
    /*                                                                  */
    /********************************************************************/

class HEAP : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		//   The heap is the top level container of all the
		//   functionality in the other classes.  The 'Active'
		//   flag indicates if the heap has been initialized.
		//   The 'MaxFreePages' controls the amount of free
		//   space the heap will slave before it starts to
		//   return it the the external allocator.  The
		//   'SmallestParentMask' is mask that shows which 
		//   parts of an address can be safely masked off
		//   and still ensure a hit in the find lookaside
		//   cache.  The 'ThreadSafe' flag indicates whether
		//   locking being used.
		//
		BOOLEAN						  Active;
		SBIT32						  MaxFreePages;
		BIT32						  SmallestParentMask;
		BOOLEAN						  ThreadSafe;

		//
		//   A heap is merely a collection of fixed sized
		//   allocation buckets (each with an optional cache).
		//   The 'CachesSize' is the total number of buckets.
		//   The 'MinCacheSize' is the allocation size of the
		//   smallest bucket.  The 'MidCacheSize' is the size
		//   of the bucket where the stride changes.  The
		//   'MaxCacheSize' is the allocation size of the 
		//   largest bucket externally visable.
		//
		SBIT32						  CachesSize;
		SBIT32						  MinCacheSize;
		SBIT32						  MidCacheSize;
		SBIT32						  MaxCacheSize;

		//
		//   A key function of the heap is to convert the
		//   requested allocation size into a pointer to
		//   the appropriate bucket (and cache).  This has
		//   to be very fast and is achieved using a direct
		//   lookup (i.e. an array).  The lookup array 
		//   consists of two sections (i.e. for small sizes
		//   and large sizes) to minimize space.  The 
		//   'MaxTable1' and 'MaxTable2' variables contain 
		//   the size of each section of the array.  The 
		//   'ShiftSize1' and 'ShiftSize2' variables contain
		//   the shift that should be applied to the size to
		//   obtain the appropriate index.  The 'SizeToCache1'
		//   and 'SizeToCache2' pointers refer to the direct
		//   lookup tables.
		//   
		SBIT32						  MaxTable1;
		SBIT32						  MaxTable2;
		SBIT32						  ShiftSize1;
		SBIT32						  ShiftSize2;
		CACHE                         **SizeToCache1;
		CACHE                         **SizeToCache2;

		//
		//   The heap needs to have access to most of the 
		//   other classes.  The 'Caches' class sits on
		//   top of an allocation bucket which owns all
		//   the allocated memory for a given size.  The
		//   'ExternalCache' is a special bucket that 
		//   contains weird sized pages.  The 'Find' class
		//   translates allocation addresses to page 
		//   descriptions.  The 'Rockall' class is needed
		//   to gain access to the external allocation APIs.
		//   The 'NewPage' class owns all page descriptions
		//   and plays a significant role in whole heap
		//   operations.  The 'TopCache' is the largest 
		//   bucket size and owns almost all the externally
		//   allocated memory.
		//
		CACHE						  **Caches;
		CACHE						  *ExternalCache;
		FIND						  *Find;
		NEW_PAGE					  *NewPage;
		PREFETCH					  Prefetch;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   A key feature of this heap is its ability to be
		//   significantly reconfigured at run time.  A great
		//   deal of complexity could have been removed if 
		//   certain static choices had been made.  Although
		//   this flexibility is nice the support of statistics
		//   here allows precise information to be collected so
		//   to enable the value of this to be maximized.
		//   
		//
		SBIT32						  CopyMisses;
		SBIT32						  MaxCopySize;
		SBIT32						  MaxNewSize;
		SBIT32						  NewMisses;
		SBIT32						  Reallocations;
		SBIT32						  *Statistics;
		SBIT32						  TotalCopySize;
		SBIT32						  TotalNewSize;
#endif

   public:
		//
		//   Public functions.
		//
		//   The heap exports the high level interface
		//   out to the world.  Any request a developer
		//   can make must come through one of these
		//   functions.
		//
        HEAP
			(
			CACHE					  *Caches1[],
			CACHE					  *Caches2[],
			SBIT32					  MaxFreeSpace,
			FIND					  *NewFind,
			NEW_PAGE				  *NewPages,
			ROCKALL					  *NewRockall,
			SBIT32					  Size1,
			SBIT32					  Size2,
			SBIT32					  Stride1,
			SBIT32					  Stride2,
			BOOLEAN					  NewThredSafe
			);

		BOOLEAN Delete( VOID *Address,SBIT32 Size = NoSize );

		VOID DeleteAll( BOOLEAN Recycle = True );

		BOOLEAN Details( VOID *Address,SBIT32 *Size = NULL );

		VOID LockAll( VOID );

		BOOLEAN MultipleDelete
			( 
			SBIT32					  Actual,
			VOID					  *Array[],
			SBIT32					  Size = NoSize
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested,
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *New
			( 
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *Resize
			( 
			VOID					  *Address,
			SBIT32					  NewSize,
			SBIT32					  Move = 1,
			SBIT32					  *Space = NULL,
			BOOLEAN					  NoDelete = False,
			BOOLEAN					  Zero = False
			);

		BOOLEAN Truncate( SBIT32 MaxFreeSpace = 0 );

		VOID UnlockAll( BOOLEAN Partial = False );

		BOOLEAN Check( VOID *Address,SBIT32 *Size = NULL );

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			SBIT32					  *Size 
			);

        ~HEAP( VOID );

		//
		//   Public inline functions.
		//
		//   Although these functions are public they mostly
		//   intended for internal consumption and are not
		//   to be called externally.
		//
		INLINE SBIT32 GetMaxFreePages( VOID )
			{ return MaxFreePages; }

		INLINE BOOLEAN KnownArea( VOID *Address )
			{ return (Find -> KnownArea( Address,TopCache )); }

		INLINE VOID *SpecialNew( SBIT32 Size )
			{ return NewPage -> NewCacheStack( Size ); }

	private:
		//
		//   Private functions.
		//
		//   All of the statistical information is 
		//   generated and output when the heaps
		//   destructor executes.
		//
		CACHE *FindCache( SBIT32 Size );
#ifdef ENABLE_HEAP_STATISTICS

		VOID PrintDebugStatistics( VOID );
#endif
		//
		//   Private inline functions.
		//
		//   The notion that resizing an allocation is 
		//   cheap has worked its way into the minds of 
		//   a large number of developers.  As a result
		//   parameter has been added to the function to
		//   allow the actual behavior to be controlled.
		//
		INLINE BOOLEAN ResizeTest( SBIT32 Delta,SBIT32 Move )
			{
			return
				(
				((Move > 0) && ((((Delta >= 0) ? Delta : -Delta) >= Move)))
					||
				((Move < 0) && ((Delta > 0) || (Delta <= Move)))
				);
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        HEAP( CONST HEAP & Copy );

        VOID operator=( CONST HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\newpage.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants set overall limits on the number and size of     */
    /*   page descriptions for pages within the memory allocator.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinNewPages			  = 1;
CONST SBIT32 VectorRange			  = ((2 << 15) - 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   A 'PAGE' structure has various fixed fields and a variable     */
    /*   sized allocation bit vector.  When this class is initialized   */
    /*   the user is required to supply us with an array that details   */
    /*   the sizes of allocation bit vectors supported.                 */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::NEW_PAGE
		(
		FIND						  *NewFind,
		SBIT32						  NewPageSizes[],
		ROCKALL						  *NewRockall,
		SBIT32						  Size,
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 DefaultRootSize = (NewRockall -> NaturalSize());
	REGISTER SBIT32 ReservedBytes = (Size * sizeof(NEW_PAGES));
	REGISTER SBIT32 SpareBytes = (DefaultRootSize - ReservedBytes);
	REGISTER SBIT32 StackSize = (SpareBytes / sizeof(VOID*));

	//
	//   We need to make sure that we appear to have a valid
	//   array of 'NewPageSizes' and that the bit vector sizes
	//   do not exceed the memory addressing range.
	//
	if 
			(
			PowerOfTwo( DefaultRootSize )
				&&
			(DefaultRootSize >= PageSize())
				&&
			(Size >= MinNewPages) 
				&&
			((NewPageSizes[ (Size-1) ] * OverheadBitsPerWord) <= VectorRange)
			)
		{
		REGISTER VOID *NewMemory = 
			(
			NewRockall -> NewArea
				( 
				(DefaultRootSize-1),
				DefaultRootSize,
				False
				)
			);

		//
		//   We are in big trouble if we can not allocate space
		//   to store this initial control information.  If the
		//   allocation fails we are forced to exit and the whole  
		//   memory allocator becomes unavailable.
		//
		if ( NewMemory != AllocationFailure )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 LastSize = 0;

			//
			//   We are now ready to setup the configuration
			//   information.
			//
			MaxCacheStack = 0;
			MaxNewPages = Size;
			MaxStack = StackSize;

			NaturalSize = DefaultRootSize;
			RootCoreSize = DefaultRootSize;
			RootStackSize = 0;
			ThreadSafe = NewThreadSafe;
			TopOfStack = 0;
			Version = 0;

			CacheStack = NULL;
			NewPages = ((NEW_PAGES*) NewMemory);
			Stack = ((VOID**) & NewPages[ Size ]);

			Find = NewFind;
			Rockall = NewRockall;
			TopCache = NULL;

			//
			//   Create a lists for the various page 
			//   sizes and prepare them for use.
			//
			for ( Count=0;Count < Size;Count ++ )
				{
				REGISTER SBIT32 CurrentSize = NewPageSizes[ Count ];

				if ( CurrentSize > LastSize )
					{
					REGISTER NEW_PAGES *NewPage = & NewPages[ Count ];

					//
					//   Create a list for the current
					//   size and fill in all the related
					//   details.
					//
					NewPage -> Elements = (CurrentSize * OverheadBitsPerWord);
					PLACEMENT_NEW( & NewPage -> ExternalList,LIST );
					PLACEMENT_NEW( & NewPage -> FullList,LIST );
					PLACEMENT_NEW( & NewPage -> FreeList,LIST );
					NewPage -> Size = (CurrentSize * sizeof(BIT32));

					LastSize = CurrentSize;
					}
				else
					{ Failure( "Sizes in constructor for NEW_PAGES" ); }
				}
			}
		else
			{ Failure( "No memory in constructor for NEW_PAGES" ); }
		}
	else
		{ Failure( "Setup of pages in constructor for NEW_PAGES" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create a new page.                                             */
    /*                                                                  */
    /*   Create a new 'PAGE' structure and prepare it for use.  If      */
    /*   we don't already have any pages of the required size then      */
    /*   allocate memory, create new 'PAGE' structures and link them    */
    /*   into the appropriate free chain.                               */
    /*                                                                  */
    /********************************************************************/

PAGE *NEW_PAGE::CreatePage( CACHE *Cache,SBIT32 NewSize )
    {
	REGISTER PAGE *NewPage = ((PAGE*) AllocationFailure);
	REGISTER SBIT16 SizeKey = (Cache -> GetSizeKey());

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER NEW_PAGES *Current;

		//
		//   When there is a potential for multiple threads 
		//   we claim the lock.
		//
		ClaimNewPageLock();

		//
		//   We allocate 'PAGE' structures as we need them
		//   and link them together in the free list.
		//   If we don't have any structures available we 
		//   allocate some more and add tem to the list.
		//
		if ( (Current = & NewPages[ SizeKey ]) -> FreeList.EndOfList() )
			{
			REGISTER SBIT32 ArrayElements = (Current -> Size - MinVectorSize);
			REGISTER SBIT32 ArraySize = (ArrayElements * sizeof(BIT32));
			REGISTER SBIT32 TotalSize = (sizeof(PAGE) + ArraySize);
			REGISTER SBIT32 FinalSize = CacheAlignSize( TotalSize );
			REGISTER SBIT32 TotalPages = (NaturalSize / FinalSize);

			//
			//   Nasty, we have run out of stack space.  If
			//   we can not grow this table then the heap
			//   will not be able to expand any further.
			//
			if ( TopOfStack >= MaxStack )
				{
				//
				//   Try to grow the stack size.
				//
				ResizeStack();

				//
				//   Update the pointer as the table may
				//   have moved.
				//
				Current = & NewPages[ SizeKey ];
				}

			//
			//   We may find ourseleves in a situation where
			//   the size of the new 'PAGE' structure is larger
			//   than the natural allocation size or the stack
			//   is full so we can't create new pages.  If so we
			//   refuse to create any new pages so any allocation
			//   requests for this size will fail.
			//
			if ( (TotalPages > 0) && (TopOfStack < MaxStack) )
				{
				REGISTER CHAR *NewMemory = 
					((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

				//
				//   We may also find ourselves unable to 
				//   anymore memory.  If so we will fail the
				//   request to create a page.
				//
				if ( NewMemory != AllocationFailure )
					{
					REGISTER SBIT32 Count;

					//
					//   Add the new allocation to stack of
					//   outstanding external allocations.
					//
					Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

					//
					//   Add the new elements to the free list
					//   for the current allocation size.
					//
					for 
							( 
							Count=0;
							Count < TotalPages;
							Count ++, (NewMemory += FinalSize)
							)
						{
						REGISTER PAGE *Page = ((PAGE*) NewMemory);

						//
						//   The page has been allocated but not 
						//   initialized so call the constructor
						//   and the destructor to get it into
						//   a sane state.
						//
						PLACEMENT_NEW( NewPage,PAGE ) 
							(
							NULL,
							NULL,
							0,
							NULL,
							0
							);

						PLACEMENT_DELETE( Page,PAGE );

						//
						//   Finally add the page to the free list
						//   so it can be used.
						//
						Page -> InsertInNewPageList( & Current -> FreeList ); 
						}
					}
				}
			}

		//
		//   We are now ready to create a new allocation
		//   page.  We start by requesting a page from
		//   the parent bucket.  If this works we know that 
		//   we have almost everthing we need to create the 
		//   new page.
		//
		if ( ! Current -> FreeList.EndOfList() )
			{
			REGISTER VOID *NewMemory;
			REGISTER CACHE *ParentPage = (Cache -> GetParentCache());

			NewPage = (PAGE::FirstInNewPageList( & Current -> FreeList ));

			//
			//   We have found a suitable page structure
			//   so remove it from the free list.
			//
			NewPage -> DeleteFromNewPageList( & Current -> FreeList );

			//
			//   Release any lock we might have as another
			//   thread may be waiting to delete a page and
			//   be holding the lock we need in order to
			//   create a page.
			//
			ReleaseNewPageLock();

			//
			//   We need to allocate memory to store the users 
			//   data.  After all we are the memory allocator
			//   and that is our job in life.  Typically, we do
			//   this by making a recursive internal request
			//   from a larger bucket.  Nonetheless, at some point
			//   we will reach the 'TopCache' and will be forced
			//   to request memory from an external source.
			//
			if ( (Cache -> TopCache()) || (NewSize != NoSize) )
				{
				REGISTER AlignMask = (TopCache -> GetPageSize()-1);

				//
				//   We allocate memory externally in large blocks 
				//   and sub-divide these allocations into smaller
				//   blocks.  The only exception is if the caller 
				//   caller is requesting some weird size in which
				//   case we request memory directly from the
				//   external allocator (usually the OS).
				//
				if ( NewSize == NoSize )
					{ NewSize = (Cache -> GetPageSize()); }

				//
				//   All externally allocated memory belongs
				//   to the global root.  Thus, it will be 
				//   found in the first lookup in the find
				//   table.
				//
				ParentPage = ((CACHE*) GlobalRoot);

				//
				//   Allocate from the external allocator.
				//
				NewMemory = (VerifyNewArea( AlignMask,NewSize ));
				}
			else
				{
				//
				//   Allocate memory from a larger cache and then
				//   sub-divide it as needed.
				//
				NewMemory = 
					(Cache -> GetParentCache() -> CreateDataPage()); 
				}

			//
			//   Reclaim any lock we have had earlier so 
			//   we can update the the new page structure.
			//
			ClaimNewPageLock();

			//
			//   Lets make sure we sucessfully allocated the
			//   memory for the data page.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   We now have everything we need so lets
				//   create a new page.
				//
				PLACEMENT_NEW( NewPage,PAGE ) 
					(
					NewMemory,
					Cache,
					NewSize,
					ParentPage,
					(Version += 2)
					);

				//
				//   Finally lets add the new page to the various
				//   lists so we can quickly find it again later.
				//
				Cache -> InsertInBucketList( NewPage );

				Cache -> InsertInFindList( NewPage );

				NewPage -> InsertInNewPageList
					(
					(Cache -> TopCache())
						? & Current -> ExternalList 
						: & Current -> FullList 
					); 
				}
			else
				{
				//
				//   We were unable to allocate any data space
				//   for this new page so lets free the page 
				//   description and exit.
				//
				NewPage -> InsertInNewPageList( & Current -> FreeList );

				NewPage = ((PAGE*) AllocationFailure);
				}
			}

		//
		//   We have finished so release the lock now. 
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key is out of range" ); }
#endif

	return NewPage;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete an entire heap and return all the memory to the         */
    /*   top level pool or the external allocator (usually the OS).     */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeleteAll( BOOLEAN Recycle )
    {
	REGISTER SBIT32 Count;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We assume at this point that we have blocked
	//   all memory allocation and dealloction requests.
	//   We are now going to walk through the various lists
	//   and just blow away things.  We are going to
	//   do this in a tidy way just in case the caller
	//   wants to use the heap again later.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   All allocations that appear in the full list
		//   have been sub-allocated from larger pages in
		//   almost all cases.
		//
		for
				(
				Page = (PAGE::FirstInNewPageList( & Current -> FullList ));
				! Page -> EndOfNewPageList();
				Page = NextPage
				)
			{
			REGISTER VOID *Address = (Page -> GetAddress());
			REGISTER CACHE *Cache = (Page -> GetCache());
			REGISTER SBIT32 PageSize = (Page -> GetPageSize());

			//
			//   We decide here how we will deal with the page.
			//   If it is empty, non-standard or we are not
			//   recycling we will blow it away.  If not we
			//   simply reset it for later use.
			//
			if ( (Page -> Empty()) || (PageSize != NoSize) || (! Recycle) )
				{
				//
				//   We need to release any associated data page.
				//   If this is the top level then release the
				//   memory back to the external allocator.  If 
				//   not we release it back to the parent bucket.
				//
				if ( PageSize == NoSize )
					{
					//
					//   If we are just recycling then we cleanly
					//   delete the page.  If not then we know it
					//   will be blown away later so why bother.
					//
					if ( Recycle )
						{
						REGISTER CACHE *ParentCache = 
							(Cache -> GetParentCache());

						if ( ! (ParentCache -> DeleteDataPage( Address )) )
							{ Failure( "Reset data page in DeleteAll" ); }
						}
					}
				else
					{ Rockall -> DeleteArea( Address,PageSize,True ); }

				//
				//   We may have been blowing away pages  
				//   randomly and now we are about to destroy 
				//   the current page.  So lets figure out 
				//   what page comes next before we continue.
				//
				NextPage = (Page -> NextInNewPageList());

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> FullList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			else
				{
				//
				//   We know that the current page has at 
				//   least one allocation on it so instead
				//   of deleting it we will mark it as free
				//   (except for any sub-allocations) and
				//   leave it around for next time.  If it
				//   is never used the next top level 
				//   'DeleteAll' will delete it.
				//
				Page -> DeleteAll();

				//
				//   We have now reset the current page so  
				//   lets figure out what page comes next.
				//
				NextPage = (Page -> NextInNewPageList());
				}
			}

		//
		//   We have a choice to make.  If we intend to
		//   use this heap again we keep all top level
		//   allocated memory in a list ready for reuse.
		//   If not we return it to the external allocator
		//   (usually the OS).
		//   
		if ( ! Recycle )
			{
			//
			//   The external allocations list contains an
			//   entry for every externally allocated page
			//   except those allocated for special internal 
			//   use within this class or for weird sized
			//   pages that appeared above in the 'FullList'.
			//
			for
					(
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ));
					! Page -> EndOfNewPageList();
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ))
					)
				{
				REGISTER VOID *Address = (Page -> GetAddress());
				REGISTER CACHE *Cache = (Page -> GetCache());
				REGISTER SBIT32 PageSize = (Page -> GetPageSize());

				//
				//   We no longer need this top level allocation
				//   so return it to the external allocator.
				//
				Rockall -> DeleteArea( Address,PageSize,True );

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> ExternalList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			}
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page.                                                 */
    /*                                                                  */
    /*   Delete a page structure, free the associated memory and        */
    /*   unlink it from the various allocation lists.                   */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeletePage( PAGE *Page )
    {
	REGISTER CACHE *Cache = Page -> GetCache();
	REGISTER SBIT16 SizeKey = Cache -> GetSizeKey();

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER NEW_PAGES *Current = & NewPages[ SizeKey ];
		REGISTER SBIT32 Size = (Page -> GetPageSize());

		//
		//   We need to release any associated data page.
		//   If this is the top level then release the
		//   memory back to the external allocator.  If 
		//   not we release it back to the parent bucket.
		//
		if ( Size == NoSize )
			{ 
			REGISTER CACHE *ParentCache = (Cache -> GetParentCache());

			if ( ! (ParentCache -> DeleteDataPage( Address )) )
				{ Failure( "Deleting data page in DeletePage" ); }
			}
		else
			{ Rockall -> DeleteArea( Address,Size,True ); }

		//
		//   Claim the global lock so that the various  
		//   lists can be updated.
		//
		ClaimNewPageLock();

		//
		//   Remove the page from the lists and delete it.
		//
		Cache -> DeleteFromBucketList( Page );

		Cache -> DeleteFromFindList( Page );

		Page -> DeleteFromNewPageList
			(
			(Cache -> TopCache())
				? & Current -> ExternalList 
				: & Current -> FullList 
			); 

		PLACEMENT_DELETE( Page,PAGE );

		//
		//   Finally add the page to the free list
		//   so it can be recycled.
		//
		Page -> InsertInNewPageList( & Current -> FreeList );

		//
		//   We have finsihed so release the lock.
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key out of range in DeletePage" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find the correct index in new page.                            */
    /*                                                                  */
    /*   When we come to create a new page we need to make sure the     */
    /*   bit vector is large enough for the page.  We calculate this    */
	/*   here just once to save time later.                             */
    /*                                                                  */
    /********************************************************************/

SBIT16 NEW_PAGE::FindSizeKey( SBIT16 NumberOfElements )
    {
	REGISTER SBIT32 Count;

	//
	//   Search the table of page structures looking for 
	//   elements of a suitable size.  As the table is
	//   known to be in order of increasing size we can
	//   terminate the search as soon as we find something 
	//   large enough.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		if ( NumberOfElements <= Current -> Elements )
			{ return ((SBIT16) Count); }
		}

	//
	//   Nasty, we don't seem to have anything large enough
	//   to store the bit vector.
	//
	return NoSizeKey;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new cache stack.                                      */
    /*                                                                  */
    /*   A cache stack is an array that contains memory allocations     */
    /*   that are waiting to be allocated or released.                  */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::NewCacheStack( SBIT32 Size )
    {
	REGISTER VOID *NewStack;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We ensure that there is enough space to make the
	//   allocation.  If not we request additional space
	//   and prepare it for use.
	//
	if ( (CacheStack == NULL) || ((MaxCacheStack + Size) > NaturalSize) )
		{
		//
		//   Nasty, we have run out of stack space.  If
		//   we can not grow this table then the heap
		//   will not be able to expand any further.
		//
		if ( TopOfStack >= MaxStack )
			{
			//
			//   Try to grow the stack size.
			//
			ResizeStack();
			}

		//
		//   We may find ourseleves in a situation where
		//   the size of the new stack structure is larger
		//   than the natural allocation size or the stack
		//   is full so we can't create new pages.  If so we
		//   refuse to create any new stacks.
		//
		if ( (Size < NaturalSize) && (TopOfStack < MaxStack) )
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

			//
			//   We may also find ourselves unable to 
			//   anymore memory.  If so we will fail the
			//   request to create a new cache stack.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   Add the new allocation to stack of
				//   outstanding external allocations.
				//
				Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

				//
				//   Prepare the new memory block for use.
				//   
				CacheStack = NewMemory;
				MaxCacheStack = 0;
				}
			else
				{ return NULL; }
			}
		else
			{ return NULL; }
		}

	//
	//   We allocate some space for the new cache 
	//   stack and update and align the high water
	//   mark of the space used.
	//
	NewStack = ((VOID*) & CacheStack[ MaxCacheStack ]);

	MaxCacheStack += (Size + CacheLineMask);
	MaxCacheStack &= ~CacheLineMask;

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return NewStack;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Resize the new page stack.                                     */
    /*                                                                  */
    /*   The new page stack holds pointers to all the pages owned       */
    /*   by the heap.  If this stack become full we must expand it      */
	/*   otherwise we can no longer grow the heap.                      */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::ResizeStack( VOID )
    {
	REGISTER SBIT32 NewSize = 
		(((RootStackSize <= 0) ? NaturalSize : RootStackSize) * 2);

	//
	//   Lets just check that we have really run out
	//   of stack space as expanding it really hurts.
	//
	if ( TopOfStack >= MaxStack )
		{
		REGISTER VOID *NewMemory = 
			(
			Rockall -> NewArea
				( 
				(NaturalSize-1),
				NewSize,
				False
				)
			);

		//
		//   We need to verify that we were able to allocate
		//   fresh memory for the stack.
		//
		if ( NewMemory != NULL )
			{
			REGISTER BOOLEAN DeleteStack = (RootStackSize > 0);
			REGISTER VOID *OriginalMemory = ((VOID*) Stack);
			REGISTER SBIT32 OriginalSize = (MaxStack * sizeof(VOID*));

			//
			//   All is well as we were able to allocate 
			//   additional space for the stack.  All we 
			//   need to do now is to update the control 
			//   information.
			//
			MaxStack = (NewSize / sizeof(VOID*));

			RootStackSize = NewSize;

			Stack = ((VOID**) NewMemory);

			//
			//   Now lets copy across the existing data. 
			//
			memcpy( NewMemory,OriginalMemory,OriginalSize );

			//
			//   When the heap is created we put the
			//   stack on the root core page.  Later
			//   we may move it if we expand it.  If
			//   this is the case we have to delete  
			//   the previous expansion here.
			//
			if ( DeleteStack )
				{
				//
				//   Deallocate the existing stack if it
				//   is not on the root core page.
				//
				Rockall -> DeleteArea( OriginalMemory,OriginalSize,False );
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify an external allocation.                                 */
    /*                                                                  */
    /*   All memory requests are allocated from the external allocator  */
	/*   at the highest level.  Here we have a wrapper for this         */
    /*   function so we can test the result and make sure it is sane.   */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::VerifyNewArea( SBIT32 AlignMask,SBIT32 Size )
	{
#ifdef DEBUGGING
	//
	//   We need to ensure that the alignment of the new
	//   external allocation is a power of two.
	//
	if ( PowerOfTwo( (AlignMask + 1) ) )
		{
#endif
		REGISTER VOID *NewMemory = 
			(Rockall -> NewArea( AlignMask,Size,True ));

		//
		//   We need to ensure that the external allocation
		//   request is sucessful.  If not it makes no sense
		//   to try and check it.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   We require the external memory allocator to always
			//   allocate memory on the requested boundary.  If not 
			//   we are forced to reject the supplied memory.
			//
			if ( (((SBIT32) NewMemory) & AlignMask) == 0 )
				{ return NewMemory; }
			else
				{ 
				Rockall -> DeleteArea( NewMemory,Size,True );
				
				Failure( "Alignment of allocation in VerifyNewArea" );
				}
			}
#ifdef DEBUGGING
		}
	else
		{ Failure( "Alignment is not a power of two in VerifyNewArea" ); }
#endif

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN NEW_PAGE::Walk( SEARCH_PAGE *Details )
    {
	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We examine the current address to see if it
	//   is null.  If so then this is the start of a
	//   heap walk so we need to set it up.
	//
	if ( Details -> Address == NULL )
		{
		REGISTER SBIT32 Count;

		//
		//   Walk through the list of different sized
		//   page descriptions.
		//
		for ( Count=0;Count < MaxNewPages;Count ++ )
			{
			REGISTER NEW_PAGES *Current = & NewPages[ Count ];

			//
			//   Compute a pointer to the first element
			//   of the current size.
			//
			Details -> Page = 
				(PAGE::FirstInNewPageList( & Current -> FullList ));

			//
			//   Examine the current list of full (or 
			//   partially full) pages.  If there is at  
			//   least one page then this is the starting 
			//   point for the heap walk.
			//
			if ( ! Details -> Page -> EndOfNewPageList() )
				{
				//
				//   Compute the starting address of the 
				//   heap walk.
				//
				Details -> Address = 
					(Details -> Page -> GetAddress());

				break;
				}
			}
		}
	else
		{
		REGISTER PAGE *LastPage = Details -> Page;

		//
		//   We have exhusted the current page so walk
		//   the list and find the next page.
		//
		Details -> Page = 
			(Details -> Page -> NextInNewPageList());

		//
		//   We need to ensure that we have not reached
		//   the end of the current list.
		//
		if ( Details -> Page -> EndOfNewPageList() )
			{
			REGISTER SBIT32 Count;
			REGISTER BOOLEAN Found = False;

			//
			//   We need to find a new page description
			//   list to walk so reset the current 
			//   address just in case we don't find 
			//   anything.
			//
			Details -> Address = NULL;

			//
			//   We have reached the end of the current
			//   list and we need to continue with the
			//   start of the next list.  However, we
			//   don't know which list we were using
			//   previously.  So first we identify the
			//   previous list and then select the next
			//   avaibale list.
			//
			for ( Count=0;Count < MaxNewPages;Count ++ )
				{
				REGISTER NEW_PAGES *Current = & NewPages[ Count ];

				//
				//   We search for the original list
				//   we were walking.
				//
				if ( ! Found )
					{
					//
					//   When we find the original list
					//   then we set a flag showing that
					//   the next available list is the
					//   target.
					//
					if 
							( 
							LastPage 
								== 
							(PAGE::LastInNewPageList( & Current -> FullList )) 
							)
						{ Found = True; }
					}
				else
					{
					//
					//   We have found the previous list
					//   so the first element of the next
					//   list seems a good place to continue.
					//
					Details -> Page = 
						(PAGE::FirstInNewPageList( & Current -> FullList ));

					//
					//   We check to make sure that the list
					//   has at least one active page.  If not
					//   it is worthless and we continue looking
					//   for a suitable list.
					//
					if ( ! Details -> Page -> EndOfNewPageList() )
						{
						//
						//   Compute the starting address for 
						//   the next page in the heap walk.
						//
						Details -> Address = 
							(Details -> Page -> GetAddress());

						break;
						}
					}
				}
			}
		else
			{ 
			//
			//   Compute the starting address for 
			//   the next page in the heap walk.
			//
			Details -> Address = 
				(Details -> Page -> GetAddress());
			}
		}

	//
	//   If we find a new heap page to walk we update
	//   the details.  We mark some entry's as exhusted
    //   so as to provoke other code to set them up.
	//
	if ( Details -> Address != NULL )
		{
		//
		//   Compute the new allocation details.
		//
		Details -> Page -> FindPage
			( 
			Details -> Address,
			Details,
			False 
			);
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return (Details -> Address != NULL);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory all the page structures and release any allocated      */
    /*   memory.                                                        */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::~NEW_PAGE( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Delete all active allocations.
	//
	DeleteAll( False );

	//
	//   We are about to delete all of the memory 
	//   allocated by this class so destroy any
	//   internal pointers.
	//
	MaxCacheStack = 0;
	CacheStack = NULL;

	//
	//   We have now deleted all the memory allocated by
	//   this heap except for the memory  allocated directly 
	//   by this class.  Here we finish off the job by 
	//   deleting these allocations and reseting the internal 
	//   data structures.
	//
	for ( Count=0;Count < TopOfStack;Count ++ )
		{
		REGISTER VOID *Current = Stack[ Count ];

		Rockall -> DeleteArea( Current,NaturalSize,False );
		}

	TopOfStack = 0;

	//
	//   If we were forced to expand the root stack then
	//   release this additional memory now.
	//
	if ( RootStackSize > 0 )
		{
		//
		//   Deallocate root stack which previously 
		//   contained pointers to all the memory
		//   allocated by this class.
		//
		Rockall -> DeleteArea( ((VOID*) Stack),RootStackSize,False );
		}

	//
	//   Delete all the new page list headings just
	//   to be neat
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		PLACEMENT_DELETE( & Current -> ExternalList,LIST );
		PLACEMENT_DELETE( & Current -> FullList,LIST );
		PLACEMENT_DELETE( & Current -> FreeList,LIST );
		}

	//
	//   Deallocate root core page which previously 
	//   contained all the new page lists.
	//
	Rockall -> DeleteArea( ((VOID*) NewPages),RootCoreSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\heap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control minimum size of an         */
    /*   allocation bucket.                                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinParentSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a heap and prepare it for use.  Additionally, make      */
    /*   sure that the heap configuration makes sense.  This is         */
    /*   tricky as the whole structure of the heap can be changed       */
    /*   by the external configuration information.                     */
    /*                                                                  */
    /********************************************************************/

HEAP::HEAP
		(
		CACHE						  *Caches1[],
		CACHE						  *Caches2[],
		SBIT32						  MaxFreeSpace,
		FIND						  *NewFind,
		NEW_PAGE					  *NewPages,
		ROCKALL						  *NewRockall,
		SBIT32						  Size1,
		SBIT32						  Size2,
		SBIT32						  Stride1,
		SBIT32						  Stride2,
		BOOLEAN						  NewThreadSafe
		)
    {
	//
	//   The top three buckets are special and a user can not 
	//   allocate memory from two of them.  Thus, unless we have  
	//   at least four buckets the memory allocator is not going 
	//   to be very useful. 
	//
	if ( (Size1 >= 1) && (Size2 >= 3) )
		{
		REGISTER CACHE *FirstCache = Caches1[0];
		REGISTER CACHE *MiddleCache = Caches2[0];
		REGISTER CACHE *LastCache = Caches2[ (Size2-3) ];

		//
		//   Calculate the minimum and maximum allocation sizes.
		//   All allocations outside of this range will be passed
		//   directly to the external allocator.
		//
		CachesSize = (Size1 + Size2);
		MinCacheSize = FirstCache -> GetAllocationSize();
		MidCacheSize = MiddleCache -> GetAllocationSize();
		MaxCacheSize = LastCache -> GetAllocationSize();

		//
		//   Calculate and save various useful pointers needed
		//   during the course of execution.
		//
		Caches = Caches1;
		ExternalCache = (Caches2[ (Size2-1) ]);
		Find = NewFind;
		NewPage = NewPages;
		Rockall = NewRockall;
		TopCache = (Caches2[ (Size2-2) ]);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Zero the heap statistics.
		//
		CopyMisses = 0;
		MaxCopySize = 0;
		MaxNewSize = 0;
		NewMisses = 0;
		Reallocations = 0;
		TotalCopySize = 0;
		TotalNewSize = 0;
#endif

		//
		//   The external allocation size must be reasonable.
		//   All allocation sizes must be a multiple of the
		//   minimum allocation size.  The minimum allocation
		//   size and the middle allocation size must be a 
		//   power of two.
		//   
		if 
				( 
				(ExternalCache -> GetPageSize() == TopCache -> GetPageSize())
					&& 
				(PowerOfTwo( Rockall -> NaturalSize() ))
					&&
				(Rockall -> NaturalSize() >= PageSize())
					&&
				(TopCache -> GetPageSize() >= PageSize())
					&&
				(PowerOfTwo( TopCache -> GetPageSize() ))
					&&
				((Stride1 > 0) && (PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (PowerOfTwo( Stride2 )))
					&&
				(ConvertDivideToShift( Stride1,& ShiftSize1 ))
					&&
				(ConvertDivideToShift( Stride2,& ShiftSize2 ))
				)
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 TopCacheSize = (TopCache -> GetPageSize());
			REGISTER SBIT32 MaxSize1 = (MidCacheSize / Stride1);
			REGISTER SBIT32 MaxSize2 = (TopCacheSize / Stride2);

			//
			//   Calculate the maximum number of free pages 
			//   that can be kept.  Also set the smallest parent
			//   mask to the maximum value.
			//
			MaxFreePages = (MaxFreeSpace / (TopCache -> GetAllocationSize()));
			SmallestParentMask = ((TopCache -> GetAllocationSize())-1);
			ThreadSafe = NewThreadSafe;

			//
			//   Calculate the sizes of the arrays that map 
			//   sizes to caches.
			//
			MaxTable1 = (MaxSize1 * sizeof(CACHE*));
			MaxTable2 = (MaxSize2 * sizeof(CACHE*));

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < Size1;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches1[ Count1 ];
				REGISTER CACHE *Next = Caches1[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride1) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < (Size2-2);Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER CACHE *Next = Caches2[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The external and top caches have special rules
			//   which must be checked to ensure these caches
			//   are valid.
			//
			for ( Count1=(Size2-2);Count1 < Size2;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Top cache size not multiple of minimum" ); }

				if ( AllocationSize != Current -> GetChunkSize() )
					{ Failure( "Chunk size not suitable for top cache" ); }

				if ( AllocationSize != Current -> GetPageSize() )
					{ Failure( "Page size not suitable for top cache" ); }

				if ( Current -> GetCacheSize() != 0 )
					{ Failure( "Cache size not zero for top cache" ); }
				}

			//
			//   We need to allocate two arrays to enable requested
			//   sizes to be quickly mapped to allocation caches.
			//   Here we allocate the tables and later fill in all
			//   the necessary mapping information.
			//
			SizeToCache1 = (CACHE**) 
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxTable1 + MaxTable2),
					False
					)
				);
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   When we are compiled for statistics we keep
			//   information on all the allocations we see.
			//
			Statistics = (SBIT32*)
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxCacheSize * sizeof(SBIT32)),
					False
					)
				);
#endif

			//
			//   We make sure that the allocations we made 
			//   did not fail.  If not we have to fail the 
			//   creation of the whole heap.
			//
			if 
					( 
					(SizeToCache1 != ((CACHE**) AllocationFailure))
#ifdef ENABLE_HEAP_STATISTICS
						&&
					(Statistics != ((SBIT32*) AllocationFailure))
#endif
					) 
				{
				REGISTER SBIT32 Count2;

				//
				//   Cycle through the first segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize1;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride1)
								> 
							(Caches1[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache1[ Count1 ] = Caches1[ Count2 ];
					}

				//
				//   Compute the start address for the second
				//   segment of the table.
				//
				SizeToCache2 = 
					((CACHE**) & ((CHAR*) SizeToCache1)[ MaxTable1 ]);

				//
				//   Cycle through the second segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize2;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride2)
								> 
							(Caches2[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache2[ Count1 ] = Caches2[ Count2 ];
					}

				//
				//   Now that we have created the size to cache 
				//   mappings lets use them to link each cache to  
				//   the cache it uses to allocate additional 
				//   memory.
				//
				for ( Count1=0;Count1 < (CachesSize-1);Count1 ++ )
					{
					REGISTER CACHE *CurrentCache = Caches[ Count1 ];
					REGISTER SBIT32 PageSize = CurrentCache -> GetPageSize();
					REGISTER CACHE *ParentCache = FindCache( PageSize );
					REGISTER BOOLEAN Top = (CurrentCache == ParentCache);

					//
					//   Ensure that the parent cache is suitable
					//   and in line with what we were expecting. 
					//
					if 
							(
							(PowerOfTwo( PageSize ))
								&&
							(PageSize >= MinParentSize)
								&&
							(PageSize == (ParentCache -> GetAllocationSize()))
							)
						{
						//
						//   We keep track of the smallest
						//   cache that is a parent.  We can
						//   use this to improve the performance
						//   of the find hash table.
						//
						if ( ((BIT32) PageSize) < SmallestParentMask )
							{ SmallestParentMask = (PageSize-1); }

						//
						//   Update the current cache with  
						//   information about it's parent 
						//   cache.
						//
						CurrentCache -> UpdateCache
							(
							NewFind,
							this,
							NewPages,
							((Top) ? ((CACHE*) GlobalRoot) : ParentCache)
							); 
						} 
					else
						{ Failure( "Parent bucket is invalid" ); }
					}

				//
				//   The external cache is an exact duplicate
				//   of the top cache and is used to hold all
				//   memory allocations that are too large for
				//   any bucket.  Nonetheless, its parent is
				//   still the top cache.
				//
				ExternalCache -> UpdateCache
					(
					NewFind,
					this,
					NewPages,
					TopCache
					);

				//
				//   Update the hash table with the minimum
				//   parent size for this heap.
				//
				Find -> UpdateFind
					(
					(TopCache -> GetAllocationSize()-1),
					SmallestParentMask 
					);

				//
				//   Update the new page structure with the 
				//   details of the top cache.
				//
				NewPage -> UpdateNewPage( TopCache );

				//
				//   Activate the heap.
				//
				Active = True;
				}
			else
				{ Failure( "Mapping table in constructor for HEAP" ); }
			}
		else
			{ Failure( "The allocation sizes in constructor for HEAP" ); }
		}
	else
		{ Failure( "A heap size in constructor for HEAP" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We need to release some memory.  First we try to slave the     */
    /*   request in the free cache so we can do a batch of releases     */
    /*   later.  If not we are forced to do it at once.                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Delete( VOID *Address,SBIT32 Size )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   When the caller gives us the size of the 
		//   allocation we can short cut the deallocation 
		//   process by skipping directly to the correct 
		//   cache.  However, if the user supplies us
		//   with bogus data we will retry using the
		//   the full deallocation process.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			if ( Find -> Delete( Address,Cache ) )
				{ return True; }
			}

		//
		//   It looks like all we have is the address so 
		//   deallocate using the long path.
		//
		return (Find -> Delete( Address,TopCache ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We delete the entire heap and free all existing allocations.   */
    /*   If 'Recycle' is requested we slave the allocated memory as     */
    /*   we expect some new allocations.  If not we return all the      */
    /*   memory to the external allocator.                              */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::DeleteAll( BOOLEAN Recycle )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   We claim all of the heap locks to freeze
		//   all new allocations or deletions.
		//
		LockAll();

		//
		//   Now reset all the caches and the find
		//   hash table statistics.
		//
		Find -> DeleteAll();

		for ( Count=0;Count < CachesSize;Count ++ )
			{ Caches[ Count ] -> DeleteAll(); }

		//
		//   Delete the heap.
		//
		NewPage -> DeleteAll( Recycle );

		//
		//   Now release all the heap locks we claimed
		//   earlier and unfreeze the heap.
		//
		UnlockAll();

		//
		//   Trim the free space if needed.
		//
		if ( Recycle )
			{ TopCache -> ReleaseSpace( MaxFreePages ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Details( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Size' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.
		//
		if ( Size == NULL )
			{ Size = & Dummy; }

		//
		//   Find the details relating to this allocation
		//   and return them.
		//
		return (Find -> Details( Address,NULL,TopCache,Size ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a cache.                                                  */
    /*                                                                  */
    /*   Find the allocation cache for the size supplied and return     */
    /*   a pointer to it.                                               */
    /*                                                                  */
    /********************************************************************/

CACHE *HEAP::FindCache( SBIT32 Size )
	{
	REGISTER CACHE *Cache;

	//
	//   Compute the cache address.
	//
	if ( Size < MidCacheSize )
		{ return (SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }

	//
	//   Prefetch the class data if we are running a
	//   Pentium III or better with locks.  We do this
	//   because prefetching hot SMP data structures
	//   really helps.  However, if the structures are
	//   not shared (i.e. no locks) then it is worthless
	//   overhead.
	//
	if ( ThreadSafe )
		{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

	return Cache;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim a lock on the entire heap.                               */
    /*                                                                  */
    /*   We claim a lock on the heap to improve performance             */
    /*   or prevent others from performing heap operations.             */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::LockAll( VOID )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We claim the locks if we have not already
		//   claimed them earlier.
		//
		if ( Find -> GetLockCount() == 0 )
			{
			REGISTER SBIT32 Count;

			//
			//   We claim all of the heap locks to freeze
			//   all new allocations or deletions.
			//
			for ( Count=0;Count < CachesSize;Count ++ )
				{ Caches[ Count ] -> ClaimCacheLock(); }

			//
			//  Although the heap is frozen at this point
			//  we claim the last few locks just to be
			//  tidy.
			//
			Find -> ClaimFindExclusiveLock();

			NewPage -> ClaimNewPageLock();
			}

		//
		//   Increment the per thread lock count.
		//
		Find -> IncrementLockCount();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete multiple allocations.                                   */
    /*                                                                  */
    /*   We need to release multiple memory allocations.  First we try  */
    /*   to slave the requets in the free cache so we can do a batch    */
    /*   of releases later.  If not we are forced to do it immediately. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleDelete
		( 
		SBIT32						  Actual,
		VOID						  *Array[],
		SBIT32						  Size 
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;
		REGISTER BOOLEAN Result = True;
		REGISTER CACHE *ParentCache = ((CACHE*) GlobalRoot);

		//
		//   When the caller gives us the size of the allocation
		//   we can short cut the deallocation process by skipping
		//   directly to the correct cache.  However, if the user
		//   supplies us with bogus data we will retry using the
		//   the long path.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			ParentCache = (Cache -> GetParentCache());
			}

		//
		//   Delete each memory allocation one at a time.
		//   We would like to delete them all at once but
		//   we can't be sure they are all vaild or related.
		//
		for ( Count=0;Count < Actual;Count ++ )
			{
			REGISTER VOID *Address = Array[ Count ];

			//
			//   First try to optimize the delete and if that
			//   fails then try the long path.
			//
			if 
					(
					(ParentCache == ((CACHE*) GlobalRoot)) 
						|| 
					(! Find -> Delete( Address,ParentCache )) 
					)
				{
				Result =
					(
					Find -> Delete( Address,TopCache )
						&&
					Result
					);
				}
			}

		return Result;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We have been asked to allocate muliple memory blocks.   We     */
    /*   we do this by using the cache and then claiming and addition   */
    /*   space from the heap as needed.                                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested,
		SBIT32						  Size,
		SBIT32						  *Space,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Actual' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.  Regardless we zero it.
		//
		if ( Actual == NULL )
			{ Actual = & Dummy; }

		(*Actual) = 0;

		//
		//   We need to be sure that the size requested is in the 
		//   range supported by the memory allocator.  If not we
		//   do a series of single allocations from the default
		//   allocator.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
			REGISTER SBIT32 NewSize = (Cache -> GetAllocationSize());

			//
			//   Allocate memory from the appropriate 
			//   allocation bucket.
			//
			(VOID) Cache -> MultipleNew( Actual,Array,Requested );

			//
			//   If needed return the actual amount  
			//   of space allocated for each element.
			//
			if ( Space != NULL )
				{ (*Space) = NewSize; }
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] += Requested;
#endif

			//
			//   If needed zero each element that is  
			//   allocated.
			//
			if ( Zero )
				{
				REGISTER SBIT32 Count;

				for ( Count=((*Actual)-1);Count >= 0;Count -- )
					{ ZeroMemory( Array[ Count ],NewSize ); }
				}

			return ((*Actual) == Requested);
			}
		else
			{
			//
			//   If the allocation size is greater than
			//   zero we create the allocations.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
				//
				//   We have got a request for an element size
				//   larger than the largest bucket size.  So 
				//   we call the single allocation interface 
				//   as this supports large sizes.
				//
				for 
					( 
					/* void */;
					((*Actual) < Requested)
						&&
					((Array[ (*Actual) ] = New( Size )) != AllocationFailure);
					(*Actual) ++ 
					);

				//
				//   If needed return the actual amount of space 
				//   allocated for each element.
				//
				if ( Space != NULL )
					{ (*Space) = Size; }

				return ((*Actual) == Requested);
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We have been asked to allocate some memory.  Hopefully,        */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket.                                                        */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::New( SBIT32 Size,SBIT32 *Space,BOOLEAN Zero )
	{
	REGISTER VOID *NewMemory = ((VOID*) AllocationFailure);

	//
	//   Although normally a class is never called before
	//   its constructor. The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We ensure the allocation size is in
		//   the range supported by the heap.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] ++;
#endif

			//
			//   Allocate memory from the appropriate
			//   cache in the heap.
			//
			NewMemory = (Cache -> New()); 
			Size = (Cache -> GetAllocationSize());
			}
		else
			{ 
			//
			//   If the allocation size is greater than
			//   zero we create the allocation.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the allocation statistics.
				//
				if ( Size > MaxNewSize )
					{ MaxNewSize = Size; }

				NewMisses ++;
				TotalNewSize += Size;

#endif
				//
				//   Allocate memory from a special
				//   cache bucket which gets space
				//   externally.
				//
				NewMemory = (ExternalCache -> New( False,Size ));
				}
			else
				{ NewMemory = ((VOID*) AllocationFailure); }
			}

		//
		//   We need to be sure that the allocation 
		//   request did not fail.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   If needed return the actual amount of space 
			//   allocated for this request.
			//
			if ( Space != NULL )
				{ (*Space) = Size; }

			//
			//   Zero the memory if the needed.
			//
			if ( Zero )
				{ ZeroMemory( NewMemory,Size ); }
			}
		}

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Print statistics.                                              */
    /*                                                                  */
    /*   We output the allocation statistics to the debug console.      */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::PrintDebugStatistics( VOID )
	{
	REGISTER HANDLE Semaphore;
	
	//
	//   As we may have multiple heaps executing there 
	//   destructors at the same time we create a semaphore
	//   to prevent multiple threads producing output at
	//   the same time.
	//
	if ( (Semaphore = CreateSemaphore( NULL,1,MaxCpus,"Print" )) != NULL)
        {
		//
		//   Wait for the global semaphore.
		//
		if 
				( 
				WaitForSingleObject( Semaphore,INFINITE ) 
					== 
				WAIT_OBJECT_0 
				)
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 CurrentSize = 0;
			REGISTER SBIT32 GrandTotal = 0;
			REGISTER SBIT32 HighWater = 0;
			REGISTER SBIT32 Total = 0;

			//
			//   Output the titles to the debug console.
			//
			DebugPrint
				( 
				"\n"
				"  Original    New      Bucket    High   "
				"   Cache    Cache     Partial    Grand\n" 
				"    Size    Allocs      Size     Water  "
				"   Fills   Flushes     Total     Total\n"
				);

			//
			//   Output details for every sample size.
			//
			for ( Count=0;Count < MaxCacheSize;Count ++ )
				{
				REGISTER SBIT32 Hits = Statistics[ Count ]; 

				//
				//   Skip the sample if there are no hits.
				//
				if ( Hits > 0 )
					{
					REGISTER CACHE *Cache = FindCache( (Count+1) );
					REGISTER SBIT32 CacheSize = Cache -> GetAllocationSize();

					//
					//   Zero the running totals at the end
					//   of each bucket.
					//
					if ( CurrentSize != CacheSize )
						{
						CurrentSize = CacheSize;
						Total = 0;

						DebugPrint
							( 
							"----------------------------------------"
							"--------------------------------------\n" 
							);
						}

					//
					//   Compute and output the totals.
					//
					if ( Total == 0)
						{ HighWater += (Cache -> GetHighWater() * CacheSize); }

					Total += Hits;
					GrandTotal += Hits;

					DebugPrint
						(
						"%8d  %8d  %8d  %8d  %8d  %8d  %8d  %8d\n",
						(Count + 1),
						Hits,
						CacheSize,
						Cache -> GetHighWater(),
						Cache -> GetCacheFills(),
						Cache -> GetCacheFlushes(),
						Total,
						GrandTotal
						); 
					}
				}

			//
			//   Print the hash table statistics.
			//
			DebugPrint( "\nHash Table Statistics" );
			DebugPrint( "\n---------------------\n" );

			DebugPrint
				(
				"\t*** Cache ***\n"
				"\tFills\t\t: %d\n\tHits\t\t: %d\n\tMisses\t\t: %d\n"
				"\t*** Table ***\n"
				"\tAverage\t\t: %d\n\tMax\t\t: %d\n\tScans\t\t: %d\n"
				"\tMax Hash\t: %d\n\tMax LookAside\t: %d\n\tUsage\t\t: %d%%\n",
				Find -> CacheFills(),
				Find -> CacheHits(),
				Find -> CacheMisses(),
				Find -> AverageHashLength(),
				Find -> MaxHashLength(),
				Find -> TotalScans(),
				Find -> MaxHashSize(),
				Find -> MaxLookAsideSize(),
				Find -> MaxUsage()
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nOversize Statistics" );
			DebugPrint( "\n-------------------\n" );

			DebugPrint
				(
				"\tAverage Size\t: %d\n\tMax Size\t: %d\n\tMisses\t\t: %d\n",
				(TotalNewSize / ((NewMisses > 0) ? NewMisses : 1)),
				MaxNewSize,
				NewMisses
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nRealloc Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tAverage Copy\t: %d\n\tCalls\t\t: %d\n\tMax Copy\t: %d\n"
				"\tTotal Copies\t: %d\n",
				(TotalCopySize / ((CopyMisses > 0) ? CopyMisses : 1)),
				Reallocations,
				MaxCopySize,
				CopyMisses
				);

			//
			//   Print the general statistics.
			//
			DebugPrint( "\nSummary Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tHigh Water\t: %d\n",
				HighWater
				);
			}
		else
			{ Failure( "Sleep failed in PrintDebugStatistics" ); }

		//
		//   Release the global semaphore.
		//
		ReleaseSemaphore( Semaphore,1,NULL );

		CloseHandle( Semaphore );
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We have been asked to reallocate some memory.  Hopefully,      */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket, do a copy and free the orginal allocation.             */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::Resize
		( 
		VOID						  *Address,
		SBIT32						  NewSize,
		SBIT32						  Move,
		SBIT32						  *Space,
		BOOLEAN						  NoDelete,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Size;
		AUTO SBIT32 NewSpace;

		//
		//   Find the details of the existing allocation.
		//   If there is no existing allocation then exit.
		//
		if ( Details( Address,& Size ) )
			{
			REGISTER VOID *NewMemory;
			REGISTER SBIT32 Smallest = ((Size < NewSize) ? Size : NewSize);

			//
			//   Make sure the sizes appear to make sense.
			//
			if ( Smallest > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the statistics.
				//
				Reallocations ++;

#endif
				//
				//   When the new allocation allocation is 
				//   standard heap allocation size we check 
				//   for various optimizations.
				//
				if ( NewSize <= MaxCacheSize )
					{
					REGISTER CACHE *Cache = (FindCache( NewSize ));
					REGISTER SBIT32 CacheSize = (Cache -> GetAllocationSize());
					REGISTER SBIT32 Delta = (CacheSize - Size);
					
					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   We need to allocate some more
						//   memory and copy the old data.
						//   into the new area.
						//
						NewMemory = (Cache -> New());
						NewSpace = CacheSize;
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the statistics.
						//
						Statistics[ (NewSize-1) ] ++;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				else
					{
					REGISTER SBIT32 Delta = (NewSize - Size);

					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   One of the sizes is not within the
						//   allocation range of the heap.  So
						//   I have to punt and reallocate.
						//   
						NewMemory = 
							(
							ExternalCache -> New
								( 
								False,
								(NewSpace = NewSize)
								)
							);
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the allocation statistics.
						//
						if ( NewSize > MaxNewSize )
							{ MaxNewSize = NewSize; }

						NewMisses ++;
						TotalNewSize += NewSize;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				
				//
				//   We need to make sure we were able to allocate
				//   the new memory otherwise the copy will fail.
				//
				if ( NewMemory != ((VOID*) AllocationFailure) )
					{
					//
					//   Copy the contents of the old allocation 
					//   to the new allocation.
					//
					memcpy
						( 
						((void*) NewMemory),
						((void*) Address),
						((int) Smallest) 
						);

					//
					//   If needed return the actual amount of  
					//   space allocated for this request.
					//
					if ( Space != NULL )
						{ (*Space) = NewSpace; }

					//
					//   Delete the old allocation unless we
					//   need to keep it around.
					//
					if ( ! NoDelete )
						{
						//
						//   Delete the old allocation.
						//
						if ( ! Delete( Address,Size ) )
							{ Failure( "Deleting allocation in Resize" ); }
						}

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 Difference = (NewSpace - Smallest);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) NewMemory);

							ZeroMemory( & Array[ Smallest ],Difference ); 
							} 
						}	
#ifdef ENABLE_HEAP_STATISTICS

					//
					//   Update the allocation statistics.
					//
					if ( Smallest > MaxCopySize )
						{ MaxCopySize = Smallest; }

					CopyMisses ++;
					TotalCopySize += Smallest;
#endif
					}

				return NewMemory;
				}
			}
		}

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This pretty much a do nothing   */
    /*   as we do this automatically anyway.  The only thing we can     */
    /*   do is free any space the user suggested keeping earlier.       */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Truncate( SBIT32 MaxFreeSpace )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Flush all the caches and to free up
		//   as much space as possible.
		//
		for ( Count=0;Count < CachesSize;Count ++ )
			{
			Result =
				(
				(Caches[ Count ] -> Truncate())
					&&
				(Result)
				); 
			}

		//
		//   We slave all available free space in the top
		//   bucket so force it to be released.
		//
		TopCache -> ReleaseSpace
			(
			(MaxFreeSpace / (TopCache -> GetAllocationSize()))
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We release the locks so others can use the heap.               */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::UnlockAll( BOOLEAN Partial )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   Decrement the per thread lock count.
		//
		Find -> DecrementLockCount();

		//
		//   We release the locks only if we have claimed 
		//   them earlier.
		//
		if ( (Find -> GetLockCount()) == 0 )
			{
			//
			//   Now release all the heap locks we claimed
			//   earlier and unfreeze the heap.
			//
			NewPage -> ReleaseNewPageLock();

			Find -> ReleaseFindExclusiveLock();

			//
			//   When we destroy the heap we hold on
			//   to the cache locks to prevent errors.
			//
			if ( ! Partial )
				{
				REGISTER SBIT32 Count;

				//
				//   Now release all the cache locks we claimed
				//   earlier and unfreeze the cache.
				//
				for ( Count=0;Count < CachesSize;Count ++ )
					{ Caches[ Count ] -> ReleaseCacheLock(); }
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify of a memory allocation.                                 */
    /*                                                                  */
    /*   We need to verify the details of a memory allocation.          */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.  Finally, we check that the element       */
    /*   is not in the cache waiting to be allocated or freed.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Check( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SEARCH_PAGE Details;
		AUTO SBIT32 NewSize;

		//
		//   We extract the size of the allocation and  
		//   any associated allocation information.
		//   to see if it is present.
		//
		if ( Find -> Details( Address,& Details,TopCache,& NewSize ) )
			{
			//
			//   We need to be careful to make sure this 
			//   element is actually allocated.
			//
			if ( Details.Found )
				{
				//
				//   We know that the element appears to be 
				//   allocated but it may be in the cache
				//   somewhere so ensure this is not the case.
				//
				if ( (NewSize > 0) && (NewSize <= MaxCacheSize) )
					{
					if ( Details.Cache -> SearchCache( Address ) )
						{ return False; }
					}

				//
				//   We have shown that the element is active
				//   so return the size if requested.
				//
				if ( Size != NULL )
					{ (*Size) = NewSize; }

				return True;
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		SBIT32						  *Size 
		)
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We walk the heap and find the next allocation
		//   along with some basic information.
		//
		if ( Find -> Walk( Active,Address,TopCache,Size ) )
			{
			//
			//   We know that the element appears to be 
			//   allocated but it may be in the cache
			//   somewhere so ensure this is not the case.
			//
			if ( ((*Size) > 0) && ((*Size) <= MaxCacheSize) )
				{
				if ( FindCache( (*Size) ) -> SearchCache( (*Address) ) )
					{ (*Active) = False; }
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   We would like to destroy the heap at the end of the run        */
    /*   just to be tidy.  However, to do this we need to know that     */
    /*   all of the other destructors have been called and that the     */
    /*   application will not request more memory or use any existing   */
    /*   allocations.  We can't know this without help from the         */
    /*   compiler and OS.                                               */
    /*                                                                  */
    /********************************************************************/

HEAP::~HEAP( VOID )
	{
	REGISTER SBIT32 Count;

	//
	//   We mark the heap as inactive.
	//
	Active = False;

	//
	//   We claim all of the heap locks to freeze
	//   all new allocations or deletions.
	//
	LockAll();

	//
	//   Now reset all the caches.
	//
	for ( Count=0;Count < CachesSize;Count ++ )
		{ Caches[ Count ] -> DeleteAll(); }

	//
	//   Delete the heap.
	//
	NewPage -> DeleteAll( False );

	//
	//   We release any of the shared locks we 
	//   cliamed earlier.
	//
	UnlockAll( True );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Deal with heap statistics.
	//
	if ( Statistics != NULL ) 
		{
		//
		//   Print all the statistics.
		//
		PrintDebugStatistics();

		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) Statistics),
			(MaxCacheSize * sizeof(SBIT32)),
			False
			); 
		}
#endif

	//
	//   Delete the heap mapping tables.
	//
	if ( SizeToCache1 != NULL ) 
		{ 	
		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) SizeToCache1),
			(MaxTable1 + MaxTable2),
			False
			); 
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\newpagelist.hpp ===
#ifndef _NEW_PAGE_LIST_HPP_
#define _NEW_PAGE_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "FindList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The new page list.                                             */
    /*                                                                  */
    /*   The new page list links all the memory allocated by the low    */
    /*   level external allocator, or sub-divided pages or free pages   */
    /*   so they can be quickly found.                                  */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE_LIST : public FIND_LIST
    {
		//
		//   Private data.
		//
 		LIST						  NewPageList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        NEW_PAGE_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromNewPageList( LIST *HeadOfList )
			{ NewPageList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfNewPageList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInNewPageList( LIST *HeadOfList )
			{ NewPageList.Insert( HeadOfList ); }

		STATIC INLINE PAGE *LastInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> Last()) ); }

		INLINE PAGE *NextInNewPageList( VOID )
			{ return ComputePageAddress( ((CHAR*) NewPageList.Next()) ); }

        ~NEW_PAGE_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(FIND_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE_LIST( CONST NEW_PAGE_LIST & Copy );

        VOID operator=( CONST NEW_PAGE_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\newpage.hpp ===
#ifndef _NEW_PAGE_HPP_
#define _NEW_PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Page.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here relate to various failure          */
    /*   conditions or situations where information is unknown.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 NoSizeKey				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Create and delete pages.                                       */
    /*                                                                  */
    /*   We would normally expect a class to manage its own memory.     */
    /*   However, this is quite difficult for the 'PAGE' class as it    */
    /*   is also responsible for managing the memory for the memory     */
    /*   allocator.  So here we remove a potentially nasty chore        */
    /*   and isolate it in a class of its own.                          */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE : public ENVIRONMENT, public COMMON
    {
		//
		//   Private structures.
		//
		//   All the pages descriptions created by this
		//   class and managed by the memory allocator
		//   are linked in three list.  One of these lists
		//   is managed by this class and is called the
		//   'NewPageList'.  All pages are linked into 
		//   of three sub-lists.  The 'ExternalList' is
		//   a list of pages externally allocated pages.
		//   The 'FullList' is a list of sub-allocated
		//   space from the 'ExternalList' which is 
		//   partially or completely filled with alocations.
		//   Finally, the 'FreeList' is a collection of
		//   empty page descriptions all of the same size.
		//   
		//
		typedef struct
			{
			SBIT32                    Elements;
			LIST					  ExternalList;
			LIST					  FreeList;
			LIST					  FullList;
			SBIT32                    Size;
			}
		NEW_PAGES;
		
		//
		//   Private data.
		//
		//   We manage a collection of data structures in
		//   this class.  The fundamental data structure
		//   is a stack of externally allocated pages that
		//   typically contain page descriptions that are
		//   linked together into linked lists.  The maximum
		//   size of this stack is given by 'MaxStack'. 
		//   A few additional pages are consumed to allocate
		//   stacks for caches in other classes.
		//
		SBIT32						  MaxCacheStack;
		SBIT32						  MaxNewPages;
		SBIT32						  MaxStack;

		//
		//   We keep track of various values to save having
		//   to recompute them.  The 'NaturalSize' is the 
		//   natural allocation size of our host (i.e. the OS).
		//   The 'RootSize' is some multiple of the 
		//   'NaturalSize' that this class uses to consume 
		//   memory.  The 'ThreadSafe' flag indicates whether
		//   we need to use locks.  The "TopOfStack' is the
		//   stack which contains pointers to the externally
		//   allocated space.  The 'Version' is the global
		//   version number that is used to stamp each page
		//   whenever it is allocated or deallocated.  The
		//   version number allows the code to ensure that
		//   a page description has not been changed while
		//   it was not holding the associated lock.
		//   
		SBIT32						  NaturalSize;
		SBIT32						  RootCoreSize;
		SBIT32						  RootStackSize;
		BOOLEAN						  ThreadSafe;
		SBIT32						  TopOfStack;
		SBIT32						  Version;

		//
		//   We keep pointers to all the interesting data
		//   structures we may need to update.  The
		//   'CacheStack' points to block of memory that
		//   is being sliced into small stacks for caches
		//   in other classes.  The 'NewPages' points to
		//   an array of linked lists of page descriptions.
		//   Each collection of page descriptions is 
		//   identical except for the size of the assocated
		//   bit vector.
		//
		CHAR						  *CacheStack;
 		NEW_PAGES					  *NewPages;
		VOID                          **Stack;

		//
		//   We sometimes need to interact with some of
		//   the other class.  The 'Find" class is a hash
		//   table of all the currently allocated pages.
		//   The 'Rockall' class contains the external
		//   API which includes the external memory memory
		//   allocation functions.  The 'TopCache' is the
		//   largest cache we support and contains details
		//   about top level allocations sizes.
		//
		FIND						  *Find;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;

		SPINLOCK                      Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The public functions provide support for creating
		//   new page descriptions and caches for other 
		//   classes.  Although a lot of the fuinctionality
		//   of the heap is masked from this class various
		//   features such as deleting the entire heap
		//   (i.e. 'DeleteAll') are still visable.
		//
        NEW_PAGE
			(
			FIND					  *NewFind,
			SBIT32					  NewPageSizes[],
			ROCKALL					  *NewRockall,
			SBIT32					  Size,
			BOOLEAN					  NewThreadSafe 
			);

		PAGE *CreatePage( CACHE *Cache,SBIT32 NewSize = NoSize );

		VOID DeleteAll( BOOLEAN Recycle );

		VOID DeletePage( PAGE *Page );

		SBIT16 FindSizeKey( SBIT16 NumberOfElements );

		VOID *NewCacheStack( SBIT32 Size  );

		VOID ResizeStack( VOID );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~NEW_PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The public inline functions are typically either
		//   small or highly performance sensitive.  The
		//   functions here mainly relate to locking and
		//   updating various data structures.
		//
		INLINE VOID ClaimNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE VOID ReleaseNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE VOID UpdateNewPage( CACHE *NewTopCache )
			{ TopCache = NewTopCache; }

	private:
		//
		//   Private functions.
		//
		//   We support the overloading of the external
		//   memory allocation routines.  This is somewhat
		//   unusual and means that we need to Verify
		//   that these functions do not supply us with
		//   total rubbish.
		//
		VOID *VerifyNewArea( SBIT32 AlignMask,SBIT32 Size );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE( CONST NEW_PAGE & Copy );

        VOID operator=( CONST NEW_PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\page.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here allow the allocation bit vector    */
    /*   to be rapidly searched for free storage.                       */
    /*                                                                  */
    /********************************************************************/

CONST BIT32 AllocatedMask			  = 0x2;
CONST BIT32 FullSearchMask			  = 0xaaaaaaaa;
CONST BIT32 FullWordShift			  = (MaxBitsPerWord - OverheadBits);
CONST BIT32 SubDividedMask			  = 0x1;
CONST BIT32 WordSearchMask			  = (AllocatedMask << FullWordShift);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*                                                                  */
    /*   All page descriptions are actually created and deleted by      */
    /*   a separate class called 'NEW_PAGE'.  Nonetheless, as a         */
    /*   step the appropriate constructors and destructors are          */
    /*   invoked to support the standard C++ programming methodology.   */
    /*                                                                  */
    /********************************************************************/

PAGE::PAGE
		( 
		VOID						  *NewAddress,
		CACHE						  *NewCache,
		SBIT32						  NewPageSize, 
		CACHE						  *NewParentPage,
		SBIT32						  NewVersion 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER SBIT16 NumberOfElements = (NewCache -> GetNumberOfElements());
	REGISTER SBIT16 SizeOfElements = (NewCache -> GetSizeOfElements());

	//
	//   Create a page description.
	//
	Address = (CHAR*) NewAddress;
	PageSize = NewPageSize;
	Version = NewVersion;

	Allocated = 0;
	Available = NumberOfElements;
	FirstFree = 0;

	//
	//   Set up the pointers to related classes.
	//
	Cache = NewCache;
	ParentPage = NewParentPage;

	//
	//   Zero the bit vector.
	//
	for ( Count=0;Count < SizeOfElements;Count ++ )
		{ Vector[ Count ] = 0; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the actual size.                                       */
    /*                                                                  */
    /*   Almost all allocation sizes are derived from the associated    */
    /*   caches.  However, there are a few special pages that contain   */
    /*   a single allocation of some weird size.                        */
    /*                                                                  */
    /********************************************************************/

SBIT32 PAGE::ActualSize( VOID )
	{
	return
		(
		(ParentPage == ((CACHE*) GlobalRoot))
			? PageSize
			: (Cache -> GetAllocationSize())
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete an allocation.                                          */
    /*                                                                  */
    /*   We need to delete the memory allocation described by the       */
    /*   parameters.  However, as we are of an untrusting nature        */
    /*   we carefully check the request to ensure it is valid.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Delete( SEARCH_PAGE *Details )
    {
	//
	//   We know that no one would deallocate memory
	//   they had not previously allocated (yea - right).
	//   So here we check for this case.
	//
	if ( (*Details -> VectorWord) & Details -> AllocationMask )
		{
		//
		//   Nasty: it is possible for the user to give us an
		//   address that points to the middle of the element
		//   to be freed instead of the beginning.  This is no
		//   problem for us but we have to ponder whether the
		//   caller knew what they were doing.  If this is the 
		//   case we fail the request.
		//
		if ( Details -> Found )
			{
			//
			//   We have found that the element is allocated
			//   (as one might expect) so lets deallocate it 
			//   and update the various counters.
			//
			(*Details -> VectorWord) &= 
				~(Details -> AllocationMask | Details ->SubDivisionMask);

			//
			//   We may need to push back the pointer to the 
			//   first free element.  This will ensure that
			//   we can quickly locate the freed element for  
			//   later so we can reuse it.
			//
			if ( FirstFree > Details -> VectorOffset )
				{ FirstFree = ((SBIT16) Details -> VectorOffset); }

			//
			//   If the page was full and now has an empty
			//   slot then add it to the bucket list so that
			//   the free space can be found.
			//
			if ( Full() )
				{ Cache -> InsertInBucketList( this ); }

			//
			//   Update the allocation information.
			//
			Allocated --;
			Available ++;

			//
			//   If the page is now empty then delete 
			//   the page to conserve space.
			//
			if ( Empty() ) 
				{
				//
				//   We immediately delete empty pages
				//   except at the top level where it is
				//   under user control.
				//
				if ( ! Cache -> TopCache() )
					{ Cache -> DeletePage( this ); }
				else
					{
					REGISTER SBIT32 MaxFreePages = 
						(Cache -> GetHeap() -> GetMaxFreePages());

					((BUCKET*) Cache) -> ReleaseSpace( MaxFreePages );
					}
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete all simple allocations.                                 */
    /*                                                                  */
    /*   Although this routine may seem insignificant its effects are   */
    /*   dramatic.  When called this function deletes all the none      */
    /*   sub-allocated elements and updates the control values.         */
    /*                                                                  */
    /********************************************************************/

VOID PAGE::DeleteAll( VOID )
    {
	REGISTER BOOLEAN PageFull = Full();

	//
	//   Simply reset the allocation counts.
	//
	Allocated = 0;
	Available = (Cache -> GetNumberOfElements());
	FirstFree = 0;

	//
	//   We know that if this cache does not have any
	//   child allocations that it is safe to simply
	//   zero the bit vector.  If not we have to do it
	//   the long way.
	//
	if ( Cache -> GetNumberOfChildren() > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   We examine each word of the bit vector 
		//   and delete all the elements that are
		//   not sub-divided into smaller sizes.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{
			REGISTER BIT32 *Word = & Vector[ Count ];
			REGISTER BIT32 AllAllocations = ((*Word) & FullSearchMask);
			REGISTER BIT32 AllSubDivided = ((*Word) & (AllAllocations >> 1));
			REGISTER BIT32 FinalMask = (AllSubDivided | (AllSubDivided << 1));

			//
			//   Delete all normal allocations.
			//
			(*Word) &= FinalMask;

			//
			//   If the final mask is not zero then
			//   we still have some allocations active.
			//   We need to count these and update the
			//   control information.
			//
			if ( FinalMask != 0 )
				{
				REGISTER SBIT32 Total = 0;

				//
				//   Count the allocations.
				//
				for ( /* void */;FinalMask != 0;FinalMask >>= OverheadBits )
					{ Total += (FinalMask & 1); }

				//
				//   Update the control information.
				//
				Allocated = ((SBIT16) (Allocated + Total));
				Available = ((SBIT16) (Available - Total));
				}
			}
		}
	else
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Zero the bit vector.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{ Vector[ Count ] = 0; }
		}

	//
	//   If the page was full and now has empty
	//   slots then add it to the bucket list so 
	//   that the free space can be found.
	//
	if ( (PageFull) && (! Full()) )
		{ Cache -> InsertInBucketList( this ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find an allocation page.                                       */
    /*                                                                  */
    /*   When we receive a request to delete an allocation we don't     */
    /*   have a clue about where to find it.  All we have is a hash     */
    /*   table (see 'FIND') of allocated pages.  So we mask off the     */
    /*   low order bits of the address and try to find the top level    */
    /*   external allocation.  If this works we see if the area we      */
    /*   are looking at has been sub-divided and if so we try the       */
    /*   same trick again until we get the the origibal allocation      */
    /*   page.                                                          */
    /*                                                                  */
    /********************************************************************/

PAGE *PAGE::FindPage( VOID *Memory,SEARCH_PAGE *Details,BOOLEAN Recursive )
    {
	//
	//   We navigate through the pages trying to find
	//   the allocation page associated with the address.
	//   If we find a page that has no children then 
	//   we can assume we have arrived and exit early 
	//   unless the caller has requested all the realated 
	//   details.
	//
	if ( (Cache -> GetNumberOfChildren() > 0) || (Details != NULL) )
		{
		AUTO BOOLEAN Found;
		REGISTER SBIT32 Displacement = 
			((SBIT32) (((CHAR*) Memory) - Address));
		REGISTER SBIT32 ArrayOffset = 
			(Cache -> ComputeOffset( Displacement,& Found ));
		REGISTER SBIT32 VectorOffset = 
			(ArrayOffset / OverheadBitsPerWord);
		REGISTER SBIT32 WordOffset = 
			(ArrayOffset - (VectorOffset * OverheadBitsPerWord));
		REGISTER SBIT32 WordShift = 
			(((OverheadBitsPerWord-1) - WordOffset) * OverheadBits);
		REGISTER BIT32 AllocationMask = 
			(AllocatedMask << WordShift);
		REGISTER BIT32 SubDivisionMask = 
			(SubDividedMask << WordShift);
		REGISTER BIT32 *VectorWord = 
			& Vector[ VectorOffset ];

		//
		//  We will recursively search and find the target 
		//  address if requested otherwise we will just 
		//  return the details of the next level in the tree.
		//
		if 
				(
				(Recursive)
					&&
				((*VectorWord) & AllocationMask)
					&&
				((*VectorWord) & SubDivisionMask)
				)
			{
			REGISTER PAGE *Page = (Cache -> FindChildPage( Memory ));

			//
			//   We have found the element and checked it. 
			//   So lets pass this request on to the
			//   child page.  However, there is a slight
			//   chance of a race condition here.  It
			//   might be that the original page was
			//   deleted and a new page is currently
			//   being created.  If this is the case
			//   then we will not find the page in the 
			//   hash table so we just exit and fail the 
			//   call.
			//
			if ( Page != ((PAGE*) NULL) )
				{ return (Page -> FindPage( Memory,Details,Recursive )); }
			else
				{ return NULL; }
			}

		//
		//   We see if the caller is interested in the
		//   details relating to this address at the
		//   current level in the tree.
		//
		if ( Details != NULL )
			{
			//
			//   We have computed the details relating
			//   to this address at the current level
			//   in the tree so load them into the
			//   caller supplied structure.
			//
			Details -> Address = Memory;
			Details -> Cache = Cache;
			Details -> Found = Found;
			Details -> Page = this;

			Details -> AllocationMask = AllocationMask;
			Details -> SubDivisionMask = SubDivisionMask;
			Details -> VectorWord = VectorWord;

			Details -> ArrayOffset = ArrayOffset;
			Details -> VectorOffset = VectorOffset;
			Details -> WordShift = WordShift;
			}
		}

	return this;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate available memeory elements from a page.  This is      */
    /*   done by scanning the bit vector looking for unallocated        */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate and that we need to
	//   allocated at least one element.
	//
	if ( (! Full()) && ((*Actual) < Requested) )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slots.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER SBIT32 ArrayOffset = (FirstFree * OverheadBitsPerWord);
			REGISTER BIT32 AvailableMask = WordSearchMask;
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];
			REGISTER SBIT32 WordOffset = 0;

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			while ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 Value = (*VectorWord);

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = (ArrayOffset + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bits indicating that this
						//   element is in use.
						//
						(*VectorWord) |= AvailableMask;

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Add the element to the allocation array
						//   so it can be returned to the caller.
						//
						Array[ (Requested - ((*Actual) ++) - 1) ] =
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);

						//
						//   When we have got what we need we exit.
						//
						if ( ((*Actual) >= Requested) )
							{ return True; }
						}
					else
						{ break; }
					}
				else
					{ Failure( "Bit vector is corrupt in MultipleNew" ); }
				}
			}
		}

	return ((*Actual) >= Requested);
    }

    /********************************************************************/
    /*                                                                  */
    /*   A single memory allocation.                                    */
    /*                                                                  */
    /*   Allocate an available memeory element from the page.  This     */
    /*   is done by scanning the bit vector looking for unallocated     */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

VOID *PAGE::New( BOOLEAN SubDivided )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate.
	//
	if ( ! Full() )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slot.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			if ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 AvailableMask = WordSearchMask;
				REGISTER BIT32 Value = (*VectorWord);
				REGISTER SBIT32 WordOffset = 0;

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = 
						((FirstFree * OverheadBitsPerWord) + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bit indicating that this
						//   element is in use.  If the allocation 
						//   is to be sub-divided then trun on this
						//   bit as well.
						//
						(*VectorWord) |=
							(
							AvailableMask
								|
							(SubDivided ? (AvailableMask >> 1) : 0)
							);

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Return the address of the allocated 
						//   memory to the caller.
						//
						return
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);
						}
					}
				else
					{ Failure( "Bit vector is corrupt in New" ); }
				}
			}
#ifdef DEBUGGING

		if ( ! Full() )
			{ Failure( "Available count corrupt in New" ); }
#endif
		}

	return ((VOID*) AllocationFailure);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Walk( SEARCH_PAGE *Details )
    {
	REGISTER BOOLEAN FreshPage = False;

	//
	//   We have been handed the details of an allocation.
	//   We need to walk along this allocation and find
	//   the next non-subdivided allocation.
	do
		{
		//
		//   We need to setup the heap walk if the address
		//   is null so we skip the heap walk code.
		//
		if ( Details -> Address != NULL )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 End = Details -> Cache -> GetNumberOfElements();
			REGISTER SBIT32 Start = Details -> ArrayOffset;
			REGISTER PAGE *Page = Details -> Page;

			//
			//   Walk the current page looking for a suitable
			//   memory allocation to report to the user.  When
			//   we reach the end of the page we need to get
			//   another page to walk.
			//
			for 
					(
					Count = ((FreshPage) ? 0 : 1);
					(Start + Count) < End;
					Count ++
					)
				{
				//
				//   Compute the new address.
				//
				Details -> Address = 
					(
					Page -> Cache -> ComputeAddress
						( 
						Page -> Address,
						(Start + Count)
						)
					);

				//
				//   Compute the new allocation details.
				//
				Page -> FindPage
					( 
					Details -> Address,
					Details,
					False 
					);

				//
				//   We skip all sub-divided allocations as they 
				//   will get reported elsewhere.
				//
				if (! ((*Details -> VectorWord) & Details -> SubDivisionMask) )
					{ return True; }
				}
			}

		//
		//   Update the flag to show that we have
		//   had to go and get a new page.
		//
		FreshPage = True;
		}
	while ( Details -> Cache -> Walk( Details ) );

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current page structure.                            */
    /*                                                                  */
    /********************************************************************/

PAGE::~PAGE( VOID )
	{
#ifdef DEBUGGING
	//
	//   Destroy the page structure.
	//
	Address = NULL;
	PageSize = 0;
	ParentPage = NULL;

	Allocated = 0;
	Available = 0;
	FirstFree = 0;

#endif
	//
	//   We update the version number whenever a page is created
	//   or destroyed.  We use the version number to ensure that
	//   a page has not been deleteed and/or recreated between
	//   releasing one lock and claiming a another other lock.
	//
	Version ++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\interfacepch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Size;
			int						  StartGuard;
			}
		DEBUG_HEADER;

		typedef struct
			{
			char					  MidGuard[ sizeof(int) ];
			int						  EndGuard[1];
			}
		DEBUG_TRAILER;

		typedef struct
			{
			DEBUG_HEADER			  DebugHeader;
			DEBUG_TRAILER			  DebugTrailer;
			}
		DEBUG_GUARD;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Check
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void HeapLeaks( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~DEBUG_HEAP( void );

	private:
		//
		//   Private functions.
		//
		//   A debug heap verifies each allocation using a 
		//   collection of private functions.
		//
		DEBUG_HEADER *ComputeHeaderAddress( void *Address )
			{
			register int HeaderSize = sizeof(DEBUG_HEADER);

			return ((DEBUG_HEADER*) (((char*) Address) - HeaderSize)); 
			}

		void *ComputeDataAddress( DEBUG_HEADER *Header )
			{ return ((void*) & Header[1]); }

		void ResetGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

		void TestGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\heap\page.hpp ===
#ifndef _PAGE_HPP_
#define _PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "NewPageList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control the number of bits in      */
    /*   a page descriptions bit vector and its minimum size.           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxBitsPerWord			  = (sizeof(BIT32) * 8);
CONST SBIT32 MinVectorSize			  = 1;
CONST SBIT32 OverheadBits			  = 2;
CONST SBIT32 OverheadBitsPerWord	  = (MaxBitsPerWord / OverheadBits);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   The page descriptions supported by this class are at the       */
    /*   heart of the memory allocator.  These pages are linked in      */
    /*   various ways so they can be quickly found.  The following      */
    /*   structure contains the results of a search for a specific      */
    /*   memory address and its related page information.               */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	CACHE							  *Cache;
	BOOLEAN							  Found;
	PAGE							  *Page;

	BIT32							  AllocationMask;
	BIT32							  SubDivisionMask;
	BIT32							  *VectorWord;

	SBIT32							  ArrayOffset;
	SBIT32							  VectorOffset;
	SBIT32							  WordShift;
	}
SEARCH_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The page allocation mechanism.                                 */
    /*                                                                  */
    /*   The memory manager allocates storage in large chunks from      */
    /*   the external memory allocator.  It then sub-divides these      */
    /*   chunks into various sized pages and keeps track of these       */
    /*   allocations using a bit vector in each page description.       */
    /*                                                                  */
    /********************************************************************/

class PAGE : public NEW_PAGE_LIST
    {
		//
		//   Private data.
		//
		//   The page description contains various details
		//   about the page.  The 'Address' is the starting 
		//   address of the allocation page.  The 'PageSize'
		//   is typically empty but contains a value is the 
		//   page size is weird and not realted to the
		//   assocated bucket.  The 'Version' is a unique
		//   version number and is changed everytime a new
		//   page description is created or deleted.  This
		//   version number allows a thread to see if anyone
		//   has been significantly playing with a page  
		//   description since it last held the associated lock.
		//
		CHAR                          *Address;
		SBIT32						  PageSize;
		SBIT32						  Version;

		//
		//   We keep track of the number of elements that
		//   are currently 'Allocated' and 'Available' on
		//   the page.  Additionally, 'FirstFree' is the
		//   index of the first word in the bit vector that
		//   has at least one available slot.
		//
		SBIT16                        Allocated;
		SBIT16                        Available;
		SBIT16						  FirstFree;

		//
		//   We sometimes need to interact with other classes.
		//   The 'Cache' class typically owns a number of pages
		//   and keeps all the information about this size of
		//   allocation.  The 'ParentPage' is a pointer to 
		//   another cache from where this page was sub-allocated
		//   and where the space will need to be returned when
		//   it becomes free.
		//
		CACHE						  *Cache;
		CACHE						  *ParentPage;

		//
		//   The 'Vector' is the variable sized bit vector that
		//   contains allocation information.  Each allocation
		//   is recorded using 2 bits.  The first bit indicates
		//   whether the allocation is in use and the second bit
		//   indicates whether an active allocation has been 
		//   sub-divided into smaller chunks.  Any unused bits
		//   at the end of the final word are set to zero, assumed
		//   to be zero and should never be non-zero.
		//
		BIT32                         Vector[MinVectorSize];

   public:
		//
		//   Public functions.
		//
		//   The page description contains all the information
		//   relating to an allocation.  There is no information
		//   stored with the allocation itself.  A significant
		//   portion of the external API can find its way to
		//   this class if the many layers of caches fail to
		//   deal with the request first.
		//
        PAGE
			( 
			VOID					  *NewAddress,
			CACHE					  *NewCache,
			SBIT32					  NewPageSize,
			CACHE					  *NewParentPage,
			SBIT32					  NewVersion 
			);

		SBIT32 ActualSize( VOID );

		BOOLEAN Delete( SEARCH_PAGE *Details );

		VOID DeleteAll( VOID );

		PAGE *FindPage
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			BOOLEAN					  Recursive 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Available, 
			VOID					  *Array[],
			SBIT32					  Requested
			);

		VOID *New( BOOLEAN SubDivided );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The page class is so central to the entire memory
		//   allocator that a number of other classes need to
		//   get at certain data from time to time.  Thus, it 
		//   is necessary for both brevity and performance to
		//   provide inline function for certain critical 
		//   information relating to a page.
		//
		INLINE BOOLEAN Empty( VOID )
			{ return (Allocated <= 0); }

		INLINE BOOLEAN Full( VOID )
			{ return (Available <= 0); }

		INLINE VOID *GetAddress( VOID )
			{ return ((VOID*) Address); }

		INLINE CACHE *GetCache( VOID )
			{ return Cache; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE CACHE *GetParentPage( VOID )
			{ return ParentPage; }

		INLINE SBIT32 GetVersion( VOID )
			{ return Version; }

		INLINE BOOLEAN ValidPage( VOID )
			{ return ((BOOLEAN) ~(Version & 0x1)); }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE( CONST PAGE & Copy );

        VOID operator=( CONST PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\interfacepch.hpp ===
#ifndef _ROCKALL_PCH_HPP_
#define _ROCKALL_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "HeapPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\duser\engine\rockall\interface\debugheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DebugHeap.hpp"
#include "Heap.hpp"

void Failure( char* a);

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 512;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

CONST int GuardMask					  = (sizeof(int)-1);
CONST int GuardSize					  = sizeof(int);

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We make much use of the guard value in the
	//   debug heap so here we try to claim the 
	//   address but not commit it so we will cause
	//   an access violation if the program ever
	//   tries to access it.
	//
	VirtualAlloc
		( 
		((void*) GuardValue),
		GuardSize,
		MEM_RESERVE,
		PAGE_NOACCESS 
		);

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap initialization failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We make sure the memory is allocated and that the guard        */
    /*   words have not been damanged.  If so we reset the contents     */
    /*   of the allocation and delete the allocation.                   */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Delete( void *Address,int Size )
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to delete
	//   a null pointer.  This is really a very poor  
	//   style but we support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
			{
			REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Delete the allocation.  This really ought 
			//   to work given we have already checked that 
			//   the allocation is valid unless there is a  
			//   race condition.
			//
			if ( ! ROCKALL::Delete( ((void*) Header),NewSize ) )
				{ Failure( "Delete requested failed due to race" ); }

			//
			//   We ensure that the heap has not become corrupt
			//   during the deletion process.
			//
			if ( ROCKALL::Corrupt() ) 
				{ Failure( "Delete failed to complete" ); }
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::DeleteAll( bool Recycle )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   Delete the heap and force all the allocated
	//   memory to be returned to the operating system
	//   regardless of what the user requested.  Any
	//   attempt to access the deallocated memory will 
	//   be trapped by the operating system.
	//
	ROCKALL::DeleteAll( (Recycle && false) );

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "DeleteAll failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Details( void *Address,int *Space )
	{ return Check( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		CONST INT DebugBufferSize = 8192;
#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO CHAR Buffer[ DebugBufferSize ];

			//
			//   Format the string to be printed.
			//
			(void) sprintf
				(
				Buffer,
				"Memory leak \t%d \t0x%x \t%d\n",
				Active,
				(((SBIT32) Address) + sizeof(DEBUG_HEADER)),
				Space
				);

			//
			//   Force null termination.
			//
			Buffer[ (DebugBufferSize-1) ] = '\0';

			//
			//   Write the string to the debug window.
			//
			OutputDebugString( Buffer );
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   We make sure all the memory is allocated and that the guard    */
    /*   words have not been damaged.  If so we reset the contents      */
    /*   of the allocations and then delete all the allocations.        */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER int Count;
	REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

	//
	//   Examine each memory allocation and delete it
	//   after carefully checking it.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		AUTO int TotalSize;
		AUTO VOID *Address = Array[ Count ];
		AUTO DEBUG_HEADER *Header =
			(
			(Address == ((void*) AllocationFailure))
				? ((DEBUG_HEADER*) Address)
				: ComputeHeaderAddress( Address )
			);

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Update the address in the array to the
			//   address originally allocated.
			//
			Array[ Count ] = ((VOID*) Header);
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	//
	//   Delete the allocation.  This really ought 
	//   to work given we have already checked that 
	//   the allocations are valid unless there is a  
	//   race condition.
	//
	if ( ! ROCKALL::MultipleDelete( Actual,Array,NewSize ) )
		{ Failure( "Delete requested failed due to race" ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "MultipleDelete failed to complete" ); }

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate a collection of memory elements and setup the         */
    /*   guard information so we can check they have not been           */
    /*   damaged later.                                                 */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	REGISTER bool Result = false;

	//
	//   The requested number of elements and the size  
	//   must be greater than zero.  We require the 
	//   caller to allocate a positive amount of memory.
	//
	if ( (Requested > 0) && (Size >= 0) )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Result = 
			(
			ROCKALL::MultipleNew
				( 
				Actual,
				Array,
				Requested,
				NewSize,
				& TotalSize 
				)
			);

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER int Count;

			//
			//   If the real size is requested then return 
			//   it to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ 
				REGISTER void **Current = & Array[ Count ];

				//
				//   Set up the guard words and ensure
				//   the allocation has not been written
				//   since being freed.
				//
				SetGuardWords
					( 
					((DEBUG_HEADER*) (*Current)),
					((Space == NULL) ? Size : (*Space)), 
					TotalSize
					);

				//
				//   Compute the external address and place
				//   it back in the array.
				//
				(*Current) = ComputeDataAddress( ((DEBUG_HEADER*) (*Current)) );

				//
				//   Zero the memory if the needed.
				//
				if ( Zero )
					{ 
					ZeroMemory
						( 
						(*Current),
						((Space == NULL) ? Size : (*Space)) 
						); 
					}
				}
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "Multiple new failed to complete" ); }
		}
	else
		{ Failure( "Allocation size must greater than zero" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We add some space on to the original allocation size for       */
    /*   various information and then call the allocator.  We then      */
    /*   set the guard words so we can check for overruns.              */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::New( int Size,int *Space,bool Zero )
    {
	REGISTER void *Address = ((void*) AllocationFailure);

	//
	//   The size must be greater than or equal to zero.  
	//   We do not know how to allocate a negative amount
	//   of memory.
	//
	if ( Size >= 0 )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Address = ROCKALL::New( NewSize,& TotalSize,false );

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( Address != ((void*) AllocationFailure) ) 
			{
			//
			//   If the real size is requested then return it
			//   to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			SetGuardWords
				( 
				((DEBUG_HEADER*) Address),
				((Space == NULL) ? Size : (*Space)), 
				TotalSize
				); 

			//
			//   Compute the external address and place
			//   it back in the variable.
			//
			Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

			//
			//   Zero the allocation if needed.
			//
			if ( Zero )
				{ 
				ZeroMemory
					( 
					Address,
					((Space == NULL) ? Size : (*Space)) 
					); 
				} 
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "New failed to complete" ); }
		}
	else
		{ Failure( "Allocation size can not be negative" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::NewArea( int AlignMask,int Size,bool User )
    {
	REGISTER void *Memory = ROCKALL::NewArea( AlignMask,Size,User );

	//
	//   If we managed to get a new page then write
	//   the guard value over it to allow us to
	//   verify it has not been overwritten later.
	//
	if ( Memory != ((void*) AllocationFailure) )
		{
		REGISTER int Count;

		//
		//   Write the guard value into all of the new
		//   heap page to allow it to be checked for
		//   corruption.
		//
		for ( Count=0;Count < Size;Count += GuardSize )
			{ (((int*) Memory)[ (Count / GuardSize) ]) = GuardValue; }
		}
	
	return Memory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We need to resize an allocation.  We ensure the original       */
    /*   allocation was undamaged and then expand it.  We also          */
    /*   update the guard words to reflect the changes.                 */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to resize a null
	//   pointer.  This is really a very poor style but we 
	//   support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   The new size must be greater than or equal to  
		//   zero.  We do not know how to allocate a negative 
		//   amount of memory.
		//
		if ( NewSize >= 0 )
			{
			REGISTER int Size = 
				(((NewSize + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

			//
			//   Ask for the details of the allocation.  This 
			//   will fail if the memory is not allocated.
			//
			if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
				{
				REGISTER void *OriginalAddress = ((void*) Header);
				REGISTER int OriginalSize = TotalSize;

				//
				//   Test the guard words to make sure they have
				//   not been damaged.
				//
				TestGuardWords( Header,TotalSize );

				//
				//   Reallocate the memory plus some additional 
				//   memory for the guard words.
				//
				Address =
					(
					ROCKALL::Resize
						( 
						OriginalAddress,
						Size,
						Move,
						& TotalSize,
						true,
						false
						)
					);

				//
				//   If we were able to allocate some memory 
				//   then set the guard words so we can detect 
				//   any corruption later.
				//
				if ( Address != ((void*) AllocationFailure) )
					{
					REGISTER SBIT32 SpaceUsed = Header -> Size;

					//
					//   Delete the user information by writing 
					//   guard words over the allocation.  This
					//   should cause the application to crash
					//   if the area is read and allows us to
					//   check to see if it is written later.
					//
					if ( (! NoDelete) && (Address != OriginalAddress) )
						{
						ResetGuardWords( Header,OriginalSize );

						if ( ! ROCKALL::Delete( OriginalAddress ) )
							{ Failure( "Delete failed due to race" ); }
						}

					//
					//   If the real size is requested then 
					//   return it to the caller.
					//
					if ( Space != NULL )
						{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

					//
					//   Update the guard words so we can see 
					//   if someone damages the allocation.  If
					//   the caller requested the size information 
					//   then we must assume that it could be 
					//   used so we need to adjust the guard words.
					//
					UpdateGuardWords
						( 
						((DEBUG_HEADER*) Address),
						((Space == NULL) ? NewSize : (*Space)), 
						TotalSize
		