entLength) {

                //
                // What we want isn't in this buffer.
                //

                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;

            } else {

                VirtualAddress = (PCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;

            }

        }

        //
        // Copy the data.
        //


        {

            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            AmountToMove =
                       ((CurrentLength <= (BytesToCopy - LocalBytesCopied))?
                        (CurrentLength):(BytesToCopy - LocalBytesCopied));

            RtlCopyMemory(
                Buffer,
                VirtualAddress,
                AmountToMove
                );

            Buffer = (PCHAR)Buffer + AmountToMove;
            VirtualAddress = (PCHAR)VirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            CurrentLength -= AmountToMove;

        }

    }

    *BytesCopied = LocalBytesCopied;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\event.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiSetEventHandler

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NbfTdiSetEventHandler(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiSetEventHandler request for the
    transport provider.  The caller (request dispatcher) verifies
    that this routine will not be executed on behalf of a user-mode
    client, as this request enables direct callouts at DISPATCH_LEVEL.

Arguments:

    Irp - Pointer to the IRP for this request

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS rc=STATUS_SUCCESS;
    KIRQL oldirql;
    PTDI_REQUEST_KERNEL_SET_EVENT parameters;
    PIO_STACK_LOCATION irpSp;
    PTP_ADDRESS address;
    PTP_ADDRESS_FILE addressFile;
    NTSTATUS status;

    //
    // Get the Address this is associated with; if there is none, get out.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_TRANSPORT_ADDRESS_FILE) {
        return STATUS_INVALID_ADDRESS;
    }

    addressFile  = irpSp->FileObject->FsContext;
    status = NbfVerifyAddressObject (addressFile);
    if (!NT_SUCCESS (status)) {
        return status;
    }

    address = addressFile->Address;

    ACQUIRE_SPIN_LOCK (&address->SpinLock, &oldirql);

    parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)&irpSp->Parameters;

    switch (parameters->EventType) {

    case TDI_EVENT_RECEIVE:

        if (parameters->EventHandler == NULL) {
            addressFile->ReceiveHandler =
                (PTDI_IND_RECEIVE)TdiDefaultReceiveHandler;
            addressFile->ReceiveHandlerContext = NULL;
            addressFile->RegisteredReceiveHandler = FALSE;
        } else {
            addressFile->ReceiveHandler =
                (PTDI_IND_RECEIVE)parameters->EventHandler;
            addressFile->ReceiveHandlerContext = parameters->EventContext;
            addressFile->RegisteredReceiveHandler = TRUE;
        }

        break;

    case TDI_EVENT_RECEIVE_EXPEDITED:

        if (parameters->EventHandler == NULL) {
            addressFile->ExpeditedDataHandler =
                (PTDI_IND_RECEIVE_EXPEDITED)TdiDefaultRcvExpeditedHandler;
            addressFile->ExpeditedDataHandlerContext = NULL;
            addressFile->RegisteredExpeditedDataHandler = FALSE;
        } else {
            addressFile->ExpeditedDataHandler =
                (PTDI_IND_RECEIVE_EXPEDITED)parameters->EventHandler;
            addressFile->ExpeditedDataHandlerContext = parameters->EventContext;
            addressFile->RegisteredExpeditedDataHandler = TRUE;
        }

        break;

    case TDI_EVENT_RECEIVE_DATAGRAM:

        if (parameters->EventHandler == NULL) {
            addressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)TdiDefaultRcvDatagramHandler;
            addressFile->ReceiveDatagramHandlerContext = NULL;
            addressFile->RegisteredReceiveDatagramHandler = FALSE;
        } else {
            addressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)parameters->EventHandler;
            addressFile->ReceiveDatagramHandlerContext = parameters->EventContext;
            addressFile->RegisteredReceiveDatagramHandler = TRUE;
        }

        break;

    case TDI_EVENT_ERROR:

        if (parameters->EventHandler == NULL) {
            addressFile->ErrorHandler =
                (PTDI_IND_ERROR)TdiDefaultErrorHandler;
            addressFile->ErrorHandlerContext = NULL;
            addressFile->RegisteredErrorHandler = FALSE;
        } else {
            addressFile->ErrorHandler =
                (PTDI_IND_ERROR)parameters->EventHandler;
            addressFile->ErrorHandlerContext = parameters->EventContext;
            addressFile->RegisteredErrorHandler = TRUE;
        }

        break;

    case TDI_EVENT_DISCONNECT:

        if (parameters->EventHandler == NULL) {
            addressFile->DisconnectHandler =
                (PTDI_IND_DISCONNECT)TdiDefaultDisconnectHandler;
            addressFile->DisconnectHandlerContext = NULL;
            addressFile->RegisteredDisconnectHandler = FALSE;
        } else {
            addressFile->DisconnectHandler =
                (PTDI_IND_DISCONNECT)parameters->EventHandler;
            addressFile->DisconnectHandlerContext = parameters->EventContext;
            addressFile->RegisteredDisconnectHandler = TRUE;
        }

        break;

    case TDI_EVENT_CONNECT:

        if (parameters->EventHandler == NULL) {
            addressFile->ConnectionHandler =
                (PTDI_IND_CONNECT)TdiDefaultConnectHandler;
            addressFile->ConnectionHandlerContext = NULL;
            addressFile->RegisteredConnectionHandler = FALSE;
        } else {
            addressFile->ConnectionHandler =
                (PTDI_IND_CONNECT)parameters->EventHandler;
            addressFile->ConnectionHandlerContext = parameters->EventContext;
            addressFile->RegisteredConnectionHandler = TRUE;
        }
            break;

    default:

        rc = STATUS_INVALID_PARAMETER;

    } /* switch */

    RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

    NbfDereferenceAddress ("Set event handler", address, AREF_VERIFY);

    return rc;
} /* TdiSetEventHandler */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\info.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    info.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiQueryInformation
        o   TdiSetInformation

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Only the following routine is active in this module. All is is commented
// out waiting for the definition of Get/Set info in TDI version 2.
//

//
// Useful macro to obtain the total length of an MDL chain.
//

#define NbfGetMdlChainLength(Mdl, Length) { \
    PMDL _Mdl = (Mdl); \
    *(Length) = 0; \
    while (_Mdl) { \
        *(Length) += MmGetMdlByteCount(_Mdl); \
        _Mdl = _Mdl->Next; \
    } \
}


//
// Local functions used to satisfy various requests.
//

VOID
NbfStoreProviderStatistics(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTDI_PROVIDER_STATISTICS ProviderStatistics
    );

VOID
NbfStoreAdapterStatus(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN PVOID StatusBuffer
    );

VOID
NbfStoreNameBuffers(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG NamesToSkip,
    OUT PULONG NamesWritten,
    OUT PULONG TotalNameCount OPTIONAL,
    OUT PBOOLEAN Truncated
    );


NTSTATUS
NbfTdiQueryInformation(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Irp - the Irp for the requested operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID adapterStatus;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION query;
    PTA_NETBIOS_ADDRESS broadcastAddress;
    PTDI_PROVIDER_STATISTICS ProviderStatistics;
    PTDI_CONNECTION_INFO ConnectionInfo;
    ULONG TargetBufferLength;
    PFIND_NAME_HEADER FindNameHeader;
    LARGE_INTEGER timeout = {0,0};
    PTP_REQUEST tpRequest;
    PTP_CONNECTION Connection;
    PTP_ADDRESS_FILE AddressFile;
    PTP_ADDRESS Address;
    ULONG NamesWritten, TotalNameCount, BytesWritten;
    BOOLEAN Truncated;
    BOOLEAN RemoteAdapterStatus;
    TDI_ADDRESS_NETBIOS * RemoteAddress;
    struct {
        ULONG ActivityCount;
        TA_NETBIOS_ADDRESS TaAddressBuffer;
    } AddressInfo;
    PTRANSPORT_ADDRESS TaAddress;
    TDI_DATAGRAM_INFO DatagramInfo;
    BOOLEAN UsedConnection;
    PLIST_ENTRY p;
    KIRQL oldirql;
    ULONG BytesCopied;

    //
    // what type of status do we want?
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&irpSp->Parameters;

    switch (query->QueryType) {

#if 0
    case 0x12345678:

        {
            typedef struct _NBF_CONNECTION_STATUS {
                UCHAR LocalName[16];
                UCHAR RemoteName[16];
                BOOLEAN SendActive;
                BOOLEAN ReceiveQueued;
                BOOLEAN ReceiveActive;
                BOOLEAN ReceiveWakeUp;
                ULONG Flags;
                ULONG Flags2;
            } NBF_CONNECTION_STATUS, *PNBF_CONNECTION_STATUS;

            PNBF_CONNECTION_STATUS CurStatus;
            ULONG TotalStatus;
            ULONG AllowedStatus;
            PLIST_ENRY q;

            CurStatus = MmGetSystemAddressForMdl (Irp->MdlAddress);
            TotalStatus = 0;
            AllowedStatus = MmGetMdlByteCount (Irp->MdlAddress) / sizeof(NBF_CONNECTION_STATUS);

            for (p = DeviceContext->AddressDatabase.Flink;
                 p != &DeviceContext->AddressDatabase;
                 p = p->Flink) {

                Address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

                if ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
                    continue;
                }

                for (q = Address->ConnectionDatabase.Flink;
                     q != &Address->ConnectionDatabase;
                     q = q->Flink) {

                    Connection = CONTAINING_RECORD (q, TP_CONNECTION, AddressList);

                    if ((Connection->Flags & CONNECTION_FLAGS_READY) == 0) {
                        continue;
                    }

                    if (TotalStatus >= AllowedStatus) {
                        continue;
                    }

                    RtlMoveMemory (CurStatus->LocalName, Address->NetworkName->NetbiosName, 16);
                    RtlMoveMemory (CurStatus->RemoteName, Connection->RemoteName, 16);

                    CurStatus->Flags = Connection->Flags;
                    CurStatus->Flags2 = Connection->Flags2;
                    CurStatus->SendActive = (BOOLEAN)(!IsListEmpty(&Connection->SendQueue));
                    CurStatus->ReceiveQueued = (BOOLEAN)(!IsListEmpty(&Connection->ReceiveQueue));
                    CurStatus->ReceiveActive = (BOOLEAN)((Connection->Flags & CONNECTION_FLAGS_ACTIVE_RECEIVE) != 0);
                    CurStatus->ReceiveWakeUp = (BOOLEAN)((Connection->Flags & CONNECTION_FLAGS_RECEIVE_WAKEUP) != 0);

                    ++CurStatus;
                    ++TotalStatus;

                }
            }

            Irp->IoStatus.Information = TotalStatus * sizeof(NBF_CONNECTION_STATUS);
            status = STATUS_SUCCESS;

        }

        break;
#endif

    case TDI_QUERY_CONNECTION_INFO:

        //
        // Connection info is queried on a connection,
        // verify this.
        //

        if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
            return STATUS_INVALID_CONNECTION;
        }

        Connection = irpSp->FileObject->FsContext;

        status = NbfVerifyConnectionObject (Connection);

        if (!NT_SUCCESS (status)) {
#if DBG
            NbfPrint2 ("TdiQueryInfo: Invalid Connection %lx Irp %lx\n", Connection, Irp);
#endif
            return status;
        }

        ConnectionInfo = ExAllocatePoolWithTag (
                             NonPagedPool,
                             sizeof (TDI_CONNECTION_INFO),
                             NBF_MEM_TAG_TDI_CONNECTION_INFO);

        if (ConnectionInfo == NULL) {

            PANIC ("NbfQueryInfo: Cannot allocate connection info!\n");
            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_POOL,
                6,
                sizeof(TDI_CONNECTION_INFO),
                0);
            status = STATUS_INSUFFICIENT_RESOURCES;

        } else if ((Connection->Flags & CONNECTION_FLAGS_READY) == 0) {

            status = STATUS_INVALID_CONNECTION;
            ExFreePool (ConnectionInfo);

        } else {

            PTP_LINK Link = Connection->Link;

            RtlZeroMemory ((PVOID)ConnectionInfo, sizeof(TDI_CONNECTION_INFO));


            //
            // Get link delay and throughput.
            //

            if (Link->Delay == 0xffffffff) {

                //
                // If delay is not known, assume 0.
                //

                ConnectionInfo->Delay.HighPart = 0;
                ConnectionInfo->Delay.LowPart = 0;

            } else {

                //
                // Copy the delay as an NT relative time.
                //

                ConnectionInfo->Delay.HighPart = -1L;
                ConnectionInfo->Delay.LowPart = (ULONG)-((LONG)(Link->Delay));

            }

            if (DeviceContext->MacInfo.MediumAsync) {

                ULONG PacketsSent;
                ULONG PacketsResent;
                ULONG MultiplyFactor;

                //
                // Calculate the packets sent and resent since the
                // last time the throughput was queried.
                //

                PacketsSent = Link->PacketsSent - Connection->LastPacketsSent;
                PacketsResent = Link->PacketsResent - Connection->LastPacketsResent;

                //
                // Save these for next time.
                //

                Connection->LastPacketsSent = Link->PacketsSent;
                Connection->LastPacketsResent = Link->PacketsResent;

                //
                // To convert exactly from 100 bits-per-second to
                // bytes-per-second, we need to multiply by 12.5.
                // Using lower numbers will give worse throughput.
                // If there have been no errors we use 12, if there
                // have been 20% or more errors we use 1, and in
                // between we subtract 11 * (error%/20%) from 12
                // and use that.
                //

                if (PacketsResent == 0 || PacketsSent <= 10) {

                    MultiplyFactor = 12;

                } else if ((PacketsSent / PacketsResent) <= 5) {

                    MultiplyFactor = 1;

                } else {

                    //
                    // error%/20% is error%/(1/5), which is 5*error%,
                    // which is 5 * (resent/send).
                    //

                    ASSERT (((11 * 5 * PacketsResent) / PacketsSent) <= 11);
                    MultiplyFactor = 12 - ((11 * 5 * PacketsResent) / PacketsSent);

                }

                ConnectionInfo->Throughput.QuadPart =
                    UInt32x32To64(DeviceContext->MediumSpeed, MultiplyFactor);

            } else if (!Link->ThroughputAccurate) {

                //
                // If throughput is not known, then guess. We
                // have MediumSpeed in units of 100 bps; we
                // return four times that number as the throughput,
                // which corresponds to about 1/3 of the
                // maximum bandwidth expressed in bytes/sec.
                //

                ConnectionInfo->Throughput.QuadPart =
                    UInt32x32To64(DeviceContext->MediumSpeed, 4);

            } else {

                //
                // Throughput is accurate, return it.
                //

                ConnectionInfo->Throughput = Link->Throughput;

            }


            //
            // Calculate reliability using the sent/resent ratio,
            // if there has been enough activity to make it
            // worthwhile. >10% resent is unreliable.
            //

            if ((Link->PacketsResent > 0) &&
                (Link->PacketsSent > 20)) {

                ConnectionInfo->Unreliable =
                    ((Link->PacketsSent / Link->PacketsResent) < 10);

            } else {

                ConnectionInfo->Unreliable = FALSE;

            }

            ConnectionInfo->TransmittedTsdus = Connection->TransmittedTsdus;
            ConnectionInfo->ReceivedTsdus = Connection->ReceivedTsdus;
            ConnectionInfo->TransmissionErrors = Connection->TransmissionErrors;
            ConnectionInfo->ReceiveErrors = Connection->ReceiveErrors;
            
            status = TdiCopyBufferToMdl (
                            (PVOID)ConnectionInfo,
                            0L,
                            sizeof(TDI_CONNECTION_INFO),
                            Irp->MdlAddress,
                            0,
                            &BytesCopied);

            Irp->IoStatus.Information = BytesCopied;

            ExFreePool (ConnectionInfo);
        }

        NbfDereferenceConnection ("query connection info", Connection, CREF_BY_ID);

        break;

    case TDI_QUERY_ADDRESS_INFO:

        if (irpSp->FileObject->FsContext2 == (PVOID)TDI_TRANSPORT_ADDRESS_FILE) {

            AddressFile = irpSp->FileObject->FsContext;

            status = NbfVerifyAddressObject(AddressFile);

            if (!NT_SUCCESS (status)) {
#if DBG
                NbfPrint2 ("TdiQueryInfo: Invalid AddressFile %lx Irp %lx\n", AddressFile, Irp);
#endif
                return status;
            }

            UsedConnection = FALSE;

        } else if (irpSp->FileObject->FsContext2 == (PVOID)TDI_CONNECTION_FILE) {

            Connection = irpSp->FileObject->FsContext;

            status = NbfVerifyConnectionObject (Connection);

            if (!NT_SUCCESS (status)) {
#if DBG
                NbfPrint2 ("TdiQueryInfo: Invalid Connection %lx Irp %lx\n", Connection, Irp);
#endif
                return status;
            }

            AddressFile = Connection->AddressFile;

            UsedConnection = TRUE;

        } else {

            return STATUS_INVALID_ADDRESS;

        }

        Address = AddressFile->Address;

        TdiBuildNetbiosAddress(
            Address->NetworkName->NetbiosName,
            (BOOLEAN)(Address->Flags & ADDRESS_FLAGS_GROUP ? TRUE : FALSE),
            &AddressInfo.TaAddressBuffer);

        //
        // Count the active addresses.
        //

        AddressInfo.ActivityCount = 0;

        ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

        for (p = Address->AddressFileDatabase.Flink;
             p != &Address->AddressFileDatabase;
             p = p->Flink) {
            ++AddressInfo.ActivityCount;
        }

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        status = TdiCopyBufferToMdl (
                    &AddressInfo,
                    0,
                    sizeof(ULONG) + sizeof(TA_NETBIOS_ADDRESS),
                    Irp->MdlAddress,
                    0,                    
                    &BytesCopied);

        Irp->IoStatus.Information = BytesCopied;

        if (UsedConnection) {

            NbfDereferenceConnection ("query address info", Connection, CREF_BY_ID);

        } else {

            NbfDereferenceAddress ("query address info", Address, AREF_VERIFY);

        }

        break;

    case TDI_QUERY_BROADCAST_ADDRESS:

        //
        // for this provider, the broadcast address is a zero byte name,
        // contained in a Transport address structure.
        //

        broadcastAddress = ExAllocatePoolWithTag (
                                NonPagedPool,
                                sizeof (TA_NETBIOS_ADDRESS),
                                NBF_MEM_TAG_TDI_QUERY_BUFFER);
        if (broadcastAddress == NULL) {
            PANIC ("NbfQueryInfo: Cannot allocate broadcast address!\n");
            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_POOL,
                2,
                sizeof(TA_NETBIOS_ADDRESS),
                0);
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            broadcastAddress->TAAddressCount = 1;
            broadcastAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            broadcastAddress->Address[0].AddressLength = 0;

            Irp->IoStatus.Information =
                    sizeof (broadcastAddress->TAAddressCount) +
                    sizeof (broadcastAddress->Address[0].AddressType) +
                    sizeof (broadcastAddress->Address[0].AddressLength);

            BytesCopied = (ULONG)Irp->IoStatus.Information;

            status = TdiCopyBufferToMdl (
                            (PVOID)broadcastAddress,
                            0L,
                            BytesCopied,
                            Irp->MdlAddress,
                            0,
                            &BytesCopied);
                            
            Irp->IoStatus.Information = BytesCopied;

            ExFreePool (broadcastAddress);
        }

        break;

    case TDI_QUERY_PROVIDER_INFO:

        status = TdiCopyBufferToMdl (
                    &(DeviceContext->Information),
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    Irp->MdlAddress,
                    0,
                    &BytesCopied);

        Irp->IoStatus.Information = BytesCopied;

        break;

    case TDI_QUERY_PROVIDER_STATISTICS:

        //
        // This information is probablt available somewhere else.
        //

        NbfGetMdlChainLength (Irp->MdlAddress, &TargetBufferLength);

        if (TargetBufferLength < sizeof(TDI_PROVIDER_STATISTICS) + ((NBF_TDI_RESOURCES-1) * sizeof(TDI_PROVIDER_RESOURCE_STATS))) {

            Irp->IoStatus.Information = 0;
            status = STATUS_BUFFER_OVERFLOW;

        } else {

            ProviderStatistics = ExAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(TDI_PROVIDER_STATISTICS) +
                                     ((NBF_TDI_RESOURCES-1) * sizeof(TDI_PROVIDER_RESOURCE_STATS)),
                                   NBF_MEM_TAG_TDI_PROVIDER_STATS);

            if (ProviderStatistics == NULL) {

                PANIC ("NbfQueryInfo: Cannot allocate provider statistics!\n");
                NbfWriteResourceErrorLog(
                    DeviceContext,
                    EVENT_TRANSPORT_RESOURCE_POOL,
                    7,
                    sizeof(TDI_PROVIDER_STATISTICS),
                    0);
                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                NbfStoreProviderStatistics (DeviceContext, ProviderStatistics);

                status = TdiCopyBufferToMdl (
                                (PVOID)ProviderStatistics,
                                0L,
                                sizeof(TDI_PROVIDER_STATISTICS) +
                                  ((NBF_TDI_RESOURCES-1) * sizeof(TDI_PROVIDER_RESOURCE_STATS)),
                                Irp->MdlAddress,
                                0,
                                &BytesCopied);

                Irp->IoStatus.Information = BytesCopied;

                ExFreePool (ProviderStatistics);
            }

        }

        break;

    case TDI_QUERY_SESSION_STATUS:

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case TDI_QUERY_ADAPTER_STATUS:

        NbfGetMdlChainLength (Irp->MdlAddress, &TargetBufferLength);

        //
        // Determine if this is a local or remote query. It is
        // local if there is no remote address specific at all,
        // or if it is equal to our reserved address.
        //

        RemoteAdapterStatus = FALSE;

        if (query->RequestConnectionInformation != NULL) {

            if (!NbfValidateTdiAddress(
                     query->RequestConnectionInformation->RemoteAddress,
                     query->RequestConnectionInformation->RemoteAddressLength)) {
                return STATUS_BAD_NETWORK_PATH;
            }

            RemoteAddress = NbfParseTdiAddress(query->RequestConnectionInformation->RemoteAddress, FALSE);

            if (!RemoteAddress) {
                return STATUS_BAD_NETWORK_PATH;
            }
            if (!RtlEqualMemory(
                 RemoteAddress->NetbiosName,
                 DeviceContext->ReservedNetBIOSAddress,
                 NETBIOS_NAME_LENGTH)) {

                 RemoteAdapterStatus = TRUE;

            }
        }

        if (RemoteAdapterStatus) {

            //
            // We need a request object to keep track of this TDI request.
            // Attach this request to the device context.
            //

            status = NbfCreateRequest (
                         Irp,                           // IRP for this request.
                         DeviceContext,                 // context.
                         REQUEST_FLAGS_DC,              // partial flags.
                         Irp->MdlAddress,               // the data to be received.
                         TargetBufferLength,            // length of the data.
                         timeout,                       // do this ourselves here.
                         &tpRequest);

            if (NT_SUCCESS (status)) {

                NbfReferenceDeviceContext ("Remote status", DeviceContext, DCREF_REQUEST);
                tpRequest->Owner = DeviceContextType;

                //
                // Allocate a temp buffer to hold our results.
                //

                tpRequest->ResponseBuffer = ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                TargetBufferLength,
                                                NBF_MEM_TAG_TDI_QUERY_BUFFER);

                if (tpRequest->ResponseBuffer == NULL) {

                    NbfWriteResourceErrorLog(
                        DeviceContext,
                        EVENT_TRANSPORT_RESOURCE_POOL,
                        12,
                        TargetBufferLength,
                        0);
                    NbfCompleteRequest (tpRequest, STATUS_INSUFFICIENT_RESOURCES, 0);

                } else {

                    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);

                    if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {

                        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock,oldirql);
                        NbfCompleteRequest (tpRequest, STATUS_DEVICE_NOT_READY, 0);

                    } else {

                        PUCHAR SingleSR;
                        UINT SingleSRLength;

                        InsertTailList (
                            &DeviceContext->StatusQueryQueue,
                            &tpRequest->Linkage);

                        tpRequest->FrameContext = DeviceContext->UniqueIdentifier | 0x8000;
                        ++DeviceContext->UniqueIdentifier;
                        if (DeviceContext->UniqueIdentifier == 0x8000) {
                            DeviceContext->UniqueIdentifier = 1;
                        }

                        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

                        //
                        // The request is queued. Now send out the first packet and
                        // start the timer.
                        //

                        tpRequest->Retries = DeviceContext->GeneralRetries;
                        tpRequest->BytesWritten = 0;

                        //
                        // STATUS_QUERY frames go out as
                        // single-route source routing.
                        //

                        MacReturnSingleRouteSR(
                            &DeviceContext->MacInfo,
                            &SingleSR,
                            &SingleSRLength);

                        NbfSendStatusQuery(
                            DeviceContext,
                            tpRequest,
                            &DeviceContext->NetBIOSAddress,
                            SingleSR,
                            SingleSRLength);

                    }

                }

                //
                // As long as the request is created, pend here.
                // The IRP will complete when the request completes.
                //

                status = STATUS_PENDING;

            }

        } else {

            //
            // Local.
            //

            adapterStatus = ExAllocatePoolWithTag (
                                NonPagedPool,
                                TargetBufferLength,
                                NBF_MEM_TAG_TDI_QUERY_BUFFER);

            if (adapterStatus == NULL) {
                PANIC("NbfQueryInfo: PANIC! Could not allocate adapter status buffer\n");
                NbfWriteResourceErrorLog(
                    DeviceContext,
                    EVENT_TRANSPORT_RESOURCE_POOL,
                    3,
                    TargetBufferLength,
                    0);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            NbfStoreAdapterStatus (
                DeviceContext,
                NULL,
                0,
                adapterStatus);

            NbfStoreNameBuffers (
                DeviceContext,
                (PUCHAR)adapterStatus + sizeof(ADAPTER_STATUS),
                TargetBufferLength - sizeof(ADAPTER_STATUS),
                0,
                &NamesWritten,
                &TotalNameCount,
                &Truncated);

            ((PADAPTER_STATUS)adapterStatus)->name_count = (WORD)TotalNameCount;

            BytesWritten = sizeof(ADAPTER_STATUS) + (NamesWritten * sizeof(NAME_BUFFER));

            status = TdiCopyBufferToMdl (
                        adapterStatus,
                        0,
                        BytesWritten,
                        Irp->MdlAddress,
                        0,
                        &BytesCopied);
                        
            Irp->IoStatus.Information = BytesCopied;

            if (Truncated) {
                 status = STATUS_BUFFER_OVERFLOW;
            }

            ExFreePool (adapterStatus);

        }

        break;

    case TDI_QUERY_FIND_NAME:

        NbfGetMdlChainLength (Irp->MdlAddress, &TargetBufferLength);

        //
        // Check that there is a valid Netbios remote address.
        //

        if (!NbfValidateTdiAddress(
                 query->RequestConnectionInformation->RemoteAddress,
                 query->RequestConnectionInformation->RemoteAddressLength)) {
            return STATUS_BAD_NETWORK_PATH;
        }

        RemoteAddress = NbfParseTdiAddress(query->RequestConnectionInformation->RemoteAddress, FALSE);

        if (!RemoteAddress) {
            return STATUS_BAD_NETWORK_PATH;
        }

        //
        // We need a request object to keep track of this TDI request.
        // Attach this request to the device context.
        //

        status = NbfCreateRequest (
                     Irp,                           // IRP for this request.
                     DeviceContext,                 // context.
                     REQUEST_FLAGS_DC,              // partial flags.
                     Irp->MdlAddress,               // the data to be received.
                     TargetBufferLength,            // length of the data.
                     timeout,                       // do this ourselves here.
                     &tpRequest);

        if (NT_SUCCESS (status)) {

            NbfReferenceDeviceContext ("Find name", DeviceContext, DCREF_REQUEST);
            tpRequest->Owner = DeviceContextType;

            //
            // Allocate a temp buffer to hold our results.
            //

            tpRequest->ResponseBuffer = ExAllocatePoolWithTag(
                                            NonPagedPool,
                                            TargetBufferLength,
                                            NBF_MEM_TAG_TDI_QUERY_BUFFER);

            if (tpRequest->ResponseBuffer == NULL) {

                NbfWriteResourceErrorLog(
                    DeviceContext,
                    EVENT_TRANSPORT_RESOURCE_POOL,
                    4,
                    TargetBufferLength,
                    0);
                NbfCompleteRequest (tpRequest, STATUS_INSUFFICIENT_RESOURCES, 0);

            } else {

                ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);

                if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {

                    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock,oldirql);
                    NbfCompleteRequest (tpRequest, STATUS_DEVICE_NOT_READY, 0);

                } else {

                    InsertTailList (
                        &DeviceContext->FindNameQueue,
                        &tpRequest->Linkage);

                    tpRequest->FrameContext = DeviceContext->UniqueIdentifier | 0x8000;
                    ++DeviceContext->UniqueIdentifier;
                    if (DeviceContext->UniqueIdentifier == 0x8000) {
                        DeviceContext->UniqueIdentifier = 1;
                    }

                    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

                    //
                    // The request is queued. Now send out the first packet and
                    // start the timer.
                    //
                    // We fill in the FIND_NAME_HEADER in the buffer, but
                    // set BytesWritten to 0; we don't include the header
                    // in BytesWritten until we get a response, so that
                    // a BytesWritten of 0 means "no response".
                    //

                    tpRequest->Retries = DeviceContext->GeneralRetries;
                    tpRequest->BytesWritten = 0;
                    FindNameHeader = (PFIND_NAME_HEADER)tpRequest->ResponseBuffer;
                    FindNameHeader->node_count = 0;
                    FindNameHeader->unique_group = NETBIOS_NAME_TYPE_UNIQUE;

                    NbfSendQueryFindName (DeviceContext, tpRequest);

                }

            }

            //
            // As long as the request is created, pend here.
            // The IRP will complete when the request completes.
            //

            status = STATUS_PENDING;
        }

        break;

    case TDI_QUERY_DATA_LINK_ADDRESS:
    case TDI_QUERY_NETWORK_ADDRESS:

        TaAddress = (PTRANSPORT_ADDRESS)&AddressInfo.TaAddressBuffer;
        TaAddress->TAAddressCount = 1;
        TaAddress->Address[0].AddressLength = 6;
        if (query->QueryType == TDI_QUERY_DATA_LINK_ADDRESS) {
            TaAddress->Address[0].AddressType =
                DeviceContext->MacInfo.MediumAsync ?
                    NdisMediumWan : DeviceContext->MacInfo.MediumType;
        } else {
            TaAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;
        }
        RtlCopyMemory (TaAddress->Address[0].Address, DeviceContext->LocalAddress.Address, 6);

        status = TdiCopyBufferToMdl (
                    &AddressInfo.TaAddressBuffer,
                    0,
                    sizeof(TRANSPORT_ADDRESS)+5,
                    Irp->MdlAddress,
                    0,
                    &BytesCopied);
                        
        Irp->IoStatus.Information = BytesCopied;
        break;

    case TDI_QUERY_DATAGRAM_INFO:

        DatagramInfo.MaximumDatagramBytes = 0;
        DatagramInfo.MaximumDatagramCount = 0;

        status = TdiCopyBufferToMdl (
                    &DatagramInfo,
                    0,
                    sizeof(DatagramInfo),
                    Irp->MdlAddress,
                    0,
                    &BytesCopied);
                        
        Irp->IoStatus.Information = BytesCopied;
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;

} /* NbfTdiQueryInformation */

//
// Quick macros, assumes DeviceContext and ProviderStatistics exist.
//

#define STORE_RESOURCE_STATS_1(_ResourceNum,_ResourceId,_ResourceName) \
{ \
    PTDI_PROVIDER_RESOURCE_STATS RStats = &ProviderStatistics->ResourceStats[_ResourceNum]; \
    RStats->ResourceId = (_ResourceId); \
    RStats->MaximumResourceUsed = DeviceContext->_ResourceName ## MaxInUse; \
    if (DeviceContext->_ResourceName ## Samples > 0) { \
        RStats->AverageResourceUsed = DeviceContext->_ResourceName ## Total / DeviceContext->_ResourceName ## Samples; \
    } else { \
        RStats->AverageResourceUsed = 0; \
    } \
    RStats->ResourceExhausted = DeviceContext->_ResourceName ## Exhausted; \
}

#define STORE_RESOURCE_STATS_2(_ResourceNum,_ResourceId,_ResourceName) \
{ \
    PTDI_PROVIDER_RESOURCE_STATS RStats = &ProviderStatistics->ResourceStats[_ResourceNum]; \
    RStats->ResourceId = (_ResourceId); \
    RStats->MaximumResourceUsed = DeviceContext->_ResourceName ## Allocated; \
    RStats->AverageResourceUsed = DeviceContext->_ResourceName ## Allocated; \
    RStats->ResourceExhausted = DeviceContext->_ResourceName ## Exhausted; \
}


VOID
NbfStoreProviderStatistics(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTDI_PROVIDER_STATISTICS ProviderStatistics
    )

/*++

Routine Description:

    This routine writes the TDI_PROVIDER_STATISTICS structure
    from the device context into ProviderStatistics.

Arguments:

    DeviceContext - a pointer to the device context.

    ProviderStatistics - The buffer that holds the result. It is assumed
        that it is long enough.

Return Value:

    None.

--*/

{

    //
    // Copy all the statistics up to NumberOfResources
    // in one move.
    //

    RtlCopyMemory(
        ProviderStatistics,
        &DeviceContext->Statistics,
        FIELD_OFFSET (TDI_PROVIDER_STATISTICS, NumberOfResources));

    //
    // Calculate AverageSendWindow.
    //

    if (DeviceContext->SendWindowSamples > 0) {
        ProviderStatistics->AverageSendWindow =
            DeviceContext->SendWindowTotal / DeviceContext->SendWindowSamples;
    } else {
        ProviderStatistics->AverageSendWindow = 1;
    }

    //
    // Copy the resource statistics.
    //

    ProviderStatistics->NumberOfResources = NBF_TDI_RESOURCES;

    STORE_RESOURCE_STATS_1 (0, LINK_RESOURCE_ID, Link);
    STORE_RESOURCE_STATS_1 (1, ADDRESS_RESOURCE_ID, Address);
    STORE_RESOURCE_STATS_1 (2, ADDRESS_FILE_RESOURCE_ID, AddressFile);
    STORE_RESOURCE_STATS_1 (3, CONNECTION_RESOURCE_ID, Connection);
    STORE_RESOURCE_STATS_1 (4, REQUEST_RESOURCE_ID, Request);

    STORE_RESOURCE_STATS_2 (5, UI_FRAME_RESOURCE_ID, UIFrame);
    STORE_RESOURCE_STATS_2 (6, PACKET_RESOURCE_ID, Packet);
    STORE_RESOURCE_STATS_2 (7, RECEIVE_PACKET_RESOURCE_ID, ReceivePacket);
    STORE_RESOURCE_STATS_2 (8, RECEIVE_BUFFER_RESOURCE_ID, ReceiveBuffer);

}   /* NbfStoreProviderStatistics */


VOID
NbfStoreAdapterStatus(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN PVOID StatusBuffer
    )

/*++

Routine Description:

    This routine writes the ADAPTER_STATUS structure for the
    device context into StatusBuffer. The name_count field is
    initialized to zero; NbfStoreNameBuffers is used to write
    name buffers.

Arguments:

    DeviceContext - a pointer to the device context.

    SourceRouting - If this is a remote request, the source
        routing information from the frame.

    SourceRoutingLength - The length of SourceRouting.

    StatusBuffer - The buffer that holds the result. It is assumed
        that it is at least sizeof(ADAPTER_STATUS) bytes long.

Return Value:

    None.

--*/

{

    PADAPTER_STATUS AdapterStatus = (PADAPTER_STATUS)StatusBuffer;
    UINT MaxUserData;

    RtlZeroMemory ((PVOID)AdapterStatus, sizeof(ADAPTER_STATUS));

    RtlCopyMemory (AdapterStatus->adapter_address, DeviceContext->LocalAddress.Address, 6);
    AdapterStatus->rev_major = 0x03;

    switch (DeviceContext->MacInfo.MediumType) {
        case NdisMedium802_5: AdapterStatus->adapter_type = 0xff; break;
        default: AdapterStatus->adapter_type = 0xfe; break;
    }

    AdapterStatus->frmr_recv = (WORD)DeviceContext->FrmrReceived;
    AdapterStatus->frmr_xmit = (WORD)DeviceContext->FrmrTransmitted;

    AdapterStatus->recv_buff_unavail = (WORD)(DeviceContext->ReceivePacketExhausted + DeviceContext->ReceiveBufferExhausted);
    AdapterStatus->xmit_buf_unavail = (WORD)DeviceContext->PacketExhausted;

    AdapterStatus->xmit_success = (WORD)(DeviceContext->Statistics.DataFramesSent - DeviceContext->Statistics.DataFramesResent);
    AdapterStatus->recv_success = (WORD)DeviceContext->Statistics.DataFramesReceived;
    AdapterStatus->iframe_recv_err = (WORD)DeviceContext->Statistics.DataFramesRejected;
    AdapterStatus->iframe_xmit_err = (WORD)DeviceContext->Statistics.DataFramesResent;

    AdapterStatus->t1_timeouts = (WORD)DeviceContext->Statistics.ResponseTimerExpirations;
    AdapterStatus->ti_timeouts = (WORD)DeviceContext->TiExpirations;
    AdapterStatus->xmit_aborts = (WORD)0;


    AdapterStatus->free_ncbs = (WORD)0xffff;
    AdapterStatus->max_cfg_ncbs = (WORD)0xffff;
    AdapterStatus->max_ncbs = (WORD)0xffff;
    AdapterStatus->pending_sess = (WORD)DeviceContext->Statistics.OpenConnections;
    AdapterStatus->max_cfg_sess = (WORD)0xffff;
    AdapterStatus->max_sess = (WORD)0xffff;


    MacReturnMaxDataSize(
        &DeviceContext->MacInfo,
        NULL,
        0,
        DeviceContext->MaxSendPacketSize,
        TRUE,
        &MaxUserData);
    AdapterStatus->max_dgram_size = (WORD)(MaxUserData - (sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS)));

    MacReturnMaxDataSize(
        &DeviceContext->MacInfo,
        SourceRouting,
        SourceRoutingLength,
        DeviceContext->MaxSendPacketSize,
        FALSE,
        &MaxUserData);
    AdapterStatus->max_sess_pkt_size = (WORD)(MaxUserData - (sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION)));

    return;

}   /* NbfStoreAdapterStatus */


VOID
NbfStoreNameBuffers(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG NamesToSkip,
    OUT PULONG NamesWritten,
    OUT PULONG TotalNameCount OPTIONAL,
    OUT PBOOLEAN Truncated
    )

/*++

Routine Description:

    This routine writes NAME_BUFFER structures for the
    device context into NameBuffer. It can skip a specified
    number of names at the beginning, and returns the number
    of names written into NameBuffer. If a name will only
    partially fit, it is not written.

Arguments:

    DeviceContext - a pointer to the device context.

    NameBuffer - The buffer to write the names into.

    NameBufferLength - The length of NameBuffer.

    NamesToSkip - The number of names to skip.

    NamesWritten - Returns the number of names written.

    TotalNameCount - Returns the total number of names available,
        if specified.

    Truncated - More names are available than were written.

Return Value:

    None.

--*/

{

    ULONG NameCount = 0;
    ULONG BytesWritten = 0;
    KIRQL oldirql;
    PLIST_ENTRY p;
    PNAME_BUFFER NameBuffer = (PNAME_BUFFER)Buffer;
    PTP_ADDRESS address;


    //
    // Spin through the address list for this device context.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    p = DeviceContext->AddressDatabase.Flink;

    for (p = DeviceContext->AddressDatabase.Flink;
         p != &DeviceContext->AddressDatabase;
         p = p->Flink) {

        address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

        //
        // Ignore addresses that are shutting down.
        //

        if ((address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        //
        // Ignore the broadcast address.
        //

        if (address->NetworkName == NULL) {
            continue;
        }

        //
        // Ignore the reserved address.
        //

        if ((address->NetworkName->NetbiosName[0] == 0) &&
            (RtlEqualMemory(
                 address->NetworkName->NetbiosName,
                 DeviceContext->ReservedNetBIOSAddress,
                 NETBIOS_NAME_LENGTH))) {

            continue;
        }

        //
        // Check if we are still skipping.
        //

        if (NameCount < NamesToSkip) {
             ++NameCount;
             continue;
        }

        //
        // Make sure we still have room.
        //

        if (BytesWritten + sizeof(NAME_BUFFER) > BufferLength) {
            break;
        }

        RtlCopyMemory(
            NameBuffer->name,
            address->NetworkName->NetbiosName,
            NETBIOS_NAME_LENGTH);

        ++NameCount;
        NameBuffer->name_num = (UCHAR)NameCount;

        NameBuffer->name_flags = REGISTERED;
        if (address->Flags & ADDRESS_FLAGS_GROUP) {
            NameBuffer->name_flags |= GROUP_NAME;
        }

        // name_flags should be done more accurately.

        BytesWritten += sizeof(NAME_BUFFER);
        ++NameBuffer;

    }

    *NamesWritten = (ULONG)(NameBuffer - (PNAME_BUFFER)Buffer);

    if (p == &DeviceContext->AddressDatabase) {

        *Truncated = FALSE;
        if (ARGUMENT_PRESENT(TotalNameCount)) {
            *TotalNameCount = NameCount;
        }

    } else {

        *Truncated = TRUE;

        //
        // If requested, continue through the list and count
        // all the addresses.
        //

        if (ARGUMENT_PRESENT(TotalNameCount)) {

            for ( ;
                 p != &DeviceContext->AddressDatabase;
                 p = p->Flink) {

                address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

                //
                // Ignore addresses that are shutting down.
                //

                if ((address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
                    continue;
                }

                //
                // Ignore the broadcast address.
                //

                if (address->NetworkName == NULL) {
                    continue;
                }

                //
                // Ignore the reserved address, since we count it no matter what.
                //

                if ((address->NetworkName->NetbiosName[0] == 0) &&
                    (RtlEqualMemory(
                         address->NetworkName->NetbiosName,
                         DeviceContext->ReservedNetBIOSAddress,
                         NETBIOS_NAME_LENGTH))) {

                    continue;
                }

                ++NameCount;

            }

            *TotalNameCount = NameCount;

        }

    }


    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    return;

}   /* NbfStoreNameBuffers */


NTSTATUS
NbfProcessStatusQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address OPTIONAL,
    IN PNBF_HDR_CONNECTIONLESS UiFrame,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes a STATUS.QUERY packet.

Arguments:

    DeviceContext - a pointer to the device context the frame was received on.

    Address - The address we are responding from, or NULL if the STATUS.QUERY
        was sent to the reserved address.

    UiFrame - The packet in question, starting at the Netbios header.

    SourceAddress - The source hardware address of the packet.

    SourceRouting - Source routing data in the query.

    SourceRoutingLength - The length of SourceRouting.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    NTSTATUS Status;
    NDIS_STATUS NdisStatus;
    PTP_UI_FRAME RawFrame;
    PVOID ResponseBuffer;
    UINT ResponseBufferLength;
    ULONG NamesWritten, TotalNameCount;
    ULONG BytesWritten;
    UCHAR RequestType;
    BOOLEAN Truncated, UsersBufferTooShort;
    USHORT UsersBufferLength;
    UINT HeaderLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;
    PNDIS_BUFFER NdisBuffer;

    //
    // Allocate a buffer to hold the status.
    //

    MacReturnMaxDataSize(
        &DeviceContext->MacInfo,
        SourceRouting,
        SourceRoutingLength,
        DeviceContext->CurSendPacketSize,
        FALSE,
        &ResponseBufferLength);

    ResponseBufferLength -= (sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS));

    UsersBufferLength = (UiFrame->Data2High * 256) + UiFrame->Data2Low;

    //
    // See how big to make our buffer; if the amount remaining in the user's
    // buffer is less than our max size, chop it down.
    //

    if (UiFrame->Data1 <= 1) {

        //
        // This is the initial request.
        //

        if (ResponseBufferLength > (UINT)UsersBufferLength) {
            ResponseBufferLength = UsersBufferLength;
        }

    } else {

        //
        // Subsequent request; compensate for already-sent data.
        //

        UsersBufferLength -= (sizeof(ADAPTER_STATUS) + (UiFrame->Data1 * sizeof(NAME_BUFFER)));

        if (ResponseBufferLength > (UINT)UsersBufferLength) {
            ResponseBufferLength = UsersBufferLength;
        }

    }

    //
    // If the remote station is asking for no data, ignore this request.
    // This prevents us from trying to allocate 0 bytes of pool.
    //

    if ( (LONG)ResponseBufferLength <= 0 ) {
        return STATUS_ABANDONED;
    }

    ResponseBuffer = ExAllocatePoolWithTag(
                         NonPagedPool,
                         ResponseBufferLength,
                         NBF_MEM_TAG_TDI_QUERY_BUFFER);

    if (ResponseBuffer == NULL) {
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            5,
            ResponseBufferLength,
            0);
        return STATUS_ABANDONED;
    }


    //
    // Fill in the response buffer.
    //

    if (UiFrame->Data1 <= 1) {

        //
        // First request.
        //

        NbfStoreAdapterStatus (
            DeviceContext,
            SourceRouting,
            SourceRoutingLength,
            ResponseBuffer);

        NbfStoreNameBuffers (
            DeviceContext,
            (PUCHAR)ResponseBuffer + sizeof(ADAPTER_STATUS),
            ResponseBufferLength - sizeof(ADAPTER_STATUS),
            0,
            &NamesWritten,
            &TotalNameCount,
            &Truncated);

        BytesWritten = sizeof(ADAPTER_STATUS) + (NamesWritten * sizeof(NAME_BUFFER));

        //
        // If the data was truncated, but we are returning the maximum
        // that the user requested, report that as "user's buffer
        // too short" instead of "truncated".
        //

        if (Truncated && (ResponseBufferLength >= (UINT)UsersBufferLength)) {
            Truncated = FALSE;
            UsersBufferTooShort = TRUE;
        } else {
            UsersBufferTooShort = FALSE;
        }

        ((PADAPTER_STATUS)ResponseBuffer)->name_count = (WORD)TotalNameCount;

    } else {

        NbfStoreNameBuffers (
            DeviceContext,
            ResponseBuffer,
            ResponseBufferLength,
            UiFrame->Data1,
            &NamesWritten,
            NULL,
            &Truncated);

        BytesWritten = NamesWritten * sizeof(NAME_BUFFER);

        if (Truncated && (ResponseBufferLength >= (UINT)UsersBufferLength)) {
            Truncated = FALSE;
            UsersBufferTooShort = TRUE;
        } else {
            UsersBufferTooShort = FALSE;
        }

    }

    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        ExFreePool (ResponseBuffer);
        return STATUS_ABANDONED;
    }

    IF_NBFDBG (NBF_DEBUG_DEVCTX) {
        NbfPrint2 ("NbfProcessStatusQuery:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header. STATUS_RESPONSE frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS) + BytesWritten,
        ResponseSR,
        SourceRoutingLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    switch (UiFrame->Data1) {
    case 0:                       // pre 2.1 request
        RequestType = (UCHAR)0;
        break;
    case 1:                       // 2.1, first request
        RequestType = (UCHAR)NamesWritten;
        break;
    default:                      // 2.1, subsequent request
        RequestType = (UCHAR)(UiFrame->Data1 + NamesWritten);
        break;
    }

    ConstructStatusResponse (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        RequestType,                          // request type.
        Truncated,                            // more data.
        UsersBufferTooShort,                  // user's buffer too small
        (USHORT)BytesWritten,                 // bytes in response
        RESPONSE_CORR(UiFrame),               // correlator
        UiFrame->SourceName,                  // receiver permanent name
        (ARGUMENT_PRESENT(Address)) ?
            Address->NetworkName->NetbiosName :
            DeviceContext->ReservedNetBIOSAddress); // source name

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length (now, before we append the second
    // buffer).
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);


    //
    // Now, if we have any name data, attach our buffer onto the frame.
    // Note that it's possible at the end of the user's buffer for us
    // to not have room for any names, and thus we'll have no data to
    // send.
    //

    if ( BytesWritten != 0 ) {

        RawFrame->DataBuffer = ResponseBuffer;

        NdisAllocateBuffer(
            &NdisStatus,
            &NdisBuffer,
            DeviceContext->NdisBufferPool,
            ResponseBuffer,
            BytesWritten);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            PANIC ("ConstructStatusResponse: NdisAllocateBuffer failed.\n");
            NbfDestroyConnectionlessFrame (DeviceContext, RawFrame);
            return STATUS_ABANDONED;
        }

        NdisChainBufferAtBack (RawFrame->NdisPacket, NdisBuffer);

    } else {

        RawFrame->DataBuffer = NULL;

    }


    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                           // no loopback (MC frame)

    return STATUS_ABANDONED;

}   /* NbfProcessStatusQuery */


VOID
NbfSendQueryFindName(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST Request
    )

/*++

Routine Description:

    This routine will send a FIND.NAME packet for the specified
    find name request, and start the request timer.

Arguments:

    DeviceContext - a pointer to the device context to send the find name on.

    Request - The find name request.

Return Value:

    None.

--*/

{
    TDI_ADDRESS_NETBIOS * remoteAddress;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;
    PTP_UI_FRAME RawFrame;
    PUCHAR SingleSR;
    UINT SingleSRLength;
    UINT HeaderLength;
    LARGE_INTEGER Timeout;

    irpSp = IoGetCurrentIrpStackLocation (Request->IoRequestPacket);

    remoteAddress = NbfParseTdiAddress(
                        ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)(&irpSp->Parameters))->
                            RequestConnectionInformation->RemoteAddress, FALSE);

    //
    // Start the timer for this request.
    //

    Request->Flags |= REQUEST_FLAGS_TIMER;  // there is a timeout on this request.
    KeInitializeTimer (&Request->Timer);    // set to not-signaled state.
    NbfReferenceRequest ("Find Name: timer", Request, RREF_TIMER);           // one for the timer
    Timeout.LowPart = (ULONG)(-(LONG)DeviceContext->GeneralTimeout);
    Timeout.HighPart = -1;
    KeSetTimer (&Request->Timer, Timeout, &Request->Dpc);

    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return;
    }

    IF_NBFDBG (NBF_DEBUG_DEVCTX) {
        NbfPrint2 ("NbfSendFindNames:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header. NAME_QUERY frames go out as
    // single-route source routing.
    //

    MacReturnSingleRouteSR(
        &DeviceContext->MacInfo,
        &SingleSR,
        &SingleSRLength);

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        DeviceContext->NetBIOSAddress.Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        SingleSR,
        SingleSRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructNameQuery (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NETBIOS_NAME_TYPE_UNIQUE,               // call from a unique name.
        NAME_QUERY_LSN_FIND_NAME,               // LSN
        Request->FrameContext,                  // corr. in 1st NAME_RECOGNIZED.
        DeviceContext->ReservedNetBIOSAddress,
        (PNAME)remoteAddress->NetbiosName);

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                           // no loopback (MC frame)

}   /* NbfSendQueryFindName */


NTSTATUS
NbfProcessQueryNameRecognized(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Packet,
    PNBF_HDR_CONNECTIONLESS UiFrame
    )

/*++

Routine Description:

    This routine processes a NAME.RECOGNIZED request with a
    correlator of 0, indicating it was a response to a previous
    FIND.NAME packet.

Arguments:

    DeviceContext - a pointer to the device context the frame was received on.

    Packet - The packet in question, starting at the MAC header.

    UiFrame - The packet, starting at the Netbios header.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    KIRQL oldirql;
    PTP_REQUEST Request;
    PFIND_NAME_BUFFER FindNameBuffer;
    PFIND_NAME_HEADER FindNameHeader;
    PUCHAR DestinationAddress;
    HARDWARE_ADDRESS SourceAddressBuffer;
    PHARDWARE_ADDRESS SourceAddress;
    PUCHAR SourceRouting;
    UINT SourceRoutingLength;
    PUCHAR TargetBuffer;
    USHORT FrameContext;
    PLIST_ENTRY p;


    MacReturnDestinationAddress(
        &DeviceContext->MacInfo,
        Packet,
        &DestinationAddress);

    MacReturnSourceAddress(
        &DeviceContext->MacInfo,
        Packet,
        &SourceAddressBuffer,
        &SourceAddress,
        NULL);

    MacReturnSourceRouting(
        &DeviceContext->MacInfo,
        Packet,
        &SourceRouting,
        &SourceRoutingLength);

    //
    // Find the request that this is for, using the frame context.
    //

    FrameContext = TRANSMIT_CORR(UiFrame);

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    for (p=DeviceContext->FindNameQueue.Flink;
         p != &DeviceContext->FindNameQueue;
         p=p->Flink) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);

        if (Request->FrameContext == FrameContext) {

             break;

        }

    }

    if (p == &DeviceContext->FindNameQueue) {

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        return STATUS_SUCCESS;

    }

    NbfReferenceRequest ("Name Recognized", Request, RREF_FIND_NAME);

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    //
    // Make sure that this physical address has not
    // responded yet.
    //

    ACQUIRE_SPIN_LOCK (&Request->SpinLock, &oldirql);

    //
    // Make sure this request is not stopping.
    //

    if ((Request->Flags & REQUEST_FLAGS_STOPPING) != 0) {
        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        NbfDereferenceRequest ("Stopping", Request, RREF_STATUS);
        return STATUS_SUCCESS;
    }

    //
    // If this is the first response, update BytesWritten to include
    // the header that is already written in ResponseBuffer.
    //

    if (Request->BytesWritten == 0) {
        Request->BytesWritten = sizeof(FIND_NAME_HEADER);
    }

    TargetBuffer = Request->ResponseBuffer;
    FindNameBuffer = (PFIND_NAME_BUFFER)(TargetBuffer + sizeof(FIND_NAME_HEADER));

    for ( ; FindNameBuffer < (PFIND_NAME_BUFFER)(TargetBuffer + Request->BytesWritten); FindNameBuffer++) {

        if (RtlEqualMemory (FindNameBuffer->source_addr, SourceAddress->Address, 6)) {

            RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
            NbfDereferenceRequest ("Duplicate NR", Request, RREF_FIND_NAME);
            return STATUS_SUCCESS;

        }

    }

    //
    // This is a new address, update if there is room.
    //

    if ((Request->BytesWritten + sizeof(FIND_NAME_BUFFER)) >
        Request->Buffer2Length) {

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);
        RemoveEntryList (&Request->Linkage);
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        NbfCompleteRequest (Request, STATUS_SUCCESS, Request->BytesWritten);
        NbfDereferenceRequest ("No Buffer", Request, RREF_FIND_NAME);
        return STATUS_SUCCESS;

    }

    FindNameHeader = (PFIND_NAME_HEADER)TargetBuffer;
    FindNameHeader->unique_group = UiFrame->Data2High;

    Request->BytesWritten += sizeof(FIND_NAME_BUFFER);
    ++FindNameHeader->node_count;

    RtlCopyMemory(FindNameBuffer->source_addr, SourceAddress->Address, 6);

    RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

    RtlCopyMemory(FindNameBuffer->destination_addr, DestinationAddress, 6);
    FindNameBuffer->length = 14;

    if (DeviceContext->MacInfo.MediumType == NdisMedium802_5) {

        //
        // token-ring, copy the correct fields.
        //

        FindNameBuffer->access_control = Packet[0];
        FindNameBuffer->frame_control = Packet[1];

        if (SourceRouting != NULL) {
            RtlCopyMemory (FindNameBuffer->routing_info, SourceRouting, SourceRoutingLength);
            FindNameBuffer->length += (UCHAR) SourceRoutingLength;
        }

    } else {

        //
        // non-token-ring, nothing else is significant.
        //

        FindNameBuffer->access_control = 0x0;
        FindNameBuffer->frame_control = 0x0;

    }


    //
    // If this is a unique name, complete the request now.
    //

    if (UiFrame->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);
        RemoveEntryList (&Request->Linkage);
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        NbfCompleteRequest(Request, STATUS_SUCCESS, Request->BytesWritten);

    }

    NbfDereferenceRequest ("NR processed", Request, RREF_FIND_NAME);
    return STATUS_SUCCESS;

}   /* NbfProcessQueryNameRecognized */


VOID
NbfSendStatusQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST Request,
    IN PHARDWARE_ADDRESS DestinationAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine will send a STATUS.NAME packet for the specified
    find name request, and start the request timer.

Arguments:

    DeviceContext - a pointer to the device context to send the status query on.

    Request - The find name request.

    DestinationAddress - The hardware destination address of the frame.

    SourceRouting - Optional source routing information in the frame.

    SourceRoutingLength - The length of SourceRouting.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    TDI_ADDRESS_NETBIOS * remoteAddress;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;
    PTP_UI_FRAME RawFrame;
    PUCHAR SingleSR;
    UINT SingleSRLength;
    UINT HeaderLength;
    LARGE_INTEGER Timeout;
    UCHAR RequestType;

    irpSp = IoGetCurrentIrpStackLocation (Request->IoRequestPacket);

    remoteAddress = NbfParseTdiAddress(
                        ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)(&irpSp->Parameters))->
                            RequestConnectionInformation->RemoteAddress, FALSE);

    //
    // Start the timer for this request.
    //

    Request->Flags |= REQUEST_FLAGS_TIMER;  // there is a timeout on this request.
    KeInitializeTimer (&Request->Timer);    // set to not-signaled state.
    NbfReferenceRequest ("Find Name: timer", Request, RREF_TIMER);           // one for the timer
    Timeout.LowPart = (ULONG)(-(LONG)DeviceContext->GeneralTimeout);
    Timeout.HighPart = -1;
    KeSetTimer (&Request->Timer, Timeout, &Request->Dpc);

    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return;
    }

    IF_NBFDBG (NBF_DEBUG_DEVCTX) {
        NbfPrint2 ("NbfSendFindNames:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header. STATUS_QUERY frames go out as
    // single-route source routing.
    //

    MacReturnSingleRouteSR(
        &DeviceContext->MacInfo,
        &SingleSR,
        &SingleSRLength);

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        DeviceContext->NetBIOSAddress.Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        SingleSR,
        SingleSRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    //
    // Determine what RequestType should be.
    //

    if (Request->BytesWritten == 0) {

        //
        // No way to know if he is 2.1 or not, so we put a 1 here
        // instead of 0.
        //

        RequestType = 1;

    } else {

        RequestType = (UCHAR)((Request->BytesWritten - sizeof(ADAPTER_STATUS)) / sizeof(NAME_BUFFER));

    }

    ConstructStatusQuery (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        RequestType,                            // request status type.
        (USHORT)Request->Buffer2Length,         // user's buffer length
        Request->FrameContext,                  // corr. in 1st NAME_RECOGNIZED.
        (PNAME)remoteAddress->NetbiosName,
        DeviceContext->ReservedNetBIOSAddress);

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                            // no loopback (MC frame)

}   /* NbfSendStatusQuery */


NTSTATUS
NbfProcessStatusResponse(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PNBF_HDR_CONNECTIONLESS UiFrame,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes a STATUS.RESPONSE packet.

Arguments:

    DeviceContext - a pointer to the device context the frame was received on.

    ReceiveContext - The context for calling NdisTransferData.

    UiFrame - The packet in question, starting at the Netbios header.

    SourceAddress - The source hardware address of the packet.

    SourceRouting - Source routing data in the query.

    SourceRoutingLength - The length of SourceRouting.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    KIRQL oldirql;
    PTP_REQUEST Request;
    PUCHAR TargetBuffer;
    USHORT FrameContext;
    USHORT NamesReceived;
    USHORT ResponseLength, ResponseBytesToCopy;
    PLIST_ENTRY p;
    PSINGLE_LIST_ENTRY linkage;
    NDIS_STATUS ndisStatus;
    PNDIS_BUFFER NdisBuffer;
    PNDIS_PACKET ndisPacket;
    ULONG ndisBytesTransferred;
    PRECEIVE_PACKET_TAG receiveTag;
    NDIS_STATUS NdisStatus;


    //
    // Find the request that this is for, using the frame context.
    //

    FrameContext = TRANSMIT_CORR(UiFrame);

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    for (p=DeviceContext->StatusQueryQueue.Flink;
         p != &DeviceContext->StatusQueryQueue;
         p=p->Flink) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);

        if (Request->FrameContext == FrameContext) {

             break;

        }

    }

    if (p == &DeviceContext->StatusQueryQueue) {

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        return STATUS_SUCCESS;

    }

    NbfReferenceRequest ("Status Response", Request, RREF_STATUS);

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    ACQUIRE_SPIN_LOCK (&Request->SpinLock, &oldirql);

    //
    // Make sure this request is not stopping.
    //

    if ((Request->Flags & REQUEST_FLAGS_STOPPING) != 0) {
        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        NbfDereferenceRequest ("Stopping", Request, RREF_STATUS);
        return STATUS_SUCCESS;
    }

    //
    // See if this is packet has new data.
    //

    if (Request->BytesWritten == 0) {

        NamesReceived = 0;

    } else {

        NamesReceived = (USHORT)(Request->BytesWritten - sizeof(ADAPTER_STATUS)) / sizeof(NAME_BUFFER);

    }

    if ((UiFrame->Data1 > 0) && (UiFrame->Data1 <= NamesReceived)) {

        //
        // If it is a post-2.1 response, but we already got
        // this data, ignore it.
        //

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        NbfDereferenceRequest ("Duplicate SR", Request, RREF_STATUS);
        return STATUS_SUCCESS;

    }


    //
    // This is new data, append if there is room.
    //

    ResponseLength = ((UiFrame->Data2High & 0x3f) * 256) + UiFrame->Data2Low;

    if ((ULONG)(Request->BytesWritten + ResponseLength) >
        Request->Buffer2Length) {

        ResponseBytesToCopy = (USHORT)(Request->Buffer2Length - Request->BytesWritten);

    } else {

        ResponseBytesToCopy = ResponseLength;

    }

    //
    // Allocate a receive packer for this operation.
    //

    linkage = ExInterlockedPopEntryList(
        &DeviceContext->ReceivePacketPool,
        &DeviceContext->Interlock);

    if (linkage != NULL) {
        ndisPacket = CONTAINING_RECORD( linkage, NDIS_PACKET, ProtocolReserved[0] );
    } else {

        //
        // Could not get a packet, oh well, it is connectionless.
        //

        DeviceContext->ReceivePacketExhausted++;

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        return STATUS_SUCCESS;
    }

    receiveTag = (PRECEIVE_PACKET_TAG)(ndisPacket->ProtocolReserved);
    receiveTag->PacketType = TYPE_STATUS_RESPONSE;
    receiveTag->Connection = (PTP_CONNECTION)Request;

    TargetBuffer = (PUCHAR)Request->ResponseBuffer + Request->BytesWritten;

    //
    // Allocate an MDL to describe the part of the buffer we
    // want transferred.
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        TargetBuffer,
        ResponseBytesToCopy);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {

        ExInterlockedPushEntryList(
            &DeviceContext->ReceivePacketPool,
            linkage,
            &DeviceContext->Interlock);

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        return STATUS_SUCCESS;
    }

    //
    // Assume success, if not we fail the request.
    //

    Request->BytesWritten += ResponseBytesToCopy;


    RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

    NdisChainBufferAtFront(ndisPacket, NdisBuffer);

    //
    // See if the response was too big (we can complete the
    // request here since we still reference it).
    //

    if ((ResponseLength > ResponseBytesToCopy) ||
        (UiFrame->Data2High & 0x40)) {

        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);
        RemoveEntryList (&Request->Linkage);
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        receiveTag->CompleteReceive = TRUE;
        receiveTag->EndOfMessage = FALSE;

    } else {

        //
        // If we are done, complete the packet, otherwise send off
        // the next request (unless it is a pre-2.1 response).
        //

        if ((UiFrame->Data1 > 0) && (UiFrame->Data2High & 0x80)) {

            UCHAR TempSR[MAX_SOURCE_ROUTING];
            PUCHAR ResponseSR;

            receiveTag->CompleteReceive = FALSE;

            //
            // Try to cancel the timer, no harm if we fail.
            //

            ACQUIRE_SPIN_LOCK (&Request->SpinLock, &oldirql);
            if ((Request->Flags & REQUEST_FLAGS_TIMER) != 0) {

                Request->Flags &= ~REQUEST_FLAGS_TIMER;
                RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
                if (KeCancelTimer (&Request->Timer)) {
                    NbfDereferenceRequest ("Status Response: stop timer", Request, RREF_TIMER);
                }

            } else {
                RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
            }

            Request->Retries = DeviceContext->GeneralRetries;

            //
            // Send a STATUS_QUERY directed.
            //

            if (SourceRouting != NULL) {

                RtlCopyMemory(
                    TempSR,
                    SourceRouting,
                    SourceRoutingLength);

                MacCreateNonBroadcastReplySR(
                    &DeviceContext->MacInfo,
                    TempSR,
                    SourceRoutingLength,
                    &ResponseSR);

            } else {

                ResponseSR = NULL;

            }

            NbfSendStatusQuery(
                DeviceContext,
                Request,
                SourceAddress,
                ResponseSR,
                SourceRoutingLength);

        } else {

            ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);
            RemoveEntryList (&Request->Linkage);
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

            receiveTag->CompleteReceive = TRUE;
            receiveTag->EndOfMessage = TRUE;

        }

    }

    //
    // Now do the actual data transfer.
    //

    if (DeviceContext->NdisBindingHandle) {
    
        NdisTransferData (
            &ndisStatus,
            DeviceContext->NdisBindingHandle,
            ReceiveContext,
            DeviceContext->MacInfo.TransferDataOffset +
                3 + sizeof(NBF_HDR_CONNECTIONLESS),
            ResponseBytesToCopy,
            ndisPacket,
            (PUINT)&ndisBytesTransferred);
    }
    else {
        ndisStatus = STATUS_INVALID_DEVICE_STATE;
    }

    if (ndisStatus != NDIS_STATUS_PENDING) {

        NbfTransferDataComplete(
            (NDIS_HANDLE)DeviceContext,
            ndisPacket,
            ndisStatus,
            ndisBytesTransferred);

    }

    return STATUS_SUCCESS;

}   /* NbfProcessStatusResponse */


NTSTATUS
NbfTdiSetInformation(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Irp - the Irp for the requested operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Irp);    // prevent compiler warnings

    return STATUS_NOT_IMPLEMENTED;

} /* NbfTdiQueryInformation */

#if 0

NTSTATUS
NbfQueryInfoEndpoint(
    IN PTP_ENDPOINT Endpoint,
    IN PTDI_REQ_QUERY_INFORMATION TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_ENDPOINT_INFO InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine returns information for the specified endpoint.

Arguments:

    Endpoint - Pointer to transport endpoint context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;

    TdiRequest, TdiRequestLength; // prevent compiler warnings

    if (InfoBufferLength < sizeof (TDI_ENDPOINT_INFO)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ACQUIRE_SPIN_LOCK (&Endpoint->SpinLock, &oldirql);

    *InfoBuffer = Endpoint->Information;        // structure copy.

    RELEASE_SPIN_LOCK (&Endpoint->SpinLock, oldirql);

    *InformationSize = sizeof (Endpoint->Information);

    return STATUS_SUCCESS;
} /* NbfQueryInfoEndpoint */


NTSTATUS
NbfQueryInfoConnection(
    IN PTP_CONNECTION Connection,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_CONNECTION_INFO InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine returns information for the specified connection.

Arguments:

    Connection - Pointer to transport connection object.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;

    TdiRequest, TdiRequestLength; // prevent compiler warnings

    if (InfoBufferLength < sizeof (TDI_CONNECTION_INFO)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql);

    *InfoBuffer = Connection->Information;      // structure copy.

    RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql);

    *InformationSize = sizeof (Connection->Information);

    return STATUS_SUCCESS;
} /* NbfQueryInfoConnection */


NTSTATUS
NbfQueryInfoAddress(
    IN PTP_ADDRESS Address,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_ADDRESS_INFO InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine returns information for the specified address.  We
    don't acquire a spinlock in this routine because there are no statistics
    which must be read atomically.

Arguments:

    Address - Pointer to transport address object.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    SHORT i;
    PSZ p, q;

    TdiRequest, TdiRequestLength; // prevent compiler warnings

    //
    // Calculate whether his buffer is big enough to return the entire
    // information.  The total size of the address information is the
    // size of the fixed part, plus the size of the variable-length flat
    // string in the NETWORK_NAME component of the TRANSPORT_ADDRESS
    // component.
    //

    if (InfoBufferLength <
        sizeof (TDI_ADDRESS_INFO) +
        Address->NetworkName.Length)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Copy both the fixed part of the address information, and the variable
    // part.  The variable part comes from the NETWORK_NAME component of the
    // TRANSPORT_ADDRESS structure.  This component contains a FLAT_STRING,
    // which is of variable length.
    //

    InfoBuffer->Address.AddressComponents = Address->AddressComponents;
    InfoBuffer->Address.Tsap = Address->Tsap;

    InfoBuffer->Address.NetworkName.Name.Length =
        Address->NetworkName.Length;

    p = Address->NetworkName.Buffer;            // p = ptr, source string.
    q = InfoBuffer->Address.NetworkName.Name.Buffer; // q = ptr, dest string.
    for (i=0; i<InfoBuffer->Address.NetworkName.Name.Length; i++) {
        *(q++) = *(p++);
    }

    *InformationSize = sizeof (TDI_ADDRESS_INFO) +
                       Address->NetworkName.Length;

    return STATUS_SUCCESS;
} /* NbfQueryInfoAddress */


NTSTATUS
NbfQueryInfoProvider(
    IN PDEVICE_CONTEXT Provider,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_PROVIDER_INFO InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine returns information for the transport provider.

Arguments:

    Provider - Pointer to device context for provider.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;

    TdiRequest, TdiRequestLength; // prevent compiler warnings

    if (InfoBufferLength < sizeof (TDI_PROVIDER_INFO)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ACQUIRE_SPIN_LOCK (&Provider->SpinLock, &oldirql);

    *InfoBuffer = Provider->Information;        // structure copy.

    RELEASE_SPIN_LOCK (&Provider->SpinLock, oldirql);

    *InformationSize = sizeof (Provider->Information);

    return STATUS_SUCCESS;
} /* NbfQueryInfoProvider */


NTSTATUS
NbfQueryInfoNetman(
    IN PDEVICE_CONTEXT Provider,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_NETMAN_INFO InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine returns information for the specified network-managable
    variable managed by the transport provider.

Arguments:

    Provider - Pointer to device context for provider.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PFLAT_STRING p;
    PTP_VARIABLE v;
    PTDI_NETMAN_VARIABLE n;
    USHORT i;
    ULONG NameOffset, ValueOffset;

    TdiRequest, TdiRequestLength; // prevent compiler warnings
    InfoBufferLength, InformationSize;

    //
    // check param lengths here.
    //

    ACQUIRE_SPIN_LOCK (&Provider->SpinLock, &oldirql);
    NbfReferenceDeviceContext ("Query InfoNetMan", Provider, DCREF_QUERY_INFO);
    for (v=Provider->NetmanVariables; v != NULL; v=v->Fwdlink) {
        if (TdiRequest->Identification == v->VariableSerialNumber) {

            //
            // Return the variable information here.
            //

            NameOffset = sizeof (TDI_NETMAN_INFO);
            ValueOffset = NameOffset + (sizeof (FLAT_STRING)-1) +
                          v->VariableName.Length;

            InfoBuffer->VariableName = NameOffset;
            InfoBuffer->VariableValue = ValueOffset;

            //
            // Copy the variable name to the user's buffer.
            //

            p = (PFLAT_STRING)((PUCHAR)InfoBuffer + NameOffset);
            p->MaximumLength = v->VariableName.Length;
            p->Length        = v->VariableName.Length;
            for (i=0; i<v->VariableName.Length; i++) {
                p->Buffer [i] = v->VariableName.Buffer [i];
            }

            //
            // Now copy the variable's contents to the user's buffer.
            //

            n = (PTDI_NETMAN_VARIABLE)((PUCHAR)InfoBuffer + ValueOffset);
            n->VariableType = v->VariableType;

            switch (v->VariableType) {

                case NETMAN_VARTYPE_ULONG:
                    n->Value.LongValue = v->Value.LongValue;
                    break;

                case NETMAN_VARTYPE_HARDWARE_ADDRESS:
                    n->Value.HardwareAddressValue =
                        v->Value.HardwareAddressValue;
                    break;

                case NETMAN_VARTYPE_STRING:
                    p = &n->Value.StringValue;
                    p->MaximumLength = v->Value.StringValue.Length;
                    p->Length = v->Value.StringValue.Length;
                    for (i=0; i<v->Value.StringValue.Length; i++) {
                        p->Buffer [i] = v->Value.StringValue.Buffer [i];
                    }

            } /* switch */

            RELEASE_SPIN_LOCK (&Provider->SpinLock, oldirql);
            NbfDereferenceDeviceContext ("Query InfoNetMan success", Provider, DCREF_QUERY_INFO);
            return STATUS_SUCCESS;
        } /* if */
    } /* for */

    RELEASE_SPIN_LOCK (&Provider->SpinLock, oldirql);

    NbfDereferenceDeviceContext ("Query InfoNetMan no exist", Provider, DCREF_QUERY_INFO);

    return STATUS_INVALID_INFO_CLASS;             // variable does not exist.
} /* NbfQueryInfoNetman */


NTSTATUS
NbfSetInfoEndpoint(
    IN PTP_ENDPOINT Endpoint,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine sets information for the specified endpoint.

Arguments:

    Endpoint - Pointer to transport endpoint context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PTDI_ENDPOINT_INFO InfoBuffer;

    if (TdiRequestLength !=
        sizeof (TDI_ENDPOINT_INFO) + sizeof (TDI_REQ_SET_INFORMATION) -
                                     sizeof (TDI_INFO_BUFFER)) {
        return STATUS_BUFFER_TOO_SMALL;         // buffer sizes must match.
    }

    InfoBuffer = (PTDI_ENDPOINT_INFO)&TdiRequest->InfoBuffer;

    if ((InfoBuffer->MinimumLookaheadData <= NBF_MAX_LOOKAHEAD_DATA) ||
        (InfoBuffer->MaximumLookaheadData <= NBF_MAX_LOOKAHEAD_DATA) ||
        (InfoBuffer->MinimumLookaheadData > InfoBuffer->MaximumLookaheadData)) {
        return STATUS_INVALID_PARAMETER;
    }

    ACQUIRE_SPIN_LOCK (&Endpoint->SpinLock, &oldirql);

    //
    // Set minimum lookahead data size.  This is the number of bytes of
    // contiguous data that will be supplied to TDI_IND_RECEIVE and
    // TDI_IND_RECEIVE_DATAGRAM event handlers at indication time.
    //

    Endpoint->Information.MinimumLookaheadData = InfoBuffer->MinimumLookaheadData;

    //
    // Set maximum lookahead data size.  This is the number of bytes of
    // contiguous data that will be supplied to TDI_IND_RECEIVE and
    // TDI_IND_RECEIVE_DATAGRAM event handlers at indication time.
    //

    Endpoint->Information.MaximumLookaheadData = InfoBuffer->MaximumLookaheadData;

    //
    // Reset all the statistics to his new values.
    //

    Endpoint->Information.TransmittedTsdus    = InfoBuffer->TransmittedTsdus;
    Endpoint->Information.ReceivedTsdus       = InfoBuffer->ReceivedTsdus;
    Endpoint->Information.TransmissionErrors  = InfoBuffer->TransmissionErrors;
    Endpoint->Information.ReceiveErrors       = InfoBuffer->ReceiveErrors;
    Endpoint->Information.PriorityLevel       = InfoBuffer->PriorityLevel;
    Endpoint->Information.SecurityLevel       = InfoBuffer->SecurityLevel;
    Endpoint->Information.SecurityCompartment = InfoBuffer->SecurityCompartment;

    //
    // The State and Event fields are read-only, so we DON'T set them here.
    //

    RELEASE_SPIN_LOCK (&Endpoint->SpinLock, oldirql);

    return STATUS_SUCCESS;
} /* NbfSetInfoEndpoint */


NTSTATUS
NbfSetInfoAddress(
    IN PTP_ADDRESS Address,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine sets information for the specified address.  Currently,
    all the user-visible fields in the transport address object are read-only.

Arguments:

    Address - Pointer to transport address object.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    Address, TdiRequest, TdiRequestLength; // prevent compiler warnings

    return STATUS_SUCCESS;
} /* NbfSetInfoAddress */


NTSTATUS
NbfSetInfoConnection(
    IN PTP_CONNECTION Connection,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine sets information for the specified connection.

Arguments:

    Connection - Pointer to transport connection object.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PTDI_CONNECTION_INFO InfoBuffer;

    if (TdiRequestLength !=
        sizeof (TDI_CONNECTION_INFO) + sizeof (TDI_REQ_SET_INFORMATION) -
                                       sizeof (TDI_INFO_BUFFER)) {
        return STATUS_BUFFER_TOO_SMALL;         // buffer sizes must match.
    }

    InfoBuffer = (PTDI_CONNECTION_INFO)&TdiRequest->InfoBuffer;

    ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql);

    //
    // Reset all the statistics to his new values.
    //

    Connection->Information.TransmittedTsdus   = InfoBuffer->TransmittedTsdus;
    Connection->Information.ReceivedTsdus      = InfoBuffer->ReceivedTsdus;
    Connection->Information.TransmissionErrors = InfoBuffer->TransmissionErrors;
    Connection->Information.ReceiveErrors      = InfoBuffer->ReceiveErrors;

    //
    // The State and Event fields are read-only, so we DON'T set them here.
    //

    RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql);

    return STATUS_SUCCESS;
} /* NbfSetInfoConnection */


NTSTATUS
NbfSetInfoProvider(
    IN PDEVICE_CONTEXT Provider,
    IN PTDI_REQUEST_KERNEL TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine sets information for the specified transport provider.

Arguments:

    Provider - Pointer to device context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PTDI_PROVIDER_INFO InfoBuffer;

    if (TdiRequestLength !=
        sizeof (TDI_PROVIDER_INFO) + sizeof (TDI_REQ_SET_INFORMATION) -
                                     sizeof (TDI_INFO_BUFFER)) {
        return STATUS_BUFFER_TOO_SMALL;         // buffer sizes must match.
    }

    InfoBuffer = (PTDI_PROVIDER_INFO)&TdiRequest->InfoBuffer;

    //
    // By changing the service flags the caller can request additional
    // or fewer services on the fly.  Make sure that he is requesting
    // services we can provide, or else fail the request.
    //

    if (InfoBuffer->ServiceFlags & ~NBF_SERVICE_FLAGS) {
        return STATUS_NOT_SUPPORTED;
    }

    ACQUIRE_SPIN_LOCK (&Provider->SpinLock, &oldirql);

    //
    // Reset all the statistics to his new values.
    //

    Provider->Information.TransmittedTsdus   = InfoBuffer->TransmittedTsdus;
    Provider->Information.ReceivedTsdus      = InfoBuffer->ReceivedTsdus;
    Provider->Information.TransmissionErrors = InfoBuffer->TransmissionErrors;
    Provider->Information.ReceiveErrors      = InfoBuffer->ReceiveErrors;
    Provider->Information.DiscardedFrames    = InfoBuffer->DiscardedFrames;
    Provider->Information.ReceiveErrors      = InfoBuffer->ReceiveErrors;
    Provider->Information.OversizeTsdusReceived = InfoBuffer->OversizeTsdusReceived;
    Provider->Information.UndersizeTsdusReceived = InfoBuffer->UndersizeTsdusReceived;
    Provider->Information.MulticastTsdusReceived = InfoBuffer->MulticastTsdusReceived;
    Provider->Information.BroadcastTsdusReceived = InfoBuffer->BroadcastTsdusReceived;
    Provider->Information.MulticastTsdusTransmitted = InfoBuffer->MulticastTsdusTransmitted;
    Provider->Information.BroadcastTsdusTransmitted = InfoBuffer->BroadcastTsdusTransmitted;
    Provider->Information.SendTimeouts       = InfoBuffer->SendTimeouts;
    Provider->Information.ReceiveTimeouts    = InfoBuffer->ReceiveTimeouts;
    Provider->Information.ConnectionIndicationsReceived = InfoBuffer->ConnectionIndicationsReceived;
    Provider->Information.ConnectionIndicationsAccepted = InfoBuffer->ConnectionIndicationsAccepted;
    Provider->Information.ConnectionsInitiated = InfoBuffer->ConnectionsInitiated;
    Provider->Information.ConnectionsAccepted  = InfoBuffer->ConnectionsAccepted;

    //
    // The following fields are read-only, so we DON'T set them here:
    // Version, MaxTsduSize, MaxConnectionUserData, MinimumLookaheadData,
    // MaximumLookaheadData.
    //

    RELEASE_SPIN_LOCK (&Provider->SpinLock, oldirql);

    return STATUS_SUCCESS;
} /* NbfSetInfoProvider */


NTSTATUS
NbfSetInfoNetman(
    IN PDEVICE_CONTEXT Provider,
    IN PTDI_REQ_SET_INFORMATION TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine sets information for the specified transport provider's
    network-managable variable.

Arguments:

    Provider - Pointer to device context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTDI_NETMAN_INFO InfoBuffer;

    Provider; // prevent compiler warnings

    if (TdiRequestLength !=
        sizeof (TDI_NETMAN_INFO) + sizeof (TDI_REQ_SET_INFORMATION) -
                                   sizeof (TDI_INFO_BUFFER)) {
        return STATUS_BUFFER_TOO_SMALL;         // buffer sizes must match.
    }

    InfoBuffer = (PTDI_NETMAN_INFO)&TdiRequest->InfoBuffer;

    //
    // set the network-managable variable here.
    //

    return STATUS_SUCCESS;
} /* NbfSetInfoNetman */


NTSTATUS
NbfTdiQueryInformation(
    IN PTP_ENDPOINT Endpoint,
    IN PTDI_REQ_QUERY_INFORMATION TdiRequest,
    IN ULONG TdiRequestLength,
    OUT PTDI_INFO_BUFFER InfoBuffer,
    IN ULONG InfoBufferLength,
    OUT PULONG InformationSize
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Endpoint - Pointer to transport endpoint context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

    InfoBuffer - Pointer to output buffer to return information into.

    InfoBufferLength - Length of output buffer.

    InformationSize - Pointer to ulong where actual size of returned
        information is to be stored.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PTP_CONNECTION Connection;

    switch (TdiRequest->InformationClass) {

        //
        // ENDPOINT information: return information about the endpoint
        // to which this request was submitted.
        //

        case TDI_INFO_CLASS_ENDPOINT:
            Status = NbfQueryInfoEndpoint (
                         Endpoint,
                         TdiRequest,
                         TdiRequestLength,
                         (PTDI_ENDPOINT_INFO)InfoBuffer,
                         InfoBufferLength,
                         InformationSize);
            break;

        //
        // CONNECTION information: return information about a connection
        // that is associated with the endpoint on which this request was
        // submitted.
        //

        case TDI_INFO_CLASS_CONNECTION:
            // This causes a connection reference which is removed below.
            Connection = NbfLookupConnectionById (
                             Endpoint,
                             TdiRequest->Identification);
            if (Connection == NULL) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            Status = NbfQueryInfoConnection (
                         Connection,
                         TdiRequest,
                         TdiRequestLength,
                         (PTDI_CONNECTION_INFO)InfoBuffer,
                         InfoBufferLength,
                         InformationSize);

            NbfDereferenceConnection("Query Connection Info", Connection, CREF_BY_ID);
            break;

        //
        // ADDRESS information: return information about the address object
        // that is associated with the endpoint on which this request was
        // submitted.
        //

        case TDI_INFO_CLASS_ADDRESS:
            Status = NbfQueryInfoAddress (
                         Endpoint->BoundAddress,
                         TdiRequest,
                         TdiRequestLength,
                         (PTDI_ADDRESS_INFO)InfoBuffer,
                         InfoBufferLength,
                         InformationSize);
            break;

        //
        // PROVIDER information: return information about the transport
        // provider itself.
        //

        case TDI_INFO_CLASS_PROVIDER:
            Status = NbfQueryInfoProvider (
                         Endpoint->BoundAddress->Provider,
                         TdiRequest,
                         TdiRequestLength,
                         (PTDI_PROVIDER_INFO)InfoBuffer,
                         InfoBufferLength,
                         InformationSize);
            break;

        //
        // NETMAN information: return information about the network-managable
        // variables managed by the provider itself.
        //

        case TDI_INFO_CLASS_NETMAN:
            Status = NbfQueryInfoNetman (
                         Endpoint->BoundAddress->Provider,
                         TdiRequest,
                         TdiRequestLength,
                         (PTDI_NETMAN_INFO)InfoBuffer,
                         InfoBufferLength,
                         InformationSize);
            break;

        default:
            Status = STATUS_INVALID_INFO_CLASS;

    } /* switch */

    return Status;
} /* TdiQueryInformation */


NTSTATUS
TdiSetInformation(
    IN PTP_ENDPOINT Endpoint,
    IN PTDI_REQ_SET_INFORMATION TdiRequest,
    IN ULONG TdiRequestLength
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Endpoint - Pointer to transport endpoint context.

    TdiRequest - Pointer to request buffer.

    TdiRequestLength - Length of request buffer.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PTP_CONNECTION Connection;

    switch (TdiRequest->InformationClass) {

        //
        // ENDPOINT information: set information on the endpoint
        // to which this request was submitted.
        //

        case TDI_INFO_CLASS_ENDPOINT:
            Status = NbfSetInfoEndpoint (
                         Endpoint,
                         TdiRequest,
                         TdiRequestLength);
            break;

        //
        // CONNECTION information: set information for a connection
        // that is associated with the endpoint on which this request
        // was submitted.
        //

    case TDI_INFO_CLASS_CONNECTION:
            // This causes a connection reference which is removed below.
            Connection = NbfLookupConnectionById (
                             Endpoint,
                             TdiRequest->Identification);
            if (Connection == NULL) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            Status = NbfSetInfoConnection (
                         Connection,
                         TdiRequest,
                         TdiRequestLength);

            NbfDereferenceConnection("Set Connection Info", Connection, CREF_BY_ID);
            break;

        //
        // ADDRESS information: set information for the address object
        // that is associated with the endpoint on which this request
        // was submitted.
        //

        case TDI_INFO_CLASS_ADDRESS:
            Status = NbfSetInfoAddress (
                         Endpoint->BoundAddress,
                         TdiRequest,
                         TdiRequestLength);
            break;

        //
        // PROVIDER information: set information for the transport
        // provider itself.
        //

        case TDI_INFO_CLASS_PROVIDER:
            Status = NbfSetInfoProvider (
                         Endpoint->BoundAddress->Provider,
                         TdiRequest,
                         TdiRequestLength);
            break;

        //
        // NETMAN information: set information for the network-managable
        // variables managed by the provider itself.
        //

        case TDI_INFO_CLASS_NETMAN:
            Status = NbfSetInfoNetman (
                         Endpoint->BoundAddress->Provider,
                         TdiRequest,
                         TdiRequestLength);
            break;

        default:
            Status = STATUS_INVALID_INFO_CLASS;

    } /* switch */

    return Status;
} /* TdiSetInformation */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\framecon.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    framecon.c

Abstract:

    This module contains routines which build NetBIOS Frames Protocol frames,
    both connection-oriented and connectionless.  The following frames are
    constructed by routines in this module:

        o    NBF_CMD_ADD_GROUP_NAME_QUERY
        o    NBF_CMD_ADD_NAME_QUERY
        o    NBF_CMD_NAME_IN_CONFLICT
        o    NBF_CMD_STATUS_QUERY
        o    NBF_CMD_TERMINATE_TRACE
        o    NBF_CMD_DATAGRAM
        o    NBF_CMD_DATAGRAM_BROADCAST
        o    NBF_CMD_NAME_QUERY
        o    NBF_CMD_ADD_NAME_RESPONSE
        o    NBF_CMD_NAME_RECOGNIZED
        o    NBF_CMD_STATUS_RESPONSE
        o    NBF_CMD_TERMINATE_TRACE2
        o    NBF_CMD_DATA_ACK
        o    NBF_CMD_DATA_FIRST_MIDDLE
        o    NBF_CMD_DATA_ONLY_LAST
        o    NBF_CMD_SESSION_CONFIRM
        o    NBF_CMD_SESSION_END
        o    NBF_CMD_SESSION_INITIALIZE
        o    NBF_CMD_NO_RECEIVE
        o    NBF_CMD_RECEIVE_OUTSTANDING
        o    NBF_CMD_RECEIVE_CONTINUE
        o    NBF_CMD_SESSION_ALIVE

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
ConstructAddGroupNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN USHORT Correlator,               // correlator for ADD_NAME_RESPONSE.
    IN PNAME GroupName                  // NetBIOS group name to be added.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_ADD_GROUP_NAME_QUERY connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    Correlator - Correlator for ADD_NAME_RESPONSE frame.

    GroupName - Pointer to NetBIOS group name to be added.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructAddGroupNameQuery:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_ADD_GROUP_NAME_QUERY;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = 0;
        RawFrame->SourceName [i] = GroupName [i];
    }
} /* ConstructAddGroupNameQuery */


VOID
ConstructAddNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN USHORT Correlator,               // correlator for ADD_NAME_RESPONSE.
    IN PNAME Name                       // NetBIOS name to be added.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_ADD_NAME_QUERY connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    Correlator - Correlator for ADD_NAME_RESPONSE frame.

    Name - Pointer to NetBIOS name to be added.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructAddNameQuery:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_ADD_NAME_QUERY;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = 0;
        RawFrame->SourceName [i] = Name [i];
    }
} /* ConstructAddNameQuery */


VOID
ConstructNameInConflict(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME ConflictingName,           // NetBIOS name that is conflicting.
    IN PNAME SendingPermanentName       // NetBIOS permanent node name of sender.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_NAME_IN_CONFLICT connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    Conflictingname - Pointer to NetBIOS name that is conflicting.

    SendingPermanentName - Pointer to NetBIOS permanent node name of sender.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructNameInConflict:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_NAME_IN_CONFLICT;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ConflictingName[i];
        RawFrame->SourceName [i] = SendingPermanentName[i];
    }

} /* ConstructNameInConflict */


VOID
ConstructStatusQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR RequestType,               // type of request.
    IN USHORT BufferLength,             // length of user's status buffer.
    IN USHORT Correlator,               // correlator for STATUS_RESPONSE.
    IN PNAME ReceiverName,              // NetBIOS name of receiver.
    IN PNAME SendingPermanentName       // NetBIOS permanent node name of sender.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_STATUS_QUERY connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    RequestType - Type of request. One of:
        0 - request is 1.x or 2.0.
        1 - first request, 2.1 or above.
        >1 - subsequent request, 2.1 or above.

    BufferLength - Length of user's status buffer.

    Correlator - Correlator for STATUS_RESPONSE frame.

    ReceiverName - Pointer to NetBIOS name of receiver.

    SendingPermanentName - Pointer to NetBIOS permanent node name of sender.

Return Value:

    none.

--*/

{
    SHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint1 ("ConstructStatusQuery:  Entered, frame: %lx\n", RawFrame);
    }

    RawFrame->Command = NBF_CMD_STATUS_QUERY;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = RequestType;
    RawFrame->Data2Low = (UCHAR)(BufferLength & 0xff);
    RawFrame->Data2High = (UCHAR)(BufferLength >> 8);
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = Correlator;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ReceiverName [i];
        RawFrame->SourceName [i] = SendingPermanentName [i];
    }

} /* ConstructStatusQuery */


VOID
ConstructDatagram(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME ReceiverName,              // NetBIOS name of receiver.
    IN PNAME SenderName                 // NetBIOS name of sender.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_DATAGRAM connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    ReceiverName - Pointer to a NetBIOS name of the receiver.

    SenderName - Pointer to a NetBIOS name of the sender.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructDatagram:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_DATAGRAM;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ReceiverName [i];
        RawFrame->SourceName [i] = SenderName [i];
    }
} /* ConstructDatagram */


VOID
ConstructDatagramBroadcast(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME SenderName                 // NetBIOS name of sender.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_DATAGRAM_BROADCAST connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    SenderName - Pointer to a NetBIOS name of the sender.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructDatagramBroadcast:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_DATAGRAM_BROADCAST;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = 0;
        RawFrame->SourceName [i] = SenderName [i];
    }
} /* ConstructDatagramBroadcast */


VOID
ConstructNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN UCHAR LocalSessionNumber,        // LSN assigned to session (0=FIND_NAME).
    IN USHORT Correlator,               // correlator in NAME_RECOGNIZED.
    IN PNAME SenderName,                // NetBIOS name of sender.
    IN PNAME ReceiverName               // NetBIOS name of receiver.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_NAME_QUERY connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    NameType - Type of name, one of the following:
        NAME_QUERY_LSN_FIND_NAME

    LocalSessionNumber - LSN assigned to session (0=FIND.NAME).

    Correlator - Correlator in NAME_RECOGNIZED.

    SenderName - Pointer to a NetBIOS name of the sender.

    ReceiverName - Pointer to a NetBIOS name of the receiver.

Return Value:

    none.

--*/

{
    SHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint1 ("ConstructNameQuery:  Entered, frame: %lx\n", RawFrame);
    }

    RawFrame->Command = NBF_CMD_NAME_QUERY;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = LocalSessionNumber;
    RawFrame->Data2High = NameType;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = Correlator;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ReceiverName [i];
        RawFrame->SourceName [i] = SenderName [i];
    }
} /* ConstructNameQuery */


VOID
ConstructAddNameResponse(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN USHORT Correlator,               // correlator from ADD_[GROUP_]NAME_QUERY.
    IN PNAME Name                       // NetBIOS name being responded to.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_ADD_NAME_RESPONSE connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    NameType - Type of name, either group or unique.

    Correlator - Correlator from ADD_[GROUP]NAME_QUERY.

    Name - Pointer to NetBIOS name being responded to.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructAddNameResponse:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_ADD_NAME_RESPONSE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = NameType;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = Name [i];
        RawFrame->SourceName [i] = Name [i];
    }
} /* ConstructAddNameResponse */


VOID
ConstructNameRecognized(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN UCHAR LocalSessionNumber,        // LSN assigned to session.
    IN USHORT NameQueryCorrelator,      // correlator from NAME_QUERY.
    IN USHORT Correlator,               // correlator expected from next response.
    IN PNAME SenderName,                // NetBIOS name of sender.
    IN PNAME ReceiverName               // NetBIOS name of receiver.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_NAME_RECOGNIZED connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    NameType - Type of name, either group or unique.

    LocalSessionNumber - LSN assigned to session.  Special values are:
        NAME_RECOGNIZED_LSN_NO_LISTENS  // no listens available.
        NAME_RECOGNIZED_LSN_FIND_NAME   // this is a find name response.
        NAME_RECOGNIZED_LSN_NO_RESOURCE // listen available, but no resources.

    NameQueryCorrelator - Correlator from NAME_QUERY.

    Correlator - Correlator expected from next response.

    SenderName - Pointer to a NetBIOS name of the sender.

    ReceiverName - Pointer to a NetBIOS name of the receiver.

Return Value:

    none.

--*/

{
    USHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructNameRecognized:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_NAME_RECOGNIZED;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;                // reserved field, MBZ.
    RawFrame->Data2Low = LocalSessionNumber;
    RawFrame->Data2High = NameType;
    TRANSMIT_CORR(RawFrame) = NameQueryCorrelator;
    RESPONSE_CORR(RawFrame) = Correlator;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ReceiverName [i];
        RawFrame->SourceName [i] = SenderName [i];
    }
} /* ConstructNameRecognized */


VOID
ConstructStatusResponse(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR RequestType,               // type of request, defined below.
    IN BOOLEAN Truncated,               // data is truncated.
    IN BOOLEAN DataOverflow,            // too much data for user's buffer.
    IN USHORT DataLength,               // length of data sent.
    IN USHORT Correlator,               // correlator from STATUS_QUERY.
    IN PNAME ReceivingPermanentName,    // NetBIOS permanent node name of receiver.
    IN PNAME SenderName                 // NetBIOS name of sender.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_STATUS_RESPONSE connectionless
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 44-byte connectionless frame buffer.

    RequestType - type of request, one of the below:
        0 - request is 1.x or 2.0.
        >0 - number of names, 2.1 or above.

    Truncated - TRUE if there are more names.

    DataOverflow - TRUE if the total data is larger than the user's buffer.

    DataLength - The length of the data in Buffer.

    Correlator - Correlator from STATUS_QUERY.

    ReceivingPermanentName - Pointer to the NetBIOS permanent node name of the receiver,
        as passed in the STATUS_QUERY frame.

    SenderName - Pointer to a NetBIOS name of the sender.

Return Value:

    none.

--*/

{
    SHORT i;

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructStatusResponse:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_STATUS_RESPONSE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTIONLESS);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = RequestType;
    RawFrame->Data2Low = (UCHAR)(DataLength & 0xff);
    RawFrame->Data2High = (UCHAR)((DataLength >> 8) +
                                  (Truncated << 7) +
                                  (DataOverflow << 6));
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = 0;
    for (i=0; i<NETBIOS_NAME_LENGTH; i++) {
        RawFrame->DestinationName [i] = ReceivingPermanentName [i];
        RawFrame->SourceName [i] = SenderName [i];
    }

} /* ConstructStatusResponse */


VOID
ConstructDataAck(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Correlator,               // correlator from DATA_ONLY_LAST.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_DATA_ACK connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Correlator - Correlator from DATA_ONLY_LAST being acked.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructDataAck:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_DATA_ACK;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructDataAck */


VOID
ConstructDataOnlyLast(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN BOOLEAN Resynched,               // TRUE if we are resynching.
    IN USHORT Correlator,               // correlator for RECEIVE_CONTINUE.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_DATA_ONLY_LAST connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Resynched - TRUE if we are resynching and should set the
        correct bit in the frame.

    Correlator - Correlator for RECEIVE_CONTINUE, if any.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructDataOnlyLast:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_DATA_ONLY_LAST;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    ASSERT (TRUE == (UCHAR)1);
    RawFrame->Data2Low = Resynched;
    RawFrame->Data2High = (UCHAR)0;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = Correlator;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructDataOnlyLast */


VOID
ConstructSessionConfirm(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN UCHAR Options,                   // bitflag options, defined below.
    IN USHORT MaximumUserBufferSize,    // max size of user frame on session.
    IN USHORT Correlator,               // correlator from SESSION_INITIALIZE.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_SESSION_CONFIRM connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Options - Bitflag options, any of the following:
        SESSION_CONFIRM_OPTIONS_20      // set if NETBIOS 2.0 or above.
        SESSION_CONFIRM_NO_ACK          // set if NO.ACK protocol supported.

    MaximumUserBufferSize - Maximum size of user data per frame on this
        session, in bytes.  This is limited by the following constant:
        SESSION_CONFIRM_MAXIMUM_FRAME_SIZE // defined limit of this field.

    Correlator - Correlator from SESSION_INITIALIZE.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructSessionConfirm:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_SESSION_CONFIRM;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = Options;
    RawFrame->Data2Low = (UCHAR)(MaximumUserBufferSize & 0xff);
    RawFrame->Data2High = (UCHAR)(MaximumUserBufferSize >> 8);
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructSessionConfirm */


VOID
ConstructSessionEnd(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Reason,                   // reason for termination, defined below.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_SESSION_END connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Reason - Reason code for termination, any of the following:
        SESSION_END_REASON_HANGUP       // normal termination via HANGUP.
        SESSION_END_REASON_ABEND        // abnormal session termination.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructSessionEnd:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_SESSION_END;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    RawFrame->Data2Low = (UCHAR)(Reason & 0xff);
    RawFrame->Data2High = (UCHAR)(Reason >> 8);
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructSessionEnd */


VOID
ConstructSessionInitialize(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN UCHAR Options,                   // bitflag options, defined below.
    IN USHORT MaximumUserBufferSize,    // max size of user frame on session.
    IN USHORT NameRecognizedCorrelator, // correlator from NAME_RECOGNIZED.
    IN USHORT Correlator,               // correlator for SESSION_CONFIRM.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_SESSION_INITIALIZE connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Options - Bitflag options, any of the following:
        SESSION_INITIALIZE_OPTIONS_20   // set if NETBIOS 2.0 or above.
        SESSION_INITIALIZE_NO_ACK       // set if NO.ACK protocol supported.

    MaximumUserBufferSize - Maximum size of user data per frame on this
        session, in bytes.  This is limited by the following constant:
        SESSION_INITIALIZE_MAXIMUM_FRAME_SIZE // defined limit of this field.

    NameRecognizedCorrelator - Correlator from NAME_RECOGNIZED.

    Correlator - Correlator for SESSION_CONFIRM.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructSessionInitialize:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_SESSION_INITIALIZE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = Options;
    RawFrame->Data2Low = (UCHAR)(MaximumUserBufferSize & 0xff);
    RawFrame->Data2High = (UCHAR)(MaximumUserBufferSize >> 8);
    TRANSMIT_CORR(RawFrame) = NameRecognizedCorrelator;
    RESPONSE_CORR(RawFrame) = Correlator;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructSessionInitialize */


VOID
ConstructNoReceive(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Options,                  // option bitflags, defined below.
    IN USHORT BytesAccepted,            // number of bytes accepted.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_NO_RECEIVE connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Options - Bitflag options, any of the following:
        NO_RECEIVE_OPTIONS_PARTIAL_NO_ACK   // NO.ACK data partially received.

    BytesAccepted - Number of bytes accepted, current outstanding message.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
//    Options; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructNoReceive:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_NO_RECEIVE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    if (Options == NO_RECEIVE_PARTIAL_NO_ACK) {
        RawFrame->Data1 = NO_RECEIVE_PARTIAL_NO_ACK;
    } else {
        RawFrame->Data1 = 0;
    }
    RawFrame->Data2Low = (UCHAR)(BytesAccepted & 0xff);
    RawFrame->Data2High = (UCHAR)(BytesAccepted >> 8);
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructNoReceive */


VOID
ConstructReceiveOutstanding(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT BytesAccepted,            // number of bytes accepted.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_RECEIVE_OUTSTANDING connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    BytesAccepted - Number of bytes accepted, current outstanding message.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructReceiveOutstanding:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_RECEIVE_OUTSTANDING;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    RawFrame->Data2Low = (UCHAR)(BytesAccepted & 0xff);
    RawFrame->Data2High = (UCHAR)(BytesAccepted >> 8);
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructReceiveOutstanding */


VOID
ConstructReceiveContinue(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Correlator,               // correlator from DATA_FIRST_MIDDLE
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_RECEIVE_CONTINUE connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

    Correlator - The correlator from the DATA_FIRST_MIDDLE frame.

    LocalSessionNumber - Session number of SENDER.

    RemoteSessionNumber - Session number of RECEIVER.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructReceiveContinue:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_RECEIVE_CONTINUE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = Correlator;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = LocalSessionNumber;
    RawFrame->DestinationSessionNumber = RemoteSessionNumber;
} /* ConstructReceiveContinue */

#if 0

VOID
ConstructSessionAlive(
    IN PNBF_HDR_CONNECTION RawFrame     // frame buffer to format.
    )

/*++

Routine Description:

    This routine constructs an NBF_CMD_SESSION_ALIVE connection-oriented
    NetBIOS Frame.

Arguments:

    RawFrame - Pointer to an unformatted 14-byte connection-oriented buffer.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_FRAMECON) {
        NbfPrint0 ("ConstructSessionAlive:  Entered.\n");
    }

    RawFrame->Command = NBF_CMD_SESSION_ALIVE;
    HEADER_LENGTH(RawFrame) = sizeof(NBF_HDR_CONNECTION);
    HEADER_SIGNATURE(RawFrame) = NETBIOS_SIGNATURE;
    RawFrame->Data1 = 0;
    RawFrame->Data2Low = 0;
    RawFrame->Data2High = 0;
    TRANSMIT_CORR(RawFrame) = (USHORT)0;
    RESPONSE_CORR(RawFrame) = (USHORT)0;
    RawFrame->SourceSessionNumber = 0;
    RawFrame->DestinationSessionNumber = 0;
} /* ConstructSessionAlive */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\iframes.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    iframes.c

Abstract:

    This module contains routines called to handle i-frames received
    from the data link provider. Most of these routines are called at receive
    indication time.

    Also included here are routines that process data at receive completion
    time. These are limited to handling DFM/DOL frames.

    The following frame types are cracked by routines in this module:

        o    NBF_CMD_DATA_ACK
        o    NBF_CMD_DATA_FIRST_MIDDLE
        o    NBF_CMD_DATA_ONLY_LAST
        o    NBF_CMD_SESSION_CONFIRM
        o    NBF_CMD_SESSION_END
        o    NBF_CMD_SESSION_INITIALIZE
        o    NBF_CMD_NO_RECEIVE
        o    NBF_CMD_RECEIVE_OUTSTANDING
        o    NBF_CMD_RECEIVE_CONTINUE
        o    NBF_CMD_SESSION_ALIVE

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode, DISPATCH_LEVEL.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

extern ULONG StartTimerDelayedAck;

#define NbfUsePiggybackAcks   1
#if DBG
extern ULONG NbfDebugPiggybackAcks;
#endif


VOID
NbfAcknowledgeDataOnlyLast(
    IN PTP_CONNECTION Connection,
    IN ULONG MessageLength
    )

/*++

Routine Description:

    This routine takes care of acknowledging a DOL which has
    been received. It either sends a DATA_ACK right away, or
    queues a request for a piggyback ack.

    NOTE: This routine is called with the connection spinlock
    held, and it returns with it released. IT MUST BE CALLED
    AT DPC LEVEL.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    MessageLength - the total length (including all DFMs and this
        DOL) of the message.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PDEVICE_CONTEXT DeviceContext;


    //
    // Determine if we need to ack at all.
    //

    if (Connection->CurrentReceiveNoAck) {
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        return;
    }


    //
    // Determine if a piggyback ack is feasible.
    //
    if (NbfUsePiggybackAcks &&
        Connection->CurrentReceiveAckQueueable) {

        //
        // The sender allows it, see if we want to.
        //

#if 0
        //
        // First reset this variable, to be safe.
        //

        Connection->CurrentReceiveAckQueueable = FALSE;
#endif

        //
        // For long sends, don't bother since these
        // often happen without back traffic.
        //

        if (MessageLength >= 8192L) {
#if DBG
           if (NbfDebugPiggybackAcks) {
               NbfPrint0("M");
           }
#endif
           goto NormalDataAck;
        }

        //
        // If there have been two receives in a row with
        // no sends in between, don't wait for back traffic.
        //

        if (Connection->ConsecutiveReceives >= 2) {
#if DBG
           if (NbfDebugPiggybackAcks) {
               NbfPrint0("R");
           }
#endif
           goto NormalDataAck;
        }

        //
        // Do not put a stopping connection on the DataAckQueue
        //

        if ((Connection->Flags & CONNECTION_FLAGS_READY) == 0) {
#if DBG
           if (NbfDebugPiggybackAcks) {
               NbfPrint0("S");
           }
#endif
           goto NormalDataAck;
        }

        //
        // Queue the piggyback ack request. If the timer expires
        // before a DFM or DOL is sent, a normal DATA ACK will
        // be sent.
        //
        // Connection->Header.TransmitCorrelator has already been filled in.
        //

        //
        // BAD! We shouldn't already have an ack queued.
        //

        ASSERT ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) == 0);

        KeQueryTickCount (&Connection->ConnectStartTime);
        Connection->DeferredFlags |= CONNECTION_FLAGS_DEFERRED_ACK;

#if DBG
        if (NbfDebugPiggybackAcks) {
            NbfPrint0("Q");
        }
#endif

        DeviceContext = Connection->Link->Provider;

        if (!Connection->OnDataAckQueue) {

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            if (!Connection->OnDataAckQueue) {

                Connection->OnDataAckQueue = TRUE;
                InsertTailList (&DeviceContext->DataAckQueue, &Connection->DataAckLinkage);

                if (!(DeviceContext->a.i.DataAckQueueActive)) {

                    StartTimerDelayedAck++;
                    NbfStartShortTimer (DeviceContext);
                    DeviceContext->a.i.DataAckQueueActive = TRUE;

                }

            }

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        }

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        INCREMENT_COUNTER (DeviceContext, PiggybackAckQueued);

        return;

    }

NormalDataAck:;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    NbfSendDataAck (Connection);

} /* NbfAcknowledgeDataOnlyLast */


NTSTATUS
ProcessSessionConfirm(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming SESSION_CONFIRM NetBIOS frame.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL cancelirql;
    PLIST_ENTRY p;
    PTP_REQUEST request;
    PTDI_CONNECTION_INFORMATION remoteInformation;
    USHORT HisMaxDataSize;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    ULONG returnLength;
    TA_NETBIOS_ADDRESS TempAddress;
//    BOOLEAN TimerWasSet;

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint1 ("ProcessSessionConfirm:  Entered, Flags: %lx\n", Connection->Flags);
    }

    Connection->IndicationInProgress = FALSE;

    IoAcquireCancelSpinLock (&cancelirql);
    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    if ((Connection->Flags & CONNECTION_FLAGS_WAIT_SC) != 0) {
        Connection->Flags &= ~CONNECTION_FLAGS_WAIT_SC;

        //
        // Get his capability bits and maximum frame size.
        //

        if (IFrame->Data1 & SESSION_CONFIRM_OPTIONS_20) {
            Connection->Flags |= CONNECTION_FLAGS_VERSION2;
        }

        if (Connection->Link->Loopback) {
            Connection->MaximumDataSize = 0x8000;
        } else {
            Connection->MaximumDataSize = (USHORT)
                (Connection->Link->MaxFrameSize - sizeof(NBF_HDR_CONNECTION) - sizeof(DLC_I_FRAME));

            HisMaxDataSize = (USHORT)(IFrame->Data2Low + IFrame->Data2High*256);
            if (HisMaxDataSize < Connection->MaximumDataSize) {
                Connection->MaximumDataSize = HisMaxDataSize;
            }
        }

        //
        // Build a standard Netbios header for speed when sending
        // data frames.
        //

        ConstructDataOnlyLast(
            &Connection->NetbiosHeader,
            FALSE,
            (USHORT)0,
            Connection->Lsn,
            Connection->Rsn);

        //
        // Turn off the connection request timer if there is one, and set
        // this connection's state to READY.
        //

        Connection->Flags |= CONNECTION_FLAGS_READY;

        INCREMENT_COUNTER (Connection->Provider, OpenConnections);

        //
        // Record that the connect request has been successfully
        // completed by TpCompleteRequest.
        //


        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

        if (Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) {
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
            Connection->IndicationInProgress = FALSE;
            IoReleaseCancelSpinLock (cancelirql);
            return STATUS_SUCCESS;
        }

        //
        // Complete the TdiConnect request.
        //

        p = RemoveHeadList (&Connection->InProgressRequest);

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        //
        // Now complete the request and get out.
        //

        if (p == &Connection->InProgressRequest) {

            Connection->IndicationInProgress = FALSE;
            IoReleaseCancelSpinLock (cancelirql);
            return STATUS_SUCCESS;

        }


        //
        // We have a completed connection with a queued connect. Complete
        // the connect.
        //

        request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        IoSetCancelRoutine(request->IoRequestPacket, NULL);
        IoReleaseCancelSpinLock(cancelirql);

        irpSp = IoGetCurrentIrpStackLocation (request->IoRequestPacket);
        remoteInformation =
           ((PTDI_REQUEST_KERNEL)(&irpSp->Parameters))->ReturnConnectionInformation;
        if (remoteInformation != NULL) {
            try {
                if (remoteInformation->RemoteAddressLength != 0) {

                    //
                    // Build a temporary TA_NETBIOS_ADDRESS, then
                    // copy over as many bytes as fit.
                    //

                    TdiBuildNetbiosAddress(
                        Connection->CalledAddress.NetbiosName,
                        (BOOLEAN)(Connection->CalledAddress.NetbiosNameType ==
                            TDI_ADDRESS_NETBIOS_TYPE_GROUP),
                        &TempAddress);

                    if (remoteInformation->RemoteAddressLength >=
                                           sizeof (TA_NETBIOS_ADDRESS)) {

                        returnLength = sizeof(TA_NETBIOS_ADDRESS);
                        remoteInformation->RemoteAddressLength = returnLength;

                    } else {

                        returnLength = remoteInformation->RemoteAddressLength;

                    }

                    RtlCopyMemory(
                        (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                        &TempAddress,
                        returnLength);

                } else {

                    returnLength = 0;
                }

                status = STATUS_SUCCESS;

            } except (EXCEPTION_EXECUTE_HANDLER) {

                returnLength = 0;
                status = GetExceptionCode ();

            }

        } else {

            status = STATUS_SUCCESS;
            returnLength = 0;

        }

        if (status == STATUS_SUCCESS) {

            if ((ULONG)Connection->Retries == Connection->Provider->NameQueryRetries) {

                INCREMENT_COUNTER (Connection->Provider, ConnectionsAfterNoRetry);

            } else {

                INCREMENT_COUNTER (Connection->Provider, ConnectionsAfterRetry);

            }

        }

        //
        // Don't clear this until now, so that the connection is all
        // set up before we allow more indications.
        //

        Connection->IndicationInProgress = FALSE;

        NbfCompleteRequest (request, status, returnLength);

    } else {

        Connection->IndicationInProgress = FALSE;
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        IoReleaseCancelSpinLock(cancelirql);

    }

    return STATUS_SUCCESS;
} /* ProcessSessionConfirm */


NTSTATUS
ProcessSessionEnd(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming SESSION_END NetBIOS frame.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    USHORT data2;
    NTSTATUS StopStatus;

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint0 ("ProcessSessionEnd:  Entered.\n");
    }

    //
    // Handle the error code in the Data2 field.  Current protocol says
    // if the field is 0, then this is a normal HANGUP.NCB operation.
    // If the field is 1, then this is an abnormal session end, caused
    // by something like a SEND.NCB timing out.  Of course, new protocol
    // may be added in the future, so we handle only these specific cases.
    //

    data2 = (USHORT)(IFrame->Data2Low + IFrame->Data2High*256);
    switch (data2) {
        case 0:
        case 1:
            StopStatus = STATUS_REMOTE_DISCONNECT;
            break;

        default:
            PANIC ("ProcessSessionEnd: frame not expected.\n");
            StopStatus = STATUS_INVALID_NETWORK_RESPONSE;
    }
#if DBG
    if (NbfDisconnectDebug) {
        STRING remoteName, localName;
        remoteName.Length = NETBIOS_NAME_LENGTH - 1;
        remoteName.Buffer = Connection->RemoteName;
        localName.Length = NETBIOS_NAME_LENGTH - 1;
        localName.Buffer = Connection->AddressFile->Address->NetworkName->NetbiosName;
        NbfPrint3( "SessionEnd received for connection to %S from %S; reason %s\n",
            &remoteName, &localName,
            data2 == 0 ? "NORMAL" : data2 == 1 ? "ABORT" : "UNKNOWN" );
    }
#endif

    //
    // Run-down this connection.
    //

    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
        NbfPrint0 ("ProcessSessionEnd calling NbfStopConnection\n");
    }
    NbfStopConnection (Connection, StopStatus);    // disconnected by the other end

    Connection->IndicationInProgress = FALSE;

    return STATUS_SUCCESS;
} /* ProcessSessionEnd */


NTSTATUS
ProcessSessionInitialize(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming SESSION_INITIALIZE NetBIOS frame.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL cancelirql;
    PLIST_ENTRY p;
    PTP_REQUEST request;
    PIO_STACK_LOCATION irpSp;
    USHORT HisMaxDataSize;
    ULONG returnLength;
    PTDI_CONNECTION_INFORMATION remoteInformation;
    NTSTATUS status;
    TA_NETBIOS_ADDRESS TempAddress;

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint1 ("ProcessSessionInitialize:  Entered, Flags: %lx\n", Connection->Flags);
    }

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    if ((Connection->Flags & CONNECTION_FLAGS_WAIT_SI) != 0) {
        Connection->Flags &= ~CONNECTION_FLAGS_WAIT_SI;

        //
        // Get his capability bits and maximum frame size.
        //

        if (IFrame->Data1 & SESSION_INIT_OPTIONS_20) {
            Connection->Flags |= CONNECTION_FLAGS_VERSION2;
        }

        if (Connection->Link->Loopback) {
            Connection->MaximumDataSize = 0x8000;
        } else {
            Connection->MaximumDataSize = (USHORT)
                (Connection->Link->MaxFrameSize - sizeof(NBF_HDR_CONNECTION) - sizeof(DLC_I_FRAME));

            HisMaxDataSize = (USHORT)(IFrame->Data2Low + IFrame->Data2High*256);
            if (HisMaxDataSize < Connection->MaximumDataSize) {
                Connection->MaximumDataSize = HisMaxDataSize;
            }
        }

        //
        // Build a standard Netbios header for speed when sending
        // data frames.
        //

        ConstructDataOnlyLast(
            &Connection->NetbiosHeader,
            FALSE,
            (USHORT)0,
            Connection->Lsn,
            Connection->Rsn);

        //
        // Save his session initialize correlator so we can send it
        // in the session confirm frame.
        //

        Connection->NetbiosHeader.TransmitCorrelator = RESPONSE_CORR(IFrame);

        //
        // Turn off the connection request timer if there is one (we're done).
        // Do this with the lock held in case the connection is about to
        // be closed, to not interfere with the timer started when the
        // connection started then.
        //

        if (KeCancelTimer (&Connection->Timer)) {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfDereferenceConnection ("Timer canceled", Connection, CREF_TIMER);   // remove timer reference.

        } else {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        //
        // Now, complete the listen request on the connection (if there was
        // one) and continue with as much of the protocol request as possible.
        // if the user has "pre-accepted" the connection, we'll just continue
        // onward here and complete the entire connection setup. If the user
        // was indicated and has not yet accepted, we'll just put the
        // connection into the proper state and fall out the bottom without
        // completing anything.
        //

        ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        if (((Connection->Flags2 & CONNECTION_FLAGS2_ACCEPTED) != 0) ||
            ((Connection->Flags2 & CONNECTION_FLAGS2_PRE_ACCEPT) != 0)) {

            IF_NBFDBG (NBF_DEBUG_SETUP) {
                 NbfPrint1("SessionInitialize: Accepted connection %lx\n", Connection);
            }
            //
            // we've already accepted the connection; allow it to proceed.
            // this is the normal path for kernel mode indication clients,
            // or for those who don't specify TDI_QUERY_ACCEPT on the listen.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            Connection->Flags |= CONNECTION_FLAGS_READY;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            INCREMENT_COUNTER (Connection->Provider, OpenConnections);

            //
            // Record that the listen request has been successfully
            // completed by NbfCompleteRequest.
            //

            Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

            status = STATUS_SUCCESS;
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            NbfSendSessionConfirm (Connection);

        } else {

            if ((Connection->Flags2 & CONNECTION_FLAGS2_DISCONNECT) != 0) {

                //
                // we disconnected, destroy the connection
                //
                IF_NBFDBG (NBF_DEBUG_SETUP) {
                     NbfPrint1("SessionInitialize: Disconnected connection %lx\n", Connection);
                }

                status = STATUS_LOCAL_DISCONNECT;
                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                NbfStopConnection (Connection, STATUS_LOCAL_DISCONNECT);

            } else {

                //
                // we've done nothing, wait for the user to accept on this
                // connection. This is the "normal" path for non-indication
                // clients.
                //

                Connection->Flags2 |= CONNECTION_FLAGS2_WAITING_SC;

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                status = STATUS_SUCCESS;
            }
        }

        //
        // Now, if there was no queued listen, we have done everything we can
        // for this connection, so we simply exit and leave everything up to
        // the user. If we've gotten an indication response that allows the
        // connection to proceed, we will come out of here with a connection
        // that's up and running.
        //

        IoAcquireCancelSpinLock (&cancelirql);
        ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        p = RemoveHeadList (&Connection->InProgressRequest);
        if (p == &Connection->InProgressRequest) {

            Connection->IndicationInProgress = FALSE;
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
            IoReleaseCancelSpinLock (cancelirql);
            return STATUS_SUCCESS;

        }

        //
        // We have a completed connection with a queued listen. Complete
        // the listen and let the user do an accept at some time down the
        // road.
        //

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        IoSetCancelRoutine(request->IoRequestPacket, NULL);
        IoReleaseCancelSpinLock (cancelirql);

        irpSp = IoGetCurrentIrpStackLocation (request->IoRequestPacket);
        remoteInformation =
            ((PTDI_REQUEST_KERNEL)(&irpSp->Parameters))->ReturnConnectionInformation;
        if (remoteInformation != NULL) {
            try {
                if (remoteInformation->RemoteAddressLength != 0) {

                    //
                    // Build a temporary TA_NETBIOS_ADDRESS, then
                    // copy over as many bytes as fit.
                    //

                    TdiBuildNetbiosAddress(
                        Connection->CalledAddress.NetbiosName,
                        (BOOLEAN)(Connection->CalledAddress.NetbiosNameType ==
                            TDI_ADDRESS_NETBIOS_TYPE_GROUP),
                        &TempAddress);

                    if (remoteInformation->RemoteAddressLength >=
                                           sizeof (TA_NETBIOS_ADDRESS)) {

                        returnLength = sizeof(TA_NETBIOS_ADDRESS);
                        remoteInformation->RemoteAddressLength = returnLength;

                    } else {

                        returnLength = remoteInformation->RemoteAddressLength;

                    }

                    RtlCopyMemory(
                        (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                        &TempAddress,
                        returnLength);

                } else {

                    returnLength = 0;
                }

                status = STATUS_SUCCESS;

            } except (EXCEPTION_EXECUTE_HANDLER) {

                returnLength = 0;
                status = GetExceptionCode ();

            }

        } else {

            status = STATUS_SUCCESS;
            returnLength = 0;

        }

        //
        // Don't clear this until now, so that the connection is all
        // set up before we allow more indications.
        //

        Connection->IndicationInProgress = FALSE;

        NbfCompleteRequest (request, status, 0);

    } else {

        Connection->IndicationInProgress = FALSE;
#if DBG
        NbfPrint3 ("ProcessSessionInitialize: C %lx, Flags %lx, Flags2 %lx\n",
                             Connection, Connection->Flags, Connection->Flags2);
#endif
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    }

    return STATUS_SUCCESS;
} /* ProcessSessionInitialize */


NTSTATUS
ProcessNoReceive(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming NO_RECEIVE NetBIOS frame.

    NOTE: This routine is called with the connection spinlock
    held and returns with it released.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (IFrame); // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint0 ("ProcessNoReceive:  Entered.\n");
    }

    switch (Connection->SendState) {
        case CONNECTION_SENDSTATE_W_PACKET:     // waiting for free packet.
        case CONNECTION_SENDSTATE_PACKETIZE:    // send being packetized.
        case CONNECTION_SENDSTATE_W_LINK:       // waiting for good link conditions.
        case CONNECTION_SENDSTATE_W_EOR:        // waiting for TdiSend(EOR).
        case CONNECTION_SENDSTATE_W_ACK:        // waiting for DATA_ACK.
//            Connection->SendState = CONNECTION_SENDSTATE_W_RCVCONT;
//
// this used to be here, and is right for the other side of the connection. It's
// wrong here.
//            Connection->Flags |= CONNECTION_FLAGS_W_RESYNCH;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            ReframeSend (Connection, IFrame->Data2Low + IFrame->Data2High*256);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            break;

        case CONNECTION_SENDSTATE_W_RCVCONT:    // waiting for RECEIVE_CONTINUE.
        case CONNECTION_SENDSTATE_IDLE:         // no sends being processed.
            PANIC ("ProcessNoReceive:  Frame not expected.\n");
            break;

        default:
            PANIC ("ProcessNoReceive:  Invalid SendState.\n");
    }

    //
    // Don't clear this until ReframeSend has been called
    //

    Connection->IndicationInProgress = FALSE;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    return STATUS_SUCCESS;
} /* ProcessNoReceive */


NTSTATUS
ProcessReceiveOutstanding(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming RECEIVE_OUTSTANDING NetBIOS frame.

    NOTE: This routine is called with the connection spinlock
    held and returns with it released.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint0 ("ProcessReceiveOutstanding:  Entered.\n");
    }

    switch (Connection->SendState) {
        case CONNECTION_SENDSTATE_W_PACKET:     // waiting for free packet.
        case CONNECTION_SENDSTATE_PACKETIZE:    // send being packetized.
        case CONNECTION_SENDSTATE_W_LINK:       // waiting for good link conditions.
        case CONNECTION_SENDSTATE_W_EOR:        // waiting for TdiSend(EOR).
        case CONNECTION_SENDSTATE_W_ACK:        // waiting for DATA_ACK.
        case CONNECTION_SENDSTATE_W_RCVCONT:    // waiting for RECEIVE_CONTINUE.
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            ReframeSend (Connection, IFrame->Data2Low + IFrame->Data2High*256);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            if ((Connection->Flags & CONNECTION_FLAGS_READY) != 0) {
                Connection->Flags |= CONNECTION_FLAGS_RESYNCHING;
                Connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;
            }
            break;

        case CONNECTION_SENDSTATE_IDLE:         // no sends being processed.
            PANIC ("ProcessReceiveOutstanding:  Frame not expected.\n");
            break;

        default:
            PANIC ("ProcessReceiveOutstanding:  Invalid SendState.\n");
    }

    //
    // Don't clear this until ReframeSend has been called
    //

    Connection->IndicationInProgress = FALSE;

    //
    // Now start packetizing the connection again since we've reframed
    // the current send.  If we were idle or in a bad state, then the
    // packetizing routine will detect that.
    //
    // *** StartPacketizingConnection releases the Connection spin lock.
    //

    StartPacketizingConnection (Connection, FALSE);
    return STATUS_SUCCESS;
} /* ProcessReceiveOutstanding */


NTSTATUS
ProcessReceiveContinue(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming RECEIVE_CONTINUE NetBIOS frame.

    NOTE: This routine is called with the connection spinlock
    held and returns with it released.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint0 ("ProcessReceiveContinue:  Entered.\n");
    }

    switch (Connection->SendState) {
        case CONNECTION_SENDSTATE_W_PACKET:     // waiting for free packet.
        case CONNECTION_SENDSTATE_PACKETIZE:    // send being packetized.
        case CONNECTION_SENDSTATE_W_LINK:       // waiting for good link conditions.
        case CONNECTION_SENDSTATE_W_EOR:        // waiting for TdiSend(EOR).
        case CONNECTION_SENDSTATE_W_ACK:        // waiting for DATA_ACK.
        case CONNECTION_SENDSTATE_W_RCVCONT:    // waiting for RECEIVE_CONTINUE.
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            ReframeSend (Connection, Connection->sp.MessageBytesSent);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            Connection->Flags |= CONNECTION_FLAGS_RESYNCHING;
            Connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;
            break;

        case CONNECTION_SENDSTATE_IDLE:         // no sends being processed.
            PANIC ("ProcessReceiveContinue:  Frame not expected.\n");
            break;

        default:
            PANIC ("ProcessReceiveContinue:  Invalid SendState.\n");
    }

    //
    // Don't clear this until ReframeSend has been called
    //

    Connection->IndicationInProgress = FALSE;

    //
    // Now start packetizing the connection again since we've reframed
    // the current send.  If we were idle or in a bad state, then the
    // packetizing routine will detect that.
    //
    // *** StartPacketizingConnection releases the Connection spin lock.
    //

    StartPacketizingConnection (Connection, FALSE);
    return STATUS_SUCCESS;
} /* ProcessReceiveContinue */


NTSTATUS
ProcessSessionAlive(
    IN PTP_CONNECTION Connection,
    IN PNBF_HDR_CONNECTION IFrame
    )

/*++

Routine Description:

    This routine handles an incoming SESSION_ALIVE NetBIOS frame.  This
    routine is by far the simplest in the transport because it does nothing.
    The SESSION_ALIVE frame is simply a dummy frame that is sent on the
    reliable data link layer to determine if the data link is still active;
    no NetBIOS level protocol processing is performed.

Arguments:

    Connection - Pointer to a transport connection (TP_CONNECTION).

    IFrame - Pointer to NetBIOS connection-oriented header.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Connection); // prevent compiler warnings
    UNREFERENCED_PARAMETER (IFrame);     // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
        NbfPrint0 ("ProcessSessionAlive:  Entered.\n");
    }

    Connection->IndicationInProgress = FALSE;

    return STATUS_SUCCESS;
} /* ProcessSessionAlive */


VOID
NbfProcessIIndicate(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PUCHAR DlcHeader,
    IN UINT DlcIndicatedLength,
    IN UINT DlcTotalLength,
    IN NDIS_HANDLE ReceiveContext,
    IN BOOLEAN Loopback
    )

/*++

Routine Description:

    This routine processes a received I frame at indication time. It will do
    all necessary verification processing of the frame and pass those frames
    that are valid on to the proper handling routines.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC I-type frame.

    DlcHeader - A pointer to the start of the DLC header in the packet.

    DlcIndicatedLength - The length of the packet indicated, starting at
        DlcHeader.

    DlcTotalLength - The total length of the packet, starting at DlcHeader.

    ReceiveContext - A magic value for NDIS that indicates which packet we're
        talking about.

    Loopback - Is this a loopback indication; used to determine whether
        to call NdisTransferData or NbfTransferLoopbackData.

Return Value:

    None.

--*/

{
#if DBG
    UCHAR *s;
#endif
    PNBF_HDR_CONNECTION nbfHeader;
    PDLC_I_FRAME header;
    NTSTATUS Status;
    UCHAR lsn, rsn;
    PTP_CONNECTION connection;
    PUCHAR DataHeader;
    ULONG DataTotalLength;
    PLIST_ENTRY p;
    BOOLEAN ConnectionFound;

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessIIndicate:  Entered.\n");
    }

    //
    // Process any of:  I-x/x.
    //

    header = (PDLC_I_FRAME)DlcHeader;
    nbfHeader = (PNBF_HDR_CONNECTION)((PUCHAR)header + 4); // skip DLC hdr.

    //
    // Verify signatures.  We test the signature as a 16-bit
    // word as specified in the NetBIOS Formats and Protocols manual,
    // with the assert guarding us against big-endian systems.
    //

    ASSERT ((((PUCHAR)(&nbfHeader->Length))[0] + ((PUCHAR)(&nbfHeader->Length))[1]*256) ==
            HEADER_LENGTH(nbfHeader));

    if (HEADER_LENGTH(nbfHeader) != sizeof(NBF_HDR_CONNECTION)) {
        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint0 ("NbfProcessIIndicate:  Dropped I frame, Too short or long.\n");
        }
        return;        // frame too small or too large.
    }

    if (HEADER_SIGNATURE(nbfHeader) != NETBIOS_SIGNATURE) {
        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint0 ("NbfProcessIIndicate:  Dropped I frame, Signature bad.\n");
        }
        return;        // invalid signature in frame.
    }

    DataHeader = (PUCHAR)DlcHeader + (4 + sizeof(NBF_HDR_CONNECTION));
    DataTotalLength = DlcTotalLength - (4 + sizeof(NBF_HDR_CONNECTION));

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    switch (Link->State) {

        case LINK_STATE_READY:

            //
            // Link is balanced.  This code is extremely critical since
            // it is the most-covered path in the system for small and
            // large I/O.  Be very careful in adding code here as it will
            // seriously affect the overall performance of the LAN. It is
            // first in the list of possible states for that reason.
            //

#if DBG
            s = "READY";
#endif
            Link->LinkBusy = FALSE;

            //
            // The I-frame's N(S) should match our V(R).  If it
            // doesn't, issue a reject.  Otherwise, increment our V(R).
            //

            if ((UCHAR)((header->SendSeq >> 1) & 0x7F) != Link->NextReceive) {
                IF_NBFDBG (NBF_DEBUG_DLC) {
                    NbfPrint0 ("   NbfProcessIIndicate: N(S) != V(R).\n");
                }

                if (Link->ReceiveState == RECEIVE_STATE_REJECTING) {


                    //
                    // We already sent a reject, only respond if
                    // he is polling.
                    //

                    if (Command & PollFinal) {
                        NbfSendRr(Link, FALSE, TRUE);  // releases lock
                    } else {
                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    }

                } else {

                    Link->ReceiveState = RECEIVE_STATE_REJECTING;

                    //
                    // NbfSendRej releases the spinlock.
                    //

                    if (Command) {
                        NbfSendRej (Link, FALSE, PollFinal);
                    } else {
                        NbfSendRej (Link, FALSE, FALSE);
                    }
                }

                //
                // Update our "bytes rejected" counters.
                //

                ADD_TO_LARGE_INTEGER(
                    &Link->Provider->Statistics.DataFrameBytesRejected,
                    DataTotalLength);
                ++Link->Provider->Statistics.DataFramesRejected;

                //
                // Discard this packet.
                //

                break;

            }


            //
            // Find the transport connection object associated with this frame.
            // Because there may be several NetBIOS (transport) connections
            // over the same data link connection, and the ConnectionContext
            // value represents a data link connection to a specific address,
            // we simply use the RSN field in the frame to index into the
            // connection database for this link object.
            //
            // We do this before processing the rest of the LLC header,
            // in case the connection is busy and we have to ignore
            // the frame.
            //

            ConnectionFound = FALSE;

            lsn = nbfHeader->DestinationSessionNumber;
            rsn = nbfHeader->SourceSessionNumber;

            if ((lsn == 0) || (lsn > NETBIOS_SESSION_LIMIT)) {

                IF_NBFDBG (NBF_DEBUG_IFRAMES) {
                    NbfPrint0 ("NbfProcessIIndicate: Invalid LSN.\n");
                }

            } else {

                p = Link->ConnectionDatabase.Flink;
                while (p != &Link->ConnectionDatabase) {
                    connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
                    if (connection->Lsn >= lsn) {   // assumes ordered list
                        break;
                    }
                    p = p->Flink;
                }

                // Don't use compound if 'cause Connection may be garbage

                if (p == &Link->ConnectionDatabase) {
#if DBG
                    NbfPrint2 ("NbfProcessIIndicate: Connection not found in database: \n Lsn %x Link %lx",
                        lsn, Link);
                    NbfPrint6 ("Remote: %x-%x-%x-%x-%x-%x\n",
                        Link->HardwareAddress.Address[0], Link->HardwareAddress.Address[1],
                        Link->HardwareAddress.Address[2], Link->HardwareAddress.Address[3],
                        Link->HardwareAddress.Address[4], Link->HardwareAddress.Address[5]);
#endif
                } else if (connection->Lsn != lsn) {
#if DBG
                    NbfPrint0 ("NbfProcessIIndicate:  Connection in database doesn't match.\n");
#endif
                } else if (connection->Rsn != rsn) {
#if DBG
                    NbfPrint3 ("NbfProcessIIndicate:  Connection lsn %d had rsn %d, got frame for %d\n",
                        connection->Lsn, connection->Rsn, rsn);
#endif
                } else {

                    //
                    // The connection is good, proceed.
                    //

                    ConnectionFound = TRUE;

                    if (connection->IndicationInProgress) {
                        NbfPrint1("ProcessIIndicate: Indication in progress on %lx\n", connection);
                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                        return;
                    }

                    //
                    // Set this, it prevents other I-frames from being received
                    // on this connection. The various ProcessXXX routines
                    // that are called from the switch below will clear
                    // this flag when they determine it is OK to be reentered.
                    //

                    connection->IndicationInProgress = TRUE;


                    // This reference is removed before this function returns or
                    // we are done with the LINK_STATE_READY part of the outer switch.

                    NbfReferenceConnection ("Processing IFrame", connection, CREF_PROCESS_DATA);


                }

            }

#if PKT_LOG
            if (ConnectionFound) {
                // We have the connection here, log the packet for debugging
                NbfLogRcvPacket(connection,
                                NULL,
                                DlcHeader,
                                DlcTotalLength,
                                DlcIndicatedLength);
            }
            else {
                // We just have the link here, log the packet for debugging
                NbfLogRcvPacket(NULL,
                                Link,
                                DlcHeader,
                                DlcTotalLength,
                                DlcIndicatedLength);

            }
#endif // PKT_LOG

            //
            // As long as we don't have to drop this frame, adjust the link
            // state correctly. If ConnectionFound is FALSE, then we exit
            // right after doing this.
            //


            //
            // The I-frame we expected arrived, clear rejecting state.
            //

            if (Link->ReceiveState == RECEIVE_STATE_REJECTING) {
                Link->ReceiveState = RECEIVE_STATE_READY;
            }

            Link->NextReceive = (UCHAR)((Link->NextReceive+1) & 0x7f);

            //
            // If he is checkpointing, we need to respond with RR-c/f.  If
            // we respond, then stop the delayed ack timer.  Otherwise, we
            // need to start it because this is an I-frame that will not be
            // acked immediately.
            //

            if (Command && PollFinal) {

                IF_NBFDBG (NBF_DEBUG_DLC) {
                    NbfPrint0 ("   NbfProcessI:  he's checkpointing.\n");
                }
                Link->RemoteNoPoll = FALSE;
                StopT2 (Link);                  // we're acking, so no delay req'd.
                NbfSendRr (Link, FALSE, TRUE);   // releases lock
                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

            } else {

                if (Link->RemoteNoPoll) {

                    if ((++Link->ConsecutiveIFrames) == Link->Provider->MaxConsecutiveIFrames) {

                        //
                        // This appears to be one of those remotes which
                        // never polls, so we send an RR if there are two
                        // frames outstanding (StopT2 sets ConsecutiveIFrames
                        // to 0).
                        //

                        StopT2 (Link);                  // we're acking, so no delay req'd.
                        NbfSendRr (Link, FALSE, FALSE);   // releases lock
                        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

                    } else {

                        StartT2 (Link);

                        ACQUIRE_DPC_SPIN_LOCK (&Link->Provider->Interlock);
                        if (!Link->OnDeferredRrQueue) {
                            InsertTailList(
                                &Link->Provider->DeferredRrQueue,
                                &Link->DeferredRrLinkage);
                            Link->OnDeferredRrQueue = TRUE;
                        }
                        RELEASE_DPC_SPIN_LOCK (&Link->Provider->Interlock);

                    }

                } else {

                    StartT2 (Link);                 // start delayed ack sequence.
                }

                //
                // If he is responding to a checkpoint, we need to clear our
                // send state.  Any packets which are still waiting for acknowlegement
                // at this point must now be resent.
                //

                if ((!Command) && PollFinal) {
                    IF_NBFDBG (NBF_DEBUG_DLC) {
                        NbfPrint0 ("   NbfProcessI:  he's responding to our checkpoint.\n");
                    }
                    if (Link->SendState != SEND_STATE_CHECKPOINTING) {
                        IF_NBFDBG (NBF_DEBUG_DLC) {
                            NbfPrint1 ("   NbfProcessI: Ckpt but SendState=%ld.\n",
                                       Link->SendState);
                        }
                    }
                    StopT1 (Link);                  // checkpoint completed.
                    Link->SendState = SEND_STATE_READY;
                    StartTi (Link);
                }

            }

            //
            // Now, if we could not find the connection or the sequence
            // numbers did not match, return. We don't call ResendLlcPackets
            // in this case, but that is OK (eventually we will poll).
            //

            if (!ConnectionFound) {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                return;
            }

            ASSERT (connection->LinkSpinLock == &Link->SpinLock);

            //
            // The N(R) in this frame may acknowlege some WackQ packets.
            // We delay checking this until after processing the I-frame,
            // so that we can get IndicationInProgress set to FALSE
            // before we start resending the WackQ.
            //

            switch (nbfHeader->Command) {

                case NBF_CMD_DATA_FIRST_MIDDLE:
                case NBF_CMD_DATA_ONLY_LAST:

                    //
                    // First see if this packet has a piggyback ack -- we process
                    // this even if we throw the packet away below.
                    //
                    // This is a bit ugly since theoretically the piggyback
                    // ack bits in a DFM and a DOL could be different, but
                    // they aren't.
                    //
                    if (NbfUsePiggybackAcks) {
                        ASSERT (DFM_OPTIONS_ACK_INCLUDED == DOL_OPTIONS_ACK_INCLUDED);

                        if ((nbfHeader->Data1 & DFM_OPTIONS_ACK_INCLUDED) != 0) {

                            //
                            // This returns with the connection spinlock held
                            // but may release it and reacquire it.
                            //

                            CompleteSend(
                                connection,
                                TRANSMIT_CORR(nbfHeader));

                        }
                    }

                    //
                    // NOTE: The connection spinlock is held here.
                    //

                    //
                    // If the connection is not ready, drop the frame.
                    //

                    if ((connection->Flags & CONNECTION_FLAGS_READY) == 0) {
                        connection->IndicationInProgress = FALSE;
                        RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        Status = STATUS_SUCCESS;
                        goto SkipProcessIndicateData;
                    }

                    //
                    // A quick check for the three flags that are
                    // rarely set.
                    //

                    if ((connection->Flags & (CONNECTION_FLAGS_W_RESYNCH |
                                              CONNECTION_FLAGS_RC_PENDING |
                                              CONNECTION_FLAGS_RECEIVE_WAKEUP)) == 0) {
                        goto NoFlagsSet;
                    }

                    //
                    // If we are waiting for a resynch bit to be set in an
                    // incoming frame, toss the frame if it isn't set.
                    // Otherwise, clear the wait condition.
                    //

                    if (connection->Flags & CONNECTION_FLAGS_W_RESYNCH) {
                        if ((nbfHeader->Data2Low == 1) && (nbfHeader->Data2High == 0)) {
                            connection->Flags &= ~CONNECTION_FLAGS_W_RESYNCH;
                        } else {
                            connection->IndicationInProgress = FALSE;
                            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                            IF_NBFDBG (NBF_DEBUG_IFRAMES) {
                                NbfPrint0 ("NbfProcessIIndicate: Discarded DFM/DOL, waiting for resynch.\n");
                            }

                            Status = STATUS_SUCCESS;
                            goto SkipProcessIndicateData;
                        }
                    }

                    //
                    // If we have a previous receive that is pending
                    // completion, then we need to ignore this frame.
                    // This may be common on MP, so rather than drop
                    // it and wait for a poll, we send a NO_RECEIVE,
                    // then a RCV_OUTSTANDING when we have some
                    // resources.
                    //

                    if (connection->Flags & CONNECTION_FLAGS_RC_PENDING) {

                        //
                        // Hack the connection object so the NO_RECEIVE
                        // looks right.
                        //

                        connection->MessageBytesReceived = 0;
                        connection->MessageBytesAcked = 0;
                        connection->MessageInitAccepted = 0;

                        RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        NbfSendNoReceive (connection);

                        ACQUIRE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        //
                        // We now turn on the PEND_INDICATE flag to show
                        // that we need to send RCV_OUTSTANDING when the
                        // receive completes. If RC_PENDING is now off,
                        // it means the receive was just completed, so
                        // we ourselves need to send the RCV_OUTSTANDING.
                        //

                        if ((connection->Flags & CONNECTION_FLAGS_RC_PENDING) == 0) {

                            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                            NbfSendReceiveOutstanding (connection);
                            ACQUIRE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        } else {

                            connection->Flags |= CONNECTION_FLAGS_PEND_INDICATE;

                        }

                        connection->IndicationInProgress = FALSE;
                        RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        IF_NBFDBG (NBF_DEBUG_IFRAMES) {
                            NbfPrint0 ("NbfProcessIIndicate: Discarded DFM/DOL, receive complete pending.\n");
                        }

                        Status = STATUS_SUCCESS;
                        goto SkipProcessIndicateData;
                    }

                    //
                    // If we are discarding data received on this connection
                    // because we've sent a no receive, ditch it.
                    //

                    if (connection->Flags & CONNECTION_FLAGS_RECEIVE_WAKEUP) {
                        connection->IndicationInProgress = FALSE;
                        IF_NBFDBG (NBF_DEBUG_RCVENG) {
                            NbfPrint0 ("NbfProcessIIndicate: In wakeup state, discarding frame.\n");
                        }
                        RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                        Status = STATUS_SUCCESS;
                        goto SkipProcessIndicateData;
                    }

NoFlagsSet:;

                    //
                    // The connection spinlock is held here.
                    //

                    if (nbfHeader->Command == NBF_CMD_DATA_FIRST_MIDDLE) {

                        //
                        // NOTE: This release connection->LinkSpinLock.
                        //

                        Status = ProcessIndicateData (
                                    connection,
                                    DlcHeader,
                                    DlcIndicatedLength,
                                    DataHeader,
                                    DataTotalLength,
                                    ReceiveContext,
                                    FALSE,
                                    Loopback);

                        //
                        // If the receive-continue bit is set in this frame, then we must
                        // reply with a RECEIVE_CONTINUE frame saying that he can continue
                        // sending.  This old protocol option allowed a sender to send a
                        // single frame over to see if there was a receive posted before
                        // sending the entire message and potentially dropping the entire
                        // message.  Because the TDI is indication-based, we cannot know
                        // if there is NO receive available until we actually try perform
                        // the indication, so we simply say that there is one posted.
                        // (This will only happen on DFMs.)
                        //

                        if (nbfHeader->Data1 & 0x01) {

                            //
                            // Save this to use in RECEIVE_CONTINUE.
                            //

                            connection->NetbiosHeader.TransmitCorrelator =
                                RESPONSE_CORR(nbfHeader);

                            NbfSendReceiveContinue (connection);
                        }
                    } else {

                        //
                        // Keep track of how many consecutive receives we have had.
                        //

                        connection->ConsecutiveReceives++;
                        connection->ConsecutiveSends = 0;

                        //
                        // Save this information now, it will be needed
                        // when the ACK for this DOL is sent.
                        //

                        connection->CurrentReceiveAckQueueable =
                            (nbfHeader->Data1 & DOL_OPTIONS_ACK_W_DATA_ALLOWED);

                        connection->CurrentReceiveNoAck =
                            (nbfHeader->Data1 & DOL_OPTIONS_NO_ACK);

                        connection->NetbiosHeader.TransmitCorrelator =
                            RESPONSE_CORR(nbfHeader);

                        //
                        // NOTE: This release connection->LinkSpinLock.
                        //

                        Status = ProcessIndicateData (
                                    connection,
                                    DlcHeader,
                                    DlcIndicatedLength,
                                    DataHeader,
                                    DataTotalLength,
                                    ReceiveContext,
                                    TRUE,
                                    Loopback);
                    }

                    //
                    // Update our "bytes received" counters.
                    //

                    Link->Provider->TempIFrameBytesReceived += DataTotalLength;
                    ++Link->Provider->TempIFramesReceived;

SkipProcessIndicateData:

                    break;

                case NBF_CMD_DATA_ACK:

                    connection->IndicationInProgress = FALSE;

                    //
                    // This returns with the lock held.
                    //

                    CompleteSend(
                        connection,
                        TRANSMIT_CORR(nbfHeader));
                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

                    Status = STATUS_SUCCESS;
                    break;

                case NBF_CMD_SESSION_CONFIRM:

                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                    Status = ProcessSessionConfirm (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_SESSION_END:

                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                    Status = ProcessSessionEnd (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_SESSION_INITIALIZE:

                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                    Status = ProcessSessionInitialize (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_NO_RECEIVE:

                    //
                    // This releases the connection spinlock.
                    //

                    Status = ProcessNoReceive (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_RECEIVE_OUTSTANDING:

                    //
                    // This releases the connection spinlock.
                    //

                    Status = ProcessReceiveOutstanding (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_RECEIVE_CONTINUE:

                    //
                    // This releases the connection spinlock.
                    //

                    Status = ProcessReceiveContinue (
                                       connection,
                                       nbfHeader);
                    break;

                case NBF_CMD_SESSION_ALIVE:

                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                    Status = ProcessSessionAlive (
                                       connection,
                                       nbfHeader);
                    break;

                //
                // An unrecognized command was found in a NetBIOS frame.  Because
                // this is a connection-oriented frame, we should probably shoot
                // the sender, but for now we will simply discard the packet.
                //
                // trash the session here-- protocol violation.
                //

                default:
                    RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
                    PANIC ("NbfProcessIIndicate: Unknown NBF command byte.\n");
                    connection->IndicationInProgress = FALSE;
                    Status = STATUS_SUCCESS;
            } /* switch */

            //
            // A status of STATUS_MORE_PROCESSING_REQUIRED means
            // that the connection reference count was inherited
            // by the routine we called, so we don't do the dereference
            // here.
            //

            if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                NbfDereferenceConnectionMacro("ProcessIIndicate done", connection, CREF_PROCESS_DATA);
            }


            //
            // The N(R) in this frame acknowleges some (or all) of our packets.
            // This call must come after the checkpoint acknowlegement check
            // so that an RR-r/f is always sent BEFORE any new I-frames.  This
            // allows us to always send I-frames as commands.
            // If he responded to a checkpoint, then resend all left-over
            // packets.
            //

            // Link->NextSend = (UCHAR)(header->RcvSeq >> 1) < Link->NextSend ?
            //    Link->NextSend : (UCHAR)(header->RcvSeq >> 1);

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            if (Link->WackQ.Flink != &Link->WackQ) {

                UCHAR AckSequenceNumber = (UCHAR)(header->RcvSeq >> 1);

                //
                // Verify that the sequence number is reasonable.
                //

                if (Link->NextSend >= Link->LastAckReceived) {

                    //
                    // There is no 127 -> 0 wrap between the two...
                    //

                    if ((AckSequenceNumber < Link->LastAckReceived) ||
                        (AckSequenceNumber > Link->NextSend)) {
                        goto NoResend;
                    }

                } else {

                    //
                    // There is a 127 -> 0 wrap between the two...
                    //

                    if ((AckSequenceNumber < Link->LastAckReceived) &&
                        (AckSequenceNumber > Link->NextSend)) {
                        goto NoResend;
                    }

                }

                //
                // NOTE: ResendLlcPackets may release and
                // reacquire the link spinlock.
                //

                (VOID)ResendLlcPackets(
                    Link,
                    AckSequenceNumber,
                    (BOOLEAN)((!Command) && PollFinal));

NoResend:;

            }


            //
            // Get link going again.
            //
            // NOTE: RestartLinkTraffic releases the link spinlock
            //

            RestartLinkTraffic (Link);
            break;

        case LINK_STATE_ADM:

            //
            // used to be, we'd just blow off the other guy with a DM and go home.
            // it seems that OS/2 likes to believe (under some conditions) that
            // it has a link up and it is still potentially active (probably
            // because we return the same connection number to him that he used
            // to be using). This would all be ok, except for the fact that we
            // may have a connection hanging on this link waiting for a listen
            // to finish. If we're in that state, go ahead and accept the
            // connect.
            // Set our values for link packet serial numbers to what he wants.
            //

            if (!IsListEmpty (&Link->ConnectionDatabase)) {
                if (nbfHeader->Command == NBF_CMD_SESSION_INITIALIZE) {

                    //
                    // OK, we're at the only legal case. We've gotten an SI
                    // and we have a connection on this link. If the connection
                    // is waiting SI, we will go ahead and make believe we did
                    // all the correct stuff before we got it.
                    //

                    for (
                        p = Link->ConnectionDatabase.Flink, connection = NULL;
                        p != &Link->ConnectionDatabase ;
                        p = p->Flink, connection = NULL
                        ) {

                        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
                        if ((connection->Flags & CONNECTION_FLAGS_WAIT_SI) != 0) {
                            // This reference is removed below
                            NbfReferenceConnection ("Found Listener at session init", connection, CREF_ADM_SESS);
                            break;
                        }
                    }

                    //
                    // Well, we've looked through the connections, if we have one,
                    // make it the connection of the day. Note that it will
                    // complete when we call ProcessSessionInitialize.
                    //

                    if (connection != NULL) {

                        Link->NextReceive = (UCHAR)(header->SendSeq >> 1) & (UCHAR)0x7f;
                        Link->NextSend = (UCHAR)(header->RcvSeq >> 1) & (UCHAR)0x7F;

                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                        NbfCompleteLink (Link); // completes the listening connection

                        Status = ProcessSessionInitialize (
                                           connection,
                                           nbfHeader);
                        NbfDereferenceConnection ("Processed SessInit", connection, CREF_ADM_SESS);

#if DBG
                        s = "ADM";
#endif

                        // Link is ready for use.

                        break;
                    }
                }

                //
                // we've got a connection on a link that's in state admin.
                // really bad, kill it and the link.
                //

                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "NbfProcessIIndicate calling NbfStopLink\n" );
                }
#endif
                NbfStopLink (Link);
                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

            }

            //
            // We're disconnected.  Tell him.
            //

            NbfSendDm (Link, PollFinal);   // releases lock
#if DBG
            s = "ADM";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and are waiting for a UA.  He's sent an
            // I-frame too early, so just let the SABME time out.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "CONNECTING";
#endif
            break;

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  If he starts
            // with an I-frame, then we'll let him squeak by.
            //

            if (!Command) {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                s = "W_POLL";
#endif
                break;
            }

            Link->State = LINK_STATE_READY;     // we're up!
            StopT1 (Link);                      // no longer waiting.
            FakeUpdateBaseT1Timeout (Link);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            NbfCompleteLink (Link);              // fire up the connections.
            StartTi (Link);
            NbfProcessIIndicate (                // recursive, but safe
                            Command,
                            PollFinal,
                            Link,
                            DlcHeader,
                            DlcIndicatedLength,
                            DlcTotalLength,
                            ReceiveContext,
                            Loopback);
#if DBG
            s = "W_POLL";
#endif
            break;

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy.  I-r/f will do.
            //

            if (Command || !PollFinal) {        // don't allow this protocol.
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                s = "W_FINAL";
#endif
                break;                          // we sent RR-c/p.
            }

            Link->State = LINK_STATE_READY;     // we're up.
            StopT1 (Link);                      // no longer waiting.
            StartT2 (Link);                     // we have an unacked I-frame.
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            NbfCompleteLink (Link);              // fire up the connections.
            StartTi (Link);
            NbfProcessIIndicate (                // recursive, but safe
                            Command,
                            PollFinal,
                            Link,
                            DlcHeader,
                            DlcIndicatedLength,
                            DlcTotalLength,
                            ReceiveContext,
                            Loopback);
#if DBG
            s = "W_FINAL";
#endif
            break;

        case LINK_STATE_W_DISC_RSP:

            //
            // We're waiting for a response from our DISC-c/p but instead of
            // a UA-r/f, we got this I-frame.  Throw the packet away.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "W_DISC_RSP";
#endif
            break;


        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

#if DBG
    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint1 (" NbfProcessIIndicate: (%s) I-Frame processed.\n", s);
    }
#endif

    return;
} /* NbfProcessIIndicate */


NTSTATUS
ProcessIndicateData(
    IN PTP_CONNECTION Connection,
    IN PUCHAR DlcHeader,
    IN UINT DlcIndicatedLength,
    IN PUCHAR DataHeader,
    IN UINT DataTotalLength,
    IN NDIS_HANDLE ReceiveContext,
    IN BOOLEAN Last,
    IN BOOLEAN Loopback
    )

/*++

Routine Description:

    This routine is called to process data received in a DATA_FIRST_MIDDLE
    or DATA_ONLY_LAST frame.  We attempt to satisfy as many TdiReceive
    requests as possible with this data.

    If a receive is already active on this Connection, then we copy as much
    data into the active receive's buffer as possible.  If all the data is
    copied and the receive request's buffer has not been filled, then the
    Last flag is checked, and if it is TRUE, we go ahead and complete the
    current receive with the TDI_END_OF_RECORD receive indicator.  If Last
    is FALSE, we simply return.

    If more (uncopied) data remains in the frame, or if there is no active
    receive outstanding, then an indication is issued to the owning address's
    receive event handler.  The event handler can take one of three actions:

    1.  Return STATUS_SUCCESS, in which case the transport will assume that
        all of the indicated data has been accepted by the client.

    3.  Return STATUS_DATA_NOT_ACCEPTED, in which case the transport will
        discard the data and set the CONNECTION_FLAGS_RECEIVE_WAKEUP bitflag
        in the Connection, indicating that remaining data is to be discarded
        until a receive becomes available.

    NOTE: This routine is called with Connection->LinkSpinLock held,
    and returns with it released. THIS ROUTINE MUST BE CALLED AT
    DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    DlcHeader - The pointer handed to us as the start of the NBF header by NDIS;
        use this to compute the offset into the packet to start the transfer
        of data to user buffers.

    DlcIndicatedLength - The amount of NBF data available at indicate.

    DataHeader - A pointer to the start of the data in the packet.

    DataTotalLength - The total length of the packet, starting at DataHeader.

    ReceiveContext - An NDIS handle that identifies the packet we are currently
        processing.

    Last - Boolean value that indicates whether this is the last piece of data
        in a message.  The DATA_ONLY_LAST processor sets this flag to TRUE when
        calling this routine, and the DATA_FIRST_MIDDLE processor resets this
        flag to FALSE when calling this routine.

    Loopback - Is this a loopback indication; used to determine whether
        to call NdisTransferData or NbfTransferLoopbackData.


Return Value:

    STATUS_SUCCESS if we've consumed the packet,

--*/

{
    NTSTATUS status, tmpstatus;
    PDEVICE_CONTEXT deviceContext;
    NDIS_STATUS ndisStatus;
    PNDIS_PACKET ndisPacket;
    PSINGLE_LIST_ENTRY linkage;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PNDIS_BUFFER ndisBuffer;
    ULONG destBytes;
    ULONG bufferChainLength;
    ULONG indicateBytesTransferred;
    ULONG ReceiveFlags;
    ULONG ndisBytesTransferred;
    UINT BytesToTransfer;
    ULONG bytesIndicated;
    ULONG DataOffset = (ULONG)((PUCHAR)DataHeader - (PUCHAR)DlcHeader);
    PRECEIVE_PACKET_TAG receiveTag;
    PTP_ADDRESS_FILE addressFile;
    PMDL SavedCurrentMdl;
    ULONG SavedCurrentByteOffset;
    BOOLEAN ActivatedLongReceive = FALSE;
    BOOLEAN CompleteReceiveBool, EndOfMessage;
    ULONG DumpData[2];


    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint4 ("  ProcessIndicateData:  Entered, PacketStart: %lx Offset: %lx \n     TotalLength %ld DlcIndicatedLength: %ld\n",
            DlcHeader, DataOffset, DataTotalLength, DlcIndicatedLength);
    }


    //
    // copy this packet into our receive buffer.
    //

    deviceContext = Connection->Provider;

    if ((Connection->Flags & CONNECTION_FLAGS_RCV_CANCELLED) != 0) {

        //
        // A receive in progress was cancelled; we toss the data,
        // but do send the DOL if it was the last piece of the
        // send.
        //

        if (Last) {

            Connection->Flags &= ~CONNECTION_FLAGS_RCV_CANCELLED;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfSendDataAck (Connection);

        } else {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        Connection->IndicationInProgress = FALSE;

        return STATUS_SUCCESS;
    }

    //
    // Initialize this to zero, in case we do not indicate or
    // the client does not fill it in.
    //

    indicateBytesTransferred = 0;

    if (!(Connection->Flags & CONNECTION_FLAGS_ACTIVE_RECEIVE)) {

        //
        // check first to see if there is a receive available. If there is,
        // use it before doing an indication.
        //

        if (Connection->ReceiveQueue.Flink != &Connection->ReceiveQueue) {

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("  ProcessIndicateData:  Found receive.  Prepping.\n");
            }

            //
            // Found a receive, so make it the active one and
            // cycle around again.
            //

            Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;
            Connection->MessageBytesReceived = 0;
            Connection->MessageBytesAcked = 0;
            Connection->MessageInitAccepted = 0;
            Connection->CurrentReceiveIrp =
                CONTAINING_RECORD (Connection->ReceiveQueue.Flink,
                                   IRP, Tail.Overlay.ListEntry);
            Connection->CurrentReceiveSynchronous =
                deviceContext->MacInfo.SingleReceive;
            Connection->CurrentReceiveMdl =
                Connection->CurrentReceiveIrp->MdlAddress;
            Connection->ReceiveLength =
                IRP_RECEIVE_LENGTH (IoGetCurrentIrpStackLocation (Connection->CurrentReceiveIrp));
            Connection->ReceiveByteOffset = 0;
            status = STATUS_SUCCESS;
            goto NormalReceive;
        }

        //
        // A receive is not active.  Post a receive event.
        //

        if ((Connection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) == 0) {
            Connection->IndicationInProgress = FALSE;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            return STATUS_SUCCESS;
        }

        addressFile = Connection->AddressFile;

        if ((!addressFile->RegisteredReceiveHandler) ||
            (Connection->ReceiveBytesUnaccepted != 0)) {

            //
            // There is no receive posted to the Connection, and
            // no event handler. Set the RECEIVE_WAKEUP bit, so that when a
            // receive does become available, it will restart the
            // current send. Also send a NoReceive to tell the other
            // guy he needs to resynch.
            //

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("  ProcessIndicateData:  ReceiveQueue empty. Setting RECEIVE_WAKEUP.\n");
            }
            Connection->Flags |= CONNECTION_FLAGS_RECEIVE_WAKEUP;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->IndicationInProgress = FALSE;

            // NbfSendNoReceive (Connection);
            return STATUS_SUCCESS;
        }

        IF_NBFDBG (NBF_DEBUG_RCVENG) {
            NbfPrint0 ("  ProcessIndicateData:  Receive not active.  Posting event.\n");
        }

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        LEAVE_NBF;

        //
        // Indicate to the user. For BytesAvailable we
        // always use DataTotalLength; for BytesIndicated we use
        // MIN (DlcIndicatedLength - DataOffset, DataTotalLength).
        //
        // To clarify BytesIndicated, on an Ethernet packet
        // which is padded DataTotalLength will be shorter; on an
        // Ethernet packet which is not padded and which is
        // completely indicated, the two will be equal; and
        // on a long Ethernet packet DlcIndicatedLength - DataOffset
        // will be shorter.
        //

        bytesIndicated = DlcIndicatedLength - DataOffset;
        if (DataTotalLength <= bytesIndicated) {
            bytesIndicated = DataTotalLength;
        }

        ReceiveFlags = TDI_RECEIVE_AT_DISPATCH_LEVEL;
        if (Last) {
            ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
        }
        if (deviceContext->MacInfo.CopyLookahead) {
            ReceiveFlags |= TDI_RECEIVE_COPY_LOOKAHEAD;
        }

        IF_NBFDBG (NBF_DEBUG_RCVENG) {
            NbfPrint2("ProcessIndicateData:  Indicating - Bytes Indi =%lx, DataTotalLen =%lx.\n",
                      bytesIndicated, DataTotalLength);
        }

        status = (*addressFile->ReceiveHandler)(
                    addressFile->ReceiveHandlerContext,
                    Connection->Context,
                    ReceiveFlags,
                    bytesIndicated,
                    DataTotalLength,             // BytesAvailable
                    &indicateBytesTransferred,
                    DataHeader,
                    &irp);

#if PKT_LOG
        // We indicated here, log packet indicated for debugging
        NbfLogIndPacket(Connection,
                        DataHeader,
                        DataTotalLength,
                        bytesIndicated,
                        indicateBytesTransferred,
                        status);
#endif

        ENTER_NBF;

        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            ULONG SpecialIrpLength;
            PTDI_REQUEST_KERNEL_RECEIVE Parameters;

            //
            // The client's event handler has returned an IRP in the
            // form of a TdiReceive that is to be associated with this
            // data.  The request will be installed at the front of the
            // ReceiveQueue, and then made the active receive request.
            // This request will be used to accept the incoming data, which
            // will happen below.
            //

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("  ProcessIndicateData:  Status=STATUS_MORE_PROCESSING_REQUIRED.\n");
                NbfPrint4 ("  ProcessIndicateData:  Irp=%lx, Mdl=%lx, UserBuffer=%lx, Count=%ld.\n",
                          irp, irp->MdlAddress, irp->UserBuffer,
                          MmGetMdlByteCount (irp->MdlAddress));
            }

            //
            // Queueing a receive of any kind causes a Connection reference;
            // that's what we've just done here, so make the Connection stick
            // around. We create a request to keep a packets outstanding ref
            // count for the current IRP; we queue this on the connection's
            // receive queue so we can treat it like a normal receive. If
            // we can't get a request to describe this irp, we can't keep it
            // around hoping for better later; we simple fail it with
            // insufficient resources. Note this is only likely to happen if
            // we've completely run out of transport memory.
            //

            irp->IoStatus.Information = 0;  // byte transfer count.
            irp->IoStatus.Status = STATUS_PENDING;
            irpSp = IoGetCurrentIrpStackLocation (irp);

            ASSERT (irpSp->FileObject->FsContext == Connection);

            Parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
            SpecialIrpLength = Parameters->ReceiveLength;

            //
            // If the packet is a DOL, and it will fit entirely
            // inside this posted IRP, then we don't bother
            // creating a request, because we don't need any of
            // that overhead. We also don't set ReceiveBytes
            // Unaccepted, since this receive would clear it
            // anyway.
            //

            if (Last &&
                (SpecialIrpLength >= (DataTotalLength - indicateBytesTransferred))) {

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                Connection->SpecialReceiveIrp = irp;

                Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;
                Connection->ReceiveLength = SpecialIrpLength;
                Connection->MessageBytesReceived = 0;
                Connection->MessageInitAccepted = indicateBytesTransferred;
                Connection->MessageBytesAcked = 0;
                Connection->CurrentReceiveIrp = NULL;
                Connection->CurrentReceiveSynchronous = TRUE;
                Connection->CurrentReceiveMdl = irp->MdlAddress;
                Connection->ReceiveByteOffset = 0;
                if ((Parameters->ReceiveFlags & TDI_RECEIVE_NO_RESPONSE_EXP) != 0) {
                    Connection->CurrentReceiveAckQueueable = FALSE;
                }

#if DBG
                //
                // switch our reference from PROCESS_DATA to
                // RECEIVE_IRP, this is OK because the RECEIVE_IRP
                // reference won't be removed until Transfer
                // DataComplete, which is the last thing
                // we call.
                //

                NbfReferenceConnection("Special IRP", Connection, CREF_RECEIVE_IRP);
                NbfDereferenceConnection("ProcessIIndicate done", Connection, CREF_PROCESS_DATA);
#endif

            } else {
                KIRQL cancelIrql;

                //
                // The normal path, for longer receives.
                //

                IoAcquireCancelSpinLock(&cancelIrql);
                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                IRP_RECEIVE_IRP(irpSp) = irp;
                if (deviceContext->MacInfo.SingleReceive) {
                    IRP_RECEIVE_REFCOUNT(irpSp) = 1;
                } else {
#if DBG
                    IRP_RECEIVE_REFCOUNT(irpSp) = 1;
                    NbfReferenceReceiveIrpLocked ("Transfer Data", irpSp, RREF_RECEIVE);
#else
                    IRP_RECEIVE_REFCOUNT(irpSp) = 2;     // include one for first xfer
#endif
                }

                //
                // If the Connection is stopping, abort this request.
                //

                if ((Connection->Flags & CONNECTION_FLAGS_READY) == 0) {
                    Connection->IndicationInProgress = FALSE;

                    NbfReferenceConnection("Special IRP stopping", Connection, CREF_RECEIVE_IRP);
                    NbfCompleteReceiveIrp (
                        irp,
                        Connection->Status,
                        0);

                    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                    IoReleaseCancelSpinLock(cancelIrql);

                    if (!deviceContext->MacInfo.SingleReceive) {
                        NbfDereferenceReceiveIrp ("Not ready", irpSp, RREF_RECEIVE);
                    }
                    return STATUS_SUCCESS;    // we have consumed the packet

                }

                //
                // If this IRP has been cancelled, complete it now.
                //

                if (irp->Cancel) {

                    Connection->Flags |= CONNECTION_FLAGS_RECEIVE_WAKEUP;

                    Connection->IndicationInProgress = FALSE;

                    NbfReferenceConnection("Special IRP cancelled", Connection, CREF_RECEIVE_IRP);

                    //
                    // It is safe to call this with locks held.
                    //
                    NbfCompleteReceiveIrp (irp, STATUS_CANCELLED, 0);

                    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                    IoReleaseCancelSpinLock(cancelIrql);

                    if (!deviceContext->MacInfo.SingleReceive) {
                        NbfDereferenceReceiveIrp ("Cancelled", irpSp, RREF_RECEIVE);
                    }

                    return STATUS_SUCCESS;
                }

                //
                // Insert the request on the head of the connection's
                // receive queue, so it can be handled like a normal
                // receive.
                //

                InsertHeadList (&Connection->ReceiveQueue, &irp->Tail.Overlay.ListEntry);

                IoSetCancelRoutine(irp, NbfCancelReceive);

                //
                // Release the cancel spinlock out of order. Since we were
                // at DPC level when we acquired it, we don't have to fiddle
                // with swapping irqls.
                //
                ASSERT(cancelIrql == DISPATCH_LEVEL);
                IoReleaseCancelSpinLock(cancelIrql);

                Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;
                Connection->ReceiveLength = Parameters->ReceiveLength;
                Connection->MessageBytesReceived = 0;
                Connection->MessageInitAccepted = indicateBytesTransferred;
                Connection->ReceiveBytesUnaccepted = DataTotalLength - indicateBytesTransferred;
                Connection->MessageBytesAcked = 0;
                Connection->CurrentReceiveIrp = irp;
                Connection->CurrentReceiveSynchronous =
                    deviceContext->MacInfo.SingleReceive;
                Connection->CurrentReceiveMdl = irp->MdlAddress;
                Connection->ReceiveByteOffset = 0;

#if DBG
                //
                // switch our reference from PROCESS_DATA to
                // REQUEST, this is OK because the REQUEST
                // reference won't be removed until Transfer
                // DataComplete, which is the last thing
                // we call.
                //

                NbfReferenceConnection("Special IRP", Connection, CREF_RECEIVE_IRP);
                NbfDereferenceConnection("ProcessIIndicate done", Connection, CREF_PROCESS_DATA);
#endif
                //
                // Make a note so we know what to do below.
                //

                ActivatedLongReceive = TRUE;

#if DBG
                NbfReceives[NbfReceivesNext].Irp = irp;
                NbfReceivesNext = (NbfReceivesNext++) % TRACK_TDI_LIMIT;
#endif
            }

        } else if (status == STATUS_SUCCESS) {

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("  ProcessIndicateData:  Status=STATUS_SUCCESS.\n");
            }

            //
            // The client has accepted some or all of the indicated data in
            // the event handler.  Update MessageBytesReceived variable in
            // the Connection so that if we are called upon to ACK him
            // at the byte level, then we can correctly report the
            // number of bytes received thus far.  If this is a DOL,
            // then reset the number of bytes received, since this value
            // always at zero for new messages. If the data indicated wasn't
            // all the data in this packet, flow control to the sender that
            // didn't get all of the data.
            //

            if (Last && (indicateBytesTransferred >= DataTotalLength)) {

                ASSERT (indicateBytesTransferred == DataTotalLength);

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                //
                // This will send a DATA ACK or queue a request for
                // a piggyback ack.
                //
                // NOTE: It will also release the connection spinlock.
                //

                Connection->MessageBytesReceived = 0;
                Connection->MessageInitAccepted = indicateBytesTransferred;

                NbfAcknowledgeDataOnlyLast(
                    Connection,
                    Connection->MessageBytesReceived
                    );

                Connection->IndicationInProgress = FALSE;
                return STATUS_SUCCESS;

            } else {

                //
                // This gets gory.
                // If this packet wasn't a DOL, we have no way of knowing how
                // much the client will take of the data in this send that is
                // now arriving. Pathological clients will break this protocol
                // if they do things like taking part of the receive at indicate
                // immediate and then return an irp (this would make the byte
                // count wrong for the irp).
                //
                // Since the client did not take all the data that we
                // told him about, he will eventually post a receive.
                // If this has not already happened then we set the
                // RECEIVE_WAKEUP bit and send a NO_RECEIVE.
                //

#if DBG
                NbfPrint0("NBF: Indicate returned SUCCESS but did not take all data\n");
#endif

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                Connection->MessageBytesReceived = 0;
                Connection->MessageInitAccepted = indicateBytesTransferred;
                Connection->ReceiveBytesUnaccepted = DataTotalLength - indicateBytesTransferred;
                Connection->MessageBytesAcked = 0;

                if (Connection->ReceiveQueue.Flink == &Connection->ReceiveQueue) {

                    //
                    // There is no receive posted to the Connection.
                    //

                    IF_NBFDBG (NBF_DEBUG_RCVENG) {
                        NbfPrint0 ("  ProcessIndicateData:  ReceiveQueue empty. Setting RECEIVE_WAKEUP.\n");
                    }

                    if (indicateBytesTransferred == DataTotalLength) {

                        //
                        // This means he took everything, but it was not
                        // a DOL; there is no need to do anything since
                        // the rest of the data will be right behind.
                        //

                        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                    } else {

                        Connection->Flags |= CONNECTION_FLAGS_RECEIVE_WAKEUP;
                        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                        NbfSendNoReceive (Connection);

                    }

                    Connection->IndicationInProgress = FALSE;

                    return STATUS_SUCCESS;

                } else {

                    IF_NBFDBG (NBF_DEBUG_RCVENG) {
                        NbfPrint0 ("  ProcessIndicateData:  Found receive.  Prepping.\n");
                    }

                    //
                    // Found a receive, so make it the active one. This will cause
                    // an NdisTransferData below, so we don't dereference the
                    // Connection here.
                    //

                    Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;
                    Connection->CurrentReceiveIrp =
                        CONTAINING_RECORD (Connection->ReceiveQueue.Flink,
                                           IRP, Tail.Overlay.ListEntry);
                    Connection->CurrentReceiveSynchronous =
                        deviceContext->MacInfo.SingleReceive;
                    Connection->CurrentReceiveMdl =
                        Connection->CurrentReceiveIrp->MdlAddress;
                    Connection->ReceiveLength =
                        IRP_RECEIVE_LENGTH (IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp));
                    Connection->ReceiveByteOffset = 0;
                }

            }

        } else {    // STATUS_DATA_NOT_ACCEPTED or other

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("  ProcessIndicateData:  Status=STATUS_DATA_NOT_ACCEPTED.\n");
            }

            //
            // Either there is no event handler installed (the default
            // handler returns this code) or the event handler is not
            // able to process the received data at this time.  If there
            // is a TdiReceive request outstanding on this Connection's
            // ReceiveQueue, then we may use it to receive this data.
            // If there is no request outstanding, then we must initiate
            // flow control at the transport level.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->ReceiveBytesUnaccepted = DataTotalLength;

            if (Connection->ReceiveQueue.Flink == &Connection->ReceiveQueue) {

                //
                // There is no receive posted to the Connection, and
                // the event handler didn't want to accept the incoming
                // data.  Set the RECEIVE_WAKEUP bit, so that when a
                // receive does become available, it will restart the
                // current send. Also send a NoReceive to tell the other
                // guy he needs to resynch.
                //

                IF_NBFDBG (NBF_DEBUG_RCVENG) {
                    NbfPrint0 ("  ProcessIndicateData:  ReceiveQueue empty. Setting RECEIVE_WAKEUP.\n");
                }
                Connection->Flags |= CONNECTION_FLAGS_RECEIVE_WAKEUP;
                Connection->IndicationInProgress = FALSE;

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                return STATUS_SUCCESS;

            } else {

                IF_NBFDBG (NBF_DEBUG_RCVENG) {
                    NbfPrint0 ("  ProcessIndicateData:  Found receive.  Prepping.\n");
                }

                //
                // Found a receive, so make it the active one. This will cause
                // an NdisTransferData below, so we don't dereference the
                // Connection here.
                //

                Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;
                Connection->MessageBytesReceived = 0;
                Connection->MessageBytesAcked = 0;
                Connection->MessageInitAccepted = 0;
                Connection->CurrentReceiveIrp =
                    CONTAINING_RECORD (Connection->ReceiveQueue.Flink,
                                       IRP, Tail.Overlay.ListEntry);
                Connection->CurrentReceiveSynchronous =
                    deviceContext->MacInfo.SingleReceive;
                Connection->CurrentReceiveMdl =
                    Connection->CurrentReceiveIrp->MdlAddress;
                Connection->ReceiveLength =
                    IRP_RECEIVE_LENGTH (IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp));
                Connection->ReceiveByteOffset = 0;
            }

        }

    } else {

        //
        // A receive is active, set the status to show
        // that so far.
        //

        status = STATUS_SUCCESS;

    }


NormalReceive:;

    //
    // NOTE: The connection spinlock is held here.
    //
    // We should only get through here if a receive is active
    // and we have not released the lock since checking or
    // making one active.
    //

    ASSERT(Connection->Flags & CONNECTION_FLAGS_ACTIVE_RECEIVE);

    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint2 ("  ProcessIndicateData:  Receive is active. ReceiveLengthLength: %ld Offset: %ld.\n",
            Connection->ReceiveLength, Connection->MessageBytesReceived);
    }

    destBytes = Connection->ReceiveLength - Connection->MessageBytesReceived;

    //
    // If we just activated a non-special receive IRP, we already
    // added a refcount for this transfer.
    //

    if (!Connection->CurrentReceiveSynchronous && !ActivatedLongReceive) {
        NbfReferenceReceiveIrpLocked ("Transfer Data", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
    }
    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);


    //
    // Determine how much data remains to be transferred.
    //

    ASSERT (indicateBytesTransferred <= DataTotalLength);
    BytesToTransfer = DataTotalLength - indicateBytesTransferred;

    if (destBytes < BytesToTransfer) {

        //
        // If the data overflows the current receive, then make a
        // note that we should complete the receive at the end of
        // transfer data, but with EOR false.
        //

        EndOfMessage = FALSE;
        CompleteReceiveBool = TRUE;
        BytesToTransfer = destBytes;

    } else if (destBytes == BytesToTransfer) {

        //
        // If the data just fills the current receive, then complete
        // the receive; EOR depends on whether this is a DOL or not.
        //

        EndOfMessage = Last;
        CompleteReceiveBool = TRUE;

    } else {

        //
        // Complete the receive if this is a DOL.
        //

        EndOfMessage = Last;
        CompleteReceiveBool = Last;

    }


    //
    // If we can copy the data directly, then do so.
    //

    if ((BytesToTransfer > 0) &&
        (DataOffset + indicateBytesTransferred + BytesToTransfer <= DlcIndicatedLength)) {

        //
        // All the data that we need to transfer is available in
        // the indication, so copy it directly.
        //

        ULONG BytesNow, BytesLeft;
        PUCHAR CurTarget, CurSource;
        ULONG CurTargetLen;
        PMDL CurMdl;
        ULONG CurByteOffset;

        //
        // First we advance the connection pointers by the appropriate
        // number of bytes, so that we can reallow indications (only
        // do this if needed).
        //

        CurMdl = Connection->CurrentReceiveMdl;
        CurByteOffset = Connection->ReceiveByteOffset;

        if (!deviceContext->MacInfo.ReceiveSerialized) {

            SavedCurrentMdl = CurMdl;
            SavedCurrentByteOffset = CurByteOffset;

            BytesLeft = BytesToTransfer;
            CurTargetLen = MmGetMdlByteCount (CurMdl) - CurByteOffset;
            while (TRUE) {
                if (BytesLeft >= CurTargetLen) {
                    BytesLeft -= CurTargetLen;
                    CurMdl = CurMdl->Next;
                    CurByteOffset = 0;
                    if (BytesLeft == 0) {
                        break;
                    }
                    CurTargetLen = MmGetMdlByteCount (CurMdl);
                } else {
                    CurByteOffset += BytesLeft;
                    break;
                }
            }

            Connection->CurrentReceiveMdl = CurMdl;
            Connection->ReceiveByteOffset = CurByteOffset;
            Connection->MessageBytesReceived += BytesToTransfer;

            //
            // Set this up, we know the transfer won't
            // "fail" but another one at the same time
            // might.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            if (Connection->TransferBytesPending == 0) {
                Connection->TransferBytesPending = BytesToTransfer;
                Connection->TotalTransferBytesPending = BytesToTransfer;
                Connection->SavedCurrentReceiveMdl = SavedCurrentMdl;
                Connection->SavedReceiveByteOffset = SavedCurrentByteOffset;
            } else {
                Connection->TransferBytesPending += BytesToTransfer;
                Connection->TotalTransferBytesPending += BytesToTransfer;
            }
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->IndicationInProgress = FALSE;

            //
            // Restore these for the next section of code.
            //

            CurMdl = SavedCurrentMdl;
            CurByteOffset = SavedCurrentByteOffset;

        }

        CurTarget = (PUCHAR)(MmGetSystemAddressForMdl(CurMdl)) + CurByteOffset;
        CurTargetLen = MmGetMdlByteCount(CurMdl) - CurByteOffset;
        CurSource = DataHeader + indicateBytesTransferred;

        BytesLeft = BytesToTransfer;

        while (TRUE) {

            if (CurTargetLen < BytesLeft) {
                BytesNow = CurTargetLen;
            } else {
                BytesNow = BytesLeft;
            }
            TdiCopyLookaheadData(
                CurTarget,
                CurSource,
                BytesNow,
                deviceContext->MacInfo.CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

            if (BytesNow == CurTargetLen) {
                BytesLeft -= BytesNow;
                CurMdl = CurMdl->Next;
                CurByteOffset = 0;
                if (BytesLeft > 0) {
                    CurTarget = MmGetSystemAddressForMdl(CurMdl);
                    CurTargetLen = MmGetMdlByteCount(CurMdl);
                    CurSource += BytesNow;
                } else {
                    break;
                }
            } else {
                CurByteOffset += BytesNow;
                ASSERT (BytesLeft == BytesNow);
                break;
            }

        }

        if (deviceContext->MacInfo.ReceiveSerialized) {

            //
            // If we delayed updating these, do it now.
            //

            Connection->CurrentReceiveMdl = CurMdl;
            Connection->ReceiveByteOffset = CurByteOffset;
            Connection->MessageBytesReceived += BytesToTransfer;
            Connection->IndicationInProgress = FALSE;

        } else {

            //
            // Check if something else failed and we are the
            // last to complete, if so then back up our
            // receive pointers and send a receive
            // outstanding to make him resend.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->TransferBytesPending -= BytesToTransfer;

            if ((Connection->TransferBytesPending == 0) &&
                (Connection->Flags & CONNECTION_FLAGS_TRANSFER_FAIL)) {

                Connection->CurrentReceiveMdl = Connection->SavedCurrentReceiveMdl;
                Connection->ReceiveByteOffset = Connection->SavedReceiveByteOffset;
                Connection->MessageBytesReceived -= Connection->TotalTransferBytesPending;
                Connection->Flags &= ~CONNECTION_FLAGS_TRANSFER_FAIL;
                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                NbfSendReceiveOutstanding (Connection);

                if (!Connection->SpecialReceiveIrp &&
                    !Connection->CurrentReceiveSynchronous) {
                        NbfDereferenceReceiveIrp ("TransferData complete", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
                }

                return status;

            } else {

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            }

        }

        //
        // Now that the transfer is complete, simulate a call to
        // TransferDataComplete.
        //


        if (!Connection->SpecialReceiveIrp) {

            Connection->CurrentReceiveIrp->IoStatus.Information += BytesToTransfer;
            if (!Connection->CurrentReceiveSynchronous) {
                NbfDereferenceReceiveIrp ("TransferData complete", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
            }

        }

        //
        // see if we've completed the current receive. If so, move to the next one.
        //

        if (CompleteReceiveBool) {
            CompleteReceive (Connection, EndOfMessage, BytesToTransfer);
        }

        return status;

    }


    //
    // Get a packet for the coming transfer
    //

    linkage = ExInterlockedPopEntryList(
        &deviceContext->ReceivePacketPool,
        &deviceContext->Interlock);

    if (linkage != NULL) {
        ndisPacket = CONTAINING_RECORD( linkage, NDIS_PACKET, ProtocolReserved[0] );
    } else {
        deviceContext->ReceivePacketExhausted++;
        if (!Connection->CurrentReceiveSynchronous) {
            NbfDereferenceReceiveIrp ("No receive packet", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
        }

        //
        // We could not get a receive packet. We do have an active
        // receive, so we just send a receive outstanding to
        // get him to resend. Hopefully we will have a receive
        // packet available when the data is resent.
        //

        if ((Connection->Flags & CONNECTION_FLAGS_VERSION2) == 0) {
            NbfSendNoReceive (Connection);
        }
        NbfSendReceiveOutstanding (Connection);

#if DBG
        NbfPrint0 ("  ProcessIndicateData: Discarding Packet, no receive packets\n");
#endif
        Connection->IndicationInProgress = FALSE;

        return status;
    }

    //
    // Initialize the receive packet.
    //

    receiveTag = (PRECEIVE_PACKET_TAG)(ndisPacket->ProtocolReserved);
    // receiveTag->PacketType = TYPE_AT_INDICATE;
    receiveTag->Connection = Connection;
    receiveTag->TransferDataPended = TRUE;

    receiveTag->EndOfMessage = EndOfMessage;
    receiveTag->CompleteReceive = CompleteReceiveBool;


    //
    // if we've got zero bytes left, avoid the TransferData below and
    // just deliver.
    //

    if (BytesToTransfer <= 0) {
        Connection->IndicationInProgress = FALSE;
        receiveTag->TransferDataPended = FALSE;
        receiveTag->AllocatedNdisBuffer = FALSE;
        receiveTag->BytesToTransfer = 0;
        NbfTransferDataComplete (
                deviceContext,
                ndisPacket,
                NDIS_STATUS_SUCCESS,
                0);

        return status;
    }

    //
    // describe the right part of the user buffer to NDIS. If we can't get
    // the mdl for the packet, drop dead. Bump the request reference count
    // so that we know we need to hold open receives until the NDIS transfer
    // data requests complete.
    //

    SavedCurrentMdl = Connection->CurrentReceiveMdl;
    SavedCurrentByteOffset = Connection->ReceiveByteOffset;

    if ((Connection->ReceiveByteOffset == 0) &&
        (CompleteReceiveBool)) {

        //
        // If we are transferring into the beginning of
        // the current MDL, and we will be completing the
        // receive after the transfer, then we don't need to
        // copy it.
        //

        ndisBuffer = (PNDIS_BUFFER)Connection->CurrentReceiveMdl;
        bufferChainLength = BytesToTransfer;
        Connection->CurrentReceiveMdl = NULL;
        // Connection->ReceiveByteOffset = 0;
        receiveTag->AllocatedNdisBuffer = FALSE;
        tmpstatus = STATUS_SUCCESS;

    } else {

        tmpstatus = BuildBufferChainFromMdlChain (
                    deviceContext,
                    Connection->CurrentReceiveMdl,
                    Connection->ReceiveByteOffset,
                    BytesToTransfer,
                    &ndisBuffer,
                    &Connection->CurrentReceiveMdl,
                    &Connection->ReceiveByteOffset,
                    &bufferChainLength);

        receiveTag->AllocatedNdisBuffer = TRUE;

    }


    if ((!NT_SUCCESS (tmpstatus)) || (bufferChainLength != BytesToTransfer)) {

        DumpData[0] = bufferChainLength;
        DumpData[1] = BytesToTransfer;

        NbfWriteGeneralErrorLog(
            deviceContext,
            EVENT_TRANSPORT_TRANSFER_DATA,
            604,
            tmpstatus,
            NULL,
            2,
            DumpData);

        if (!Connection->CurrentReceiveSynchronous) {
            NbfDereferenceReceiveIrp ("No MDL chain", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
        }

        //
        // Restore our old state and make him resend.
        //

        Connection->CurrentReceiveMdl = SavedCurrentMdl;
        Connection->ReceiveByteOffset = SavedCurrentByteOffset;

        if ((Connection->Flags & CONNECTION_FLAGS_VERSION2) == 0) {
            NbfSendNoReceive (Connection);
        }
        NbfSendReceiveOutstanding (Connection);

        Connection->IndicationInProgress = FALSE;

        ExInterlockedPushEntryList(
            &deviceContext->ReceivePacketPool,
            &receiveTag->Linkage,
            &deviceContext->Interlock);

        return status;
    }

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint3 ("  ProcessIndicateData: Mdl: %lx user buffer: %lx user offset: %lx \n",
            ndisBuffer, Connection->CurrentReceiveMdl, Connection->ReceiveByteOffset);
    }

    NdisChainBufferAtFront (ndisPacket, ndisBuffer);

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint1 ("  ProcessIndicateData: Transferring Complete Packet: %lx\n",
            ndisPacket);
    }

    //
    // update the number of bytes received; OK to do this
    // unprotected since IndicationInProgress is still FALSE.
    //
    //

    Connection->MessageBytesReceived += BytesToTransfer;

    //
    // We have to do this for two reasons: for MACs that
    // are not receive-serialized, to keep track of it,
    // and for MACs where transfer data can pend, so
    // we have stuff saved to handle failure later (if
    // the MAC is synchronous on transfers and it fails,
    // we fill these fields in before calling CompleteTransferData).
    //

    if (!deviceContext->MacInfo.SingleReceive) {

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        receiveTag->BytesToTransfer = BytesToTransfer;
        if (Connection->TransferBytesPending == 0) {
            Connection->TransferBytesPending = BytesToTransfer;
            Connection->TotalTransferBytesPending = BytesToTransfer;
            Connection->SavedCurrentReceiveMdl = SavedCurrentMdl;
            Connection->SavedReceiveByteOffset = SavedCurrentByteOffset;
        } else {
            Connection->TransferBytesPending += BytesToTransfer;
            Connection->TotalTransferBytesPending += BytesToTransfer;
        }

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    }

    //
    // We have now updated all the connection counters (
    // assuming the TransferData will succeed) and this
    // packet's location in the request is secured, so we
    // can be reentered.
    //

    Connection->IndicationInProgress = FALSE;

    if (Loopback) {

        NbfTransferLoopbackData(
            &ndisStatus,
            deviceContext,
            ReceiveContext,
            deviceContext->MacInfo.TransferDataOffset +
                DataOffset + indicateBytesTransferred,
            BytesToTransfer,
            ndisPacket,
            (PUINT)&ndisBytesTransferred
            );

    } else {

        if (deviceContext->NdisBindingHandle) {

            NdisTransferData (
                &ndisStatus,
                deviceContext->NdisBindingHandle,
                ReceiveContext,
                deviceContext->MacInfo.TransferDataOffset +
                    DataOffset + indicateBytesTransferred,
                BytesToTransfer,
                ndisPacket,
                (PUINT)&ndisBytesTransferred);
        }
        else {
            ndisStatus = STATUS_INVALID_DEVICE_STATE;
        }
    }

    //
    // handle the various completion codes
    //

    if ((ndisStatus == NDIS_STATUS_SUCCESS) &&
        (ndisBytesTransferred == BytesToTransfer)) {

        //
        // deallocate the buffers and such that we've used if at indicate
        //

        receiveTag->TransferDataPended = FALSE;

        NbfTransferDataComplete (
                deviceContext,
                ndisPacket,
                ndisStatus,
                BytesToTransfer);

    } else if (ndisStatus == NDIS_STATUS_PENDING) {

        //
        // Because TransferDataPended stays TRUE, this reference will
        // be removed in TransferDataComplete. It is OK to do this
        // now, even though TransferDataComplete may already have been
        // called, because we also hold the ProcessIIndicate reference
        // so there will be no "bounce".
        //

        NbfReferenceConnection ("TransferData pended", Connection, CREF_TRANSFER_DATA);

    } else {

        //
        // something broke; certainly we'll never get NdisTransferData
        // asynch completion with this error status. We set things up
        // to that NbfTransferDataComplete will do the right thing.
        //

        if (deviceContext->MacInfo.SingleReceive) {
            Connection->TransferBytesPending = BytesToTransfer;
            Connection->TotalTransferBytesPending = BytesToTransfer;
            Connection->SavedCurrentReceiveMdl = SavedCurrentMdl;
            Connection->SavedReceiveByteOffset = SavedCurrentByteOffset;
            receiveTag->BytesToTransfer = BytesToTransfer;
        }

        receiveTag->TransferDataPended = FALSE;

        NbfTransferDataComplete (
                deviceContext,
                ndisPacket,
                ndisStatus,
                BytesToTransfer);

    }

    return status;  // which only means we've dealt with the packet

} /* ProcessIndicateData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\link.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    link.c

Abstract:

    This module contains code which implements the TP_LINK object.
    Routines are provided to create, destroy, reference, and dereference,
    transport link objects.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

extern ULONG StartTimerLinkDeferredAdd;
extern ULONG StartTimerLinkDeferredDelete;

#if DBG
// The following is here for debugging purposes to make it easy to change
// the maximum packet size.

ULONG MaxUserPacketData = 18000;
#endif

#if 0

VOID
DisconnectCompletionHandler(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine is called as an I/O completion handler at the time a
    TdiDisconnect request is completed.   Here we dereference the link
    object, and optionally reference it again and start up the link if
    some transport connection started up on the link during the time we
    were trying to shut it down.

Arguments:

    TransportLink - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("DisconnectCompletionHandler:  Entered for link %lx.\n",
                    TransportLink);
    }

    //
    // The following call will dereference this link for the last time,
    // unless another transport connection has been assigned to the link
    // during the time the data link layer was bringing the link down and
    // when we got here.  If this condition exists, then now is the time
    // to bring the link back up, else destroy it.
    //

    // don't forget to check for bringing it back up again.

    NbfDereferenceLink ("Disconnecting", TransportLink, LREF_CONNECTION);  // this makes it go away.
#if DBG
    NbfPrint0("Disconnecting Completion Handler\n");
#endif

} /* DisconnectCompletionHandler */
#endif


VOID
NbfCompleteLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called by the UA-r/x handler, NbfWaitLink, and
    NbfActivateLink to startup the NBF connections associated with
    a link because they were waiting for the link to become established.

    When we get here, the link has been established, so we need to
    start the next set of connection-establishment protocols:

        SESSION_INIT    ----------------->
                        <-----------------      SESSION_CONFIRM

        (TdiConnect completes)                  (TdiListen completes)

    NOTE: THIS ROUTINE MUST BE CALLED FROM DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    PTP_CONNECTION Connection;
    BOOLEAN TimerWasCleared;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfCompleteLink:  Entered for link %lx.\n", Link);
    }

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Officially declare that this link is ready for I-frame business.
    //

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    //
    // We can now send and receive I-frames on this link.  We are in ABME.
    //

    //
    // This probably isn't necessary, but to be safe for now.. (adb 6/28)
    //
    if (Link->State == LINK_STATE_ADM) {
        // Moving out of ADM, add special reference
        NbfReferenceLinkSpecial("To READY in NbfCompleteLink", Link, LREF_NOT_ADM);
    }

    Link->State = LINK_STATE_READY;
    Link->SendState = SEND_STATE_READY;
    Link->ReceiveState = RECEIVE_STATE_READY;
    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    //
    // Complete all of the listens first, so they will be expecting
    // incoming SESSION_INITIALIZEs.  Then do the connects.
    //

    // This creates a connection reference which is removed below.
    while ((Connection=NbfLookupPendingListenOnLink (Link)) != NULL) {
        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // This loop looks unnecessary, let's make sure... - adb 9/11/91
        //
        ASSERT(Connection->Flags & CONNECTION_FLAGS_WAIT_SI);

        Connection->Flags |= CONNECTION_FLAGS_WAIT_SI; // wait session initialize.
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        NbfDereferenceConnection ("Pending listen", Connection, CREF_P_LINK);
    } /* while */

    //
    // And do the connects. If there are connections in progress, they'll
    // also have timers associated with them. Cancel those timers.
    //

    while ((Connection=NbfLookupPendingConnectOnLink (Link)) != NULL) {
        TimerWasCleared = KeCancelTimer (&Connection->Timer);
        IF_NBFDBG (NBF_DEBUG_LINK) {
            NbfPrint2 ("NbfCompleteLink:  Timer for connection %lx %s canceled.\n",
                Connection, TimerWasCleared ? "was" : "was NOT" );
            }
        if (TimerWasCleared) {
            NbfDereferenceConnection("Cancel timer", Connection, CREF_TIMER);
        }
        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        Connection->Flags |= CONNECTION_FLAGS_WAIT_SC; // wait session confirm.
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // No timeout for this frame is required since the link is responsible
        // for reliable delivery.  If we can't send this frame, however, the
        // data link connection will happily keep quiet without timeouts.
        //

        NbfSendSessionInitialize (Connection);
        NbfDereferenceConnection ("NbfCompleteLink", Connection, CREF_P_CONNECT);
    } /* while */

} /* NbfCompleteLink */


VOID
NbfAllocateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_LINK *TransportLink
    )

/*++

Routine Description:

    This routine allocates storage for a data link connection. It
    performs minimal initialization of the object.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        link.

    TransportLink - Pointer to a place where this routine will return a
        pointer to an allocated transport link structure. Returns
        NULL if no storage can be allocated.

Return Value:

    None.

--*/

{
    PTP_LINK Link;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + sizeof(TP_LINK)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate link: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            105,
            sizeof(TP_LINK),
            LINK_RESOURCE_ID);
        *TransportLink = NULL;
        return;
    }
    Link = (PTP_LINK)ExAllocatePoolWithTag (
                         NonPagedPool,
                         sizeof (TP_LINK),
                         NBF_MEM_TAG_TP_LINK);
    if (Link == NULL) {
        PANIC("NBF: Could not allocate link: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            205,
            sizeof(TP_LINK),
            LINK_RESOURCE_ID);
        *TransportLink = NULL;
        return;
    }
    RtlZeroMemory (Link, sizeof(TP_LINK));

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint1 ("ExAllocatePool Link %08x\n", Link);
    }

    ++DeviceContext->LinkAllocated;
    DeviceContext->MemoryUsage += sizeof(TP_LINK);

    Link->Type = NBF_LINK_SIGNATURE;
    Link->Size = sizeof (TP_LINK);

    KeInitializeSpinLock (&Link->SpinLock);
    Link->Provider = DeviceContext;
    Link->ProviderInterlock = &DeviceContext->Interlock;

    InitializeListHead (&Link->Linkage);
    InitializeListHead (&Link->ConnectionDatabase);
    InitializeListHead (&Link->WackQ);
    InitializeListHead (&Link->NdisSendQueue);
    InitializeListHead (&Link->ShortList);
    Link->OnShortList = FALSE;
    InitializeListHead (&Link->LongList);
    Link->OnLongList = FALSE;
    InitializeListHead (&Link->PurgeList);

    Link->T1 = 0;          // 0 indicates they are not in the list
    Link->T2 = 0;
    Link->Ti = 0;

    NbfAddSendPacket (DeviceContext);
    NbfAddReceivePacket (DeviceContext);

    *TransportLink = Link;

}   /* NbfAllocateLink */


VOID
NbfDeallocateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine frees storage for a data link connection.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        link.

    TransportLink - Pointer to the transport link structure.

Return Value:

    None.

--*/

{
    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint1 ("ExFreePool Link: %08x\n", TransportLink);
    }

    ExFreePool (TransportLink);
    --DeviceContext->LinkAllocated;
    DeviceContext->MemoryUsage -= sizeof(TP_LINK);

    NbfRemoveSendPacket (DeviceContext);
    NbfRemoveReceivePacket (DeviceContext);

}   /* NbfDeallocateLink */


NTSTATUS
NbfCreateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PHARDWARE_ADDRESS HardwareAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN USHORT LoopbackLinkIndex,
    OUT PTP_LINK *TransportLink
    )

/*++

Routine Description:

    This routine creates a data link connection between the local
    data link station and the specified remote data link address.
    As an option (Passive=TRUE), the caller may specify that instead
    of a Connect activity, a Listen is to be performed instead.

    Normally, if a link to the remote address is not already active,
    then a link object is allocated, the reference count in the link
    is set to 1, and the reference count of the device context is
    incremented.

    If a link is already active to the remote address, then the existing
    link object is referenced with NbfReferenceLink() so that it can be
    shared between the transport connections.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        link.

    HardwareAddress - Pointer to a HARDWARE_ADDRESS type containing the
        hardware address of the REMOTE link station to connect to/listen for.

    LoopbackLinkIndex - In the case that this turns out to be created
        as one of the LoopbackLinks, this will indicate which one to
        use.

    TransportLink - Pointer to a place where this routine will return a
        pointer to an allocated transport link structure.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_LINK Link;
    PLIST_ENTRY p;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;
    USHORT i;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);


    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfCreateLink:  Entered, DeviceContext: %lx\n", DeviceContext);
    }

    //
    // Walk the list of addresses to see if we already have a link to this
    // remote address.
    //

    // This adds a reference if the link is found.

    Link = NbfFindLink (DeviceContext, HardwareAddress->Address);


    if (Link == (PTP_LINK)NULL) {

        //
        // If necessary, check whether we are looking for one of
        // the loopback links (NbfFindLink won't find those).
        //

        if (RtlEqualMemory(
               HardwareAddress->Address,
               DeviceContext->LocalAddress.Address,
               DeviceContext->MacInfo.AddressLength)) {

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
            Link = DeviceContext->LoopbackLinks[LoopbackLinkIndex];

            if (Link != (PTP_LINK)NULL) {

                //
                // Add a reference to simulate the one from NbfFindLink
                //
                // This needs to be atomically done with the assignment above.
                //

                NbfReferenceLink ("Found loopback link", Link, LREF_TREE);

                RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
            } else {

                RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
                //
                // May have the first loopback link; need to make sure the
                // buffer for indications is allocated.
                //

                if (DeviceContext->LookaheadContiguous == NULL) {

                     DeviceContext->LookaheadContiguous =
                         ExAllocatePoolWithTag (
                             NonPagedPool,
                             NBF_MAX_LOOPBACK_LOOKAHEAD,
                             NBF_MEM_TAG_LOOPBACK_BUFFER);
                     if (DeviceContext->LookaheadContiguous == NULL) {
                         PANIC ("NbfCreateLink: Could not allocate loopback buffer!\n");
                         return STATUS_INSUFFICIENT_RESOURCES;
                     }

                }

            }

        }

    }


    if (Link != (PTP_LINK)NULL) {

        //
        // Found the link structure here, so use the existing link.
        //

#if DBG
        //
        // These two operations have no net effect, so if not in debug
        // mode we can remove them.
        //

        // This reference is removed by NbfDisconnectFromLink
        // (this assumes that NbfConnectToLink is always called
        // if this function returns success).

        NbfReferenceLink ("New Ref, Found existing link", Link, LREF_CONNECTION);        // extra reference.

        // Now we can remove the NbfFindLinkInTree reference.

        NbfDereferenceLink ("Found link in tree", Link, LREF_TREE);
#endif

        *TransportLink = Link;             // return pointer to the link.
        IF_NBFDBG (NBF_DEBUG_LINK) {
            NbfPrint0 ("NbfCreateLink: returning ptr to existing link object.\n");
        }
        return STATUS_SUCCESS;          // all done.

    } /* if LINK != NULL */


    //
    // We don't have an existing link, so we have to create one.
    //

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint0 ("NbfCreateLink: using new link object.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    p = RemoveHeadList (&DeviceContext->LinkPool);
    if (p == &DeviceContext->LinkPool) {

        if ((DeviceContext->LinkMaxAllocated == 0) ||
            (DeviceContext->LinkAllocated < DeviceContext->LinkMaxAllocated)) {

            NbfAllocateLink (DeviceContext, &Link);
            IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
                NbfPrint1 ("NBF: Allocated link at %lx\n", Link);
            }

        } else {

            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_SPECIFIC,
                405,
                sizeof(TP_LINK),
                LINK_RESOURCE_ID);
            Link = NULL;

        }

        if (Link == NULL) {
            ++DeviceContext->LinkExhausted;
            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
            PANIC ("NbfCreateConnection: Could not allocate link object!\n");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        Link = CONTAINING_RECORD (p, TP_LINK, Linkage);

    }

    ++DeviceContext->LinkInUse;
    ASSERT(DeviceContext->LinkInUse > 0);

    if (DeviceContext->LinkInUse > DeviceContext->LinkMaxInUse) {
        ++DeviceContext->LinkMaxInUse;
    }

    DeviceContext->LinkTotal += DeviceContext->LinkInUse;
    ++DeviceContext->LinkSamples;

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);


    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfCreateLink:  Link at %lx.\n", Link);
    }

    //
    // Initialize all of the static data for this link.
    //

    Link->SpecialRefCount = 1;
    Link->ReferenceCount = 0;
#if DBG
    {
        UINT Counter;
        for (Counter = 0; Counter < NUMBER_OF_LREFS; Counter++) {
            Link->RefTypes[Counter] = 0;
        }

        // This reference is removed by NbfDisconnectFromLink
        // (this assumes that NbfConnectToLink is always called
        // if this function returns success).
        //

        Link->RefTypes[LREF_CONNECTION] = 1;
        Link->RefTypes[LREF_SPECIAL_TEMP] = 1;
    }
    Link->Destroyed = FALSE;
    Link->TotalReferences = 0;
    Link->TotalDereferences = 0;
    Link->NextRefLoc = 0;
    ExInterlockedInsertHeadList (&NbfGlobalLinkList, &Link->GlobalLinkage, &NbfGlobalInterlock);
    StoreLinkHistory (Link, TRUE);
#endif
    Link->Flags = 0;                    // in the beginning, the link is closed.
    Link->DeferredFlags = 0;
    Link->State = LINK_STATE_ADM;       // async disconnected mode.

    Link->NdisSendsInProgress = 0;
    Link->ResendingPackets = FALSE;

    //
    // Initialize the counters
    //

    Link->FrmrsReceived = 0;
    Link->FrmrsTransmitted = 0;
    Link->ErrorIFramesReceived = 0;
    Link->ErrorIFramesTransmitted = 0;
    Link->AbortedTransmissions = 0;
    Link->BuffersNotAvailable = 0;
    Link->SuccessfulTransmits = 0;
    Link->SuccessfulReceives = 0;
    Link->T1Expirations = 0;
    Link->TiExpirations = 0;

#if DBG
    Link->CreatePacketFailures = 0;
#endif


    //
    // At first, the delay and throughput are unknown.
    //

    Link->Delay = 0xffffffff;
    Link->Throughput.HighPart = 0xffffffff;
    Link->Throughput.LowPart = 0xffffffff;
    Link->ThroughputAccurate = FALSE;
    Link->CurrentT1Backoff = FALSE;

    Link->OnDeferredRrQueue = FALSE;
    InitializeListHead (&Link->DeferredRrLinkage);


    //
    // Determine the maximum sized data frame that can be sent
    // on this link, based on the source routing information and
    // the size of the MAC header ("data frame" means the frame
    // without the MAC header). We don't assume the worst case
    // about source routing since we create a link in response
    // to a received frame, so if there is no source routing it
    // is because we are not going over a bridge. The exception
    // is if we are creating a link to a group name, in which
    // case we come back later and hack the MaxFrameSize in.
    //

    MacReturnMaxDataSize(
        &DeviceContext->MacInfo,
        SourceRouting,
        SourceRoutingLength,
        DeviceContext->CurSendPacketSize,
        FALSE,
        (PUINT)&(Link->MaxFrameSize));


#if DBG
    if (Link->MaxFrameSize > MaxUserPacketData) {
        Link->MaxFrameSize = MaxUserPacketData;
    }
#endif

    // Link->Provider = DeviceContext;

    //
    // Build the default MAC header. I-frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        Link->Header,
        HardwareAddress->Address,
        DeviceContext->LocalAddress.Address,
        0,                                 // PacketLength, filled in later
        ResponseSR,
        SourceRoutingLength,
        (PUINT)&(Link->HeaderLength));

    //
    // We optimize for fourteen-byte headers by putting
    // the correct Dsap/Ssap at the end, so we can fill
    // in new packets as one 16-byte move.
    //

    if (Link->HeaderLength <= 14) {
        Link->Header[Link->HeaderLength] = DSAP_NETBIOS_OVER_LLC;
        Link->Header[Link->HeaderLength+1] = DSAP_NETBIOS_OVER_LLC;
    }

    Link->RespondToPoll = FALSE;
    Link->NumberOfConnectors = 0;

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
    NbfResetLink (Link);
    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    Link->ActiveConnectionCount = 0;
    if (!IsListEmpty(&Link->ConnectionDatabase)) {

        //
        // Not good; we've got something left over...
        //
#if DBG
        NbfPrint1 ("NbfCreateLink: Link 0x%lx has connections at startup, disconnecting...\n", Link);
        DbgBreakPoint();
#endif
        //
        // This won't work, the link ref count will be bad.
        //
        NbfStopLink (Link);
    }

    for (i=0; i<(USHORT)DeviceContext->MacInfo.AddressLength; i++) {
        Link->HardwareAddress.Address[i] = HardwareAddress->Address[i];
    }
    MacReturnMagicAddress (&DeviceContext->MacInfo, HardwareAddress, &Link->MagicAddress);

    //
    // Determine if this is a loopback link.
    //

    if (RtlEqualMemory(
            HardwareAddress->Address,
            DeviceContext->LocalAddress.Address,
            DeviceContext->MacInfo.AddressLength)) {

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
        //
        // Yes, just fill it in, no need to do deferred processing
        // since this link does not go in the tree.
        //

        if (LoopbackLinkIndex == LISTENER_LINK) {
            Link->LoopbackDestinationIndex = LOOPBACK_TO_CONNECTOR;
        } else {
            Link->LoopbackDestinationIndex = LOOPBACK_TO_LISTENER;
        }

        Link->Loopback = TRUE;
        DeviceContext->LoopbackLinks[LoopbackLinkIndex] = Link;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
    } else {

        Link->Loopback = FALSE;

        //
        // Now put the link in the deferred operations queue and go away. We'll
        // insert this link in the tree at some future time (soon).
        //

        IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
            NbfPrint6 ("NbfCreateLink: link to deferred queue %lx %lx %lx %lx %lx Flags: %lx \n",
                Link, Link->DeferredList.Flink, Link->DeferredList.Blink,
                DeviceContext->LinkDeferred.Flink, DeviceContext->LinkDeferred.Blink,
                Link->Flags);
        }

        //
        // We should not have any deferred flags yet!
        //

        ASSERT ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_MASK) == 0);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) == 0) {
            Link->DeferredFlags |= LINK_FLAGS_DEFERRED_ADD;
            InsertTailList (&DeviceContext->LinkDeferred, &Link->DeferredList);

            if (!(DeviceContext->a.i.LinkDeferredActive)) {
                StartTimerLinkDeferredAdd++;
                NbfStartShortTimer (DeviceContext);
                DeviceContext->a.i.LinkDeferredActive = TRUE;
            }
        }
        else {
           Link->DeferredFlags = LINK_FLAGS_DEFERRED_ADD;
            if (!(DeviceContext->a.i.LinkDeferredActive)) {
                StartTimerLinkDeferredAdd++;
                NbfStartShortTimer (DeviceContext);
                DeviceContext->a.i.LinkDeferredActive = TRUE;
            }
        } 
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
            NbfPrint6 ("NbfCreateLink: link on deferred queue %lx %lx %lx %lx %lx Flags: %lx \n",
                Link, Link->DeferredList.Flink, Link->DeferredList.Blink,
                DeviceContext->LinkDeferred.Flink, DeviceContext->LinkDeferred.Blink,
                Link->DeferredFlags);
        }

    }

#if PKT_LOG
    RtlZeroMemory (&Link->LastNRecvs, sizeof(PKT_LOG_QUE));
    RtlZeroMemory (&Link->LastNSends, sizeof(PKT_LOG_QUE));
#endif // PKT_LOG

    NbfReferenceDeviceContext ("Create Link", DeviceContext, DCREF_LINK);   // count refs to the device context.
    *TransportLink = Link;              // return a pointer to the link object.
    return STATUS_SUCCESS;
} /* NbfCreateLink */


NTSTATUS
NbfDestroyLink(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine destroys a transport link and removes all references
    made to it by other objects in the transport.  The link is expected
    to still be on the splay tree of links. This routine merely marks the
    link as needing to be deleted and pushes it onto the deferred operations
    queue. The deferred operations processor actually removes the link from
    tree and returns the link to pool.

Arguments:

    TransportLink - Pointer to a transport link structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PTP_PACKET packet;
    PLIST_ENTRY pkt;
    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfDestroyLink:  Entered for link %lx.\n", TransportLink);
    }

#if DBG
    if (TransportLink->Destroyed) {
        NbfPrint1 ("attempt to destroy already-destroyed link 0x%lx\n", TransportLink);
        DbgBreakPoint ();
    }
    TransportLink->Destroyed = TRUE;
#if 1
    ACQUIRE_SPIN_LOCK (&NbfGlobalInterlock, &oldirql);
    RemoveEntryList (&TransportLink->GlobalLinkage);
    RELEASE_SPIN_LOCK (&NbfGlobalInterlock, oldirql);
#else
    ExInterlockedRemoveHeadList (TransportLink->GlobalLinkage.Blink, &NbfGlobalInterlock);
#endif
#endif

    DeviceContext = TransportLink->Provider;

    //
    // In case there's a holdover from the DISC link shutdown protocol
    //

    //
    // We had better be in ADM, otherwise the reference count should
    // be non-zero and what are we doing in NbfDestroyLink?
    //

    ASSERT(TransportLink->State == LINK_STATE_ADM);
    // TransportLink->State = LINK_STATE_ADM;

    StopT1 (TransportLink);
    StopT2 (TransportLink);
    StopTi (TransportLink);


    //
    // Make sure we are not in the deferred timer queue.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->TimerSpinLock, &oldirql);

    if (TransportLink->OnShortList) {
        TransportLink->OnShortList = FALSE;
        RemoveEntryList (&TransportLink->ShortList);
    }

    if (TransportLink->OnLongList) {
        TransportLink->OnLongList = FALSE;
        RemoveEntryList (&TransportLink->LongList);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->TimerSpinLock, oldirql);

    ASSERT (!TransportLink->OnDeferredRrQueue);

    //
    // Now free this link object's resources.
    // later, we'll spin through the WackQ and verify that sequencing
    // is correct and we've gotten an implicit ack for these packets. This
    // maybe should be handled in ResendLlcPackets for non-final, non-command
    // packets.
    //

    while (!IsListEmpty (&TransportLink->WackQ)) {
        pkt = RemoveHeadList (&TransportLink->WackQ);
        packet = CONTAINING_RECORD (pkt, TP_PACKET, Linkage);
#if DBG
        // IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
            NbfPrint1 ("NbfDereferenceLink: Destroying packets on Link WackQ! %lx\n", packet);
        // }
#endif
        NbfDereferencePacket (packet);

    }

    //
    // The NDIS send queue should be empty!!
    //

    ASSERT (IsListEmpty (&TransportLink->NdisSendQueue));

#if DBG
    if (!IsListEmpty (&TransportLink->ConnectionDatabase)) {
        NbfPrint1 ("NbfDestroyLink: link 0x%lx still has connections\n", TransportLink);
        DbgBreakPoint ();
    }
#endif

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    DeviceContext->LinkTotal += DeviceContext->LinkInUse;
    ++DeviceContext->LinkSamples;
    ASSERT(DeviceContext->LinkInUse > 0);
    --DeviceContext->LinkInUse;

    ASSERT(DeviceContext->LinkAllocated > DeviceContext->LinkInUse);

    if ((DeviceContext->LinkAllocated - DeviceContext->LinkInUse) >
            DeviceContext->LinkInitAllocated) {
        NbfDeallocateLink (DeviceContext, TransportLink);
        IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
            NbfPrint1 ("NBF: Deallocated link at %lx\n", TransportLink);
        }
    } else {
        InsertTailList (&DeviceContext->LinkPool, &TransportLink->Linkage);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    NbfDereferenceDeviceContext ("Destroy Link", DeviceContext, DCREF_LINK);  // just housekeeping.

    return STATUS_SUCCESS;

} /* NbfDestroyLink */


VOID
NbfDisconnectLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine calls the data link provider to disconnect a data link
    connection associated with a TP_LINK object.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    KIRQL oldirql;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfDisconnectLink:  Entered for link %lx.\n", Link);
    }

    ACQUIRE_SPIN_LOCK (&Link->SpinLock, &oldirql);

    if ((Link->Flags & LINK_FLAGS_LOCAL_DISC) != 0) {

        Link->Flags &= ~LINK_FLAGS_LOCAL_DISC;

        if (Link->State == LINK_STATE_ADM) {

            RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);

        } else {

            PLIST_ENTRY p;
            PTP_PACKET packet;

            Link->State = LINK_STATE_W_DISC_RSP;        // we are awaiting a DISC/f.
            Link->SendState = SEND_STATE_DOWN;
            Link->ReceiveState = RECEIVE_STATE_DOWN;
            StopT1 (Link);
            StopT2 (Link);
            StopTi (Link);

            //
            // check for left over packets on the link WackQ; we'll never get
            // acked for these if the link is in W_DISC_RSP.
            //

            while (!IsListEmpty (&Link->WackQ)) {
                p = RemoveHeadList (&Link->WackQ);
                RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);
                packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
                NbfDereferencePacket (packet);
                ACQUIRE_SPIN_LOCK (&Link->SpinLock, &oldirql);
            }

            Link->SendRetries = (UCHAR)Link->LlcRetries;
            StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
            RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);
            NbfSendDisc (Link, TRUE);            // send DISC-c/p.

        }

    } else {

        RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);

    }

} /* NbfDisconnectLink */

#if DBG

VOID
NbfRefLink(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine increments the reference count on a transport link. If we are
    currently in the state waiting for disconnect response, we do not
    reference; this avoids the link "bouncing" during disconnect (trying to
    disconnect multiple times).

Arguments:

    TransportLink - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint2 ("NbfReferenceLink:  Entered for link %lx, current level=%ld.\n",
                  TransportLink, TransportLink->ReferenceCount);
    }

#if DBG
    StoreLinkHistory( TransportLink, TRUE );
#endif

    result = InterlockedIncrement (&TransportLink->ReferenceCount);

    if (result == 0) {

        //
        // The first increment causes us to increment the
        // "ref count is not zero" special ref.
        //

        NbfReferenceLinkSpecial ("first ref", TransportLink, LREF_SPECIAL_TEMP);

    }

    ASSERT (result >= 0);

} /* NbfRefLink */
#endif


VOID
NbfDerefLink(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine dereferences a transport link by decrementing the
    reference count contained in the structure.

    There are two special reference counts, 1 and 0.  If, after dereferencing,
    the reference count is one (1), then we initiate a disconnect protocol
    sequence (DISC/UA) to terminate the connection.  When this request
    completes, the completion routine will dereference the link object again.
    While this protocol is in progress, we will not allow the link to be
    incremented again.

    If the reference count becomes 0 after dereferencing, then we are in
    the disconnection request completion handler, and we should actually
    destroy the link object.  We place the link on the deferred operations
    queue and let the link get deleted later at a safe time.

    Warning:  Watch out for cases where a link is going down, and it is
    suddenly needed again.  Keep a bitflag for that in the link object.

Arguments:

    TransportLink - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint2 ("NbfDereferenceLink:  Entered for link %lx, current level=%ld.\n",
                  TransportLink, TransportLink->ReferenceCount);
    }

#if DBG
    StoreLinkHistory( TransportLink, FALSE );
#endif

    result = InterlockedDecrement(&TransportLink->ReferenceCount);

    //
    // If all the normal references to this link are gone, then
    // we can remove the special reference that stood for
    // "the regular ref count is non-zero".
    //


    if (result < 0) {

        //
        // If the refcount is -1 we want to call DisconnectLink,
        // we do this before removing the special ref so that
        // the link does not go away during the call.
        //

        IF_NBFDBG (NBF_DEBUG_LINK) {
            NbfPrint0 ("NbfDereferenceLink: refcnt=1, disconnecting Link object.\n");
        }

        NbfDisconnectLink (TransportLink);

        //
        // Now it is OK to let the link go away.
        //

        NbfDereferenceLinkSpecial ("Regular ref 0", TransportLink, LREF_SPECIAL_TEMP);

    }

} /* NbfDerefLink */


VOID
NbfRefLinkSpecial(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine increments the special reference count on a transport link.

Arguments:

    TransportLink - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    ULONG result;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint3 ("NbfRefLinkSpecial:  Entered for link %lx, current level=%ld (%ld).\n",
                  TransportLink, TransportLink->ReferenceCount, TransportLink->SpecialRefCount);
    }

#if DBG
    StoreLinkHistory( TransportLink, TRUE );
#endif

    result = ExInterlockedAddUlong (
                 (PULONG)&TransportLink->SpecialRefCount,
                 1,
                 TransportLink->ProviderInterlock);

} /* NbfRefLinkSpecial */


VOID
NbfDerefLinkSpecial(
    IN PTP_LINK TransportLink
    )

/*++

Routine Description:

    This routine dereferences a transport link by decrementing the
    special reference count contained in the structure.

    The special reference may be decremented at any time, however
    the effect of those dereferences only happen when the normal
    reference count is 0, to prevent the link from going away
    while the operations due to the ->0 transition of the
    normal reference count are done.

    If the special reference count becomes 0 after dereferencing, then we
    are in the disconnection request completion handler, and we should actually
    destroy the link object.  We place the link on the deferred operations
    queue and let the link get deleted later at a safe time.

    Warning:  Watch out for cases where a link is going down, and it is
    suddenly needed again.  Keep a bitflag for that in the link object.

Arguments:

    TransportLink - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    KIRQL oldirql, oldirql1;
    ULONG OldRefCount;
    PDEVICE_CONTEXT DeviceContext = TransportLink->Provider;


    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint3 ("NbfDerefLinkSpecial:  Entered for link %lx, current level=%ld (%ld).\n",
                  TransportLink, TransportLink->ReferenceCount, TransportLink->SpecialRefCount);
    }

#if DBG
    StoreLinkHistory( TransportLink, FALSE );
#endif

    //
    // Links stay in the device context tree with a ref count
    // of 0. Routines that scan this queue check the DEFERRED_DELETE
    // flag, so we need to synchronize the decrementing of the
    // ref count with setting that flag. DeviceContext->LinkSpinLock
    // is used to synchronize this.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->LinkSpinLock, &oldirql1);

    OldRefCount = ExInterlockedAddUlong (
                      (PULONG)&TransportLink->SpecialRefCount,
                      (ULONG)-1,
                      TransportLink->ProviderInterlock);

    ASSERT (OldRefCount > 0);

    if ((OldRefCount == 1) &&
        (TransportLink->ReferenceCount == -1)) {

        if (TransportLink->Loopback) {

            //
            // It is a loopback link, hence not in the link
            // tree so we don't need to queue a deferred removal.
            //

            if (TransportLink == DeviceContext->LoopbackLinks[0]) {
                DeviceContext->LoopbackLinks[0] = NULL;
            } else if (TransportLink == DeviceContext->LoopbackLinks[1]) {
                DeviceContext->LoopbackLinks[1] = NULL;
            } else {
#if DBG
                NbfPrint0("Destroying unknown loopback link!!\n");
#endif
                ASSERT(FALSE);
            }

            NbfDestroyLink (TransportLink);
            RELEASE_SPIN_LOCK (&DeviceContext->LinkSpinLock, oldirql1);

        } else {

            //
            // Not only are all transport connections gone, but the data link
            // provider does not have a reference to this object, so we can
            // safely delete it from the system. Make sure we haven't already
            // been here before we try to insert this link.
            //

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint6 ("NbfDerefLink: link to deferred queue %lx %lx %lx %lx %lx Flags: %lx \n",
                    TransportLink, TransportLink->DeferredList.Flink,
                    TransportLink->DeferredList.Blink, DeviceContext->LinkDeferred.Flink,
                    DeviceContext->LinkDeferred.Blink, TransportLink->Flags);
            }

            ACQUIRE_SPIN_LOCK (&DeviceContext->TimerSpinLock, &oldirql);
            if ((TransportLink->DeferredFlags & LINK_FLAGS_DEFERRED_MASK) == 0) {

                TransportLink->DeferredFlags |= LINK_FLAGS_DEFERRED_DELETE;

                InsertTailList (&DeviceContext->LinkDeferred, &TransportLink->DeferredList);
                if (!(DeviceContext->a.i.LinkDeferredActive)) {
                    StartTimerLinkDeferredDelete++;
                    NbfStartShortTimer (DeviceContext);
                    DeviceContext->a.i.LinkDeferredActive = TRUE;
                }

            } else {

                TransportLink->DeferredFlags |= LINK_FLAGS_DEFERRED_DELETE;

            }

            RELEASE_SPIN_LOCK (&DeviceContext->TimerSpinLock, oldirql);
            RELEASE_SPIN_LOCK (&DeviceContext->LinkSpinLock, oldirql1);

            IF_NBFDBG (NBF_DEBUG_LINK) {
                NbfPrint0 ("NbfDereferenceLink: refcnt=0, link placed on deferred operations queue.\n");
            }

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint6 ("NbfDerefLink: link on deferred queue %lx %lx %lx %lx %lx Flags: %lx \n",
                    TransportLink, TransportLink->DeferredList.Flink,
                    TransportLink->DeferredList.Blink, DeviceContext->LinkDeferred.Flink,
                    DeviceContext->LinkDeferred.Blink, TransportLink->DeferredFlags);
            }

        }

    } else {

        RELEASE_SPIN_LOCK (&DeviceContext->LinkSpinLock, oldirql1);

    }

} /* NbfDerefLinkSpecial */


NTSTATUS
NbfAssignGroupLsn(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine is called to assign a global LSN to the connection
    in question. If successful, it fills in the connection's LSN
    appropriately.

Arguments:

    TransportConnection - Pointer to a transport connection object.

Return Value:

    STATUS_SUCCESS if we got an LSN for the connection;
    STATUS_INSUFFICIENT_RESOURCES if we didn't.

--*/

{
    KIRQL oldirql;
    UCHAR Lsn;
    PDEVICE_CONTEXT DeviceContext;
    BOOLEAN FoundLsn = FALSE;

    DeviceContext = TransportConnection->Provider;

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    //
    // Scan through the device context tables to find an LSN that
    // is not in use, starting with NextLsnStart+128.
    //

    Lsn = (UCHAR)DeviceContext->NextLsnStart;

    do {

        if (DeviceContext->LsnTable[Lsn] == 0) {
            DeviceContext->LsnTable[Lsn] = LSN_TABLE_MAX;
            FoundLsn = TRUE;
            break;
        }

        Lsn = (Lsn % NETBIOS_SESSION_LIMIT) + 1;

    } while (Lsn != DeviceContext->NextLsnStart);

    DeviceContext->NextLsnStart = (DeviceContext->NextLsnStart % 64) + 1;

    if (!FoundLsn) {

        //
        // Could not find an empty LSN; have to fail.
        //

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    TransportConnection->Lsn = Lsn;

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
    return STATUS_SUCCESS;

}


NTSTATUS
NbfConnectToLink(
    IN PTP_LINK Link,
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine is called to establish a linkage between a transport
    connection and a transport link.  We find a session number in one
    of two ways. If the last connection on the link's list has a number less
    than the maximum session number, we simply increment it's number and
    assign it to this session. If that doesn't work, we scan through the
    sessions associated with this link until we find a hole in the LSNs;
    we then use the first number in that hole. If that fails, we've used
    the number of sessions we can create on this link and we fail.

    It is assumed that the caller holds at least temporary references
    on both the connection and link objects, or they could go away during
    the call sequence or during this routine's execution.

Arguments:

    Link - Pointer to a transport link object.

    TransportConnection - Pointer to a transport connection object.

Return Value:

    STATUS_SUCCESS if we got an LSN for the connection;
    STATUS_INSUFFICIENT_RESOURCES if we didn't.

--*/

{
    KIRQL oldirql;
    UCHAR lastSession=0;
    PTP_CONNECTION connection;
    PLIST_ENTRY p;
    PDEVICE_CONTEXT DeviceContext;
    UCHAR Lsn;
    BOOLEAN FoundLsn;

    //
    // Assign an LSN for a new connection. If this connection makes for more
    // connections than the maximum, blow off the creation.
    //

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint2 ("NbfConnectToLink:  Entered for connection %lx, link %lx.\n",
                    TransportConnection, Link);
    }

    DeviceContext = Link->Provider;

    ACQUIRE_SPIN_LOCK (&Link->SpinLock, &oldirql);
#if DBG
    if (!(IsListEmpty(&TransportConnection->LinkList)) ||
        (TransportConnection->Link != NULL)) {
        DbgPrint ("Connecting C %lx to L %lx, appears to be in use\n", TransportConnection, Link);
        DbgBreakPoint();
    }
#endif

    if ((TransportConnection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) == 0) {

        //
        // This connection is to a remote unique name, which means
        // we need to assign the LSN here based on the link. We
        // scan through our LSN table starting with NextLsnStart
        // (which cycles from 1 to 64) to find an LSN which is not
        // used by any connections on this link.
        //

        ASSERT (TransportConnection->Lsn == 0);

        FoundLsn = FALSE;
        Lsn = (UCHAR)DeviceContext->NextLsnStart;

        //
        // First scan through the database until we reach
        // Lsn (or hit the end of the database).
        //

        for (p = Link->ConnectionDatabase.Flink;
            p != &Link->ConnectionDatabase;
            p = p->Flink) {

            connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
            if (connection->Lsn >= Lsn) {
                break;
            }
        }

        //
        // p now points to the first element after Lsn's spot.
        // We now scan forwards until we hit NETBIOS_SESSION_LIMIT,
        // looking for an Lsn that is available.
        //

        for ( ; Lsn <= NETBIOS_SESSION_LIMIT; ++Lsn) {

            //
            // At some point (perhaps right away) we may
            // pass the end of the database without finding
            // an LSN. If we have not yet done this, see
            // if we need to skip this lsn because it is
            // in use by a connection on this link.
            //

            if (p != &Link->ConnectionDatabase) {
                if (connection->Lsn == Lsn) {
                    p = p->Flink;
                    if (p != &Link->ConnectionDatabase) {
                        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
                    }
                    continue;
                }
            }

            //
            // This lsn is not in use on this link, see if
            // there is room for it to be used.
            //

            if (DeviceContext->LsnTable[Lsn] < LSN_TABLE_MAX) {
                ++(DeviceContext->LsnTable[Lsn]);
                TransportConnection->Lsn = Lsn;
                InsertTailList (p, &TransportConnection->LinkList);
                FoundLsn = TRUE;
                break;
            }

        }

        DeviceContext->NextLsnStart = (DeviceContext->NextLsnStart % 64) + 1;

    } else {

        //
        // This connection is to a group name; we already assigned
        // the LSN on a global basis.
        //

        FoundLsn = TRUE;

        //
        // Find the spot for this LSN in the database.
        //

        p = Link->ConnectionDatabase.Flink;
        while (p != &Link->ConnectionDatabase) {

            connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
            if (TransportConnection->Lsn < connection->Lsn) {
                InsertTailList (p, &TransportConnection->LinkList);
                break;
            }
            p = p->Flink;

        }

        if (p == &Link->ConnectionDatabase) {
            InsertTailList (&Link->ConnectionDatabase, &TransportConnection->LinkList);
        }

    }

    if (!FoundLsn) {

        ULONG DumpData = NETBIOS_SESSION_LIMIT;

        ASSERT (Link->ActiveConnectionCount == NETBIOS_SESSION_LIMIT);

        RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);

        PANIC ("NbfConnectToLink: PANIC! too many active connections!\n");

        NbfWriteGeneralErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_TOO_MANY_LINKS,
            602,
            STATUS_INSUFFICIENT_RESOURCES,
            NULL,
            1,
            &DumpData);

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    TransportConnection->Link = Link;
    TransportConnection->LinkSpinLock = &Link->SpinLock;
    TransportConnection->Flags |= CONNECTION_FLAGS_WAIT_LINK_UP;

    TransportConnection->LastPacketsSent = Link->PacketsSent;
    TransportConnection->LastPacketsResent = Link->PacketsResent;

    Link->ActiveConnectionCount++;

    //
    // Note that the connection is already inserted in the
    // link's ConnectionDatabase.
    //

    // This reference is removed in NbfDisconnectFromLink
    NbfReferenceConnection("Adding link", TransportConnection, CREF_LINK);

    RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql);

    return STATUS_SUCCESS;              // we did it!

} /* NbfConnectToLink */


BOOLEAN
NbfDisconnectFromLink(
    IN PTP_CONNECTION TransportConnection,
    IN BOOLEAN VerifyReferenceCount
    )

/*++

Routine Description:

    This routine is called to terminate a linkage between a transport
    connection and its associated transport link.  If it turns out that
    this is the last connection to be removed from this link, then the
    link's disconnection protocol is engaged.

Arguments:

    TransportConnection - Pointer to a transport connection object.

    VerifyReferenceCount - TRUE if we should check that the refcount
        is still -1 before removing the connection from the link.
        If it is not, it means someone just referenced us and we
        exit.

Return Value:

    FALSE if VerifyReferenceCount was TRUE but the refcount was
        not -1; TRUE otherwise.


--*/

{
    KIRQL oldirql, oldirql1;
    PTP_LINK Link;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint2 ("NbfDisconnectFromLink:  Entered for connection %lx, link %lx.\n",
                    TransportConnection, TransportConnection->Link);
    }

    ACQUIRE_C_SPIN_LOCK (&TransportConnection->SpinLock, &oldirql);
    Link  = TransportConnection->Link;
    if (Link != NULL) {

        ACQUIRE_SPIN_LOCK (&Link->SpinLock, &oldirql1);

        if ((VerifyReferenceCount) &&
            (TransportConnection->ReferenceCount != -1)) {

            RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql1);
            RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);
            return FALSE;

        }

        TransportConnection->Link = NULL;
        TransportConnection->LinkSpinLock = NULL;
        RemoveEntryList (&TransportConnection->LinkList);
#if DBG
        InitializeListHead (&TransportConnection->LinkList);
#endif

        //
        // If this was the last connection being serviced by this link,
        // then we can shut the link down.  It still has a reference
        // from the device context, which will go away in the DM/UA
        // DLC frame handler.
        //

        if (--Link->ActiveConnectionCount == 0) {

            //
            // only want to send DISC if the remote was NOT the originator
            // of the disconnect.
            //

            if ((TransportConnection->Status == STATUS_LOCAL_DISCONNECT) ||
                (TransportConnection->Status == STATUS_CANCELLED)) {

                //
                // This is a local disconnect of the last connection
                // on the link, let's get the disconnect ball rolling.
                //

                Link->Flags |= LINK_FLAGS_LOCAL_DISC;

                //
                // When the link reference count drops down to 1,
                // that will cause the DISC to get sent.
                //

            }

        }

        RELEASE_SPIN_LOCK (&Link->SpinLock, oldirql1);

        //
        // Clear these now that we are off the link's database.
        //

        NbfClearConnectionLsn (TransportConnection);
        TransportConnection->Rsn = 0;

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);

        if ((TransportConnection->Flags2 & CONNECTION_FLAGS2_CONNECTOR) != 0) {

            (VOID)InterlockedDecrement(&Link->NumberOfConnectors);
        }

        //
        // All done with this connection's reference to link.
        //

        NbfDereferenceLink ("Disconnecting connection",Link, LREF_CONNECTION);

    } else {

        //
        // A group LSN may have been assigned even though Link is NULL.
        //

        if ((TransportConnection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) != 0) {
            NbfClearConnectionLsn (TransportConnection);
        }

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);

    }

    return TRUE;

} /* NbfDisconnectFromLink */


PTP_CONNECTION
NbfLookupPendingListenOnLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine scans the LSN database on a transport link object to find
    a TP_CONNECTION object which has the CONNECTION_FLAGS_WAIT_LINK_UP and
    CONNECTION_FLAGS2_LISTENER flags set.  It returns a pointer to the found
    connection object (and simultaneously resets the LINK_UP flag) or NULL
    if it could not be found.  The reference count is also incremented
    atomically on the connection.

    NOTE: THIS ROUTINE MUST BE CALLED FROM DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_CONNECTION connection;
    PLIST_ENTRY p;

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    for (p = Link->ConnectionDatabase.Flink;
         p != &Link->ConnectionDatabase;
         p = p->Flink) {
        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
        if ((connection->Flags & CONNECTION_FLAGS_WAIT_LINK_UP) &&
            (connection->Flags2 & CONNECTION_FLAGS2_LISTENER) &&
            ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0)) {
            // This reference is removed by the calling function
            NbfReferenceConnection ("Found Pending Listen", connection, CREF_P_LINK);
            connection->Flags &= ~CONNECTION_FLAGS_WAIT_LINK_UP;
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            return connection;
        }
    }

    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    return NULL;

} /* NbfLookupPendingListenOnLink */


PTP_CONNECTION
NbfLookupPendingConnectOnLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine scans the LSN database on a transport link object to find
    a TP_CONNECTION object which has the CONNECTION_FLAGS_WAIT_LINK_UP and
    CONNECTION_FLAGS2_CONNECTOR flags set.  It returns a pointer to the found
    connection object (and simultaneously resets the LINK_UP flag) or NULL
    if it could not be found.  The reference count is also incremented
    atomically on the connection.

    NOTE: THIS ROUTINE MUST BE CALLED FROM DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_CONNECTION connection;
    PLIST_ENTRY p;

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    for (p = Link->ConnectionDatabase.Flink;
         p != &Link->ConnectionDatabase;
         p = p->Flink) {
        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
        if ((connection->Flags & CONNECTION_FLAGS_WAIT_LINK_UP) &&
            (connection->Flags2 & CONNECTION_FLAGS2_CONNECTOR) &&
            ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0)) {
            // This reference is removed by the calling function
            NbfReferenceConnection ("Found pending Connect", connection, CREF_P_CONNECT);
            connection->Flags &= ~CONNECTION_FLAGS_WAIT_LINK_UP;
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            return connection;
        }
    }

    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    return NULL;

} /* NbfLookupPendingConnectOnLink */


VOID
NbfActivateLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine activates a link if it is not already active.  The other
    related routines, NbfCreateLink and NbfConnectToLink, simply set up data
    structures which represent active links so that we can reuse links
    wherever possible.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfActivateLink:  Entered for link %lx.\n", Link);
    }

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    switch (Link->State) {
        case LINK_STATE_READY:
            NbfCompleteLink (Link);
            break;

        case LINK_STATE_ADM:

            // Moving out of ADM, add reference

            NbfReferenceLinkSpecial("Wait on ADM", Link, LREF_NOT_ADM);

            //
            // Intentionally fall through to the next case.
            //

        case LINK_STATE_W_DISC_RSP:
        case LINK_STATE_CONNECTING:
            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            Link->State = LINK_STATE_CONNECTING;
            Link->SendState = SEND_STATE_DOWN;
            Link->ReceiveState = RECEIVE_STATE_DOWN;
            Link->SendRetries = (UCHAR)Link->LlcRetries;
            NbfSendSabme (Link, TRUE);   // send SABME/p, StartT1, release lock
            break;

    }
} /* NbfActivateLink */


VOID
NbfWaitLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine waits for a remote link activation if it is not already
    active.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfWaitLink:  Entered for link %lx.\n", Link);
    }

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    switch (Link->State) {
    case LINK_STATE_READY:
            NbfCompleteLink (Link);
            break;

        case LINK_STATE_W_DISC_RSP:
            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            Link->State = LINK_STATE_CONNECTING;
            Link->SendState = SEND_STATE_DOWN;
            Link->ReceiveState = RECEIVE_STATE_DOWN;
            NbfSendSabme (Link, TRUE);  // send SABME/p, StartT1, release lock
            break;

    }
} /* NbfWaitLink */


VOID
NbfStopLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine terminates a link and all outstanding connections attached
    to the link.  It is called from routines such as ExpireT2Timer, because
    the remote connection partner seems dead or inoperative. As a consequence
    of this routine being called, every outstanding connection will have its
    disconnect handler called (in NbfStopConnection).

    NOTE: THIS ROUTINE MUST BE CALLED FROM DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p;
    PTP_PACKET packet;
    PTP_CONNECTION connection;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfStopLink:  Entered for link %lx.\n", Link);
    }

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    // Take a reference so the link won't go away inside this function

    NbfReferenceLink("Temp in NbfStopLink", Link, LREF_STOPPING);


    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    StopT1 (Link);
    StopT2 (Link);
    StopTi (Link);

    p = RemoveHeadList (&Link->ConnectionDatabase);

    while (p != &Link->ConnectionDatabase) {

        //
        // This will allow this connection to be "removed"
        // from its link's list in NbfDisconnectFromLink, even if
        // its not on a list.
        //
        InitializeListHead (p);

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
        IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
            NbfPrint1 ("NbfStopLink stopping connection, refcnt=%ld",
                        connection->ReferenceCount);
        }
#if DBG
        if (NbfDisconnectDebug) {
            STRING remoteName, localName;
            remoteName.Length = NETBIOS_NAME_LENGTH - 1;
            remoteName.Buffer = connection->RemoteName;
            localName.Length = NETBIOS_NAME_LENGTH - 1;
            localName.Buffer = connection->AddressFile->Address->NetworkName->NetbiosName;
            NbfPrint2( "TpStopLink stopping connection to %S from %S\n",
                &remoteName, &localName );
        }
#endif
        NbfStopConnection (connection, STATUS_LINK_FAILED);
        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
        p = RemoveHeadList (&Link->ConnectionDatabase);
    }

    //
    // We hold the link spinlock here.
    //

    //
    // check for left over packets on the link WackQ; we'll never get
    // acked for these if the link is in ADM mode.
    //

    while (!IsListEmpty (&Link->WackQ)) {
        p = RemoveHeadList (&Link->WackQ);
        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
        NbfDereferencePacket (packet);
        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
    }

    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    StopT1 (Link);
    StopT2 (Link);
    StopTi (Link);


    //
    // Make sure we are not waiting for a deferred RR to be sent.
    //

    if (Link->OnDeferredRrQueue) {

        ACQUIRE_DPC_SPIN_LOCK (Link->ProviderInterlock);
        if (Link->OnDeferredRrQueue) {
            RemoveEntryList (&Link->DeferredRrLinkage);
            Link->OnDeferredRrQueue = FALSE;
        }
        RELEASE_DPC_SPIN_LOCK (Link->ProviderInterlock);

    }

    // Remove the temporary reference.

    NbfDereferenceLink ("Temp in NbfStopLink", Link, LREF_STOPPING);


} /* NbfStopLink */


VOID
NbfResetLink(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called by DLC.C routines only to reset this link
    object and restart in-progress transport data transfers.

    NOTE: This routine is called with the link spinlock acquired
    at *OldIrqlP, and will return with it held, although it may
    release it in the interim.

Arguments:

    Link - Pointer to a transport link object.

    OldIrqlP - Pointer to where the IRQL at which Link->SpinLock
    was acquired is stored.

Return Value:

    none.

--*/

{
    PTP_PACKET packet;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_LINK) {
        NbfPrint1 ("NbfResetLink:  Entered for link %lx.\n", Link);
    }

    //
    // Reset the link state to waiting for connection to start.
    // Note that this is NOT the same as initiating a new link, as some things
    // don't change, such as provider (devicecontext binding stays the same),
    // Max Packet Length (can't change if provider doesn't), and other things
    // that would bind this link structure to a different provider or provider
    // type. Note also that we acquire the spinlock because, in the case of a
    // link that's dropped (remotely) and is restarting, activities on this
    // link could be occurring while we're in this routine.
    //

    StopT1 (Link);
    StopT2 (Link);
    // StopTi (Link);
    Link->Flags = 0;                    // clear this, keep DeferredFlags

    Link->SendState = SEND_STATE_DOWN;  // send side is down.
    Link->NextSend = 0;
    Link->LastAckReceived = 0;
    if (Link->Provider->MacInfo.MediumAsync) {
        Link->SendWindowSize = (UCHAR)Link->Provider->RecommendedSendWindow;
        Link->PrevWindowSize = (UCHAR)Link->Provider->RecommendedSendWindow;
    } else {
        Link->SendWindowSize = (UCHAR)1;
        Link->PrevWindowSize = (UCHAR)1;
    }
    Link->WindowsUntilIncrease = 1;
    Link->LinkBusy = FALSE;
    Link->ConsecutiveLastPacketLost = 0;

    //
    // check for left over packets on the link WackQ; we'll never get
    // acked for these if the link is resetting.
    //

    while (!IsListEmpty (&Link->WackQ)) {
        p = RemoveHeadList (&Link->WackQ);
        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
        NbfDereferencePacket (packet);
        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
    }

    Link->ReceiveState = RECEIVE_STATE_DOWN;    // receive side down.
    Link->NextReceive = 0;
    Link->LastAckSent = 0;
    Link->ReceiveWindowSize = 1;

    Link->WindowErrors = 0;
    Link->BestWindowSize = 1;
    Link->WorstWindowSize = (UCHAR)Link->MaxWindowSize;
    Link->Flags |= LINK_FLAGS_JUMP_START;

    //
    // This must be accurate before we set up timeouts.
    //

    Link->CurrentT1Timeout = Link->Provider->DefaultT1Timeout;
    Link->BaseT1Timeout = Link->Provider->DefaultT1Timeout << DLC_TIMER_ACCURACY;
    Link->MinimumBaseT1Timeout = Link->Provider->MinimumT1Timeout << DLC_TIMER_ACCURACY;
    Link->BaseT1RecalcThreshhold = Link->MaxFrameSize / 2;
    Link->CurrentPollRetransmits = 0;
    Link->CurrentT1Backoff = FALSE;
    Link->CurrentPollOutstanding = FALSE;
    Link->RemoteNoPoll = TRUE;
    Link->ConsecutiveIFrames = 0;
    Link->T2Timeout = Link->Provider->DefaultT2Timeout;
    Link->TiTimeout = Link->Provider->DefaultTiTimeout;
    Link->LlcRetries = Link->Provider->LlcRetries;
    Link->MaxWindowSize = Link->Provider->LlcMaxWindowSize;

    Link->SendRetries = (UCHAR)Link->LlcRetries;

} /* NbfResetLink */


VOID
NbfDumpLinkInfo (
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when any of the link timers fire and the
    link send state is not ready. This gives us a way to track the
    link state when strange things are happening.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    none.

--*/
{
    Link;  // avoid compiler warnings in non-debug versions

#if DBG
    NbfPrint4 ("NbfDumpLinkInfo: Link %lx : State: %x SendState: %x ReceiveState: %x\n",
                Link, Link->State, Link->SendState, Link->ReceiveState);
    NbfPrint1 ("                Flags: %lx\n",Link->Flags);
    NbfPrint4 ("                NextReceive: %d LastAckRcvd: %d  NextSend: %d LastAckSent: %d\n",
                Link->NextReceive, Link->LastAckReceived, Link->NextSend, Link->LastAckSent);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\linktree.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    linktree.c

Abstract:

    This module contains code which implements the management of the link
    splay tree. This splay tree is maintained to minimize the lookup time
    needed with each individual packet that comes in. To this end, we create a
    ULARGE_INTEGER that contains the transport address of the remote and
    do a ULARGE_INTEGER comaprison of the addresses (rather than comparing
    the bytes 1 by 1). Assuming that the ULARGE_INTEGER comparison routines are
    optimized for the hardware on the machine, this should be as fast as or
    faster than comparing bytes.

    DEBUG: there is currently code in the comparison routines that will let
           me fine-tune the search and ordering algorithm as we gain more
           experience with it.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NbfAddLinkToTree(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine adds a link to the tree of links maintained for this device.
    Note that since this routine needs to modify the link tree, it is called
    in the context of a deferred processing routine, and must have exclusive
    access to the tree. The spinlock is taken by the routine that calls this
    one, as this operation must be atomic in the eyes of the rest of NBF.
    Note further that this routine insists that there not be a link with this
    address in the tree.

    As the final operation of this insertion, the splay tree is balanced.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    STATUS_SUCCESS if the link is successfully added,
    STATUS_DRIVER_INTERNAL_ERROR if there was a problem adding
        the link (implying the tree was in a bad state).

--*/
{
    PTP_LINK treeLink;
    PRTL_SPLAY_LINKS linkLink;

    //
    // initialize the link and check for the trivial case.
    //

    RtlInitializeSplayLinks (Link);
    linkLink = DeviceContext->LinkTreeRoot;
    if (linkLink == NULL) { // null tree, make this the parent
        DeviceContext->LinkTreeRoot = (PRTL_SPLAY_LINKS)Link;
        DeviceContext->LinkTreeElements++;
        DeviceContext->LastLink = Link;
        return STATUS_SUCCESS;
    }

    //
    // Wasn't a null tree, so set up for the addition
    //

    treeLink = (PTP_LINK) linkLink;

    IF_NBFDBG(NBF_DEBUG_LINKTREE) {
        NbfPrint1 ("NbfAddLinkToTree: starting insert, Elements: %ld \n",DeviceContext->LinkTreeElements);
    }

    //
    // find the proper spot to put this link.
    //

    do {
        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
            NbfPrint3 ("NbfAddLinkToTree: searching, Link: %lx LC: %lx RC: %lx\n",
                linkLink, RtlLeftChild (linkLink), RtlRightChild (linkLink));
        }

        //
        // Bad news == means we already have this link, someone is messed up.
        // it's possible to be adding and deleting things at the same time;
        // that's
        //

        if ((treeLink->MagicAddress).QuadPart == (Link->MagicAddress).QuadPart) {

            //
            // First make sure we don't have the splay tree in a loop.
            //

            ASSERT (treeLink != Link);

            //
            // This link is already in the tree. This is OK if it is
            // due to be deleted; we can just do the delete right now,
            // since AddLinkToTree is only called from the deferred
            // timer routine.
            //

            if (treeLink->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) {

                //
                // It will be in the deferred list. We remove it,
                // we don't worry about LinkDeferredActive since
                // the timeout routine that is calling us handles
                // that.
                //

                RemoveEntryList (&treeLink->DeferredList);

                treeLink->DeferredFlags &= ~LINK_FLAGS_DEFERRED_DELETE;
                NbfRemoveLinkFromTree (DeviceContext, treeLink);
                NbfDestroyLink (treeLink);

#if DBG
                NbfPrint2 ("NbfAddLinkToTree: Link %lx removed for %lx\n",
                        treeLink, Link);
#endif

                //
                // Now that that link is out of the tree, call
                // ourselves recursively to do the insert.
                //

                return NbfAddLinkToTree (DeviceContext, Link);

            } else {

                ASSERTMSG ("NbfAddLinkToTree: Found identical Link in tree!\n", FALSE);
                return STATUS_DRIVER_INTERNAL_ERROR;

            }

        }

        //
        // traverse the tree for the correct spot
        //

        if ((Link->MagicAddress).QuadPart < (treeLink->MagicAddress).QuadPart) {
            if ((linkLink = RtlLeftChild (linkLink)) == NULL) {
                IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                    NbfPrint0 ("NbfAddLinkToTree: Adding link as LC.\n");
                }
                RtlInsertAsLeftChild ((PRTL_SPLAY_LINKS)treeLink,
                                       (PRTL_SPLAY_LINKS)Link);
                // DeviceContext->LinkTreeRoot = RtlSplay (DeviceContext->LinkTreeRoot);
                DeviceContext->LinkTreeElements++;
                return STATUS_SUCCESS;

            } else {
                treeLink = (PTP_LINK) linkLink;
                continue;
            } // Left Child

        } else { // is greater
            if ((linkLink = RtlRightChild (linkLink)) == NULL) {
                IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                    NbfPrint0 ("NbfAddLinkToTree: Adding link as RC.\n");
                }
                RtlInsertAsRightChild ((PRTL_SPLAY_LINKS)treeLink,
                                       (PRTL_SPLAY_LINKS)Link);
                // DeviceContext->LinkTreeRoot = RtlSplay (DeviceContext->LinkTreeRoot);
                DeviceContext->LinkTreeElements++;
                return STATUS_SUCCESS;

            } else {
                treeLink = (PTP_LINK) linkLink;
                continue;
            } // Right Child

        } // end else addresses comparison

    } while (TRUE);


} // NbfAddLinkToTree


NTSTATUS
NbfRemoveLinkFromTree(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine removes a link from the tree of links.
    Note that since this routine needs to modify the link tree, it is called
    in the context of a deferred processing routine, and must have exclusive
    access to the tree. The spinlock is taken by the routine that calls this
    one, as this operation must be atomic in the eyes of the rest of NBF.
    Note further that this routine insists that there not be a link with this
    address in the tree.

Arguments:

    Link - Pointer to a transport link object.
    DeviceContext - pointer to the device context on which this

Return Value:

    STATUS_SUCCESS if the link was removed,
    STATUS_DRIVER_INTERNAL_ERROR if there was a problem removing
        the link (implying the tree was in a bad state).

--*/
{
    DeviceContext->LinkTreeRoot = RtlDelete ((PRTL_SPLAY_LINKS)Link);
    DeviceContext->LinkTreeElements--;
    if (DeviceContext->LastLink == Link) {
        DeviceContext->LastLink = (PTP_LINK)DeviceContext->LinkTreeRoot;
    }
    return STATUS_SUCCESS;

} //NbfRemoveLinkFromTree



PTP_LINK
NbfFindLinkInTree(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Remote
    )

/*++

Routine Description:

    This routine traverses the link tree looking for the given remote address.
    The link tree spinlock is held while looking for the link. After the link
    is found, it's reference count is incremented.

    NOTE: This function is called with the device context LinkSpinLock
    held.

Arguments:

    DeviceContext - pointer to the device this address is associated with.

    Remote - pointer to the hardware address of the remote node.

Return Value:

    Pointer to the link in the tree that matches this remote address. If
    no link is found, NULL is returned.

--*/
{
    PTP_LINK link;
    PRTL_SPLAY_LINKS linkLink;
    ULARGE_INTEGER Magic = {0,0};


    //
    // Are there even any links in the tree?
    //

    if (DeviceContext->LinkTreeElements <= 0) {
        return NULL;
    }

    linkLink = DeviceContext->LinkTreeRoot;

    //
    // Make a magic number for this link
    //

    MacReturnMagicAddress (&DeviceContext->MacInfo, Remote, &Magic);

    IF_NBFDBG(NBF_DEBUG_LINKTREE) {
        NbfPrint1 ("NbfFindLinkInTree: starting search, Elements: %ld \n",
            DeviceContext->LinkTreeElements);
    }

    //
    // Do a quick check if the last link found is this one.
    //

    ASSERT (DeviceContext->LastLink != NULL);

    if ((DeviceContext->LastLink->MagicAddress).QuadPart == Magic.QuadPart) {

        link = DeviceContext->LastLink;

    } else {

        //
        // find the link.
        //

        link = (PTP_LINK) linkLink;     // depends upon splay links being first
                                        // subfield in link!
        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
            NbfPrint3 ("NbfFindLinkInTree: searching, Link: %lx LC: %lx RC: %lx \n",
                linkLink, RtlLeftChild (linkLink), RtlRightChild (linkLink));
        }

        do {

            IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                NbfPrint4 ("NbfFindLinkInTree: Comparing: %lx%lx to %lx%lx\n",
                    link->MagicAddress.HighPart,link->MagicAddress.LowPart,
                    Magic.HighPart, Magic.LowPart);
            }

            if ((link->MagicAddress).QuadPart == Magic.QuadPart) {
                IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                    NbfPrint0 ("NbfFindLinkInTree: equal, going to end.\n");
                }
                break;

            } else {
                if ((link->MagicAddress).QuadPart < Magic.QuadPart) {
                    if ((linkLink = RtlRightChild (linkLink)) == NULL) {

                        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                            NbfPrint0 ("NbfFindLinkInTree: Link Not Found.\n");
                        }
                        return NULL;

                    } else {
                        link = (PTP_LINK) linkLink;
                        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                            NbfPrint3 ("NbfFindLinkInTree: less, took right child, Link: %lx LC: %lx RC: %lx \n",
                                linkLink, RtlLeftChild (linkLink), RtlRightChild (linkLink));
                        }
                        continue;
                    }

                } else { // is greater
                    if ((linkLink = RtlLeftChild (linkLink)) == NULL) {
                        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                            NbfPrint0 ("NbfFindLinkInTree: Link Not Found.\n");
                        }
                        return NULL;

                    } else {
                        link = (PTP_LINK) linkLink;
                        IF_NBFDBG(NBF_DEBUG_LINKTREE) {
                            NbfPrint3 ("NbfFindLinkInTree: greater, took left child, Link: %lx LC: %lx RC: %lx \n",
                                linkLink, RtlLeftChild (linkLink), RtlRightChild (linkLink));
                        }
                        continue;
                    } // got left child branch
                } // greater branch
            } // equal to branch
        } while (TRUE);

        DeviceContext->LastLink = link;

    }

    //
    // Only break out when we've actually found a match..
    //

    if ((link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {
       IF_NBFDBG(NBF_DEBUG_LINKTREE) {
           NbfPrint0 ("NbfFindLinkInTree: Link Found but delete pending.\n");
       }
       return NULL;
    }

    //
    // Mark the link as in use and say we don't need the tree stable any more.
    //

    NbfReferenceLink ("Found in tree", link, LREF_TREE);

    IF_NBFDBG(NBF_DEBUG_LINKTREE) {
        NbfPrint0 ("NbfFindLinkInTree: Link Found.\n");
    }

    return link;

} // NbfFindLinkInTree


PTP_LINK
NbfFindLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Remote
    )

/*++

Routine Description:

    This routine looks for a link in the link tree, and if
    not found there in the deferred queue.

Arguments:

    DeviceContext - pointer to the device this address is associated with.

    Remote - pointer to the hardware address of the remote node.

Return Value:

    Pointer to the link in the tree that matches this remote address. If
    no link is found, NULL is returned.

--*/

{
    PTP_LINK Link;
    BOOLEAN MatchedLink;
    PLIST_ENTRY p;
    UINT i;

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

    Link = NbfFindLinkInTree (DeviceContext, Remote);

    if (Link == NULL) {

        //
        // Not found there, try in deferred queue.
        //

        MatchedLink = FALSE;        // Assume failure

        //
        // Hold the spinlock while we walk the deferred list. We need
        // TimerSpinLock to stop the list from changing, and we need
        // LinkSpinLock to synchronize checking DEFERRED_DELETE and
        // referencing the link.
        //

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        for (p = DeviceContext->LinkDeferred.Flink;
             p != &DeviceContext->LinkDeferred;
             p = p->Flink) {

            //
            // What about taking a lock while we walk
            // this list? It won't be removed from at the front,
            // but it may be added to at the back.
            //

            //
            // We're probably still getting this link to the splay tree.
            // find it and process normally.
            //

            Link = CONTAINING_RECORD (p, TP_LINK, DeferredList);

            //
            // NOTE: We know that the link is not going to be destroyed
            // now, because we have increased the semaphore. We
            // reference the link if DEFERRED_DELETE is not on; the
            // setting of this flag is synchronized (also using
            // DeviceContext->LinkSpinLock) with the refcount going
            // to 0).
            //

            if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {
                continue;      // we're deleting link, can't handle
            }

            for (i=0; i<(UINT)DeviceContext->MacInfo.AddressLength; i++) {
                if (Remote[i] != Link->HardwareAddress.Address[i]){
                    break;
                }
            }

            if (i == (UINT)DeviceContext->MacInfo.AddressLength) { // addresses match.  Deliver packet.
                IF_NBFDBG (NBF_DEBUG_DLC) {
                    NbfPrint1 ("NbfFindLink: Found link on deferred queue, Link: %lx\n",
                                Link);
                }
                NbfReferenceLink ("Got Frame on Deferred", Link, LREF_TREE);
                MatchedLink = TRUE;
                break;
            }

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // If this didn't find the link, make note of that.
        //

        if (MatchedLink == FALSE) {

            Link = (PTP_LINK)NULL;

        }

    } else {

        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint1 ("NbfFindLink: Found link in tree, Link: %lx\n", Link);
        }

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

    return Link;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\framesnd.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    framesnd.c

Abstract:

    This module contains routines which build and send NetBIOS Frames Protocol
    frames and data link frames for other modules.  These routines call on the
    ones in FRAMECON.C to do the construction work.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG
ULONG NbfSendsIssued = 0;
ULONG NbfSendsCompletedInline = 0;
ULONG NbfSendsCompletedOk = 0;
ULONG NbfSendsCompletedFail = 0;
ULONG NbfSendsPended = 0;
ULONG NbfSendsCompletedAfterPendOk = 0;
ULONG NbfSendsCompletedAfterPendFail = 0;

ULONG NbfPacketPanic = 0;
#endif


NTSTATUS
NbfSendAddNameQuery(
    IN PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine sends a ADD_NAME_QUERY frame to register the specified
    address.

Arguments:

    Address - Pointer to a transport address object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext;
    PTP_UI_FRAME RawFrame;
    PUCHAR SingleSR;
    UINT SingleSRLength;
    UINT HeaderLength;

    DeviceContext = Address->Provider;


    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint3 ("NbfSendAddNameQuery:  Sending Frame: %lx, NdisPacket: %lx MacHeader: %lx\n",
            RawFrame, RawFrame->NdisPacket, RawFrame->Header);
    }


    //
    // Build the MAC header. ADD_NAME_QUERY frames go out as
    // single-route source routing.
    //

    MacReturnSingleRouteSR(
        &DeviceContext->MacInfo,
        &SingleSR,
        &SingleSRLength);

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        DeviceContext->NetBIOSAddress.Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        SingleSR,
        SingleSRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the appropriate Netbios header based on the type
    // of the address.
    //

    if ((Address->Flags & ADDRESS_FLAGS_GROUP) != 0) {

        ConstructAddGroupNameQuery (
            (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
            0,                                      // correlator we don't use.
            Address->NetworkName->NetbiosName);

    } else {

        ConstructAddNameQuery (
            (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
            0,                                      // correlator we don't use.
            Address->NetworkName->NetbiosName);

    }

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send the it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                            // no loopback (MC frame).

    return STATUS_SUCCESS;
} /* NbfSendAddNameQuery */


VOID
NbfSendNameQuery(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN SourceRoutingOptional
    )

/*++

Routine Description:

    This routine sends a NAME_QUERY frame of the appropriate type given the
    state of the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.

    SourceRoutingOptional - TRUE if source routing should be removed if
        we are configured that way.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext;
    PTP_ADDRESS Address;
    PTP_UI_FRAME RawFrame;
    PUCHAR NameQuerySR;
    UINT NameQuerySRLength;
    PUCHAR NameQueryAddress;
    UINT HeaderLength;
    UCHAR Lsn;
    UCHAR NameType;

    Address = Connection->AddressFile->Address;
    DeviceContext = Address->Provider;


    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame(DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return;
    }

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint2 ("NbfSendNameQuery:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header.
    //

    if (((Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) != 0) &&
        ((Connection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) == 0)) {

        //
        // This is the second find name to a unique name; this
        // means that we already have a link and we can send this
        // frame directed to it.
        //

        ASSERT (Connection->Link != NULL);

        MacReturnSourceRouting(
            &DeviceContext->MacInfo,
            Connection->Link->Header,
            &NameQuerySR,
            &NameQuerySRLength);

        NameQueryAddress = Connection->Link->HardwareAddress.Address;

    } else {

        //
        // Standard NAME_QUERY frames go out as
        // single-route source routing, except if
        // it is optional and we are configured
        // that way.
        //

        if (SourceRoutingOptional &&
            Connection->Provider->MacInfo.QueryWithoutSourceRouting) {

            NameQuerySR = NULL;
            NameQuerySRLength = 0;

        } else {

            MacReturnSingleRouteSR(
                &DeviceContext->MacInfo,
                &NameQuerySR,
                &NameQuerySRLength);

        }

        NameQueryAddress = DeviceContext->NetBIOSAddress.Address;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        NameQueryAddress,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        NameQuerySR,
        NameQuerySRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    Lsn = (UCHAR)((Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR_FN) ?
                    NAME_QUERY_LSN_FIND_NAME : Connection->Lsn);

    NameType = (UCHAR)((Connection->AddressFile->Address->Flags & ADDRESS_FLAGS_GROUP) ?
                        NETBIOS_NAME_TYPE_GROUP : NETBIOS_NAME_TYPE_UNIQUE);

    ConstructNameQuery (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NameType,                               // type of our name.
        Lsn,                                    // calculated, above.
        (USHORT)Connection->ConnectionId,       // corr. in 1st NAME_RECOGNIZED.
        Address->NetworkName->NetbiosName,      // NetBIOS name of sender.
        Connection->CalledAddress.NetbiosName); // NetBIOS name of receiver.

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send the it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                            // no loopback (MC frame)

} /* NbfSendNameQuery */


VOID
NbfSendNameRecognized(
    IN PTP_ADDRESS Address,
    IN UCHAR LocalSessionNumber,        // LSN assigned to session.
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine sends a NAME_RECOGNIZED frame of the appropriate type
    in response to the NAME_QUERY pointed to by Header.

Arguments:

    Address - Pointer to a transport address object.

    LocalSessionNumber - The LSN to use in the frame.

    Header - Pointer to the connectionless NetBIOS header of the
        NAME_QUERY frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRoutingInformation - Pointer to source routing information, if any.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext;
    PTP_UI_FRAME RawFrame;
    UINT HeaderLength;
    PUCHAR ReplySR;
    UINT ReplySRLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    UCHAR NameType;

    DeviceContext = Address->Provider;


    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return;
    }

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint2 ("NbfSendNameRecognized:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header. NAME_RECOGNIZED frames go out as
    // directed source routing unless configured for general-route.
    //

    if (DeviceContext->MacInfo.AllRoutesNameRecognized) {

        MacReturnGeneralRouteSR(
            &DeviceContext->MacInfo,
            &ReplySR,
            &ReplySRLength);

    } else {

        if (SourceRouting != NULL) {

            RtlCopyMemory(
                TempSR,
                SourceRouting,
                SourceRoutingLength);

            MacCreateNonBroadcastReplySR(
                &DeviceContext->MacInfo,
                TempSR,
                SourceRoutingLength,
                &ReplySR);

            ReplySRLength = SourceRoutingLength;

        } else {

            ReplySR = NULL;
        }
    }


    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        ReplySR,
        ReplySRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    NameType = (UCHAR)((Address->Flags & ADDRESS_FLAGS_GROUP) ?
                        NETBIOS_NAME_TYPE_GROUP : NETBIOS_NAME_TYPE_UNIQUE);

    ConstructNameRecognized (   // build a good response.
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NameType,                            // type of local name.
        LocalSessionNumber,                  // return our LSN.
        RESPONSE_CORR(Header),               // new xmit corr.
        0,                                   // our response correlator (unused).
        Header->DestinationName,             // our NetBIOS name.
        Header->SourceName);                 // his NetBIOS name.

    //
    // Use Address->NetworkName->Address[0].Address[0].NetbiosName
    // instead of Header->DestinationName?
    //

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send the it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                            // no loopback (MC frame)

} /* NbfSendNameRecognized */


VOID
NbfSendNameInConflict(
    IN PTP_ADDRESS Address,
    IN PUCHAR ConflictingName
    )

/*++

Routine Description:

    This routine sends a NAME_IN_CONFLICT frame.

Arguments:

    Address - Pointer to a transport address object.

    ConflictingName - The NetBIOS name which is in conflict.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext;
    PTP_UI_FRAME RawFrame;
    UINT HeaderLength;
    PUCHAR SingleSR;
    UINT SingleSRLength;

    DeviceContext = Address->Provider;


    //
    // Allocate a UI frame from the pool.
    //

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
        return;
    }

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint2 ("NbfSendNameRecognized:  Sending Frame: %lx, NdisPacket: %lx\n",
            RawFrame, RawFrame->NdisPacket);
    }


    //
    // Build the MAC header. ADD_NAME_QUERY frames go out as
    // single-route source routing.
    //

    MacReturnSingleRouteSR(
        &DeviceContext->MacInfo,
        &SingleSR,
        &SingleSRLength);

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        DeviceContext->NetBIOSAddress.Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        SingleSR,
        SingleSRLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructNameInConflict (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        ConflictingName,                         // his NetBIOS name.
        DeviceContext->ReservedNetBIOSAddress);  // our reserved NetBIOS name.

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send the it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                            // no loopback (MC frame)

} /* NbfSendNameInConflict */


VOID
NbfSendSessionInitialize(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a SESSION_INITIALIZE frame on the specified connection.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;

    NbfReferenceConnection("send Session Initialize", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendSessionInitialize:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_SI);
        NbfDereferenceConnection("Couldn't get SI packet", Connection, CREF_FRAME_SEND);
        return;
    }


    //
    // Initialize the Netbios header.
    //

    ConstructSessionInitialize (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        SESSION_INIT_OPTIONS_20 | SESSION_INIT_NO_ACK |
            SESSION_INIT_OPTIONS_LF,    // supported options Set LF correctly.
        (USHORT)(Connection->Link->MaxFrameSize - sizeof(NBF_HDR_CONNECTION) - sizeof(DLC_I_FRAME)),
                                        // maximum frame size/this session.
        Connection->NetbiosHeader.TransmitCorrelator, // correlator from NAME_RECOGNIZED.
        0,                              // correlator for expected SESSION_CONFIRM.
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status == STATUS_LINK_FAILED) {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendSessionInitialize */


VOID
NbfSendSessionConfirm(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a SESSION_CONFIRM frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;

    NbfReferenceConnection("send Session Confirm", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendSessionConfirm:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_SC);
        NbfDereferenceConnection("Couldn't get SC packet", Connection, CREF_FRAME_SEND);
        return;
    }


    //
    // Initialize the Netbios header.
    //

    ConstructSessionConfirm (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        SESSION_CONFIRM_OPTIONS_20 | SESSION_CONFIRM_NO_ACK, // supported options.
        (USHORT)(Connection->Link->MaxFrameSize - sizeof(NBF_HDR_CONNECTION) - sizeof(DLC_I_FRAME)),
                                        // maximum frame size/this session.
        Connection->NetbiosHeader.TransmitCorrelator, // correlator from NAME_RECOGNIZED.
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status == STATUS_LINK_FAILED) {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendSessionConfirm */


VOID
NbfSendSessionEnd(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN Abort
    )

/*++

Routine Description:

    This routine sends a SESSION_END frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.

    Abort - Boolean set to TRUE if the connection is abnormally terminating.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;

    NbfReferenceConnection("send Session End", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;

    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendSessionEnd:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_SE);
        NbfDereferenceConnection("Couldn't get SE packet", Connection, CREF_FRAME_SEND);
        return;
    }

    //
    // The following statements instruct the packet destructor to run
    // down this connection when the packet is acknowleged.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_END;


    //
    // Initialize the Netbios header.
    //

    ConstructSessionEnd (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        (USHORT)(Abort ?                // reason for termination.
            SESSION_END_REASON_ABEND :
            SESSION_END_REASON_HANGUP),
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //
    // Note that we force an ack for this packet, as we want to make sure we
    // run down the connection and link correctly.
    //

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    Status = SendOnePacket (Connection, Packet, TRUE, NULL); // fire and forget.

    if (Status == STATUS_LINK_FAILED) {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendSessionEnd */


VOID
NbfSendNoReceive(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a NO_RECEIVE frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    USHORT MessageBytesToAck;

    NbfReferenceConnection("send No Receive", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendNoReceive:  NbfCreatePacket failed.\n");
        }
#endif
        NbfDereferenceConnection("Couldn't get NR packet", Connection, CREF_FRAME_SEND);
        return;
    }


    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    MessageBytesToAck = (USHORT)
        (Connection->MessageBytesReceived + Connection->MessageInitAccepted - Connection->MessageBytesAcked);
    Connection->Flags |= CONNECTION_FLAGS_W_RESYNCH;

    //
    // Initialize the Netbios header.
    //

    ConstructNoReceive (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        (USHORT)0,                      // options
        MessageBytesToAck,              // number of bytes accepted.
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status != STATUS_LINK_FAILED) {
        ExInterlockedAddUlong(
            &Connection->MessageBytesAcked,
            MessageBytesToAck,
            Connection->LinkSpinLock);
    } else {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendNoReceive */


VOID
NbfSendReceiveContinue(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a RECEIVE_CONTINUE frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    USHORT MessageBytesToAck;

    NbfReferenceConnection("send Receive Continue", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendReceiveContinue:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_RC);
        NbfDereferenceConnection("Couldn't get RC packet", Connection, CREF_FRAME_SEND);
        return;
    }

    //
    // Save this variable now since it is what we are implicitly ack'ing.
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    MessageBytesToAck = (USHORT)
        (Connection->MessageBytesReceived + Connection->MessageInitAccepted - Connection->MessageBytesAcked);

    //
    // Initialize the Netbios header.
    //

    ConstructReceiveContinue (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        Connection->NetbiosHeader.TransmitCorrelator, // correlator from DFM
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status != STATUS_LINK_FAILED) {
        ExInterlockedAddUlong(
            &Connection->MessageBytesAcked,
            MessageBytesToAck,
            Connection->LinkSpinLock);
    } else {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendReceiveContinue */


VOID
NbfSendReceiveOutstanding(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a RECEIVE_OUTSTANDING frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    USHORT MessageBytesToAck;

    NbfReferenceConnection("send Receive Outstanding", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendReceiveOutstanding:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_RO);
        NbfDereferenceConnection("Couldn't get RO packet", Connection, CREF_FRAME_SEND);
        return;
    }


    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    MessageBytesToAck = (USHORT)
        (Connection->MessageBytesReceived + Connection->MessageInitAccepted - Connection->MessageBytesAcked);
    Connection->Flags |= CONNECTION_FLAGS_W_RESYNCH;

    //
    // Initialize the Netbios header.
    //

    ConstructReceiveOutstanding (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        MessageBytesToAck,              // number of bytes accepted.
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).


    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status != STATUS_LINK_FAILED) {
        ExInterlockedAddUlong(
            &Connection->MessageBytesAcked,
            MessageBytesToAck,
            Connection->LinkSpinLock);
    } else {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendReceiveOutstanding */


VOID
NbfSendDataAck(
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine sends a DATA_ACK frame on the specified connection.

Arguments:

    Connection - Pointer to a transport connection object.


Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET Packet;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;

    NbfReferenceConnection("send Data Ack", Connection, CREF_FRAME_SEND);

    DeviceContext = Connection->Provider;
    Link = Connection->Link;
    Status = NbfCreatePacket (DeviceContext, Connection->Link, &Packet);

    if (!NT_SUCCESS (Status)) {            // if we couldn't make frame.
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendDataAck:  NbfCreatePacket failed.\n");
        }
#endif
        NbfWaitPacket (Connection, CONNECTION_FLAGS_SEND_DA);
        NbfDereferenceConnection("Couldn't get DA packet", Connection, CREF_FRAME_SEND);
        return;
    }


    //
    // Initialize the Netbios header.
    //

    ConstructDataAck (
        (PNBF_HDR_CONNECTION)&(Packet->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]),
        Connection->NetbiosHeader.TransmitCorrelator, // correlator from DATA_ONLY_LAST.
        Connection->Lsn,                // our local session number.
        Connection->Rsn);               // his session number (our RSN).

    //
    // Now send the packet on the connection via the link.  If there are
    // conditions on the link which make it impossible to send the packet,
    // then the packet will be queued to the WackQ, and then timeouts will
    // restart the link.  This is acceptable when the traffic level is so
    // high that we encounter this condition. Note that Data Ack will be
    // seeing this condition frequently when send windows close after large
    // sends.
    //

    //
    // Set this so NbfDestroyPacket will dereference the connection.
    //

    Packet->Owner = Connection;
    Packet->Action = PACKET_ACTION_CONNECTION;

    Packet->NdisIFrameLength =
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

    MacModifyHeader(
         &DeviceContext->MacInfo,
         Packet->Header,
         sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

    NbfSetNdisPacketLength(
        Packet->NdisPacket,
        Packet->NdisIFrameLength);

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    Status = SendOnePacket (Connection, Packet, FALSE, NULL); // fire and forget.

    if (Status == STATUS_LINK_FAILED) {
        NbfDereferencePacket (Packet);           // destroy the packet.
    }

    return;
} /* NbfSendDataAck */


VOID
NbfSendDm(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a DM-r/x DLC frame on the specified link.

    NOTE: This routine is called with the link spinlock held,
    and returns with it released. IT MUST BE CALLED AT DPC
    LEVEL.

Arguments:

    Link - Pointer to a transport link object.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_U_FRAME DlcHeader;                     // S-format frame alias.

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_FRAME));

        //
        // Format LLC DM-r/x header.
        //

        DlcHeader = (PDLC_U_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = DSAP_NETBIOS_OVER_LLC | DLC_SSAP_RESPONSE;
        DlcHeader->Command = (UCHAR)(DLC_CMD_DM | (PollFinal ? DLC_U_PF : 0));

        //
        // This releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
        RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendDm:  packet not sent.\n");
        }
#endif
    }
} /* NbfSendDm */


VOID
NbfSendUa(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a UA-r/x DLC frame on the specified link.

    NOTE: This routine is called with the link spinlock held,
    and returns with it released. IT MUST BE CALLED AT DPC
    LEVEL.

Arguments:

    Link - Pointer to a transport link object.

    PollFinal - TRUE if poll/final bit should be set.

    OldIrql - The IRQL at which Link->SpinLock was acquired.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_U_FRAME DlcHeader;                     // U-format frame alias.

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_FRAME));

        // Format LLC UA-r/x header.
        //

        DlcHeader = (PDLC_U_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = DSAP_NETBIOS_OVER_LLC | DLC_SSAP_RESPONSE;
        DlcHeader->Command = (UCHAR)(DLC_CMD_UA | (PollFinal ? DLC_U_PF : 0));

        //
        // This releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
        RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendUa:  packet not sent.\n");
        }
#endif
    }
} /* NbfSendUa */


VOID
NbfSendSabme(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a SABME-c/x DLC frame on the specified link.

    NOTE: This routine is called with the link spinlock held,
    and returns with it released.

Arguments:

    Link - Pointer to a transport link object.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY p;
    PTP_PACKET RawFrame, packet;
    PDLC_U_FRAME DlcHeader;                     // S-format frame alias.

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_FRAME));

        //
        // Format LLC SABME-c/x header.
        //

        DlcHeader = (PDLC_U_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Command = (UCHAR)(DLC_CMD_SABME | (PollFinal ? DLC_U_PF : 0));

        //
        // Set up so that T1 will be started when the send
        // completes.
        //

        if (PollFinal) {
            if (Link->Provider->MacInfo.MediumAsync) {
                RawFrame->NdisIFrameLength = Link->HeaderLength + sizeof(DLC_S_FRAME);
                RawFrame->Link = Link;
                NbfReferenceLink ("Sabme/p", Link, LREF_START_T1);
            } else {
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));
            }
        }

        //
        // This releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

        //
        // Reset the link state based on having sent this packet..
        // Note that a SABME can be sent under some conditions on an existing
        // link. If it is, it means we want to reset this link to a known state.
        // We'll do that; note that that involves ditching any packets outstanding
        // on the link.
        //

        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
        Link->NextSend = 0;
        Link->LastAckReceived = 0;
        Link->NextReceive = 0; // expect next packet to be sequence 0
        Link->NextReceive = 0;
        Link->LastAckSent = 0;
        Link->NextReceive = 0;
        Link->LastAckSent = 0;

        while (!IsListEmpty (&Link->WackQ)) {
            p = RemoveHeadList (&Link->WackQ);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
            NbfDereferencePacket (packet);
            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
        }

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
    } else {
        if (PollFinal) {
            StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));
        }
        RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendSabme:  packet not sent.\n");
        }
#endif
    }
} /* NbfSendSabme */


VOID
NbfSendDisc(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a DISC-c/x DLC frame on the specified link.

Arguments:

    Link - Pointer to a transport link object.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_U_FRAME DlcHeader;                     // S-format frame alias.
    KIRQL oldirql;

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_FRAME));

        //
        // Format LLC DISC-c/x header.
        //

        DlcHeader = (PDLC_U_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Command = (UCHAR)(DLC_CMD_DISC | (PollFinal ? DLC_U_PF : 0));

        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

        //
        // This releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendDisc:  packet not sent.\n");
        }
#endif
    }

    KeLowerIrql (oldirql);

} /* NbfSendDisc */


VOID
NbfSendRr(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a RR-x/x DLC frame on the specified link.

    NOTE: This routine is called with the link spinlock held,
    and returns with it released. THIS ROUTINE MUST BE CALLED
    AT DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

    Command - TRUE if command bit should be set.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_S_FRAME DlcHeader;                     // S-format frame alias.

    Status = NbfCreateRrPacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;

        //
        // RawFrame->Action will be set to PACKET_ACTION_RR if
        // NbfCreateRrPacket got a packet from the RrPacketPool
        // and PACKET_ACTION_NULL if it got one from the regular
        // pool.
        //

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_S_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_S_FRAME));

        //
        // Format LLC RR-x/x header.
        //

        DlcHeader = (PDLC_S_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = (UCHAR)(DSAP_NETBIOS_OVER_LLC | (Command ? 0 : DLC_SSAP_RESPONSE));
        DlcHeader->Command = DLC_CMD_RR;
        DlcHeader->RcvSeq = (UCHAR)(PollFinal ? DLC_S_PF : 0);

        //
        // If this is a command frame (which will always be a
        // poll with the current code) set up so that T1 will
        // be started when the send completes.
        //

        if (Command) {
            if (Link->Provider->MacInfo.MediumAsync) {
                RawFrame->NdisIFrameLength = Link->HeaderLength + sizeof(DLC_S_FRAME);
                RawFrame->Link = Link;
                NbfReferenceLink ("Rr/p", Link, LREF_START_T1);
            } else {
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));
            }
        }

        //
        // This puts Link->NextReceive into DlcHeader->RcvSeq
        // and releases the spinlock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
        if (Command) {
            StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));
        }
        RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendRr:  packet not sent.\n");
        }
#endif
    }
} /* NbfSendRr */

#if 0

//
// These functions are not currently called, so they are commented
// out.
//


VOID
NbfSendRnr(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a RNR-x/x DLC frame on the specified link.

Arguments:

    Link - Pointer to a transport link object.

    Command - TRUE if command bit should be set.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_S_FRAME DlcHeader;                     // S-format frame alias.
    KIRQL oldirql;

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_S_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_S_FRAME));

        //
        // Format LLC RR-x/x header.
        //

        DlcHeader = (PDLC_S_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = (UCHAR)(DSAP_NETBIOS_OVER_LLC | (Command ? 0 : DLC_SSAP_RESPONSE));
        DlcHeader->Command = DLC_CMD_RNR;
        DlcHeader->RcvSeq = (UCHAR)(PollFinal ? DLC_S_PF : 0);

        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

        //
        // This puts Link->NextReceive into DlcHeader->RcvSeq
        // and releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendRnr:  packet not sent.\n");
        }
#endif
    }
    KeLowerIrql (oldirql);
} /* NbfSendRnr */


VOID
NbfSendTest(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PMDL Psdu
    )

/*++

Routine Description:

    This routine sends a TEST-x/x DLC frame on the specified link.

Arguments:

    Link - Pointer to a transport link object.

    Command - TRUE if command bit should be set.

    PollFinal - TRUE if poll/final bit should be set.

    Psdu - Pointer to an MDL chain describing received TEST-c frame's storage.

Return Value:

    none.

--*/

{
    Link, Command, PollFinal, Psdu; // prevent compiler warnings

    PANIC ("NbfSendTest:  Entered.\n");
} /* NbfSendTest */


VOID
NbfSendFrmr(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a FRMR-r/x DLC frame on the specified link.

Arguments:

    Link - Pointer to a transport link object.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    Link, PollFinal; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfSendFrmr:  Entered.\n");
    }
} /* NbfSendFrmr */

#endif


VOID
NbfSendXid(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends an XID-x/x DLC frame on the specified link.

    NOTE: This routine is called with the link spinlock held,
    and returns with it released.

Arguments:

    Link - Pointer to a transport link object.

    Command - TRUE if command bit should be set.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    Link, Command, PollFinal; // prevent compiler warnings

    RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
    PANIC ("NbfSendXid:  Entered.\n");
} /* NbfSendXid */


VOID
NbfSendRej(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    )

/*++

Routine Description:

    This routine sends a REJ-x/x DLC frame on the specified link.

    NOTE: This function is called with Link->SpinLock held and
    returns with it released. THIS MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a transport link object.

    Command - TRUE if command bit should be set.

    PollFinal - TRUE if poll/final bit should be set.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    PTP_PACKET RawFrame;
    PDLC_S_FRAME DlcHeader;                     // S-format frame alias.

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfSendRej:  Entered.\n");
    }

    Status = NbfCreatePacket (Link->Provider, Link, &RawFrame);
    if (NT_SUCCESS (Status)) {

        RawFrame->Owner = NULL;
        RawFrame->Action = PACKET_ACTION_NULL;

        //
        // set the packet length correctly (Note that the NDIS_BUFFER
        // gets returned to the proper length in NbfDestroyPacket)
        //

        MacModifyHeader(&Link->Provider->MacInfo, RawFrame->Header, sizeof(DLC_S_FRAME));
        NbfSetNdisPacketLength (RawFrame->NdisPacket, Link->HeaderLength + sizeof(DLC_S_FRAME));

        //
        // Format LLC REJ-x/x header.
        //

        DlcHeader = (PDLC_S_FRAME)&(RawFrame->Header[Link->HeaderLength]);
        DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHeader->Ssap = (UCHAR)(DSAP_NETBIOS_OVER_LLC | (Command ? 0 : DLC_SSAP_RESPONSE));
        DlcHeader->Command = DLC_CMD_REJ;
        DlcHeader->RcvSeq = (UCHAR)(PollFinal ? DLC_S_PF : 0);

        //
        // This puts Link->NextReceive into DlcHeader->RcvSeq
        // and releases the spin lock.
        //

        SendControlPacket (Link, RawFrame);

    } else {
        RELEASE_DPC_SPIN_LOCK(&Link->SpinLock);
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfSendRej:  packet not sent.\n");
        }
#endif
    }
} /* NbfSendRej */


NTSTATUS
NbfCreateConnectionlessFrame(
    PDEVICE_CONTEXT DeviceContext,
    PTP_UI_FRAME *RawFrame
    )

/*++

Routine Description:

    This routine allocates a connectionless frame (either from the local
    device context pool or out of non-paged pool).

Arguments:

    DeviceContext - Pointer to our device context to charge the frame to.

    RawFrame - Pointer to a place where we will return a pointer to the
        allocated frame.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PTP_UI_FRAME UIFrame;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfCreateConnectionlessFrame:  Entered.\n");
    }

    //
    // Make sure that structure padding hasn't happened.
    //

    ASSERT (sizeof(NBF_HDR_CONNECTIONLESS) == 44);

    p = ExInterlockedRemoveHeadList (
            &DeviceContext->UIFramePool,
            &DeviceContext->Interlock);

    if (p == NULL) {
#if DBG
        if (NbfPacketPanic) {
            PANIC ("NbfCreateConnectionlessFrame: PANIC! no more UI frames in pool!\n");
        }
#endif
        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);
        ++DeviceContext->UIFrameExhausted;
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UIFrame = (PTP_UI_FRAME) CONTAINING_RECORD (p, TP_UI_FRAME, Linkage);

    *RawFrame = UIFrame;

    return STATUS_SUCCESS;
} /* NbfCreateConnectionlessFrame */


VOID
NbfDestroyConnectionlessFrame(
    PDEVICE_CONTEXT DeviceContext,
    PTP_UI_FRAME RawFrame
    )

/*++

Routine Description:

    This routine destroys a connectionless frame by either returning it
    to the device context's pool or to the system's non-paged pool.

Arguments:

    DeviceContext - Pointer to our device context to return the frame to.

    RawFrame - Pointer to a frame to be returned.

Return Value:

    none.

--*/

{
    PNDIS_BUFFER HeaderBuffer;
    PNDIS_BUFFER NdisBuffer;

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfDestroyConnectionlessFrame:  Entered.\n");
    }

    //
    // Strip off and unmap the buffers describing data and header.
    //

    NdisUnchainBufferAtFront (RawFrame->NdisPacket, &HeaderBuffer);

    // data buffers get thrown away

    NdisUnchainBufferAtFront (RawFrame->NdisPacket, &NdisBuffer);
    while (NdisBuffer != NULL) {
        NdisFreeBuffer (NdisBuffer);
        NdisUnchainBufferAtFront (RawFrame->NdisPacket, &NdisBuffer);
    }

    NDIS_BUFFER_LINKAGE(HeaderBuffer) = (PNDIS_BUFFER)NULL;

    //
    // If this UI frame has some transport-created data,
    // free the buffer now.
    //

    if (RawFrame->DataBuffer) {
        ExFreePool (RawFrame->DataBuffer);
        RawFrame->DataBuffer = NULL;
    }

    NdisChainBufferAtFront (RawFrame->NdisPacket, HeaderBuffer);

    ExInterlockedInsertTailList (
        &DeviceContext->UIFramePool,
        &RawFrame->Linkage,
        &DeviceContext->Interlock);

} /* NbfDestroyConnectionlessFrame */


VOID
NbfSendUIFrame(
    PDEVICE_CONTEXT DeviceContext,
    PTP_UI_FRAME RawFrame,
    IN BOOLEAN Loopback
    )

/*++

Routine Description:

    This routine sends a connectionless frame by calling the physical
    provider's Send service.  When the request completes, or if the service
    does not return successfully, then the frame is deallocated.

Arguments:

    DeviceContext - Pointer to our device context.

    RawFrame - Pointer to a connectionless frame to be sent.

    Loopback - A boolean flag set to TRUE if the source hardware address
        of the packet should be set to zeros.

    SourceRoutingInformation - Pointer to optional source routing information.

Return Value:

    None.

--*/

{
    NDIS_STATUS NdisStatus;
    PUCHAR DestinationAddress;

    UNREFERENCED_PARAMETER(Loopback);

#if DBG
    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint2 ("NbfSendUIFrame:  Entered, RawFrame: %lx NdisPacket %lx\n",
            RawFrame, RawFrame->NdisPacket);
        DbgPrint ("NbfSendUIFrame: MacHeader: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x \n",
            RawFrame->Header[0],
            RawFrame->Header[1],
            RawFrame->Header[2],
            RawFrame->Header[3],
            RawFrame->Header[4],
            RawFrame->Header[5],
            RawFrame->Header[6],
            RawFrame->Header[7],
            RawFrame->Header[8],
            RawFrame->Header[9],
            RawFrame->Header[10],
            RawFrame->Header[11],
            RawFrame->Header[12],
            RawFrame->Header[13]);
    }
#endif

    //
    // Send the packet.
    //

#if DBG
    NbfSendsIssued++;
#endif

    //
    // Loopback will be FALSE for multicast frames or other
    // frames that we know are not directly addressed to
    // our hardware address.
    //

    if (Loopback) {

        //
        // See if this frame should be looped back.
        //

        MacReturnDestinationAddress(
            &DeviceContext->MacInfo,
            RawFrame->Header,
            &DestinationAddress);

        if (RtlEqualMemory(
                DestinationAddress,
                DeviceContext->LocalAddress.Address,
                DeviceContext->MacInfo.AddressLength)) {

            NbfInsertInLoopbackQueue(
                DeviceContext,
                RawFrame->NdisPacket,
                LOOPBACK_UI_FRAME
                );

            NdisStatus = NDIS_STATUS_PENDING;

            goto NoNdisSend;

        }

    }

    INCREMENT_COUNTER (DeviceContext, PacketsSent);

    if (DeviceContext->NdisBindingHandle) {
    
        NdisSend (
            &NdisStatus,
            (NDIS_HANDLE)DeviceContext->NdisBindingHandle,
            RawFrame->NdisPacket);
    }
    else {
        NdisStatus = STATUS_INVALID_DEVICE_STATE;
    }

NoNdisSend:

    if (NdisStatus != NDIS_STATUS_PENDING) {

#if DBG
        if (NdisStatus == NDIS_STATUS_SUCCESS) {
            NbfSendsCompletedOk++;
        } else {
            NbfSendsCompletedFail++;
            IF_NBFDBG (NBF_DEBUG_FRAMESND) {
                 NbfPrint1 ("NbfSendUIFrame: NdisSend failed, status other Pending or Complete: %s.\n",
                          NbfGetNdisStatus(NdisStatus));
            }
        }
#endif

        NbfDestroyConnectionlessFrame (DeviceContext, RawFrame);

    } else {

#if DBG
        NbfSendsPended++;
#endif
    }

} /* NbfSendUIFrame */


VOID
NbfSendUIMdlFrame(
    PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine sends a connectionless frame by calling the NbfSendUIFrame.
    It is intended that this routine be used for sending datagrams and
    braodcast datagrams.

    The datagram to be sent is described in the NDIS packet contained
    in the Address. When the send completes, the send completion handler
    returns the NDIS buffer describing the datagram to the buffer pool and
    marks the address ndis packet as usable again. Thus, all datagram and
    UI frames are sequenced through the address they are sent on.

Arguments:

    Address - pointer to the address from which to send this datagram.

    SourceRoutingInformation - Pointer to optional source routing information.

Return Value:

    None.

--*/

{
//    NTSTATUS Status;
    NDIS_STATUS NdisStatus;
    PDEVICE_CONTEXT DeviceContext;
    PUCHAR DestinationAddress;

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfSendUIMdlFrame:  Entered.\n");
    }


    //
    // Send the packet.
    //

    DeviceContext = Address->Provider;

    INCREMENT_COUNTER (DeviceContext, PacketsSent);

    MacReturnDestinationAddress(
        &DeviceContext->MacInfo,
        Address->UIFrame->Header,
        &DestinationAddress);

    if (RtlEqualMemory(
            DestinationAddress,
            DeviceContext->LocalAddress.Address,
            DeviceContext->MacInfo.AddressLength)) {

        //
        // This packet is sent to ourselves; we should loop it
        // back.
        //

        NbfInsertInLoopbackQueue(
            DeviceContext,
            Address->UIFrame->NdisPacket,
            LOOPBACK_UI_FRAME
            );

        NdisStatus = NDIS_STATUS_PENDING;

    } else {

#ifndef NO_STRESS_BUG
        Address->SendFlags |=  ADDRESS_FLAGS_SENT_TO_NDIS;
        Address->SendFlags &= ~ADDRESS_FLAGS_RETD_BY_NDIS;
#endif

        if (Address->Provider->NdisBindingHandle) {

            NdisSend (
                &NdisStatus,
                (NDIS_HANDLE)Address->Provider->NdisBindingHandle,
                Address->UIFrame->NdisPacket);
        }
        else {
            NdisStatus = STATUS_INVALID_DEVICE_STATE;
        }
    }

    if (NdisStatus != NDIS_STATUS_PENDING) {

		NbfSendDatagramCompletion (Address, Address->UIFrame->NdisPacket, NdisStatus);

#if DBG
        if (NdisStatus != NDIS_STATUS_SUCCESS) {  // This is an error, trickle it up
            IF_NBFDBG (NBF_DEBUG_FRAMESND) {
                  NbfPrint1 ("NbfSendUIMdlFrame: NdisSend failed, status other Pending or Complete: %s.\n",
                      NbfGetNdisStatus(NdisStatus));
            }
        }
#endif
    }

} /* NbfSendUIMdlFrame */


VOID
NbfSendDatagramCompletion(
    IN PTP_ADDRESS Address,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called as an I/O completion handler at the time a
    NbfSendUIMdlFrame send request is completed.  Because this handler is only
    associated with NbfSendUIMdlFrame, and because NbfSendUIMdlFrame is only
    used with datagrams and broadcast datagrams, we know that the I/O being
    completed is a datagram.  Here we complete the in-progress datagram, and
    start-up the next one if there is one.

Arguments:

    Address - Pointer to a transport address on which the datagram
        is queued.

    NdisPacket - pointer to the NDIS packet describing this request.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PLIST_ENTRY p;
    KIRQL oldirql;
    PNDIS_BUFFER HeaderBuffer;

    NdisPacket;  // prevent compiler warnings.

    IF_NBFDBG (NBF_DEBUG_FRAMESND) {
        NbfPrint0 ("NbfSendDatagramCompletion:  Entered.\n");
    }

#ifndef NO_STRESS_BUG
	Address->SendFlags |= ADDRESS_FLAGS_RETD_BY_NDIS;
#endif

    //
    // Dequeue the current request and return it to the client.  Release
    // our hold on the send datagram queue.
    //
    // *** There may be no current request, if the one that was queued
    //     was aborted or timed out. If this is the case, we added a
    //     special reference to the address, so we still want to deref
    //     when we are done (I don't think this is true - adb 3/22/93).
    //

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);
    p = RemoveHeadList (&Address->SendDatagramQueue);

    if (p != &Address->SendDatagramQueue) {

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

        IF_NBFDBG (NBF_DEBUG_FRAMESND) {
            NbfPrint0 ("NbfDestroyConnectionlessFrame:  Entered.\n");
        }

        //
        // Strip off and unmap the buffers describing data and header.
        //

        NdisUnchainBufferAtFront (Address->UIFrame->NdisPacket, &HeaderBuffer);

        // drop the rest of the packet

        NdisReinitializePacket (Address->UIFrame->NdisPacket);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = (PNDIS_BUFFER)NULL;
        NdisChainBufferAtFront (Address->UIFrame->NdisPacket, HeaderBuffer);

        //
        // Ignore NdisStatus; datagrams always "succeed". The Information
        // field was filled in when we queued the datagram.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

#ifndef NO_STRESS_BUG
        Address->SendFlags &= ~ADDRESS_FLAGS_SENT_TO_NDIS;
        Address->SendFlags &= ~ADDRESS_FLAGS_RETD_BY_NDIS;
#endif

        ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);
        Address->Flags &= ~ADDRESS_FLAGS_SEND_IN_PROGRESS;
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        //
        // Send more datagrams on the Address if possible.
        //

        NbfSendDatagramsOnAddress (Address);       // do more datagrams.

    } else {

        ASSERT (FALSE);

        Address->Flags &= ~ADDRESS_FLAGS_SEND_IN_PROGRESS;
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    }

    NbfDereferenceAddress ("Complete datagram", Address, AREF_REQUEST);

} /* NbfSendDatagramCompletion */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbf.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbf.h

Abstract:

    Private include file for the NBF (NetBIOS Frames Protocol) transport
    provider subcomponent of the NTOS project.

Author:

    Stephen E. Jones (stevej) 25-Oct-1989

Revision History:

    David Beaver (dbeaver) 24-Sep-1990
        Remove PDI and PC586-specific support; add NDIS support

--*/

#ifndef _NBF_
#define _NBF_

#include <ntddk.h>

typedef struct _RTL_SPLAY_LINKS {
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) {    \
    PRTL_SPLAY_LINKS _SplayLinks;            \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks;   \
    _SplayLinks->LeftChild = NULL;       \
    _SplayLinks->RightChild = NULL;      \
    }

#define RtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->LeftChild \
    )

#define RtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->RightChild \
    )

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                      \
    PRTL_SPLAY_LINKS _SplayChild;                       \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);     \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);       \
    _SplayParent->LeftChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;             \
    }

#define RtlInsertAsRightChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                       \
    PRTL_SPLAY_LINKS _SplayChild;                        \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);      \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);        \
    _SplayParent->RightChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;              \
    }


PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );


VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

#include <tdikrnl.h>                        // Transport Driver Interface.

#include <ndis.h>                       // Physical Driver Interface.

#if DEVL
#define STATIC
#else
#define STATIC static
#endif

#include "nbfconst.h"                   // private NETBEUI constants.
#include "nbfmac.h"                     // mac-specific definitions
#include "nbfhdrs.h"                    // private NETBEUI protocol headers.
#include "nbftypes.h"                   // private NETBEUI types.
#include "nbfcnfg.h"                    // configuration information.
#include "nbfprocs.h"                   // private NETBEUI function prototypes.
#ifdef MEMPRINT
#include "memprint.h"                   // drt's memory debug print
#endif


#ifndef NBF_LOCKS

#define ACQUIRE_SPIN_LOCK(lock,irql) KeAcquireSpinLock(lock,irql)
#define RELEASE_SPIN_LOCK(lock,irql) KeReleaseSpinLock(lock,irql)

#if 0
#define ACQUIRE_DPC_SPIN_LOCK(lock) \
    { KIRQL OldIrql; ASSERT ((lock != NULL) && (KeGetCurrentIrql() == DISPATCH_LEVEL)); KeAcquireSpinLock(lock,&OldIrql); }
#define RELEASE_DPC_SPIN_LOCK(lock) \
    { ASSERT(lock != NULL); KeReleaseSpinLock(lock,DISPATCH_LEVEL); }
#else
#define ACQUIRE_DPC_SPIN_LOCK(lock) KeAcquireSpinLockAtDpcLevel(lock)
#define RELEASE_DPC_SPIN_LOCK(lock) KeReleaseSpinLockFromDpcLevel(lock)
#endif

#define ENTER_NBF
#define LEAVE_NBF

#else

VOID
NbfAcquireSpinLock(
    IN PKSPIN_LOCK Lock,
    OUT PKIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    );

VOID
NbfReleaseSpinLock(
    IN PKSPIN_LOCK Lock,
    IN KIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    );

#define ACQUIRE_SPIN_LOCK(lock,irql) \
    NbfAcquireSpinLock( lock, irql, #lock, __FILE__, __LINE__ )
#define RELEASE_SPIN_LOCK(lock,irql) \
    NbfReleaseSpinLock( lock, irql, #lock, __FILE__, __LINE__ )

#define ACQUIRE_DPC_SPIN_LOCK(lock) \
    { \
        KIRQL OldIrql; \
        NbfAcquireSpinLock( lock, &OldIrql, #lock, __FILE__, __LINE__ ); \
    }
#define RELEASE_DPC_SPIN_LOCK(lock) \
    NbfReleaseSpinLock( lock, DISPATCH_LEVEL, #lock, __FILE__, __LINE__ )

#define ENTER_NBF                   \
    NbfAcquireSpinLock( (PKSPIN_LOCK)NULL, (PKIRQL)NULL, "(Global)", __FILE__, __LINE__ )
#define LEAVE_NBF                   \
    NbfReleaseSpinLock( (PKSPIN_LOCK)NULL, (KIRQL)-1, "(Global)", __FILE__, __LINE__ )

#endif


#endif // def _NBF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfcnfg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbfconfig.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of NBF. Note that the parts of this file that are
    called at initialization time will be replaced by calls to the configuration manager over time.

Author:

    David Beaver (dbeaver) 13-Feb-1991

Revision History:

    David Beaver (dbeaver) 1-July-1991
        modified to use new tdi interface

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local functions used to access the registry.
//

VOID
NbfFreeConfigurationInfo (
    IN PCONFIG_DATA ConfigurationInfo
    );

NTSTATUS
NbfOpenParametersKey(
    IN HANDLE NbfConfigHandle,
    OUT PHANDLE ParametersHandle
    );

VOID
NbfCloseParametersKey(
    IN HANDLE ParametersHandle
    );

NTSTATUS
NbfCountEntries(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbfAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbfAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
NbfReadLinkageInformation(
    IN PWSTR RegistryPathBuffer,
    IN PCONFIG_DATA * ConfigurationInfo
    );

ULONG
NbfReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue
    );

VOID
NbfWriteSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG ValueData
    );

UINT
NbfWstrLength(
    IN PWSTR Wstr
    );

NTSTATUS
NbfMatchBindName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
NbfExportAtIndex(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbfWstrLength)
#pragma alloc_text(PAGE,NbfConfigureTransport)
#pragma alloc_text(PAGE,NbfFreeConfigurationInfo)
#pragma alloc_text(PAGE,NbfOpenParametersKey)
#pragma alloc_text(PAGE,NbfCloseParametersKey)
#pragma alloc_text(PAGE,NbfCountEntries)
#pragma alloc_text(PAGE,NbfAddBind)
#pragma alloc_text(PAGE,NbfAddExport)
#pragma alloc_text(PAGE,NbfReadLinkageInformation)
#pragma alloc_text(PAGE,NbfReadSingleParameter)
#pragma alloc_text(PAGE,NbfWriteSingleParameter)
#endif

UINT
NbfWstrLength(
    IN PWSTR Wstr
    )
{
    UINT Length = 0;
    while (*Wstr++) {
        Length += sizeof(WCHAR);
    }
    return Length;
}

#define InsertAdapter(ConfigurationInfo, Subscript, Name)                \
{ \
    PWSTR _S; \
    PWSTR _N = (Name); \
    UINT _L = NbfWstrLength(_N)+sizeof(WCHAR); \
    _S = (PWSTR)ExAllocatePoolWithTag(NonPagedPool, _L, NBF_MEM_TAG_DEVICE_EXPORT); \
    if (_S != NULL) { \
        RtlCopyMemory(_S, _N, _L); \
        RtlInitUnicodeString (&(ConfigurationInfo)->Names[Subscript], _S); \
    } \
}

#define InsertDevice(ConfigurationInfo, Subscript, Name)                \
{ \
    PWSTR _S; \
    PWSTR _N = (Name); \
    UINT _L = NbfWstrLength(_N)+sizeof(WCHAR); \
    _S = (PWSTR)ExAllocatePoolWithTag(NonPagedPool, _L, NBF_MEM_TAG_DEVICE_EXPORT); \
    if (_S != NULL) { \
        RtlCopyMemory(_S, _N, _L); \
        RtlInitUnicodeString (&(ConfigurationInfo)->Names[(ConfigurationInfo)->DevicesOffset+Subscript], _S); \
    } \
}


#define RemoveAdapter(ConfigurationInfo, Subscript)                \
    ExFreePool ((ConfigurationInfo)->Names[Subscript].Buffer)

#define RemoveDevice(ConfigurationInfo, Subscript)                \
    ExFreePool ((ConfigurationInfo)->Names[(ConfigurationInfo)->DevicesOffset+Subscript].Buffer)



//
// These strings are used in various places by the registry.
//

#define DECLARE_STRING(_str_) WCHAR Str ## _str_[] = L#_str_


#define READ_HIDDEN_CONFIG(_Field) \
{ \
    ConfigurationInfo->_Field = \
        NbfReadSingleParameter( \
             ParametersHandle, \
             Str ## _Field, \
             ConfigurationInfo->_Field); \
}

#define WRITE_HIDDEN_CONFIG(_Field) \
{ \
    NbfWriteSingleParameter( \
        ParametersHandle, \
        Str ## _Field, \
        ConfigurationInfo->_Field); \
}



NTSTATUS
NbfConfigureTransport (
    IN PUNICODE_STRING RegistryPath,
    IN PCONFIG_DATA * ConfigurationInfoPtr
    )
/*++

Routine Description:

    This routine is called by NBF to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in nbfcnfg.h file.

Arguments:

    RegistryPath - The name of NBF's node in the registry.

    ConfigurationInfoPtr - A pointer to the configuration information structure.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{

    NTSTATUS OpenStatus;
    HANDLE ParametersHandle;
    HANDLE NbfConfigHandle;
    NTSTATUS Status;
    ULONG Disposition;
    PWSTR RegistryPathBuffer;
    OBJECT_ATTRIBUTES TmpObjectAttributes;
    PCONFIG_DATA ConfigurationInfo;

    DECLARE_STRING(InitRequests);
    DECLARE_STRING(InitLinks);
    DECLARE_STRING(InitConnections);
    DECLARE_STRING(InitAddressFiles);
    DECLARE_STRING(InitAddresses);

    DECLARE_STRING(MaxRequests);
    DECLARE_STRING(MaxLinks);
    DECLARE_STRING(MaxConnections);
    DECLARE_STRING(MaxAddressFiles);
    DECLARE_STRING(MaxAddresses);

    DECLARE_STRING(InitPackets);
    DECLARE_STRING(InitReceivePackets);
    DECLARE_STRING(InitReceiveBuffers);
    DECLARE_STRING(InitUIFrames);

    DECLARE_STRING(SendPacketPoolSize);
    DECLARE_STRING(ReceivePacketPoolSize);
    DECLARE_STRING(MaxMemoryUsage);

    DECLARE_STRING(MinimumT1Timeout);
    DECLARE_STRING(DefaultT1Timeout);
    DECLARE_STRING(DefaultT2Timeout);
    DECLARE_STRING(DefaultTiTimeout);
    DECLARE_STRING(LlcRetries);
    DECLARE_STRING(LlcMaxWindowSize);
    DECLARE_STRING(MaximumIncomingFrames);

    DECLARE_STRING(NameQueryRetries);
    DECLARE_STRING(NameQueryTimeout);
    DECLARE_STRING(AddNameQueryRetries);
    DECLARE_STRING(AddNameQueryTimeout);
    DECLARE_STRING(GeneralRetries);
    DECLARE_STRING(GeneralTimeout);
    DECLARE_STRING(WanNameQueryRetries);

    DECLARE_STRING(UseDixOverEthernet);
    DECLARE_STRING(QueryWithoutSourceRouting);
    DECLARE_STRING(AllRoutesNameRecognized);
    DECLARE_STRING(MinimumSendWindowLimit);

    //
    // Open the registry.
    //

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwCreateKey(
                 &NbfConfigHandle,
                 KEY_WRITE,
                 &TmpObjectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &Disposition);     // disposition

    if (!NT_SUCCESS(Status)) {
        NbfPrint1("NBF: Could not open/create NBF key: %lx\n", Status);
        return Status;
    }

    IF_NBFDBG (NBF_DEBUG_REGISTRY) {
        NbfPrint2("%s NBF key: %lx\n",
            (Disposition == REG_CREATED_NEW_KEY) ? "created" : "opened",
            NbfConfigHandle);
    }


    OpenStatus = NbfOpenParametersKey (NbfConfigHandle, &ParametersHandle);

    if (OpenStatus != STATUS_SUCCESS) {
        return OpenStatus;
    }

    //
    // Read in the NDIS binding information (if none is present
    // the array will be filled with all known drivers).
    //
    // NbfReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    //

    RegistryPathBuffer = (PWSTR)ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    RegistryPath->Length + sizeof(WCHAR),
                                    NBF_MEM_TAG_REGISTRY_PATH);
    if (RegistryPathBuffer == NULL) {
        NbfCloseParametersKey (ParametersHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    NbfReadLinkageInformation (RegistryPathBuffer, ConfigurationInfoPtr);

    if (*ConfigurationInfoPtr == NULL) {
        ExFreePool (RegistryPathBuffer);
        NbfCloseParametersKey (ParametersHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ConfigurationInfo = *ConfigurationInfoPtr;


    //
    // Configure the initial values for some NBF resources.
    //

    ConfigurationInfo->InitRequests = 1;
    ConfigurationInfo->InitLinks = 2;
    ConfigurationInfo->InitConnections = 2;
    ConfigurationInfo->InitAddressFiles = 0;
    ConfigurationInfo->InitAddresses = 0;

    //
    // These are the initial values; remember that the
    // resources above also allocate some of these each
    // time they are allocated (shown in the comment).
    //

    ConfigurationInfo->InitPackets = 30;         // + link + 2*conn
    ConfigurationInfo->InitReceivePackets = 10;  // + link + addr
    ConfigurationInfo->InitReceiveBuffers = 5;   // + addr
    ConfigurationInfo->InitUIFrames = 5;         // + addr + conn

    //
    // Set the size of the packet pools and the total
    // allocateable by NBF.
    //

    ConfigurationInfo->SendPacketPoolSize = 100;
    ConfigurationInfo->ReceivePacketPoolSize = 30;
    ConfigurationInfo->MaxMemoryUsage = 0;       // no limit


    //
    // Now initialize the timeout etc. values.
    //
    
    ConfigurationInfo->MinimumT1Timeout = DLC_MINIMUM_T1;
    ConfigurationInfo->DefaultT1Timeout = DLC_DEFAULT_T1;
    ConfigurationInfo->DefaultT2Timeout = DLC_DEFAULT_T2;
    ConfigurationInfo->DefaultTiTimeout = DLC_DEFAULT_TI;
    ConfigurationInfo->LlcRetries = DLC_RETRIES;
    ConfigurationInfo->LlcMaxWindowSize = DLC_WINDOW_LIMIT;
    ConfigurationInfo->MaximumIncomingFrames = 4;
    ConfigurationInfo->NameQueryRetries = NAME_QUERY_RETRIES;
    ConfigurationInfo->NameQueryTimeout = NAME_QUERY_TIMEOUT;
    ConfigurationInfo->AddNameQueryRetries = ADD_NAME_QUERY_RETRIES;
    ConfigurationInfo->AddNameQueryTimeout = ADD_NAME_QUERY_TIMEOUT;
    ConfigurationInfo->GeneralRetries = NAME_QUERY_RETRIES;
    ConfigurationInfo->GeneralTimeout = NAME_QUERY_TIMEOUT;
    ConfigurationInfo->WanNameQueryRetries = WAN_NAME_QUERY_RETRIES;

    ConfigurationInfo->UseDixOverEthernet = 0;
    ConfigurationInfo->QueryWithoutSourceRouting = 0;
    ConfigurationInfo->AllRoutesNameRecognized = 0;
    ConfigurationInfo->MinimumSendWindowLimit = 2;


    //
    // Now read the optional "hidden" parameters; if these do
    // not exist then the current values are used. Note that
    // the current values will be 0 unless they have been
    // explicitly initialized above.
    //
    // NOTE: These macros expect "ConfigurationInfo" and
    // "ParametersHandle" to exist when they are expanded.
    //

    READ_HIDDEN_CONFIG (InitRequests);
    READ_HIDDEN_CONFIG (InitLinks);
    READ_HIDDEN_CONFIG (InitConnections);
    READ_HIDDEN_CONFIG (InitAddressFiles);
    READ_HIDDEN_CONFIG (InitAddresses);

    READ_HIDDEN_CONFIG (MaxRequests);
    READ_HIDDEN_CONFIG (MaxLinks);
    READ_HIDDEN_CONFIG (MaxConnections);
    READ_HIDDEN_CONFIG (MaxAddressFiles);
    READ_HIDDEN_CONFIG (MaxAddresses);

    READ_HIDDEN_CONFIG (InitPackets);
    READ_HIDDEN_CONFIG (InitReceivePackets);
    READ_HIDDEN_CONFIG (InitReceiveBuffers);
    READ_HIDDEN_CONFIG (InitUIFrames);

    READ_HIDDEN_CONFIG (SendPacketPoolSize);
    READ_HIDDEN_CONFIG (ReceivePacketPoolSize);
    READ_HIDDEN_CONFIG (MaxMemoryUsage);

    READ_HIDDEN_CONFIG (MinimumT1Timeout);
    READ_HIDDEN_CONFIG (DefaultT1Timeout);
    READ_HIDDEN_CONFIG (DefaultT2Timeout);
    READ_HIDDEN_CONFIG (DefaultTiTimeout);
    READ_HIDDEN_CONFIG (LlcRetries);
    READ_HIDDEN_CONFIG (LlcMaxWindowSize);
    READ_HIDDEN_CONFIG (MaximumIncomingFrames);

    READ_HIDDEN_CONFIG (NameQueryRetries);
    READ_HIDDEN_CONFIG (NameQueryTimeout);
    READ_HIDDEN_CONFIG (AddNameQueryRetries);
    READ_HIDDEN_CONFIG (AddNameQueryTimeout);
    READ_HIDDEN_CONFIG (GeneralRetries);
    READ_HIDDEN_CONFIG (GeneralTimeout);
    READ_HIDDEN_CONFIG (WanNameQueryRetries);

    READ_HIDDEN_CONFIG (UseDixOverEthernet);
    READ_HIDDEN_CONFIG (QueryWithoutSourceRouting);
    READ_HIDDEN_CONFIG (AllRoutesNameRecognized);
    READ_HIDDEN_CONFIG (MinimumSendWindowLimit);


    //
    // Print out some config info, to make sure it is read right.
    //

    IF_NBFDBG (NBF_DEBUG_REGISTRY) {
       NbfPrint2("Links: init %d, max %d\n",
                     ConfigurationInfo->InitLinks,
                     ConfigurationInfo->MaxLinks);
       NbfPrint3("Timeouts (NBF ticks): T1 %d, T2 %d, Ti %d\n",
                     ConfigurationInfo->DefaultT1Timeout / SHORT_TIMER_DELTA,
                     ConfigurationInfo->DefaultT2Timeout / SHORT_TIMER_DELTA,
                     ConfigurationInfo->DefaultTiTimeout / LONG_TIMER_DELTA);
       NbfPrint2("Pools: send %d, receive %d\n",
                     ConfigurationInfo->SendPacketPoolSize,
                     ConfigurationInfo->ReceivePacketPoolSize);
       NbfPrint1("Max mem %d\n",
                     ConfigurationInfo->MaxMemoryUsage);
       NbfPrint2("NQRetries %d, NQTimeout %d\n",
                     ConfigurationInfo->NameQueryRetries,
                     ConfigurationInfo->NameQueryTimeout / SHORT_TIMER_DELTA);
    }

    //
    // Save the "hidden" parameters, these may not exist in
    // the registry.
    //
    // NOTE: These macros expect "ConfigurationInfo" and
    // "ParametersHandle" to exist when they are expanded.
    //

    //
    // 5/22/92 - don't write the parameters that are set
    // based on Size, since otherwise these will overwrite
    // those values since hidden parameters are set up
    // after the Size-based configuration is done.
    //

    WRITE_HIDDEN_CONFIG (MaxRequests);
    WRITE_HIDDEN_CONFIG (MaxLinks);
    WRITE_HIDDEN_CONFIG (MaxConnections);
    WRITE_HIDDEN_CONFIG (MaxAddressFiles);
    WRITE_HIDDEN_CONFIG (MaxAddresses);

    WRITE_HIDDEN_CONFIG (MinimumT1Timeout);
    WRITE_HIDDEN_CONFIG (DefaultT1Timeout);
    WRITE_HIDDEN_CONFIG (DefaultT2Timeout);
    WRITE_HIDDEN_CONFIG (DefaultTiTimeout);
    WRITE_HIDDEN_CONFIG (LlcRetries);
    WRITE_HIDDEN_CONFIG (LlcMaxWindowSize);
    WRITE_HIDDEN_CONFIG (MaximumIncomingFrames);

    WRITE_HIDDEN_CONFIG (NameQueryRetries);
    WRITE_HIDDEN_CONFIG (NameQueryTimeout);
    WRITE_HIDDEN_CONFIG (AddNameQueryRetries);
    WRITE_HIDDEN_CONFIG (AddNameQueryTimeout);
    WRITE_HIDDEN_CONFIG (GeneralRetries);
    WRITE_HIDDEN_CONFIG (GeneralTimeout);
    WRITE_HIDDEN_CONFIG (WanNameQueryRetries);

    WRITE_HIDDEN_CONFIG (UseDixOverEthernet);
    WRITE_HIDDEN_CONFIG (QueryWithoutSourceRouting);
    WRITE_HIDDEN_CONFIG (AllRoutesNameRecognized);

    // ZwFlushKey (ParametersHandle);

    ExFreePool (RegistryPathBuffer);
    NbfCloseParametersKey (ParametersHandle);
    ZwClose (NbfConfigHandle);

    return STATUS_SUCCESS;

}   /* NbfConfigureTransport */


VOID
NbfFreeConfigurationInfo (
    IN PCONFIG_DATA ConfigurationInfo
    )

/*++

Routine Description:

    This routine is called by NBF to get free any storage that was allocated
    by NbfConfigureTransport in producing the specified CONFIG_DATA structure.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    UINT i;

    for (i=0; i<ConfigurationInfo->NumAdapters; i++) {
        RemoveAdapter (ConfigurationInfo, i);
        RemoveDevice (ConfigurationInfo, i);
    }
    ExFreePool (ConfigurationInfo);

}   /* NbfFreeConfigurationInfo */


NTSTATUS
NbfOpenParametersKey(
    IN HANDLE NbfConfigHandle,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by NBF to open the NBF "Parameters" key.

Arguments:

    ParametersHandle - Returns the handle used to read parameters.

Return Value:

    The status of the request.

--*/
{

    NTSTATUS Status;
    HANDLE ParamHandle;
    PWSTR ParametersString = L"Parameters";
    UNICODE_STRING ParametersKeyName;
    OBJECT_ATTRIBUTES TmpObjectAttributes;

    //
    // Open the NBF parameters key.
    //

    RtlInitUnicodeString (&ParametersKeyName, ParametersString);

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        &ParametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NbfConfigHandle,            // root
        NULL                        // security descriptor
        );


    Status = ZwOpenKey(
                 &ParamHandle,
                 KEY_READ,
                 &TmpObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        NbfPrint1("Could not open parameters key: %lx\n", Status);
        return Status;

    }

    IF_NBFDBG (NBF_DEBUG_REGISTRY) {
        NbfPrint1("Opened parameters key: %lx\n", ParamHandle);
    }


    *ParametersHandle = ParamHandle;


    //
    // All keys successfully opened or created.
    //

    return STATUS_SUCCESS;

}   /* NbfOpenParametersKey */

VOID
NbfCloseParametersKey(
    IN HANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by NBF to close the "Parameters" key.
    It closes the handles passed in and does any other work needed.

Arguments:

    ParametersHandle - The handle used to read other parameters.

Return Value:

    None.

--*/

{

    ZwClose (ParametersHandle);

}   /* NbfCloseParametersKey */


NTSTATUS
NbfCountEntries(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called with the "Bind" and "Export" multi-strings.
    It counts the number of name entries required in the
    CONFIGURATION_DATA structure and then allocates it.

Arguments:

    ValueName - The name of the value ("Bind" or "Export" -- ignored).

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to a pointer to the ConfigurationInfo structure.
        When the "Export" callback is made this is filled in
        with the allocate structure.

    EntryContext - A pointer to a counter holding the total number
        of name entries required.

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG StringCount;
    PWCHAR ValuePointer = (PWCHAR)ValueData;
    PCONFIG_DATA * ConfigurationInfo = (PCONFIG_DATA *)Context;
    PULONG TotalCount = ((PULONG)EntryContext);
    ULONG OldTotalCount = *TotalCount;

#if DBG
    ASSERT (ValueType == REG_MULTI_SZ);
#else
    UNREFERENCED_PARAMETER(ValueType);
#endif

    //
    // Count the number of strings in the multi-string; first
    // check that it is NULL-terminated to make the rest
    // easier.
    //

    if ((ValueLength < 2) ||
        (ValuePointer[(ValueLength/2)-1] != (WCHAR)'\0')) {
        return STATUS_INVALID_PARAMETER;
    }

    StringCount = 0;
    while (*ValuePointer != (WCHAR)'\0') {
        while (*ValuePointer != (WCHAR)'\0') {
            ++ValuePointer;
        }
        ++StringCount;
        ++ValuePointer;
        if ((ULONG)((PUCHAR)ValuePointer - (PUCHAR)ValueData) >= ValueLength) {
            break;
        }
    }

    (*TotalCount) += StringCount;

    if (*ValueName == (WCHAR)'E') {

        //
        // This is "Export", allocate the config data structure.
        //

        *ConfigurationInfo = ExAllocatePoolWithTag(
                                 NonPagedPool,
                                 sizeof (CONFIG_DATA) +
                                     ((*TotalCount-1) * sizeof(NDIS_STRING)),
                                 NBF_MEM_TAG_CONFIG_DATA);

        if (*ConfigurationInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(
            *ConfigurationInfo,
            sizeof(CONFIG_DATA) + ((*TotalCount-1) * sizeof(NDIS_STRING)));

        (*ConfigurationInfo)->DevicesOffset = OldTotalCount;

    }

    return STATUS_SUCCESS;

}   /* NbfCountEntries */


NTSTATUS
NbfAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Bind" multi-string and
    saves the information in a ConfigurationInfo structure.

Arguments:

    ValueName - The name of the value ("Bind" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the ConfigurationInfo structure.

    EntryContext - A pointer to a count of binds that is incremented.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG_DATA ConfigurationInfo = *(PCONFIG_DATA *)Context;
    PULONG CurBindNum = ((PULONG)EntryContext);

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    InsertAdapter(
        ConfigurationInfo,
        *CurBindNum,
        (PWSTR)(ValueData));

    ++(*CurBindNum);

    return STATUS_SUCCESS;

}   /* NbfAddBind */


NTSTATUS
NbfAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string and
    saves the information in a ConfigurationInfo structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the ConfigurationInfo structure.

    EntryContext - A pointer to a count of exports that is incremented.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG_DATA ConfigurationInfo = *(PCONFIG_DATA *)Context;
    PULONG CurExportNum = ((PULONG)EntryContext);

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    InsertDevice(
        ConfigurationInfo,
        *CurExportNum,
        (PWSTR)(ValueData));

    ++(*CurExportNum);

    return STATUS_SUCCESS;

}   /* NbfAddExport */


VOID
NbfReadLinkageInformation(
    IN PWSTR RegistryPathBuffer,
    IN PCONFIG_DATA * ConfigurationInfo
    )

/*++

Routine Description:

    This routine is called by NBF to read its linkage information
    from the registry. If there is none present, then ConfigData
    is filled with a list of all the adapters that are known
    to NBF.

Arguments:

    RegistryPathBuffer - The null-terminated root of the NBF registry tree.

    ConfigurationInfo - Returns NBF's current configuration.

Return Value:

    None.

--*/

{

    UINT ConfigBindings;
    UINT NameCount = 0;
    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[6];
    PWSTR Subkey = L"Linkage";
    PWSTR Bind = L"Bind";
    PWSTR Export = L"Export";
    ULONG BindCount, ExportCount;
    UINT i;


    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below NBF
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call NbfCountEntries for the "Bind" multi-string
    //

    QueryTable[1].QueryRoutine = NbfCountEntries;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[1].Name = Bind;
    QueryTable[1].EntryContext = (PVOID)&NameCount;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Call NbfCountEntries for the "Export" multi-string
    //

    QueryTable[2].QueryRoutine = NbfCountEntries;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[2].Name = Export;
    QueryTable[2].EntryContext = (PVOID)&NameCount;
    QueryTable[2].DefaultType = REG_NONE;

    //
    // 4) Call NbfAddBind for each string in "Bind"
    //

    QueryTable[3].QueryRoutine = NbfAddBind;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = Bind;
    QueryTable[3].EntryContext = (PVOID)&BindCount;
    QueryTable[3].DefaultType = REG_NONE;

    //
    // 5) Call NbfAddExport for each string in "Export"
    //

    QueryTable[4].QueryRoutine = NbfAddExport;
    QueryTable[4].Flags = 0;
    QueryTable[4].Name = Export;
    QueryTable[4].EntryContext = (PVOID)&ExportCount;
    QueryTable[4].DefaultType = REG_NONE;

    //
    // 6) Stop
    //

    QueryTable[5].QueryRoutine = NULL;
    QueryTable[5].Flags = 0;
    QueryTable[5].Name = NULL;


    BindCount = 0;
    ExportCount = 0;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 RegistryPathBuffer,
                 QueryTable,
                 (PVOID)ConfigurationInfo,
                 NULL);

    if (Status != STATUS_SUCCESS) {
        return;
    }

    //
    // Make sure that BindCount and ExportCount match, if not
    // remove the extras.
    //

    if (BindCount < ExportCount) {

        for (i=BindCount; i<ExportCount; i++) {
            RemoveDevice (*ConfigurationInfo, i);
        }
        ConfigBindings = BindCount;

    } else if (ExportCount < BindCount) {

        for (i=ExportCount; i<BindCount; i++) {
            RemoveAdapter (*ConfigurationInfo, i);
        }
        ConfigBindings = ExportCount;

    } else {

        ConfigBindings = BindCount;      // which is equal to ExportCount

    }

    (*ConfigurationInfo)->NumAdapters = ConfigBindings;

}   /* NbfReadLinkageInformation */


ULONG
NbfReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by NBF to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    ULONG InformationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION Information =
        (PKEY_VALUE_FULL_INFORMATION)InformationBuffer;
    UNICODE_STRING ValueKeyName;
    ULONG InformationLength;
    ULONG ReturnValue;
    NTSTATUS Status;

    RtlInitUnicodeString (&ValueKeyName, ValueName);

    Status = ZwQueryValueKey(
                 ParametersHandle,
                 &ValueKeyName,
                 KeyValueFullInformation,
                 (PVOID)Information,
                 sizeof (InformationBuffer),
                 &InformationLength);

    if ((Status == STATUS_SUCCESS) &&
        (Information->DataLength == sizeof(ULONG))) {

        RtlCopyMemory(
            (PVOID)&ReturnValue,
            ((PUCHAR)Information) + Information->DataOffset,
            sizeof(ULONG));

        if ((LONG)ReturnValue < 0) {

            ReturnValue = DefaultValue;

        }

    } else {

        ReturnValue = DefaultValue;

    }

    return ReturnValue;

}   /* NbfReadSingleParameter */


VOID
NbfWriteSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG ValueData
    )

/*++

Routine Description:

    This routine is called by NBF to write a single parameter
    from the registry.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to store.

    ValueData - The data to store at the value.

Return Value:

    None.

--*/

{
    UNICODE_STRING ValueKeyName;
    NTSTATUS Status;
    ULONG TmpValueData = ValueData;

    RtlInitUnicodeString (&ValueKeyName, ValueName);

    Status = ZwSetValueKey(
                 ParametersHandle,
                 &ValueKeyName,
                 0,
                 REG_DWORD,
                 (PVOID)&TmpValueData,
                 sizeof(ULONG));

    if (!NT_SUCCESS(Status)) {
        NbfPrint1("NBF: Could not write dword key: %lx\n", Status);
    }

}   /* NbfWriteSingleParameter */


NTSTATUS
NbfGetExportNameFromRegistry(
    IN  PUNICODE_STRING RegistryPath,
    IN  PUNICODE_STRING BindName,
    OUT PUNICODE_STRING ExportName
    )
{
    NTSTATUS OpenStatus;
    HANDLE ParametersHandle;
    HANDLE NbfConfigHandle;
    NTSTATUS Status;
    PWSTR RegistryPathBuffer;
    OBJECT_ATTRIBUTES TmpObjectAttributes;
    
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWSTR Subkey = L"Linkage";
    PWSTR Bind = L"Bind";
    PWSTR Export = L"Export";
    LONG BindNumber;

    //
    // Open the registry.
    //

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    OpenStatus = ZwOpenKey(
                     &NbfConfigHandle,
                     KEY_WRITE,
                     &TmpObjectAttributes
                     );

    if (!NT_SUCCESS(OpenStatus)) {
        NbfPrint1("NBF: Could not open NBF key: %lx\n", OpenStatus);
        return OpenStatus;
    }

    Status = NbfOpenParametersKey (NbfConfigHandle, &ParametersHandle);

    if (Status != STATUS_SUCCESS) {
        ZwClose (NbfConfigHandle);
        return Status;
    }

    //
    // NbfReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    //

    RegistryPathBuffer = (PWSTR)ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    RegistryPath->Length + sizeof(WCHAR),
                                    NBF_MEM_TAG_REGISTRY_PATH);
                                    
    if (RegistryPathBuffer == NULL) {
        NbfCloseParametersKey (ParametersHandle);
        ZwClose (NbfConfigHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    //
    // We have a new device whose binding was absent 
    // at boot - get export name given the bind name
    //

    // First we need to get index of the bind name
    
    // Set up QueryTable to do the following:

    //
    // 1) Switch to the Linkage key below NBF
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call NbfMatchBindName for each string in "Bind"
    //

    QueryTable[1].QueryRoutine = NbfMatchBindName;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = Bind;
    QueryTable[1].EntryContext = (PVOID)&BindNumber;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Stop
    //

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;


    BindNumber = -1;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 RegistryPathBuffer,
                 QueryTable,
                 (PVOID)BindName,
                 NULL);

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint2 ("Status from NbfMatchBindName's = %08x, Bind Number = %d\n",
                        Status, BindNumber);
    }

    if (Status != STATUS_NO_MORE_MATCHES)
    {
#if DBG
        DbgBreakPoint();
#endif
    
        if (Status == STATUS_SUCCESS) {
        
            // We did not find the device 'bind name'
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            
            IF_NBFDBG (NBF_DEBUG_PNP) {
                NbfPrint1 ("NBF - cannot find dynamic binding %S\n", BindName->Buffer);
            }
        }

        goto Done;
    }
    
    ASSERT(BindNumber >= 0);

    // First we need to get export name given index
    
    // Set up QueryTable to do the following:

    //
    // 1) Switch to the Linkage key below NBF
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call NbfAddExport for each string in "Export"
    //

    QueryTable[1].QueryRoutine = NbfExportAtIndex;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = Export;
    QueryTable[1].EntryContext = (PVOID)&BindNumber;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Stop
    //

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    RtlInitUnicodeString(ExportName, NULL);

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 RegistryPathBuffer,
                 QueryTable,
                 (PVOID)ExportName,
                 NULL);

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint2("Status from NbfExportAtIndex's = %08x, ExportLength = %d\n",
                        Status,
                        ExportName->Length);

        if (ExportName->Length > 0)
        {
            NbfPrint1("ExportName = %S\n", ExportName->Buffer);
        }
    }

    if (ExportName->Length != 0) {

        ASSERT(Status == STATUS_NO_MORE_MATCHES);
        
        Status = STATUS_SUCCESS;
    }
    else {
    
        // We found the bind, but no corr export  
        Status = NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER;
    }

Done:

    ExFreePool (RegistryPathBuffer);
    
    NbfCloseParametersKey (ParametersHandle);
    
    ZwClose (NbfConfigHandle);

    return Status;
}


NTSTATUS
NbfMatchBindName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Bind" multi-string and
    tries to match a given bind name with each of these pieces.

Arguments:

    ValueName - The name of the value ("Bind" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - Bind name that we are trying to match.

    EntryContext - A pointer where index of the match is stored.

Return Value:

    STATUS_SUCCESS

--*/

{
    PUNICODE_STRING BindName = (PUNICODE_STRING) Context;
    PLONG CurBindNum = (PLONG) EntryContext;
    UNICODE_STRING ValueString;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    RtlInitUnicodeString(&ValueString, ValueData);

    // We are yet to find a match

    (*CurBindNum)++ ;
    
    if (NdisEqualString(BindName, &ValueString, TRUE)) {
        return STATUS_NO_MORE_MATCHES;
    }

    return STATUS_SUCCESS;
    
}   /* NbfMatchBindName */

NTSTATUS
NbfExportAtIndex(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PUNICODE_STRING ExportName = (PUNICODE_STRING) Context;
    PLONG CurBindNum = (PLONG) EntryContext;
    PWSTR ValueWideChars;
    UINT ValueWideLength;    
    UNICODE_STRING ValueString;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);

    ASSERT(*CurBindNum >= 0);

    if (*CurBindNum == 0)
    {
        ValueWideLength = NbfWstrLength(ValueData) + sizeof(WCHAR);

        ValueWideChars = (PWSTR) ExAllocatePoolWithTag(NonPagedPool, 
                                                       ValueWideLength, 
                                                       NBF_MEM_TAG_DEVICE_EXPORT);
        if (ValueWideChars == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        RtlCopyMemory (ValueWideChars, ValueData, ValueWideLength);
        
        RtlInitUnicodeString (ExportName, ValueWideChars);

        return STATUS_NO_MORE_MATCHES;
    }
    
    (*CurBindNum)-- ;
    
    return STATUS_SUCCESS;
    
}   /* NbfExportAtIndex */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbfdebug.c

Abstract:

    This module contains code that implements debug things for NBF. It is
    compiled only if debug is on in the compile phase.

Author:

    David Beaver (dbeaver) 18-Apr-1991

Environment:

    Kernel mode

Revision History:

    David Beaver (dbeaver) 1-July-1991
        modified to use new TDI interface

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG

VOID
DisplayOneFrame(
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine is a temporary debugging aid that displays an I-frame
    before it is sent.  This ensures that we have formatted all our packets
    correctly.

Arguments:

    Packet - Pointer to a TP_PACKET representing an I-frame to be displayed.

Return Value:

    none.

--*/

{
    PCH s, e;
    ULONG ns, nr;                       // I-frame (NetBIOS) cracking.
    PNBF_HDR_CONNECTION NbfHeader;
    PDLC_I_FRAME DlcHeader;
    BOOLEAN Command, PollFinal;
    BOOLEAN IsUFrame=FALSE;
    UCHAR CmdByte;

    PDLC_S_FRAME SFrame;                // DLC frame cracking.
    PDLC_U_FRAME UFrame;

    DlcHeader = (PDLC_I_FRAME)&(Packet->Header[14]);
    NbfHeader = (PNBF_HDR_CONNECTION)&(Packet->Header[18]);
    ns = DlcHeader->SendSeq >> 1;
    nr = DlcHeader->RcvSeq >> 1;
    PollFinal = (BOOLEAN)(DlcHeader->RcvSeq & DLC_I_PF);
    Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);

    if (DlcHeader->SendSeq & DLC_I_INDICATOR) {
        IF_NBFDBG (NBF_DEBUG_DLCFRAMES) {
        } else {
            return;                     // if DLCFRAMES not set, don't print.
        }

        SFrame = (PDLC_S_FRAME)DlcHeader;         // alias.
        UFrame = (PDLC_U_FRAME)DlcHeader;         // alias.
        CmdByte = SFrame->Command;
        IsUFrame = (BOOLEAN)((UFrame->Command & DLC_U_INDICATOR) == DLC_U_INDICATOR);
        if (IsUFrame) {
            CmdByte = (UCHAR)(UFrame->Command & ~DLC_U_PF);
        }

        switch (CmdByte) {
            case DLC_CMD_RR:
                s = "RR";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_RNR:
                s = "RNR";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_REJ:
                s = "REJ";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_SABME:
                s = "SABME";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_DISC:
                s = "DISC";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_UA:
                s = "UA";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_DM:
                s = "DM";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_FRMR:
                s = "FRMR";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_XID:
                s = "XID";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_TEST:
                s = "TEST";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            default:
                s = "(UNKNOWN)";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
        }
        return;
    }

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
    } else {
        return;                         // if IFRAMES not set, don't print.
    }

    switch (NbfHeader->Command) {
        case NBF_CMD_ADD_GROUP_NAME_QUERY:
            s = "ADD_GROUP_NAME_QUERY"; break;

        case NBF_CMD_ADD_NAME_QUERY:
            s = "ADD_NAME_QUERY"; break;

        case NBF_CMD_NAME_IN_CONFLICT:
            s = "NAME_IN_CONFLICT"; break;

        case NBF_CMD_STATUS_QUERY:
            s = "STATUS_QUERY"; break;

        case NBF_CMD_TERMINATE_TRACE:
            s = "TERMINATE_TRACE"; break;

        case NBF_CMD_DATAGRAM:
            s = "DATAGRAM"; break;

        case NBF_CMD_DATAGRAM_BROADCAST:
            s = "BROADCAST_DATAGRAM"; break;

        case NBF_CMD_NAME_QUERY:
            s = "NAME_QUERY"; break;

        case NBF_CMD_ADD_NAME_RESPONSE:
            s = "ADD_NAME_RESPONSE"; break;

        case NBF_CMD_NAME_RECOGNIZED:
            s = "NAME_RECOGNIZED"; break;

        case NBF_CMD_STATUS_RESPONSE:
            s = "STATUS_RESPONSE"; break;

        case NBF_CMD_TERMINATE_TRACE2:
            s = "TERMINATE_TRACE2"; break;

        case NBF_CMD_DATA_ACK:
            s = "DATA_ACK"; break;

        case NBF_CMD_DATA_FIRST_MIDDLE:
            s = "DATA_FIRST_MIDDLE"; break;

        case NBF_CMD_DATA_ONLY_LAST:
            s = "DATA_ONLY_LAST"; break;

        case NBF_CMD_SESSION_CONFIRM:
            s = "SESSION_CONFIRM"; break;

        case NBF_CMD_SESSION_END:
            s = "SESSION_END"; break;

        case NBF_CMD_SESSION_INITIALIZE:
            s = "SESSION_INITIALIZE"; break;

        case NBF_CMD_NO_RECEIVE:
            s = "NO_RECEIVE"; break;

        case NBF_CMD_RECEIVE_OUTSTANDING:
            s = "RECEIVE_OUTSTANDING"; break;

        case NBF_CMD_RECEIVE_CONTINUE:
            s = "RECEIVE_CONTINUE"; break;

        case NBF_CMD_SESSION_ALIVE:
            s = "SESSION_ALIVE"; break;

        default:
            s = "<<<<UNKNOWN I PACKET TYPE>>>>";
    } /* switch */

    if (HEADER_LENGTH(NbfHeader) != 14) {
        e = "(LENGTH IN ERROR) ";
    } else if (HEADER_SIGNATURE(NbfHeader) != NETBIOS_SIGNATURE) {
        e = "(SIGNATURE IN ERROR) ";
    } else {
        e = "";
    }

    DbgPrint ("DLC:  I-%s/%s, N(S)=%ld, N(R)=%ld %s",
        Command ? "c" : "r",
        PollFinal ? (Command ? "p" : "f") : "0",
        ns, nr, e);
    DbgPrint (s);
    DbgPrint (" ( D1=%ld, D2=%ld, XC=%ld, RC=%ld )\n",
              (ULONG)NbfHeader->Data1,
              (ULONG)(NbfHeader->Data2Low+NbfHeader->Data2High*256),
              TRANSMIT_CORR(NbfHeader),
              RESPONSE_CORR(NbfHeader));
} /* DisplayOneFrame */


VOID
NbfDisplayUIFrame(
    PTP_UI_FRAME OuterFrame
    )

/*++

Routine Description:

    This routine is a temporary debugging aid that displays a UI frame
    before it is sent by NbfSendUIFrame.  This ensures that we have formatted
    all our UI frames correctly.

Arguments:

    RawFrame - Pointer to a connectionless frame to be sent.

Return Value:

    none.

--*/

{
    PCH s, e;
    UCHAR ReceiverName [17];
    UCHAR SenderName [17];
    BOOLEAN PollFinal, Command;
    PDLC_S_FRAME SFrame;
    PDLC_U_FRAME UFrame;
    USHORT i;
    PDLC_FRAME DlcHeader;
    PNBF_HDR_CONNECTIONLESS NbfHeader;

    //

    DlcHeader = (PDLC_FRAME)&(OuterFrame->Header[14]);
    NbfHeader = (PNBF_HDR_CONNECTIONLESS)&(OuterFrame->Header[17]);

    if (DlcHeader->Byte1 != DLC_CMD_UI) {

        IF_NBFDBG (NBF_DEBUG_DLCFRAMES) {
        } else {
            return;                     // don't print this if DLCFRAMES is off.
        }

        Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);
        SFrame = (PDLC_S_FRAME)DlcHeader;             // alias.
        UFrame = (PDLC_U_FRAME)DlcHeader;             // alias.
        switch (DlcHeader->Byte1) {
            case DLC_CMD_RR:
                s = "RR";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_RNR:
                s = "RNR";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_REJ:
                s = "REJ";
                PollFinal = (BOOLEAN)(SFrame->RcvSeq & DLC_S_PF);
                DbgPrint ("DLC:  %s-%s/%s(%ld) ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0",
                          (ULONG)(SFrame->RcvSeq >> 1));
                break;

            case DLC_CMD_SABME:
                s = "SABME";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_DISC:
                s = "DISC";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_UA:
                s = "UA";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_DM:
                s = "DM";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_FRMR:
                s = "FRMR";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_XID:
                s = "XID";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            case DLC_CMD_TEST:
                s = "TEST";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
                break;

            default:
                s = "(UNKNOWN)";
                PollFinal = (BOOLEAN)(UFrame->Command & DLC_U_PF);
                DbgPrint ("DLC:  %s-%s/%s ---->\n",
                          s,
                          Command ? "c" : "r",
                          PollFinal ? (Command ? "p" : "f") : "0");
        }
        return;
    }

    //
    // We know that this is an I-frame, because the bottom bit of the
    // first byte in the DLC header is cleared.  Go ahead and print it
    // as though it were a NetBIOS packet, which it should be.
    //

    IF_NBFDBG (NBF_DEBUG_IFRAMES) {
    } else {
        return;                         // don't print this if IFRAMES is off.
    }

    switch (NbfHeader->Command) {
        case NBF_CMD_ADD_GROUP_NAME_QUERY:
            s = "ADD_GROUP_NAME_QUERY"; break;

        case NBF_CMD_ADD_NAME_QUERY:
            s = "ADD_NAME_QUERY"; break;

        case NBF_CMD_NAME_IN_CONFLICT:
            s = "NAME_IN_CONFLICT"; break;

        case NBF_CMD_STATUS_QUERY:
            s = "STATUS_QUERY"; break;

        case NBF_CMD_TERMINATE_TRACE:
            s = "TERMINATE_TRACE"; break;

        case NBF_CMD_DATAGRAM:
            s = "DATAGRAM"; break;

        case NBF_CMD_DATAGRAM_BROADCAST:
            s = "BROADCAST_DATAGRAM"; break;

        case NBF_CMD_NAME_QUERY:
            s = "NAME_QUERY"; break;

        case NBF_CMD_ADD_NAME_RESPONSE:
            s = "ADD_NAME_RESPONSE"; break;

        case NBF_CMD_NAME_RECOGNIZED:
            s = "NAME_RECOGNIZED"; break;

        case NBF_CMD_STATUS_RESPONSE:
            s = "STATUS_RESPONSE"; break;

        case NBF_CMD_TERMINATE_TRACE2:
            s = "TERMINATE_TRACE2"; break;

        case NBF_CMD_DATA_ACK:
            s = "DATA_ACK"; break;

        case NBF_CMD_DATA_FIRST_MIDDLE:
            s = "DATA_FIRST_MIDDLE"; break;

        case NBF_CMD_DATA_ONLY_LAST:
            s = "DATA_ONLY_LAST"; break;

        case NBF_CMD_SESSION_CONFIRM:
            s = "SESSION_CONFIRM"; break;

        case NBF_CMD_SESSION_END:
            s = "SESSION_END"; break;

        case NBF_CMD_SESSION_INITIALIZE:
            s = "SESSION_INITIALIZE"; break;

        case NBF_CMD_NO_RECEIVE:
            s = "NO_RECEIVE"; break;

        case NBF_CMD_RECEIVE_OUTSTANDING:
            s = "RECEIVE_OUTSTANDING"; break;

        case NBF_CMD_RECEIVE_CONTINUE:
            s = "RECEIVE_CONTINUE"; break;

        case NBF_CMD_SESSION_ALIVE:
            s = "SESSION_ALIVE"; break;

        default:
            s = "<<<<UNKNOWN UI PACKET TYPE>>>>";
    } /* switch */

    for (i=0; i<16; i++) {              // copy NetBIOS names.
        SenderName [i] = NbfHeader->SourceName [i];
        ReceiverName [i] = NbfHeader->DestinationName [i];
    }
    SenderName [16] = 0;                // install zero bytes.
    ReceiverName [16] = 0;

    if (HEADER_LENGTH(NbfHeader) != 44) {
        e = "(LENGTH IN ERROR) ";
    } else if (HEADER_SIGNATURE(NbfHeader) != NETBIOS_SIGNATURE) {
        e = "(SIGNATURE IN ERROR) ";
    } else {
        e = "";
    }

    DbgPrint ("[UI] %s", e);
    DbgPrint (s);
    DbgPrint (" ( D1=%ld, D2=%ld, XC=%ld, RC=%ld, ",
              (ULONG)NbfHeader->Data1,
              (ULONG)(NbfHeader->Data2Low+NbfHeader->Data2High*256),
              TRANSMIT_CORR(NbfHeader),
              RESPONSE_CORR(NbfHeader));
    DbgPrint ("'%s'->'%s' ) ---->\n", SenderName, ReceiverName);
} /* NbfDisplayUIFrame */


VOID
NbfHexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}


VOID
NbfFormattedDump(
    PCHAR far_p,
    ULONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    while (len) {
        l = len < 16 ? len : 16;

        DbgPrint ("\n%lx ", far_p);
        NbfHexDumpLine (far_p, l, s, t);
        DbgPrint ("%s%.*s%s", s, 1 + ((16 - l) * 3), "", t);

        len    -= l;
        far_p  += l;
    }
    DbgPrint ("\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfdrvr.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    nbfdrvr.c

Abstract:

    This module contains code which defines the NetBIOS Frames Protocol
    transport provider's device object.

Author:

    David Beaver (dbeaver) 2-July-1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"

#pragma hdrstop

//
// This is a list of all the device contexts that NBF owns,
// used while unloading.
//

LIST_ENTRY NbfDeviceList = {0,0};   // initialized for real at runtime.

//
// And a lock that protects the global list of NBF devices
//
FAST_MUTEX NbfDevicesLock;

//
// Global variables this is a copy of the path in the registry for
// configuration data.
//

UNICODE_STRING NbfRegistryPath;

//
// We need the driver object to create device context structures.
//

PDRIVER_OBJECT NbfDriverObject;

//
// A handle to be used in all provider notifications to TDI layer
//
HANDLE         NbfProviderHandle;

//
// Global Configuration block for the driver ( no lock required )
//
PCONFIG_DATA   NbfConfig = NULL;

#ifdef NBF_LOCKS                    // see spnlckdb.c

extern KSPIN_LOCK NbfGlobalLock;

#endif // def NBF_LOCKS

//
// The debugging longword, containing a bitmask as defined in NBFCONST.H.
// If a bit is set, then debugging is turned on for that component.
//

#if DBG

ULONG NbfDebug = 0;
BOOLEAN NbfDisconnectDebug;

NBF_SEND NbfSends[TRACK_TDI_LIMIT+1];
LONG NbfSendsNext;

NBF_SEND_COMPLETE NbfCompletedSends[TRACK_TDI_LIMIT+1];
LONG NbfCompletedSendsNext;

NBF_RECEIVE NbfReceives[TRACK_TDI_LIMIT+1];
LONG NbfReceivesNext;

NBF_RECEIVE_COMPLETE NbfCompletedReceives[TRACK_TDI_LIMIT+1];
LONG NbfCompletedReceivesNext=0;

PVOID * NbfConnectionTable;
PVOID * NbfRequestTable;
PVOID * NbfUiFrameTable;
PVOID * NbfSendPacketTable;
PVOID * NbfLinkTable;
PVOID * NbfAddressFileTable;
PVOID * NbfAddressTable;


LIST_ENTRY NbfGlobalRequestList;
LIST_ENTRY NbfGlobalLinkList;
LIST_ENTRY NbfGlobalConnectionList;
KSPIN_LOCK NbfGlobalInterlock;
KSPIN_LOCK NbfGlobalHistoryLock;

PVOID
TtdiSend ();

PVOID
TtdiReceive ();

PVOID
TtdiServer ();

KEVENT TdiSendEvent;
KEVENT TdiReceiveEvent;
KEVENT TdiServerEvent;

#endif

#if MAGIC

BOOLEAN NbfEnableMagic = FALSE;   // Controls sending of magic bullets.

#endif // MAGIC

//
// This prevents us from having a bss section
//

ULONG _setjmpexused = 0;

//
// Forward declaration of various routines used in this module.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NbfUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
NbfFreeConfigurationInfo (
    IN PCONFIG_DATA ConfigurationInfo
    );

NTSTATUS
NbfDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbfDispatchInternal(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbfDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbfDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbfDispatchPnPPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
NbfDeallocateResources(
    IN PDEVICE_CONTEXT DeviceContext
    );

#ifdef RASAUTODIAL
VOID
NbfAcdBind();

VOID
NbfAcdUnbind();
#endif // RASAUTODIAL

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the NetBIOS Frames Protocol
    transport driver.  It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of NBF's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    ULONG j;
    UNICODE_STRING nameString;
    NTSTATUS status;

    ASSERT (sizeof (SHORT) == 2);

#ifdef MEMPRINT
    MemPrintInitialize ();
#endif

#ifdef NBF_LOCKS
    KeInitializeSpinLock( &NbfGlobalLock );
#endif

#if DBG
    InitializeListHead (&NbfGlobalRequestList);
    InitializeListHead (&NbfGlobalLinkList);
    InitializeListHead (&NbfGlobalConnectionList);
    KeInitializeSpinLock (&NbfGlobalInterlock);
    KeInitializeSpinLock (&NbfGlobalHistoryLock);
#endif

    NbfRegistryPath = *RegistryPath;
    NbfRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool,
                                                   RegistryPath->MaximumLength,
                                                   NBF_MEM_TAG_REGISTRY_PATH);

    if (NbfRegistryPath.Buffer == NULL) {
        PANIC(" Failed to allocate Registry Path!\n");
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(NbfRegistryPath.Buffer, RegistryPath->Buffer,
                                                RegistryPath->MaximumLength);
    NbfDriverObject = DriverObject;
    RtlInitUnicodeString( &nameString, NBF_NAME);


    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction [IRP_MJ_CREATE] = NbfDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = NbfDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = NbfDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = NbfDispatchInternal;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NbfDispatch;

    DriverObject->MajorFunction [IRP_MJ_PNP_POWER] = NbfDispatch;

    DriverObject->DriverUnload = NbfUnload;

    //
    // Initialize the global list of devices.
    // & the lock guarding this global list
    //

    InitializeListHead (&NbfDeviceList);

    ExInitializeFastMutex (&NbfDevicesLock);

    TdiInitialize();

    status = NbfRegisterProtocol (&nameString);

    if (!NT_SUCCESS (status)) {

        //
        // No configuration info read at startup when using PNP
        //

        ExFreePool(NbfRegistryPath.Buffer);
        PANIC ("NbfInitialize: RegisterProtocol with NDIS failed!\n");

        NbfWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlInitUnicodeString( &nameString, NBF_DEVICE_NAME);

    //
    // Register as a provider with TDI
    //
    status = TdiRegisterProvider(
                &nameString,
                &NbfProviderHandle);

    if (!NT_SUCCESS (status)) {

        //
        // Deregister with the NDIS layer as TDI registration failed
        //
        NbfDeregisterProtocol();

        ExFreePool(NbfRegistryPath.Buffer);
        PANIC ("NbfInitialize: RegisterProtocol with TDI failed!\n");

        NbfWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    return(status);

}

VOID
NbfUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the NetBIOS Frames Protocol transport driver.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has NBF open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{

    PDEVICE_CONTEXT DeviceContext;
    PLIST_ENTRY p;
    KIRQL       oldIrql;

    UNREFERENCED_PARAMETER (DriverObject);

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint0 ("ENTER NbfUnload\n");
    }

/*

#ifdef RASAUTODIAL

    //
    // Unbind from the automatic connection driver.
    //

#if DBG
        DbgPrint("Calling NbfAcdUnbind()\n");
#endif

    NbfAcdUnbind();
#endif // RASAUTODIAL

*/

    //
    // Walk the list of device contexts.
    //

    ACQUIRE_DEVICES_LIST_LOCK();

    while (!IsListEmpty (&NbfDeviceList)) {

        // Remove an entry from list and reset its
        // links (as we might try to remove from
        // the list again - when ref goes to zero)
        p = RemoveHeadList (&NbfDeviceList);

        InitializeListHead(p);

        DeviceContext = CONTAINING_RECORD (p, DEVICE_CONTEXT, Linkage);

        DeviceContext->State = DEVICECONTEXT_STATE_STOPPING;

        // Remove creation ref if it has not already been removed
        if (InterlockedExchange(&DeviceContext->CreateRefRemoved, TRUE) == FALSE) {

            RELEASE_DEVICES_LIST_LOCK();

            // Stop all internal timers
            NbfStopTimerSystem(DeviceContext);

            // Remove creation reference
            NbfDereferenceDeviceContext ("Unload", DeviceContext, DCREF_CREATION);

            ACQUIRE_DEVICES_LIST_LOCK();
        }
    }

    RELEASE_DEVICES_LIST_LOCK();

    //
    // Deregister from TDI layer as a network provider
    //
    TdiDeregisterProvider(NbfProviderHandle);

    //
    // Then remove ourselves as an NDIS protocol.
    //

    NbfDeregisterProtocol();

    //
    // Finally free any memory allocated for config info
    //
    if (NbfConfig != NULL) {

        // Free configuration block
        NbfFreeConfigurationInfo(NbfConfig);

#if DBG
        // Free debugging tables
        ExFreePool(NbfConnectionTable);
#endif
    }

    //
    // Free memory allocated in DriverEntry for reg path
    //
    
    ExFreePool(NbfRegistryPath.Buffer);

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint0 ("LEAVE NbfUnload\n");
    }

    return;
}


VOID
NbfFreeResources (
    IN PDEVICE_CONTEXT DeviceContext
    )
/*++

Routine Description:

    This routine is called by NBF to clean up the data structures associated
    with a given DeviceContext. When this routine exits, the DeviceContext
    should be deleted as it no longer has any assocaited resources.

Arguments:

    DeviceContext - Pointer to the DeviceContext we wish to clean up.

Return Value:

    None.

--*/
{
    PLIST_ENTRY p;
    PSINGLE_LIST_ENTRY s;
    PTP_PACKET packet;
    PTP_UI_FRAME uiFrame;
    PTP_ADDRESS address;
    PTP_CONNECTION connection;
    PTP_REQUEST request;
    PTP_LINK link;
    PTP_ADDRESS_FILE addressFile;
    PNDIS_PACKET ndisPacket;
    PBUFFER_TAG BufferTag;
    KIRQL       oldirql;
    PNBF_POOL_LIST_DESC PacketPoolDescCurr;
    PNBF_POOL_LIST_DESC PacketPoolDescNext;

    //
    // Clean up I-frame packet pool.
    //

    while ( DeviceContext->PacketPool.Next != NULL ) {
        s = PopEntryList( &DeviceContext->PacketPool );
        packet = CONTAINING_RECORD( s, TP_PACKET, Linkage );

        NbfDeallocateSendPacket (DeviceContext, packet);
    }

    //
    // Clean up RR-frame packet pool.
    //

    while ( DeviceContext->RrPacketPool.Next != NULL ) {
        s = PopEntryList( &DeviceContext->RrPacketPool );
        packet = CONTAINING_RECORD( s, TP_PACKET, Linkage );

        NbfDeallocateSendPacket (DeviceContext, packet);
    }

    //
    // Clean up UI frame pool.
    //

    while ( !IsListEmpty( &DeviceContext->UIFramePool ) ) {
        p = RemoveHeadList( &DeviceContext->UIFramePool );
        uiFrame = CONTAINING_RECORD (p, TP_UI_FRAME, Linkage );

        NbfDeallocateUIFrame (DeviceContext, uiFrame);
    }

    //
    // Clean up address pool.
    //

    while ( !IsListEmpty (&DeviceContext->AddressPool) ) {
        p = RemoveHeadList (&DeviceContext->AddressPool);
        address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

        NbfDeallocateAddress (DeviceContext, address);
    }

    //
    // Clean up address file pool.
    //

    while ( !IsListEmpty (&DeviceContext->AddressFilePool) ) {
        p = RemoveHeadList (&DeviceContext->AddressFilePool);
        addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);

        NbfDeallocateAddressFile (DeviceContext, addressFile);
    }

    //
    // Clean up connection pool.
    //

    while ( !IsListEmpty (&DeviceContext->ConnectionPool) ) {
        p  = RemoveHeadList (&DeviceContext->ConnectionPool);
        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);

        NbfDeallocateConnection (DeviceContext, connection);
    }

    //
    // Clean up link pool.
    //

    while ( !IsListEmpty (&DeviceContext->LinkPool) ) {
        p  = RemoveHeadList (&DeviceContext->LinkPool);
        link = CONTAINING_RECORD (p, TP_LINK, Linkage);

        NbfDeallocateLink (DeviceContext, link);
    }

    //
    // Clean up request pool.
    //

    while ( !IsListEmpty( &DeviceContext->RequestPool ) ) {
        p = RemoveHeadList( &DeviceContext->RequestPool );
        request = CONTAINING_RECORD (p, TP_REQUEST, Linkage );

        NbfDeallocateRequest (DeviceContext, request);
    }

    //
    // Clean up receive packet pool
    //

    while ( DeviceContext->ReceivePacketPool.Next != NULL) {
        s = PopEntryList (&DeviceContext->ReceivePacketPool);

        //
        // HACK: This works because Linkage is the first field in
        // ProtocolReserved for a receive packet.
        //

        ndisPacket = CONTAINING_RECORD (s, NDIS_PACKET, ProtocolReserved[0]);

        NbfDeallocateReceivePacket (DeviceContext, ndisPacket);
    }


    //
    // Clean up receive buffer pool.
    //

    while ( DeviceContext->ReceiveBufferPool.Next != NULL ) {
        s = PopEntryList( &DeviceContext->ReceiveBufferPool );
        BufferTag = CONTAINING_RECORD (s, BUFFER_TAG, Linkage );

        NbfDeallocateReceiveBuffer (DeviceContext, BufferTag);
    }

    //
    // Now clean up all NDIS resources -
    // packet pools, buffers and such
    //

    //
    // Cleanup list of send packet pools
    //
    if (DeviceContext->SendPacketPoolDesc != NULL)  {

        ACQUIRE_SPIN_LOCK (&DeviceContext->SendPoolListLock, &oldirql);
        for (PacketPoolDescCurr = DeviceContext->SendPacketPoolDesc;
                PacketPoolDescCurr != NULL; ) {

            if (PacketPoolDescCurr->PoolHandle != NULL) {

                NdisFreePacketPool (PacketPoolDescCurr->PoolHandle);
                DeviceContext->MemoryUsage -=
                    (PacketPoolDescCurr->TotalElements * (sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG)));
            }

            PacketPoolDescNext = PacketPoolDescCurr->Next;
            ExFreePool(PacketPoolDescCurr);
            PacketPoolDescCurr = PacketPoolDescNext;
        }

        DeviceContext->SendPacketPoolDesc = NULL;
        DeviceContext->SendPacketPoolSize = 0;

        RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
    }

    //
    // Cleanup list of receive packet pools
    //
    if (DeviceContext->ReceivePacketPoolDesc != NULL)  {

        ACQUIRE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, &oldirql);
        for (PacketPoolDescCurr = DeviceContext->ReceivePacketPoolDesc;
                PacketPoolDescCurr != NULL; ) {

            if (PacketPoolDescCurr->PoolHandle != NULL) {

                NdisFreePacketPool (PacketPoolDescCurr->PoolHandle);
                DeviceContext->MemoryUsage -=
                    (PacketPoolDescCurr->TotalElements * (sizeof(NDIS_PACKET) + sizeof(RECEIVE_PACKET_TAG)));
            }

            PacketPoolDescNext = PacketPoolDescCurr->Next;
            ExFreePool(PacketPoolDescCurr);
            PacketPoolDescCurr = PacketPoolDescNext;
        }

        DeviceContext->ReceivePacketPoolDesc = NULL;
        DeviceContext->ReceivePacketPoolSize = 0;

        RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
    }

    //
    // Cleanup list of ndis buffers
    //
    if (DeviceContext->NdisBufferPool != NULL) {
        NdisFreeBufferPool (DeviceContext->NdisBufferPool);
        DeviceContext->NdisBufferPool = NULL;
    }

    return;

}   /* NbfFreeResources */


NTSTATUS
NbfDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the NBF device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    BOOL DeviceControlIrp = FALSE;
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_CONTEXT DeviceContext;

    ENTER_NBF;

    //
    // Check to see if NBF has been initialized; if not, don't allow any use.
    // Note that this only covers any user mode code use; kernel TDI clients
    // will fail on their creation of an endpoint.
    //

    try {
        DeviceContext = (PDEVICE_CONTEXT)DeviceObject;
        if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {
            LEAVE_NBF;
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INVALID_DEVICE_STATE;
        }

        // Reference the device so that it does not go away from under us
        NbfReferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);
        
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LEAVE_NBF;
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    
    //
    // Make sure status information is consistent every time.
    //

    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //


    switch (IrpSp->MajorFunction) {

        case IRP_MJ_DEVICE_CONTROL:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatch: IRP_MJ_DEVICE_CONTROL.\n");
            }

            DeviceControlIrp = TRUE;

            Status = NbfDeviceControl (DeviceObject, Irp, IrpSp);
            break;

    case IRP_MJ_PNP:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatch: IRP_MJ_PNP.\n");
            }

            Status = NbfDispatchPnPPower (DeviceObject, Irp, IrpSp);
            break;

        default:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatch: OTHER (DEFAULT).\n");
            }
            Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status == STATUS_PENDING) {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: request PENDING from handler.\n");
        }
    } else {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: request COMPLETED by handler.\n");
        }

        //
        // NbfDeviceControl would have completed this IRP already
        //

        if (!DeviceControlIrp)
        {
            LEAVE_NBF;
            IrpSp->Control &= ~SL_PENDING_RETURNED;
            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            ENTER_NBF;
        }
    }

    // Remove the temp use reference on device context added above
    NbfDereferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);
    
    //
    // Return the immediate status code to the caller.
    //

    LEAVE_NBF;
    return Status;
} /* NbfDispatch */


NTSTATUS
NbfDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the NBF device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    KIRQL oldirql;
    PDEVICE_CONTEXT DeviceContext;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_FULL_EA_INFORMATION openType;
    USHORT i;
    BOOLEAN found;
    PTP_ADDRESS_FILE AddressFile;
    PTP_CONNECTION Connection;

    ENTER_NBF;

    //
    // Check to see if NBF has been initialized; if not, don't allow any use.
    // Note that this only covers any user mode code use; kernel TDI clients
    // will fail on their creation of an endpoint.
    //

    try {
        DeviceContext = (PDEVICE_CONTEXT)DeviceObject;
        if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {
            LEAVE_NBF;
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INVALID_DEVICE_STATE;
        }

        // Reference the device so that it does not go away from under us
        NbfReferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);
        
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LEAVE_NBF;
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Make sure status information is consistent every time.
    //

    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //


    switch (IrpSp->MajorFunction) {

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //

    case IRP_MJ_CREATE:
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: IRP_MJ_CREATE.\n");
        }

        openType =
            (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

        if (openType != NULL) {

            //
            // Address?
            //

            found = TRUE;

            if ((USHORT)openType->EaNameLength == TDI_TRANSPORT_ADDRESS_LENGTH) {
                for (i = 0; i < TDI_TRANSPORT_ADDRESS_LENGTH; i++) {
                    if (openType->EaName[i] != TdiTransportAddress[i]) {
                        found = FALSE;
                        break;
                    }
                }
            }
            else {
                found = FALSE;
            }

            if (found) {
                Status = NbfOpenAddress (DeviceObject, Irp, IrpSp);
                break;
            }

            //
            // Connection?
            //

            found = TRUE;

            if ((USHORT)openType->EaNameLength == TDI_CONNECTION_CONTEXT_LENGTH) {
                for (i = 0; i < TDI_CONNECTION_CONTEXT_LENGTH; i++) {
                    if (openType->EaName[i] != TdiConnectionContext[i]) {
                        found = FALSE;
                        break;
                    }
                }
            }
            else {
                found = FALSE;
            }

            if (found) {
                Status = NbfOpenConnection (DeviceObject, Irp, IrpSp);
                break;
            }

            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint2 ("NbfDispatchOpenClose: IRP_MJ_CREATE on invalid type, len: %3d, name: %s\n",
                            (USHORT)openType->EaNameLength, openType->EaName);
            }

        } else {

            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchOpenClose: IRP_MJ_CREATE on control channel!\n");
            }

            ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

            IrpSp->FileObject->FsContext = (PVOID)(DeviceContext->ControlChannelIdentifier);
            ++DeviceContext->ControlChannelIdentifier;
            if (DeviceContext->ControlChannelIdentifier == 0) {
                DeviceContext->ControlChannelIdentifier = 1;
            }

            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

            IrpSp->FileObject->FsContext2 = UlongToPtr(NBF_FILE_TYPE_CONTROL);
            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

        //
        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        //

        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: IRP_MJ_CLOSE.\n");
        }

        switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {
        case TDI_TRANSPORT_ADDRESS_FILE:
            AddressFile = (PTP_ADDRESS_FILE)IrpSp->FileObject->FsContext;

            //
            // This creates a reference to AddressFile->Address
            // which is removed by NbfCloseAddress.
            //

            Status = NbfVerifyAddressObject(AddressFile);

            if (!NT_SUCCESS (Status)) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                Status = NbfCloseAddress (DeviceObject, Irp, IrpSp);
            }

            break;

        case TDI_CONNECTION_FILE:

            //
            // This is a connection
            //

            Connection = (PTP_CONNECTION)IrpSp->FileObject->FsContext;

            Status = NbfVerifyConnectionObject (Connection);
            if (NT_SUCCESS (Status)) {

                Status = NbfCloseConnection (DeviceObject, Irp, IrpSp);
                NbfDereferenceConnection ("Temporary Use",Connection, CREF_BY_ID);

            }

            break;

        case NBF_FILE_TYPE_CONTROL:

            //
            // this always succeeds
            //

            Status = STATUS_SUCCESS;
            break;

        default:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint1 ("NbfDispatch: IRP_MJ_CLOSE on unknown file type %lx.\n",
                    IrpSp->FileObject->FsContext2);
            }

            Status = STATUS_INVALID_HANDLE;
        }

        break;

    case IRP_MJ_CLEANUP:

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        //

        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: IRP_MJ_CLEANUP.\n");
        }

        switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {
        case TDI_TRANSPORT_ADDRESS_FILE:
            AddressFile = (PTP_ADDRESS_FILE)IrpSp->FileObject->FsContext;
            Status = NbfVerifyAddressObject(AddressFile);
            if (!NT_SUCCESS (Status)) {

                Status = STATUS_INVALID_HANDLE;

            } else {

                NbfStopAddressFile (AddressFile, AddressFile->Address);
                NbfDereferenceAddress ("IRP_MJ_CLEANUP", AddressFile->Address, AREF_VERIFY);
                Status = STATUS_SUCCESS;
            }

            break;

        case TDI_CONNECTION_FILE:
            Connection = (PTP_CONNECTION)IrpSp->FileObject->FsContext;
            Status = NbfVerifyConnectionObject (Connection);
            if (NT_SUCCESS (Status)) {
                KeRaiseIrql (DISPATCH_LEVEL, &oldirql);
                NbfStopConnection (Connection, STATUS_LOCAL_DISCONNECT);
                KeLowerIrql (oldirql);
                Status = STATUS_SUCCESS;
                NbfDereferenceConnection ("Temporary Use",Connection, CREF_BY_ID);
            }

            break;

        case NBF_FILE_TYPE_CONTROL:

            NbfStopControlChannel(
                (PDEVICE_CONTEXT)DeviceObject,
                (USHORT)IrpSp->FileObject->FsContext
                );

            Status = STATUS_SUCCESS;
            break;

        default:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint1 ("NbfDispatch: IRP_MJ_CLEANUP on unknown file type %lx.\n",
                    IrpSp->FileObject->FsContext2);
            }

            Status = STATUS_INVALID_HANDLE;
        }

        break;

    default:
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: OTHER (DEFAULT).\n");
        }

        Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status == STATUS_PENDING) {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: request PENDING from handler.\n");
        }
    } else {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatch: request COMPLETED by handler.\n");
        }

        LEAVE_NBF;
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        ENTER_NBF;
    }

    // Remove the temp use reference on device context added above
    NbfDereferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);

    //
    // Return the immediate status code to the caller.
    //

    LEAVE_NBF;
    return Status;
} /* NbfDispatchOpenClose */


NTSTATUS
NbfDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    BOOL InternalIrp = FALSE;
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)DeviceObject;

    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        NbfPrint0 ("NbfDeviceControl: Entered.\n");
    }

    //
    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly;this is a check which must be made within each routine.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

#if MAGIC
        case IOCTL_TDI_MAGIC_BULLET:

            //
            // Special: send the magic bullet (to trigger the Sniffer).
            //

            NbfPrint1 ("NBF: Sending user MagicBullet on %lx\n", DeviceContext);
            {
                extern VOID NbfSendMagicBullet (PDEVICE_CONTEXT, PTP_LINK);
                NbfSendMagicBullet (DeviceContext, NULL);
            }

            if (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer != NULL) {
                NbfPrint0 ("NBF: DbgBreakPoint after MagicBullet\n");
                DbgBreakPoint();
            }

            Status = STATUS_SUCCESS;
            break;
#endif

#if DBG
        case IOCTL_TDI_SEND_TEST:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDeviceControl: Internal IOCTL: start send side test\n");
            }

            (VOID) KeSetEvent( &TdiSendEvent, 0, FALSE );

            break;

        case IOCTL_TDI_RECEIVE_TEST:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDeviceControl: Internal IOCTL: start receive side test\n");
            }

            (VOID) KeSetEvent( &TdiReceiveEvent, 0, FALSE );

            break;

        case IOCTL_TDI_SERVER_TEST:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDeviceControl: Internal IOCTL: start receive side test\n");
            }

            (VOID) KeSetEvent( &TdiServerEvent, 0, FALSE );

            break;
#endif

        default:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDeviceControl: invalid request type.\n");
            }

            //
            // Convert the user call to the proper internal device call.
            //

            Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);

            if (Status == STATUS_SUCCESS) {

                //
                // If TdiMapUserRequest returns SUCCESS then the IRP
                // has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
                // IRP, so we dispatch it as usual. The IRP will be
                // completed by this call to NbfDispatchInternal, so we dont
                //

                InternalIrp = TRUE;

                Status = NbfDispatchInternal (DeviceObject, Irp);
            }
    }

    //
    // If this IRP got converted to an internal IRP,
    // it will be completed by NbfDispatchInternal.
    //

    if ((!InternalIrp) && (Status != STATUS_PENDING))
    {
        LEAVE_NBF;
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        ENTER_NBF;
    }

    return Status;
} /* NbfDeviceControl */

NTSTATUS
NbfDispatchPnPPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dispatches PnP request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE_RELATIONS DeviceRelations = NULL;
    PTP_CONNECTION Connection;
    PVOID PnPContext;
    NTSTATUS Status;

    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        NbfPrint0 ("NbfDispatchPnPPower: Entered.\n");
    }

    Status = STATUS_INVALID_DEVICE_REQUEST;

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

      if (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){

        switch (PtrToUlong(IrpSp->FileObject->FsContext2))
        {
        case TDI_CONNECTION_FILE:

            // Get the connection object and verify
            Connection = IrpSp->FileObject->FsContext;

            //
            // This adds a connection reference of type BY_ID if successful.
            //

            Status = NbfVerifyConnectionObject (Connection);

            if (NT_SUCCESS (Status)) {

                //
                // Get the PDO associated with conn's device object
                //

                PnPContext = Connection->Provider->PnPContext;
                if (PnPContext) {

                    DeviceRelations = 
                        ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(DEVICE_RELATIONS),
                                              NBF_MEM_TAG_DEVICE_PDO);
                    if (DeviceRelations) {

                        //
                        // TargetDeviceRelation allows exactly 1 PDO. fill it.
                        //
                        DeviceRelations->Count = 1;
                        DeviceRelations->Objects[0] = PnPContext;
                        ObReferenceObject(PnPContext);

                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                } else {
                    Status = STATUS_INVALID_DEVICE_STATE;
                }
            
                NbfDereferenceConnection ("Temp Rel", Connection, CREF_BY_ID);
            }
            break;
            
        case TDI_TRANSPORT_ADDRESS_FILE:

            Status = STATUS_UNSUCCESSFUL;
            break;
        }
      }
    }

    //
    // Invoker of this irp will free the information buffer.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        NbfPrint1 ("NbfDispatchPnPPower: exiting, status: %lx\n",Status);
    }

    return Status;
} /* NbfDispatchPnPPower */


NTSTATUS
NbfDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE_CONTEXT DeviceContext;
    PIO_STACK_LOCATION IrpSp;
#if DBG
    KIRQL IrqlOnEnter = KeGetCurrentIrql();
#endif

    ENTER_NBF;

    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        NbfPrint0 ("NbfInternalDeviceControl: Entered.\n");
    }

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    DeviceContext = (PDEVICE_CONTEXT)DeviceObject;

    try {
        if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {
            LEAVE_NBF;
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INVALID_DEVICE_STATE;
        }
    
        // Reference the device so that it does not go away from under us
        NbfReferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);
        
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LEAVE_NBF;
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Make sure status information is consistent every time.
    //

    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;


    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        {
            PULONG Temp=(PULONG)&IrpSp->Parameters;
            NbfPrint5 ("Got IrpSp %lx %lx %lx %lx %lx\n", Temp++,  Temp++,
                Temp++, Temp++, Temp++);
        }
    }

    //
    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    switch (IrpSp->MinorFunction) {

        case TDI_ACCEPT:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiAccept request.\n");
            }

            Status = NbfTdiAccept (Irp);
            break;

        case TDI_ACTION:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiAction request.\n");
            }

            Status = NbfTdiAction (DeviceContext, Irp);
            break;

        case TDI_ASSOCIATE_ADDRESS:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiAccept request.\n");
            }

            Status = NbfTdiAssociateAddress (Irp);
            break;

        case TDI_DISASSOCIATE_ADDRESS:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiDisassociateAddress request.\n");
            }

            Status = NbfTdiDisassociateAddress (Irp);
            break;

        case TDI_CONNECT:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiConnect request\n");
            }

            Status = NbfTdiConnect (Irp);

            break;

        case TDI_DISCONNECT:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiDisconnect request.\n");
            }

            Status = NbfTdiDisconnect (Irp);
            break;

        case TDI_LISTEN:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiListen request.\n");
            }

            Status = NbfTdiListen (Irp);
            break;

        case TDI_QUERY_INFORMATION:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiQueryInformation request.\n");
            }

            Status = NbfTdiQueryInformation (DeviceContext, Irp);
            break;

        case TDI_RECEIVE:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiReceive request.\n");
            }

            Status =  NbfTdiReceive (Irp);
            break;

        case TDI_RECEIVE_DATAGRAM:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiReceiveDatagram request.\n");
            }

            Status =  NbfTdiReceiveDatagram (Irp);
            break;

        case TDI_SEND:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiSend request.\n");
            }

            Status =  NbfTdiSend (Irp);
            break;

        case TDI_SEND_DATAGRAM:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiSendDatagram request.\n");
           }

           Status = NbfTdiSendDatagram (Irp);
            break;

        case TDI_SET_EVENT_HANDLER:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiSetEventHandler request.\n");
            }

            //
            // Because this request will enable direct callouts from the
            // transport provider at DISPATCH_LEVEL to a client-specified
            // routine, this request is only valid in kernel mode, denying
            // access to this request in user mode.
            //

            Status = NbfTdiSetEventHandler (Irp);
            break;

        case TDI_SET_INFORMATION:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint0 ("NbfDispatchInternal: TdiSetInformation request.\n");
            }

            Status = NbfTdiSetInformation (Irp);
            break;

#if DBG
        case 0x7f:

            //
            // Special: send the magic bullet (to trigger the Sniffer).
            //

            NbfPrint1 ("NBF: Sending MagicBullet on %lx\n", DeviceContext);
            {
                extern VOID NbfSendMagicBullet (PDEVICE_CONTEXT, PTP_LINK);
                NbfSendMagicBullet (DeviceContext, NULL);
            }

            Status = STATUS_SUCCESS;
            break;
#endif

        //
        // Something we don't know about was submitted.
        //

        default:
            IF_NBFDBG (NBF_DEBUG_DISPATCH) {
                NbfPrint1 ("NbfDispatchInternal: invalid request type %lx\n",
                IrpSp->MinorFunction);
            }
            Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (Status == STATUS_PENDING) {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatchInternal: request PENDING from handler.\n");
        }
    } else {
        IF_NBFDBG (NBF_DEBUG_DISPATCH) {
            NbfPrint0 ("NbfDispatchInternal: request COMPLETED by handler.\n");
        }

        LEAVE_NBF;
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        ENTER_NBF;
    }


    IF_NBFDBG (NBF_DEBUG_DISPATCH) {
        NbfPrint1 ("NbfDispatchInternal: exiting, status: %lx\n",Status);
    }

    // Remove the temp use reference on device context added above
    NbfDereferenceDeviceContext ("Temp Use Ref", DeviceContext, DCREF_TEMP_USE);

    //
    // Return the immediate status code to the caller.
    //

    LEAVE_NBF;
#if DBG
    ASSERT (KeGetCurrentIrql() == IrqlOnEnter);
#endif

    return Status;

} /* NbfDispatchInternal */


VOID
NbfWriteResourceErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN ULONG BytesNeeded,
    IN ULONG ResourceId
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    an out of resources condition. It will handle event codes
    RESOURCE_POOL, RESOURCE_LIMIT, and RESOURCE_SPECIFIC.

Arguments:

    DeviceContext - Pointer to the device context.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated.

    ResourceId - The resource ID of the allocated structure.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PWSTR SecondString;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    WCHAR ResourceIdBuffer[3];
    WCHAR SizeBuffer[2];
    WCHAR SpecificMaxBuffer[11];
    ULONG SpecificMax;
    INT i;

    switch (ErrorCode) {

    case EVENT_TRANSPORT_RESOURCE_POOL:
        SecondString = NULL;
        SecondStringSize = 0;
        break;

    case EVENT_TRANSPORT_RESOURCE_LIMIT:
        SecondString = SizeBuffer;
        SecondStringSize = sizeof(SizeBuffer);

        switch (DeviceContext->MemoryLimit) {
            case 100000: SizeBuffer[0] = L'1'; break;
            case 250000: SizeBuffer[0] = L'2'; break;
            case 0: SizeBuffer[0] = L'3'; break;
            default: SizeBuffer[0] = L'0'; break;
        }
        SizeBuffer[1] = 0;
        break;

    case EVENT_TRANSPORT_RESOURCE_SPECIFIC:
        switch (ResourceId) {
            case UI_FRAME_RESOURCE_ID: SpecificMax = DeviceContext->SendPacketPoolSize; break;
            case PACKET_RESOURCE_ID: SpecificMax = DeviceContext->SendPacketPoolSize; break;
            case RECEIVE_PACKET_RESOURCE_ID: SpecificMax = DeviceContext->ReceivePacketPoolSize; break;
            case RECEIVE_BUFFER_RESOURCE_ID: SpecificMax = DeviceContext->SendPacketPoolSize+DeviceContext->ReceivePacketPoolSize; break;
            case ADDRESS_RESOURCE_ID: SpecificMax = DeviceContext->MaxAddresses; break;
            case ADDRESS_FILE_RESOURCE_ID: SpecificMax = DeviceContext->MaxAddressFiles; break;
            case CONNECTION_RESOURCE_ID: SpecificMax = DeviceContext->MaxConnections; break;
            case LINK_RESOURCE_ID: SpecificMax = DeviceContext->MaxLinks; break;
            case REQUEST_RESOURCE_ID: SpecificMax = DeviceContext->MaxRequests; break;
        }

        for (i=9; i>=0; i--) {
            SpecificMaxBuffer[i] = (WCHAR)((SpecificMax % 10) + L'0');
            SpecificMax /= 10;
            if (SpecificMax == 0) {
                break;
            }
        }
        SecondString = SpecificMaxBuffer + i;
        SecondStringSize = sizeof(SpecificMaxBuffer) - (i * sizeof(WCHAR));
        SpecificMaxBuffer[10] = 0;
        break;

    default:
        ASSERT (FALSE);
        SecondString = NULL;
        SecondStringSize = 0;
        break;
    }

    EntrySize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                        DeviceContext->DeviceNameLength +
                        sizeof(ResourceIdBuffer) +
                        SecondStringSize);

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)DeviceContext,
        EntrySize
    );

    //
    // Convert the resource ID into a buffer.
    //

    ResourceIdBuffer[1] = (WCHAR)((ResourceId % 10) + L'0');
    ResourceId /= 10;
    ASSERT(ResourceId <= 9);
    ResourceIdBuffer[0] = (WCHAR)((ResourceId % 10) + L'0');
    ResourceIdBuffer[2] = 0;

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 2 : 3;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, DeviceContext->DeviceName, DeviceContext->DeviceNameLength);
        StringLoc += DeviceContext->DeviceNameLength;

        RtlCopyMemory (StringLoc, ResourceIdBuffer, sizeof(ResourceIdBuffer));
        StringLoc += sizeof(ResourceIdBuffer);

        if (SecondString) {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* NbfWriteResourceErrorLog */


VOID
NbfWriteGeneralErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    DeviceContext - Pointer to the device context, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    DumpDataCount - The number of ULONGs of dump data.

    DumpData - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    PWSTR DriverName;

    EntrySize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                       (DumpDataCount * sizeof(ULONG)));

    if (DeviceContext->Type == IO_TYPE_DEVICE) {
        EntrySize += (UCHAR)DeviceContext->DeviceNameLength;
    } else {
        DriverName = L"Nbf";
        EntrySize += 4 * sizeof(WCHAR);
    }

    if (SecondString) {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)DeviceContext,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)(DumpDataCount * sizeof(ULONG));
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset =
            (USHORT)(sizeof(IO_ERROR_LOG_PACKET) + ((DumpDataCount-1) * sizeof(ULONG)));
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (DumpDataCount) {
            RtlCopyMemory(errorLogEntry->DumpData, DumpData, DumpDataCount * sizeof(ULONG));
        }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (DeviceContext->Type == IO_TYPE_DEVICE) {
            RtlCopyMemory (StringLoc, DeviceContext->DeviceName, DeviceContext->DeviceNameLength);
            StringLoc += DeviceContext->DeviceNameLength;
        } else {
            RtlCopyMemory (StringLoc, DriverName, 4 * sizeof(WCHAR));
            StringLoc += 4 * sizeof(WCHAR);
        }
        if (SecondString) {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* NbfWriteGeneralErrorLog */


VOID
NbfWriteOidErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a problem querying or setting an OID on an adapter. It handles
    event codes SET_OID_FAILED and QUERY_OID_FAILED.

Arguments:

    DeviceContext - Pointer to the device context.

    ErrorCode - Used as the ErrorCode in the error log packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    AdapterString - The name of the adapter we were bound to.

    OidValue - The OID which could not be set or queried.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG EntrySize;
    PUCHAR StringLoc;
    WCHAR OidBuffer[9];
    INT i;
    UINT CurrentDigit;

    EntrySize = (sizeof(IO_ERROR_LOG_PACKET) -
                 sizeof(ULONG) +
                 DeviceContext->DeviceNameLength +
                 sizeof(OidBuffer));

    if (EntrySize > ERROR_LOG_LIMIT_SIZE) {
        return;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)DeviceContext,
        (UCHAR) EntrySize
    );

    //
    // Convert the OID into a buffer.
    //

    for (i=7; i>=0; i--) {
        CurrentDigit = OidValue & 0xf;
        OidValue >>= 4;
        if (CurrentDigit >= 0xa) {
            OidBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            OidBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    }
    OidBuffer[8] = 0;

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = 0;
        errorLogEntry->NumberOfStrings = 3;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, DeviceContext->DeviceName, DeviceContext->DeviceNameLength);
        StringLoc += DeviceContext->DeviceNameLength;

        RtlCopyMemory (StringLoc, OidBuffer, sizeof(OidBuffer));

        IoWriteErrorLogEntry(errorLogEntry);
    }

}   /* NbfWriteOidErrorLog */

ULONG
NbfInitializeOneDeviceContext(
                                OUT PNDIS_STATUS NdisStatus,
                                IN PDRIVER_OBJECT DriverObject,
                                IN PCONFIG_DATA NbfConfig,
                                IN PUNICODE_STRING BindName,
                                IN PUNICODE_STRING ExportName,
                                IN PVOID SystemSpecific1,
                                IN PVOID SystemSpecific2
                             )
/*++

Routine Description:

    This routine creates and initializes one nbf device context.  In order to
    do this it must successfully open and bind to the adapter described by
    nbfconfig->names[adapterindex].

Arguments:

    NdisStatus   - The outputted status of the operations.

    DriverObject - the nbf driver object.

    NbfConfig    - the transport configuration information from the registry.

    SystemSpecific1 - SystemSpecific1 argument to ProtocolBindAdapter

    SystemSpecific2 - SystemSpecific2 argument to ProtocolBindAdapter

Return Value:

    The number of successful binds.

--*/

{
    ULONG i;
    PDEVICE_CONTEXT DeviceContext;
    PTP_REQUEST Request;
    PTP_LINK Link;
    PTP_CONNECTION Connection;
    PTP_ADDRESS_FILE AddressFile;
    PTP_ADDRESS Address;
    PTP_UI_FRAME UIFrame;
    PTP_PACKET Packet;
    PNDIS_PACKET NdisPacket;
    PRECEIVE_PACKET_TAG ReceiveTag;
    PBUFFER_TAG BufferTag;
    KIRQL oldIrql;
    NTSTATUS status;
    UINT MaxUserData;
    ULONG InitReceivePackets;
    BOOLEAN UniProcessor;
    PDEVICE_OBJECT DeviceObject;
    UNICODE_STRING DeviceString;
    UCHAR PermAddr[sizeof(TA_ADDRESS)+TDI_ADDRESS_LENGTH_NETBIOS];
    PTA_ADDRESS pAddress = (PTA_ADDRESS)PermAddr;
    PTDI_ADDRESS_NETBIOS NetBIOSAddress =
                                    (PTDI_ADDRESS_NETBIOS)pAddress->Address;
    struct {
        TDI_PNP_CONTEXT tdiPnPContextHeader;
        PVOID           tdiPnPContextTrailer;
    } tdiPnPContext1, tdiPnPContext2;

    pAddress->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
    pAddress->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    NetBIOSAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    //
    // Determine if we are on a uniprocessor.
    //

    if (KeNumberProcessors == 1) {
        UniProcessor = TRUE;
    } else {
        UniProcessor = FALSE;
    }

    //
    // Loop through all the adapters that are in the configuration
    // information structure. Allocate a device object for each
    // one that we find.
    //

    status = NbfCreateDeviceContext(
                                    DriverObject,
                                    ExportName,
                                    &DeviceContext
                                   );

    if (!NT_SUCCESS (status)) {

        IF_NBFDBG (NBF_DEBUG_PNP) {
            NbfPrint2 ("NbfCreateDeviceContext for %S returned error %08x\n",
                            ExportName->Buffer, status);
        }

		//
		// First check if we already have an object with this name
		// This is because a previous unbind was not done properly.
		//

    	if (status == STATUS_OBJECT_NAME_COLLISION) {

			// See if we can reuse the binding and device name
			
			NbfReInitializeDeviceContext(
                                         &status,
                                         DriverObject,
                                         NbfConfig,
                                         BindName,
                                         ExportName,
                                         SystemSpecific1,
                                         SystemSpecific2
                                        );

			if (status == STATUS_NOT_FOUND)
			{
				// Must have got deleted in the meantime
			
				return NbfInitializeOneDeviceContext(
                                                     NdisStatus,
                                                     DriverObject,
                                                     NbfConfig,
                                                     BindName,
                                                     ExportName,
                                                     SystemSpecific1,
                                                     SystemSpecific2
                                                    );
			}
		}

	    *NdisStatus = status;

		if (!NT_SUCCESS (status))
		{
	        NbfWriteGeneralErrorLog(
    	        (PVOID)DriverObject,
        	    EVENT_TRANSPORT_BINDING_FAILED,
	            707,
    	        status,
        	    BindName->Buffer,
	            0,
    	        NULL);

            return(0);
		}
		
    	return(1);
	}

    DeviceContext->UniProcessor = UniProcessor;

    //
    // Initialize the timer and retry values (note that the link timeouts
    // are converted from NT ticks to NBF ticks). These values may
    // be modified by NbfInitializeNdis.
    //
    DeviceContext->MinimumT1Timeout = NbfConfig->MinimumT1Timeout / SHORT_TIMER_DELTA;
    DeviceContext->DefaultT1Timeout = NbfConfig->DefaultT1Timeout / SHORT_TIMER_DELTA;
    DeviceContext->DefaultT2Timeout = NbfConfig->DefaultT2Timeout / SHORT_TIMER_DELTA;
    DeviceContext->DefaultTiTimeout = NbfConfig->DefaultTiTimeout / LONG_TIMER_DELTA;
    DeviceContext->LlcRetries = NbfConfig->LlcRetries;
    DeviceContext->LlcMaxWindowSize = NbfConfig->LlcMaxWindowSize;
    DeviceContext->MaxConsecutiveIFrames = (UCHAR)NbfConfig->MaximumIncomingFrames;
    DeviceContext->NameQueryRetries = NbfConfig->NameQueryRetries;
    DeviceContext->NameQueryTimeout = NbfConfig->NameQueryTimeout;
    DeviceContext->AddNameQueryRetries = NbfConfig->AddNameQueryRetries;
    DeviceContext->AddNameQueryTimeout = NbfConfig->AddNameQueryTimeout;
    DeviceContext->GeneralRetries = NbfConfig->GeneralRetries;
    DeviceContext->GeneralTimeout = NbfConfig->GeneralTimeout;
    DeviceContext->MinimumSendWindowLimit = NbfConfig->MinimumSendWindowLimit;

    //
    // Initialize our counter that records memory usage.
    //

    DeviceContext->MemoryUsage = 0;
    DeviceContext->MemoryLimit = NbfConfig->MaxMemoryUsage;

    DeviceContext->MaxRequests = NbfConfig->MaxRequests;
    DeviceContext->MaxLinks = NbfConfig->MaxLinks;
    DeviceContext->MaxConnections = NbfConfig->MaxConnections;
    DeviceContext->MaxAddressFiles = NbfConfig->MaxAddressFiles;
    DeviceContext->MaxAddresses = NbfConfig->MaxAddresses;

    //
    // Now fire up NDIS so this adapter talks
    //

    status = NbfInitializeNdis (DeviceContext,
                                NbfConfig,
                                BindName);

    if (!NT_SUCCESS (status)) {

        //
        // Log an error if we were failed to
        // open this adapter.
        //

        NbfWriteGeneralErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_BINDING_FAILED,
            601,
            status,
            BindName->Buffer,
            0,
            NULL);

        if (InterlockedExchange(&DeviceContext->CreateRefRemoved, TRUE) == FALSE) {
            NbfDereferenceDeviceContext ("Initialize NDIS failed", DeviceContext, DCREF_CREATION);
        }
        
        *NdisStatus = status;
        return(0);

    }

#if 0
    DbgPrint("Opened %S as %S\n", &NbfConfig->Names[j], &nameString);
#endif

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint6 ("NbfInitialize: NDIS returned: %x %x %x %x %x %x as local address.\n",
            DeviceContext->LocalAddress.Address[0],
            DeviceContext->LocalAddress.Address[1],
            DeviceContext->LocalAddress.Address[2],
            DeviceContext->LocalAddress.Address[3],
            DeviceContext->LocalAddress.Address[4],
            DeviceContext->LocalAddress.Address[5]);
    }

    //
    // Initialize our provider information structure; since it
    // doesn't change, we just keep it around and copy it to
    // whoever requests it.
    //


    MacReturnMaxDataSize(
        &DeviceContext->MacInfo,
        NULL,
        0,
        DeviceContext->MaxSendPacketSize,
        TRUE,
        &MaxUserData);

    DeviceContext->Information.Version = 0x0100;
    DeviceContext->Information.MaxSendSize = 0x1fffe;   // 128k - 2
    DeviceContext->Information.MaxConnectionUserData = 0;
    DeviceContext->Information.MaxDatagramSize =
        MaxUserData - (sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS));
    DeviceContext->Information.ServiceFlags = NBF_SERVICE_FLAGS;
    if (DeviceContext->MacInfo.MediumAsync) {
        DeviceContext->Information.ServiceFlags |= TDI_SERVICE_POINT_TO_POINT;
    }
    DeviceContext->Information.MinimumLookaheadData =
        240 - (sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS));
    DeviceContext->Information.MaximumLookaheadData =
        DeviceContext->MaxReceivePacketSize - (sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));
    DeviceContext->Information.NumberOfResources = NBF_TDI_RESOURCES;
    KeQuerySystemTime (&DeviceContext->Information.StartTime);


    //
    // Allocate various structures we will need.
    //

    ENTER_NBF;

    //
    // The TP_UI_FRAME structure has a CHAR[1] field at the end
    // which we expand upon to include all the headers needed;
    // the size of the MAC header depends on what the adapter
    // told us about its max header size.
    //

    DeviceContext->UIFrameHeaderLength =
        DeviceContext->MacInfo.MaxHeaderLength +
        sizeof(DLC_FRAME) +
        sizeof(NBF_HDR_CONNECTIONLESS);

    DeviceContext->UIFrameLength =
        FIELD_OFFSET(TP_UI_FRAME, Header[0]) +
        DeviceContext->UIFrameHeaderLength;


    //
    // The TP_PACKET structure has a CHAR[1] field at the end
    // which we expand upon to include all the headers needed;
    // the size of the MAC header depends on what the adapter
    // told us about its max header size. TP_PACKETs are used
    // for connection-oriented frame as well as for
    // control frames, but since DLC_I_FRAME and DLC_S_FRAME
    // are the same size, the header is the same size.
    //

    ASSERT (sizeof(DLC_I_FRAME) == sizeof(DLC_S_FRAME));

    DeviceContext->PacketHeaderLength =
        DeviceContext->MacInfo.MaxHeaderLength +
        sizeof(DLC_I_FRAME) +
        sizeof(NBF_HDR_CONNECTION);

    DeviceContext->PacketLength =
        FIELD_OFFSET(TP_PACKET, Header[0]) +
        DeviceContext->PacketHeaderLength;


    //
    // The BUFFER_TAG structure has a CHAR[1] field at the end
    // which we expand upong to include all the frame data.
    //

    DeviceContext->ReceiveBufferLength =
        DeviceContext->MaxReceivePacketSize +
        FIELD_OFFSET(BUFFER_TAG, Buffer[0]);


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: pre-allocating requests.\n");
    }
    for (i=0; i<NbfConfig->InitRequests; i++) {

        NbfAllocateRequest (DeviceContext, &Request);

        if (Request == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate requests.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&DeviceContext->RequestPool, &Request->Linkage);
#if DBG
        NbfRequestTable[i+1] = (PVOID)Request;
#endif
    }
#if DBG
    NbfRequestTable[0] = UlongToPtr(NbfConfig->InitRequests);
    NbfRequestTable[NbfConfig->InitRequests + 1] = (PVOID)
                        ((NBF_REQUEST_SIGNATURE << 16) | sizeof (TP_REQUEST));
    InitializeListHead (&NbfGlobalRequestList);
#endif

    DeviceContext->RequestInitAllocated = NbfConfig->InitRequests;
    DeviceContext->RequestMaxAllocated = NbfConfig->MaxRequests;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d requests, %ld\n", NbfConfig->InitRequests, DeviceContext->MemoryUsage);
    }

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating links.\n");
    }
    for (i=0; i<NbfConfig->InitLinks; i++) {

        NbfAllocateLink (DeviceContext, &Link);

        if (Link == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate links.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&DeviceContext->LinkPool, &Link->Linkage);
#if DBG
        NbfLinkTable[i+1] = (PVOID)Link;
#endif
    }
#if DBG
    NbfLinkTable[0] = UlongToPtr(NbfConfig->InitLinks);
    NbfLinkTable[NbfConfig->InitLinks+1] = (PVOID)
                ((NBF_LINK_SIGNATURE << 16) | sizeof (TP_LINK));
#endif

    DeviceContext->LinkInitAllocated = NbfConfig->InitLinks;
    DeviceContext->LinkMaxAllocated = NbfConfig->MaxLinks;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d links, %ld\n", NbfConfig->InitLinks, DeviceContext->MemoryUsage);
    }

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating connections.\n");
    }
    for (i=0; i<NbfConfig->InitConnections; i++) {

        NbfAllocateConnection (DeviceContext, &Connection);

        if (Connection == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate connections.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&DeviceContext->ConnectionPool, &Connection->LinkList);
#if DBG
        NbfConnectionTable[i+1] = (PVOID)Connection;
#endif
    }
#if DBG
    NbfConnectionTable[0] = UlongToPtr(NbfConfig->InitConnections);
    NbfConnectionTable[NbfConfig->InitConnections+1] = (PVOID)
                ((NBF_CONNECTION_SIGNATURE << 16) | sizeof (TP_CONNECTION));
#endif

    DeviceContext->ConnectionInitAllocated = NbfConfig->InitConnections;
    DeviceContext->ConnectionMaxAllocated = NbfConfig->MaxConnections;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d connections, %ld\n", NbfConfig->InitConnections, DeviceContext->MemoryUsage);
    }


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating AddressFiles.\n");
    }
    for (i=0; i<NbfConfig->InitAddressFiles; i++) {

        NbfAllocateAddressFile (DeviceContext, &AddressFile);

        if (AddressFile == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate Address Files.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&DeviceContext->AddressFilePool, &AddressFile->Linkage);
#if DBG
        NbfAddressFileTable[i+1] = (PVOID)AddressFile;
#endif
    }
#if DBG
    NbfAddressFileTable[0] = UlongToPtr(NbfConfig->InitAddressFiles);
    NbfAddressFileTable[NbfConfig->InitAddressFiles + 1] = (PVOID)
                            ((NBF_ADDRESSFILE_SIGNATURE << 16) |
                                 sizeof (TP_ADDRESS_FILE));
#endif

    DeviceContext->AddressFileInitAllocated = NbfConfig->InitAddressFiles;
    DeviceContext->AddressFileMaxAllocated = NbfConfig->MaxAddressFiles;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d address files, %ld\n", NbfConfig->InitAddressFiles, DeviceContext->MemoryUsage);
    }


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating addresses.\n");
    }
    for (i=0; i<NbfConfig->InitAddresses; i++) {

        NbfAllocateAddress (DeviceContext, &Address);
        if (Address == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate addresses.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&DeviceContext->AddressPool, &Address->Linkage);
#if DBG
        NbfAddressTable[i+1] = (PVOID)Address;
#endif
    }
#if DBG
    NbfAddressTable[0] = UlongToPtr(NbfConfig->InitAddresses);
    NbfAddressTable[NbfConfig->InitAddresses + 1] = (PVOID)
                        ((NBF_ADDRESS_SIGNATURE << 16) | sizeof (TP_ADDRESS));
#endif

    DeviceContext->AddressInitAllocated = NbfConfig->InitAddresses;
    DeviceContext->AddressMaxAllocated = NbfConfig->MaxAddresses;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d addresses, %ld\n", NbfConfig->InitAddresses, DeviceContext->MemoryUsage);
    }


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating UI frames.\n");
    }

    for (i=0; i<NbfConfig->InitUIFrames; i++) {

        NbfAllocateUIFrame (DeviceContext, &UIFrame);

        if (UIFrame == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate UI frames.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        InsertTailList (&(DeviceContext->UIFramePool), &UIFrame->Linkage);
#if DBG
        NbfUiFrameTable[i+1] = UIFrame;
#endif
    }
#if DBG
        NbfUiFrameTable[0] = UlongToPtr(NbfConfig->InitUIFrames);
#endif

    DeviceContext->UIFrameInitAllocated = NbfConfig->InitUIFrames;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d UI frames, %ld\n", NbfConfig->InitUIFrames, DeviceContext->MemoryUsage);
    }


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating I frames.\n");
        NbfPrint1 ("NBFDRVR: Packet pool header: %lx\n",&DeviceContext->PacketPool);
    }

    for (i=0; i<NbfConfig->InitPackets; i++) {

        NbfAllocateSendPacket (DeviceContext, &Packet);
        if (Packet == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate packets.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        PushEntryList (&DeviceContext->PacketPool, (PSINGLE_LIST_ENTRY)&Packet->Linkage);
#if DBG
        NbfSendPacketTable[i+1] = Packet;
#endif
    }
#if DBG
        NbfSendPacketTable[0] = UlongToPtr(NbfConfig->InitPackets);
        NbfSendPacketTable[NbfConfig->InitPackets+1] = (PVOID)
                    ((NBF_PACKET_SIGNATURE << 16) | sizeof (TP_PACKET));
#endif

    DeviceContext->PacketInitAllocated = NbfConfig->InitPackets;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d I-frame send packets, %ld\n", NbfConfig->InitPackets, DeviceContext->MemoryUsage);
    }


    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating RR frames.\n");
        NbfPrint1 ("NBFDRVR: Packet pool header: %lx\n",&DeviceContext->RrPacketPool);
    }

    for (i=0; i<10; i++) {

        NbfAllocateSendPacket (DeviceContext, &Packet);
        if (Packet == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate packets.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        Packet->Action = PACKET_ACTION_RR;
        PushEntryList (&DeviceContext->RrPacketPool, (PSINGLE_LIST_ENTRY)&Packet->Linkage);
    }

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d RR-frame send packets, %ld\n", 10, DeviceContext->MemoryUsage);
    }


    // Allocate receive Ndis packets

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating Ndis Receive packets.\n");
    }
    if (DeviceContext->MacInfo.SingleReceive) {
        InitReceivePackets = 2;
    } else {
        InitReceivePackets = NbfConfig->InitReceivePackets;
    }
    for (i=0; i<InitReceivePackets; i++) {

        NbfAllocateReceivePacket (DeviceContext, &NdisPacket);

        if (NdisPacket == NULL) {
            PANIC ("NbfInitialize:  insufficient memory to allocate packet MDLs.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        ReceiveTag = (PRECEIVE_PACKET_TAG)NdisPacket->ProtocolReserved;
        PushEntryList (&DeviceContext->ReceivePacketPool, &ReceiveTag->Linkage);

        IF_NBFDBG (NBF_DEBUG_RESOURCE) {
            PNDIS_BUFFER NdisBuffer;
            NdisQueryPacket(NdisPacket, NULL, NULL, &NdisBuffer, NULL);
            NbfPrint2 ("NbfInitialize: Created NDIS Pkt: %x Buffer: %x\n",
                NdisPacket, NdisBuffer);
        }
    }

    DeviceContext->ReceivePacketInitAllocated = InitReceivePackets;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d receive packets, %ld\n", InitReceivePackets, DeviceContext->MemoryUsage);
    }

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NBFDRVR: allocating Ndis Receive buffers.\n");
    }

    for (i=0; i<NbfConfig->InitReceiveBuffers; i++) {

        NbfAllocateReceiveBuffer (DeviceContext, &BufferTag);

        if (BufferTag == NULL) {
            PANIC ("NbfInitialize: Unable to allocate receive packet.\n");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        PushEntryList (&DeviceContext->ReceiveBufferPool, (PSINGLE_LIST_ENTRY)&BufferTag->Linkage);

    }

    DeviceContext->ReceiveBufferInitAllocated = NbfConfig->InitReceiveBuffers;

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint2 ("%d receive buffers, %ld\n", NbfConfig->InitReceiveBuffers, DeviceContext->MemoryUsage);
    }

    // Store away the PDO for the underlying object
    DeviceContext->PnPContext = SystemSpecific2;

    DeviceContext->State = DEVICECONTEXT_STATE_OPEN;

    //
    // Start the link-level timers running.
    //

    NbfInitializeTimerSystem (DeviceContext);

    //
    // Now link the device into the global list.
    //

    ACQUIRE_DEVICES_LIST_LOCK();
    InsertTailList (&NbfDeviceList, &DeviceContext->Linkage);
    RELEASE_DEVICES_LIST_LOCK();

    DeviceObject = (PDEVICE_OBJECT) DeviceContext;
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    RtlInitUnicodeString(&DeviceString, DeviceContext->DeviceName);

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("TdiRegisterDeviceObject for %S\n", DeviceString.Buffer);
    }

    status = TdiRegisterDeviceObject(&DeviceString,
                                     &DeviceContext->TdiDeviceHandle);

    if (!NT_SUCCESS (status)) {
        RemoveEntryList(&DeviceContext->Linkage);
        goto cleanup;
    }

    RtlCopyMemory(NetBIOSAddress->NetbiosName,
                  DeviceContext->ReservedNetBIOSAddress, 16);

    tdiPnPContext1.tdiPnPContextHeader.ContextSize = sizeof(PVOID);
    tdiPnPContext1.tdiPnPContextHeader.ContextType = TDI_PNP_CONTEXT_TYPE_IF_NAME;
    *(PVOID UNALIGNED *) &tdiPnPContext1.tdiPnPContextHeader.ContextData = &DeviceString;

    tdiPnPContext2.tdiPnPContextHeader.ContextSize = sizeof(PVOID);
    tdiPnPContext2.tdiPnPContextHeader.ContextType = TDI_PNP_CONTEXT_TYPE_PDO;
    *(PVOID UNALIGNED *) &tdiPnPContext2.tdiPnPContextHeader.ContextData = SystemSpecific2;

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("TdiRegisterNetAddress on %S ", DeviceString.Buffer);
        NbfPrint6 ("for %02x%02x%02x%02x%02x%02x\n",
                            NetBIOSAddress->NetbiosName[10],
                            NetBIOSAddress->NetbiosName[11],
                            NetBIOSAddress->NetbiosName[12],
                            NetBIOSAddress->NetbiosName[13],
                            NetBIOSAddress->NetbiosName[14],
                            NetBIOSAddress->NetbiosName[15]);
    }

    status = TdiRegisterNetAddress(pAddress,
                                   &DeviceString,
                                   (TDI_PNP_CONTEXT *) &tdiPnPContext2,
                                   &DeviceContext->ReservedAddressHandle);

    if (!NT_SUCCESS (status)) {
        RemoveEntryList(&DeviceContext->Linkage);
        goto cleanup;
    }

    NbfReferenceDeviceContext ("Load Succeeded", DeviceContext, DCREF_CREATION);

    LEAVE_NBF;
    *NdisStatus = NDIS_STATUS_SUCCESS;

    return(1);

cleanup:

    NbfWriteResourceErrorLog(
        DeviceContext,
        EVENT_TRANSPORT_RESOURCE_POOL,
        501,
        DeviceContext->MemoryUsage,
        0);

    //
    // Cleanup whatever device context we were initializing
    // when we failed.
    //
    *NdisStatus = status;
    ASSERT(status != STATUS_SUCCESS);
    
    if (InterlockedExchange(&DeviceContext->CreateRefRemoved, TRUE) == FALSE) {

        // Stop all internal timers
        NbfStopTimerSystem(DeviceContext);

        // Remove creation reference
        NbfDereferenceDeviceContext ("Load failed", DeviceContext, DCREF_CREATION);
    }

    LEAVE_NBF;

    return (0);
}


VOID
NbfReInitializeDeviceContext(
                                OUT PNDIS_STATUS NdisStatus,
                                IN PDRIVER_OBJECT DriverObject,
                                IN PCONFIG_DATA NbfConfig,
                                IN PUNICODE_STRING BindName,
                                IN PUNICODE_STRING ExportName,
                                IN PVOID SystemSpecific1,
                                IN PVOID SystemSpecific2
                            )
/*++

Routine Description:

    This routine re-initializes an existing nbf device context. In order to
    do this, we need to undo whatever is done in the Unbind handler exposed
    to NDIS - recreate the NDIS binding, and re-start the NBF timer system.

Arguments:

    NdisStatus   - The outputted status of the operations.

    DriverObject - the nbf driver object.

    NbfConfig    - the transport configuration information from the registry.

    SystemSpecific1 - SystemSpecific1 argument to ProtocolBindAdapter

    SystemSpecific2 - SystemSpecific2 argument to ProtocolBindAdapter

Return Value:

    None

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    KIRQL oldIrql;
	PLIST_ENTRY p;
    NTSTATUS status;
    UNICODE_STRING DeviceString;
    UCHAR PermAddr[sizeof(TA_ADDRESS)+TDI_ADDRESS_LENGTH_NETBIOS];
    PTA_ADDRESS pAddress = (PTA_ADDRESS)PermAddr;
    PTDI_ADDRESS_NETBIOS NetBIOSAddress =
                                    (PTDI_ADDRESS_NETBIOS)pAddress->Address;
    struct {
        TDI_PNP_CONTEXT tdiPnPContextHeader;
        PVOID           tdiPnPContextTrailer;
    } tdiPnPContext1, tdiPnPContext2;


    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("ENTER NbfReInitializeDeviceContext for %S\n",
                        ExportName->Buffer);
    }

	//
	// Search the list of NBF devices for a matching device name
	//
	
    ACQUIRE_DEVICES_LIST_LOCK();

    for (p = NbfDeviceList.Flink ; p != &NbfDeviceList; p = p->Flink)
    {
        DeviceContext = CONTAINING_RECORD (p, DEVICE_CONTEXT, Linkage);

        RtlInitUnicodeString(&DeviceString, DeviceContext->DeviceName);

        if (NdisEqualString(&DeviceString, ExportName, TRUE)) {
        					
            // This has to be a rebind - otherwise something wrong

        	ASSERT(DeviceContext->CreateRefRemoved == TRUE);

            // Reference within lock so that it is not cleaned up

            NbfReferenceDeviceContext ("Reload Temp Use", DeviceContext, DCREF_TEMP_USE);

            break;
        }
	}

    RELEASE_DEVICES_LIST_LOCK();

	if (p == &NbfDeviceList)
	{
        IF_NBFDBG (NBF_DEBUG_PNP) {
            NbfPrint2 ("LEAVE NbfReInitializeDeviceContext for %S with Status %08x\n",
                            ExportName->Buffer,
                            STATUS_NOT_FOUND);
        }

        *NdisStatus = STATUS_NOT_FOUND;

	    return;
	}

    //
    // Fire up NDIS again so this adapter talks
    //

    status = NbfInitializeNdis (DeviceContext,
					            NbfConfig,
					            BindName);

    if (!NT_SUCCESS (status)) {
		goto Cleanup;
	}

    // Store away the PDO for the underlying object
    DeviceContext->PnPContext = SystemSpecific2;

    DeviceContext->State = DEVICECONTEXT_STATE_OPEN;

    //
    // Restart the link-level timers on device
    //

    NbfInitializeTimerSystem (DeviceContext);

	//
	// Re-Indicate to TDI that new binding has arrived
	//

    status = TdiRegisterDeviceObject(&DeviceString,
                                     &DeviceContext->TdiDeviceHandle);

    if (!NT_SUCCESS (status)) {
        goto Cleanup;
	}


    pAddress->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
    pAddress->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    NetBIOSAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    RtlCopyMemory(NetBIOSAddress->NetbiosName,
                  DeviceContext->ReservedNetBIOSAddress, 16);

    tdiPnPContext1.tdiPnPContextHeader.ContextSize = sizeof(PVOID);
    tdiPnPContext1.tdiPnPContextHeader.ContextType = TDI_PNP_CONTEXT_TYPE_IF_NAME;
    *(PVOID UNALIGNED *) &tdiPnPContext1.tdiPnPContextHeader.ContextData = &DeviceString;

    tdiPnPContext2.tdiPnPContextHeader.ContextSize = sizeof(PVOID);
    tdiPnPContext2.tdiPnPContextHeader.ContextType = TDI_PNP_CONTEXT_TYPE_PDO;
    *(PVOID UNALIGNED *) &tdiPnPContext2.tdiPnPContextHeader.ContextData = SystemSpecific2;

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("TdiRegisterNetAddress on %S ", DeviceString.Buffer);
        NbfPrint6 ("for %02x%02x%02x%02x%02x%02x\n",
                            NetBIOSAddress->NetbiosName[10],
                            NetBIOSAddress->NetbiosName[11],
                            NetBIOSAddress->NetbiosName[12],
                            NetBIOSAddress->NetbiosName[13],
                            NetBIOSAddress->NetbiosName[14],
                            NetBIOSAddress->NetbiosName[15]);
    }

    status = TdiRegisterNetAddress(pAddress,
                                   &DeviceString,
                                   (TDI_PNP_CONTEXT *) &tdiPnPContext2,
                                   &DeviceContext->ReservedAddressHandle);

    if (!NT_SUCCESS (status)) {
        goto Cleanup;
    }

    // Put the creation reference back again
    NbfReferenceDeviceContext ("Reload Succeeded", DeviceContext, DCREF_CREATION);

    DeviceContext->CreateRefRemoved = FALSE;

    status = NDIS_STATUS_SUCCESS;

Cleanup:

    if (status != NDIS_STATUS_SUCCESS)
    {
        // Stop all internal timers
        NbfStopTimerSystem (DeviceContext);
    }

    NbfDereferenceDeviceContext ("Reload Temp Use", DeviceContext, DCREF_TEMP_USE);

	*NdisStatus = status;

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint2 ("LEAVE NbfReInitializeDeviceContext for %S with Status %08x\n",
                        ExportName->Buffer,
                        status);
    }

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbflog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nbflog.c

Abstract:

    This module contains code which performs various logging activities:

        o   NbfLogRcvPacket
        o   NbfLogSndPacket

Author:

    Chaitanya Kodeboyina   27-April-1998

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if PKT_LOG

VOID
NbfLogRcvPacket(
                PTP_CONNECTION  Connection,
                PTP_LINK        Link,
                PUCHAR          Header,
                UINT            TotalLength,
                UINT            AvailLength
               )
{
    PKT_LOG_QUE  *PktLogQueue;
    PKT_LOG_ELM  *PktLogItem;
    ULONG         BytesSaved;
    LARGE_INTEGER TickCounts;

    if (Connection == NULL) {
    
        PktLogQueue = &Link->LastNRecvs;

        IF_NBFDBG (NBF_DEBUG_PKTLOG) {
            DbgPrint("Logging Recv Packet on LNK %08x: Hdr: %08x, TLen: %5d, ILen: %5d\n",
                            Link, 
                            Header, TotalLength, AvailLength);
        }
    }
    else {
    
        PktLogQueue = &Connection->LastNRecvs;

        IF_NBFDBG (NBF_DEBUG_PKTLOG) {
            DbgPrint("Logging Recv Packet on CON %08x: Hdr: %08x, TLen: %5d, ILen: %5d\n",
                            Connection, 
                            Header, TotalLength, AvailLength);
        }
    }
    
    PktLogItem = &PktLogQueue->PktQue[PktLogQueue->PktNext++];
    PktLogQueue->PktNext %= PKT_QUE_SIZE;

    KeQueryTickCount(&TickCounts);
    PktLogItem->TimeLogged = (USHORT) TickCounts.LowPart;

    PktLogItem->BytesTotal = (USHORT) TotalLength;
    PktLogItem->BytesSaved = (USHORT) AvailLength;
    
    BytesSaved = AvailLength > PKT_LOG_SIZE ? 
                    PKT_LOG_SIZE : 
                    AvailLength;

    RtlCopyMemory (PktLogItem->PacketData, 
                    Header, 
                    BytesSaved);
}

VOID
NbfLogSndPacket(
                PTP_LINK    Link,
                PTP_PACKET  Packet
               )
{
    PKT_LOG_QUE   *PktLogQueue;
    PKT_LOG_ELM   *PktLogItem;
    LARGE_INTEGER  TickCounts;
    PTP_CONNECTION Connection;
    ULONG          BytesSaved;
    
    // Check if this is a packet on a connection
    switch (Packet->Action) {
    
        case PACKET_ACTION_CONNECTION:
        case PACKET_ACTION_END:
            ASSERT(Packet->Owner != NULL);
            
            Connection = Packet->Owner;
            break;

        case PACKET_ACTION_IRP_SP:
            ASSERT(Packet->Owner != NULL);
            
            Connection = IRP_SEND_CONNECTION((PIO_STACK_LOCATION)(Packet->Owner));
            break;

        case PACKET_ACTION_NULL:
        case PACKET_ACTION_RR:
            Connection = NULL;
            break;
        
        default:
            Connection = NULL;
            
            IF_NBFDBG (NBF_DEBUG_PKTLOG) {
                PVOID   Caller1, Caller2;
                
                RtlGetCallersAddress(&Caller1, &Caller2);
                DbgPrint("Callers: @1: %08x, @2: %08x\n",
                                Caller1, Caller2);
            }            

            ASSERT(FALSE);
    }

    if (Connection == NULL) {
    
        PktLogQueue = &Link->LastNSends;
        
        BytesSaved = sizeof(DLC_S_FRAME);

        IF_NBFDBG (NBF_DEBUG_PKTLOG) {
            DbgPrint("Logging Send Packet on LNK %08x: Hdr: %08x, TLen: %5d, ILen: %5d\n",
                     Link, &Packet->Header, Packet->NdisIFrameLength, BytesSaved);
        }
    }
    else {
    
        // Make sure connection is on this link
        ASSERT(Connection->Link == Link);
    
        PktLogQueue = &Connection->LastNSends;
        
        BytesSaved = sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);

        IF_NBFDBG (NBF_DEBUG_PKTLOG) {
            DbgPrint("Logging Send Packet on CON %08x: Hdr: %08x, TLen: %5d, ILen: %5d\n",
                  Connection, &Packet->Header, Packet->NdisIFrameLength, BytesSaved);
        }
    }

    PktLogItem = &PktLogQueue->PktQue[PktLogQueue->PktNext++];
    PktLogQueue->PktNext %= PKT_QUE_SIZE;

    PktLogItem->BytesTotal = (USHORT) Packet->NdisIFrameLength;

    RtlCopyMemory (PktLogItem->PacketData,
                   &Packet->Header[Link->HeaderLength],
                   BytesSaved);

    PktLogItem->BytesSaved = (USHORT) BytesSaved;

    KeQueryTickCount(&TickCounts);
    PktLogItem->TimeLogged = (USHORT) TickCounts.LowPart;
}

VOID
NbfLogIndPacket(
                PTP_CONNECTION  Connection,
                PUCHAR          Header,
                UINT            TotalLength,
                UINT            AvailLength,
                UINT            TakenLength,
                ULONG           Status
               )
{
    PKT_IND_QUE  *PktIndQueue;
    PKT_IND_ELM  *PktIndItem;
    ULONG         BytesSaved;
    LARGE_INTEGER TickCounts;
    
    PktIndQueue = &Connection->LastNIndcs;

    IF_NBFDBG (NBF_DEBUG_PKTLOG) {
        DbgPrint("Indicate the client on CON %08x: Hdr: %08x, TLen: %5d, ILen: %5d, PLen: %5d, ST: %08x\n",
                        Connection, Header, TotalLength, AvailLength, TakenLength, Status);
    }
    
    PktIndItem = &PktIndQueue->PktQue[PktIndQueue->PktNext++];
    PktIndQueue->PktNext %= PKT_QUE_SIZE;

    KeQueryTickCount(&TickCounts);
    PktIndItem->TimeLogged = (USHORT) TickCounts.LowPart;

    PktIndItem->BytesTotal = (USHORT) TotalLength;
    PktIndItem->BytesIndic = (USHORT) AvailLength;
    PktIndItem->BytesTaken = (USHORT) TakenLength;
    
    PktIndItem->IndcnStatus = Status;
    
    BytesSaved = AvailLength > PKT_IND_SIZE ? 
                    PKT_IND_SIZE : 
                    AvailLength;

    RtlCopyMemory (PktIndItem->PacketData, 
                    Header, 
                    BytesSaved);
}

#endif // PKT_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfcnfg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbfcnfg.h

Abstract:

    Private include file for the NBF (NetBIOS Frames Protocol) transport. This
    file defines all constants and structures necessary for support of
    the dynamic configuration of NBF. Note that this file will be replaced
    by calls to the configuration manager over time.

Author:

    David Beaver (dbeaver) 13-Feb-1991

Revision History:

--*/

#ifndef _NBFCONFIG_
#define _NBFCONFIG_

//
// Define the devices we support; this is in leiu of a real configuration
// manager.
//

#define NBF_SUPPORTED_ADAPTERS 10

#define NE3200_ADAPTER_NAME L"\\Device\\NE320001"
#define ELNKII_ADAPTER_NAME L"\\Device\\Elnkii"   // adapter we will talk to
#define ELNKMC_ADAPTER_NAME L"\\Device\\Elnkmc01"
#define ELNK16_ADAPTER_NAME L"\\Device\\Elnk1601"
#define SONIC_ADAPTER_NAME L"\\Device\\Sonic01"
#define LANCE_ADAPTER_NAME L"\\Device\\Lance01"
#define PC586_ADAPTER_NAME L"\\Device\\Pc586"
#define IBMTOK_ADAPTER_NAME L"\\Device\\Ibmtok01"
#define PROTEON_ADAPTER_NAME L"\\Device\\Proteon01"
#define WDLAN_ADAPTER_NAME L"\\Device\\Wdlan01"


//
// configuration structure.
//

typedef struct {

    ULONG InitRequests;
    ULONG InitLinks;
    ULONG InitConnections;
    ULONG InitAddressFiles;
    ULONG InitAddresses;
    ULONG MaxRequests;
    ULONG MaxLinks;
    ULONG MaxConnections;
    ULONG MaxAddressFiles;
    ULONG MaxAddresses;
    ULONG InitPackets;
    ULONG InitReceivePackets;
    ULONG InitReceiveBuffers;
    ULONG InitUIFrames;
    ULONG SendPacketPoolSize;
    ULONG ReceivePacketPoolSize;
    ULONG MaxMemoryUsage;
    ULONG MinimumT1Timeout;
    ULONG DefaultT1Timeout;
    ULONG DefaultT2Timeout;
    ULONG DefaultTiTimeout;
    ULONG LlcRetries;
    ULONG LlcMaxWindowSize;
    ULONG MaximumIncomingFrames;
    ULONG NameQueryRetries;
    ULONG NameQueryTimeout;
    ULONG AddNameQueryRetries;
    ULONG AddNameQueryTimeout;
    ULONG GeneralRetries;
    ULONG GeneralTimeout;
    ULONG WanNameQueryRetries;

    ULONG UseDixOverEthernet;
    ULONG QueryWithoutSourceRouting;
    ULONG AllRoutesNameRecognized;
    ULONG MinimumSendWindowLimit;

    //
    // Names contains NumAdapters pairs of NDIS adapter names (which
    // nbf binds to) and device names (which nbf exports). The nth
    // adapter name is in location n and the device name is in
    // DevicesOffset+n (DevicesOffset may be different from NumAdapters
    // if the registry Bind and Export strings are different sizes).
    //

    ULONG NumAdapters;
    ULONG DevicesOffset;
    NDIS_STRING Names[1];

} CONFIG_DATA, *PCONFIG_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfmac.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    nbfmac.c

Abstract:

    This module contains code which implements Mac type dependent code for
    the NBF transport.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode (Actually, unimportant)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

UCHAR SingleRouteSourceRouting[] = { 0xc2, 0x70 };
UCHAR GeneralRouteSourceRouting[] = { 0x82, 0x70 };
ULONG DefaultSourceRoutingLength = 2;

//
// This is the interpretation of the length bits in
// the 802.5 source-routing information.
//

ULONG SR802_5Lengths[8] = {  516,  1500,  2052,  4472,
                            8144, 11407, 17800, 17800 };


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MacInitializeMacInfo)
#pragma alloc_text(PAGE,MacSetNetBIOSMulticast)
#endif


VOID
MacInitializeMacInfo(
    IN NDIS_MEDIUM MacType,
    IN BOOLEAN UseDix,
    OUT PNBF_NDIS_IDENTIFICATION MacInfo
    )

/*++

Routine Description:

    Fills in the MacInfo table based on MacType.

Arguments:

    MacType - The MAC type we wish to decode.

    UseDix - TRUE if we should use DIX encoding on 802.3.

    MacInfo - The MacInfo structure to fill in.

Return Value:

    None.

--*/

{
    switch (MacType) {
    case NdisMedium802_3:
        MacInfo->DestinationOffset = 0;
        MacInfo->SourceOffset = 6;
        MacInfo->SourceRouting = FALSE;
        MacInfo->AddressLength = 6;
        if (UseDix) {
            MacInfo->TransferDataOffset = 3;
            MacInfo->MaxHeaderLength = 17;
            MacInfo->MediumType = NdisMediumDix;
        } else {
            MacInfo->TransferDataOffset = 0;
            MacInfo->MaxHeaderLength = 14;
            MacInfo->MediumType = NdisMedium802_3;
        }
        MacInfo->MediumAsync = FALSE;
        break;
    case NdisMedium802_5:
        MacInfo->DestinationOffset = 2;
        MacInfo->SourceOffset = 8;
        MacInfo->SourceRouting = TRUE;
        MacInfo->AddressLength = 6;
        MacInfo->TransferDataOffset = 0;
        MacInfo->MaxHeaderLength = 32;
        MacInfo->MediumType = NdisMedium802_5;
        MacInfo->MediumAsync = FALSE;
        break;
    case NdisMediumFddi:
        MacInfo->DestinationOffset = 1;
        MacInfo->SourceOffset = 7;
        MacInfo->SourceRouting = FALSE;
        MacInfo->AddressLength = 6;
        MacInfo->TransferDataOffset = 0;
        MacInfo->MaxHeaderLength = 13;
        MacInfo->MediumType = NdisMediumFddi;
        MacInfo->MediumAsync = FALSE;
        break;
    case NdisMediumWan:
        MacInfo->DestinationOffset = 0;
        MacInfo->SourceOffset = 6;
        MacInfo->SourceRouting = FALSE;
        MacInfo->AddressLength = 6;
        MacInfo->TransferDataOffset = 0;
        MacInfo->MaxHeaderLength = 14;
        MacInfo->MediumType = NdisMedium802_3;
        MacInfo->MediumAsync = TRUE;
        break;
    default:
        ASSERT(FALSE);
    }
}

VOID
MacConstructHeader (
    IN PNBF_NDIS_IDENTIFICATION MacInfo,
    IN PUCHAR Buffer,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress,
    IN UINT PacketLength,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    OUT PUINT HeaderLength
    )

/*++

Routine Description:

    This routine is called to construct the Mac header for the particular
    network type we're talking to.

Arguments:

    MacInfo - Describes the mac we wish to build a header for.

    Buffer - Where to build the header.

    DestinationAddress - the address this packet is to be sent to.

    SourceAddress - Our address. Passing it in as a parameter allows us to play
            games with source if we need to.

    PacketLength - The length of this packet. Note that this does not
            includes the Mac header.

    SourceRouting - Optional source routing information.

    SourceRoutingLength - The length of SourceRouting.

    HeaderLength - Returns the length of the constructed header.

Return Value:

    None.

--*/
{

    //
    // Note network order of bytes.
    //

    switch (MacInfo->MediumType) {

    case NdisMedium802_3:

        *(ULONG UNALIGNED *)&Buffer[6] = *(ULONG UNALIGNED *)&SourceAddress[0];
        Buffer[10] = SourceAddress[4];
        Buffer[11] = SourceAddress[5];

        *(ULONG UNALIGNED *)&Buffer[0] = *(ULONG UNALIGNED *)&DestinationAddress[0];
        Buffer[4] = DestinationAddress[4];
        Buffer[5] = DestinationAddress[5];

        Buffer[12] = (UCHAR)(PacketLength >> 8);
        Buffer[13] = (UCHAR)PacketLength;

        *HeaderLength = 14;

        break;

    case NdisMediumDix:

        *(ULONG UNALIGNED *)&Buffer[6] = *(ULONG UNALIGNED *)&SourceAddress[0];
        Buffer[10] = SourceAddress[4];
        Buffer[11] = SourceAddress[5];

        *(ULONG UNALIGNED *)&Buffer[0] = *(ULONG UNALIGNED *)&DestinationAddress[0];
        Buffer[4] = DestinationAddress[4];
        Buffer[5] = DestinationAddress[5];

        Buffer[12] = 0x80;
        Buffer[13] = 0xd5;

        Buffer[14] = (UCHAR)(PacketLength >> 8);
        Buffer[15] = (UCHAR)PacketLength;

        Buffer[16] = 0x00;
        *HeaderLength = 17;

        break;

    case NdisMedium802_5:

        Buffer[0] = TR_HEADER_BYTE_0;
        Buffer[1] = TR_HEADER_BYTE_1;

        ASSERT (TR_ADDRESS_LENGTH == 6);

        *(ULONG UNALIGNED *)&Buffer[8] = *(ULONG UNALIGNED *)&SourceAddress[0];
        Buffer[12] = SourceAddress[4];
        Buffer[13] = SourceAddress[5];

        *(ULONG UNALIGNED *)&Buffer[2] = *(ULONG UNALIGNED *)&DestinationAddress[0];
        Buffer[6] = DestinationAddress[4];
        Buffer[7] = DestinationAddress[5];

        *HeaderLength = 14;
        if (SourceRouting != NULL) {
            RtlCopyMemory (&Buffer[14], SourceRouting, SourceRoutingLength);
            Buffer[8] |= 0x80;           // add SR bit in source address
            *HeaderLength = 14 + SourceRoutingLength;
        }

        break;

    case NdisMediumFddi:

        Buffer[0] = FDDI_HEADER_BYTE;

        *(ULONG UNALIGNED *)&Buffer[7] = *(ULONG UNALIGNED *)&SourceAddress[0];
        Buffer[11] = SourceAddress[4];
        Buffer[12] = SourceAddress[5];

        *(ULONG UNALIGNED *)&Buffer[1] = *(ULONG UNALIGNED *)&DestinationAddress[0];
        Buffer[5] = DestinationAddress[4];
        Buffer[6] = DestinationAddress[5];

        *HeaderLength = 13;

        break;

    default:
        PANIC ("MacConstructHeader: PANIC! called with unsupported Mac type.\n");

        // This should not happen - but just in case
        *HeaderLength = 0;
    }
}


VOID
MacReturnMaxDataSize(
    IN PNBF_NDIS_IDENTIFICATION MacInfo,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN UINT DeviceMaxFrameSize,
    IN BOOLEAN AssumeWorstCase,
    OUT PUINT MaxFrameSize
    )

/*++

Routine Description:

    This routine returns the space available for user data in a MAC packet.
    This will be the available space after the MAC header; all LLC and NBF
    headers will be included in this space.

Arguments:

    MacInfo - Describes the MAC we wish to decode.

    SourceRouting - If we are concerned about a reply to a specific
        frame, then this information is used.

    SourceRouting - The length of SourceRouting.

    MaxFrameSize - The maximum frame size as returned by the adapter.

    AssumeWorstCase - TRUE if we should be pessimistic.

    MaxDataSize - The maximum data size computed.

Return Value:

    None.

--*/

{
    switch (MacInfo->MediumType) {

    case NdisMedium802_3:

        //
        // For 802.3, we always have a 14-byte MAC header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 14;
        break;

    case NdisMediumDix:

        //
        // For DIX, we have the 14-byte MAC header plus
        // the three-byte DIX header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 17;
        break;

    case NdisMedium802_5:

        //
        // For 802.5, if we have source routing information then
        // use that, otherwise assume the worst if told to.
        //

        if (SourceRouting && SourceRoutingLength >= 2) {

            UINT SRLength;

            SRLength = SR802_5Lengths[(SourceRouting[1] & 0x70) >> 4];
            DeviceMaxFrameSize -= (SourceRoutingLength + 14);

            if (DeviceMaxFrameSize < SRLength) {
                *MaxFrameSize = DeviceMaxFrameSize;
            } else {
                *MaxFrameSize = SRLength;
            }

        } else {

            if (!AssumeWorstCase) {
                *MaxFrameSize = DeviceMaxFrameSize - 16;
            } else if (DeviceMaxFrameSize < (544+sizeof(DLC_FRAME)+sizeof(NBF_HDR_CONNECTIONLESS))) {
                *MaxFrameSize = DeviceMaxFrameSize - 32;
            } else {
                *MaxFrameSize = 512 + sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS);
            }
        }

        break;

    case NdisMediumFddi:

        //
        // For FDDI, we always have a 13-byte MAC header.
        //

        *MaxFrameSize = DeviceMaxFrameSize - 13;
        break;

    }
}



VOID
MacSetNetBIOSMulticast (
    IN NDIS_MEDIUM Type,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine sets the NetBIOS broadcast address into a buffer provided
    by the user.

Arguments:

    Type the Mac Medium type.

    Buffer the buffer to put the multicast address in.


Return Value:

    none.

--*/
{
    switch (Type) {
    case NdisMedium802_3:
    case NdisMediumDix:
        Buffer[0] = 0x03;
        Buffer[ETHERNET_ADDRESS_LENGTH-1] = 0x01;
        break;

    case NdisMedium802_5:
        Buffer[0] = 0xc0;
        Buffer[TR_ADDRESS_LENGTH-1] = 0x80;
        break;

    case NdisMediumFddi:
        Buffer[0] = 0x03;
        Buffer[FDDI_ADDRESS_LENGTH-1] = 0x01;
        break;

    default:
        PANIC ("MacSetNetBIOSAddress: PANIC! called with unsupported Mac type.\n");
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfmac.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mac.h

Abstract:

    This header file defines manifest constants and necessary macros for use
    by transports dealing with multiple MAC cards through the NDIS interface.

Author:

    David Beaver (dbeaver) 02-Oct-1990

Revision History:

--*/

#ifndef _MAC_
#define _MAC_

//
// MAC-specific definitions, some of which get used below
//

#define MAX_MAC_HEADER_LENGTH       32
#define MAX_SOURCE_ROUTING          18
#define MAX_DEFAULT_SR               2

#define ETHERNET_ADDRESS_LENGTH        6
#define ETHERNET_PACKET_LENGTH      1514  // max size of an ethernet packet
#define ETHERNET_HEADER_LENGTH        14  // size of the ethernet MAC header
#define ETHERNET_DATA_LENGTH_OFFSET   12
#define ETHERNET_DESTINATION_OFFSET    0
#define ETHERNET_SOURCE_OFFSET         6

#define TR_ADDRESS_LENGTH        6
#define TR_ADDRESS_OFFSET        2
#define TR_SPECIFIC_OFFSET       0
#define TR_PACKET_LENGTH      1514  // max size of a TR packet
#define TR_HEADER_LENGTH        36  // size of the MAC header w/o source routing
#define TR_DATA_LENGTH_OFFSET    0
#define TR_DESTINATION_OFFSET    2
#define TR_SOURCE_OFFSET         8
#define TR_ROUTING_OFFSET       14      // starts at the 14th byte
#define TR_GR_BCAST_LENGTH       2
#define TR_GR_BROADCAST         0xC270  // what a general route b'cast looks like
#define TR_ROUTING_LENGTH_MASK  0x1F    // low 5 bits in byte
#define TR_DIRECTION_MASK       0x80    // returns direction bit

#define TR_PREAMBLE_AC        0x10  // how would these be specified?
#define TR_PREAMBLE_FC        0x40

#define TR_HEADER_BYTE_0            0x10
#define TR_HEADER_BYTE_1            0x40

#define FDDI_ADDRESS_LENGTH         6
#define FDDI_HEADER_BYTE            0x57



//
// We need this to define information about the MAC. Note that
// it is a strange structure in that the first four elements
// are for use internally by the nbfmac routines, while the
// DeviceContext knows about and uses the last two.
//

typedef struct _NBF_NDIS_IDENTIFICATION {
  NDIS_MEDIUM MediumType;
  BOOLEAN SourceRouting;
  BOOLEAN MediumAsync;
  BOOLEAN QueryWithoutSourceRouting;
  BOOLEAN AllRoutesNameRecognized;
  ULONG DestinationOffset;
  ULONG SourceOffset;
  ULONG AddressLength;
  ULONG TransferDataOffset;
  ULONG MaxHeaderLength;
  BOOLEAN CopyLookahead;
  BOOLEAN ReceiveSerialized;
  BOOLEAN TransferSynchronous;
  BOOLEAN SingleReceive;
} NBF_NDIS_IDENTIFICATION, *PNBF_NDIS_IDENTIFICATION;



VOID
MacConstructHeader(
    IN PNBF_NDIS_IDENTIFICATION MacInfo,
    IN PUCHAR Buffer,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress,
    IN UINT PacketLength,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    OUT PUINT HeaderLength
    );

VOID
MacReturnMaxDataSize(
    IN PNBF_NDIS_IDENTIFICATION MacInfo,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN UINT DeviceMaxFrameSize,
    IN BOOLEAN AssumeWorstCase,
    OUT PUINT MaxFrameSize
    );

VOID
MacInitializeMacInfo(
    IN NDIS_MEDIUM MacType,
    IN BOOLEAN UseDix,
    OUT PNBF_NDIS_IDENTIFICATION MacInfo
    );


extern UCHAR SingleRouteSourceRouting[];
extern UCHAR GeneralRouteSourceRouting[];
extern ULONG DefaultSourceRoutingLength;


//++
//
// VOID
// MacReturnDestinationAddress(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Packet,
//     OUT PVOID * DestinationAddress
//     );
//
// Routine Description:
//
//     Returns the a pointer to the destination address in the packet.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Packet - The packet data.
//
//     DestinationAddress - Returns the start of the destination address.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnDestinationAddress(_MacInfo, _Packet, _DestinationAddress) \
    *(_DestinationAddress) = ((PUCHAR)(_Packet)) + (_MacInfo)->DestinationOffset


//++
//
// VOID
// MacReturnSourceAddress(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Packet,
//     OUT PHARDWARE_ADDRESS SourceAddressBuffer,
//     OUT PHARDWARE_ADDRESS * SourceAddress,
//     OUT BOOLEAN * Multicast OPTIONAL
//     );
//
// Routine Description:
//
//     Copies the source address in the packet into SourceAddress.
//     NOTE THAT IT MAY COPY THE DATA, UNLIKE ReturnDestinationAddress
//     AND ReturnSourceRouting.  Optionally, indicates whether the
//     destination address is a multicast address.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Packet - The packet data.
//
//     SourceAddressBuffer - A buffer to hold the source address,
//         if needed.
//
//     SourceAddress - Returns a pointer to the source address.
//
//     Multicast - Optional pointer to a BOOLEAN to receive indication
//         of whether the destination was a multicast address.
//
// Return Value:
//
//     None.
//
//--

//
// NOTE:  The default case below handles Ethernet and FDDI.
//

#define MacReturnSourceAddress(_MacInfo, _Packet, _SourceAddressBuffer, \
                                _SourceAddress, _Multicast)             \
{                                                                       \
    PUCHAR TmpPacket = (PUCHAR)(_Packet);                               \
    PUCHAR SrcBuffer = (PUCHAR)(_SourceAddressBuffer);                  \
                                                                        \
    switch ((_MacInfo)->MediumType) {                                   \
    case NdisMedium802_5:                                               \
        if (ARGUMENT_PRESENT(_Multicast)) {                              \
            *(PBOOLEAN)(_Multicast) = TmpPacket[2] & 0x80;                \
        }                                                                  \
        if (TmpPacket[8] & 0x80) {                                          \
            *(PULONG)SrcBuffer = *(ULONG UNALIGNED *)(&TmpPacket[8]) & ~0x80;\
            SrcBuffer[4] = TmpPacket[12];                                   \
            SrcBuffer[5] = TmpPacket[13];                                  \
            *(_SourceAddress) = (PHARDWARE_ADDRESS)SrcBuffer;             \
        } else {                                                         \
            *(_SourceAddress) = (PHARDWARE_ADDRESS)(TmpPacket + 8);     \
        }                                                               \
        break;                                                          \
    default:                                                            \
        if (ARGUMENT_PRESENT(_Multicast)) {                             \
            *(PBOOLEAN)(_Multicast) = TmpPacket[0] & 0x01;              \
        }                                                               \
        *(_SourceAddress) = (PHARDWARE_ADDRESS)(TmpPacket +             \
                                        (_MacInfo)->SourceOffset);      \
        break;                                                          \
    }                                                                   \
}


//++
//
// VOID
// MacReturnSourceRouting(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Packet,
//     OUT PVOID * SourceRouting
//     OUT PUINT SourceRoutingLength
//     );
//
// Routine Description:
//
//     Returns the a pointer to the source routing info in the packet.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Packet - The packet data.
//
//     SourceRouting - Returns the start of the source routing information,
//         or NULL if none is present.
//
//     SourceRoutingLength - Returns the length of the source routing
//         information.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnSourceRouting(_MacInfo, _Packet, _SourceRouting, _SourceRoutingLength) \
{                                                               \
    PUCHAR TmpPacket = (PUCHAR)(_Packet);                       \
    *(_SourceRoutingLength) = 0;                                \
    if ((_MacInfo)->SourceRouting) {                            \
        if (TmpPacket[8] & 0x80) {                              \
            *(_SourceRouting) = TmpPacket + 14;                 \
            *(_SourceRoutingLength) = TmpPacket[14] & 0x1f;     \
        } else {                                                \
            *(_SourceRouting) = NULL;                           \
        }                                                       \
    } else {                                                    \
        *(_SourceRouting) = NULL;                               \
    }                                                           \
}

//++
//
// VOID
// MacIsMulticast(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Packet,
//     OUT PBOOLEAN Multicast
//     );
//
// Routine Description:
//
//     Returns TRUE if the packet is sent to the multicast address.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Packet - The packet data.
//
//     Multicast - Returns the result.
//
// Return Value:
//
//     None.
//
//--

#define MacIsMulticast(_MacInfo, _Packet, _Multicast)           \
{                                                               \
    PUCHAR TmpPacket = (PUCHAR)(_Packet);                       \
                                                                \
    switch ((_MacInfo)->MediumType) {                           \
    case NdisMedium802_5:                                       \
        *(_Multicast) = ((TmpPacket[2] & 0x80) != 0);           \
        break;                                                  \
    default:                                                    \
        *(_Multicast) = ((TmpPacket[0] & 0x01) != 0);           \
        break;                                                  \
    }                                                           \
}

//++
//
// VOID
// MacReturnPacketLength(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Header,
//     IN UINT PacketLength,
//     OUT PUINT DataLength
//     );
//
// Routine Description:
//
//     Returns the length of data in the packet given the header.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Header - The packet header.
//
//     PacketLength - The length of the data (not including header).
//
//     DataLength - Returns the length of the data.  Unchanged if the
//         packet is not recognized.  Should be initialized by caller to 0.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnPacketLength(_MacInfo, _Header, _HeaderLength, _PacketLength, _DataLength, _LookaheadBuffer, _LookaheadBufferLength) \
{                                                               \
    PUCHAR TmpPacket = (PUCHAR)(_Header);                       \
    UINT TmpLength;                                             \
                                                                \
    switch ((_MacInfo)->MediumType) {                           \
    case NdisMedium802_3:                                       \
        if ((_HeaderLength) >= 14) {                            \
            TmpLength = (TmpPacket[12] << 8) | TmpPacket[13];   \
            if (TmpLength <= 0x600) {                           \
                if (TmpLength <= (_PacketLength)) {             \
                    *(_DataLength) = TmpLength;                 \
                }                                               \
            }                                                   \
        }                                                       \
        break;                                                  \
    case NdisMedium802_5:                                       \
        if (((_HeaderLength) >= 14) &&                          \
            (!(TmpPacket[8] & 0x80) ||                          \
             ((_HeaderLength) >=                                \
                       (UINT)(14 + (TmpPacket[14] & 0x1f))))) { \
            *(_DataLength) = (_PacketLength);                   \
        }                                                       \
        break;                                                  \
    case NdisMediumFddi:                                        \
        if ((_HeaderLength) >= 13) {                            \
            *(_DataLength) = (_PacketLength);                   \
        }                                                       \
        break;                                                  \
    case NdisMediumDix:                                          \
        if ((TmpPacket[12] == 0x80) && (TmpPacket[13] == 0xd5)) { \
            if (*(_LookaheadBufferLength) >= 3) {                 \
                TmpPacket = (PUCHAR)(*(_LookaheadBuffer));        \
                TmpLength = (TmpPacket[0] << 8) | TmpPacket[1];   \
                if (TmpLength <= (_PacketLength)-3) {             \
                    *(_DataLength) = TmpLength;                   \
                    *(_LookaheadBuffer) = (PVOID)(TmpPacket + 3); \
                    *(_LookaheadBufferLength) -= 3;               \
                }                                                \
            }                                                   \
        }                                                       \
        break;                                                  \
    }                                                           \
}

//++
//
// VOID
// MacReturnHeaderLength(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Packet,
//     OUT PVOID HeaderLength,
//     );
//
// Routine Description:
//
//     Returns the length of the MAC header in a packet (this
//     is used for loopback indications to separate header
//     and data).
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Header - The packet header.
//
//     HeaderLength - Returns the length of the header.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnHeaderLength(_MacInfo, _Header, _HeaderLength) \
{                                                               \
    PUCHAR TmpPacket = (PUCHAR)(_Header);                       \
                                                                \
    switch ((_MacInfo)->MediumType) {                           \
    case NdisMedium802_3:                                       \
    case NdisMediumDix:                                         \
        *(_HeaderLength) = 14;                                  \
        break;                                                  \
    case NdisMedium802_5:                                       \
         if (TmpPacket[8] & 0x80) {                             \
             *(_HeaderLength) = (TmpPacket[14] & 0x1f) + 14;    \
         } else {                                               \
             *(_HeaderLength) = 14;                             \
         }                                                      \
        break;                                                  \
    case NdisMediumFddi:                                        \
        *(_HeaderLength) = 13;                                  \
        break;                                                  \
    }                                                           \
}

//++
//
// VOID
// MacReturnSingleRouteSR(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     OUT PVOID * SingleRouteSR,
//     OUT PUINT SingleRouteSRLength
//     );
//
// Routine Description:
//
//     Returns the a pointer to the standard single route broadcast
//     source routing information for the media type. This is used
//     for ADD_NAME_QUERY, DATAGRAM, NAME_IN_CONFLICT, NAME_QUERY,
//     and STATUS_QUERY frames.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     SingleRouteSR - Returns a pointer to the data.
//
//     SingleRouteSRLength - The length of SingleRouteSR.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnSingleRouteSR(_MacInfo, _SingleRouteSR, _SingleRouteSRLength) \
{                                                               \
    switch ((_MacInfo)->MediumType) {                           \
    case NdisMedium802_5:                                       \
        *(_SingleRouteSR) = SingleRouteSourceRouting;           \
        *(_SingleRouteSRLength) = DefaultSourceRoutingLength;   \
        break;                                                  \
    default:                                                    \
        *(_SingleRouteSR) = NULL;                               \
        break;                                                  \
    }                                                           \
}


//++
//
// VOID
// MacReturnGeneralRouteSR(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     OUT PVOID * GeneralRouteSR,
//     OUT PUINT GeneralRouteSRLength
//     );
//
// Routine Description:
//
//     Returns the a pointer to the standard general route broadcast
//     source routing information for the media type. This is used
//     for NAME_RECOGNIZED frames.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     GeneralRouteSR - Returns a pointer to the data.
//
//     GeneralRouteSRLength - The length of GeneralRouteSR.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnGeneralRouteSR(_MacInfo, _GeneralRouteSR, _GeneralRouteSRLength) \
{                                                               \
    switch ((_MacInfo)->MediumType) {                           \
    case NdisMedium802_5:                                       \
        *(_GeneralRouteSR) = GeneralRouteSourceRouting;         \
        *(_GeneralRouteSRLength) = DefaultSourceRoutingLength;  \
        break;                                                  \
    default:                                                    \
        *(_GeneralRouteSR) = NULL;                              \
        break;                                                  \
    }                                                           \
}

#if 0

//++
//
// VOID
// MacCreateGeneralRouteReplySR(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PUCHAR ExistingSR,
//     IN UINT ExistingSRLength,
//     OUT PUCHAR * NewSR
//     );
//
// Routine Description:
//
//     This modifies an existing source routing entry to make
//     it into a general-route source routing entry. The assumption
//     is that is to reply to existing source routing, so the
//     direction bit is also reversed. In addition, if it is
//     determined that no source routing is needed in the reply,
//     then NULL is returned.
//
//     Note that the information is modified in-place, but a
//     separate pointer is returned (to allow NULL to be returned).
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     ExistingSR - The existing source routing to be modified.
//
// Return Value:
//
//     None.
//
//--

#define MacCreateGeneralRouteReplySR(_MacInfo, _ExistingSR, _ExistingSRLength, _NewSR)  \
{                                                               \
    if (_ExistingSR) {                                          \
        PUCHAR TmpSR = (PUCHAR)(_ExistingSR);                   \
        switch ((_MacInfo)->MediumType) {                       \
        case NdisMedium802_5:                                   \
            TmpSR[0] = (TmpSR[0] & 0x1f) | 0x80;                \
            TmpSR[1] = (TmpSR[1] ^ 0x80);                       \
            *(_NewSR) = (_ExistingSR);                          \
            break;                                              \
        default:                                                \
            *(_NewSR) = (_ExistingSR);                          \
            break;                                              \
        }                                                       \
    } else {                                                    \
        *(_NewSR) = NULL;                                       \
    }                                                           \
}
#endif


//++
//
// VOID
// MacCreateNonBroadcastReplySR(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PUCHAR ExistingSR,
//     IN UINT ExistingSRLength,
//     OUT PUCHAR * NewSR
//     );
//
// Routine Description:
//
//     This modifies an existing source routing entry to make
//     it into a non-broadcast source routing entry. The assumption
//     is that is to reply to existing source routing, so the
//     direction bit is also reversed. In addition, if it is
//     determined that no source routing is needed in the reply,
//     then NULL is returned.
//
//     Note that the information is modified in-place, but a
//     separate pointer is returned (to allow NULL to be returned).
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     ExistingSR - The existing source routing to be modified.
//
// Return Value:
//
//     None.
//
//--

#define MacCreateNonBroadcastReplySR(_MacInfo, _ExistingSR, _ExistingSRLength, _NewSR)  \
{                                                               \
    if (_ExistingSR) {                                          \
        PUCHAR TmpSR = (PUCHAR)(_ExistingSR);                   \
        switch ((_MacInfo)->MediumType) {                       \
        case NdisMedium802_5:                                   \
            if ((_ExistingSRLength) == 2) {                     \
                *(_NewSR) = NULL;                               \
            } else {                                            \
                TmpSR[0] = (TmpSR[0] & 0x1f);                   \
                TmpSR[1] = (TmpSR[1] ^ 0x80);                   \
                *(_NewSR) = (_ExistingSR);                      \
            }                                                   \
            break;                                              \
        default:                                                \
            *(_NewSR) = (_ExistingSR);                          \
            break;                                              \
        }                                                       \
    } else {                                                    \
        *(_NewSR) = NULL;                                       \
    }                                                           \
}


//++
//
// VOID
// MacModifyHeader(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PUCHAR Header,
//     IN UINT PacketLength
//     );
//
// Routine Description:
//
//     Modifies a pre-built packet header to include the
//     packet length. Used for connection-oriented traffic
//     where the header is pre-built.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Header - The header to modify.
//
//     PacketLength - Packet length (not including the header).
//       Currently this is the only field that cannot be pre-built.
//
// Return Value:
//
//     None.
//
//--

#define MacModifyHeader(_MacInfo, _Header, _PacketLength)            \
{                                                                    \
    switch ((_MacInfo)->MediumType) {                                \
    case NdisMedium802_3:                                            \
        (_Header)[12] = (UCHAR)((_PacketLength) >> 8);               \
        (_Header)[13] = (UCHAR)((_PacketLength) & 0xff);             \
        break;                                                       \
    case NdisMediumDix:                                              \
        (_Header)[14] = (UCHAR)((_PacketLength) >> 8);               \
        (_Header)[15] = (UCHAR)((_PacketLength) & 0xff);             \
        break;                                                       \
    }                                                                \
}


//++
//
// VOID
// MacReturnMagicAddress(
//     IN PNBF_NDIS_IDENTIFICATION MacInfo,
//     IN PVOID Address,
//     OUT PULARGE_INTEGER Magic
//     );
//
// Routine Description:
//
//     MacReturnMagicAddress returns the link as a 64 bit number.
//     We then find the link in the link trees by doing a large
//     integer comparison.
//
//     The number is constructed by assigning the last four bytes of
//     the address as the low longword, and the first two bytes as
//     the high one. For 802_5 we need to mask off the source routing
//     bit in byte 0 of the address.
//
// Arguments:
//
//     MacInfo - Describes the MAC we wish to decode.
//
//     Address - The address we are encoding.
//
//     Magic - Returns the magic number for this address.
//
// Return Value:
//
//     None.
//
//--

#define MacReturnMagicAddress(_MacInfo, _Address, _Magic)              \
{                                                                      \
    PUCHAR TempAddr = (PUCHAR)(_Address);                              \
                                                                       \
    (_Magic)->LowPart = *((LONG UNALIGNED *)(TempAddr + 2));           \
    if ((_MacInfo)->MediumType == NdisMedium802_5) {                   \
        (_Magic)->HighPart = ((TempAddr[0] & 0x7f) << 8) + TempAddr[1]; \
    } else {                                                           \
        (_Magic)->HighPart = (TempAddr[0] << 8) + TempAddr[1];         \
    }                                                                  \
}


VOID
MacSetNetBIOSMulticast (
    IN NDIS_MEDIUM Type,
    IN PUCHAR Buffer
    );



//  VOID
//  NbfSetNdisPacketLength (
//      IN NDIS_PACKET Packet,
//      IN ULONG Length
//      );
//
// NB: This is not a general purpose macro; it assumes that we are setting the
//     length of an NDIS packet with only one NDIS_BUFFER chained. We do
//     this to save time during the sending of short control packets.
//

#define NbfSetNdisPacketLength(_packet,_length) {              \
    PNDIS_BUFFER NdisBuffer;                                   \
    NdisQueryPacket((_packet), NULL, NULL, &NdisBuffer, NULL); \
    NdisAdjustBufferLength(NdisBuffer, (_length));             \
    NdisRecalculatePacketCounts(_packet);                      \
}

#endif // ifdef _MAC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nbfpnp.c

Abstract:

    This module contains code which allocates and initializes all data 
    structures needed to activate a plug and play binding.  It also informs
    tdi (and thus nbf clients) of new devices and protocol addresses. 

Author:

    Jim McNelis (jimmcn)  1-Jan-1996

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef RASAUTODIAL

LONG NumberOfBinds = 0;

VOID
NbfAcdBind();

VOID
NbfAcdUnbind();

#endif // RASAUTODIAL

// PnP-Power Declarations

VOID
NbfPnPEventDispatch(
                    IN PVOID            NetPnPEvent
                   );

VOID
NbfPnPEventComplete(
                    IN PNET_PNP_EVENT   NetPnPEvent,
                    IN NTSTATUS         retVal
                   );

NTSTATUS
NbfPnPBindsComplete(
                    IN PDEVICE_CONTEXT  DeviceContext,
                    IN PNET_PNP_EVENT   NetPnPEvent
                   );

// PnP Handler Routines
                        
VOID
NbfProtocolBindAdapter(
                OUT PNDIS_STATUS    NdisStatus,
                IN NDIS_HANDLE      BindContext,
                IN PNDIS_STRING     DeviceName,
                IN PVOID            SystemSpecific1,
                IN PVOID            SystemSpecific2
                ) 
/*++

Routine Description:

    This routine activates a transport binding and exposes the new device
    and associated addresses to transport clients.  This is done by reading
    the registry, and performing any one time initialization of the transport
    and then natching the device to bind to with the linkage information from
    the registry.  If we have a match for that device the bind will be 
    performed.

Arguments:

    NdisStatus      - The status of the bind.

    BindContext     - A context used for NdisCompleteBindAdapter() if 
                      STATUS_PENDING is returned.

    DeviceName      - The name of the device that we are binding with.

    SystemSpecific1 - Unused (a pointer to an NDIS_STRING to use with
                      NdisOpenProtocolConfiguration.  This is not used by nbf
                      since there is no adapter specific information when 
                      configuring the protocol via the registry. Passed to
                      NbfInitializeOneDeviceContext for possible future use)

    SystemSpecific2 - Passed to NbfInitializeOneDeviceContext to be used
                      in a call to TdiRegisterNetAddress

Return Value:

    None.

--*/
{
    PUNICODE_STRING ExportName;
    UNICODE_STRING ExportString;
    ULONG i, j, k;
    NTSTATUS status;

#if DBG
    // We can never be called at DISPATCH or above
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        DbgBreakPoint();
    }
#endif

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("ENTER NbfProtocolBindAdapter for %S\n", DeviceName->Buffer);
    }

    if (NbfConfig == NULL) {
        //
        // This allocates the CONFIG_DATA structure and returns
        // it in NbfConfig.
        //

        status = NbfConfigureTransport(&NbfRegistryPath, &NbfConfig);

        if (!NT_SUCCESS (status)) {
            PANIC (" Failed to initialize transport, Nbf binding failed.\n");
            *NdisStatus = NDIS_STATUS_RESOURCES;
            return;
        }

#if DBG
        //
        // Allocate the debugging tables. 
        //

        NbfConnectionTable = (PVOID *)ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(PVOID) *
                                          (NbfConfig->InitConnections + 2 +
                                           NbfConfig->InitRequests + 2 +
                                           NbfConfig->InitUIFrames + 2 +
                                           NbfConfig->InitPackets + 2 +
                                           NbfConfig->InitLinks + 2 +
                                           NbfConfig->InitAddressFiles + 2 +
                                           NbfConfig->InitAddresses + 2),
                                           NBF_MEM_TAG_CONNECTION_TABLE);

        ASSERT (NbfConnectionTable);

        NbfRequestTable = NbfConnectionTable + (NbfConfig->InitConnections + 2);
        NbfUiFrameTable = NbfRequestTable + (NbfConfig->InitRequests + 2);
        NbfSendPacketTable = NbfUiFrameTable + (NbfConfig->InitUIFrames + 2);
        NbfLinkTable = NbfSendPacketTable + (NbfConfig->InitPackets + 2);
        NbfAddressFileTable = NbfLinkTable + (NbfConfig->InitLinks + 2);
        NbfAddressTable = NbfAddressFileTable + 
                                        (NbfConfig->InitAddressFiles + 2);
#endif

    }

    //
    // Loop through all the adapters that are in the configuration
    // information structure (this is the initial cache) until we
    // find the one that NDIS is calling Protocol bind adapter for. 
    //        

    for (j = 0; j < NbfConfig->NumAdapters; j++ ) {

        if (NdisEqualString(DeviceName, &NbfConfig->Names[j], TRUE)) {
            break;
        }
    }

    if (j < NbfConfig->NumAdapters) {

        // We found the bind to export mapping in initial cache

        ExportName = &NbfConfig->Names[NbfConfig->DevicesOffset + j];
    }
    else {

        IF_NBFDBG (NBF_DEBUG_PNP) {
        
            NbfPrint1("\nNot In Initial Cache = %08x\n\n", DeviceName->Buffer);

            NbfPrint0("Bind Names in Initial Cache: \n");

            for (k = 0; k < NbfConfig->NumAdapters; k++)
            {
                NbfPrint3("Config[%2d]: @ %08x, %75S\n",
                           k, &NbfConfig->Names[k],
                           NbfConfig->Names[k].Buffer);
            }

            NbfPrint0("Export Names in Initial Cache: \n");

            for (k = 0; k < NbfConfig->NumAdapters; k++)
            {
                NbfPrint3("Config[%2d]: @ %08x, %75S\n",
                           k, &NbfConfig->Names[NbfConfig->DevicesOffset + k],
                           NbfConfig->Names[NbfConfig->DevicesOffset + k].Buffer);
            }

            NbfPrint0("\n\n");
        }

        ExportName = &ExportString;

        //
        // We have not found the name in the initial registry info;
        // Read the registry and check if a new binding appeared...
        //

        *NdisStatus = NbfGetExportNameFromRegistry(&NbfRegistryPath,
                                                   DeviceName,
                                                   ExportName
                                                  );
        if (!NT_SUCCESS (*NdisStatus))
        {
            return;
        }
    }
        
    NbfInitializeOneDeviceContext(NdisStatus, 
                                  NbfDriverObject,
                                  NbfConfig,
                                  DeviceName,
                                  ExportName,
                                  SystemSpecific1,
                                  SystemSpecific2
                                 );

    // Check if we need to de-allocate the ExportName buffer

    if (ExportName == &ExportString)
    {
        ExFreePool(ExportName->Buffer);
    }

    if (*NdisStatus == NDIS_STATUS_SUCCESS) {

        if (InterlockedIncrement(&NumberOfBinds) == 1) {

#ifdef RASAUTODIAL

            // 
            // This is the first successful open.
            //
#if DBG
            DbgPrint("Calling NbfAcdBind()\n");
#endif
            //
            // Get the automatic connection driver entry points.
            //
            
            NbfAcdBind();

#endif // RASAUTODIAL

        }            
    }

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint2 ("LEAVE NbfProtocolBindAdapter for %S with Status %08x\n", 
                        DeviceName->Buffer, *NdisStatus);
    }

    return;
}


VOID
NbfProtocolUnbindAdapter(
                    OUT PNDIS_STATUS NdisStatus,
                    IN NDIS_HANDLE ProtocolBindContext,
                    IN PNDIS_HANDLE UnbindContext
                        )
/*++

Routine Description:

    This routine deactivates a transport binding. Before it does this, it
    indicates to all clients above, that the device is going away. Clients
    are expected to close all open handles to the device.

    Then the device is pulled out of the list of NBF devices, and all
    resources reclaimed. Any connections, address files etc, that the
    client has cleaned up are forcibly cleaned out at this point. Any
    outstanding requests are completed (with a status). Any future
    requests are automatically invalid as they use obsolete handles.

Arguments:

    NdisStatus              - The status of the bind.

    ProtocolBindContext     - the context from the openadapter call 

    UnbindContext           - A context for async unbinds.


Return Value:

    None.
    
--*/
{
    PDEVICE_CONTEXT DeviceContext;
    PTP_ADDRESS Address;
    NTSTATUS status;
    KIRQL oldirql;
    PLIST_ENTRY p;

#if DBG

    // We can never be called at DISPATCH or above
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        DbgBreakPoint();
    }
#endif

    // Get the device context for the adapter being unbound
    DeviceContext = (PDEVICE_CONTEXT) ProtocolBindContext;

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint1 ("ENTER NbfProtocolUnbindAdapter for %S\n", DeviceContext->DeviceName);
    }

    // Remove creation ref if it has not already been removed,
    // after telling TDI and its clients that we'r going away.
    // This flag also helps prevent any more TDI indications
    // of deregister addr/devobj - after the 1st one succeeds.
    if (InterlockedExchange(&DeviceContext->CreateRefRemoved, TRUE) == FALSE) {

        // Assume upper layers clean up by closing connections
        // when we deregister all addresses and device object,
        // but this can happen asynchronously, after we return
        // from the (asynchronous) TdiDeregister.. calls below 

        // Inform TDI by deregistering the reserved netbios address
        *NdisStatus = TdiDeregisterNetAddress(DeviceContext->ReservedAddressHandle);

        if (!NT_SUCCESS (*NdisStatus)) {
        
            IF_NBFDBG (NBF_DEBUG_PNP) {
                NbfPrint1("No success deregistering this address,STATUS = %08X\n",*NdisStatus);
            }

            // this can never happen
            ASSERT(FALSE);

            // In case it happens, this allows a redo of the unbind
            DeviceContext->CreateRefRemoved = FALSE;
            
            return;
        }
        
        // Inform TDI (and its clients) that device is going away
        *NdisStatus = TdiDeregisterDeviceObject(DeviceContext->TdiDeviceHandle);

        if (!NT_SUCCESS (*NdisStatus)) {
        
            IF_NBFDBG (NBF_DEBUG_PNP) {
                NbfPrint1("No success deregistering device object,STATUS = %08X\n",*NdisStatus);
            }

            // This can never happen
            ASSERT(FALSE);

            // In case it happens, this allows a redo of the unbind
            DeviceContext->CreateRefRemoved = FALSE;

            return;
        }

        // Clear away the association with the underlying PDO object
        DeviceContext->PnPContext = NULL;

        // Stop all the internal timers - this'll clear timer refs
        NbfStopTimerSystem(DeviceContext);

        // Cleanup the Ndis Binding as it is not useful on return
        // from this function - do not try to use it after this
        NbfCloseNdis(DeviceContext);

        // BUG BUG -- probable race condition with timer callbacks
        // Do we wait for some time in case a timer func gets in ?

        // Removing creation reference means that once all handles
        // r closed,device will automatically be garbage-collected
        NbfDereferenceDeviceContext ("Unload", DeviceContext, DCREF_CREATION);

        if (InterlockedDecrement(&NumberOfBinds) == 0) {

#ifdef RASAUTODIAL

            // 
            // This is a successful close of last adapter
            //
#if DBG
            DbgPrint("Calling NbfAcdUnbind()\n");
#endif

            //
            // Unbind from the automatic connection driver.
            //  

            NbfAcdUnbind();

#endif // RASAUTODIAL

        }
    }
    else {
    
        // Ignore any duplicate Unbind Indications from NDIS layer
        *NdisStatus = NDIS_STATUS_SUCCESS;
    }

    IF_NBFDBG (NBF_DEBUG_PNP) {
        NbfPrint2 ("LEAVE NbfProtocolUnbindAdapter for %S with Status %08x\n",
                        DeviceContext->DeviceName, *NdisStatus);
    }

    return;
}

NDIS_STATUS
NbfProtocolPnPEventHandler(
                    IN NDIS_HANDLE ProtocolBindContext,
                    IN PNET_PNP_EVENT NetPnPEvent
                          )
/*++

Routine Description:

    This routine queues a work item to invoke the actual PnP
    event dispatcher. This asyncronous mechanism is to allow
    NDIS to signal PnP events to other bindings in parallel.

Arguments:

    ProtocolBindContext - the context from the openadapter call 

    NetPnPEvent         - kind of PnP event and its parameters

Return Value:

    STATUS_PENDING (or) an error code
    
--*/

{
    PNET_PNP_EVENT_RESERVED NetPnPReserved;
    PWORK_QUEUE_ITEM PnPWorkItem;

    PnPWorkItem = (PWORK_QUEUE_ITEM)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        sizeof (WORK_QUEUE_ITEM),
                                        NBF_MEM_TAG_WORK_ITEM);

    if (PnPWorkItem == NULL) 
    {
        return NDIS_STATUS_RESOURCES;
    }

    NetPnPReserved = (PNET_PNP_EVENT_RESERVED)NetPnPEvent->TransportReserved;
    NetPnPReserved->PnPWorkItem = PnPWorkItem;
    NetPnPReserved->DeviceContext = (PDEVICE_CONTEXT) ProtocolBindContext;

    ExInitializeWorkItem(
            PnPWorkItem,
            NbfPnPEventDispatch,
            NetPnPEvent);
            
    ExQueueWorkItem(PnPWorkItem, CriticalWorkQueue);

    return NDIS_STATUS_PENDING;
}

VOID
NbfPnPEventDispatch(
                    IN PVOID NetPnPEvent
                   )
/*++

Routine Description:

    This routine dispatches all PnP events for the NBF transport.
    The event is dispatched to the proper PnP event handler, and
    the events are indicated to the transport clients using TDI.

    These PnP events can trigger state changes that affect the
    device behavior ( like transitioning to low power state ).

Arguments:

    NetPnPEvent         - kind of PnP event and its parameters

Return Value:

    None

--*/

{
    PNET_PNP_EVENT_RESERVED NetPnPReserved;
    PDEVICE_CONTEXT  DeviceContext;
    UNICODE_STRING   DeviceString;
    PTDI_PNP_CONTEXT tdiPnPContext1;
    PTDI_PNP_CONTEXT tdiPnPContext2;
    NDIS_STATUS      retVal;

    // Retrieve the transport information block in event
    NetPnPReserved = (PNET_PNP_EVENT_RESERVED)((PNET_PNP_EVENT)NetPnPEvent)->TransportReserved;

    // Free the memory allocated for this work item itself
    ExFreePool(NetPnPReserved->PnPWorkItem);
     
    // Get the device context for the adapter being unbound
    DeviceContext = NetPnPReserved->DeviceContext;

    // In case everything goes ok, we return an NDIS_SUCCESS
    retVal = STATUS_SUCCESS;
    
    // Dispatch the PnP Event to the appropriate PnP handler
    switch (((PNET_PNP_EVENT)NetPnPEvent)->NetEvent)
    {
        case NetEventReconfigure:
        case NetEventCancelRemoveDevice:
        case NetEventQueryRemoveDevice:
        case NetEventQueryPower:
        case NetEventSetPower:
        case NetEventPnPCapabilities:
            break;

        case NetEventBindsComplete:
            retVal = NbfPnPBindsComplete(DeviceContext, NetPnPEvent);
            break;

        default:
            ASSERT( FALSE );
    }

    if ( retVal == STATUS_SUCCESS ) 
    {
        if (DeviceContext != NULL)
        {
            RtlInitUnicodeString(&DeviceString, DeviceContext->DeviceName);
            tdiPnPContext1 = tdiPnPContext2 = NULL;

            //  Notify our TDI clients about this PNP event
            retVal = TdiPnPPowerRequest(&DeviceString,
                                         NetPnPEvent,
                                         tdiPnPContext1, 
                                         tdiPnPContext2,
                                         NbfPnPEventComplete);
        }
    }

    if (retVal != STATUS_PENDING)
    {
        NdisCompletePnPEvent(retVal, (NDIS_HANDLE)DeviceContext, NetPnPEvent);
    }
}

//
// PnP Complete Handler
//
VOID
NbfPnPEventComplete(
                    IN PNET_PNP_EVENT   NetPnPEvent,
                    IN NTSTATUS         retVal
                   )
{
    PNET_PNP_EVENT_RESERVED NetPnPReserved;
    PDEVICE_CONTEXT  DeviceContext;

    // Retrieve the transport information block in event
    NetPnPReserved = (PNET_PNP_EVENT_RESERVED)NetPnPEvent->TransportReserved;

    // Get the device context for the adapter being unbound
    DeviceContext = NetPnPReserved->DeviceContext;

    NdisCompletePnPEvent(retVal, (NDIS_HANDLE)DeviceContext, NetPnPEvent);
}

//
// PnP Handler Dispatches
//

NTSTATUS
NbfPnPBindsComplete(
                    IN PDEVICE_CONTEXT  DeviceContext,
                    IN PNET_PNP_EVENT   NetPnPEvent
                   )
{
    NDIS_STATUS retVal;

    ASSERT(DeviceContext == NULL);

    retVal = TdiProviderReady(NbfProviderHandle);

    ASSERT(retVal == STATUS_SUCCESS);

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfndis.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbfndis.c

Abstract:

    This module contains code which implements the routines used to interface
    NBF and NDIS. All callback routines (except for Transfer Data,
    Send Complete, and ReceiveIndication) are here, as well as those routines
    called to initialize NDIS.

Author:

    David Beaver (dbeaver) 13-Feb-1991

Environment:

    Kernel mode

Revision History:

    David Beaver (dbeaver) 1-July-1991
        modify to use new TDI interface

--*/
#include "precomp.h"
#pragma hdrstop

#ifdef NBF_LOCKS                // see spnlckdb.c

VOID
NbfFakeSendCompletionHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

VOID
NbfFakeTransferDataComplete (
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT BytesTransferred
    );

#endif


//
// This is a one-per-driver variable used in binding
// to the NDIS interface.
//

NDIS_HANDLE NbfNdisProtocolHandle = (NDIS_HANDLE)NULL;


NDIS_STATUS
NbfSubmitNdisRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_REQUEST NdisRequest,
    IN PNDIS_STRING AdapterName
    );

VOID
NbfOpenAdapterComplete (
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    );

VOID
NbfCloseAdapterComplete(
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS Status
    );

VOID
NbfResetComplete(
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS Status
    );

VOID
NbfRequestComplete (
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS NdisStatus
    );

VOID
NbfStatusIndication (
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
    );

VOID
NbfProcessStatusClosing(
    IN PVOID Parameter
    );

VOID
NbfStatusComplete (
    IN NDIS_HANDLE NdisBindingContext
    );

VOID
NbfProtocolBindAdapter(
                OUT PNDIS_STATUS    NdisStatus,
                IN NDIS_HANDLE      BindContext,
                IN PNDIS_STRING     DeviceName,
                IN PVOID            SystemSpecific1,
                IN PVOID            SystemSpecific2
                );
VOID
NbfProtocolUnbindAdapter(
                OUT PNDIS_STATUS    NdisStatus,
                IN NDIS_HANDLE      ProtocolBindContext,
                IN PNDIS_HANDLE     UnbindContext
                );

NDIS_STATUS
NbfProtocolPnPEventHandler(
                IN  NDIS_HANDLE     ProtocolBindingContext,
                IN  PNET_PNP_EVENT  NetPnPEvent
                );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbfProtocolBindAdapter)
#pragma alloc_text(PAGE,NbfRegisterProtocol)
#pragma alloc_text(PAGE,NbfSubmitNdisRequest)
#pragma alloc_text(PAGE,NbfInitializeNdis)
#endif


NTSTATUS
NbfRegisterProtocol (
    IN PUNICODE_STRING NameString
    )

/*++

Routine Description:

    This routine introduces this transport to the NDIS interface.

Arguments:

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.
    STATUS_SUCCESS if all goes well,
    Failure status if we tried to register and couldn't,
    STATUS_INSUFFICIENT_RESOURCES if we couldn't even try to register.

--*/

{
    NDIS_STATUS ndisStatus;
    NDIS_PROTOCOL_CHARACTERISTICS ProtChars;

    RtlZeroMemory(&ProtChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    //
    // Set up the characteristics of this protocol
    //
    ProtChars.MajorNdisVersion = 4;
    ProtChars.MinorNdisVersion = 0;
    
    ProtChars.BindAdapterHandler = NbfProtocolBindAdapter;
    ProtChars.UnbindAdapterHandler = NbfProtocolUnbindAdapter;
    ProtChars.PnPEventHandler = NbfProtocolPnPEventHandler;
    
    ProtChars.Name.Length = NameString->Length;
    ProtChars.Name.MaximumLength = NameString->MaximumLength;
    ProtChars.Name.Buffer = NameString->Buffer;

    ProtChars.OpenAdapterCompleteHandler = NbfOpenAdapterComplete;
    ProtChars.CloseAdapterCompleteHandler = NbfCloseAdapterComplete;
    ProtChars.ResetCompleteHandler = NbfResetComplete;
    ProtChars.RequestCompleteHandler = NbfRequestComplete;

#ifdef NBF_LOCKS
    ProtChars.SendCompleteHandler = NbfFakeSendCompletionHandler;
    ProtChars.TransferDataCompleteHandler = NbfFakeTransferDataComplete;
#else
    ProtChars.SendCompleteHandler = NbfSendCompletionHandler;
    ProtChars.TransferDataCompleteHandler = NbfTransferDataComplete;
#endif

    ProtChars.ReceiveHandler = NbfReceiveIndication;
    ProtChars.ReceiveCompleteHandler = NbfReceiveComplete;
    ProtChars.StatusHandler = NbfStatusIndication;
    ProtChars.StatusCompleteHandler = NbfStatusComplete;

    NdisRegisterProtocol (
        &ndisStatus,
        &NbfNdisProtocolHandle,
        &ProtChars,
        sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    if (ndisStatus != NDIS_STATUS_SUCCESS) {
#if DBG
        IF_NBFDBG (NBF_DEBUG_RESOURCE) {
            NbfPrint1("NbfInitialize: NdisRegisterProtocol failed: %s\n",
                        NbfGetNdisStatus(ndisStatus));
        }
#endif
        return (NTSTATUS)ndisStatus;
    }

    return STATUS_SUCCESS;
}


VOID
NbfDeregisterProtocol (
    VOID
    )

/*++

Routine Description:

    This routine removes this transport to the NDIS interface.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NDIS_STATUS ndisStatus;

    if (NbfNdisProtocolHandle != (NDIS_HANDLE)NULL) {
        NdisDeregisterProtocol (
            &ndisStatus,
            NbfNdisProtocolHandle);
        NbfNdisProtocolHandle = (NDIS_HANDLE)NULL;
    }
}


NDIS_STATUS
NbfSubmitNdisRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_REQUEST Request,
    IN PNDIS_STRING AdapterString
    )

/*++

Routine Description:

    This routine passed an NDIS_REQUEST to the MAC and waits
    until it has completed before returning the final status.

Arguments:

    DeviceContext - Pointer to the device context for this driver.

    Request - Pointer to the NDIS_REQUEST to submit.

    AdapterString - The name of the adapter, in case an error needs
        to be logged.

Return Value:

    The function value is the status of the operation.

--*/
{
    NDIS_STATUS NdisStatus;

    if (DeviceContext->NdisBindingHandle) {
        NdisRequest(
            &NdisStatus,
            DeviceContext->NdisBindingHandle,
            Request);
    }
    else {
        NdisStatus = STATUS_INVALID_DEVICE_STATE;
    }
    
    if (NdisStatus == NDIS_STATUS_PENDING) {

        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint1 ("OID %lx pended.\n",
                Request->DATA.QUERY_INFORMATION.Oid);
        }

        //
        // The completion routine will set NdisRequestStatus.
        //

        KeWaitForSingleObject(
            &DeviceContext->NdisRequestEvent,
            Executive,
            KernelMode,
            TRUE,
            (PLARGE_INTEGER)NULL
            );

        NdisStatus = DeviceContext->NdisRequestStatus;

        KeResetEvent(
            &DeviceContext->NdisRequestEvent
            );

    }

    if (NdisStatus == STATUS_SUCCESS) {

        IF_NBFDBG (NBF_DEBUG_NDIS) {
            if (Request->RequestType == NdisRequestSetInformation) {
                NbfPrint1 ("Nbfdrvr: Set OID %lx succeeded.\n",
                    Request->DATA.SET_INFORMATION.Oid);
            } else {
                NbfPrint1 ("Nbfdrvr: Query OID %lx succeeded.\n",
                    Request->DATA.QUERY_INFORMATION.Oid);
            }
        }

    } else {
#if DBG
        if (Request->RequestType == NdisRequestSetInformation) {
            NbfPrint2 ("Nbfdrvr: Set OID %lx failed: %s.\n",
                Request->DATA.SET_INFORMATION.Oid, NbfGetNdisStatus(NdisStatus));
        } else {
            NbfPrint2 ("Nbfdrvr: Query OID %lx failed: %s.\n",
                Request->DATA.QUERY_INFORMATION.Oid, NbfGetNdisStatus(NdisStatus));
        }
#endif
        if (NdisStatus != STATUS_INVALID_DEVICE_STATE) {
        
            NbfWriteOidErrorLog(
                DeviceContext,
                Request->RequestType == NdisRequestSetInformation ?
                    EVENT_TRANSPORT_SET_OID_FAILED : EVENT_TRANSPORT_QUERY_OID_FAILED,
                NdisStatus,
                AdapterString->Buffer,
                Request->DATA.QUERY_INFORMATION.Oid);
        }
    }

    return NdisStatus;
}


NTSTATUS
NbfInitializeNdis (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PCONFIG_DATA NbfConfig,
    IN PNDIS_STRING AdapterString
    )

/*++

Routine Description:

    This routine introduces this transport to the NDIS interface and sets up
    any necessary NDIS data structures (Buffer pools and such). It will be
    called for each adapter opened by this transport.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
    ULONG SendPacketReservedLength;
    ULONG ReceivePacketReservedLen;
    ULONG SendPacketPoolSize;
    ULONG ReceivePacketPoolSize;
    NDIS_STATUS NdisStatus;
    NDIS_STATUS OpenErrorStatus;
    NDIS_MEDIUM NbfSupportedMedia[] = { NdisMedium802_3, NdisMedium802_5, NdisMediumFddi, NdisMediumWan };
    UINT SelectedMedium;
    NDIS_REQUEST NbfRequest;
    UCHAR NbfDataBuffer[6];
    NDIS_OID NbfOid;
    UCHAR WanProtocolId[6] = { 0x80, 0x00, 0x00, 0x00, 0x80, 0xd5 };
    ULONG WanHeaderFormat = NdisWanHeaderEthernet;
    ULONG MinimumLookahead = 128 + sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS);
    ULONG MacOptions;


    //
    // Initialize this adapter for NBF use through NDIS
    //

    //
    // This event is used in case any of the NDIS requests
    // pend; we wait until it is set by the completion
    // routine, which also sets NdisRequestStatus.
    //

    KeInitializeEvent(
        &DeviceContext->NdisRequestEvent,
        NotificationEvent,
        FALSE
    );

    DeviceContext->NdisBindingHandle = NULL;

    NdisOpenAdapter (
        &NdisStatus,
        &OpenErrorStatus,
        &DeviceContext->NdisBindingHandle,
        &SelectedMedium,
        NbfSupportedMedia,
        sizeof (NbfSupportedMedia) / sizeof(NDIS_MEDIUM),
        NbfNdisProtocolHandle,
        (NDIS_HANDLE)DeviceContext,
        AdapterString,
        0,
        NULL);

    if (NdisStatus == NDIS_STATUS_PENDING) {

        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint1 ("Adapter %S open pended.\n", AdapterString);
        }

        //
        // The completion routine will set NdisRequestStatus.
        //

        KeWaitForSingleObject(
            &DeviceContext->NdisRequestEvent,
            Executive,
            KernelMode,
            TRUE,
            (PLARGE_INTEGER)NULL
            );

        NdisStatus = DeviceContext->NdisRequestStatus;

        KeResetEvent(
            &DeviceContext->NdisRequestEvent
            );

    }

    if (NdisStatus == NDIS_STATUS_SUCCESS) {
#if DBG
        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint1 ("Adapter %S successfully opened.\n", AdapterString);
        }
#endif
    } else {
#if DBG
        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint2 ("Adapter open %S failed, status: %s.\n",
                AdapterString,
                NbfGetNdisStatus (NdisStatus));
        }
#endif
        NbfWriteGeneralErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_ADAPTER_NOT_FOUND,
            807,
            NdisStatus,
            AdapterString->Buffer,
            0,
            NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Get the information we need about the adapter, based on
    // the media type.
    //

    MacInitializeMacInfo(
        NbfSupportedMedia[SelectedMedium],
        (BOOLEAN)(NbfConfig->UseDixOverEthernet != 0),
        &DeviceContext->MacInfo);
    DeviceContext->MacInfo.QueryWithoutSourceRouting =
        NbfConfig->QueryWithoutSourceRouting ? TRUE : FALSE;
    DeviceContext->MacInfo.AllRoutesNameRecognized =
        NbfConfig->AllRoutesNameRecognized ? TRUE : FALSE;


    //
    // Set the multicast/functional addresses first so we avoid windows where we
    // receive only part of the addresses.
    //

    MacSetNetBIOSMulticast (
            DeviceContext->MacInfo.MediumType,
            DeviceContext->NetBIOSAddress.Address);


    switch (DeviceContext->MacInfo.MediumType) {

    case NdisMedium802_3:
    case NdisMediumDix:

        //
        // Fill in the data for our multicast list.
        //

        RtlCopyMemory(NbfDataBuffer, DeviceContext->NetBIOSAddress.Address, 6);

        //
        // Now fill in the NDIS_REQUEST.
        //

        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.SET_INFORMATION.Oid = OID_802_3_MULTICAST_LIST;
        NbfRequest.DATA.SET_INFORMATION.InformationBuffer = &NbfDataBuffer;
        NbfRequest.DATA.SET_INFORMATION.InformationBufferLength = 6;

        break;

    case NdisMedium802_5:

        //
        // For token-ring, we pass the last four bytes of the
        // Netbios functional address.
        //

        //
        // Fill in the OVB for our functional address.
        //

        RtlCopyMemory(NbfDataBuffer, ((PUCHAR)(DeviceContext->NetBIOSAddress.Address)) + 2, 4);

        //
        // Now fill in the NDIS_REQUEST.
        //

        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.SET_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
        NbfRequest.DATA.SET_INFORMATION.InformationBuffer = &NbfDataBuffer;
        NbfRequest.DATA.SET_INFORMATION.InformationBufferLength = 4;

        break;

    case NdisMediumFddi:

        //
        // Fill in the data for our multicast list.
        //

        RtlCopyMemory(NbfDataBuffer, DeviceContext->NetBIOSAddress.Address, 6);

        //
        // Now fill in the NDIS_REQUEST.
        //

        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.SET_INFORMATION.Oid = OID_FDDI_LONG_MULTICAST_LIST;
        NbfRequest.DATA.SET_INFORMATION.InformationBuffer = &NbfDataBuffer;
        NbfRequest.DATA.SET_INFORMATION.InformationBufferLength = 6;

        break;

    }

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }



    switch (DeviceContext->MacInfo.MediumType) {

    case NdisMedium802_3:
    case NdisMediumDix:

        if (DeviceContext->MacInfo.MediumAsync) {
            NbfOid = OID_WAN_CURRENT_ADDRESS;
        } else {
            NbfOid = OID_802_3_CURRENT_ADDRESS;
        }
        break;

    case NdisMedium802_5:

        NbfOid = OID_802_5_CURRENT_ADDRESS;
        break;

    case NdisMediumFddi:

        NbfOid = OID_FDDI_LONG_CURRENT_ADDR;
        break;

    default:

        NdisStatus = NDIS_STATUS_FAILURE;
        break;

    }
    NbfRequest.RequestType = NdisRequestQueryInformation;
    NbfRequest.DATA.QUERY_INFORMATION.Oid = NbfOid;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = DeviceContext->LocalAddress.Address;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set up the reserved Netbios address.
    //

    RtlZeroMemory(DeviceContext->ReservedNetBIOSAddress, 10);
    RtlCopyMemory(&DeviceContext->ReservedNetBIOSAddress[10], DeviceContext->LocalAddress.Address, 6);



    //
    // Now query the maximum packet sizes.
    //

    NbfRequest.RequestType = NdisRequestQueryInformation;
    NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_FRAME_SIZE;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(DeviceContext->MaxReceivePacketSize);
    NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    NbfRequest.RequestType = NdisRequestQueryInformation;
    NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_TOTAL_SIZE;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(DeviceContext->MaxSendPacketSize);
    NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DeviceContext->CurSendPacketSize = DeviceContext->MaxSendPacketSize;


    //
    // Now set the minimum lookahead size.
    //

    NbfRequest.RequestType = NdisRequestSetInformation;
    NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_CURRENT_LOOKAHEAD;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &MinimumLookahead;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now query the link speed for non-wan media
    //

    if (!DeviceContext->MacInfo.MediumAsync) {

        NbfRequest.RequestType = NdisRequestQueryInformation;
        NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_LINK_SPEED;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &(DeviceContext->MediumSpeed);
        NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DeviceContext->MediumSpeedAccurate = TRUE;

        // Initialized MinimumT1Timeout in nbfdrvr.c
        // For a non-WAN media, this value is picked
        // from the registry, and remains constant.

        // DeviceContext->MinimumT1Timeout = 8;

    } else {

        //
        // On an wan media, this isn't valid until we get an
        // WAN_LINE_UP indication. Set the timeouts to
        // low values for now.
        //

        DeviceContext->DefaultT1Timeout = 8;
        DeviceContext->MinimumT1Timeout = 8;

        DeviceContext->MediumSpeedAccurate = FALSE;


        //
        // Back off our connectionless timeouts to 2 seconds.
        //

        DeviceContext->NameQueryTimeout = 2 * SECONDS;
        DeviceContext->AddNameQueryTimeout = 2 * SECONDS;
        DeviceContext->GeneralTimeout = 2 * SECONDS;

        //
        // Use the WAN parameter for name query retries.
        //

        DeviceContext->NameQueryRetries = NbfConfig->WanNameQueryRetries;

        //
        // Use this until we know better.
        //

        DeviceContext->RecommendedSendWindow = 1;

    }

    //
    // On media that use source routing, we double our name query
    // retry count if we are configured to try both ways (with and
    // without source routing).
    //

    if ((DeviceContext->MacInfo.QueryWithoutSourceRouting) &&
        (DeviceContext->MacInfo.SourceRouting)) {
        DeviceContext->NameQueryRetries *= 2;
    }


    //
    // For wan, specify our protocol ID and header format.
    // We don't query the medium subtype because we don't
    // case (since we require ethernet emulation).
    //

    if (DeviceContext->MacInfo.MediumAsync) {

        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_TYPE;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = WanProtocolId;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

        NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_WAN_HEADER_FORMAT;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &WanHeaderFormat;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    //
    // Now query the MAC's optional characteristics.
    //

    NbfRequest.RequestType = NdisRequestQueryInformation;
    NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAC_OPTIONS;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &MacOptions;
    NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

    NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
#if 1
        return STATUS_INSUFFICIENT_RESOURCES;
#else
        MacOptions = 0;
#endif
    }

    DeviceContext->MacInfo.CopyLookahead =
        (BOOLEAN)((MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) != 0);
    DeviceContext->MacInfo.ReceiveSerialized =
        (BOOLEAN)((MacOptions & NDIS_MAC_OPTION_RECEIVE_SERIALIZED) != 0);
    DeviceContext->MacInfo.TransferSynchronous =
        (BOOLEAN)((MacOptions & NDIS_MAC_OPTION_TRANSFERS_NOT_PEND) != 0);
    DeviceContext->MacInfo.SingleReceive =
        (BOOLEAN)(DeviceContext->MacInfo.ReceiveSerialized && DeviceContext->MacInfo.TransferSynchronous);


#if 0
    //
    // Now set our options if needed.
    //
    // Don't allow early indications because we can't determine
    // if the CRC has been checked yet.
    //

    if ((DeviceContext->MacInfo.MediumType == NdisMedium802_3) ||
        (DeviceContext->MacInfo.MediumType == NdisMediumDix)) {

        ULONG ProtocolOptions = NDIS_PROT_OPTION_ESTIMATED_LENGTH;

        NbfRequest.RequestType = NdisRequestSetInformation;
        NbfRequest.DATA.QUERY_INFORMATION.Oid = OID_GEN_PROTOCOL_OPTIONS;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBuffer = &ProtocolOptions;
        NbfRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

        NdisStatus = NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    }
#endif


    //
    // Calculate the NDIS-related stuff.
    //

    SendPacketReservedLength = sizeof (SEND_PACKET_TAG);
    ReceivePacketReservedLen = sizeof (RECEIVE_PACKET_TAG);


    //
    // The send packet pool is used for UI frames and regular packets.
    //

    SendPacketPoolSize = NbfConfig->SendPacketPoolSize;

    //
    // The receive packet pool is used in transfer data.
    //
    // For a MAC that will only have one receive active, we
    // don't need multiple receive packets. Allow an extra
    // one for loopback.
    //

    if (DeviceContext->MacInfo.SingleReceive) {
        ReceivePacketPoolSize = 2;
    } else {
        ReceivePacketPoolSize = NbfConfig->ReceivePacketPoolSize;
    }


    // Allocate Packet pool descriptors for dynamic packet allocation.

    if (!DeviceContext->SendPacketPoolDesc)
	{
    	DeviceContext->SendPacketPoolDesc = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(NBF_POOL_LIST_DESC),
                    NBF_MEM_TAG_POOL_DESC);

	    if (DeviceContext->SendPacketPoolDesc == NULL) {
    	    return STATUS_INSUFFICIENT_RESOURCES;
	    }

	    RtlZeroMemory(DeviceContext->SendPacketPoolDesc,
    	              sizeof(NBF_POOL_LIST_DESC));

	    DeviceContext->SendPacketPoolDesc->NumElements =
    	DeviceContext->SendPacketPoolDesc->TotalElements = (USHORT)SendPacketPoolSize;

    	// To track packet pools in NDIS allocated on NBF's behalf
#if NDIS_POOL_TAGGING
	    DeviceContext->SendPacketPoolDesc->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NBF;
#endif

	    NdisAllocatePacketPoolEx (
    	    &NdisStatus,
        	&DeviceContext->SendPacketPoolDesc->PoolHandle,
	        SendPacketPoolSize,
    	    0,
        	SendPacketReservedLength);

	    if (NdisStatus == NDIS_STATUS_SUCCESS) {
    	    IF_NBFDBG (NBF_DEBUG_NDIS) {
        	    NbfPrint0 ("NdisInitializePacketPool successful.\n");
	        }

    	} else {
    	    ExFreePool(DeviceContext->SendPacketPoolDesc);
    	    DeviceContext->SendPacketPoolDesc = NULL;
#if DBG
        	NbfPrint1 ("NbfInitialize: NdisInitializePacketPool failed, reason: %s.\n",
            	NbfGetNdisStatus (NdisStatus));
#endif
	        NbfWriteResourceErrorLog(
	            DeviceContext,
    	        EVENT_TRANSPORT_RESOURCE_POOL,
        	    109,
	            SendPacketPoolSize,
    	        0);
        	return STATUS_INSUFFICIENT_RESOURCES;
	    }

    	NdisSetPacketPoolProtocolId (DeviceContext->SendPacketPoolDesc->PoolHandle, NDIS_PROTOCOL_ID_NBF);

	    DeviceContext->SendPacketPoolSize = SendPacketPoolSize;

    	DeviceContext->MemoryUsage +=
	        (SendPacketPoolSize *
    	     (sizeof(NDIS_PACKET) + SendPacketReservedLength));

#if DBG
	    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
    	    DbgPrint ("send pool %d hdr %d, %ld\n",
        	    SendPacketPoolSize,
            	SendPacketReservedLength,
	            DeviceContext->MemoryUsage);
    	}
#endif

	}

    if (!DeviceContext->ReceivePacketPoolDesc)
	{
	    // Allocate Packet pool descriptors for dynamic packet allocation.

	    DeviceContext->ReceivePacketPoolDesc = ExAllocatePoolWithTag(
	                    NonPagedPool,
	                    sizeof(NBF_POOL_LIST_DESC),
	                    NBF_MEM_TAG_POOL_DESC);

	    if (DeviceContext->ReceivePacketPoolDesc == NULL) {
	        return STATUS_INSUFFICIENT_RESOURCES;
	    }

	    RtlZeroMemory(DeviceContext->ReceivePacketPoolDesc,
	                  sizeof(NBF_POOL_LIST_DESC));

	    DeviceContext->ReceivePacketPoolDesc->NumElements =
	    DeviceContext->ReceivePacketPoolDesc->TotalElements = (USHORT)ReceivePacketPoolSize;

	    // To track packet pools in NDIS allocated on NBF's behalf
#if NDIS_POOL_TAGGING
	    DeviceContext->ReceivePacketPoolDesc->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NBF;
#endif

	    NdisAllocatePacketPoolEx (
	        &NdisStatus,
	        &DeviceContext->ReceivePacketPoolDesc->PoolHandle,
	        ReceivePacketPoolSize,
	        0,
	        ReceivePacketReservedLen);

	    if (NdisStatus == NDIS_STATUS_SUCCESS) {
	        IF_NBFDBG (NBF_DEBUG_NDIS) {
	            NbfPrint1 ("NdisInitializePacketPool successful, Pool: %lx\n",
	                DeviceContext->ReceivePacketPoolDesc->PoolHandle);
	        }
	    } else {
	        ExFreePool(DeviceContext->ReceivePacketPoolDesc);
	        DeviceContext->ReceivePacketPoolDesc = NULL;
#if DBG
	        NbfPrint1 ("NbfInitialize: NdisInitializePacketPool failed, reason: %s.\n",
	            NbfGetNdisStatus (NdisStatus));
#endif
	        NbfWriteResourceErrorLog(
	            DeviceContext,
	            EVENT_TRANSPORT_RESOURCE_POOL,
	            209,
	            ReceivePacketPoolSize,
	            0);
	        return STATUS_INSUFFICIENT_RESOURCES;
	    }

	    NdisSetPacketPoolProtocolId (DeviceContext->ReceivePacketPoolDesc->PoolHandle, NDIS_PROTOCOL_ID_NBF);

	    DeviceContext->ReceivePacketPoolSize = ReceivePacketPoolSize;

	    DeviceContext->MemoryUsage +=
	        (ReceivePacketPoolSize *
	         (sizeof(NDIS_PACKET) + ReceivePacketReservedLen));

#if DBG
	    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
	        DbgPrint ("receive pool %d hdr %d, %ld\n",
	            ReceivePacketPoolSize,
	            ReceivePacketReservedLen,
	            DeviceContext->MemoryUsage);
	    }
#endif

	}

    if (!DeviceContext->NdisBufferPool)
	{
	    //
	    // Allocate the buffer pool; as an estimate, allocate
	    // one per send or receive packet.
	    //

	    NdisAllocateBufferPool (
	        &NdisStatus,
	        &DeviceContext->NdisBufferPool,
	        SendPacketPoolSize + ReceivePacketPoolSize);

	    if (NdisStatus == NDIS_STATUS_SUCCESS) {
	        IF_NBFDBG (NBF_DEBUG_NDIS) {
	            NbfPrint0 ("NdisAllocateBufferPool successful.\n");
	        }

	    } else {
#if DBG
	        NbfPrint1 ("NbfInitialize: NdisAllocateBufferPool failed, reason: %s.\n",
	            NbfGetNdisStatus (NdisStatus));
#endif
	        NbfWriteResourceErrorLog(
	            DeviceContext,
	            EVENT_TRANSPORT_RESOURCE_POOL,
	            309,
	            SendPacketPoolSize + ReceivePacketPoolSize,
	            0);
	        return STATUS_INSUFFICIENT_RESOURCES;
	    }
	}

    //
    // Now that everything is set up, we enable the filter
    // for packet reception.
    //

    //
    // Fill in the OVB for packet filter.
    //

    switch (DeviceContext->MacInfo.MediumType) {

    case NdisMedium802_3:
    case NdisMediumDix:
    case NdisMediumFddi:

        RtlStoreUlong((PULONG)NbfDataBuffer,
            (NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST));
        break;

    case NdisMedium802_5:

        RtlStoreUlong((PULONG)NbfDataBuffer,
            (NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_FUNCTIONAL));
        break;

    default:

        NdisStatus = NDIS_STATUS_FAILURE;
        break;

    }

    //
    // Now fill in the NDIS_REQUEST.
    //

    NbfRequest.RequestType = NdisRequestSetInformation;
    NbfRequest.DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_PACKET_FILTER;
    NbfRequest.DATA.SET_INFORMATION.InformationBuffer = &NbfDataBuffer;
    NbfRequest.DATA.SET_INFORMATION.InformationBufferLength = sizeof(ULONG);

    NbfSubmitNdisRequest (DeviceContext, &NbfRequest, AdapterString);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;

}   /* NbfInitializeNdis */


VOID
NbfCloseNdis (
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine unbinds the transport from the NDIS interface and does
    any other work required to undo what was done in NbfInitializeNdis.
    It is written so that it can be called from within NbfInitializeNdis
    if it fails partway through.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    The function value is the status of the operation.

--*/
{
    NDIS_STATUS ndisStatus;
    NDIS_HANDLE NdisBindingHandle;
    
    //
    // Close the NDIS binding.
    //
    
    NdisBindingHandle = DeviceContext->NdisBindingHandle;
    
    DeviceContext->NdisBindingHandle = NULL;
        
    if (NdisBindingHandle != NULL) {
    
        //
        // This event is used in case any of the NDIS requests
        // pend; we wait until it is set by the completion
        // routine, which also sets NdisRequestStatus.
        //

        KeInitializeEvent(
            &DeviceContext->NdisRequestEvent,
            NotificationEvent,
            FALSE
        );

        NdisCloseAdapter(
            &ndisStatus,
            NdisBindingHandle);

        if (ndisStatus == NDIS_STATUS_PENDING) {

            IF_NBFDBG (NBF_DEBUG_NDIS) {
                NbfPrint0 ("Adapter close pended.\n");
            }

            //
            // The completion routine will set NdisRequestStatus.
            //

            KeWaitForSingleObject(
                &DeviceContext->NdisRequestEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );

            ndisStatus = DeviceContext->NdisRequestStatus;

            KeResetEvent(
                &DeviceContext->NdisRequestEvent
                );

        }

        //
        // We ignore ndisStatus.
        //

    }
}   /* NbfCloseNdis */


VOID
NbfOpenAdapterComplete (
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that an open adapter
    is complete. Since we only ever have one outstanding, and then only
    during initialization, all we do is record the status and set
    the event to signalled to unblock the initialization thread.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

    OpenErrorStatus - More status information.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)BindingContext;

#if DBG
    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint1 ("Nbfdrvr: NbfOpenAdapterCompleteNDIS Status: %s\n",
            NbfGetNdisStatus (NdisStatus));
    }
#endif

    ENTER_NBF;

    DeviceContext->NdisRequestStatus = NdisStatus;
    KeSetEvent(
        &DeviceContext->NdisRequestEvent,
        0L,
        FALSE);

    LEAVE_NBF;
    return;
}

VOID
NbfCloseAdapterComplete (
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a close adapter
    is complete. Currently we don't close adapters, so this is not
    a problem.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)BindingContext;

#if DBG
    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint1 ("Nbfdrvr: NbfCloseAdapterCompleteNDIS Status: %s\n",
            NbfGetNdisStatus (NdisStatus));
    }
#endif

    ENTER_NBF;

    DeviceContext->NdisRequestStatus = NdisStatus;
    KeSetEvent(
        &DeviceContext->NdisRequestEvent,
        0L,
        FALSE);

    LEAVE_NBF;
    return;
}

VOID
NbfResetComplete (
    IN NDIS_HANDLE BindingContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a reset adapter
    is complete. Currently we don't reset adapters, so this is not
    a problem.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(BindingContext);
    UNREFERENCED_PARAMETER(NdisStatus);

#if DBG
    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint1 ("Nbfdrvr: NbfResetCompleteNDIS Status: %s\n",
            NbfGetNdisStatus (NdisStatus));
    }
#endif

    return;
}

VOID
NbfRequestComplete (
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by NDIS to indicate that a request is complete.
    Since we only ever have one request outstanding, and then only
    during initialization, all we do is record the status and set
    the event to signalled to unblock the initialization thread.

Arguments:

    BindingContext - Pointer to the device object for this driver.

    NdisRequest - The object describing the request.

    NdisStatus - The request completion code.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)BindingContext;

#if DBG
    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint2 ("Nbfdrvr: NbfRequestComplete request: %i, NDIS Status: %s\n",
            NdisRequest->RequestType,NbfGetNdisStatus (NdisStatus));
    }
#endif

    ENTER_NBF;

    DeviceContext->NdisRequestStatus = NdisStatus;
    KeSetEvent(
        &DeviceContext->NdisRequestEvent,
        0L,
        FALSE);

    LEAVE_NBF;
    return;
}

VOID
NbfStatusIndication (
    IN NDIS_HANDLE NdisBindingContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )

{
    PDEVICE_CONTEXT DeviceContext;
    PNDIS_WAN_LINE_UP LineUp;
    KIRQL oldirql;
    PTP_LINK Link;

    DeviceContext = (PDEVICE_CONTEXT)NdisBindingContext;

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    switch (NdisStatus) {

        case NDIS_STATUS_WAN_LINE_UP:

            //
            // A wan line is connected.
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            //
            // If this happens before we are ready, then make
            // a note of it, otherwise make the device ready.
            //

            DeviceContext->MediumSpeedAccurate = TRUE;

			LineUp = (PNDIS_WAN_LINE_UP)StatusBuffer;

			//
			// See if this is a new lineup for this protocol type
			//
			if (LineUp->ProtocolType == 0x80D5) {
				NDIS_HANDLE	TransportHandle;

				*((ULONG UNALIGNED *)(&TransportHandle)) =
				*((ULONG UNALIGNED *)(&LineUp->LocalAddress[2]));

				//
				// See if this is a new lineup
				//
				if (TransportHandle == NULL) {
					*((ULONG UNALIGNED *)(&LineUp->LocalAddress[2])) = *((ULONG UNALIGNED *)(&DeviceContext));
//					ETH_COPY_NETWORK_ADDRESS(DeviceContext->LocalAddress.Address, LineUp->LocalAddress);
//					ETH_COPY_NETWORK_ADDRESS(&DeviceContext->ReservedNetBIOSAddress[10], DeviceContext->LocalAddress.Address);
				}

				//
				// Calculate minimum link timeouts based on the speed,
				// which is passed in StatusBuffer.
				//
				// The formula is (max_frame_size * 2) / speed + 0.4 sec.
				// This expands to
				//
				//   MFS (bytes) * 2       8 bits
				// -------------------  x  ------   == timeout (sec),
				// speed (100 bits/sec)     byte
				//
				// which is (MFS * 16 / 100) / speed. We then convert it into
				// the 50 ms units that NBF uses and add 8 (which is
				// 0.4 seconds in 50 ms units).
				//
				// As a default timeout we use the min + 0.2 seconds
				// unless the configured default is more.
				//
		
				if (LineUp->LinkSpeed > 0) {
					DeviceContext->MediumSpeed = LineUp->LinkSpeed;
				}
		
				if (LineUp->MaximumTotalSize > 0) {
#if DBG
					if (LineUp->MaximumTotalSize > DeviceContext->MaxSendPacketSize) {
						DbgPrint ("Nbf: Bad LINE_UP size, %d (> %d)\n",
							LineUp->MaximumTotalSize, DeviceContext->MaxSendPacketSize);
					}
					if (LineUp->MaximumTotalSize < 128) {
						DbgPrint ("NBF: Bad LINE_UP size, %d (< 128)\n",
							LineUp->MaximumTotalSize);
					}
#endif
					DeviceContext->CurSendPacketSize = LineUp->MaximumTotalSize;
				}
		
				if (LineUp->SendWindow == 0) {
					DeviceContext->RecommendedSendWindow = 3;
				} else {
					DeviceContext->RecommendedSendWindow = LineUp->SendWindow + 1;
				}
		
				DeviceContext->MinimumT1Timeout =
					((((DeviceContext->CurSendPacketSize * 16) / 100) / DeviceContext->MediumSpeed) *
					 ((1 * SECONDS) / (50 * MILLISECONDS))) + 8;
		
				if (DeviceContext->DefaultT1Timeout < DeviceContext->MinimumT1Timeout) {
					DeviceContext->DefaultT1Timeout = DeviceContext->MinimumT1Timeout + 4;
				}

			}

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            break;

        case NDIS_STATUS_WAN_LINE_DOWN:

            //
            // An wan line is disconnected.
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            DeviceContext->MediumSpeedAccurate = FALSE;

            //
            // Set the timeouts to small values (0.4 seconds)
            //

            DeviceContext->DefaultT1Timeout = 8;
            DeviceContext->MinimumT1Timeout = 8;

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);


            //
            // Stop the link on this device context (there
            // will only be one).
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

            if (DeviceContext->LinkTreeElements > 0) {

                Link = (PTP_LINK)DeviceContext->LinkTreeRoot;
                if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) == 0) {

                    NbfReferenceLink ("Wan line down", Link, LREF_TREE);
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

                    //
                    // Put the link in ADM to shut it down.
                    //

                    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                    if (Link->State != LINK_STATE_ADM) {
                        Link->State = LINK_STATE_ADM;
                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                        NbfDereferenceLinkSpecial ("Wan line down", Link, LREF_NOT_ADM);
                    } else {
                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    }

                    //
                    // Now stop it to destroy all connections on it.
                    //

                    NbfStopLink (Link);

                    NbfDereferenceLink ("Wan line down", Link, LREF_TREE);

                } else {

                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

                }

            } else {

                RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

            }

            break;

        case NDIS_STATUS_WAN_FRAGMENT:

            //
            // A fragment has been received on the wan line.
            // Send a reject back to him.
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

            if (DeviceContext->LinkTreeElements > 0) {

                Link = (PTP_LINK)DeviceContext->LinkTreeRoot;
                NbfReferenceLink ("Async line down", Link, LREF_TREE);
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfSendRej (Link, FALSE, FALSE);  // release lock
                NbfDereferenceLink ("Async line down", Link, LREF_TREE);

            } else {

                RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

            }

            break;

        case NDIS_STATUS_CLOSING:

            IF_NBFDBG (NBF_DEBUG_PNP) {
                NbfPrint1 ("NbfStatusIndication: Device @ %08x Closing\n", DeviceContext);
            }

            //
            // The adapter is shutting down. We queue a worker
            // thread to handle this.
            //

            ExInitializeWorkItem(
                &DeviceContext->StatusClosingQueueItem,
                NbfProcessStatusClosing,
                (PVOID)DeviceContext);
            ExQueueWorkItem(&DeviceContext->StatusClosingQueueItem, DelayedWorkQueue);

            break;

        default:
            break;

    }

    KeLowerIrql (oldirql);

}


VOID
NbfProcessStatusClosing(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This is the thread routine which restarts packetizing
    that has been delayed on WAN to allow RRs to come in.
    This is very similar to PacketizeConnections.

Arguments:

    Parameter - A pointer to the device context.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    PLIST_ENTRY p;
#if 0
    PTP_ADDRESS Address;
#endif
    PTP_LINK Link;
    PTP_REQUEST Request;
    NDIS_STATUS ndisStatus;
    KIRQL oldirql;
    NDIS_HANDLE NdisBindingHandle;

    DeviceContext = (PDEVICE_CONTEXT)Parameter;

    //
    // Prevent new activity on the connection.
    //

    DeviceContext->State = DEVICECONTEXT_STATE_DOWN;


#if 0
    //
    // Stop all the addresses.
    //

    while ((p = ExInterlockedRemoveHeadList(
                    &DeviceContext->AddressDatabase,
                    &DeviceContext->SpinLock)) != NULL) {

        Address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);
        InitializeListHead(p);

        NbfStopAddress (Address);

    }
#endif

    //
    // To speed things along, stop all the links too.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

    DeviceContext->LastLink = NULL;

    while (DeviceContext->LinkTreeRoot != NULL) {

        Link = (PTP_LINK)DeviceContext->LinkTreeRoot;
        DeviceContext->LinkTreeRoot = RtlDelete ((PRTL_SPLAY_LINKS)Link);
        DeviceContext->LinkTreeElements--;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        if (Link->OnShortList) {
            RemoveEntryList (&Link->ShortList);
        }
        if (Link->OnLongList) {
            RemoveEntryList (&Link->LongList);
        }
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

        if (Link->State != LINK_STATE_ADM) {
            Link->State = LINK_STATE_ADM;
            NbfSendDm (Link, FALSE);    // send DM/0, release lock
            // moving to ADM, remove reference
            NbfDereferenceLinkSpecial("Expire T1 in CONNECTING mode", Link, LREF_NOT_ADM);
        } else {
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        }
        NbfStopLink (Link);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

    KeLowerIrql (oldirql);


    //
    // Shutdown the control channel.
    //

    while ((p = ExInterlockedRemoveHeadList(
                    &DeviceContext->QueryIndicationQueue,
                    &DeviceContext->SpinLock)) != NULL) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        NbfCompleteRequest (Request, STATUS_INVALID_DEVICE_STATE, 0);
    }

    while ((p = ExInterlockedRemoveHeadList(
                    &DeviceContext->DatagramIndicationQueue,
                    &DeviceContext->SpinLock)) != NULL) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        NbfCompleteRequest (Request, STATUS_INVALID_DEVICE_STATE, 0);
    }

    while ((p = ExInterlockedRemoveHeadList(
                    &DeviceContext->StatusQueryQueue,
                    &DeviceContext->SpinLock)) != NULL) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        NbfCompleteRequest (Request, STATUS_INVALID_DEVICE_STATE, 0);
    }

    while ((p = ExInterlockedRemoveHeadList(
                    &DeviceContext->FindNameQueue,
                    &DeviceContext->SpinLock)) != NULL) {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        NbfCompleteRequest (Request, STATUS_INVALID_DEVICE_STATE, 0);
    }


    //
    // Close the NDIS binding.
    //

    NdisBindingHandle = DeviceContext->NdisBindingHandle;
    
    DeviceContext->NdisBindingHandle = NULL;
        
    if (NdisBindingHandle != NULL) {

        KeInitializeEvent(
            &DeviceContext->NdisRequestEvent,
            NotificationEvent,
            FALSE
        );

        NdisCloseAdapter(
            &ndisStatus,
            NdisBindingHandle);

        if (ndisStatus == NDIS_STATUS_PENDING) {

            IF_NBFDBG (NBF_DEBUG_NDIS) {
                NbfPrint0 ("Adapter close pended.\n");
            }

            //
            // The completion routine will set NdisRequestStatus.
            //

            KeWaitForSingleObject(
                &DeviceContext->NdisRequestEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );

            ndisStatus = DeviceContext->NdisRequestStatus;

            KeResetEvent(
                &DeviceContext->NdisRequestEvent
                );

        }
    }
    
    //
    // We ignore ndisStatus.
    //

#if 0
    //
    // Remove all the storage associated with the device.
    //

    NbfFreeResources (DeviceContext);

    NdisFreePacketPool (DeviceContext->SendPacketPoolHandle);
    NdisFreePacketPool (DeviceContext->ReceivePacketPoolHandle);
    NdisFreeBufferPool (DeviceContext->NdisBufferPoolHandle);
#endif

    // And remove creation ref if it has not already been removed
    if (InterlockedExchange(&DeviceContext->CreateRefRemoved, TRUE) == FALSE) {
    
        // Stop all internal timers
        NbfStopTimerSystem(DeviceContext);

        // Remove creation reference
        NbfDereferenceDeviceContext ("Unload", DeviceContext, DCREF_CREATION);
    }

}   /* NbfProcessStatusClosing */


VOID
NbfStatusComplete (
    IN NDIS_HANDLE NdisBindingContext
    )
{
    UNREFERENCED_PARAMETER (NdisBindingContext);
}

#if DBG

PUCHAR
NbfGetNdisStatus(
    NDIS_STATUS GeneralStatus
    )
/*++

Routine Description:

    This routine returns a pointer to the string describing the NDIS error
    denoted by GeneralStatus.

Arguments:

    GeneralStatus - the status you wish to make readable.

Return Value:

    None.

--*/
{
    static NDIS_STATUS Status[] = {
        NDIS_STATUS_SUCCESS,
        NDIS_STATUS_PENDING,

        NDIS_STATUS_ADAPTER_NOT_FOUND,
        NDIS_STATUS_ADAPTER_NOT_OPEN,
        NDIS_STATUS_ADAPTER_NOT_READY,
        NDIS_STATUS_ADAPTER_REMOVED,
        NDIS_STATUS_BAD_CHARACTERISTICS,
        NDIS_STATUS_BAD_VERSION,
        NDIS_STATUS_CLOSING,
        NDIS_STATUS_DEVICE_FAILED,
        NDIS_STATUS_FAILURE,
        NDIS_STATUS_INVALID_DATA,
        NDIS_STATUS_INVALID_LENGTH,
        NDIS_STATUS_INVALID_OID,
        NDIS_STATUS_INVALID_PACKET,
        NDIS_STATUS_MULTICAST_FULL,
        NDIS_STATUS_NOT_INDICATING,
        NDIS_STATUS_NOT_RECOGNIZED,
        NDIS_STATUS_NOT_RESETTABLE,
        NDIS_STATUS_NOT_SUPPORTED,
        NDIS_STATUS_OPEN_FAILED,
        NDIS_STATUS_OPEN_LIST_FULL,
        NDIS_STATUS_REQUEST_ABORTED,
        NDIS_STATUS_RESET_IN_PROGRESS,
        NDIS_STATUS_RESOURCES,
        NDIS_STATUS_UNSUPPORTED_MEDIA
    };
    static PUCHAR String[] = {
        "SUCCESS",
        "PENDING",

        "ADAPTER_NOT_FOUND",
        "ADAPTER_NOT_OPEN",
        "ADAPTER_NOT_READY",
        "ADAPTER_REMOVED",
        "BAD_CHARACTERISTICS",
        "BAD_VERSION",
        "CLOSING",
        "DEVICE_FAILED",
        "FAILURE",
        "INVALID_DATA",
        "INVALID_LENGTH",
        "INVALID_OID",
        "INVALID_PACKET",
        "MULTICAST_FULL",
        "NOT_INDICATING",
        "NOT_RECOGNIZED",
        "NOT_RESETTABLE",
        "NOT_SUPPORTED",
        "OPEN_FAILED",
        "OPEN_LIST_FULL",
        "REQUEST_ABORTED",
        "RESET_IN_PROGRESS",
        "RESOURCES",
        "UNSUPPORTED_MEDIA"
    };

    static UCHAR BadStatus[] = "UNDEFINED";
#define StatusCount (sizeof(Status)/sizeof(NDIS_STATUS))
    INT i;

    for (i=0; i<StatusCount; i++)
        if (GeneralStatus == Status[i])
            return String[i];
    return BadStatus;
#undef StatusCount
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbftypes.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbftypes.h

Abstract:

    This module defines private data structures and types for the NT
    NBF transport provider.

Author:

    David Beaver (dbeaver) 1 July 1991

Revision History:

--*/

#ifndef _NBFTYPES_
#define _NBFTYPES_

//
// This structure defines a NETBIOS name as a character array for use when
// passing preformatted NETBIOS names between internal routines.  It is
// not a part of the external interface to the transport provider.
//

#define NETBIOS_NAME_SIZE 16

typedef struct _NBF_NETBIOS_ADDRESS {
    UCHAR NetbiosName[NETBIOS_NAME_SIZE];
    USHORT NetbiosNameType;
} NBF_NETBIOS_ADDRESS, *PNBF_NETBIOS_ADDRESS;

typedef UCHAR NAME;
typedef NAME UNALIGNED *PNAME;


//
// This structure defines things associated with a TP_REQUEST, or outstanding
// TDI request, maintained on a queue somewhere in the transport.  All
// requests other than open/close require that a TP_REQUEST block be built.
//

#if DBG
#define REQUEST_HISTORY_LENGTH 20
extern KSPIN_LOCK NbfGlobalInterlock;
#endif

//
// To log packets that are sent/recd by NBF
//

#if PKT_LOG

#define PKT_QUE_SIZE     8

#define PKT_LOG_SIZE    58

typedef struct _PKT_LOG_ELM {
    USHORT   TimeLogged;
    USHORT   BytesTotal;
    USHORT   BytesSaved;
    UCHAR    PacketData[PKT_LOG_SIZE];
} PKT_LOG_ELM;

typedef struct _PKT_LOG_QUE {
    ULONG       PktNext;
    PKT_LOG_ELM PktQue[PKT_QUE_SIZE];
} PKT_LOG_QUE;

#define PKT_IND_SIZE    32

typedef struct _PKT_IND_ELM {
    USHORT   TimeLogged;
    USHORT   BytesTotal;
    USHORT   BytesIndic;
    USHORT   BytesTaken;
    ULONG    IndcnStatus;
    UCHAR    PacketData[PKT_IND_SIZE];
} PKT_IND_ELM;

typedef struct _PKT_IND_QUE {
    ULONG       PktNext;
    PKT_IND_ELM PktQue[PKT_QUE_SIZE];
} PKT_IND_QUE;


#endif // PKT_LOG


//
// the types of potential owners of requests
//

typedef  enum _REQUEST_OWNER {
    ConnectionType,
    AddressType,
    DeviceContextType
} REQUEST_OWNER;

//typedef
//NTSTATUS
//(*PTDI_TIMEOUT_ACTION)(
//    IN PTP_REQUEST Request
//    );

//
// The request itself
//

#if DBG
#define RREF_CREATION   0
#define RREF_PACKET     1
#define RREF_TIMER      2
#define RREF_RECEIVE    3
#define RREF_FIND_NAME  4
#define RREF_STATUS     5

#define NUMBER_OF_RREFS 8
#endif

typedef struct _TP_REQUEST {
    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure
    LIST_ENTRY Linkage;                   // used by ExInterlocked routines.
    KSPIN_LOCK SpinLock;                  // spinlock for other fields.
                                          //  (used in KeAcquireSpinLock calls)
#if DBG
    LONG RefTypes[NUMBER_OF_RREFS];
#endif
    LONG ReferenceCount;                  // reasons why we can't destroy this req.

    struct _DEVICE_CONTEXT *Provider;     // pointer to the device context.
    PKSPIN_LOCK ProviderInterlock;        // &Provider->Interlock.

    PIRP IoRequestPacket;                 // pointer to IRP for this request.

    //
    // The following two fields are used to quickly reference the basic
    // components of the requests without worming through the IRP's stack.
    //

    PVOID Buffer2;                        // second buffer in the request.
    ULONG Buffer2Length;                  // length of the second buffer.

    //
    // The following two fields (Flags and Context) are used to clean up
    // queued requests which must be canceled or abnormally completed.
    // The Flags field contains bitflags indicating the state of the request,
    // and the specific queue type that the request is located on.  The
    // Context field contains a pointer to the owning structure (TP_CONNECTION
    // or TP_ADDRESS) so that the cleanup routines can perform post-cleanup
    // operations on the owning structure, such as dereferencing, etc.
    //

    ULONG Flags;                          // disposition of this request.
    PVOID Context;                        // context of this request.
    REQUEST_OWNER Owner;                  // what type of owner this request has.

#if DBG
    LARGE_INTEGER Time;                   // time when request created
#endif

    KTIMER Timer;                         // kernel timer for this request.
    KDPC Dpc;                             // DPC object for timeouts.

    //
    // These fields are used for FIND.NAME and STATUS.QUERY requests.
    //

    ULONG Retries;                        // timeouts remaining.
    USHORT BytesWritten;                  // usage varies.
    USHORT FrameContext;                  // identifies request.
    PVOID ResponseBuffer;                 // temp alloc to hold data.

#if DBG
  LIST_ENTRY GlobalLinkage;
  ULONG TotalReferences;
  ULONG TotalDereferences;
  ULONG NextRefLoc;
  struct {
     PVOID Caller;
     PVOID CallersCaller;
  } History[REQUEST_HISTORY_LENGTH];
  BOOLEAN Completed;
  BOOLEAN Destroyed;
#endif

} TP_REQUEST, *PTP_REQUEST;

//
// in nbfdrvr.c
//

extern UNICODE_STRING NbfRegistryPath;

//
// We need the driver object to create device context structures.
//

extern PDRIVER_OBJECT NbfDriverObject;

//
// This is a list of all the device contexts that NBF owns,
// used while unloading.
//

extern LIST_ENTRY NbfDeviceList;

//
// And a lock that protects the global list of NBF devices
//
extern FAST_MUTEX NbfDevicesLock;

#define INITIALIZE_DEVICES_LIST_LOCK()                                  \
    ExInitializeFastMutex(&NbfDevicesLock)

#define ACQUIRE_DEVICES_LIST_LOCK()                                     \
    ACQUIRE_FAST_MUTEX_UNSAFE(&NbfDevicesLock)

#define RELEASE_DEVICES_LIST_LOCK()                                     \
    RELEASE_FAST_MUTEX_UNSAFE(&NbfDevicesLock)

//
// A handle to be used in all provider notifications to TDI layer
// 
extern HANDLE NbfProviderHandle;

//
// Global Configuration block for the driver ( no lock required )
// 
extern PCONFIG_DATA   NbfConfig;

#if DBG
extern KSPIN_LOCK NbfGlobalHistoryLock;
extern LIST_ENTRY NbfGlobalRequestList;
#define StoreRequestHistory(_req,_ref) {                                \
    KIRQL oldIrql;                                                      \
    KeAcquireSpinLock (&NbfGlobalHistoryLock, &oldIrql);                \
    if ((_req)->Destroyed) {                                            \
        DbgPrint ("request touched after being destroyed 0x%lx\n",      \
                    (_req));                                            \
        DbgBreakPoint();                                                \
    }                                                                   \
    RtlGetCallersAddress(                                               \
        &(_req)->History[(_req)->NextRefLoc].Caller,                    \
        &(_req)->History[(_req)->NextRefLoc].CallersCaller              \
        );                                                              \
    if ((_ref)) {                                                       \
        (_req)->TotalReferences++;                                      \
    } else {                                                            \
        (_req)->TotalDereferences++;                                    \
        (_req)->History[(_req)->NextRefLoc].Caller =                    \
         (PVOID)((ULONG_PTR)(_req)->History[(_req)->NextRefLoc].Caller | 1); \
    }                                                                   \
    if (++(_req)->NextRefLoc == REQUEST_HISTORY_LENGTH) {               \
        (_req)->NextRefLoc = 0;                                         \
    }                                                                   \
    KeReleaseSpinLock (&NbfGlobalHistoryLock, oldIrql);                 \
}
#endif

#define NBF_ALLOCATION_TYPE_REQUEST 1

#define REQUEST_FLAGS_TIMER      0x0001 // a timer is active for this request.
#define REQUEST_FLAGS_TIMED_OUT  0x0002 // a timer expiration occured on this request.
#define REQUEST_FLAGS_ADDRESS    0x0004 // request is attached to a TP_ADDRESS.
#define REQUEST_FLAGS_CONNECTION 0x0008 // request is attached to a TP_CONNECTION.
#define REQUEST_FLAGS_STOPPING   0x0010 // request is being killed.
#define REQUEST_FLAGS_EOR        0x0020 // TdiSend request has END_OF_RECORD mark.
#define REQUEST_FLAGS_PIGGYBACK  0x0040 // TdiSend that can be piggyback ack'ed.
#define REQUEST_FLAGS_DC         0x0080 // request is attached to a TP_DEVICE_CONTEXT

//
// This defines the TP_SEND_IRP_PARAMETERS, which is masked onto the
// Parameters section of a send IRP's stack location.
//

typedef struct _TP_SEND_IRP_PARAMETERS {
    TDI_REQUEST_KERNEL_SEND Request;
    LONG ReferenceCount;
    PVOID Irp;
} TP_SEND_IRP_PARAMETERS, *PTP_SEND_IRP_PARAMETERS;

#define IRP_SEND_LENGTH(_IrpSp) \
    (((PTP_SEND_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Request.SendLength)

#define IRP_SEND_FLAGS(_IrpSp) \
    (((PTP_SEND_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Request.SendFlags)

#define IRP_SEND_REFCOUNT(_IrpSp) \
    (((PTP_SEND_IRP_PARAMETERS)&(_IrpSp)->Parameters)->ReferenceCount)

#define IRP_SEND_IRP(_IrpSp) \
    (((PTP_SEND_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Irp)

#define IRP_SEND_CONNECTION(_IrpSp) \
    ((PTP_CONNECTION)((_IrpSp)->FileObject->FsContext))

#define IRP_DEVICE_CONTEXT(_IrpSp) \
    ((PDEVICE_CONTEXT)((_IrpSp)->DeviceObject))


//
// This defines the TP_RECEIVE_IRP_PARAMETERS, which is masked onto the
// Parameters section of a receive IRP's stack location.
//

typedef struct _TP_RECEIVE_IRP_PARAMETERS {
    TDI_REQUEST_KERNEL_RECEIVE Request;
    LONG ReferenceCount;
    PIRP Irp;
} TP_RECEIVE_IRP_PARAMETERS, *PTP_RECEIVE_IRP_PARAMETERS;

#define IRP_RECEIVE_LENGTH(_IrpSp) \
    (((PTP_RECEIVE_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Request.ReceiveLength)

#define IRP_RECEIVE_FLAGS(_IrpSp) \
    (((PTP_RECEIVE_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Request.ReceiveFlags)

#define IRP_RECEIVE_REFCOUNT(_IrpSp) \
    (((PTP_RECEIVE_IRP_PARAMETERS)&(_IrpSp)->Parameters)->ReferenceCount)

#define IRP_RECEIVE_IRP(_IrpSp) \
    (((PTP_RECEIVE_IRP_PARAMETERS)&(_IrpSp)->Parameters)->Irp)

#define IRP_RECEIVE_CONNECTION(_IrpSp) \
    ((PTP_CONNECTION)((_IrpSp)->FileObject->FsContext))



//
// This structure defines a TP_UI_FRAME, or connectionless frame header,
// that is manipulated by the FRAME.C routines.
//

typedef struct _TP_UI_FRAME {
  PNDIS_PACKET NdisPacket;
  LIST_ENTRY Linkage;                     // used by ExInterLocked routines.
  PVOID DataBuffer;                       // for transport-created data.
  UCHAR Header[1];                        // the header in the frame (MAC + DLC + NBF)
} TP_UI_FRAME, *PTP_UI_FRAME;


//
// This structure defines a TP_VARIABLE, or network managable variable,
// maintained in a linked list on the device context.
//

typedef struct _TP_VARIABLE {

  struct _TP_VARIABLE *Fwdlink;         // next variable in provider's chain.

  ULONG VariableSerialNumber;           // identifier for this variable.
  ULONG VariableType;                   // type of this variable (see TDI.H).
  STRING VariableName;                  // allocated variable name.

  union {
      ULONG LongValue;
      HARDWARE_ADDRESS HardwareAddressValue;
      STRING StringValue;               // allocated string value, if of that type.
  } Value;

} TP_VARIABLE, *PTP_VARIABLE;


//
// This structure defines a TP_CONNECTION, or active transport connection,
// maintained on a transport address.
//

#if DBG
#define CONNECTION_HISTORY_LENGTH 50

#define CREF_SPECIAL_CREATION 0
#define CREF_SPECIAL_TEMP 1
#define CREF_COMPLETE_SEND 2
#define CREF_SEND_IRP 3
#define CREF_ADM_SESS 4
#define CREF_TRANSFER_DATA 5
#define CREF_FRAME_SEND 6
#define CREF_TIMER 7
#define CREF_BY_ID 8
#define CREF_LINK 9
#define CREF_SESSION_END 10
#define CREF_LISTENING 11
#define CREF_P_LINK 12
#define CREF_P_CONNECT 13
#define CREF_PACKETIZE 14
#define CREF_RECEIVE_IRP 15
#define CREF_PROCESS_DATA 16
#define CREF_REQUEST 17
#define CREF_TEMP 18
#define CREF_DATA_ACK_QUEUE 19
#define CREF_ASSOCIATE 20
#define CREF_STOP_ADDRESS 21
#define CREF_PACKETIZE_QUEUE 22
#define CREF_STALLED 23

#define NUMBER_OF_CREFS 24
#endif

//
// This structure holds our "complex send pointer" indicating
// where we are in the packetization of a send.
//

typedef struct _TP_SEND_POINTER {
    ULONG MessageBytesSent;             // up count, bytes sent/this msg.
    PIRP CurrentSendIrp;                // ptr, current send request in chain.
    PMDL  CurrentSendMdl;               // ptr, current MDL in send chain.
    ULONG SendByteOffset;               // current byte offset in current MDL.
} TP_SEND_POINTER, *PTP_SEND_POINTER;

typedef struct _TP_CONNECTION {

#if DBG
    ULONG RefTypes[NUMBER_OF_CREFS];
#endif

#if DBG
    ULONG LockAcquired;
    UCHAR LastAcquireFile[8];
    ULONG LastAcquireLine;
    ULONG Padding;
    UCHAR LastReleaseFile[8];
    ULONG LastReleaseLine;
#endif

    CSHORT Type;
    USHORT Size;

    LIST_ENTRY LinkList;                // used for link thread or for free
                                        // resource list
    KSPIN_LOCK SpinLock;                // spinlock for connection protection.
    PKSPIN_LOCK LinkSpinLock;           // pointer to link's spinlock

    LONG ReferenceCount;                // number of references to this object.
    LONG SpecialRefCount;               // controls freeing of connection.

    //
    // The following lists are used to associate this connection with a
    // particular address.
    //

    LIST_ENTRY AddressList;             // list of connections for given address
    LIST_ENTRY AddressFileList;         // list for connections bound to a
                                        // given address reference

    //
    // The following field is used as linkage in the device context's
    // PacketizeQueue
    //

    LIST_ENTRY PacketizeLinkage;

    //
    // The following field is used as linkage in the device context's
    // PacketWaitQueue.
    //

    LIST_ENTRY PacketWaitLinkage;

    //
    // The following field points to the TP_LINK object that describes the
    // (active) data link connection for this transport connection.  To be
    // valid, this field is non-NULL.
    //

    struct _TP_LINK *Link;                  // pointer to transport link object.
    struct _TP_ADDRESS_FILE *AddressFile;   // pointer to owning Address.
    struct _DEVICE_CONTEXT *Provider;       // device context to which we are attached.
    PKSPIN_LOCK ProviderInterlock;          // &Provider->Interlock
    PFILE_OBJECT FileObject;                // easy backlink to file object.

    //
    // The following field contains the actual ID we expose to the TDI client
    // to represent this connection.  A unique one is created from the address.
    //

    USHORT ConnectionId;                    // unique identifier.
    UCHAR SessionNumber;                    // the session number used in the packet header

    //
    // This field is used to keep the reason for the connection disconnect
    // around until connection deletion time.
    //

    BOOLEAN RemoteDisconnect;           // was this connection remotely disonnected?

    //
    // The following field is specified by the user at connection open time.
    // It is the context that the user associates with the connection so that
    // indications to and from the client can be associated with a particular
    // connection.
    //

    CONNECTION_CONTEXT Context;         // client-specified value.

    //
    // The following two queues are used to associate TdiSend and TdiReceive
    // IRPs with this connection.  New arrivals are placed at the end of
    // the queues (really a linked list) and IRPs are processed at the
    // front of the queues.  The first TdiSend IRP on the SendQueue is
    // the current TdiSend being processed, and the first TdiReceive IRP
    // on the ReceiveQueue is the first TdiReceive being processed, PROVIDED
    // the CONNECTION_FLAGS_ACTIVE_RECEIVE flag is set.  If this flag is not
    // set, then the first TdiReceive IRP on the ReceiveQueue is not active.
    // These queues are managed by the EXECUTIVE interlocked list manipuation
    // routines.
    //

    LIST_ENTRY SendQueue;               // FIFO of outstanding TdiSends.
    LIST_ENTRY ReceiveQueue;            // FIFO of outstanding TdiReceives.

    //
    // The following fields are used to maintain state for the current receive.
    //

    ULONG MessageBytesReceived;         // up count, bytes recd/this msg.
    ULONG MessageBytesAcked;            // bytes acked (NR or RO) this msg.
    ULONG MessageInitAccepted;          // bytes accepted during indication.

    //
    // These fields are only valid if the CONNECTION_FLAGS_ACTIVE_RECEIVE
    // flag is set.
    //

    PIRP SpecialReceiveIrp;             // a "no-request" receive IRP exists.
    PIRP CurrentReceiveIrp;             // ptr, current receive IRP.
    PMDL  CurrentReceiveMdl;            // ptr, current MDL in receive chain.
    ULONG ReceiveByteOffset;            // current byte offset in current MDL.
    ULONG ReceiveLength;                // current receive length, in bytes (total)
    ULONG ReceiveBytesUnaccepted;       // by client...only indicate when == 0

    //
    // The following fields are used to maintain state for the active send.
    // They only have meaning if the connection's SendState is not IDLE.
    // Because the TDI client may submit multiple TdiSend requests to comprise
    // a full message, we have to keep a complex pointer to the first byte of
    // unACKed data (hence the first three fields).  We also have a complex
    // pointer to the first byte of unsent data (hence the last three fields).
    //

    ULONG SendState;                    // send state machine variable.

    PIRP FirstSendIrp;                  // ptr, 1st TdiSend's IRP.
    PMDL  FirstSendMdl;                 // ptr, 1st unacked MDL in chain/this msg.
    ULONG FirstSendByteOffset;          // pre-acked bytes in that MDL.

    TP_SEND_POINTER sp;                 // current send loc, defined above.
    ULONG CurrentSendLength;            // how long is this send (total)
    ULONG StallCount;                   // times in a row we looked stalled.
    ULONG StallBytesSent;               // bytes sent last time we checked.

    //
    // This is TRUE if we need don't need to reference the current
    // receive IRP during transfers (because it is a special
    // receive or the driver doesn't pend transfers).
    //

    BOOLEAN CurrentReceiveSynchronous;

    //
    // This field will be TRUE if the last DOL received allowed
    // piggyback acks.
    //

    BOOLEAN CurrentReceiveAckQueueable;

    //
    //
    // This field will be TRUE if the last DOL received was
    // sent NO.ACK.
    //

    BOOLEAN CurrentReceiveNoAck;

    //
    // These fields handle asynchronous TransferData calls.
    //

    ULONG TransferBytesPending;         // bytes pending in current transfers
    ULONG TotalTransferBytesPending;    // bytes since TransferBytesPending was 0;
                                        // how much we back off if a transfer fails
    PMDL SavedCurrentReceiveMdl;        // used to back off by TotalTransferPending bytes
    ULONG SavedReceiveByteOffset;       // used to back off by TotalTransferPending bytes

    //
    // This field will be TRUE if we are in the middle of
    // processing a receive indication on this connection and
    // we are not yet in a state where another indication
    // can be handled.
    //
    // It is stored as a INT since access to it is guarded
    // by the connection's link spinlock, unlike the variables
    // around it
    //

    UINT IndicationInProgress;

    //
    // The following field is used as a linkage when on the device
    // context's DataAckQueue.
    //

    LIST_ENTRY DataAckLinkage;

    //
    // TRUE if the connection is on the data ack queue.
    // Also an INT so access can be non-guarded.
    //

    UINT OnDataAckQueue;

    //
    // These keep track of the number of consecutive sends or
    // receives on this connection. This is used in determining when
    // to queue a data ack.
    //

    ULONG ConsecutiveSends;
    ULONG ConsecutiveReceives;

    //
    // The following list head is used as a pointer to a TdiListen/TdiConnect
    // request which is in progress.  Although manipulated
    // with queue instructions, there will only be one request in the queue.
    // This is done for consistency with respect to TpCreateRequest, which
    // does a great job of creating a request and associating it atomically
    // with a supervisory object.
    //

    LIST_ENTRY InProgressRequest;       // TdiListen/TdiConnect

    //
    // If the connection is being disconnected as a result of
    // a TdiDisconnect call (RemoteDisconnect is FALSE) then this
    // will hold the IRP passed to TdiDisconnect. It is needed
    // when the TdiDisconnect request is completed.
    //

    PIRP DisconnectIrp;

    //
    // If the connection is being closed, this will hold
    // the IRP passed to TdiCloseConnection. It is needed
    // when the request is completed.
    //

    PIRP CloseIrp;

    //
    // These fields are used for deferred operations on connections; the only
    // deferred operation currently supported is piggyback ACK
    //

    ULONG DeferredFlags;
#if DBG
    ULONG DeferredPasses;
#endif
    LIST_ENTRY DeferredQueue;

    //
    // The following fields are used for connection housekeeping.
    //

    ULONG Flags;                        // attributes guarded by LinkSpinLock
    ULONG Flags2;                       // attributes guarded by SpinLock
    UINT OnPacketWaitQueue;             // TRUE if on PacketWaitQueue
    UCHAR Lsn;                          // local session number (1-254).
    UCHAR Rsn;                          // remote session number (1-254).
    USHORT Retries;                     // retry limit for NAME_QUERY shipments.
    KTIMER Timer;                       // kernel timer for timeouts on NQ/NR.
    LARGE_INTEGER ConnectStartTime;     // when we sent the committed NQ.
    KDPC Dpc;                           // DPC object for timeouts.
    NTSTATUS Status;                    // status code for connection rundown.
    ULONG LastPacketsSent;              // The value that was in Link->XXX the
    ULONG LastPacketsResent;            //  last time we calculated the throughput.
    NBF_NETBIOS_ADDRESS CalledAddress;  // TdiConnect request's T.A.
    USHORT MaximumDataSize;             // maximum I-frame data size for NBF.

    NBF_HDR_CONNECTION NetbiosHeader;   // pre-built Netbios header; we store
                                        // the current send and reply correlators
                                        // in the appropriate spots in this.

    //
    // These are for CONNECTION_INFO queries.
    //

    ULONG TransmittedTsdus;             // TSDUs sent on this connection.
    ULONG ReceivedTsdus;                // TSDUs received on this connection.
    ULONG TransmissionErrors;           // TSDUs transmitted in error/this connection.
    ULONG ReceiveErrors;                // TSDUs received in error/this connection.

    //
    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    //

    // TDI_CONNECTION_INFO Information;    // information about this connection.

#if DBG
    LIST_ENTRY GlobalLinkage;
    ULONG TotalReferences;
    ULONG TotalDereferences;
    ULONG NextRefLoc;
    struct {
        PVOID Caller;
        PVOID CallersCaller;
    } History[CONNECTION_HISTORY_LENGTH];
    BOOLEAN Destroyed;
#endif
    CHAR RemoteName[16];

#if PKT_LOG
    PKT_LOG_QUE   LastNRecvs;
    PKT_LOG_QUE   LastNSends;
    PKT_IND_QUE   LastNIndcs;
#endif // PKT_LOG

} TP_CONNECTION, *PTP_CONNECTION;

#if DBG
extern KSPIN_LOCK NbfGlobalHistoryLock;
extern LIST_ENTRY NbfGlobalConnectionList;
#define StoreConnectionHistory(_conn,_ref) {                                \
    KIRQL oldIrql;                                                          \
    KeAcquireSpinLock (&NbfGlobalHistoryLock, &oldIrql);                    \
    if ((_conn)->Destroyed) {                                               \
        DbgPrint ("connection touched after being destroyed 0x%lx\n",       \
                    (_conn));                                               \
        DbgBreakPoint();                                                    \
    }                                                                       \
    RtlGetCallersAddress(                                                   \
        &(_conn)->History[(_conn)->NextRefLoc].Caller,                      \
        &(_conn)->History[(_conn)->NextRefLoc].CallersCaller                \
        );                                                                  \
    if ((_ref)) {                                                           \
        (_conn)->TotalReferences++;                                         \
    } else {                                                                \
        (_conn)->TotalDereferences++;                                       \
        (_conn)->History[(_conn)->NextRefLoc].Caller =                      \
         (PVOID)((ULONG_PTR)(_conn)->History[(_conn)->NextRefLoc].Caller | 1); \
    }                                                                       \
    if (++(_conn)->NextRefLoc == CONNECTION_HISTORY_LENGTH) {               \
        (_conn)->NextRefLoc = 0;                                            \
    }                                                                       \
    KeReleaseSpinLock (&NbfGlobalHistoryLock, oldIrql);                     \
}
#endif

#define CONNECTION_FLAGS_VERSION2       0x00000001 // remote netbios is version 2.0.
#define CONNECTION_FLAGS_RECEIVE_WAKEUP 0x00000002 // send a RECEIVE_OUTSTANDING when a receive arrives.
#define CONNECTION_FLAGS_ACTIVE_RECEIVE 0x00000004 // a receive is active.
#define CONNECTION_FLAGS_WAIT_SI        0x00000020 // waiting for a SESSION_INITIALIZE.
#define CONNECTION_FLAGS_WAIT_SC        0x00000040 // waiting for a SESSION_CONFIRM.
#define CONNECTION_FLAGS_WAIT_LINK_UP   0x00000080 // waiting for DDI to est. connection.
#define CONNECTION_FLAGS_READY          0x00000200 // sends/rcvs/discons valid.
#define CONNECTION_FLAGS_RC_PENDING     0x00001000 // a receive is pending completion
#define CONNECTION_FLAGS_W_PACKETIZE    0x00002000 // w/for a packet to packetize.
#define CONNECTION_FLAGS_PACKETIZE      0x00004000 // we're on the PacketizeQueue.
#define CONNECTION_FLAGS_W_RESYNCH      0x00008000 // waiting for resynch indicator. (receive)
#define CONNECTION_FLAGS_SEND_SI        0x00010000 // w/for a packet to send SI.
#define CONNECTION_FLAGS_SEND_SC        0x00020000 // w/for a packet to send SC.
#define CONNECTION_FLAGS_SEND_DA        0x00040000 // w/for a packet to send DA.
#define CONNECTION_FLAGS_SEND_RO        0x00080000 // w/for a packet to send RO.
#define CONNECTION_FLAGS_SEND_RC        0x00100000 // w/for a packet to send RC.
#define CONNECTION_FLAGS_SEND_SE        0x00200000 // w/for a packet to send SE.
#define CONNECTION_FLAGS_SEND_NR        0x00400000 // w/for a packet to send NR.
#define CONNECTION_FLAGS_NO_INDICATE    0x00800000 // don't take packets at indication time
#define CONNECTION_FLAGS_FAILING_TO_EOR 0x01000000 // wait for an EOF in an incoming request before sending
#define CONNECTION_FLAGS_RESYNCHING     0x02000000 // engaged send side resynch
#define CONNECTION_FLAGS_RCV_CANCELLED  0x10000000 // current receive was cancelled
#define CONNECTION_FLAGS_PEND_INDICATE  0x20000000 // new data received during RC_PENDING
#define CONNECTION_FLAGS_TRANSFER_FAIL  0x40000000 // a transfer data call failed

#define CONNECTION_FLAGS2_STOPPING      0x00000001 // connection is running down.
#define CONNECTION_FLAGS2_WAIT_NR       0x00000002 // waiting for NAME_RECOGNIZED.
#define CONNECTION_FLAGS2_WAIT_NQ       0x00000004 // waiting for NAME_QUERY.
#define CONNECTION_FLAGS2_WAIT_NR_FN    0x00000008 // waiting for FIND NAME response.
#define CONNECTION_FLAGS2_CLOSING       0x00000010 // connection is closing
#define CONNECTION_FLAGS2_ASSOCIATED    0x00000020 // associated with address
#define CONNECTION_FLAGS2_DISCONNECT    0x00000040 // disconnect done on connection
#define CONNECTION_FLAGS2_ACCEPTED      0x00000080 // accept done on connection
#define CONNECTION_FLAGS2_REQ_COMPLETED 0x00000100 // Listen/Connect request completed.
#define CONNECTION_FLAGS2_DISASSOCIATED 0x00000200 // associate CRef has been removed
#define CONNECTION_FLAGS2_DISCONNECTED  0x00000400 // disconnect has been indicated
#define CONNECTION_FLAGS2_NO_LISTEN     0x00000800 // no_listen received during setup
#define CONNECTION_FLAGS2_REMOTE_VALID  0x00001000 // Connection->RemoteName is valid
#define CONNECTION_FLAGS2_GROUP_LSN     0x00002000 // connection LSN is globally assigned
#define CONNECTION_FLAGS2_W_ADDRESS     0x00004000 // waiting for address reregistration.
#define CONNECTION_FLAGS2_PRE_ACCEPT    0x00008000 // no TdiAccept after listen completes
#define CONNECTION_FLAGS2_ABORT         0x00010000 // abort this connection.
#define CONNECTION_FLAGS2_ORDREL        0x00020000 // we're in orderly release.
#define CONNECTION_FLAGS2_DESTROY       0x00040000 // destroy this connection.
#define CONNECTION_FLAGS2_LISTENER      0x00100000 // we were the passive listener.
#define CONNECTION_FLAGS2_CONNECTOR     0x00200000 // we were the active connector.
#define CONNECTION_FLAGS2_WAITING_SC    0x00400000 // the connection is waiting for
                                                   // and accept to send the
                                                   // session confirm
#define CONNECTION_FLAGS2_INDICATING    0x00800000 // connection was manipulated while
                                                   // indication was in progress

#define CONNECTION_FLAGS2_LDISC         0x01000000 // Local disconnect req.
#ifdef RASAUTODIAL
#define CONNECTION_FLAGS2_AUTOCONNECTING 0x02000000 // RAS autodial in progress
#define CONNECTION_FLAGS2_AUTOCONNECTED  0x04000000 // RAS autodial done
#endif // RASAUTODIAL

#define CONNECTION_FLAGS_STARVED (     \
            CONNECTION_FLAGS_SEND_SI | \
            CONNECTION_FLAGS_SEND_SC | \
            CONNECTION_FLAGS_SEND_DA | \
            CONNECTION_FLAGS_SEND_RO | \
            CONNECTION_FLAGS_SEND_RC | \
            CONNECTION_FLAGS_SEND_NR | \
            CONNECTION_FLAGS_SEND_SE   \
        )

#define CONNECTION_FLAGS_DEFERRED_ACK     0x00000001  // send piggyback ack first opportunity
#define CONNECTION_FLAGS_DEFERRED_ACK_2   0x00000002  // deferred ack wasn't sent
#define CONNECTION_FLAGS_DEFERRED_NOT_Q   0x00000004  // DEFERRED_ACK set, but not on DataAckQueue
#define CONNECTION_FLAGS_DEFERRED_SENDS   0x80000000  // print completed sends

#define CONNECTION_SENDSTATE_IDLE       0       // no sends being processed.
#define CONNECTION_SENDSTATE_PACKETIZE  1       // send being packetized.
#define CONNECTION_SENDSTATE_W_PACKET   2       // waiting for free packet.
#define CONNECTION_SENDSTATE_W_LINK     3       // waiting for good link conditions.
#define CONNECTION_SENDSTATE_W_EOR      4       // waiting for TdiSend(EOR).
#define CONNECTION_SENDSTATE_W_ACK      5       // waiting for DATA_ACK.
#define CONNECTION_SENDSTATE_W_RCVCONT  6       // waiting for RECEIVE_CONTINUE.


//
// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Address.  This structure is the base for all activities on
// the open file object within the transport provider.  All active connections
// on the address point to this structure, although no queues exist here to do
// work from. This structure also maintains a reference to a TP_ADDRESS
// structure, which describes the address that it is bound to. Thus, a
// connection will point to this structure, which describes the address the
// connection was associated with. When the address file closes, all connections
// opened on this address file get closed, too. Note that this may leave an
// address hanging around, with other references.
//

typedef struct _TP_ADDRESS_FILE {

    CSHORT Type;
    CSHORT Size;

    LIST_ENTRY Linkage;                 // next address file on this address.
                                        // also used for linkage in the
                                        // look-aside list

    LONG ReferenceCount;                // number of references to this object.

    //
    // This structure is edited after taking the Address spinlock for the
    // owning address. This ensures that the address and this structure
    // will never get out of syncronization with each other.
    //

    //
    // The following field points to a list of TP_CONNECTION structures,
    // one per connection open on this address.  This list of connections
    // is used to help the cleanup process if a process closes an address
    // before disassociating all connections on it. By design, connections
    // will stay around until they are explicitly
    // closed; we use this database to ensure that we clean up properly.
    //

    LIST_ENTRY ConnectionDatabase;      // list of defined transport connections.

    //
    // the current state of the address file structure; this is either open or
    // closing
    //

    UCHAR State;

    //
    // The following fields are kept for housekeeping purposes.
    //

    PIRP Irp;                           // the irp used for open or close
    struct _TP_ADDRESS *Address;        // address to which we are bound.
    PFILE_OBJECT FileObject;            // easy backlink to file object.
    struct _DEVICE_CONTEXT *Provider;   // device context to which we are attached.

    //
    // The following queue is used to queue receive datagram requests
    // on this address file. Send datagram requests are queued on the
    // address itself. These queues are managed by the EXECUTIVE interlocked
    // list management routines. The actual objects which get queued to this
    // structure are request control blocks (RCBs).
    //

    LIST_ENTRY ReceiveDatagramQueue;    // FIFO of outstanding TdiReceiveDatagrams.

    //
    // This holds the Irp used to close this address file,
    // for pended completion.
    //

    PIRP CloseIrp;

    //
    // is this address file currently indicating a connection request? if yes, we
    // need to mark connections that are manipulated during this time.
    //

    BOOLEAN ConnectIndicationInProgress;

    //
    // handler for kernel event actions. First we have a set of booleans that
    // indicate whether or not this address has an event handler of the given
    // type registered.
    //

    BOOLEAN RegisteredConnectionHandler;
    BOOLEAN RegisteredDisconnectHandler;
    BOOLEAN RegisteredReceiveHandler;
    BOOLEAN RegisteredReceiveDatagramHandler;
    BOOLEAN RegisteredExpeditedDataHandler;
    BOOLEAN RegisteredErrorHandler;

    //
    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    //
    //

    PTDI_IND_CONNECT ConnectionHandler;
    PVOID ConnectionHandlerContext;

    //
    // The following function pointer always points to a TDI_IND_DISCONNECT
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    //

    PTDI_IND_DISCONNECT DisconnectHandler;
    PVOID DisconnectHandlerContext;

    //
    // The following function pointer always points to a TDI_IND_RECEIVE
    // event handler for connections on this address.  If the NULL handler
    // is specified in a TdiSetEventHandler, then this points to an internal
    // routine which does not accept the incoming data.
    //

    PTDI_IND_RECEIVE ReceiveHandler;
    PVOID ReceiveHandlerContext;

    //
    // The following function pointer always points to a TDI_IND_RECEIVE_DATAGRAM
    // event handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which does
    // not accept the incoming data.
    //

    PTDI_IND_RECEIVE_DATAGRAM ReceiveDatagramHandler;
    PVOID ReceiveDatagramHandlerContext;

    //
    // An expedited data handler. This handler is used if expedited data is
    // expected; it never is in NBF, thus this handler should always point to
    // the default handler.
    //

    PTDI_IND_RECEIVE_EXPEDITED ExpeditedDataHandler;
    PVOID ExpeditedDataHandlerContext;

    //
    // The following function pointer always points to a TDI_IND_ERROR
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    //

    PTDI_IND_ERROR ErrorHandler;
    PVOID ErrorHandlerContext;
    PVOID ErrorHandlerOwner;


} TP_ADDRESS_FILE, *PTP_ADDRESS_FILE;

#define ADDRESSFILE_STATE_OPENING   0x00    // not yet open for business
#define ADDRESSFILE_STATE_OPEN      0x01    // open for business
#define ADDRESSFILE_STATE_CLOSING   0x02    // closing


//
// This structure defines a TP_ADDRESS, or active transport address,
// maintained by the transport provider.  It contains all the visible
// components of the address (such as the TSAP and network name components),
// and it also contains other maintenance parts, such as a reference count,
// ACL, and so on. All outstanding connection-oriented and connectionless
// data transfer requests are queued here.
//

#if DBG
#define AREF_TIMER              0
#define AREF_TEMP_CREATE        1
#define AREF_OPEN               2
#define AREF_VERIFY             3
#define AREF_LOOKUP             4
#define AREF_FRAME_SEND         5
#define AREF_CONNECTION         6
#define AREF_TEMP_STOP          7
#define AREF_REQUEST            8
#define AREF_PROCESS_UI         9
#define AREF_PROCESS_DATAGRAM  10
#define AREF_TIMER_SCAN        11

#define NUMBER_OF_AREFS        12
#endif

typedef struct _TP_ADDRESS {

#if DBG
    ULONG RefTypes[NUMBER_OF_AREFS];
#endif

    USHORT Size;
    CSHORT Type;

    LIST_ENTRY Linkage;                 // next address/this device object.
    LONG ReferenceCount;                // number of references to this object.

    //
    // The following spin lock is acquired to edit this TP_ADDRESS structure
    // or to scan down or edit the list of address files.
    //

    KSPIN_LOCK SpinLock;                // lock to manipulate this structure.

    //
    // The following fields comprise the actual address itself.
    //

    PIRP Irp;                           // pointer to address creation IRP.
    PNBF_NETBIOS_ADDRESS NetworkName;    // this address

    //
    // The following fields are used to maintain state about this address.
    //

    ULONG Flags;                        // attributes of the address.
    ULONG SendFlags;				   // State of the datagram current send
    struct _DEVICE_CONTEXT *Provider;   // device context to which we are attached.

    //
    // The following queues is used to hold send datagrams for this
    // address. Receive datagrams are queued to the address file. Requests are
    // processed in a first-in, first-out manner, so that the very next request
    // to be serviced is always at the head of its respective queue.  These
    // queues are managed by the EXECUTIVE interlocked list management routines.
    // The actual objects which get queued to this structure are request control
    // blocks (RCBs).
    //

    LIST_ENTRY SendDatagramQueue;       // FIFO of outstanding TdiSendDatagrams.

    //
    // The following field points to a list of TP_CONNECTION structures,
    // one per active, connecting, or disconnecting connections on this
    // address.  By definition, if a connection is on this list, then
    // it is visible to the client in terms of receiving events and being
    // able to post requests by naming the ConnectionId.  If the connection
    // is not on this list, then it is not valid, and it is guaranteed that
    // no indications to the client will be made with reference to it, and
    // no requests specifying its ConnectionId will be accepted by the transport.
    //

    LIST_ENTRY ConnectionDatabase;  // list of defined transport connections.
    LIST_ENTRY AddressFileDatabase; // list of defined address file objects

    //
    // The packet pool of size 1 that holds the UI frame, and the
    // frame that is allocated out of it.
    //

    NDIS_HANDLE UIFramePoolHandle;
    PTP_UI_FRAME UIFrame;               // DLC-UI/NBF header for datagram sends.

    //
    // The following fields are used to register this address on the network.
    //

    ULONG Retries;                      // retries of ADD_NAME_QUERY left to go.
    KTIMER Timer;                       // kernel timer for timeouts on ANQ/ANR.
    KDPC Dpc;                           // DPC object for timeout.

    //
    // These two can be a union because they are not used
    // concurrently.
    //

    union {

        //
        // This structure is used for checking share access.
        //

        SHARE_ACCESS ShareAccess;

        //
        // Used for delaying NbfDestroyAddress to a thread so
        // we can access the security descriptor.
        //

        WORK_QUEUE_ITEM DestroyAddressQueueItem;

    } u;

    //
    // This structure is used to hold ACLs on the address.

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // If we get an ADD_NAME_RESPONSE frame, this holds the address
    // of the remote we got it from (used to check for duplicate names).
    //

    UCHAR UniqueResponseAddress[6];

    //
    // Set to TRUE once we send a name in conflict frame, so that
    // we don't flood the network with them on every response.
    //

    BOOLEAN NameInConflictSent;

} TP_ADDRESS, *PTP_ADDRESS;

#define ADDRESS_FLAGS_GROUP             0x00000001 // set if group, otherwise unique.
#define ADDRESS_FLAGS_CONFLICT          0x00000002 // address in conflict detected.
#define ADDRESS_FLAGS_REGISTERING       0x00000004 // registration in progress.
#define ADDRESS_FLAGS_DEREGISTERING     0x00000008 // deregistration in progress.
#define ADDRESS_FLAGS_DUPLICATE_NAME    0x00000010 // duplicate name was found on net.
#define ADDRESS_FLAGS_NEEDS_REG         0x00000020 // address must be registered.
#define ADDRESS_FLAGS_STOPPING          0x00000040 // TpStopAddress is in progress.
#define ADDRESS_FLAGS_BAD_ADDRESS       0x00000080 // name in conflict on associated address.
#define ADDRESS_FLAGS_SEND_IN_PROGRESS  0x00000100 // send datagram process active.
#define ADDRESS_FLAGS_CLOSED            0x00000200 // address has been closed;
                                                   // existing activity can
                                                   // complete, nothing new can start
#define ADDRESS_FLAGS_NEED_REREGISTER   0x00000400 // quick-reregister on next connect.
#define ADDRESS_FLAGS_QUICK_REREGISTER  0x00000800 // address is quick-reregistering.

#ifndef NO_STRESS_BUG
#define ADDRESS_FLAGS_SENT_TO_NDIS		 0x00010000	// Packet sent to the NDIS layer
#define ADDRESS_FLAGS_RETD_BY_NDIS		 0x00020000	// Packet returned by the NDIS layer
#endif


//
// This structure defines a TP_LINK, or established data link object,
// maintained by the transport provider.  Each data link connection with
// a remote machine is represented by this object.  Zero, one, or several
// transport connections can be multiplexed over the same data link connection.
// This object is managed by routines in LINK.C.
//

#if DBG
#define LREF_SPECIAL_CONN 0
#define LREF_SPECIAL_TEMP 1
#define LREF_CONNECTION 2
#define LREF_STOPPING 3
#define LREF_START_T1 4
#define LREF_TREE 5
#define LREF_NOT_ADM 6
#define LREF_NDIS_SEND 7

#define NUMBER_OF_LREFS 8
#endif

#if DBG
#define LINK_HISTORY_LENGTH 20
#endif

typedef struct _TP_LINK {

    RTL_SPLAY_LINKS SplayLinks;         // for the link splay tree
    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

#if DBG
    ULONG RefTypes[NUMBER_OF_LREFS];
#endif

    LIST_ENTRY Linkage;               // for list of free links or deferred
                                        // operation queue
    KSPIN_LOCK SpinLock;                // lock to manipulate this structure.

    LONG ReferenceCount;                // number of references to this object.
    LONG SpecialRefCount;               // controls freeing of the link.

    //
    // information about the remote hardware this link is talking to.
    //

    BOOLEAN Loopback;                   // TRUE if this is a loopback link.
    UCHAR LoopbackDestinationIndex;    // if Loopback, the index.

    HARDWARE_ADDRESS HardwareAddress;   // hardware address of remote.
    ULARGE_INTEGER MagicAddress;        // numerical representation of the
                                        // hardware address used for quick
                                        // comparisons
    UCHAR Header[MAX_MAC_HEADER_LENGTH]; // a place to stick a prebuilt packet
                                         // header.
    ULONG HeaderLength;                 // length of Header for this link

    //
    // Vital conditions surrounding the data link connnection.
    //

    ULONG MaxFrameSize;                 // maximum size of NetBIOS frame, MAC
                                        // dependent.

    //
    // Connections associated with this link. We keep a simple list of
    // connections because it's unlikely we'll get more than a few connections
    // on a given link (we're assuming that the server or redir will be the
    // biggest user of the net in the vast majority of environments). We've
    // made the link lookup be via a splay tree, which vastly speeds the
    // process of getting to the proper link; as long as there are only a few
    // connections, the connection lookup will be fast. If this becomes a
    // problem down the road, we can make this connection list be a splay tree
    // also.
    //

    LIST_ENTRY ConnectionDatabase;
    ULONG ActiveConnectionCount;        // # connections in above list.

    //
    // The following fields are used to maintain state about this link.
    // One other field is implicit-- the address of this object is the
    // ConnectionContext value as described in the PDI spec.
    //

    ULONG Flags;                        // attributes of the link.
    ULONG DeferredFlags;                // when on the deferred queue.
    ULONG State;                        // link state variable.

    //
    // Send-side state.
    //

    ULONG PacketsSent;                  // number of packets sent.
    ULONG PacketsResent;                // number of packets resent.
    UCHAR SendState;                    // send-side state variable.
    UCHAR NextSend;                     // next N(S) we should send.
    UCHAR LastAckReceived;              // last N(R) we received.
    UCHAR SendWindowSize;               // current send window size.
    UCHAR PrevWindowSize;               // size last time we dropped a frame.
    UCHAR WindowsUntilIncrease;         // how many windows until size increases.
    UCHAR SendRetries;                  // number of retries left/this checkpoint.
    UCHAR ConsecutiveLastPacketLost;    // consecutive windows with last packet dropped.
    ULONG NdisSendsInProgress;          // >0 if sends queued to NdisSendQueue.
    LIST_ENTRY NdisSendQueue;           // queue of sends to pass to NdisSend.
    LIST_ENTRY WackQ;                   // sent packets waiting LLC acks.

    BOOLEAN OnDeferredRrQueue;
    LIST_ENTRY DeferredRrLinkage;

    //
    // Receive-side state.
    //

    ULONG PacketsReceived;              // number of packets received.
    UCHAR ReceiveState;                 // receive-side state variable.
    UCHAR NextReceive;                  // next expected N(S) we should receive.
    UCHAR LastAckSent;                  // last N(R) we sent.
    UCHAR ReceiveWindowSize;            // current receive window size.
    BOOLEAN RespondToPoll;              // remote guy is polling-- we must final.
    BOOLEAN ResendingPackets;           // ResendLlcPackets in progress
    BOOLEAN LinkBusy;                   // received RNR (really send-side state).

    //
    // Timer, used to determine delay and throughput.
    //

    ULONG Delay;                        // an NT time, but only LowPart is saved.
    LARGE_INTEGER Throughput;

    //
    // These are counters needed by ADAPTER_STATUS queries.
    //

    USHORT FrmrsReceived;
    USHORT FrmrsTransmitted;
    USHORT ErrorIFramesReceived;
    USHORT ErrorIFramesTransmitted;
    USHORT AbortedTransmissions;
    USHORT BuffersNotAvailable;
    ULONG SuccessfulTransmits;
    ULONG SuccessfulReceives;
    USHORT T1Expirations;
    USHORT TiExpirations;

    //
    // Timeout state.  There is one kernel timer for this transport that is set
    // to go off at regular intervals.  This timer increments the current time,
    // which is then used to compare against the timer queues. The timer queues
    // are ordered, so whenever the first element is not expired, the rest of
    // the queue is not expired. This allows us to have hundreds of timers
    // running with very little system overhead.
    // A value of 0 indicates that the timer is not active.
    //

    ULONG T1;                           // retry timer.
    ULONG T2;                           // delayed ack timer.
    ULONG Ti;                           // inactivity timer.
    BOOLEAN OnShortList;                // TRUE if link is in ShortList
    BOOLEAN OnLongList;                 // TRUE if link is in LongList
    LIST_ENTRY ShortList;               // list of links waiting t1 or t2
    LIST_ENTRY LongList;                // list of links waiting ti

    LIST_ENTRY PurgeList;

    //
    // This counter is used to keep track of whether there are
    // any "connectors" (connections initiated by this side) on
    // this link. If there are none, and we are on an easily
    // disconnected link, then we handle the inactivity timeout
    // differently.
    //

    LONG NumberOfConnectors;

    //
    // BaseT1Timeout is the current T1 timeout computed based on
    // the response to previous poll frames. T1Timeout is the
    // value to be used for the next T1, and will generally be
    // based on BaseT1Timeout but may be more if T1 is backing
    // off. T2Timeout and TiTimeout are independent of these.
    //

    ULONG BaseT1Timeout;                // Timeout value for T1, << 16.
    ULONG CurrentT1Timeout;             // Current backed-off T1 timeout.
    ULONG MinimumBaseT1Timeout;         // Minimum value, based on link speed.
    ULONG BaseT1RecalcThreshhold;       // Only recalc BaseT1 on frames > this.
    ULONG CurrentPollRetransmits;       // Current retransmits waiting for final.
    BOOLEAN ThroughputAccurate;         // Is the throughput on this link accurate?
    BOOLEAN CurrentT1Backoff;           // the last poll frame had retransmits
    BOOLEAN CurrentPollOutstanding;     // Check that we have a poll outstanding.
    LARGE_INTEGER CurrentTimerStart;    // Time that current timing was begun.
    ULONG CurrentPollSize;              // Size of current poll packet.
    ULONG T2Timeout;                    // Timeout value for T2.
    ULONG TiTimeout;                    // Timeout value for Ti.
    ULONG LlcRetries;                   // total retry count for this link.
    ULONG MaxWindowSize;                // maximum send window size.
    ULONG TiStartPacketsReceived;       // PacketsReceived when Ti was started.

    //
    // Adaptive window algorithm state.
    //

    ULONG WindowErrors;                 // # retransmissions/this adaptive run.
    UCHAR BestWindowSize;               // our best window from experience.
    UCHAR WorstWindowSize;              // our worst window from experience.

    //
    // Keep track of remotes that never poll so we can send
    // an RR every two frames.
    //

    BOOLEAN RemoteNoPoll;               // We think remote doesn't poll
    UCHAR ConsecutiveIFrames;           // number received since polling

#if DBG
    UCHAR CreatePacketFailures;         // consecutive failures
#endif

    LIST_ENTRY DeferredList;            // for threading on deferred list

    struct _DEVICE_CONTEXT *Provider;
    PKSPIN_LOCK ProviderInterlock;      // &Provider->Interlock

#if DBG
  LIST_ENTRY GlobalLinkage;
  ULONG TotalReferences;
  ULONG TotalDereferences;
  ULONG NextRefLoc;
  struct {
     PVOID Caller;
     PVOID CallersCaller;
  } History[LINK_HISTORY_LENGTH];
  BOOLEAN Destroyed;
#endif

#if PKT_LOG
    PKT_LOG_QUE   LastNRecvs;
    PKT_LOG_QUE   LastNSends;
#endif // PKT_LOG

} TP_LINK, *PTP_LINK;

#if DBG
extern KSPIN_LOCK NbfGlobalHistoryLock;
extern LIST_ENTRY NbfGlobalLinkList;
#define StoreLinkHistory(_link,_ref) {                                      \
    KIRQL oldIrql;                                                          \
    KeAcquireSpinLock (&NbfGlobalHistoryLock, &oldIrql);                    \
    if ((_link)->Destroyed) {                                               \
        DbgPrint ("link touched after being destroyed 0x%lx\n", (_link));   \
        DbgBreakPoint();                                                    \
    }                                                                       \
    RtlGetCallersAddress(                                                   \
        &(_link)->History[(_link)->NextRefLoc].Caller,                      \
        &(_link)->History[(_link)->NextRefLoc].CallersCaller                \
        );                                                                  \
    if ((_ref)) {                                                           \
        (_link)->TotalReferences++;                                         \
    } else {                                                                \
        (_link)->TotalDereferences++;                                       \
        (_link)->History[(_link)->NextRefLoc].Caller =                      \
           (PVOID)((ULONG_PTR)(_link)->History[(_link)->NextRefLoc].Caller | 1);\
    }                                                                       \
    if (++(_link)->NextRefLoc == LINK_HISTORY_LENGTH) {                     \
        (_link)->NextRefLoc = 0;                                            \
    }                                                                       \
    KeReleaseSpinLock (&NbfGlobalHistoryLock, oldIrql);                     \
}
#endif

#define LINK_FLAGS_JUMP_START       0x00000040 // run adaptive alg/every sent window.
#define LINK_FLAGS_LOCAL_DISC       0x00000080 // link was stopped locally.

//
// deferred flags, used for processing at timer tick if needed
//

#define LINK_FLAGS_DEFERRED_DELETE  0x00010000  // delete at next opportunity
#define LINK_FLAGS_DEFERRED_ADD     0x00020000  // add to splay tree, next opportunity
#define LINK_FLAGS_DEFERRED_MASK    0x00030000  // (LINK_FLAGS_DEFERRED_DELETE | LINK_FLAGS_DEFERRED_ADD)

#define LINK_STATE_ADM          1       // asynchronous disconnected mode.
#define LINK_STATE_READY        2       // asynchronous balanced mode extended.
#define LINK_STATE_BUSY         3       // all link buffers are busy, sent RNR
#define LINK_STATE_CONNECTING   4       // waiting SABME response (UA-r/f).
#define LINK_STATE_W_POLL       5       // waiting initial checkpoint.
#define LINK_STATE_W_FINAL      6       // waiting final from initial checkpoint.
#define LINK_STATE_W_DISC_RSP   7       // waiting disconnect response.

#define SEND_STATE_DOWN         0       // asynchronous disconnected mode.
#define SEND_STATE_READY        1       // completely ready to send.
#define SEND_STATE_REJECTING    2       // other guy is rejecting.
#define SEND_STATE_CHECKPOINTING 3      // we're checkpointing (can't send data).

#define RECEIVE_STATE_DOWN      0       // asynchronous disconnected mode.
#define RECEIVE_STATE_READY     1       // we're ready to receive.
#define RECEIVE_STATE_REJECTING 2       // we're rejecting.


//
// This structure defines the DEVICE_OBJECT and its extension allocated at
// the time the transport provider creates its device object.
//

#if DBG
#define DCREF_CREATION    0
#define DCREF_ADDRESS     1
#define DCREF_CONNECTION  2
#define DCREF_LINK        3
#define DCREF_QUERY_INFO  4
#define DCREF_SCAN_TIMER  5
#define DCREF_REQUEST     6
#define DCREF_TEMP_USE    7

#define NUMBER_OF_DCREFS 8
#endif


typedef struct _NBF_POOL_LIST_DESC {
    NDIS_HANDLE PoolHandle;
    USHORT   NumElements;
    USHORT   TotalElements;
    struct _NBF_POOL_LIST_DESC *Next;
} NBF_POOL_LIST_DESC, *PNBF_POOL_LIST_DESC;

typedef struct _DEVICE_CONTEXT {

    DEVICE_OBJECT DeviceObject;         // the I/O system's device object.

#if DBG
    ULONG RefTypes[NUMBER_OF_DCREFS];
#endif

    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure

    LIST_ENTRY Linkage;                   // links them on NbfDeviceList;

    KSPIN_LOCK Interlock;               // GLOBAL spinlock for reference count.
                                        //  (used in ExInterlockedXxx calls)
                                        
    LONG ReferenceCount;                // activity count/this provider.
    LONG CreateRefRemoved;              // has unload or unbind been called ?

    //
    // This protects the LoopbackQueue.
    //

    KSPIN_LOCK LoopbackSpinLock;

    //
    // The queue of packets waiting to be looped back.
    //

    LIST_ENTRY LoopbackQueue;

    //
    // These two links are used for loopback.
    //

    PTP_LINK LoopbackLinks[2];

    //
    // This buffer is used for loopback indications; a
    // contiguous piece is copied into it. It is allocated
    // (of size NBF_MAX_LOOPBACK_LOOKAHEAD) when one of
    // the LoopbackLinks become non-NULL.
    //

    PUCHAR LookaheadContiguous;

    //
    // This holds the length of the header in the currently
    // indicating loopback packet.
    //

    ULONG LoopbackHeaderLength;

    //
    // Used for processing the loopback queue.
    //

    KDPC LoopbackDpc;

    //
    // Determines if a LoopbackDpc is in progress.
    //

    BOOLEAN LoopbackInProgress;

    //
    // Determines if a WanDelayedDpc is in progress.
    //

    BOOLEAN WanThreadQueued;

    //
    // Used for momentarily delaying WAN packetizing to
    // allow RR's to be received.
    //

    WORK_QUEUE_ITEM WanDelayedQueueItem;

    //
    // The queue of FIND.NAME requests waiting to be processed.
    //

    LIST_ENTRY FindNameQueue;

    //
    // The queue of STATUS.QUERY requests waiting to be processed.
    //

    LIST_ENTRY StatusQueryQueue;

    //
    // The queue of QUERY.INDICATION requests waiting to be completed.
    //

    LIST_ENTRY QueryIndicationQueue;

    //
    // The queue of DATAGRAM.INDICATION requests waiting to be completed.
    //

    LIST_ENTRY DatagramIndicationQueue;

    //
    // The queue of (currently receive only) IRPs waiting to complete.
    //

    LIST_ENTRY IrpCompletionQueue;

    //
    // This boolean is TRUE if either of the above two have ever
    // had anything on them.
    //

    BOOLEAN IndicationQueuesInUse;

    //
    // Following are protected by Global Device Context SpinLock
    //

    KSPIN_LOCK SpinLock;                // lock to manipulate this object.
                                        //  (used in KeAcquireSpinLock calls)

    //
    // the device context state, among open, closing
    //

    UCHAR State;

    //
    // Used when processing a STATUS_CLOSING indication.
    //

    WORK_QUEUE_ITEM StatusClosingQueueItem;

    //
    // The following queue holds free TP_LINK objects available for allocation.
    //

    LIST_ENTRY LinkPool;

    //
    // These counters keep track of resources uses by TP_LINK objects.
    //

    ULONG LinkAllocated;
    ULONG LinkInitAllocated;
    ULONG LinkMaxAllocated;
    ULONG LinkInUse;
    ULONG LinkMaxInUse;
    ULONG LinkExhausted;
    ULONG LinkTotal;
    ULONG LinkSamples;


    //
    // The following queue holds free TP_ADDRESS objects available for allocation.
    //

    LIST_ENTRY AddressPool;

    //
    // These counters keep track of resources uses by TP_ADDRESS objects.
    //

    ULONG AddressAllocated;
    ULONG AddressInitAllocated;
    ULONG AddressMaxAllocated;
    ULONG AddressInUse;
    ULONG AddressMaxInUse;
    ULONG AddressExhausted;
    ULONG AddressTotal;
    ULONG AddressSamples;


    //
    // The following queue holds free TP_ADDRESS_FILE objects available for allocation.
    //

    LIST_ENTRY AddressFilePool;

    //
    // These counters keep track of resources uses by TP_ADDRESS_FILE objects.
    //

    ULONG AddressFileAllocated;
    ULONG AddressFileInitAllocated;
    ULONG AddressFileMaxAllocated;
    ULONG AddressFileInUse;
    ULONG AddressFileMaxInUse;
    ULONG AddressFileExhausted;
    ULONG AddressFileTotal;
    ULONG AddressFileSamples;


    //
    // The following queue holds free TP_CONNECTION objects available for allocation.
    //

    LIST_ENTRY ConnectionPool;

    //
    // These counters keep track of resources uses by TP_CONNECTION objects.
    //

    ULONG ConnectionAllocated;
    ULONG ConnectionInitAllocated;
    ULONG ConnectionMaxAllocated;
    ULONG ConnectionInUse;
    ULONG ConnectionMaxInUse;
    ULONG ConnectionExhausted;
    ULONG ConnectionTotal;
    ULONG ConnectionSamples;


    //
    // The following is a free list of TP_REQUEST blocks which have been
    // previously allocated and are available for use.
    //

    LIST_ENTRY RequestPool;             // free request block pool.

    //
    // These counters keep track of resources uses by TP_REQUEST objects.
    //

    ULONG RequestAllocated;
    ULONG RequestInitAllocated;
    ULONG RequestMaxAllocated;
    ULONG RequestInUse;
    ULONG RequestMaxInUse;
    ULONG RequestExhausted;
    ULONG RequestTotal;
    ULONG RequestSamples;


    //
    // The following list comprises a pool of UI NetBIOS frame headers
    // that are manipulated by the routines in FRAMESND.C.
    //

    LIST_ENTRY UIFramePool;             // free UI frames (TP_UI_FRAME objects).

    //
    // These counters keep track of resources uses by TP_UI_FRAME objects.
    //

    ULONG UIFrameLength;
    ULONG UIFrameHeaderLength;
    ULONG UIFrameAllocated;
    ULONG UIFrameInitAllocated;
    ULONG UIFrameExhausted;


    //
    // The following queue holds I-frame Send packets managed by PACKET.C.
    //

    SINGLE_LIST_ENTRY PacketPool;

    //
    // These counters keep track of resources uses by TP_PACKET objects.
    //

    ULONG PacketLength;
    ULONG PacketHeaderLength;
    ULONG PacketAllocated;
    ULONG PacketInitAllocated;
    ULONG PacketExhausted;


    //
    // The following queue holds RR-frame Send packets managed by PACKET.C.
    //

    SINGLE_LIST_ENTRY RrPacketPool;


    //
    // The following queue contains Receive packets
    //

    SINGLE_LIST_ENTRY ReceivePacketPool;

    //
    // These counters keep track of resources uses by NDIS_PACKET objects.
    //

    ULONG ReceivePacketAllocated;
    ULONG ReceivePacketInitAllocated;
    ULONG ReceivePacketExhausted;


    //
    // This queue contains pre-allocated receive buffers
    //

    SINGLE_LIST_ENTRY ReceiveBufferPool;

    //
    // These counters keep track of resources uses by TP_PACKET objects.
    //

    ULONG ReceiveBufferLength;
    ULONG ReceiveBufferAllocated;
    ULONG ReceiveBufferInitAllocated;
    ULONG ReceiveBufferExhausted;


    //
    // This holds the total memory allocated for the above structures.
    //

    ULONG MemoryUsage;
    ULONG MemoryLimit;


    //
    // The following field is a head of a list of TP_ADDRESS objects that
    // are defined for this transport provider.  To edit the list, you must
    // hold the spinlock of the device context object.
    //

    LIST_ENTRY AddressDatabase;        // list of defined transport addresses.

    //
    // The following field is the pointer to the root of the splay tree of
    // links that are associated with this Device Context. You must hold the
    // LinkSpinLock to modify this list. You must set the LinkTreeSemaphore
    // to traverse this list without modifying it. Note that all modify
    // operations are deferred to timer(DPC)-time operations.
    //

    KSPIN_LOCK LinkSpinLock;            // protects these values
    PTP_LINK LastLink;                  // the last link found in the tree.
    PRTL_SPLAY_LINKS LinkTreeRoot;      // pointer to root of the tree.
    ULONG LinkTreeElements;             // how many elements in the tree
    LIST_ENTRY LinkDeferred;            // Deferred operations on links.
    ULONG DeferredNotSatisfied;         // how many times we've come to the
                                        // deferred well and not gotten it clear.

    //
    // The following queue holds connections which are waiting on available
    // packets.  As each new packet becomes available, a connection is removed
    // from this queue and placed on the PacketizeQueue.
    //

    LIST_ENTRY PacketWaitQueue;         // queue of packet-starved connections.
    LIST_ENTRY PacketizeQueue;          // queue of ready-to-packetize connections.

    //
    // The following queue holds connections which are waiting to send
    // a piggyback ack. In that case the CONNECTION_FLAGS_DEFERRED_ACK
    // bit in DeferredFlags will be set.
    //

    LIST_ENTRY DataAckQueue;

    //
    // The following queue holds links which are waiting to send an
    // RR frame because the remote they are talking to never polls.
    //

    LIST_ENTRY DeferredRrQueue;

    //
    // Used to track when the queue has changed.
    //

    BOOLEAN DataAckQueueChanged;

    //
    // When this hits thirty seconds we checked for stalled connections.
    //

    USHORT StalledConnectionCount;

    //
    // This queue contains receives that are in progress
    //

    LIST_ENTRY ReceiveInProgress;

    //
    // NDIS fields
    //

    //
    // following is used to keep adapter information.
    //

    NDIS_HANDLE NdisBindingHandle;

    //
    // The following fields are used for talking to NDIS. They keep information
    // for the NDIS wrapper to use when determining what pool to use for
    // allocating storage.
    //

    KSPIN_LOCK SendPoolListLock;            // protects these values
    PNBF_POOL_LIST_DESC SendPacketPoolDesc;
    KSPIN_LOCK RcvPoolListLock;            // protects these values
    PNBF_POOL_LIST_DESC ReceivePacketPoolDesc;
    NDIS_HANDLE NdisBufferPool;

    //
    // These are kept around for error logging.
    //

    ULONG SendPacketPoolSize;
    ULONG ReceivePacketPoolSize;
    ULONG MaxRequests;
    ULONG MaxLinks;
    ULONG MaxConnections;
    ULONG MaxAddressFiles;
    ULONG MaxAddresses;
    PWCHAR DeviceName;
    ULONG DeviceNameLength;

    //
    // This is the Mac type we must build the packet header for and know the
    // offsets for.
    //

    NBF_NDIS_IDENTIFICATION MacInfo;    // MAC type and other info
    ULONG MaxReceivePacketSize;         // does not include the MAC header
    ULONG MaxSendPacketSize;            // includes the MAC header
    ULONG CurSendPacketSize;            // may be smaller for async
    USHORT RecommendedSendWindow;       // used for Async lines
    BOOLEAN EasilyDisconnected;         // TRUE over wireless nets.

    //
    // some MAC addresses we use in the transport
    //

    HARDWARE_ADDRESS LocalAddress;      // our local hardware address.
    HARDWARE_ADDRESS NetBIOSAddress;    // NetBIOS functional address, used for TR

    //
    // The reserved Netbios address; consists of 10 zeroes
    // followed by LocalAddress;
    //

    UCHAR ReservedNetBIOSAddress[NETBIOS_NAME_LENGTH];
    HANDLE TdiDeviceHandle;
    HANDLE ReservedAddressHandle;

    //
    // These are used while initializing the MAC driver.
    //

    KEVENT NdisRequestEvent;            // used for pended requests.
    NDIS_STATUS NdisRequestStatus;      // records request status.

    //
    // This next field maintains a unique number which can next be assigned
    // as a connection identifier.  It is incremented by one each time a
    // value is allocated.
    //

    USHORT UniqueIdentifier;            // starts at 0, wraps around 2^16-1.

    //
    // This contains the next unique indentified to use as
    // the FsContext in the file object associated with an
    // open of the control channel.
    //

    USHORT ControlChannelIdentifier;

    //
    // The following fields are used to implement the lightweight timer
    // system in the protocol provider.  Each TP_LINK object in the device
    // context's LinkDatabase contains three lightweight timers that are
    // serviced by a DPC routine, which receives control by kernel functions.
    // There is one kernel timer for this transport that is set
    // to go off at regular intervals.  This timer increments the Absolute time,
    // which is then used to compare against the timer queues. The timer queues
    // are ordered, so whenever the first element is not expired, the rest of
    // the queue is not expired. This allows us to have hundreds of timers
    // running with very low system overhead.
    // A value of -1 indicates that the timer is not active.
    //

    ULONG TimerState;                   // See the timer Macros in nbfprocs.h

    LARGE_INTEGER ShortTimerStart;      // when the short timer was set.
    KDPC ShortTimerSystemDpc;           // kernel DPC object, short timer.
    KTIMER ShortSystemTimer;            // kernel timer object, short timer.
    ULONG ShortAbsoluteTime;            // up-count timer ticks, short timer.
    ULONG AdaptivePurge;                // absolute time of next purge (short timer).
    KDPC LongTimerSystemDpc;            // kernel DPC object, long timer.
    KTIMER LongSystemTimer;             // kernel timer object, long timer.
    ULONG LongAbsoluteTime;             // up-count timer ticks, long timer.
    union _DC_ACTIVE {
      struct _DC_INDIVIDUAL {
        BOOLEAN ShortListActive;        // ShortList is not empty.
        BOOLEAN DataAckQueueActive;     // DataAckQueue is not empty.
        BOOLEAN LinkDeferredActive;     // LinkDeferred is not empty.
      } i;
      ULONG AnyActive;                  // used to check all four at once.
    } a;
    BOOLEAN ProcessingShortTimer;       // TRUE if we are in ScanShortTimer.
    KSPIN_LOCK TimerSpinLock;           // lock for following timer queues
    LIST_ENTRY ShortList;               // list of links waiting T1 or T2
    LIST_ENTRY LongList;                // list of links waiting Ti expire
    LIST_ENTRY PurgeList;               // list of links waiting LAT expire

    //
    // These fields are used on "easily disconnected" adapters.
    // Every time the long timer expires, it notes if there has
    // been any multicast traffic received. If there has not been,
    // it increments LongTimeoutsWithoutMulticast. Activity is
    // recorded by incrementing MulticastPacket when MC
    // packets are received, and zeroing it when the long timer
    // expires.
    //

    ULONG LongTimeoutsWithoutMulticast; // LongTimer timeouts since traffic.
    ULONG MulticastPacketCount;         // How many MC packets rcved, this timeout.

    //
    // This information is used to keep track of the speed of
    // the underlying medium.
    //

    ULONG MediumSpeed;                    // in units of 100 bytes/sec
    BOOLEAN MediumSpeedAccurate;          // if FALSE, can't use the link.

    //
    // This is TRUE if we are on a UP system.
    //

    BOOLEAN UniProcessor;

    //
    // Configuration information on how soon we should send
    // an unasked for RR with a non-polling remote.
    //

    UCHAR MaxConsecutiveIFrames;

    //
    // This is configuration information controlling the default
    // value of timers and retry counts.
    //

    ULONG DefaultT1Timeout;
    ULONG MinimumT1Timeout;
    ULONG DefaultT2Timeout;
    ULONG DefaultTiTimeout;
    ULONG LlcRetries;
    ULONG LlcMaxWindowSize;
    ULONG NameQueryRetries;
    ULONG NameQueryTimeout;
    ULONG AddNameQueryRetries;
    ULONG AddNameQueryTimeout;
    ULONG GeneralRetries;
    ULONG GeneralTimeout;
    ULONG MinimumSendWindowLimit;   // how low we can lock a connection's window

    //
    // Counters for most of the statistics that NBF maintains;
    // some of these are kept elsewhere. Including the structure
    // itself wastes a little space but ensures that the alignment
    // inside the structure is correct.
    //

    TDI_PROVIDER_STATISTICS Statistics;

    //
    // These are "temporary" versions of the other counters.
    // During normal operations we update these, then during
    // the short timer expiration we update the real ones.
    //

    ULONG TempIFrameBytesSent;
    ULONG TempIFramesSent;
    ULONG TempIFrameBytesReceived;
    ULONG TempIFramesReceived;

    //
    // Some counters needed for Netbios adapter status.
    //

    ULONG TiExpirations;
    ULONG FrmrReceived;
    ULONG FrmrTransmitted;

    //
    // These are used to compute AverageSendWindow.
    //

    ULONG SendWindowTotal;
    ULONG SendWindowSamples;

    //
    // Counters for "active" time.
    //

    LARGE_INTEGER NbfStartTime;

    //
    // This resource guards access to the ShareAccess
    // and SecurityDescriptor fields in addresses.
    //

    ERESOURCE AddressResource;

    //
    // This array is used to keep track of which LSNs are
    // available for use by Netbios sessions. LSNs can be
    // re-used for sessions to unique names if they are on
    // different links, but must be committed beforehand
    // for group names. The maximum value that can fit in
    // an array element is defined by LSN_TABLE_MAX.
    //

    UCHAR LsnTable[NETBIOS_SESSION_LIMIT+1];

    //
    // This is where we start looking in LsnTable for an
    // unused LSN. We cycle from 0-63 to prevent quick
    // down-and-up connections from getting funny data.
    //

    ULONG NextLsnStart;

    //
    // This array is used to quickly dismiss UI frames that
    // are not destined for us. The count is the number
    // of addresses with that first letter that are registered
    // on this device.
    //

    UCHAR AddressCounts[256];

    //
    // This is to hold the underlying PDO of the device so
    // that we can answer DEVICE_RELATION IRPs from above
    //

    PVOID PnPContext;

    //
    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    //

    TDI_PROVIDER_INFO Information;      // information about this provider.

    PTP_VARIABLE NetmanVariables;       // list of network managable variables.

    //
    // The magic bullet is a packet that is sent under certain debugging
    // conditions. This allows the transport to signal packet capture devices
    // that a particular condiion has been met. This packet has the current
    // devicecontext as the source, and 0x04 in every other byte of the packet.
    //

    UCHAR MagicBullet[32];              //

} DEVICE_CONTEXT, *PDEVICE_CONTEXT;

//
// device context state definitions
//

#define DEVICECONTEXT_STATE_OPENING  0x00
#define DEVICECONTEXT_STATE_OPEN     0x01
#define DEVICECONTEXT_STATE_DOWN     0x02
#define DEVICECONTEXT_STATE_STOPPING 0x03

//
// device context PnP Flags
//

// #define DEVICECONTEXT_FLAGS_REMOVING     0x01
// #define DEVICECONTEXT_FLAGS_POWERING_OFF 0x02
// #define DEVICECONTEXT_FLAGS_POWERED_DOWN 0x04

//
// This is the maximum value that can go in an element
// of LsnTable (should be 0xff if they are UCHARs,
// 0xffff for USHORTs, etc.).
//

#define LSN_TABLE_MAX     0xff


#define MAGIC_BULLET_FOOD 0x04


//
// These are constants for the LoopbackLinks elements.
// The distinctions are arbitrary; the listener link
// is the one established from ProcessNameQuery, and
// the connector link is the one established from
// ProcessNameRecognized.
//

#define LISTENER_LINK                0
#define CONNECTOR_LINK               1


//
// This structure defines the packet object, used to represent a DLC I-frame
// in some portion of its lifetime.  The PACKET.C module contains routines
// to manage this object.
//

typedef struct _TP_PACKET {
    CSHORT Type;                          // type of this structure
    USHORT Size;                          // size of this structure
    PNDIS_PACKET NdisPacket;            // ptr to owning Ndis Packet
    ULONG NdisIFrameLength;             // Length of NdisPacket

    LIST_ENTRY Linkage;                 // used to chain packets together.
    LONG ReferenceCount;                // activity count/this packet.
    BOOLEAN PacketSent;                 // packet completed by NDIS.
    BOOLEAN PacketNoNdisBuffer;         // chain on this packet was not allocated.

    UCHAR Action;                      // what to do when we're acked.
    BOOLEAN PacketizeConnection;       // restart packetizing when completed.

    PVOID Owner;                        // ptr to owning connection or IrpSp.
    PTP_LINK Link;                      // ptr to link it was sent on.
    PDEVICE_CONTEXT Provider;           // The owner of this packet.
    PKSPIN_LOCK ProviderInterlock;      // &Provider->Interlock.

    UCHAR Header[1];                    // the MAC, DLC, and NBF headers

} TP_PACKET, *PTP_PACKET;


//
// The following values are placed in the Action field in the TP_PACKET
// object to indicate what action, if any, should be taken when the packet
// is destroyed.
//

#define PACKET_ACTION_NULL        0     // no special action should be taken.
#define PACKET_ACTION_IRP_SP      1     // Owner is an IRP_SP, deref when done.
#define PACKET_ACTION_CONNECTION  2     // Owner is a TP_CONNECTION, deref when done.
#define PACKET_ACTION_END         3     // shutdown session (sent SESSION_END).
#define PACKET_ACTION_RR          5     // packet is an RR, put back in RR pool.

//
// Types used to hold information in the send and receive NDIS packets
//

typedef struct _SEND_PACKET_TAG {
    LIST_ENTRY Linkage;         // used for threading on loopback queue
    BOOLEAN OnLoopbackQueue;    // TRUE if the packet is on a loopback queue
    UCHAR LoopbackLinkIndex;    // index of other link for loopback packets
    USHORT Type;                // identifier for packet type
    PVOID Frame;                // backpointer to owning NBF structure
    PVOID Owner;                // backpointer for owning nbf construct
                                //  (like address, devicecontext, etc)
     } SEND_PACKET_TAG, *PSEND_PACKET_TAG;

//
// Packet types used in send completion
//

#define TYPE_I_FRAME        1
#define TYPE_UI_FRAME       2
#define TYPE_ADDRESS_FRAME 3

//
// LoopbackLinkIndex values.
//

#define LOOPBACK_TO_LISTENER    0
#define LOOPBACK_TO_CONNECTOR   1
#define LOOPBACK_UI_FRAME       2

//
// receive packet used to hold information about this receive
//

typedef struct _RECEIVE_PACKET_TAG {
    SINGLE_LIST_ENTRY Linkage;  // used for threading in pool
    PTP_CONNECTION Connection;  // connection this receive is occuring on
    ULONG BytesToTransfer;      // for I-frame, bytes in this transfer
    UCHAR PacketType;           // the type of packet we're processing
    BOOLEAN AllocatedNdisBuffer; // did we allocate our own NDIS_BUFFERs
    BOOLEAN EndOfMessage;       // does this receive complete the message
    BOOLEAN CompleteReceive;    // complete the receive after TransferData?
    BOOLEAN TransferDataPended; // TRUE if TransferData returned PENDING
    } RECEIVE_PACKET_TAG, *PRECEIVE_PACKET_TAG;

#define TYPE_AT_INDICATE     1
#define TYPE_AT_COMPLETE     2
#define TYPE_STATUS_RESPONSE 3

//
// receive buffer descriptor (built in memory at the beginning of the buffer)
//

typedef struct _BUFFER_TAG {
    LIST_ENTRY Linkage;         // thread in pool and on receive queue
    NDIS_STATUS NdisStatus;     // completion status for send
    PTP_ADDRESS Address;        // the address this datagram is for.
    PNDIS_BUFFER NdisBuffer;    // describes the rest of the buffer
    ULONG Length;               // the length of the buffer
    UCHAR Buffer[1];            // the actual storage (accessed through the NDIS_BUFFER)
    } BUFFER_TAG, *PBUFFER_TAG;

//
// Structure used to interpret the TransportReserved part in the NET_PNP_EVENT
//

typedef struct _NET_PNP_EVENT_RESERVED {
    PWORK_QUEUE_ITEM PnPWorkItem;
    PDEVICE_CONTEXT DeviceContext;
} NET_PNP_EVENT_RESERVED, *PNET_PNP_EVENT_RESERVED;

#endif // def _NBFTYPES_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\nbfprocs.h ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    nbfprocs.h

Abstract:

    This header file defines private functions for the NT NBF transport
    provider.

Author:

    David Beaver (dbeaver) 1-July-1991

Revision History:

--*/

#ifndef _NBFPROCS_
#define _NBFPROCS_

//
// MACROS.
//
//
// Debugging aids
//

//
//  VOID
//  IF_NBFDBG(
//      IN PSZ Message
//      );
//

#if DBG
#define IF_NBFDBG(flags) \
    if (NbfDebug & (flags))
#else
#define IF_NBFDBG(flags) \
    if (0)
#endif

//
//  VOID
//  PANIC(
//      IN PSZ Message
//      );
//

#if DBG
#define PANIC(Msg) \
    DbgPrint ((Msg))
#else
#define PANIC(Msg)
#endif


//
// These are define to allow DbgPrints that disappear when
// DBG is 0.
//

#if DBG
#define NbfPrint0(fmt) DbgPrint(fmt)
#define NbfPrint1(fmt,v0) DbgPrint(fmt,v0)
#define NbfPrint2(fmt,v0,v1) DbgPrint(fmt,v0,v1)
#define NbfPrint3(fmt,v0,v1,v2) DbgPrint(fmt,v0,v1,v2)
#define NbfPrint4(fmt,v0,v1,v2,v3) DbgPrint(fmt,v0,v1,v2,v3)
#define NbfPrint5(fmt,v0,v1,v2,v3,v4) DbgPrint(fmt,v0,v1,v2,v3,v4)
#define NbfPrint6(fmt,v0,v1,v2,v3,v4,v5) DbgPrint(fmt,v0,v1,v2,v3,v4,v5)
#else
#define NbfPrint0(fmt)
#define NbfPrint1(fmt,v0)
#define NbfPrint2(fmt,v0,v1)
#define NbfPrint3(fmt,v0,v1,v2)
#define NbfPrint4(fmt,v0,v1,v2,v3)
#define NbfPrint5(fmt,v0,v1,v2,v3,v4)
#define NbfPrint6(fmt,v0,v1,v2,v3,v4,v5)
#endif

//
// The REFCOUNTS message take up a lot of room, so make
// removing them easy.
//

#if 1
#define IF_REFDBG IF_NBFDBG (NBF_DEBUG_REFCOUNTS)
#else
#define IF_REFDBG if (0)
#endif

#if DBG
#define NbfReferenceLink( Reason, Link, Type)\
    if ((Link)->Destroyed) { \
        DbgPrint("NBF: Attempt to reference destroyed link %lx\n", Link); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG {   \
        DbgPrint ("RefL %x: %s %s, %ld : %ld\n", Link, Reason, __FILE__, __LINE__, (Link)->ReferenceCount);\
    }\
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Link)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefLink (Link)

#define NbfDereferenceLink(Reason, Link, Type)\
    if ((Link)->Destroyed) { \
        DbgPrint("NBF: Attempt to dereference destroyed link %lx\n", Link); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG { \
        DbgPrint ("DeRefL %x: %s %s, %ld : %ld\n", Link, Reason, __FILE__, __LINE__, (Link)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Link)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefLink (Link)

#define NbfDereferenceLinkMacro(Reason, Link, Type)\
    NbfDereferenceLink(Reason, Link, Type)

#define NbfReferenceLinkSpecial( Reason, Link, Type)\
    if ((Link)->Destroyed) { \
        DbgPrint("NBF: Attempt to special reference destroyed link %lx\n", Link); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG {   \
        DbgPrint ("RefLS %x: %s %s, %ld : %ld\n", Link, Reason, __FILE__, __LINE__, (Link)->SpecialRefCount);\
    }\
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Link)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefLinkSpecial (Link)

#define NbfDereferenceLinkSpecial(Reason, Link, Type)\
    if ((Link)->Destroyed) { \
        DbgPrint("NBF: Attempt to special dereference destroyed link %lx\n", Link); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG { \
        DbgPrint ("DeRefLS %x: %s %s, %ld : %ld\n", Link, Reason, __FILE__, __LINE__, (Link)->SpecialRefCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Link)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefLinkSpecial (Link)

#define NbfReferenceConnection(Reason, Connection, Type)\
    if ((Connection)->Destroyed) { \
        DbgPrint("NBF: Attempt to reference destroyed conn %lx\n", Connection); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG { \
        DbgPrint ("RefC %x: %s %s, %ld : %ld\n", Connection, Reason, __FILE__, __LINE__, (Connection)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Connection)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefConnection (Connection)

#define NbfDereferenceConnection(Reason, Connection, Type)\
    if ((Connection)->Destroyed) { \
        DbgPrint("NBF: Attempt to dereference destroyed conn %lx\n", Connection); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG { \
        DbgPrint ("DeRefC %x: %s %s, %ld : %ld\n", Connection, Reason, __FILE__, __LINE__, (Connection)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)&((Connection)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefConnection (Connection)

#define NbfDereferenceConnectionMacro(Reason, Connection, Type)\
    NbfDereferenceConnection(Reason, Connection, Type)

#define NbfDereferenceConnectionSpecial(Reason, Connection, Type)\
    IF_REFDBG { \
        DbgPrint ("DeRefCL %x: %s %s, %ld : %ld\n", Connection, Reason, __FILE__, __LINE__, (Connection)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)&((Connection)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefConnectionSpecial (Connection)

#define NbfReferenceRequest( Reason, Request, Type)\
    if ((Request)->Destroyed) { \
        DbgPrint("NBF: Attempt to reference destroyed req %lx\n", Request); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG {   \
        DbgPrint ("RefR %x: %s %s, %ld : %ld\n", Request, Reason, __FILE__, __LINE__, (Request)->ReferenceCount);}\
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Request)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefRequest (Request)

#define NbfDereferenceRequest(Reason, Request, Type)\
    if ((Request)->Destroyed) { \
        DbgPrint("NBF: Attempt to dereference destroyed req %lx\n", Request); \
        DbgBreakPoint(); \
    } \
    IF_REFDBG { \
        DbgPrint ("DeRefR %x: %s %s, %ld : %ld\n", Request, Reason, __FILE__, __LINE__, (Request)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Request)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefRequest (Request)

#define NbfReferenceSendIrp( Reason, IrpSp, Type)\
    IF_REFDBG {   \
        DbgPrint ("RefSI %x: %s %s, %ld : %ld\n", IrpSp, Reason, __FILE__, __LINE__, IRP_SEND_REFCOUNT(IrpSp));}\
    NbfRefSendIrp (IrpSp)

#define NbfDereferenceSendIrp(Reason, IrpSp, Type)\
    IF_REFDBG { \
        DbgPrint ("DeRefSI %x: %s %s, %ld : %ld\n", IrpSp, Reason, __FILE__, __LINE__, IRP_SEND_REFCOUNT(IrpSp));\
    } \
    NbfDerefSendIrp (IrpSp)

#define NbfReferenceReceiveIrpLocked( Reason, IrpSp, Type)\
    IF_REFDBG {   \
        DbgPrint ("RefRI %x: %s %s, %ld : %ld\n", IrpSp, Reason, __FILE__, __LINE__, IRP_RECEIVE_REFCOUNT(IrpSp));}\
    NbfRefReceiveIrpLocked (IrpSp)

#define NbfDereferenceReceiveIrp(Reason, IrpSp, Type)\
    IF_REFDBG { \
        DbgPrint ("DeRefRI %x: %s %s, %ld : %ld\n", IrpSp, Reason, __FILE__, __LINE__, IRP_RECEIVE_REFCOUNT(IrpSp));\
    } \
    NbfDerefReceiveIrp (IrpSp)

#define NbfDereferenceReceiveIrpLocked(Reason, IrpSp, Type)\
    IF_REFDBG { \
        DbgPrint ("DeRefRILocked %x: %s %s, %ld : %ld\n", IrpSp, Reason, __FILE__, __LINE__, IRP_RECEIVE_REFCOUNT(IrpSp));\
    } \
    NbfDerefReceiveIrpLocked (IrpSp)

#define NbfReferenceAddress( Reason, Address, Type)\
    IF_REFDBG {   \
        DbgPrint ("RefA %x: %s %s, %ld : %ld\n", Address, Reason, __FILE__, __LINE__, (Address)->ReferenceCount);}\
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Address)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefAddress (Address)

#define NbfDereferenceAddress(Reason, Address, Type)\
    IF_REFDBG { \
        DbgPrint ("DeRefA %x: %s %s, %ld : %ld\n", Address, Reason, __FILE__, __LINE__, (Address)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(Address)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefAddress (Address)

#define NbfReferenceDeviceContext( Reason, DeviceContext, Type)\
    if ((DeviceContext)->ReferenceCount == 0)     \
        DbgBreakPoint();                          \
    IF_REFDBG {   \
        DbgPrint ("RefDC %x: %s %s, %ld : %ld\n", DeviceContext, Reason, __FILE__, __LINE__, (DeviceContext)->ReferenceCount);}\
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(DeviceContext)->RefTypes[Type]), \
        1, \
        &NbfGlobalInterlock); \
    NbfRefDeviceContext (DeviceContext)

#define NbfDereferenceDeviceContext(Reason, DeviceContext, Type)\
    if ((DeviceContext)->ReferenceCount == 0)     \
        DbgBreakPoint();                          \
    IF_REFDBG { \
        DbgPrint ("DeRefDC %x: %s %s, %ld : %ld\n", DeviceContext, Reason, __FILE__, __LINE__, (DeviceContext)->ReferenceCount);\
    } \
    (VOID)ExInterlockedAddUlong ( \
        (PULONG)(&(DeviceContext)->RefTypes[Type]), \
        (ULONG)-1, \
        &NbfGlobalInterlock); \
    NbfDerefDeviceContext (DeviceContext)

#else
#if defined(NBF_UP)
#define NbfReferenceLink(Reason, Link, Type) \
    { \
        ULONG _ref; \
        _ref = ++(Link)->ReferenceCount; \
        if ( _ref == 0 ) { \
            NbfReferenceLinkSpecial ("first ref", (Link), LREF_SPECIAL_TEMP); \
        } \
    }
#else
#define NbfReferenceLink(Reason, Link, Type) \
    if (InterlockedIncrement( \
            &(Link)->ReferenceCount) == 0) { \
        NbfReferenceLinkSpecial ("first ref", (Link), LREF_SPECIAL_TEMP); \
    }
#endif

#define NbfDereferenceLink(Reason, Link, Type)\
    NbfDereferenceLinkMacro(Reason,Link,Type)

#if defined(NBF_UP)
#define NbfDereferenceLinkMacro(Reason, Link, Type){ \
    ULONG _ref; \
    _ref = --(Link)->ReferenceCount; \
    if (_ref < 0) { \
        NbfDisconnectLink (Link); \
        NbfDerefLinkSpecial (Link); \
    } \
}
#else
#define NbfDereferenceLinkMacro(Reason, Link, Type){ \
    if (InterlockedDecrement( \
            &(Link)->ReferenceCount) < 0) { \
        NbfDisconnectLink (Link); \
        NbfDerefLinkSpecial (Link); \
    } \
}
#endif

#define NbfReferenceLinkSpecial(Reason, Link, Type)\
    NbfRefLinkSpecial (Link)

#define NbfDereferenceLinkSpecial(Reason, Link, Type)\
    NbfDerefLinkSpecial (Link)

#define NbfReferenceConnection(Reason, Connection, Type)\
    if (((Connection)->ReferenceCount == -1) &&   \
        ((Connection)->SpecialRefCount == 0))     \
        DbgBreakPoint();                          \
                                                  \
    if (InterlockedIncrement( \
            &(Connection)->ReferenceCount) == 0) { \
        ExInterlockedAddUlong( \
            (PULONG)(&(Connection)->SpecialRefCount), \
            1, \
            (Connection)->ProviderInterlock); \
    }

#define NbfDereferenceConnection(Reason, Connection, Type)\
    if (((Connection)->ReferenceCount == -1) &&   \
        ((Connection)->SpecialRefCount == 0))     \
        DbgBreakPoint();                          \
                                                  \
    NbfDerefConnection (Connection)

#define NbfDereferenceConnectionMacro(Reason, Connection, Type){ \
    if (((Connection)->ReferenceCount == -1) &&   \
        ((Connection)->SpecialRefCount == 0))     \
        DbgBreakPoint();                          \
                                                  \
                                                  \
    if (InterlockedDecrement( \
            &(Connection)->ReferenceCount) < 0) { \
        if (NbfDisconnectFromLink (Connection, TRUE)) { \
            NbfIndicateDisconnect (Connection); \
        } \
        NbfDerefConnectionSpecial (Connection); \
    } \
}

#define NbfDereferenceConnectionSpecial(Reason, Connection, Type)\
    NbfDerefConnectionSpecial (Connection)

#define NbfReferenceRequest(Reason, Request, Type)\
    (VOID)InterlockedIncrement( \
        &(Request)->ReferenceCount)

#define NbfDereferenceRequest(Reason, Request, Type)\
    NbfDerefRequest (Request)

#define NbfReferenceSendIrp(Reason, IrpSp, Type)\
    (VOID)InterlockedIncrement( \
        &IRP_SEND_REFCOUNT(IrpSp))

#define NbfDereferenceSendIrp(Reason, IrpSp, Type) {\
    PIO_STACK_LOCATION _IrpSp = (IrpSp); \
    if (InterlockedDecrement( \
            &IRP_SEND_REFCOUNT(_IrpSp)) == 0) { \
        PIRP _Irp = IRP_SEND_IRP(_IrpSp); \
        IRP_SEND_REFCOUNT(_IrpSp) = 0; \
        IRP_SEND_IRP (_IrpSp) = NULL; \
        IoCompleteRequest (_Irp, IO_NETWORK_INCREMENT); \
    } \
}

#define NbfReferenceReceiveIrpLocked(Reason, IrpSp, Type)\
    ++IRP_RECEIVE_REFCOUNT(IrpSp)

#define NbfDereferenceReceiveIrp(Reason, IrpSp, Type)\
    NbfDerefReceiveIrp (IrpSp)

#define NbfDereferenceReceiveIrpLocked(Reason, IrpSp, Type) { \
    if (--IRP_RECEIVE_REFCOUNT(IrpSp) == 0) { \
        ExInterlockedInsertTailList( \
            &(IRP_DEVICE_CONTEXT(IrpSp)->IrpCompletionQueue), \
            &(IRP_RECEIVE_IRP(IrpSp))->Tail.Overlay.ListEntry, \
            &(IRP_DEVICE_CONTEXT(IrpSp)->Interlock)); \
    } \
}

#define NbfReferenceAddress(Reason, Address, Type)\
    if ((Address)->ReferenceCount <= 0){ DbgBreakPoint(); }\
    (VOID)InterlockedIncrement(&(Address)->ReferenceCount)

#define NbfDereferenceAddress(Reason, Address, Type)\
    if ((Address)->ReferenceCount <= 0){ DbgBreakPoint(); }\
    NbfDerefAddress (Address)

#define NbfReferenceDeviceContext(Reason, DeviceContext, Type)\
    if ((DeviceContext)->ReferenceCount == 0)                 \
        DbgBreakPoint();                                      \
    NbfRefDeviceContext (DeviceContext)

#define NbfDereferenceDeviceContext(Reason, DeviceContext, Type)\
    if ((DeviceContext)->ReferenceCount == 0)                   \
        DbgBreakPoint();                                        \
    NbfDerefDeviceContext (DeviceContext)

#define NbfReferencePacket(Packet) \
    (VOID)InterlockedIncrement(&(Packet)->ReferenceCount)

#define NbfDereferencePacket(Packet){ \
    if (InterlockedDecrement ( \
            &(Packet)->ReferenceCount) == 0) { \
        NbfDestroyPacket (Packet); \
    } \
}

#endif


//
// Error and statistics Macros
//


//  VOID
//  LogErrorToSystem(
//      NTSTATUS ErrorType,
//      PUCHAR ErrorDescription
//      )

/*++

Routine Description:

    This routine is called to log an error from the transport to the system.
    Errors that are of system interest should be logged using this interface.
    For now, this macro is defined trivially.

Arguments:

    ErrorType - The error type, a conventional NT status

    ErrorDescription - A pointer to a string describing the error.

Return Value:

    none.

--*/

#if DBG
#define LogErrorToSystem( ErrorType, ErrorDescription)                    \
            DbgPrint ("Logging error: File: %s Line: %ld \n Description: %s\n",__FILE__, __LINE__, ErrorDescription)
#else
#define LogErrorToSystem( ErrorType, ErrorDescription)
#endif


//
// Routines in TIMER.C (lightweight timer system package).
// Note that all the start and stop routines for the timers assume that you
// have the link spinlock when you call them!
// Note also that, with the latest revisions, the timer system now works by
// putting those links that have timers running on a list of links to be looked
// at for each clock tick. This list is ordered, with the most recently inserted
// elements at the tail of the list. Note further that anything already on the
// is moved to the end of the list if the timer is restarted; thus, the list
// order is preserved.
//

VOID
NbfStartShortTimer(
    IN PDEVICE_CONTEXT DeviceContext
    );

VOID
NbfInitializeTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    );

VOID
NbfStopTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    );


VOID
StartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    );

VOID
StartT2(
    IN PTP_LINK Link
    );

VOID
StartTi(
    IN PTP_LINK Link
    );

#if DBG

VOID
StopT1(
    IN PTP_LINK Link
    );

VOID
StopT2(
    IN PTP_LINK Link
    );

VOID
StopTi(
    IN PTP_LINK Link
    );

#else

#define StopT1(_Link) \
    { \
        (_Link)->CurrentPollOutstanding = FALSE; \
        (_Link)->T1 = 0; \
    }

#define StopT2(_Link) \
    { \
        (_Link)->ConsecutiveIFrames = 0; \
        (_Link)->T2 = 0; \
    }

#define StopTi(_Link) \
    (_Link)->Ti = 0;

#endif


//
// These functions may become macros once they are finished.
//

ULONG
GetTimerInterval(
    IN PTP_LINK Link
    );

VOID
BackoffCurrentT1Timeout(
    IN PTP_LINK Link
    );

VOID
UpdateBaseT1Timeout(
    IN PTP_LINK Link
    );

VOID
CancelT1Timeout(
    IN PTP_LINK Link
    );

VOID
UpdateDelayAndThroughput(
    IN PTP_LINK Link,
    IN ULONG TimerInterval
    );

VOID
FakeStartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    );

VOID
FakeUpdateBaseT1Timeout(
    IN PTP_LINK Link
    );

//
// Timer Macros - these are make sure that no timers are
// executing after we finish call to NbfStopTimerSystem
//
// State Descriptions -
//
// If TimerState is
//      <  TIMERS_ENABLED       -   Multiple ENABLE_TIMERS happened,
//                                  Will be corrected in an instant
//
//      =  TIMERS_ENABLED       -   ENABLE_TIMERS done but no timers
//                                  that have gone through START_TIMER
//                                  but not yet executed a LEAVE_TIMER
//
//      >  TIMERS_ENABLED &&
//      <  TIMERS_DISABLED      -   ENABLE_TIMERS done and num timers =
//                                  (TimerInitialized - TIMERS_ENABLED)
//                                  that have gone through START_TIMER
//                                  but not yet executed a LEAVE_TIMER
//
//      = TIMERS_DISABLED       -   DISABLE_TIMERS done and no timers
//                                  executing timer code at this pt
//                                  [This is also the initial state]
//
//      > TIMERS_DISABLED &&
//      < TIMERS_DISABLED + TIMERS_RANGE
//                              -   DISABLE_TIMERS done and num timers =
//                                  (TimerInitialized - TIMERS_ENABLED)
//                                  that have gone through START_TIMER
//                                  but not yet executed a LEAVE_TIMER
//
//      >= TIMERS_DISABLED + TIMERS_RANGE
//                              -   Multiple DISABLE_TIMERS happened,
//                                  Will be corrected in an instant
//
//  Allow basically TIMER_RANGE = 2^24 timers 
//  (and 2^8 / 2 simultaneous stops or starts)
//

#if DBG_TIMER
#define DbgTimer DbgPrint
#else
#define DbgTimer
#endif

#define TIMERS_ENABLED      0x08000000
#define TIMERS_DISABLED     0x09000000
#define TIMERS_RANGE_ADD    0x01000000 /* TIMERS_DISABLED - TIMERS_ENABLED */
#define TIMERS_RANGE_SUB    0xFF000000 /* TIMERS_ENABLED - TIMERS_DISABLED */

#define INITIALIZE_TIMER_STATE(DeviceContext)                               \
        DbgTimer("*--------------- Timers State Initialized ---------*\n"); \
        /* Initial state is set to timers disabled */                       \
        DeviceContext->TimerState = TIMERS_DISABLED;                        \

#define TIMERS_INITIALIZED(DeviceContext)                                   \
        (DeviceContext->TimerState == TIMERS_DISABLED)                      \

#define ENABLE_TIMERS(DeviceContext)                                        \
    {                                                                       \
        ULONG Count;                                                        \
                                                                            \
        DbgTimer("*--------------- Enabling Timers ------------------*\n"); \
        Count= InterlockedExchangeAdd(&DeviceContext->TimerState,           \
                                      TIMERS_RANGE_SUB);                    \
        DbgTimer("Count = %08x, TimerState = %08x\n", Count,                \
                    DeviceContext->TimerState);                             \
        if (Count < TIMERS_ENABLED)                                         \
        {                                                                   \
        DbgTimer("*--------------- Timers Already Enabled -----------*\n"); \
            /* We have already enabled the timers */                        \
            InterlockedExchangeAdd(&DeviceContext->TimerState,              \
                                   TIMERS_RANGE_ADD);                       \
        DbgTimer("Count = %08x, TimerState = %08x\n", Count,                \
                    DeviceContext->TimerState);                             \
        }                                                                   \
        DbgTimer("*--------------- Enabling Timers Done -------------*\n"); \
    }                                                                       \

#define DISABLE_TIMERS(DeviceContext)                                       \
    {                                                                       \
        ULONG Count;                                                        \
                                                                            \
        DbgTimer("*--------------- Disabling Timers -----------------*\n"); \
        Count= InterlockedExchangeAdd(&DeviceContext->TimerState,           \
                                      TIMERS_RANGE_ADD);                    \
        DbgTimer("Count = %08x, TimerState = %08x\n", Count,                \
                    DeviceContext->TimerState);                             \
        if (Count >= TIMERS_DISABLED)                                       \
        {                                                                   \
        DbgTimer("*--------------- Timers Already Disabled ----------*\n"); \
            /* We have already disabled the timers */                       \
            InterlockedExchangeAdd(&DeviceContext->TimerState,              \
                                   TIMERS_RANGE_SUB);                       \
        DbgTimer("Count = %08x, TimerState = %08x\n", Count,                \
                    DeviceContext->TimerState);                             \
        }                                                                   \
                                                                            \
        /* Loop until we have zero timers active */                         \
        while (*((ULONG volatile *)&DeviceContext->TimerState)!=TIMERS_DISABLED)\
            DbgTimer("Number of timers active = %08x\n",                    \
                      DeviceContext->TimerState                             \
                         - TIMERS_DISABLED);                                \
        DbgTimer("*--------------- Disabling Timers Done ------------*\n"); \
    }                                                                       \

#define START_TIMER(DeviceContext, TimerId, Timer, DueTime, Dpc)            \
        /*DbgTimer("*---------- Entering Timer %d ---------*\n", TimerId);*/\
        if (InterlockedIncrement(&DeviceContext->TimerState) <              \
                TIMERS_DISABLED)                                            \
        {                                                                   \
            KeSetTimer(Timer, DueTime, Dpc);                                \
        }                                                                   \
        else                                                                \
        {                                                                   \
            /* Timers disabled - get out and reset */                       \
            NbfDereferenceDeviceContext("Timers disabled",                  \
                                         DeviceContext,                     \
                                         DCREF_SCAN_TIMER);                 \
            LEAVE_TIMER(DeviceContext, TimerId);                            \
        }                                                                   \
        /*DbgTimer("*---------- Entering Done  %d ---------*\n", TimerId);*/\

#define LEAVE_TIMER(DeviceContext, TimerId)                                 \
        /* Get out and adjust the time count */                             \
        /*DbgTimer("*---------- Leaving Timer %d ---------*\n", TimerId);*/ \
        InterlockedDecrement(&DeviceContext->TimerState);                   \
        /*DbgTimer("*---------- Leaving Done  %d ---------*\n", TimerId);*/ \


// Basic timer types (just for debugging)
#define LONG_TIMER          0
#define SHORT_TIMER         1


//
// These macros are used to create and destroy packets, due
// to the allocation or deallocation of structure which
// need them.
//

#define NbfAddUIFrame(DeviceContext) { \
    PTP_UI_FRAME _UIFrame; \
    NbfAllocateUIFrame ((DeviceContext), &_UIFrame); \
    if (_UIFrame != NULL) { \
        ExInterlockedInsertTailList( \
            &(DeviceContext)->UIFramePool, \
            &_UIFrame->Linkage, \
            &(DeviceContext)->Interlock); \
    } \
}

#define NbfRemoveUIFrame(DeviceContext) { \
    PLIST_ENTRY p; \
    if (DeviceContext->UIFrameAllocated > DeviceContext->UIFrameInitAllocated) { \
        p = ExInterlockedRemoveHeadList( \
            &(DeviceContext)->UIFramePool, \
            &(DeviceContext)->Interlock); \
        if (p != NULL) { \
            NbfDeallocateUIFrame((DeviceContext), \
                (PTP_UI_FRAME)CONTAINING_RECORD(p, TP_UI_FRAME, Linkage)); \
        } \
    } \
}


#define NbfAddSendPacket(DeviceContext) { \
    PTP_PACKET _SendPacket; \
    NbfAllocateSendPacket ((DeviceContext), &_SendPacket); \
    if (_SendPacket != NULL) { \
        ExInterlockedPushEntryList( \
            &(DeviceContext)->PacketPool, \
            (PSINGLE_LIST_ENTRY)&_SendPacket->Linkage, \
            &(DeviceContext)->Interlock); \
    } \
}

#define NbfRemoveSendPacket(DeviceContext) { \
    PSINGLE_LIST_ENTRY s; \
    if (DeviceContext->PacketAllocated > DeviceContext->PacketInitAllocated) { \
        s = ExInterlockedPopEntryList( \
            &(DeviceContext)->PacketPool, \
            &(DeviceContext)->Interlock); \
        if (s != NULL) { \
            NbfDeallocateSendPacket((DeviceContext), \
                (PTP_PACKET)CONTAINING_RECORD(s, TP_PACKET, Linkage)); \
        } \
    } \
}


#define NbfAddReceivePacket(DeviceContext) { \
    if (!(DeviceContext)->MacInfo.SingleReceive) { \
        PNDIS_PACKET _ReceivePacket; \
        NbfAllocateReceivePacket ((DeviceContext), &_ReceivePacket); \
        if (_ReceivePacket != NULL) { \
            ExInterlockedPushEntryList( \
                &(DeviceContext)->ReceivePacketPool, \
                &((PRECEIVE_PACKET_TAG)_ReceivePacket->ProtocolReserved)->Linkage, \
                &(DeviceContext)->Interlock); \
        } \
    } \
}

#define NbfRemoveReceivePacket(DeviceContext) { \
    PSINGLE_LIST_ENTRY s; \
    if (DeviceContext->ReceivePacketAllocated > DeviceContext->ReceivePacketInitAllocated) { \
        s = ExInterlockedPopEntryList( \
            &(DeviceContext)->ReceivePacketPool, \
            &(DeviceContext)->Interlock); \
        if (s != NULL) { \
            NbfDeallocateReceivePacket((DeviceContext), \
                (PNDIS_PACKET)CONTAINING_RECORD(s, NDIS_PACKET, ProtocolReserved[0])); \
        } \
    } \
}


#define NbfAddReceiveBuffer(DeviceContext) { \
    if (!(DeviceContext)->MacInfo.SingleReceive) { \
        PBUFFER_TAG _ReceiveBuffer; \
        NbfAllocateReceiveBuffer ((DeviceContext), &_ReceiveBuffer); \
        if (_ReceiveBuffer != NULL) { \
            ExInterlockedPushEntryList( \
                &(DeviceContext)->ReceiveBufferPool, \
                (PSINGLE_LIST_ENTRY)&_ReceiveBuffer->Linkage, \
                &(DeviceContext)->Interlock); \
        } \
    } \
}

#define NbfRemoveReceiveBuffer(DeviceContext) { \
    PSINGLE_LIST_ENTRY s; \
    if (DeviceContext->ReceiveBufferAllocated > DeviceContext->ReceiveBufferInitAllocated) { \
        s = ExInterlockedPopEntryList( \
            &(DeviceContext)->ReceiveBufferPool, \
            &(DeviceContext)->Interlock); \
        if (s != NULL) { \
            NbfDeallocateReceiveBuffer(DeviceContext, \
                (PBUFFER_TAG)CONTAINING_RECORD(s, BUFFER_TAG, Linkage)); \
        } \
    } \
}


//
// These routines are used to maintain counters.
//

#define INCREMENT_COUNTER(_DeviceContext,_Field) \
    ++(_DeviceContext)->Statistics._Field

#define DECREMENT_COUNTER(_DeviceContext,_Field) \
    --(_DeviceContext)->Statistics._Field

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((_LargeInteger), (ULONG)(_Ulong))



//
// Routines in PACKET.C (TP_PACKET object manager).
//

VOID
NbfAllocateUIFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_UI_FRAME *TransportUIFrame
    );

VOID
NbfAllocateSendPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_PACKET *TransportSendPacket
    );

VOID
NbfAllocateReceivePacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PNDIS_PACKET *TransportReceivePacket
    );

VOID
NbfAllocateReceiveBuffer(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PBUFFER_TAG *TransportReceiveBuffer
    );

VOID
NbfDeallocateUIFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_UI_FRAME TransportUIFrame
    );

VOID
NbfDeallocateSendPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_PACKET TransportSendPacket
    );

VOID
NbfDeallocateReceivePacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_PACKET TransportReceivePacket
    );

VOID
NbfDeallocateReceiveBuffer(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PBUFFER_TAG TransportReceiveBuffer
    );

NTSTATUS
NbfCreatePacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link,
    OUT PTP_PACKET *Packet
    );

NTSTATUS
NbfCreateRrPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link,
    OUT PTP_PACKET *Packet
    );

VOID
NbfDestroyPacket(
    IN PTP_PACKET Packet
    );
VOID 
NbfGrowSendPacketPool(
    IN PDEVICE_CONTEXT DeviceContext
    );

#if DBG
VOID
NbfReferencePacket(
    IN PTP_PACKET Packet
    );

VOID
NbfDereferencePacket(
    IN PTP_PACKET Packet
    );
#endif

VOID
NbfWaitPacket(
    IN PTP_CONNECTION Connection,
    IN ULONG Flags
    );

#if DBG
#define MAGIC 1
extern BOOLEAN NbfEnableMagic;
#else
#define MAGIC 0
#endif

#if MAGIC
VOID
NbfSendMagicBullet (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    );
#endif

//
// Routines in RCVENG.C (Receive engine).
//

VOID
AwakenReceive(
    IN PTP_CONNECTION Connection
    );

VOID
ActivateReceive(
    IN PTP_CONNECTION Connection
    );

VOID
CompleteReceive (
    IN PTP_CONNECTION Connection,
    IN BOOLEAN EndOfMessage,
    IN ULONG BytesTransferred
    );

VOID
NbfCancelReceive(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NbfCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Routines in SEND.C (Receive engine).
//

NTSTATUS
NbfTdiSend(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiSendDatagram(
    IN PIRP Irp
    );

//
// Routines in SENDENG.C (Send engine).
//

#if DBG

VOID
InitializeSend(
    PTP_CONNECTION Connection
    );

#else

// See SENDENG.C for the fully-commented description of InitializeSend.

#define InitializeSend(_conn_) {                                              \
    PIRP _irp_;                                                               \
    (_conn_)->SendState = CONNECTION_SENDSTATE_PACKETIZE;                     \
    _irp_ = CONTAINING_RECORD ((_conn_)->SendQueue.Flink,                     \
                               IRP,                                           \
                               Tail.Overlay.ListEntry);                       \
    (_conn_)->FirstSendIrp = (_conn_)->sp.CurrentSendIrp = _irp_;             \
    (_conn_)->FirstSendMdl = (_conn_)->sp.CurrentSendMdl =                    \
                             _irp_->MdlAddress;                               \
    (_conn_)->FirstSendByteOffset = (_conn_)->sp.SendByteOffset = 0;          \
    (_conn_)->sp.MessageBytesSent = 0;                                        \
    (_conn_)->CurrentSendLength =                                             \
                    IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(_irp_));     \
    (_conn_)->StallCount = 0;                                                 \
    (_conn_)->StallBytesSent = 0;                                             \
    if ((_conn_)->NetbiosHeader.ResponseCorrelator == 0xffff) {               \
        (_conn_)->NetbiosHeader.ResponseCorrelator = 1;                       \
    } else {                                                                  \
        ++((_conn_)->NetbiosHeader.ResponseCorrelator);                       \
    }                                                                         \
}

#endif

// See SENDENG.C for the fully-commented description of
// StartPacketizingConnection. On a free build this is a
// macro for speed.

#if DBG

VOID
StartPacketizingConnection(
    PTP_CONNECTION Connection,
    IN BOOLEAN Immediate
    );

#else

#define StartPacketizingConnection(_conn_,_immed_) {  \
    PDEVICE_CONTEXT _devctx_;                                                 \
    _devctx_ = (_conn_)->Provider;                                            \
    if (((_conn_)->SendState == CONNECTION_SENDSTATE_PACKETIZE) &&            \
        !((_conn_)->Flags & CONNECTION_FLAGS_PACKETIZE)) {                    \
        (_conn_)->Flags |= CONNECTION_FLAGS_PACKETIZE;                        \
        if (!(_immed_)) {                                                     \
            NbfReferenceConnection("Packetize",                               \
                                   (_conn_),                                  \
                                   CREF_PACKETIZE_QUEUE);                     \
        }                                                                     \
        ExInterlockedInsertTailList (&_devctx_->PacketizeQueue,               \
                                     &(_conn_)->PacketizeLinkage,             \
                                     &_devctx_->SpinLock);                    \
        RELEASE_DPC_SPIN_LOCK ((_conn_)->LinkSpinLock);                       \
    } else {                                                                  \
        RELEASE_DPC_SPIN_LOCK ((_conn_)->LinkSpinLock);                       \
        if (_immed_) {                                                        \
            NbfDereferenceConnection("temp TdiSend", (_conn_), CREF_BY_ID);   \
        }                                                                     \
    }                                                                         \
    if (_immed_) {                                                            \
        PacketizeConnections (_devctx_);                                      \
    }                                                                         \
}

#endif

VOID
PacketizeConnections(
    IN PDEVICE_CONTEXT DeviceContext
    );

VOID
PacketizeSend(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN Direct
    );

BOOLEAN
ResendLlcPackets(
    IN PTP_LINK Link,
    IN UCHAR AckSequenceNumber,
    IN BOOLEAN Resend
    );

VOID
CompleteSend(
    IN PTP_CONNECTION Connection,
    IN USHORT Correlator
    );

VOID
FailSend(
    IN PTP_CONNECTION Connection,
    IN NTSTATUS RequestStatus,
    IN BOOLEAN StopConnection
    );

VOID
ReframeSend(
    IN PTP_CONNECTION Connection,
    IN ULONG BytesReceived
    );

VOID
NbfCancelSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SendOnePacket(
    IN PTP_CONNECTION Connection,
    IN PTP_PACKET Packet,
    IN BOOLEAN ForceAck,
    OUT PBOOLEAN LinkCheckpoint OPTIONAL
    );

VOID
SendControlPacket(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    );

VOID
NbfNdisSend(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    );

VOID
RestartLinkTraffic(
    IN PTP_LINK Link
    );

VOID
NbfSendCompletionHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

NTSTATUS
BuildBufferChainFromMdlChain (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PMDL CurrentMdl,
    IN ULONG ByteOffset,
    IN ULONG DesiredLength,
    OUT PNDIS_BUFFER *Destination,
    OUT PMDL *NewCurrentMdl,
    OUT ULONG *NewByteOffset,
    OUT ULONG *TrueLength
    );

//
// Routines in DEVCTX.C (TP_DEVCTX object manager).
//

VOID
NbfRefDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    );

VOID
NbfDerefDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    );

NTSTATUS
NbfCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext
    );

VOID
NbfDestroyDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    );


//
// Routines in ADDRESS.C (TP_ADDRESS object manager).
//

#if DBG
VOID
NbfRefAddress(
    IN PTP_ADDRESS Address
    );
#endif

VOID
NbfDerefAddress(
    IN PTP_ADDRESS Address
    );

VOID
NbfAllocateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS_FILE *TransportAddressFile
    );

VOID
NbfDeallocateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS_FILE TransportAddressFile
    );

NTSTATUS
NbfCreateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS_FILE * AddressFile
    );

VOID
NbfReferenceAddressFile(
    IN PTP_ADDRESS_FILE AddressFile
    );

VOID
NbfDereferenceAddressFile(
    IN PTP_ADDRESS_FILE AddressFile
    );

VOID
NbfDestroyAddress(
    IN PVOID Parameter
    );

NTSTATUS
NbfOpenAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbfCloseAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
NbfStopAddress(
    IN PTP_ADDRESS Address
    );

VOID
NbfRegisterAddress(
    IN PTP_ADDRESS Address
    );

BOOLEAN
NbfMatchNetbiosAddress(
    IN PTP_ADDRESS Address,
    IN UCHAR NameType,
    IN PUCHAR NetBIOSName
    );

VOID
NbfAllocateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS *TransportAddress
    );

VOID
NbfDeallocateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS TransportAddress
    );

NTSTATUS
NbfCreateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNBF_NETBIOS_ADDRESS NetworkName,
    OUT PTP_ADDRESS *Address
    );

PTP_ADDRESS
NbfLookupAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNBF_NETBIOS_ADDRESS NetworkName
    );

PTP_CONNECTION
NbfLookupRemoteName(
    IN PTP_ADDRESS Address,
    IN PUCHAR RemoteName,
    IN UCHAR RemoteSessionNumber
    );

NTSTATUS
NbfStopAddressFile(
    IN PTP_ADDRESS_FILE AddressFile,
    IN PTP_ADDRESS Address
    );

VOID
AddressTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

TDI_ADDRESS_NETBIOS *
NbfParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN BOOLEAN BroadcastAddressOk
);

BOOLEAN
NbfValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
);

NTSTATUS
NbfVerifyAddressObject (
    IN PTP_ADDRESS_FILE AddressFile
    );

NTSTATUS
NbfSendDatagramsOnAddress(
    PTP_ADDRESS Address
    );

//
// Routines in CONNECT.C.
//

NTSTATUS
NbfTdiAccept(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiConnect(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiDisconnect(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiDisassociateAddress (
    IN PIRP Irp
    );

NTSTATUS
NbfTdiAssociateAddress(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiListen(
    IN PIRP Irp
    );

NTSTATUS
NbfOpenConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbfCloseConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

//
//
// Routines in CONNOBJ.C (TP_CONNECTION object manager).
//

#if DBG
VOID
NbfRefConnection(
    IN PTP_CONNECTION TransportConnection
    );
#endif

VOID
NbfDerefConnection(
    IN PTP_CONNECTION TransportConnection
    );

VOID
NbfDerefConnectionSpecial(
    IN PTP_CONNECTION TransportConnection
    );

VOID
NbfClearConnectionLsn(
    IN PTP_CONNECTION TransportConnection
    );

VOID
NbfStopConnection(
    IN PTP_CONNECTION TransportConnection,
    IN NTSTATUS Status
    );

VOID
NbfCancelConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NbfStartConnectionTimer(
    IN PTP_CONNECTION TransportConnection,
    IN PKDEFERRED_ROUTINE TimeoutFunction,
    IN ULONG WaitTime
    );

PTP_CONNECTION
NbfLookupListeningConnection(
    IN PTP_ADDRESS Address,
    IN PUCHAR RemoteName
    );

PTP_CONNECTION
NbfLookupConnectingConnection(
    IN PTP_ADDRESS Address
    );

VOID
NbfAllocateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_CONNECTION *TransportConnection
    );

VOID
NbfDeallocateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_CONNECTION TransportConnection
    );

NTSTATUS
NbfCreateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_CONNECTION *TransportConnection
    );

PTP_CONNECTION
NbfLookupConnectionById(
    IN PTP_ADDRESS Address,
    IN USHORT ConnectionId
    );

PTP_CONNECTION
NbfLookupConnectionByContext(
    IN PTP_ADDRESS Address,
    IN CONNECTION_CONTEXT ConnectionContext
    );

#if 0
VOID
NbfWaitConnectionOnLink(
    IN PTP_CONNECTION Connection,
    IN ULONG Flags
    );
#endif

VOID
ConnectionEstablishmentTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
NbfVerifyConnectionObject (
    IN PTP_CONNECTION Connection
    );

NTSTATUS
NbfIndicateDisconnect(
    IN PTP_CONNECTION TransportConnection
    );

//
// Routines in INFO.C (QUERY_INFO manager).
//

NTSTATUS
NbfTdiQueryInformation(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );

NTSTATUS
NbfTdiSetInformation(
    IN PIRP Irp
    );

VOID
NbfSendQueryFindName(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST Request
    );

NTSTATUS
NbfProcessQueryNameRecognized(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Packet,
    PNBF_HDR_CONNECTIONLESS UiFrame
    );

VOID
NbfSendStatusQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST Request,
    IN PHARDWARE_ADDRESS DestinationAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    );

NTSTATUS
NbfProcessStatusResponse(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PNBF_HDR_CONNECTIONLESS UiFrame,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    );

NTSTATUS
NbfProcessStatusQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address OPTIONAL,
    IN PNBF_HDR_CONNECTIONLESS UiFrame,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    );

//
// Routines in EVENT.C.
//

NTSTATUS
NbfTdiSetEventHandler(
    IN PIRP Irp
    );

//
// Routines in REQUEST.C (TP_REQUEST object manager).
//


VOID
TdiRequestTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#if DBG
VOID
NbfRefRequest(
    IN PTP_REQUEST Request
    );
#endif

VOID
NbfDerefRequest(
    IN PTP_REQUEST Request
    );

VOID
NbfCompleteRequest(
    IN PTP_REQUEST Request,
    IN NTSTATUS Status,
    IN ULONG Information
    );

#if DBG
VOID
NbfRefSendIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
NbfDerefSendIrp(
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
NbfCompleteSendIrp(
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    );

#if DBG
VOID
NbfRefReceiveIrpLocked(
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
NbfDerefReceiveIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

#if DBG
VOID
NbfDerefReceiveIrpLocked(
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
NbfCompleteReceiveIrp(
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    );

VOID
NbfAllocateRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_REQUEST *TransportRequest
    );

VOID
NbfDeallocateRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST TransportRequest
    );

NTSTATUS
NbfCreateRequest(
    IN PIRP Irp,
    IN PVOID Context,
    IN ULONG Flags,
    IN PMDL Buffer2,
    IN ULONG Buffer2Length,
    IN LARGE_INTEGER Timeout,
    OUT PTP_REQUEST * TpRequest
    );

//
// Routines in LINK.C (TP_LINK object manager).
//

NTSTATUS
NbfDestroyLink(
    IN PTP_LINK TransportLink
    );

VOID
NbfDisconnectLink(
    IN PTP_LINK Link
    );

#if DBG
VOID
NbfRefLink(
    IN PTP_LINK TransportLink
    );
#endif

VOID
NbfDerefLink(
    IN PTP_LINK TransportLink
    );

VOID
NbfRefLinkSpecial(
    IN PTP_LINK TransportLink
    );

VOID
NbfDerefLinkSpecial(
    IN PTP_LINK TransportLink
    );

VOID
NbfResetLink(
    IN PTP_LINK Link
    );

VOID
NbfStopLink(
    IN PTP_LINK Link
    );

VOID
NbfCompleteLink(
    IN PTP_LINK Link
    );

VOID
NbfActivateLink(
    IN PTP_LINK Link
    );

VOID
NbfWaitLink(
    IN PTP_LINK Link
    );

BOOLEAN
NbfDisconnectFromLink(
    IN PTP_CONNECTION TransportConnection,
    IN BOOLEAN VerifyReferenceCount
    );

NTSTATUS
NbfAssignGroupLsn(
    IN PTP_CONNECTION TransportConnection
    );

NTSTATUS
NbfConnectToLink(
    IN PTP_LINK Link,
    IN PTP_CONNECTION TransportConnection
    );

PTP_CONNECTION
NbfLookupPendingConnectOnLink(
    IN PTP_LINK Link
    );

PTP_CONNECTION
NbfLookupPendingListenOnLink(
    IN PTP_LINK Link
    );

VOID
NbfAllocateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_LINK *TransportLink
    );

VOID
NbfDeallocateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK TransportLink
    );

NTSTATUS
NbfCreateLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PHARDWARE_ADDRESS HardwareAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    IN USHORT LoopbackLinkIndex,
    OUT PTP_LINK *TransportLink
    );

VOID
NbfDumpLinkInfo (
    IN PTP_LINK Link
    );

//
// routines in linktree.c
//


NTSTATUS
NbfAddLinkToTree (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    );

NTSTATUS
NbfRemoveLinkFromTree(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    );

PTP_LINK
NbfFindLinkInTree(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Remote
    );

PTP_LINK
NbfFindLink(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PUCHAR Remote
    );

//
// Routines in DLC.C (LLC frame cracker, entrypoints from NDIS interface).
//

VOID
NbfInsertInLoopbackQueue (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_PACKET NdisPacket,
    IN UCHAR LinkIndex
    );

VOID
NbfProcessLoopbackQueue (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NDIS_STATUS
NbfReceiveIndication(
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize
    );

VOID
NbfGeneralReceiveHandler (
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PTP_LINK Link,
    IN PVOID HeaderBuffer,
    IN UINT PacketSize,
    IN PDLC_FRAME DlcHeader,
    IN UINT DlcSize,
    IN BOOLEAN Loopback
    );

VOID
NbfReceiveComplete (
    IN NDIS_HANDLE BindingContext
    );

VOID
NbfProcessWanDelayedQueue(
    IN PVOID Parameter
    );

VOID
NbfTransferDataComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    );


VOID
NbfTransferLoopbackData (
    OUT PNDIS_STATUS NdisStatus,
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer,
    IN PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred
    );


//
// Routines in UFRAMES.C, the UI-frame NBF frame processor.
//

NTSTATUS
NbfIndicateDatagram(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PUCHAR Dsdu,
    IN ULONG Length
    );

NTSTATUS
NbfProcessUi(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR Header,
    IN PUCHAR DlcHeader,
    IN ULONG DlcLength,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    OUT PTP_ADDRESS * DatagramAddress
    );

//
// Routines in IFRAMES.C, the I-frame NBF frame processor.
//

VOID
NbfAcknowledgeDataOnlyLast(
    IN PTP_CONNECTION Connection,
    IN ULONG MessageLength
    );

VOID
NbfProcessIIndicate(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PUCHAR DlcHeader,
    IN UINT DlcIndicatedLength,
    IN UINT DlcTotalLength,
    IN NDIS_HANDLE ReceiveContext,
    IN BOOLEAN Loopback
    );

NTSTATUS
ProcessIndicateData(
    IN PTP_CONNECTION Connection,
    IN PUCHAR DlcHeader,
    IN UINT DlcIndicatedLength,
    IN PUCHAR DataHeader,
    IN UINT DataTotalLength,
    IN NDIS_HANDLE ReceiveContext,
    IN BOOLEAN Last,
    IN BOOLEAN Loopback
    );

//
// Routines in RCV.C (data copying routines for receives).
//

NTSTATUS
NbfTdiReceive(
    IN PIRP Irp
    );

NTSTATUS
NbfTdiReceiveDatagram(
    IN PIRP Irp
    );

//
// Routines in FRAMESND.C, the UI-frame (non-link) shipper.
//

VOID
NbfSendNameQuery(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN SourceRoutingOptional
    );

VOID
NbfSendNameRecognized(
    IN PTP_ADDRESS Address,
    IN UCHAR LocalSessionNumber,        // LSN assigned to session.
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    );

VOID
NbfSendNameInConflict(
    IN PTP_ADDRESS Address,
    IN PUCHAR ConflictingName
    );

NTSTATUS
NbfSendAddNameQuery(
    IN PTP_ADDRESS Address
    );

VOID
NbfSendSessionInitialize(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendSessionConfirm(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendSessionEnd(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN Abort
    );

VOID
NbfSendNoReceive(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendReceiveContinue(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendReceiveOutstanding(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendDataAck(
    IN PTP_CONNECTION Connection
    );

VOID
NbfSendSabme(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendDisc(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendUa(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendDm(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendRr(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    );

#if 0

//
// These functions are not currently called, so they are commented
// out.
//

VOID
NbfSendRnr(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendTest(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PMDL Psdu
    );

VOID
NbfSendFrmr(
    IN PTP_LINK Link,
    IN BOOLEAN PollFinal
    );

#endif

VOID
NbfSendXid(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    );

VOID
NbfSendRej(
    IN PTP_LINK Link,
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal
    );

NTSTATUS
NbfCreateConnectionlessFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_UI_FRAME *OuterFrame
    );

VOID
NbfDestroyConnectionlessFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_UI_FRAME RawFrame
    );

VOID
NbfSendUIFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_UI_FRAME RawFrame,
    IN BOOLEAN Loopback
    );

VOID
NbfSendUIMdlFrame(
    IN PTP_ADDRESS Address
    );

VOID
NbfSendDatagramCompletion(
    IN PTP_ADDRESS Address,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

//
// Routines in FRAMECON.C, the NetBIOS Frames Protocol Frame Constructors.
// To understand the various constant parameters to these functions (such
// as special data1 & data2 values, see NBFCONST.H for details.
//

VOID
ConstructAddGroupNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN USHORT Correlator,               // correlator for ADD_NAME_RESPONSE.
    IN PNAME GroupName                  // NetBIOS group name to be added.
    );

VOID
ConstructAddNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN USHORT Correlator,               // correlator for ADD_NAME_RESPONSE.
    IN PNAME Name                       // NetBIOS name to be added.
    );

VOID
ConstructNameInConflict(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME ConflictingName,           // NetBIOS name that is conflicting.
    IN PNAME SendingPermanentName       // NetBIOS permanent node name of sender.
    );

VOID
ConstructStatusQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR RequestType,               // type of request, defined below.
    IN USHORT BufferLength,             // length of user's status buffer.
    IN USHORT Correlator,               // correlator for STATUS_RESPONSE.
    IN PNAME ReceiverName,              // NetBIOS name of receiver.
    IN PNAME SendingPermanentName       // NetBIOS permanent node name of sender.
    );

VOID
ConstructTerminateTrace(
    IN PNBF_HDR_CONNECTIONLESS RawFrame // frame buffer to format.
    );

VOID
ConstructDatagram(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME ReceiverName,              // NetBIOS name of receiver.
    IN PNAME SenderName                 // NetBIOS name of sender.
    );

VOID
ConstructDatagramBroadcast(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN PNAME SenderName                 // NetBIOS name of sender.
    );

VOID
ConstructNameQuery(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN UCHAR LocalSessionNumber,        // LSN assigned to session (0=FIND_NAME).
    IN USHORT Correlator,               // correlator in NAME_RECOGNIZED.
    IN PNAME SenderName,                // NetBIOS name of sender.
    IN PNAME ReceiverName               // NetBIOS name of sender.
    );

VOID
ConstructAddNameResponse(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN USHORT Correlator,               // correlator from ADD_[GROUP_]NAME_QUERY.
    IN PNAME Name                       // NetBIOS name being responded to.
    );

VOID
ConstructNameRecognized(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR NameType,                  // type of name.
    IN UCHAR LocalSessionNumber,        // LSN assigned to session.
    IN USHORT NameQueryCorrelator,      // correlator from NAME_QUERY.
    IN USHORT Correlator,               // correlator expected from next response.
    IN PNAME SenderName,                // NetBIOS name of sender.
    IN PNAME ReceiverName               // NetBIOS name of receiver.
    );

VOID
ConstructStatusResponse(
    IN PNBF_HDR_CONNECTIONLESS RawFrame,// frame buffer to format.
    IN UCHAR RequestType,               // type of request, defined below.
    IN BOOLEAN Truncated,               // data is truncated.
    IN BOOLEAN DataOverflow,            // too much data for user's buffer.
    IN USHORT DataLength,               // length of data sent.
    IN USHORT Correlator,               // correlator from STATUS_QUERY.
    IN PNAME ReceivingPermanentName,    // NetBIOS permanent node name of receiver.
    IN PNAME SenderName                 // NetBIOS name of sender.
    );

VOID
ConstructDataAck(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Correlator,               // correlator from DATA_ONLY_LAST.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructDataOnlyLast(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN BOOLEAN Resynched,               // TRUE if we are resynching.
    IN USHORT Correlator,               // correlator for RECEIVE_CONTINUE.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructSessionConfirm(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN UCHAR Options,                   // bitflag options, defined below.
    IN USHORT MaximumUserBufferSize,    // max size of user frame on session.
    IN USHORT Correlator,               // correlator from SESSION_INITIALIZE.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructSessionEnd(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Reason,                   // reason for termination, defined below.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructSessionInitialize(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN UCHAR Options,                   // bitflag options, defined below.
    IN USHORT MaximumUserBufferSize,    // max size of user frame on session.
    IN USHORT NameRecognizedCorrelator, // correlator from NAME_RECOGNIZED.
    IN USHORT Correlator,               // correlator for SESSION_CONFIRM.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructNoReceive(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Options,                  // option bitflags, defined below.
    IN USHORT BytesAccepted,            // number of bytes accepted.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructReceiveOutstanding(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT BytesAccepted,            // number of bytes accepted.
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

VOID
ConstructReceiveContinue(
    IN PNBF_HDR_CONNECTION RawFrame,    // frame buffer to format.
    IN USHORT Correlator,               // correlator from DATA_FIRST_MIDDLE
    IN UCHAR LocalSessionNumber,        // session number of SENDER.
    IN UCHAR RemoteSessionNumber        // session number of RECEIVER.
    );

#if 0
VOID
ConstructSessionAlive(
    IN PNBF_HDR_CONNECTION RawFrame     // frame buffer to format.
    );
#endif

//
// Routines in nbfndis.c.
//

#if DBG
PUCHAR
NbfGetNdisStatus (
    IN NDIS_STATUS NdisStatus
    );
#endif

//
// Routines in nbfdrvr.c
//

VOID
NbfWriteResourceErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN ULONG BytesNeeded,
    IN ULONG ResourceId
    );

VOID
NbfWriteGeneralErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    );

VOID
NbfWriteOidErrorLog(
    IN PDEVICE_CONTEXT DeviceContext,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    );

VOID
NbfFreeResources(
    IN PDEVICE_CONTEXT DeviceContext
    );


extern
ULONG
NbfInitializeOneDeviceContext(
    OUT PNDIS_STATUS NdisStatus,
    IN PDRIVER_OBJECT DriverObject,
    IN PCONFIG_DATA NbfConfig,
    IN PUNICODE_STRING BindName,
    IN PUNICODE_STRING ExportName,
    IN PVOID SystemSpecific1,
    IN PVOID SystemSpecific2
    );


extern
VOID
NbfReInitializeDeviceContext(
    OUT PNDIS_STATUS NdisStatus,
    IN PDRIVER_OBJECT DriverObject,
    IN PCONFIG_DATA NbfConfig,
    IN PUNICODE_STRING BindName,
    IN PUNICODE_STRING ExportName,
    IN PVOID SystemSpecific1,
    IN PVOID SystemSpecific2
    );

//
// routines in nbfcnfg.c
//

NTSTATUS
NbfConfigureTransport (
    IN PUNICODE_STRING RegistryPath,
    IN PCONFIG_DATA * ConfigData
    );

NTSTATUS
NbfGetExportNameFromRegistry(
    IN  PUNICODE_STRING RegistryPath,
    IN  PUNICODE_STRING BindName,
    OUT PUNICODE_STRING ExportName
    );

//
// Routines in nbfndis.c
//

NTSTATUS
NbfRegisterProtocol (
    IN PUNICODE_STRING NameString
    );

VOID
NbfDeregisterProtocol (
    VOID
    );


NTSTATUS
NbfInitializeNdis (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PCONFIG_DATA ConfigInfo,
    IN PUNICODE_STRING AdapterString
    );

VOID
NbfCloseNdis (
    IN PDEVICE_CONTEXT DeviceContext
    );


//
// Routines in action.c
//

NTSTATUS
NbfTdiAction(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );

VOID
NbfActionQueryIndication(
     PDEVICE_CONTEXT DeviceContext,
     PNBF_HDR_CONNECTIONLESS UiFrame
     );

VOID
NbfActionDatagramIndication(
     PDEVICE_CONTEXT DeviceContext,
     PNBF_HDR_CONNECTIONLESS UiFrame,
     ULONG Length
     );

VOID
NbfStopControlChannel(
    IN PDEVICE_CONTEXT DeviceContext,
    IN USHORT ChannelIdentifier
    );


//
// Routines in nbfdebug.c
//

#if DBG

VOID
DisplayOneFrame(
    PTP_PACKET Packet
    );

VOID
NbfDisplayUIFrame(
    PTP_UI_FRAME OuterFrame
    );

VOID
NbfFormattedDump(
    PCHAR far_p,
    ULONG len
    );

#endif

//
// Routines in nbflog.c
//

#if PKT_LOG

VOID
NbfLogRcvPacket(
    PTP_CONNECTION  Connection,
    PTP_LINK        Link,
    PUCHAR          Header,
    UINT            TotalLength,
    UINT            AvailLength
    );

VOID
NbfLogSndPacket(
    PTP_LINK    Link,
    PTP_PACKET  Packet
    );

VOID
NbfLogIndPacket(
    PTP_CONNECTION  Connection,
    PUCHAR          Header,
    UINT            TotalLength,
    UINT            AvailLength,
    UINT            TakenLength,
    ULONG           Status
    );

#endif // PKT_LOG

#endif // def _NBFPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\packet.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    This module contains code that implements the TP_PACKET object, which
    describes a DLC I-frame at some point in its lifetime.  Routines are
    provided to allocate packets for shipment, to ship packets, to reference
    packets, to dereference packets, to mark a connection as waiting for a
    packet to become available, to satisfy the next waiting connection for
    a packet, and to destroy packets (return them to the pool).

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// This is temporary; this is the quota that we charge for a receive
// packet for now, until we fix the problem with token-ring needing
// big packets and using all the memory. The number is the actual
// value for Ethernet.
//

#if 1
#define RECEIVE_BUFFER_QUOTA(_DeviceContext)   1533
#else
#define RECEIVE_BUFFER_QUOTA(_DeviceContext)   (_DeviceContext)->ReceiveBufferLength
#endif

#define PACKET_POOL_GROW_COUNT  32

#if DBG
ULONG NbfCreatePacketThreshold = 5;
extern ULONG NbfPacketPanic;
#endif

NDIS_STATUS
NbfAllocateNdisSendPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PNDIS_PACKET *NdisPacket
    )

/*++

Routine Description:

    This routine allocates a recieve packet from the receive packet pool.
    It Grows the packet pool if necessary.  

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    UIFrame - Returns a pointer to the frame, or NULL if no storage
        can be allocated.

Return Value:

    None.

--*/

{

    PNBF_POOL_LIST_DESC SendPacketPoolDesc;
    NDIS_STATUS NdisStatus;
    KIRQL oldirql;

    NdisStatus = NDIS_STATUS_RESOURCES;

    ACQUIRE_SPIN_LOCK (&DeviceContext->SendPoolListLock, &oldirql);
    for (SendPacketPoolDesc = DeviceContext->SendPacketPoolDesc; 
         SendPacketPoolDesc != NULL; 
         SendPacketPoolDesc = SendPacketPoolDesc->Next) {

        NdisAllocatePacket (
             &NdisStatus,
             NdisPacket,
             SendPacketPoolDesc->PoolHandle);


        if (NdisStatus == NDIS_STATUS_SUCCESS) {

            RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
            return(NdisStatus);
        }
    }

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + 
                PACKET_POOL_GROW_COUNT * 
                (sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG))) >
                DeviceContext->MemoryLimit)) {

                PANIC("NBF: Could not grow packet pool: limit\n");
            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_LIMIT,
                106,
                DeviceContext->UIFrameLength,
                UI_FRAME_RESOURCE_ID);
            RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
            return(NdisStatus);
        }
    }

    DeviceContext->MemoryUsage +=
        (PACKET_POOL_GROW_COUNT * 
        (sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG)));

    // Allocate Packet pool descriptors for dynamic packet allocation.

    SendPacketPoolDesc = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(NBF_POOL_LIST_DESC),
                    NBF_MEM_TAG_POOL_DESC);

    if (SendPacketPoolDesc == NULL) {
        RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
        return(NdisStatus);
    }

    RtlZeroMemory(SendPacketPoolDesc,  sizeof(NBF_POOL_LIST_DESC));

    SendPacketPoolDesc->NumElements = 
    SendPacketPoolDesc->TotalElements = PACKET_POOL_GROW_COUNT;

    // To track packet pools in NDIS allocated on NBF's behalf
#if NDIS_POOL_TAGGING
    SendPacketPoolDesc->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NBF;
#endif

    NdisAllocatePacketPoolEx ( &NdisStatus, &SendPacketPoolDesc->PoolHandle,
        PACKET_POOL_GROW_COUNT, 0, sizeof (SEND_PACKET_TAG));

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
#if DBG
        NbfPrint1 ("NbfGrowSendPacketPool: NdisInitializePacketPool failed, reason: %s.\n",
            NbfGetNdisStatus (NdisStatus));
#endif
        RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
        ExFreePool (SendPacketPoolDesc);
        return(NdisStatus);
    }
    
    NdisSetPacketPoolProtocolId (SendPacketPoolDesc->PoolHandle, NDIS_PROTOCOL_ID_NBF);

    SendPacketPoolDesc->Next = DeviceContext->SendPacketPoolDesc;
    DeviceContext->SendPacketPoolDesc = SendPacketPoolDesc;
    RELEASE_SPIN_LOCK (&DeviceContext->SendPoolListLock, oldirql);
    NdisAllocatePacket ( &NdisStatus, NdisPacket, 
                        SendPacketPoolDesc->PoolHandle);
    
    return(NdisStatus);
}

NDIS_STATUS
NbfAllocateNdisRcvPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PNDIS_PACKET *NdisPacket
    )

/*++

Routine Description:

    This routine allocates a recieve packet from the receive packet pool.
    It Grows the packet pool if necessary.  

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    UIFrame - Returns a pointer to the frame, or NULL if no storage
        can be allocated.

Return Value:

    None.

--*/

{

    PNBF_POOL_LIST_DESC RcvPacketPoolDesc;
    NDIS_STATUS NdisStatus;
    KIRQL oldirql;

    NdisStatus = NDIS_STATUS_RESOURCES;

    ACQUIRE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, &oldirql);
    for (RcvPacketPoolDesc = DeviceContext->ReceivePacketPoolDesc; 
         RcvPacketPoolDesc != NULL; 
         RcvPacketPoolDesc = RcvPacketPoolDesc->Next) {

        NdisAllocatePacket (
             &NdisStatus,
             NdisPacket,
             RcvPacketPoolDesc->PoolHandle);


        if (NdisStatus == NDIS_STATUS_SUCCESS) {
            RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
            return(NdisStatus);
        }
    }

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + 
                PACKET_POOL_GROW_COUNT * 
                (sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG))) >
                DeviceContext->MemoryLimit)) {

                PANIC("NBF: Could not grow packet pool: limit\n");
            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_LIMIT,
                106,
                DeviceContext->UIFrameLength,
                UI_FRAME_RESOURCE_ID);
            RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
            return(NdisStatus);
        }
    }

    DeviceContext->MemoryUsage +=
        (PACKET_POOL_GROW_COUNT * 
        (sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG)));

    // Allocate Packet pool descriptors for dynamic packet allocation.

    RcvPacketPoolDesc = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(NBF_POOL_LIST_DESC),
                    NBF_MEM_TAG_POOL_DESC);

    if (RcvPacketPoolDesc == NULL) {
        RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
        return(NdisStatus);
    }

    RtlZeroMemory(RcvPacketPoolDesc,  sizeof(NBF_POOL_LIST_DESC));

    RcvPacketPoolDesc->NumElements = 
    RcvPacketPoolDesc->TotalElements = PACKET_POOL_GROW_COUNT;

    // To track packet pools in NDIS allocated on NBF's behalf
#if NDIS_POOL_TAGGING
    RcvPacketPoolDesc->PoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NBF;
#endif

    NdisAllocatePacketPoolEx ( &NdisStatus, &RcvPacketPoolDesc->PoolHandle,
        PACKET_POOL_GROW_COUNT, 0, sizeof (RECEIVE_PACKET_TAG));

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
#if DBG
        NbfPrint1 ("NbfGrowSendPacketPool: NdisInitializePacketPool failed, reason: %s.\n",
            NbfGetNdisStatus (NdisStatus));
#endif
        RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
        ExFreePool (RcvPacketPoolDesc);
        return(NdisStatus);
    }
    
    NdisSetPacketPoolProtocolId (RcvPacketPoolDesc->PoolHandle, NDIS_PROTOCOL_ID_NBF);
    
    RcvPacketPoolDesc->Next = DeviceContext->ReceivePacketPoolDesc;
    DeviceContext->ReceivePacketPoolDesc = RcvPacketPoolDesc;
    RELEASE_SPIN_LOCK (&DeviceContext->RcvPoolListLock, oldirql);
    NdisAllocatePacket ( &NdisStatus, NdisPacket, 
                        RcvPacketPoolDesc->PoolHandle);
    
    return(NdisStatus);
}
    

VOID
NbfAllocateUIFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_UI_FRAME *TransportUIFrame
    )

/*++

Routine Description:

    This routine allocates storage for a UI frame. Some initialization
    is done here.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    UIFrame - Returns a pointer to the frame, or NULL if no storage
        can be allocated.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PNDIS_PACKET NdisPacket;
    PSEND_PACKET_TAG SendTag;
    PTP_UI_FRAME UIFrame;
    PNDIS_BUFFER NdisBuffer;
    PNBF_POOL_LIST_DESC SendPacketPoolDesc;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + DeviceContext->UIFrameLength) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate UI frame: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            106,
            DeviceContext->UIFrameLength,
            UI_FRAME_RESOURCE_ID);
        *TransportUIFrame = NULL;
        return;
    }

    UIFrame = (PTP_UI_FRAME) ExAllocatePoolWithTag (
                                 NonPagedPool,
                                 DeviceContext->UIFrameLength,
                                 NBF_MEM_TAG_TP_UI_FRAME);
    if (UIFrame == NULL) {
        PANIC("NBF: Could not allocate UI frame: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            206,
            DeviceContext->UIFrameLength,
            UI_FRAME_RESOURCE_ID);
        *TransportUIFrame = NULL;
        return;
    }
    RtlZeroMemory (UIFrame, DeviceContext->UIFrameLength);

    DeviceContext->MemoryUsage += DeviceContext->UIFrameLength;
    NdisStatus = NbfAllocateNdisSendPacket(DeviceContext, &NdisPacket);
#if 0    
    for (SendPacketPoolDesc = DeviceContext->SendPacketPoolDesc; 
         SendPacketPoolDesc != NULL; 
         SendPacketPoolDesc = SendPacketPoolDesc->Next) {

        NdisAllocatePacket (
             &NdisStatus,
             &NdisPacket,
             SendPacketPoolDesc->PoolHandle);


        if (NdisStatus == NDIS_STATUS_SUCCESS)
            break;
    }
#endif

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        ExFreePool (UIFrame);
#if 0
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            306,
            0,
            UI_FRAME_RESOURCE_ID);
#endif
        *TransportUIFrame = NULL;
        return;
    }


    UIFrame->NdisPacket = NdisPacket;
    UIFrame->DataBuffer = NULL;
    SendTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;
    SendTag->Type = TYPE_UI_FRAME;
    SendTag->Frame = UIFrame;
    SendTag->Owner = DeviceContext;

    //
    // Make the packet header known to the packet descriptor
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        UIFrame->Header,
        DeviceContext->UIFrameHeaderLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {

        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            406,
            0,
            UI_FRAME_RESOURCE_ID);
        NdisFreePacket (NdisPacket);
        ExFreePool (UIFrame);
        *TransportUIFrame = NULL;
        return;
    }

    NdisChainBufferAtFront (NdisPacket, NdisBuffer);

    ++DeviceContext->UIFrameAllocated;

    *TransportUIFrame = UIFrame;

}   /* NbfAllocateUIFrame */


VOID
NbfDeallocateUIFrame(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_UI_FRAME TransportUIFrame
    )

/*++

Routine Description:

    This routine frees storage for a UI frame.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    UIFrame - A pointer to the frame.

Return Value:

    None.

--*/

{
    PNDIS_PACKET NdisPacket = TransportUIFrame->NdisPacket;
    PNDIS_BUFFER NdisBuffer;

    NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
    if (NdisBuffer != NULL) {
        NdisFreeBuffer (NdisBuffer);
    }

    NdisFreePacket (NdisPacket);
    ExFreePool (TransportUIFrame);
    --DeviceContext->UIFrameAllocated;

    DeviceContext->MemoryUsage -= DeviceContext->UIFrameLength;

}   /* NbfDeallocateUIFrame */


VOID
NbfAllocateSendPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_PACKET *TransportSendPacket
    )

/*++

Routine Description:

    This routine allocates storage for a send packet. Some initialization
    is done here.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportSendPacket - Returns a pointer to the packet, or NULL if no
        storage can be allocated.

Return Value:

    None.

--*/

{

    PTP_PACKET Packet;
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET NdisPacket;
    PSEND_PACKET_TAG SendTag;
    PNDIS_BUFFER NdisBuffer;
    PNBF_POOL_LIST_DESC SendPacketPoolDesc;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + DeviceContext->PacketLength) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate send packet: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            107,
            DeviceContext->PacketLength,
            PACKET_RESOURCE_ID);
        *TransportSendPacket = NULL;
        return;
    }

    Packet = (PTP_PACKET)ExAllocatePoolWithTag (
                             NonPagedPool,
                             DeviceContext->PacketLength,
                             NBF_MEM_TAG_TP_PACKET);
    if (Packet == NULL) {
        PANIC("NBF: Could not allocate send packet: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            207,
            DeviceContext->PacketLength,
            PACKET_RESOURCE_ID);
        *TransportSendPacket = NULL;
        return;
    }
    RtlZeroMemory (Packet, DeviceContext->PacketLength);

    DeviceContext->MemoryUsage += DeviceContext->PacketLength;

    NdisStatus = NbfAllocateNdisSendPacket(DeviceContext, &NdisPacket);
#if 0
    for (SendPacketPoolDesc = DeviceContext->SendPacketPoolDesc; 
         SendPacketPoolDesc != NULL; 
         SendPacketPoolDesc = SendPacketPoolDesc->Next) {

        NdisAllocatePacket (
             &NdisStatus,
             &NdisPacket,
             SendPacketPoolDesc->PoolHandle);


        if (NdisStatus == NDIS_STATUS_SUCCESS)
            break;
    }
#endif

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        ExFreePool (Packet);
#if 0
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            307,
            0,
            PACKET_RESOURCE_ID);
#endif
        *TransportSendPacket = NULL;
        return;
    }

    NdisAllocateBuffer(
        &NdisStatus, 
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        Packet->Header,
        DeviceContext->PacketHeaderLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            407,
            0,
            PACKET_RESOURCE_ID);
        NdisFreePacket (NdisPacket);
        ExFreePool (Packet);
        *TransportSendPacket = NULL;
        return;
    }

    NdisChainBufferAtFront (NdisPacket, NdisBuffer);

    Packet->NdisPacket = NdisPacket;
    SendTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;
    SendTag->Type = TYPE_I_FRAME;
    SendTag->Frame = Packet;
    SendTag->Owner = DeviceContext;

    Packet->Type = NBF_PACKET_SIGNATURE;
    Packet->Size = sizeof (TP_PACKET);
    Packet->Provider = DeviceContext;
    Packet->Owner = NULL;         // no connection/irpsp yet.
    Packet->Action = PACKET_ACTION_IRP_SP;
    Packet->PacketizeConnection = FALSE;
    Packet->PacketNoNdisBuffer = FALSE;
    Packet->ProviderInterlock = &DeviceContext->Interlock;
//    KeInitializeSpinLock (&Packet->Interlock);

    ++DeviceContext->PacketAllocated;

    *TransportSendPacket = Packet;

}   /* NbfAllocateSendPacket */


VOID
NbfDeallocateSendPacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_PACKET TransportSendPacket
    )

/*++

Routine Description:

    This routine frees storage for a send packet.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportSendPacket - A pointer to the send packet.

Return Value:

    None.

--*/

{
    PNDIS_PACKET NdisPacket = TransportSendPacket->NdisPacket;
    PNDIS_BUFFER NdisBuffer;

    NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
    if (NdisBuffer != NULL) {
        NdisFreeBuffer (NdisBuffer);
    }

    NdisFreePacket (NdisPacket);
    ExFreePool (TransportSendPacket);

    --DeviceContext->PacketAllocated;
    DeviceContext->MemoryUsage -= DeviceContext->PacketLength;

}   /* NbfDeallocateSendPacket */


VOID
NbfAllocateReceivePacket(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PNDIS_PACKET *TransportReceivePacket
    )

/*++

Routine Description:

    This routine allocates storage for a receive packet. Some initialization
    is done here.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportReceivePacket - Returns a pointer to the packet, or NULL if no
        storage can be allocated.

Return Value:

    None.

--*/

{
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET NdisPacket;
    PRECEIVE_PACKET_TAG ReceiveTag;

    //
    // This does not count in DeviceContext->MemoryUsage because
    // the storage is allocated when we allocate the packet pool.
    //

    NdisStatus = NbfAllocateNdisRcvPacket(DeviceContext, &NdisPacket);
#if 0
    NdisAllocatePacket (
        &NdisStatus,
        &NdisPacket,
        DeviceContext->ReceivePacketPoolDesc->PoolHandle);
#endif

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
#if 0
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            309,
            0,
            RECEIVE_PACKET_RESOURCE_ID);
#endif
        *TransportReceivePacket = NULL;
        return;
    }

    ReceiveTag = (PRECEIVE_PACKET_TAG)(NdisPacket->ProtocolReserved);
    ReceiveTag->PacketType = TYPE_AT_INDICATE;

    ++DeviceContext->ReceivePacketAllocated;

    *TransportReceivePacket = NdisPacket;

}   /* NbfAllocateReceivePacket */


VOID
NbfDeallocateReceivePacket(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_PACKET TransportReceivePacket
    )

/*++

Routine Description:

    This routine frees storage for a receive packet.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportReceivePacket - A pointer to the packet.

Return Value:

    None.

--*/

{

    NdisFreePacket (TransportReceivePacket);

    --DeviceContext->ReceivePacketAllocated;

}   /* NbfDeallocateReceivePacket */


VOID
NbfAllocateReceiveBuffer(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PBUFFER_TAG *TransportReceiveBuffer
    )

/*++

Routine Description:

    This routine allocates storage for a receive buffer. Some initialization
    is done here.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportReceiveBuffer - Returns a pointer to the buffer, or NULL if no
        storage can be allocated.

Return Value:

    None.

--*/

{
    PBUFFER_TAG BufferTag;
    NDIS_STATUS NdisStatus;
    PNDIS_BUFFER NdisBuffer;


    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + RECEIVE_BUFFER_QUOTA(DeviceContext)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate receive buffer: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            108,
            RECEIVE_BUFFER_QUOTA(DeviceContext),
            RECEIVE_BUFFER_RESOURCE_ID);
        *TransportReceiveBuffer = NULL;
        return;
    }

    //
    // The Aligned doesn't help since the header makes it unaligned.
    //

    BufferTag = (PBUFFER_TAG)ExAllocatePoolWithTag (
                    NonPagedPoolCacheAligned,
                    DeviceContext->ReceiveBufferLength,
                    NBF_MEM_TAG_RCV_BUFFER);

    if (BufferTag == NULL) {
        PANIC("NBF: Could not allocate receive buffer: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            208,
            DeviceContext->ReceiveBufferLength,
            RECEIVE_BUFFER_RESOURCE_ID);

        *TransportReceiveBuffer = NULL;
        return;
    }

    DeviceContext->MemoryUsage += RECEIVE_BUFFER_QUOTA(DeviceContext);

    //
    // point to the buffer for NDIS
    //

    NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        BufferTag->Buffer,
        DeviceContext->MaxReceivePacketSize);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PANIC("NBF: Could not allocate receive buffer: no buffer\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            308,
            0,
            RECEIVE_BUFFER_RESOURCE_ID);
        ExFreePool (BufferTag);
        *TransportReceiveBuffer = NULL;
        return;
    }

    BufferTag->Length = DeviceContext->MaxReceivePacketSize;
    BufferTag->NdisBuffer = NdisBuffer;

    ++DeviceContext->ReceiveBufferAllocated;

    *TransportReceiveBuffer = BufferTag;

}   /* NbfAllocateReceiveBuffer */


VOID
NbfDeallocateReceiveBuffer(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PBUFFER_TAG TransportReceiveBuffer
    )

/*++

Routine Description:

    This routine frees storage for a receive buffer.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    TransportReceiveBuffer - A pointer to the buffer.

Return Value:

    None.

--*/

{

    NdisFreeBuffer (TransportReceiveBuffer->NdisBuffer);
    ExFreePool (TransportReceiveBuffer);

    --DeviceContext->ReceiveBufferAllocated;
    DeviceContext->MemoryUsage -= RECEIVE_BUFFER_QUOTA(DeviceContext);

}   /* NbfDeallocateReceiveBuffer */


NTSTATUS
NbfCreatePacket(
    PDEVICE_CONTEXT DeviceContext,
    PTP_LINK Link,
    PTP_PACKET *Packet
    )

/*++

Routine Description:

    This routine allocates a packet from the device context's pool,
    and prepares the MAC and DLC headers for use by the connection.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    Link - The link the packet will be sent over.

    Packet - Pointer to a place where we will return a pointer to the
        allocated packet.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PSINGLE_LIST_ENTRY s;
    PTP_PACKET ThePacket;
    PDLC_I_FRAME DlcHdr;
#if DBG
    PNBF_HDR_CONNECTION NbfHdr;
#endif
    typedef struct _SIXTEEN_BYTES {
        ULONG Data[4];
    } SIXTEEN_BYTES, *PSIXTEEN_BYTES;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NbfCreatePacket:  Entered.\n");
    }

    //
    // Make sure that structure packing hasn't happened.
    //

    ASSERT (sizeof(NBF_HDR_CONNECTION) == 14);

#if defined(NBF_UP)
    s = DeviceContext->PacketPool.Next;
    if (s != NULL) {
        DeviceContext->PacketPool.Next = s->Next;
    }
#else
    s = ExInterlockedPopEntryList (
            &DeviceContext->PacketPool,
            &DeviceContext->Interlock);
#endif

    if (s == NULL) {
        NbfGrowSendPacketPool(DeviceContext);
        
#if defined(NBF_UP)
        s = DeviceContext->PacketPool.Next;
        if (s != NULL) {
            DeviceContext->PacketPool.Next = s->Next;
        }
#else
        s = ExInterlockedPopEntryList (
                &DeviceContext->PacketPool,
                &DeviceContext->Interlock);
#endif
        if (s == NULL) {
#if DBG
            ++Link->CreatePacketFailures;
            if ((ULONG)Link->CreatePacketFailures >= NbfCreatePacketThreshold) {
                if (NbfPacketPanic) {
                    NbfPrint1 ("NbfCreatePacket: PANIC! no more packets in provider's pool (%d times).\n",
                             Link->CreatePacketFailures);
                }
                Link->CreatePacketFailures = 0;
            }
#endif
            ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);
            ++DeviceContext->PacketExhausted;
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    }
#if DBG
    Link->CreatePacketFailures = 0;
#endif

    ThePacket = CONTAINING_RECORD (s, TP_PACKET, Linkage);

    //
    // NOTE: ThePacket->Action and ThePacket->Owner are filled
    // in by the caller of this function.
    //

    ThePacket->ReferenceCount = 1;      // automatic ref count of 1.
    ThePacket->Link = NULL;          // no link yet.
    ThePacket->PacketSent = FALSE;
    ASSERT (ThePacket->Action == PACKET_ACTION_IRP_SP);
    ASSERT (ThePacket->PacketNoNdisBuffer == FALSE);
    ASSERT (ThePacket->PacketizeConnection == FALSE);

    //
    // Initialize the MAC header for this packet, using the connection's
    // link pre-built header.
    //

    if (Link->HeaderLength <= 14) {

        *(PSIXTEEN_BYTES)ThePacket->Header = *(PSIXTEEN_BYTES)Link->Header;

    } else {

        RtlCopyMemory(
            ThePacket->Header,
            Link->Header,
            Link->HeaderLength);

        //
        // Initialize the TP_FRAME_CONNECTION header for this packet.
        //

        DlcHdr = (PDLC_I_FRAME)&(ThePacket->Header[Link->HeaderLength]);
        DlcHdr->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHdr->Ssap = DSAP_NETBIOS_OVER_LLC;
#if DBG
        DlcHdr->SendSeq = 0;                // known values, will assist debugging.
        DlcHdr->RcvSeq = 0;                 // these are assigned at shipment time.
#endif

    }


#if DBG
    NbfHdr = (PNBF_HDR_CONNECTION)&(ThePacket->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]);
    NbfHdr->Command = 0xff;             // to assist debugging-- assigned later.
    NbfHdr->Data1 = 0xff;               // to assist debugging-- assigned later.
    NbfHdr->Data2Low = 0xff;            // to assist debugging-- assigned later.
    NbfHdr->Data2High = 0xff;           // to assist debugging-- assigned later.
    TRANSMIT_CORR(NbfHdr) = 0xffff;     // to assist debugging-- assigned later.
    RESPONSE_CORR(NbfHdr) = 0xffff;     // to assist debugging-- assigned later.
    NbfHdr->DestinationSessionNumber = 0xff; // to assist debugging-- assigned later.
    NbfHdr->SourceSessionNumber = 0xff; // to assist debugging-- assigned later.
#endif

    *Packet = ThePacket;                // return pointer to the packet.
    return STATUS_SUCCESS;
} /* NbfCreatePacket */


NTSTATUS
NbfCreateRrPacket(
    PDEVICE_CONTEXT DeviceContext,
    PTP_LINK Link,
    PTP_PACKET *Packet
    )

/*++

Routine Description:

    This routine allocates an RR packet from the device context's pool,
    and prepares the MAC and DLC headers for use by the connection.
    It first looks in the special RR packet pool, then in the regular
    packet pool.

Arguments:

    DeviceContext - Pointer to our device context to charge the packet to.

    Link - The link the packet will be sent over.

    Packet - Pointer to a place where we will return a pointer to the
        allocated packet.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PSINGLE_LIST_ENTRY s;
    PTP_PACKET ThePacket;
    PDLC_I_FRAME DlcHdr;
    NTSTATUS Status;
#if DBG
    PNBF_HDR_CONNECTION NbfHdr;
#endif
    typedef struct _SIXTEEN_BYTES {
        ULONG Data[4];
    } SIXTEEN_BYTES, *PSIXTEEN_BYTES;

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint0 ("NbfCreateRrPacket:  Entered.\n");
    }

    //
    // Make sure that structure packing hasn't happened.
    //

    ASSERT (sizeof(NBF_HDR_CONNECTION) == 14);

#if defined(NBF_UP)
    s = DeviceContext->RrPacketPool.Next;
    if (s != NULL) {
        DeviceContext->RrPacketPool.Next = s->Next;
    }
#else
    s = ExInterlockedPopEntryList (
            &DeviceContext->RrPacketPool,
            &DeviceContext->Interlock);
#endif

    if (s == NULL) {
#if DBG
        ++Link->CreatePacketFailures;
        if ((ULONG)Link->CreatePacketFailures >= NbfCreatePacketThreshold) {
            if (NbfPacketPanic) {
                NbfPrint1 ("NbfCreateRrPacket: PANIC! no more packets in provider's pool (%d times).\n",
                            Link->CreatePacketFailures);
            }
            Link->CreatePacketFailures = 0;
        }
#endif
        //
        // Try to get one from the regular pool, and mark it so
        // it goes back there.
        //

        Status = NbfCreatePacket(
                     DeviceContext,
                     Link,
                     Packet);

        if (Status == STATUS_SUCCESS) {
            (*Packet)->Action = PACKET_ACTION_NULL;
        }
        return Status;
    }
#if DBG
    Link->CreatePacketFailures = 0;
#endif

    ThePacket = CONTAINING_RECORD (s, TP_PACKET, Linkage);

    //
    // NOTE: ThePacket->Owner is filled in by the caller of this
    // function.
    //

    ThePacket->ReferenceCount = 1;      // automatic ref count of 1.
    ThePacket->Link = NULL;          // no link yet.
    ThePacket->PacketSent = FALSE;
    ASSERT (ThePacket->Action == PACKET_ACTION_RR);
    ASSERT (ThePacket->PacketNoNdisBuffer == FALSE);

    //
    // Initialize the MAC header for this packet, using the connection's
    // link pre-built header.
    //

    if (Link->HeaderLength <= 14) {

        *(PSIXTEEN_BYTES)ThePacket->Header = *(PSIXTEEN_BYTES)Link->Header;

    } else {

        RtlCopyMemory(
            ThePacket->Header,
            Link->Header,
            Link->HeaderLength);

        //
        // Initialize the TP_FRAME_CONNECTION header for this packet.
        //

        DlcHdr = (PDLC_I_FRAME)&(ThePacket->Header[Link->HeaderLength]);
        DlcHdr->Dsap = DSAP_NETBIOS_OVER_LLC;
        DlcHdr->Ssap = DSAP_NETBIOS_OVER_LLC;
#if DBG
        DlcHdr->SendSeq = 0;                // known values, will assist debugging.
        DlcHdr->RcvSeq = 0;                 // these are assigned at shipment time.
#endif

    }


#if DBG
    NbfHdr = (PNBF_HDR_CONNECTION)&(ThePacket->Header[Link->HeaderLength + sizeof(DLC_I_FRAME)]);
    NbfHdr->Command = 0xff;             // to assist debugging-- assigned later.
    NbfHdr->Data1 = 0xff;               // to assist debugging-- assigned later.
    NbfHdr->Data2Low = 0xff;            // to assist debugging-- assigned later.
    NbfHdr->Data2High = 0xff;           // to assist debugging-- assigned later.
    TRANSMIT_CORR(NbfHdr) = 0xffff;     // to assist debugging-- assigned later.
    RESPONSE_CORR(NbfHdr) = 0xffff;     // to assist debugging-- assigned later.
    NbfHdr->DestinationSessionNumber = 0xff; // to assist debugging-- assigned later.
    NbfHdr->SourceSessionNumber = 0xff; // to assist debugging-- assigned later.
#endif

    *Packet = ThePacket;                // return pointer to the packet.
    return STATUS_SUCCESS;
} /* NbfCreateRrPacket */


VOID
NbfDestroyPacket(
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine destroys a packet, thereby returning it to the pool.  If
    it is determined that there is at least one connection waiting for a
    packet to become available (and it just has), then the connection is
    removed from the device context's list and AdvanceSend is called to
    prep the connection further.

Arguments:

    Packet - Pointer to a packet to be returned to the pool.

Return Value:

    none.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    PTP_CONNECTION Connection;
    PLIST_ENTRY p;
    PNDIS_BUFFER HeaderBuffer;
    PNDIS_BUFFER NdisBuffer;
    ULONG Flags;

    IF_NBFDBG (NBF_DEBUG_RESOURCE) {
        NbfPrint2 ("NbfDestroyPacket:  Entered, Packet: %lx, NdisPacket: %lx\n",
            Packet, Packet->NdisPacket);
    }

    DeviceContext = Packet->Provider;

    //
    // Strip off and unmap the buffers describing data and header.
    //

    if (Packet->PacketNoNdisBuffer) {

        //
        // If the NDIS_BUFFER chain is not ours, then we can't
        // start unchaining since that would mess up the queue;
        // instead we just drop the rest of the chain after the
        // header.
        //

        NdisQueryPacket (Packet->NdisPacket, NULL, NULL, &HeaderBuffer, NULL);
        ASSERT (HeaderBuffer != NULL);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = (PNDIS_BUFFER)NULL;
        NdisRecalculatePacketCounts (Packet->NdisPacket);

        Packet->PacketNoNdisBuffer = FALSE;

    } else {

        NdisUnchainBufferAtFront (Packet->NdisPacket, &HeaderBuffer);
        ASSERT (HeaderBuffer != NULL);

        //
        // Return all the NDIS_BUFFERs to the system.
        //

        NdisUnchainBufferAtFront (Packet->NdisPacket, &NdisBuffer);
        while (NdisBuffer != NULL) {
            NdisFreeBuffer (NdisBuffer);
            NdisUnchainBufferAtFront (Packet->NdisPacket, &NdisBuffer);
        }

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = (PNDIS_BUFFER)NULL;
        NdisChainBufferAtFront (Packet->NdisPacket, HeaderBuffer);

    }


    //
    // invoke the packet deallocate action specified in this packet.
    //

    switch (Packet->Action) {

        case PACKET_ACTION_NULL:
            // PANIC ("NbfDestroyPacket: no action.\n");
            Packet->Action = PACKET_ACTION_IRP_SP;
            break;

        case PACKET_ACTION_IRP_SP:
            IF_NBFDBG (NBF_DEBUG_REQUEST) {
                NbfPrint2 ("NbfDestroyPacket:  Packet %x deref IrpSp %x.\n", Packet, Packet->Owner);
            }
            NbfDereferenceSendIrp("Destroy packet", (PIO_STACK_LOCATION)(Packet->Owner), RREF_PACKET);
            break;

        case PACKET_ACTION_CONNECTION:
            NbfDereferenceConnection ("Destroy packet", (PTP_CONNECTION)(Packet->Owner), CREF_FRAME_SEND);
            Packet->Action = PACKET_ACTION_IRP_SP;
            break;

        case PACKET_ACTION_END:
            NbfDereferenceConnection ("SessionEnd destroyed", (PTP_CONNECTION)(Packet->Owner), CREF_FRAME_SEND);
            NbfDereferenceConnection ("SessionEnd destroyed", (PTP_CONNECTION)(Packet->Owner), CREF_LINK);
            Packet->Action = PACKET_ACTION_IRP_SP;
            break;

        case PACKET_ACTION_RR:
#if defined(NBF_UP)
            ((PSINGLE_LIST_ENTRY)&Packet->Linkage)->Next =
                                        DeviceContext->RrPacketPool.Next;
            DeviceContext->RrPacketPool.Next =
                                &((PSINGLE_LIST_ENTRY)&Packet->Linkage)->Next;
#else
            ExInterlockedPushEntryList (
                    &DeviceContext->RrPacketPool,
                    (PSINGLE_LIST_ENTRY)&Packet->Linkage,
                    &DeviceContext->Interlock);
#endif
            return;

        default:
            IF_NBFDBG (NBF_DEBUG_RESOURCE) {
                NbfPrint1 ("NbfDestroyPacket: invalid action (%ld).\n", Packet->Action);
            }
            ASSERT (FALSE);
    }


    //
    // Put the packet back for use again.
    //

#if defined(NBF_UP)
    ((PSINGLE_LIST_ENTRY)&Packet->Linkage)->Next =
                                        DeviceContext->PacketPool.Next;
    DeviceContext->PacketPool.Next =
                            &((PSINGLE_LIST_ENTRY)&Packet->Linkage)->Next;
#else
    ExInterlockedPushEntryList (
            &DeviceContext->PacketPool,
            (PSINGLE_LIST_ENTRY)&Packet->Linkage,
            &DeviceContext->Interlock);
#endif

    //
    // If there is a connection waiting to ship out more packets, then
    // wake it up and start packetizing again.
    //
    // We do a quick check without the lock; there is a small
    // window where we may not take someone off, but this
    // window exists anyway and we assume that more packets
    // will be freed in the future.
    //

    if (IsListEmpty (&DeviceContext->PacketWaitQueue)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    if (!(IsListEmpty(&DeviceContext->PacketWaitQueue))) {

        //
        // Remove a connection from the "packet starved" queue.
        //

        p  = RemoveHeadList (&DeviceContext->PacketWaitQueue);
        Connection = CONTAINING_RECORD (p, TP_CONNECTION, PacketWaitLinkage);
        Connection->OnPacketWaitQueue = FALSE;
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // If this connection is starved because it couldn't send a
        // control packet (SI, SC, RO, RC, or DA) then start that
        // operation up again.  Otherwise, just start packetizing.
        //

        if (Connection->Flags & CONNECTION_FLAGS_STARVED) {

            Flags = Connection->Flags & CONNECTION_FLAGS_STARVED;

            if ((Flags & (Flags-1)) != 0) {

                //
                // More than one bit is on, use only the low one
                // (an arbitrary choice).
                //

#if DBG
                DbgPrint ("NBF: Connection %lx has two flag bits on %lx\n", Connection, Connection->Flags);
#endif
                Flags &= ~(Flags-1);

            }

            Connection->Flags &= ~Flags;

            if ((Connection->Flags & CONNECTION_FLAGS_W_PACKETIZE) ||
                (Connection->Flags & CONNECTION_FLAGS_STARVED)) {

                //
                // We are waiting for both a specific packet and
                // to packetize, or for two specific packets, so
                // put ourselves back on the queue.
                //

                ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
                if (!Connection->OnPacketWaitQueue) {
                    Connection->OnPacketWaitQueue = TRUE;
                    InsertTailList(
                        &DeviceContext->PacketWaitQueue,
                        &Connection->PacketWaitLinkage);
                }

                RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
            }

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            if (Flags & CONNECTION_FLAGS_SEND_SI) {
                NbfSendSessionInitialize (Connection);
            } else if (Flags & CONNECTION_FLAGS_SEND_SC) {
                NbfSendSessionConfirm (Connection);
            } else if (Flags & CONNECTION_FLAGS_SEND_RO) {
                NbfSendReceiveOutstanding (Connection);
            } else if (Flags & CONNECTION_FLAGS_SEND_RC) {
                NbfSendReceiveContinue (Connection);
            } else if (Flags & CONNECTION_FLAGS_SEND_SE) {
                NbfSendSessionEnd (
                    Connection,
                    FALSE);
            } else if (Flags & CONNECTION_FLAGS_SEND_DA) {
                NbfSendDataAck (Connection);
            } else {
                IF_NBFDBG (NBF_DEBUG_PACKET) {
                    NbfPrint0 ("NbfDestroyPacket: connection flags mismanaged.\n");
                }
            }

        } else {

            //
            // Place the connection on the packetize queue and start
            // packetizing the next connection to be serviced.  If he
            // is already on the packetize queue for some reason, then
            // don't do this.
            //
            // We shouldn't be packetizing in this case!! - adb (7/3/91).
            // This used to be a check that did nothing if FLAGS_PACKETIZE
            // was set, but if that happens something is wrong...
            //

            ASSERT (Connection->Flags & CONNECTION_FLAGS_W_PACKETIZE);
            Connection->Flags &= ~CONNECTION_FLAGS_W_PACKETIZE;

            Connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;

            if ((Connection->Flags & CONNECTION_FLAGS_READY) &&
                !(Connection->Flags & CONNECTION_FLAGS_PACKETIZE)) {

                Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

                NbfReferenceConnection ("Packet available", Connection, CREF_PACKETIZE_QUEUE);

                ExInterlockedInsertTailList(
                    &DeviceContext->PacketizeQueue,
                    &Connection->PacketizeLinkage,
                    &DeviceContext->SpinLock);
            }

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            PacketizeConnections (DeviceContext);

        }

    } else {

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    }

} /* NbfDestroyPacket */

VOID NbfGrowSendPacketPool(PDEVICE_CONTEXT DeviceContext)
{
    
    NDIS_STATUS NdisStatus;
    PNBF_POOL_LIST_DESC SendPacketPoolDesc;
    PTP_PACKET TransportSendPacket;
    UINT    i;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + DeviceContext->PacketLength) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not grow send packet pool: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            107,
            DeviceContext->PacketLength,
            PACKET_RESOURCE_ID);
        return;
    }

    for (i = 0; i < PACKET_POOL_GROW_COUNT; i += 1) {
        NbfAllocateSendPacket(DeviceContext, &TransportSendPacket);

        if (TransportSendPacket != NULL) {
            ExInterlockedPushEntryList(&(DeviceContext)->PacketPool, 
                (PSINGLE_LIST_ENTRY)&TransportSendPacket->Linkage, 
                &(DeviceContext)->Interlock); 
        }
        else {
            break;
        }    
    }

    if (i == PACKET_POOL_GROW_COUNT) {
        return;
    }

#ifdef DBG
    DbgBreakPoint();
#endif      //  DBG

}

#if DBG
VOID
NbfReferencePacket(
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine increases the number of reasons why a packet cannot be
    discarded.

Arguments:

    Packet - Pointer to a packet to be referenced.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint3 ("NbfReferencePacket:  Entered, NdisPacket: %lx Packet: %lx Ref Count: %lx.\n",
            Packet->NdisPacket, Packet, Packet->ReferenceCount);
    }

    result =  InterlockedIncrement (&Packet->ReferenceCount);

    ASSERT (result >= 0);

} /* NbfReferencePacket */


VOID
NbfDereferencePacket(
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine dereferences a transport packet by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbfDestroyPacket to remove it from the system.

Arguments:

    Packet - Pointer to a packet object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Packet->ReferenceCount);

    //
    // If we have deleted all references to this packet, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the packet any longer.
    //

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint1 ("NbfDereferencePacket:  Entered, result: %lx\n", result);
    }

    ASSERT (result >= 0);

    if (result == 0) {
        NbfDestroyPacket (Packet);
    }

} /* NbfDereferencePacket */
#endif


VOID
NbfWaitPacket(
    PTP_CONNECTION Connection,
    ULONG Flags
    )

/*++

Routine Description:

    This routine causes the specified connection to be put into a wait
    state pending the availability of a packet to send the specified
    frame.

Arguments:

    Connection - Pointer to the connection object to be paused.

    Flags - Bitflag indicating which specific frame should be resent.

Return Value:

    none.

--*/

{
    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint0 ("NbfWaitPacket:  Entered.\n");
    }

    DeviceContext = Connection->Provider;

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    //
    // Now put this connection on the device context's PacketWaitQueue,
    // but only if it isn't already queued there.  This state is managed
    // with the OnPacketWaitQueue variable.
    //
    // If the connection is stopping, don't queue him either.
    //

    if ((Connection->Flags & CONNECTION_FLAGS_READY) ||
        (Flags == CONNECTION_FLAGS_SEND_SE)) {

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        //
        // Turn on the bitflag that indicates which frame we couldn't send.
        //

#if DBG
        if (Flags == CONNECTION_FLAGS_SEND_SE) {
            DbgPrint ("NBF: Inserting connection %lx on PacketWait for SESSION_END\n", Connection);
        }
#endif
        Connection->Flags |= Flags;

        if (!Connection->OnPacketWaitQueue) {

            Connection->OnPacketWaitQueue = TRUE;
            InsertTailList (
                &DeviceContext->PacketWaitQueue,
                &Connection->PacketWaitLinkage);
        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    }

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

} /* NbfWaitPacket */


#if MAGIC
VOID
NbfSendMagicBullet (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine sends a magic bullet on the net that can be used to trigger
    sniffers or other such things.

Arguments:

    DeviceContext - pointer to the device context

    Link - This is needed to call NbfCreatePacket

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    NDIS_STATUS NdisStatus;
    PTP_UI_FRAME RawFrame;
    PUCHAR Header;
    PNDIS_BUFFER NdisBuffer;
    UINT i;

    UNREFERENCED_PARAMETER (Link);        // no longer needed

    Status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
    if (!NT_SUCCESS (Status)) {                    // couldn't make frame.
#if DBG
        DbgPrint ("NbfSendMagicBullet: Couldn't allocate frame!\n");
#endif
        return;
    }


    NdisAllocateBuffer(
        &NdisStatus, 
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        DeviceContext->MagicBullet,
        32);

    if (NdisStatus == NDIS_STATUS_SUCCESS) {

        Header = (PUCHAR)&RawFrame->Header;

        for (i=0;i<6;i++) {
            Header[i] = MAGIC_BULLET_FOOD;
            Header[i+6] = DeviceContext->LocalAddress.Address[i];
        }

        Header[12] = 0;
        Header[13] = (UCHAR)(DeviceContext->UIFrameHeaderLength + 18);

        for (i=14;i<DeviceContext->UIFrameHeaderLength;i++) {
            Header[i] = MAGIC_BULLET_FOOD;
        }

        NdisChainBufferAtBack (RawFrame->NdisPacket, NdisBuffer);

        NbfSendUIFrame (
            DeviceContext,
            RawFrame,
            FALSE);                           // no loopback

    }

    return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\precomp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbf.h

Abstract:

    Private include file for the NBF (NetBIOS Frames Protocol) transport
    provider subcomponent of the NTOS project.

Author:

    Stephen E. Jones (stevej) 25-Oct-1989

Revision History:

    David Beaver (dbeaver) 24-Sep-1990
        Remove PDI and PC586-specific support; add NDIS support

--*/

#include <ntddk.h>

#include <windef.h>
#include <nb30.h>
//#include <ntiologc.h>
//#include <ctype.h>
//#include <assert.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <memory.h>
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <string.h>
//#include <windows.h>

#ifdef BUILD_FOR_511
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif

typedef struct _RTL_SPLAY_LINKS {
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) {    \
    PRTL_SPLAY_LINKS _SplayLinks;            \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks;   \
    _SplayLinks->LeftChild = NULL;       \
    _SplayLinks->RightChild = NULL;      \
    }

#define RtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->LeftChild \
    )

#define RtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->RightChild \
    )

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                      \
    PRTL_SPLAY_LINKS _SplayChild;                       \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);     \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);       \
    _SplayParent->LeftChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;             \
    }

#define RtlInsertAsRightChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                       \
    PRTL_SPLAY_LINKS _SplayChild;                        \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);      \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);        \
    _SplayParent->RightChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;              \
    }


PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );


#include <tdikrnl.h>                        // Transport Driver Interface.

#include <ndis.h>                       // Physical Driver Interface.

#if DEVL
#define STATIC
#else
#define STATIC static
#endif

#include "nbfconst.h"                   // private NETBEUI constants.
#include "nbfmac.h"                     // mac-specific definitions
#include "nbfhdrs.h"                    // private NETBEUI protocol headers.
#include "nbfcnfg.h"                    // configuration information.
#include "nbftypes.h"                   // private NETBEUI types.
#include "nbfprocs.h"                   // private NETBEUI function prototypes.
#ifdef MEMPRINT
#include "memprint.h"                   // drt's memory debug print
#endif

#if defined(NT_UP) && defined(DRIVERS_UP)
#define NBF_UP 1
#endif

//
// Resource and Mutex Macros
//

//
// We wrap each of these macros using
// Enter,Leave critical region macros
// to disable APCs which might occur
// while we are holding the resource
// resulting in deadlocks in the OS.
//

#define ACQUIRE_RESOURCE_EXCLUSIVE(Resource, Wait) \
    KeEnterCriticalRegion(); ExAcquireResourceExclusiveLite(Resource, Wait);
    
#define RELEASE_RESOURCE(Resource) \
    ExReleaseResourceLite(Resource); KeLeaveCriticalRegion();

#define ACQUIRE_FAST_MUTEX_UNSAFE(Mutex) \
    KeEnterCriticalRegion(); ExAcquireFastMutexUnsafe(Mutex);

#define RELEASE_FAST_MUTEX_UNSAFE(Mutex) \
    ExReleaseFastMutexUnsafe(Mutex); KeLeaveCriticalRegion();


#ifndef NBF_LOCKS

#if !defined(NBF_UP)

#define ACQUIRE_SPIN_LOCK(lock,irql) KeAcquireSpinLock(lock,irql)
#define RELEASE_SPIN_LOCK(lock,irql) KeReleaseSpinLock(lock,irql)
#define ACQUIRE_DPC_SPIN_LOCK(lock) KeAcquireSpinLockAtDpcLevel(lock)
#define RELEASE_DPC_SPIN_LOCK(lock) KeReleaseSpinLockFromDpcLevel(lock)

#else // NBF_UP

#define ACQUIRE_SPIN_LOCK(lock,irql) ExAcquireSpinLock(lock,irql)
#define RELEASE_SPIN_LOCK(lock,irql) ExReleaseSpinLock(lock,irql)
#define ACQUIRE_DPC_SPIN_LOCK(lock)
#define RELEASE_DPC_SPIN_LOCK(lock)

#endif

#if DBG

#define ACQUIRE_C_SPIN_LOCK(lock,irql) { \
    PTP_CONNECTION _conn = CONTAINING_RECORD(lock,TP_CONNECTION,SpinLock); \
    KeAcquireSpinLock(lock,irql); \
    _conn->LockAcquired = TRUE; \
    strncpy(_conn->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    _conn->LastAcquireLine = __LINE__; \
}
#define RELEASE_C_SPIN_LOCK(lock,irql) { \
    PTP_CONNECTION _conn = CONTAINING_RECORD(lock,TP_CONNECTION,SpinLock); \
    _conn->LockAcquired = FALSE; \
    strncpy(_conn->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    _conn->LastReleaseLine = __LINE__; \
    KeReleaseSpinLock(lock,irql); \
}

#define ACQUIRE_DPC_C_SPIN_LOCK(lock) { \
    PTP_CONNECTION _conn = CONTAINING_RECORD(lock,TP_CONNECTION,SpinLock); \
    KeAcquireSpinLockAtDpcLevel(lock); \
    _conn->LockAcquired = TRUE; \
    strncpy(_conn->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    _conn->LastAcquireLine = __LINE__; \
}
#define RELEASE_DPC_C_SPIN_LOCK(lock) { \
    PTP_CONNECTION _conn = CONTAINING_RECORD(lock,TP_CONNECTION,SpinLock); \
    _conn->LockAcquired = FALSE; \
    strncpy(_conn->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    _conn->LastReleaseLine = __LINE__; \
    KeReleaseSpinLockFromDpcLevel(lock); \
}

#else  // DBG

#define ACQUIRE_C_SPIN_LOCK(lock,irql) ACQUIRE_SPIN_LOCK(lock,irql)
#define RELEASE_C_SPIN_LOCK(lock,irql) RELEASE_SPIN_LOCK(lock,irql)
#define ACQUIRE_DPC_C_SPIN_LOCK(lock) ACQUIRE_DPC_SPIN_LOCK(lock)
#define RELEASE_DPC_C_SPIN_LOCK(lock) RELEASE_DPC_SPIN_LOCK(lock)

#endif // DBG

#define ENTER_NBF
#define LEAVE_NBF

#else

VOID
NbfAcquireSpinLock(
    IN PKSPIN_LOCK Lock,
    OUT PKIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    );

VOID
NbfReleaseSpinLock(
    IN PKSPIN_LOCK Lock,
    IN KIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    );

#define ACQUIRE_SPIN_LOCK(lock,irql) \
    NbfAcquireSpinLock( lock, irql, #lock, __FILE__, __LINE__ )
#define RELEASE_SPIN_LOCK(lock,irql) \
    NbfReleaseSpinLock( lock, irql, #lock, __FILE__, __LINE__ )

#define ACQUIRE_DPC_SPIN_LOCK(lock) \
    { \
        KIRQL OldIrql; \
        NbfAcquireSpinLock( lock, &OldIrql, #lock, __FILE__, __LINE__ ); \
    }
#define RELEASE_DPC_SPIN_LOCK(lock) \
    NbfReleaseSpinLock( lock, DISPATCH_LEVEL, #lock, __FILE__, __LINE__ )

#define ENTER_NBF                   \
    NbfAcquireSpinLock( (PKSPIN_LOCK)NULL, (PKIRQL)NULL, "(Global)", __FILE__, __LINE__ )
#define LEAVE_NBF                   \
    NbfReleaseSpinLock( (PKSPIN_LOCK)NULL, (KIRQL)-1, "(Global)", __FILE__, __LINE__ )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\rcv.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    rcv.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiReceive
        o   TdiReceiveDatagram

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NbfTdiReceive(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiReceive request for the transport provider.

Arguments:

    Irp - I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION connection;
    KIRQL oldirql;
    PIO_STACK_LOCATION irpSp;

    //
    // verify that the operation is taking place on a connection. At the same
    // time we do this, we reference the connection. This ensures it does not
    // get removed out from under us. Note also that we do the connection
    // lookup within a try/except clause, thus protecting ourselves against
    // really bogus handles
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    connection = irpSp->FileObject->FsContext;

    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint2 ("NbfTdiReceive: Received IRP %lx on connection %lx\n", 
                        Irp, connection);
    }

    //
    // Check that this is really a connection.
    //

    if ((irpSp->FileObject->FsContext2 == UlongToPtr(NBF_FILE_TYPE_CONTROL)) ||
        (connection->Size != sizeof (TP_CONNECTION)) ||
        (connection->Type != NBF_CONNECTION_SIGNATURE)) {
#if DBG
        NbfPrint2 ("TdiReceive: Invalid Connection %lx Irp %lx\n", connection, Irp);
#endif
        return STATUS_INVALID_CONNECTION;
    }

    //
    // Initialize bytes transferred here.
    //

    Irp->IoStatus.Information = 0;              // reset byte transfer count.

    // This reference is removed by NbfDestroyRequest.

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    if ((connection->Flags & CONNECTION_FLAGS_READY) == 0) {

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        Irp->IoStatus.Status = connection->Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

        status = STATUS_PENDING;

    } else {
        KIRQL cancelIrql;

        //
        // Once the reference is in, LinkSpinLock will be valid.
        //

        NbfReferenceConnection("TdiReceive request", connection, CREF_RECEIVE_IRP);
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        IoAcquireCancelSpinLock(&cancelIrql);
        ACQUIRE_DPC_SPIN_LOCK (connection->LinkSpinLock);

        IRP_RECEIVE_IRP(irpSp) = Irp;
        IRP_RECEIVE_REFCOUNT(irpSp) = 1;

#if DBG
        NbfReceives[NbfReceivesNext].Irp = Irp;
        NbfReceives[NbfReceivesNext].Request = NULL;
        NbfReceives[NbfReceivesNext].Connection = (PVOID)connection;
        NbfReceivesNext = (NbfReceivesNext++) % TRACK_TDI_LIMIT;
#endif

        //
        // If this IRP has been cancelled, complete it now.
        //

        if (Irp->Cancel) {

#if DBG
            NbfCompletedReceives[NbfCompletedReceivesNext].Irp = Irp;
            NbfCompletedReceives[NbfCompletedReceivesNext].Request = NULL;
            NbfCompletedReceives[NbfCompletedReceivesNext].Status = STATUS_CANCELLED;
            {
                ULONG i,j,k;
                PUCHAR va;
                PMDL mdl;

                mdl = Irp->MdlAddress;

                NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = (UCHAR)0;

                i = 1;
                while (i<TRACK_TDI_CAPTURE) {
                    if (mdl == NULL) break;
                    va = MmGetSystemAddressForMdl (mdl);
                    j = MmGetMdlByteCount (mdl);

                    for (i=i,k=0;(i<TRACK_TDI_CAPTURE)&&(k<j);i++,k++) {
                        NbfCompletedReceives[NbfCompletedReceivesNext].Contents[i] = *va++;
                    }
                    mdl = mdl->Next;
                }
            }

            NbfCompletedReceivesNext = (NbfCompletedReceivesNext++) % TRACK_TDI_LIMIT;
#endif

            //
            // It is safe to do this with locks held.
            //
            NbfCompleteReceiveIrp (Irp, STATUS_CANCELLED, 0);

            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
            IoReleaseCancelSpinLock(cancelIrql);

        } else {

            //
            // Insert onto the receive queue, and make the IRP
            // cancellable.
            //

            InsertTailList (&connection->ReceiveQueue,&Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, NbfCancelReceive);

            //
            // Release the cancel spinlock out of order. Since we were
            // already at dpc level when it was acquired, we don't
            // need to swap irqls.
            //
            ASSERT(cancelIrql == DISPATCH_LEVEL);
            IoReleaseCancelSpinLock(cancelIrql);

            //
            // This call releases the link spinlock, and references the
            // connection first if it needs to access it after
            // releasing the lock.
            //

            AwakenReceive (connection);             // awaken if sleeping.

        }

        status = STATUS_PENDING;

    }

    KeLowerIrql (oldirql);

    return status;
} /* TdiReceive */


NTSTATUS
NbfTdiReceiveDatagram(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiReceiveDatagram request for the transport
    provider. Receive datagrams just get queued up to an address, and are
    completed when a DATAGRAM or DATAGRAM_BROADCAST frame is received at
    the address.

Arguments:

    Irp - I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    KIRQL oldirql;
    PTP_ADDRESS address;
    PTP_ADDRESS_FILE addressFile;
    PIO_STACK_LOCATION irpSp;
    KIRQL cancelIrql;

    //
    // verify that the operation is taking place on an address. At the same
    // time we do this, we reference the address. This ensures it does not
    // get removed out from under us. Note also that we do the address
    // lookup within a try/except clause, thus protecting ourselves against
    // really bogus handles
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_TRANSPORT_ADDRESS_FILE) {
        return STATUS_INVALID_ADDRESS;
    }

    addressFile = irpSp->FileObject->FsContext;

    status = NbfVerifyAddressObject (addressFile);

    if (!NT_SUCCESS (status)) {
        return status;
    }

#if DBG
    if (((PTDI_REQUEST_KERNEL_RECEIVEDG)(&irpSp->Parameters))->ReceiveLength > 0) {
        ASSERT (Irp->MdlAddress != NULL);
    }
#endif

    address = addressFile->Address;

    IoAcquireCancelSpinLock(&cancelIrql);
    ACQUIRE_SPIN_LOCK (&address->SpinLock,&oldirql);

    if ((address->Flags & (ADDRESS_FLAGS_STOPPING | ADDRESS_FLAGS_CONFLICT)) != 0) {

        RELEASE_SPIN_LOCK (&address->SpinLock,oldirql);
        IoReleaseCancelSpinLock(cancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = (address->Flags & ADDRESS_FLAGS_STOPPING) ?
                    STATUS_NETWORK_NAME_DELETED : STATUS_DUPLICATE_NAME;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    } else {

        //
        // If this IRP has been cancelled, then call the
        // cancel routine.
        //

        if (Irp->Cancel) {

            RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);
            IoReleaseCancelSpinLock(cancelIrql);

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

        } else {

            IoSetCancelRoutine(Irp, NbfCancelReceiveDatagram);
            NbfReferenceAddress ("Receive datagram", address, AREF_REQUEST);
            InsertTailList (&addressFile->ReceiveDatagramQueue,&Irp->Tail.Overlay.ListEntry);
            RELEASE_SPIN_LOCK (&address->SpinLock,oldirql);
            IoReleaseCancelSpinLock(cancelIrql);
        }

    }

    NbfDereferenceAddress ("Temp rcv datagram", address, AREF_VERIFY);

    return STATUS_PENDING;

} /* TdiReceiveDatagram */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\rcveng.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    rcveng.c

Abstract:

    This module contains code that implements the receive engine for the
    Jetbeui transport provider.  This code is responsible for the following
    basic activities:

    1.  Transitioning a TdiReceive request from an inactive state on the
        connection's ReceiveQueue to the active state on that connection
        (ActivateReceive).

    2.  Advancing the status of the active receive request by copying 0 or
        more bytes of data from an incoming DATA_FIRST_MIDDLE or DATA_ONLY_LAST
        NBF frame.

    3.  Completing receive requests.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
ActivateReceive(
    PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine activates the next TdiReceive request on the specified
    connection object if there is no active request on that connection
    already.  This allows the request to accept data on the connection.

    NOTE: THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    PIRP Irp;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint0 ("    ActivateReceive:  Entered.\n");
    }

    //
    // The ACTIVE_RECEIVE bitflag will be set on the connection if
    // the receive-fields in the CONNECTION object are valid.  If
    // this flag is cleared, then we try to make the next TdiReceive
    // request in the ReceiveQueue the active request.
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    if (!(Connection->Flags & CONNECTION_FLAGS_ACTIVE_RECEIVE)) {
        if (!IsListEmpty (&Connection->ReceiveQueue)) {

            //
            // Found a receive, so make it the active one.
            //

            Connection->Flags |= CONNECTION_FLAGS_ACTIVE_RECEIVE;

            Irp = CONTAINING_RECORD(
                      Connection->ReceiveQueue.Flink,
                      IRP,
                      Tail.Overlay.ListEntry);
            Connection->MessageBytesReceived = 0;
            Connection->MessageBytesAcked = 0;
            Connection->MessageInitAccepted = 0;
            Connection->CurrentReceiveIrp = Irp;
            Connection->CurrentReceiveSynchronous =
                Connection->Provider->MacInfo.SingleReceive;
            Connection->CurrentReceiveMdl = Irp->MdlAddress;
            Connection->ReceiveLength = IRP_RECEIVE_LENGTH(IoGetCurrentIrpStackLocation(Irp));
            Connection->ReceiveByteOffset = 0;
        }
    }
    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint0 ("    ActivateReceive:  Exiting.\n");
    }
} /* ActivateReceive */


VOID
AwakenReceive(
    PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine is called to reactivate a sleeping connection with the
    RECEIVE_WAKEUP bitflag set because data arrived for which no receive
    was available.  The caller has made a receive available at the connection,
    so here we activate the next receive, and send the appropriate protocol
    to restart the message at the first byte offset past the one received
    by the last receive.

    NOTE: THIS FUNCTION MUST BE CALLED AT DPC LEVEL. IT IS CALLED
    WITH CONNECTION->LINKSPINLOCK HELD.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint0 ("    AwakenReceive:  Entered.\n");
    }

    //
    // If the RECEIVE_WAKEUP bitflag is set, then awaken the connection.
    //

    if (Connection->Flags & CONNECTION_FLAGS_RECEIVE_WAKEUP) {
        if (Connection->ReceiveQueue.Flink != &Connection->ReceiveQueue) {
            Connection->Flags &= ~CONNECTION_FLAGS_RECEIVE_WAKEUP;

            //
            // Found a receive, so turn off the wakeup flag, activate
            // the next receive, and send the protocol.
            //

            //
            // Quick fix: So there is no window where a receive
            // is active but the bit is not on (otherwise we could
            // accept whatever data happens to show up in the
            // interim).
            //

            Connection->Flags |= CONNECTION_FLAGS_W_RESYNCH;

            NbfReferenceConnection ("temp AwakenReceive", Connection, CREF_BY_ID);   // release lookup hold.

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            ActivateReceive (Connection);

            //
            // What if this fails? The successful queueing
            // of a RCV_O should cause ActivateReceive to be called.
            //
            // NOTE: Send this after ActivateReceive, since that
            // is where the MessageBytesAcked/Received variables
            // are initialized.
            //

            NbfSendReceiveOutstanding (Connection);

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("    AwakenReceive:  Returned from NbfSendReceive.\n");
            }

            NbfDereferenceConnection("temp AwakenReceive", Connection, CREF_BY_ID);
            return;
        }
    }
    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
} /* AwakenReceive */


VOID
CompleteReceive(
    PTP_CONNECTION Connection,
    BOOLEAN EndOfMessage,
    IN ULONG BytesTransferred
    )

/*++

Routine Description:

    This routine is called by ProcessIncomingData when the current receive
    must be completed.  Depending on whether the current frame being
    processed is a DATA_FIRST_MIDDLE or DATA_ONLY_LAST, and also whether
    all of the data was processed, the EndOfMessage flag will be set accordingly
    by the caller to indicate that a message boundary was received.

    NOTE: THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    EndOfMessage - BOOLEAN set to true if TDI_END_OF_RECORD should be reported.

    BytesTransferred - Number of bytes copied in this receive.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p;
    PIRP Irp;
    ULONG BytesReceived;
    PIO_STACK_LOCATION IrpSp;

    IF_NBFDBG (NBF_DEBUG_RCVENG) {
        NbfPrint0 ("    CompleteReceive:  Entered.\n");
    }


    if (Connection->SpecialReceiveIrp) {

        PIRP Irp = Connection->SpecialReceiveIrp;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = BytesTransferred;

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        Connection->Flags |= CONNECTION_FLAGS_RC_PENDING;
        Connection->Flags &= ~CONNECTION_FLAGS_ACTIVE_RECEIVE;
        Connection->SpecialReceiveIrp = FALSE;

        ++Connection->ReceivedTsdus;

        ExInterlockedInsertHeadList(
            &Connection->Provider->IrpCompletionQueue,
            &Irp->Tail.Overlay.ListEntry,
            Connection->ProviderInterlock);

        //
        // NOTE: NbfAcknowledgeDataOnlyLast releases
        // the connection spinlock.
        //

        NbfAcknowledgeDataOnlyLast(
            Connection,
            Connection->MessageBytesReceived
            );

    } else {
        KIRQL cancelIrql;

        if (EndOfMessage) {

            //
            // The messages has been completely received, ack it.
            //
            // We set DEFERRED_ACK and DEFERRED_NOT_Q here, which
            // will cause an ack to be piggybacked if any data is
            // sent during the call to CompleteReceive. If this
            // does not happen, then we will call AcknowledgeDataOnlyLast
            // which will will send a DATA ACK or queue a request for
            // a piggyback ack. We do this *after* calling CompleteReceive
            // so we know that we will complete the receive back to
            // the client before we ack the data, to prevent the
            // next receive from being sent before this one is
            // completed.
            //

            IoAcquireCancelSpinLock(&cancelIrql);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->DeferredFlags |=
                (CONNECTION_FLAGS_DEFERRED_ACK | CONNECTION_FLAGS_DEFERRED_NOT_Q);
            Connection->Flags |= CONNECTION_FLAGS_RC_PENDING;

        } else {

            //
            // Send a receive outstanding (even though we don't
            // know that we have a receive) to get him to
            // reframe his send. Pre-2.0 clients require a
            // no receive before the receive outstanding.
            //
            // what if this fails (due to no send packets)?
            //

            if ((Connection->Flags & CONNECTION_FLAGS_VERSION2) == 0) {
                NbfSendNoReceive (Connection);
            }
            NbfSendReceiveOutstanding (Connection);

            //
            // If there is a receive posted, make it current and
            // send a receive outstanding.
            //
            // need general function for this, which sends NO_RECEIVE if appropriate.
            //

            ActivateReceive (Connection);

            IoAcquireCancelSpinLock(&cancelIrql);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        //
        // If we indicated to the client, adjust this down by the
        // amount of data taken, when it hits zero we can reindicate.
        //

        if (Connection->ReceiveBytesUnaccepted) {
            if (Connection->MessageBytesReceived >= Connection->ReceiveBytesUnaccepted) {
                Connection->ReceiveBytesUnaccepted = 0;
            } else {
                Connection->ReceiveBytesUnaccepted -= Connection->MessageBytesReceived;
            }
        }

        //
        // NOTE: The connection lock is held here.
        //

        if (IsListEmpty (&Connection->ReceiveQueue)) {

            ASSERT ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0);

            //
            // Release the cancel spinlock out of order. Since we were
            // already at DPC level when it was acquired, there is no
            // need to swap irqls.
            //
            ASSERT(cancelIrql == DISPATCH_LEVEL);
            IoReleaseCancelSpinLock(cancelIrql);

        } else {

            Connection->Flags &= ~CONNECTION_FLAGS_ACTIVE_RECEIVE;
            BytesReceived = Connection->MessageBytesReceived;


            //
            // Complete the TdiReceive request at the head of the
            // connection's ReceiveQueue.
            //

            IF_NBFDBG (NBF_DEBUG_RCVENG) {
                NbfPrint0 ("    CompleteReceive:  Normal IRP is present.\n");
            }

            p = RemoveHeadList (&Connection->ReceiveQueue);
            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

            IoSetCancelRoutine(Irp, NULL);

            //
            // Release the cancel spinlock out of order. Since we were
            // already at DPC level when it was acquired, there is no
            // need to swap irqls.
            //
            ASSERT(cancelIrql == DISPATCH_LEVEL);
            IoReleaseCancelSpinLock(cancelIrql);

            //
            // If this request should generate no back traffic, then
            // disable piggyback acks for it.
            //

            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            if (IRP_RECEIVE_FLAGS(IrpSp) & TDI_RECEIVE_NO_RESPONSE_EXP) {
                Connection->CurrentReceiveAckQueueable = FALSE;
            }

#if DBG
            NbfCompletedReceives[NbfCompletedReceivesNext].Irp = Irp;
            NbfCompletedReceives[NbfCompletedReceivesNext].Request = NULL;
            NbfCompletedReceives[NbfCompletedReceivesNext].Status =
                EndOfMessage ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;
            {
                ULONG i,j,k;
                PUCHAR va;
                PMDL mdl;

                mdl = Irp->MdlAddress;

                if (BytesReceived > TRACK_TDI_CAPTURE) {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = 0xFF;
                } else {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = (UCHAR)BytesReceived;
                }

                i = 1;
                while (i<TRACK_TDI_CAPTURE) {
                    if (mdl == NULL) break;
                    va = MmGetSystemAddressForMdl (mdl);
                    j = MmGetMdlByteCount (mdl);

                    for (i=i,k=0;(i<TRACK_TDI_CAPTURE)&&(k<j);i++,k++) {
                        NbfCompletedReceives[NbfCompletedReceivesNext].Contents[i] = *va++;
                    }
                    mdl = mdl->Next;
                }
            }

            NbfCompletedReceivesNext = (NbfCompletedReceivesNext++) % TRACK_TDI_LIMIT;
#endif
            ++Connection->ReceivedTsdus;

            //
            // This can be called with locks held.
            //
            NbfCompleteReceiveIrp(
                Irp,
                EndOfMessage ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW,
                BytesReceived);

        }


        //
        // If NOT_Q is still set, that means that the deferred ack was
        // not satisfied by anything resulting from the call to
        // CompleteReceive, so we need to ack or queue an ack here.
        //


        if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_NOT_Q) != 0) {

            Connection->DeferredFlags &=
                ~(CONNECTION_FLAGS_DEFERRED_ACK | CONNECTION_FLAGS_DEFERRED_NOT_Q);

            //
            // NOTE: NbfAcknowledgeDataOnlyLast releases
            // the connection spinlock.
            //

            NbfAcknowledgeDataOnlyLast(
                Connection,
                Connection->MessageBytesReceived
                );

        } else {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

    }

} /* CompleteReceive */


VOID
NbfCancelReceive(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a receive.
    The receive is found on the connection's receive queue; if it
    is the current request it is cancelled and the connection
    goes into "cancelled receive" mode, otherwise it is cancelled
    silently.

    In "cancelled receive" mode the connection makes it appear to
    the remote the data is being received, but in fact it is not
    indicated to the transport or buffered on our end

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PIO_STACK_LOCATION IrpSp;
    PIRP ReceiveIrp;
    PTP_CONNECTION Connection;
    PLIST_ENTRY p;
    ULONG BytesReceived;
    BOOLEAN Found;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_RECEIVE));

    Connection = IrpSp->FileObject->FsContext;

    //
    // Since this IRP is still in the cancellable state, we know
    // that the connection is still around (although it may be in
    // the process of being torn down).
    //

    //
    // See if this is the IRP for the current receive request.
    //

    ACQUIRE_SPIN_LOCK (Connection->LinkSpinLock, &oldirql);

    BytesReceived = Connection->MessageBytesReceived;

    p = Connection->ReceiveQueue.Flink;

    //
    // If there is a receive active and it is not a special
    // IRP, then see if this is it.
    //

    if (((Connection->Flags & CONNECTION_FLAGS_ACTIVE_RECEIVE) != 0) &&
        (!Connection->SpecialReceiveIrp)) {

        ReceiveIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

        if (ReceiveIrp == Irp) {

            //
            // yes, it is the active receive. Turn on the RCV_CANCELLED
            // bit instructing the connection to drop the rest of the
            // data received (until the DOL comes in).
            //

            Connection->Flags |= CONNECTION_FLAGS_RCV_CANCELLED;
            Connection->Flags &= ~CONNECTION_FLAGS_ACTIVE_RECEIVE;

            (VOID)RemoveHeadList (&Connection->ReceiveQueue);

#if DBG
            NbfCompletedReceives[NbfCompletedReceivesNext].Irp = ReceiveIrp;
            NbfCompletedReceives[NbfCompletedReceivesNext].Request = NULL;
            NbfCompletedReceives[NbfCompletedReceivesNext].Status = STATUS_CANCELLED;
            {
                ULONG i,j,k;
                PUCHAR va;
                PMDL mdl;

                mdl = ReceiveIrp->MdlAddress;

                if (BytesReceived > TRACK_TDI_CAPTURE) {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = 0xFF;
                } else {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = (UCHAR)BytesReceived;
                }

                i = 1;
                while (i<TRACK_TDI_CAPTURE) {
                    if (mdl == NULL) break;
                    va = MmGetSystemAddressForMdl (mdl);
                    j = MmGetMdlByteCount (mdl);

                    for (i=i,k=0;(i<TRACK_TDI_CAPTURE)&&(k<j);i++,k++) {
                        NbfCompletedReceives[NbfCompletedReceivesNext].Contents[i] = *va++;
                    }
                    mdl = mdl->Next;
                }
            }

            NbfCompletedReceivesNext = (NbfCompletedReceivesNext++) % TRACK_TDI_LIMIT;
#endif

            RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
            IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
            DbgPrint("NBF: Canceled in-progress receive %lx on %lx\n",
                    Irp, Connection);
#endif

            //
            // The following dereference will complete the I/O, provided removes
            // the last reference on the request object.  The I/O will complete
            // with the status and information stored in the Irp.  Therefore,
            // we set those values here before the dereference.
            //

            NbfCompleteReceiveIrp (ReceiveIrp, STATUS_CANCELLED, 0);
            return;

        }

    }


    //
    // If we fall through to here, the IRP was not the active receive.
    // Scan through the list, looking for this IRP.
    //

    Found = FALSE;

    while (p != &Connection->ReceiveQueue) {

        ReceiveIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        if (ReceiveIrp == Irp) {

            //
            // Found it, remove it from the list here.
            //

            RemoveEntryList (p);

            Found = TRUE;

#if DBG
            NbfCompletedReceives[NbfCompletedReceivesNext].Irp = ReceiveIrp;
            NbfCompletedReceives[NbfCompletedReceivesNext].Request = NULL;
            NbfCompletedReceives[NbfCompletedReceivesNext].Status = STATUS_CANCELLED;
            {
                ULONG i,j,k;
                PUCHAR va;
                PMDL mdl;

                mdl = ReceiveIrp->MdlAddress;

                if (BytesReceived > TRACK_TDI_CAPTURE) {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = 0xFF;
                } else {
                    NbfCompletedReceives[NbfCompletedReceivesNext].Contents[0] = (UCHAR)BytesReceived;
                }

                i = 1;
                while (i<TRACK_TDI_CAPTURE) {
                    if (mdl == NULL) break;
                    va = MmGetSystemAddressForMdl (mdl);
                    j = MmGetMdlByteCount (mdl);

                    for (i=i,k=0;(i<TRACK_TDI_CAPTURE)&&(k<j);i++,k++) {
                        NbfCompletedReceives[NbfCompletedReceivesNext].Contents[i] = *va++;
                    }
                    mdl = mdl->Next;
                }
            }

            NbfCompletedReceivesNext = (NbfCompletedReceivesNext++) % TRACK_TDI_LIMIT;
#endif

            RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
            IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
            DbgPrint("NBF: Canceled receive %lx on %lx\n",
                    ReceiveIrp, Connection);
#endif

            //
            // The following dereference will complete the I/O, provided removes
            // the last reference on the request object.  The I/O will complete
            // with the status and information stored in the Irp.  Therefore,
            // we set those values here before the dereference.
            //

            NbfCompleteReceiveIrp (ReceiveIrp, STATUS_CANCELLED, 0);
            break;

        }

        p = p->Flink;

    }

    if (!Found) {

        //
        // We didn't find it!
        //

#if DBG
        DbgPrint("NBF: Tried to cancel receive %lx on %lx, not found\n",
                Irp, Connection);
#endif
        RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }

}


VOID
NbfCancelReceiveDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a receive
    datagram. The receive is looked for on the address file's
    receive datagram queue; if it is found it is cancelled.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PIO_STACK_LOCATION IrpSp;
    PTP_ADDRESS_FILE AddressFile;
    PTP_ADDRESS Address;
    PLIST_ENTRY p;
    BOOLEAN Found;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_RECEIVE_DATAGRAM));

    AddressFile = IrpSp->FileObject->FsContext;
    Address = AddressFile->Address;

    //
    // Since this IRP is still in the cancellable state, we know
    // that the address file is still around (although it may be in
    // the process of being torn down). See if the IRP is on the list.
    //

    Found = FALSE;

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    for (p = AddressFile->ReceiveDatagramQueue.Flink;
        p != &AddressFile->ReceiveDatagramQueue;
        p = p->Flink) {

        if (CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry) == Irp) {
            RemoveEntryList (p);
            Found = TRUE;
            break;
        }
    }

    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    if (Found) {

#if DBG
        DbgPrint("NBF: Canceled receive datagram %lx on %lx\n",
                Irp, AddressFile);
#endif

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

        NbfDereferenceAddress ("Receive DG cancelled", Address, AREF_REQUEST);

    } else {

#if DBG
        DbgPrint("NBF: Tried to cancel receive datagram %lx on %lx, not found\n",
                Irp, AddressFile);
#endif

    }

}   /* NbfCancelReceiveDatagram */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\request.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    request.c

Abstract:

    This module contains code which implements the TP_REQUEST object.
    Routines are provided to create, destroy, reference, and dereference,
    transport request objects.

Author:

    David Beaver (dbeaver) 1 July 1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL

//
// External variables
//
#ifdef RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

//
// Imported routines
//
VOID
NbfNoteNewConnection(
    PTP_CONNECTION Connection,
    PDEVICE_CONTEXT DeviceContext
    );
#endif // RASAUTODIAL


VOID
NbfTdiRequestTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is executed as a DPC at DISPATCH_LEVEL when a request
    such as TdiSend, TdiReceive, TdiSendDatagram, TdiReceiveDatagram, etc.,
    encounters a timeout.  This routine cleans up the activity and cancels it.

Arguments:

    Dpc - Pointer to a system DPC object.

    DeferredContext - Pointer to the TP_REQUEST block representing the
        request that has timed out.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PTP_REQUEST Request;
    PTP_CONNECTION Connection;
#if DBG
    LARGE_INTEGER time, difference;
#endif
    PIO_STACK_LOCATION IrpSp;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION query;
    PDEVICE_CONTEXT DeviceContext;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    Request = (PTP_REQUEST)DeferredContext;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("RequestTimeoutHandler:  Entered, Request %lx\n", Request);
    }

    ACQUIRE_SPIN_LOCK (&Request->SpinLock, &oldirql);
    Request->Flags &= ~REQUEST_FLAGS_TIMER;
    if ((Request->Flags & REQUEST_FLAGS_STOPPING) == 0) {

#if DBG
        KeQuerySystemTime (&time);
        difference.QuadPart = time.QuadPart - (Request->Time).QuadPart;
        NbfPrint1 ("RequestTimeoutHandler: Request timed out, queued for %ld seconds\n",
                difference.LowPart / SECONDS);
#endif

        //
        // find reason for timeout
        //

        IrpSp = IoGetCurrentIrpStackLocation (Request->IoRequestPacket);
        if (IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) {
            switch (IrpSp->MinorFunction) {

                //
                // none of these should time out.
                //

            case TDI_SEND:
            case TDI_ACCEPT:
            case TDI_SET_INFORMATION:
            case TDI_SET_EVENT_HANDLER:
            case TDI_SEND_DATAGRAM:
            case TDI_RECEIVE_DATAGRAM:
            case TDI_RECEIVE:

#if DBG
                NbfPrint1 ("RequestTimeoutHandler: Request: %lx Timed out, and shouldn't have!\n",
                        Request);
#endif
                ASSERT (FALSE);
                RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
                NbfCompleteRequest (Request, STATUS_IO_TIMEOUT, 0);
                break;


            case TDI_LISTEN:
            case TDI_CONNECT:

#if DBG
                NbfPrint2 ("RequestTimeoutHandler:  %s Failed, Request: %lx\n",
                            IrpSp->MinorFunction == TDI_LISTEN ?
                                "Listen" :
                                IrpSp->MinorFunction == TDI_CONNECT ?
                                    "Connect" : "Disconnect",
                            Request);
#endif
                Connection = (PTP_CONNECTION)(Request->Context);
                RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

                //
                // Since these requests are part of the connection
                // itself, we just stop the connection and the
                // request will get torn down then. If we get the
                // situation where the request times out before
                // it is queued to the connection, then the code
                // that is about to queue it will check the STOPPING
                // flag and complete it then.
                //
                // Don't stop the connection if an automatic connection
                // is in progress.
                //

#if DBG
                DbgPrint("RequestTimeoutHandler: AUTOCONNECTING=0x%x\n", Connection->Flags2 & CONNECTION_FLAGS2_AUTOCONNECTING);
#endif
                if (!(Connection->Flags2 & CONNECTION_FLAGS2_AUTOCONNECTING))
                    NbfStopConnection (Connection, STATUS_IO_TIMEOUT);
                break;

            case TDI_DISCONNECT:

                //
                // We don't create requests for TDI_DISCONNECT any more.
                //

                ASSERT(FALSE);
                break;

            case TDI_QUERY_INFORMATION:

                DeviceContext = (PDEVICE_CONTEXT)IrpSp->FileObject->DeviceObject;
                query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&IrpSp->Parameters;

                IF_NBFDBG (NBF_DEBUG_DEVCTX) {
                    NbfPrint1 ("RequestTimeout: %lx:\n", DeviceContext);
                }

                //
                // Determine if the request is done, or if we should
                // requeue it.
                //

                --Request->Retries;

                if (Request->Retries > 0) {

                    RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

                    //
                    // Send another packet out, and restart the timer.
                    //

                    if (query->QueryType == TDI_QUERY_FIND_NAME) {

                        NbfSendQueryFindName (
                            DeviceContext,
                            Request);

                    } else if (query->QueryType == TDI_QUERY_ADAPTER_STATUS) {

                        PUCHAR SingleSR;
                        UINT SingleSRLength;

                        //
                        // Send the STATUS_QUERY frames out as
                        // single-route source routing.
                        //
                        // On a second status query this should
                        // really be sent directed, but currently we
                        // don't record the address anywhere.
                        //

                        MacReturnSingleRouteSR(
                            &DeviceContext->MacInfo,
                            &SingleSR,
                            &SingleSRLength);

                        NbfSendStatusQuery (
                            DeviceContext,
                            Request,
                            &DeviceContext->NetBIOSAddress,
                            SingleSR,
                            SingleSRLength);

                    } else {

                        ASSERT (FALSE);

                    }

                } else {

                    RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

                    //
                    // That's it, we retried enough, complete it.
                    //

                    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);
                    RemoveEntryList (&Request->Linkage);
                    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

                    if (Request->BytesWritten > 0) {

                        NbfCompleteRequest (Request, STATUS_SUCCESS, Request->BytesWritten);

                    } else {

                        NbfCompleteRequest (Request, STATUS_IO_TIMEOUT, Request->BytesWritten);

                    }


                }

                break;

            default:
#if DBG
                NbfPrint2 ("RequestTimeoutHandler:  Unknown Request Timed out, Request: %lx Type: %x\n",
                            Request, IrpSp->MinorFunction);
#endif
                RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
                break;

            }   // end of switch

        } else {

            RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

        }

        NbfDereferenceRequest ("Timeout", Request, RREF_TIMER);             // for the timeout

    } else {

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        NbfDereferenceRequest ("Timeout: stopping", Request, RREF_TIMER); // for the timeout

    }

    LEAVE_NBF;
    return;

} /* RequestTimeoutHandler */


VOID
NbfAllocateRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_REQUEST *TransportRequest
    )

/*++

Routine Description:

    This routine allocates a request packet from nonpaged pool and initializes
    it to a known state.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    TransportRequest - Pointer to a place where this routine will return
        a pointer to a transport request structure. It returns NULL if no
        storage can be allocated.

Return Value:

    None.

--*/

{
    PTP_REQUEST Request;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + sizeof(TP_REQUEST)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate request: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            104,
            sizeof(TP_REQUEST),
            REQUEST_RESOURCE_ID);
        *TransportRequest = NULL;
        return;
    }

    Request = (PTP_REQUEST)ExAllocatePoolWithTag (
                               NonPagedPool,
                               sizeof (TP_REQUEST),
                               NBF_MEM_TAG_TP_REQUEST);
    if (Request == NULL) {
        PANIC("NBF: Could not allocate request: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            204,
            sizeof(TP_REQUEST),
            REQUEST_RESOURCE_ID);
        *TransportRequest = NULL;
        return;
    }
    RtlZeroMemory (Request, sizeof(TP_REQUEST));

    DeviceContext->MemoryUsage += sizeof(TP_REQUEST);
    ++DeviceContext->RequestAllocated;

    Request->Type = NBF_REQUEST_SIGNATURE;
    Request->Size = sizeof (TP_REQUEST);

    Request->ResponseBuffer = NULL;

    Request->Provider = DeviceContext;
    Request->ProviderInterlock = &DeviceContext->Interlock;
    KeInitializeSpinLock (&Request->SpinLock);
    KeInitializeDpc (&Request->Dpc, NbfTdiRequestTimeoutHandler, (PVOID)Request);
    KeInitializeTimer (&Request->Timer);    // set to not-signaled state.

    *TransportRequest = Request;

}   /* NbfAllocateRequest */


VOID
NbfDeallocateRequest(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_REQUEST TransportRequest
    )

/*++

Routine Description:

    This routine frees a request packet.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    TransportRequest - Pointer to a transport request structure.

Return Value:

    None.

--*/

{

    ExFreePool (TransportRequest);
    --DeviceContext->RequestAllocated;
    DeviceContext->MemoryUsage -= sizeof(TP_REQUEST);

}   /* NbfDeallocateRequest */


NTSTATUS
NbfCreateRequest(
    IN PIRP Irp,
    IN PVOID Context,
    IN ULONG Flags,
    IN PMDL Buffer2,
    IN ULONG Buffer2Length,
    IN LARGE_INTEGER Timeout,
    OUT PTP_REQUEST * TpRequest
    )

/*++

Routine Description:

    This routine creates a transport request and associates it with the
    specified IRP, context, and queue.  All major requests, including
    TdiSend, TdiSendDatagram, TdiReceive, and TdiReceiveDatagram requests,
    are composed in this manner.

Arguments:

    Irp - Pointer to an IRP which was received by the transport for this
        request.

    Context - Pointer to anything to associate this request with.  This
        value is not interpreted except at request cancelation time.

    Flags - A set of bitflags indicating the disposition of this request.

    Timeout - Timeout value (if non-zero) to start a timer for this request.
        If zero, then no timer is activated for the request.

    TpRequest - If the function returns STATUS_SUCCESS, this will return
        pointer to the TP_REQUEST structure allocated.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PDEVICE_CONTEXT DeviceContext;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    PIO_STACK_LOCATION irpSp;
#if DBG
    LARGE_INTEGER Time;
#endif

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint0 ("NbfCreateRequest:  Entered.\n");
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    DeviceContext = (PDEVICE_CONTEXT)irpSp->FileObject->DeviceObject;

#if DBG
    if (!MmIsNonPagedSystemAddressValid (DeviceContext->RequestPool.Flink)) {
        NbfPrint2 ("NbfCreateRequest: RequestList hosed: %lx DeviceContext: %lx\n",
                &DeviceContext->RequestPool, DeviceContext);
    }
#endif

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    p = RemoveHeadList (&DeviceContext->RequestPool);
    if (p == &DeviceContext->RequestPool) {

        if ((DeviceContext->RequestMaxAllocated == 0) ||
            (DeviceContext->RequestAllocated < DeviceContext->RequestMaxAllocated)) {

            NbfAllocateRequest (DeviceContext, &Request);
            IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
                NbfPrint1 ("NBF: Allocated request at %lx\n", Request);
            }

        } else {

            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_SPECIFIC,
                404,
                sizeof(TP_REQUEST),
                REQUEST_RESOURCE_ID);
            Request = NULL;

        }

        if (Request == NULL) {
            ++DeviceContext->RequestExhausted;
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
            PANIC ("NbfCreateConnection: Could not allocate request object!\n");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);

    }

    ++DeviceContext->RequestInUse;
    if (DeviceContext->RequestInUse > DeviceContext->RequestMaxInUse) {
        ++DeviceContext->RequestMaxInUse;
    }

    DeviceContext->RequestTotal += DeviceContext->RequestInUse;
    ++DeviceContext->RequestSamples;

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);


    //
    // fill out the request.
    //

    // Request->Provider = DeviceContext;
    Request->IoRequestPacket = Irp;
    Request->Buffer2 = Buffer2;
    Request->Buffer2Length = Buffer2Length;
    Request->Flags = Flags;
    Request->Context = Context;
    Request->ReferenceCount = 1;                // initialize reference count.

#if DBG
    {
        UINT Counter;
        for (Counter = 0; Counter < NUMBER_OF_RREFS; Counter++) {
            Request->RefTypes[Counter] = 0;
        }

        // This reference is removed by NbfCompleteRequest

        Request->RefTypes[RREF_CREATION] = 1;
    }
#endif

#if DBG
    Request->Completed = FALSE;
    Request->Destroyed = FALSE;
    Request->TotalReferences = 0;
    Request->TotalDereferences = 0;
    Request->NextRefLoc = 0;
    ExInterlockedInsertHeadList (&NbfGlobalRequestList, &Request->GlobalLinkage, &NbfGlobalInterlock);
    StoreRequestHistory (Request, TRUE);
#endif

#if DBG
    KeQuerySystemTime (&Time);      // ugly, but effective
    Request->Time.LowPart = Time.LowPart;
    Request->Time.HighPart = Time.HighPart;
#endif

    IF_NBFDBG (NBF_DEBUG_IRP) {
        if (Irp->MdlAddress != NULL) {
            PMDL mdl;
            NbfPrint2 ("NbfCreateRequest: Map request %lx Irp %lx MdlChain \n",
                Request, Request->IoRequestPacket);
            mdl = Request->Buffer2;
            while (mdl != NULL) {
                NbfPrint4 ("Mdl %lx Va %lx StartVa %lx Flags %x\n",
                    mdl, MmGetSystemAddressForMdl(mdl), MmGetMdlVirtualAddress(mdl),
                    mdl->MdlFlags);
                mdl = mdl->Next;
            }
        }
    }

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint3 ("NbfCreateRequest: Request %lx Buffer2: %lx Irp: %lx\n", Request,
           Buffer2, Irp);
    }

    if ((Timeout.LowPart == 0) && (Timeout.HighPart == 0)) {

        // no timeout
    } else {

        IF_NBFDBG (NBF_DEBUG_REQUEST) {
            NbfPrint3 ("NbfCreateRequest: Starting timer %lx%lx Flags %lx\n",
                Timeout.HighPart, Timeout.LowPart, Request->Flags);
        }
        Request->Flags |= REQUEST_FLAGS_TIMER;  // there is a timeout on this request.
        KeInitializeTimer (&Request->Timer);    // set to not-signaled state.
        NbfReferenceRequest ("Create: timer", Request, RREF_TIMER);           // one for the timer
        KeSetTimer (&Request->Timer, Timeout, &Request->Dpc);
    }

    *TpRequest = Request;

    return STATUS_SUCCESS;
} /* NbfCreateRequest */


VOID
NbfDestroyRequest(
    IN PTP_REQUEST Request
    )

/*++

Routine Description:

    This routine returns a request block to the free pool.

Arguments:

    Request - Pointer to a TP_REQUEST block to return to the free pool.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint0 ("NbfDestroyRequest:  Entered.\n");
    }

#if DBG
    if (Request->Destroyed) {
        NbfPrint1 ("attempt to destroy already-destroyed request 0x%lx\n", Request);
        DbgBreakPoint ();
    }
    Request->Destroyed = TRUE;
#if 1
    ACQUIRE_SPIN_LOCK (&NbfGlobalInterlock, &oldirql);
    RemoveEntryList (&Request->GlobalLinkage);
    RELEASE_SPIN_LOCK (&NbfGlobalInterlock, oldirql);
#else
    ExInterlockedRemoveHeadList (Request->GlobalLinkage.Blink, &NbfGlobalInterlock);
#endif
#endif
    ASSERT(Request->Completed);

    //
    // Return the request to the caller with whatever status is in the IRP.
    //

    IF_NBFDBG (NBF_DEBUG_IRP) {
        NbfPrint1 ("NbfCompleteRequest: Completing IRP: %lx\n",
            Request->IoRequestPacket);
    }

    //
    // Now dereference the owner of this request so that we are safe when
    // we finally tear down the {connection, address}. The problem we're
    // facing here is that we can't allow the user to assume semantics;
    // the end of life for a connection must truly be the real end of life.
    // for that to occur, we reference the owning object when the request is
    // created and we dereference it just before we return it to the pool.
    //

    switch (Request->Owner) {
    case ConnectionType:
        NbfDereferenceConnection ("Removing Connection",((PTP_CONNECTION)Request->Context), CREF_REQUEST);
        break;

#if DBG
    case AddressType:
        ASSERT (FALSE);
        NbfDereferenceAddress ("Removing Address", ((PTP_ADDRESS)Request->Context), AREF_REQUEST);
        break;
#endif

    case DeviceContextType:
        NbfDereferenceDeviceContext ("Removing Address", ((PDEVICE_CONTEXT)Request->Context), DCREF_REQUEST);
        break;
    }

    //
    // Unmap a possibly mapped buffer. We've only mapped the buffer if the
    // Irp Major function is not method 0. (of 0, 1, 2, and 3.)
    //

    IF_NBFDBG (NBF_DEBUG_IRP) {
        {
            PMDL mdl;
            NbfPrint2 ("NbfDestroyRequest: Unmap request %lx Irp %lx MdlChain \n",
                Request, Request->IoRequestPacket);
            mdl = Request->Buffer2;
            while (mdl != NULL) {
                NbfPrint4 ("Mdl %lx Va %lx StartVa %lx Flags %x\n",
                    mdl, MmGetSystemAddressForMdl(mdl), MmGetMdlVirtualAddress(mdl),
                    mdl->MdlFlags);
                mdl = mdl->Next;
            }
        }
    }

    irpSp = IoGetCurrentIrpStackLocation (Request->IoRequestPacket);
    DeviceContext = Request->Provider;

    LEAVE_NBF;
    IoCompleteRequest (Request->IoRequestPacket, IO_NETWORK_INCREMENT);
    ENTER_NBF;

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    //
    // Put the request back on the free list. NOTE: we have the
    // lock held here.
    //


    DeviceContext->RequestTotal += DeviceContext->RequestInUse;
    ++DeviceContext->RequestSamples;
    --DeviceContext->RequestInUse;

    if ((DeviceContext->RequestAllocated - DeviceContext->RequestInUse) >
            DeviceContext->RequestInitAllocated) {
        NbfDeallocateRequest (DeviceContext, Request);
        IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
            NbfPrint1 ("NBF: Deallocated request at %lx\n", Request);
        }
    } else {
        InsertTailList (&DeviceContext->RequestPool, &Request->Linkage);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

} /* NbfDestroyRequest */


#if DBG
VOID
NbfRefRequest(
    IN PTP_REQUEST Request
    )

/*++

Routine Description:

    This routine increments the reference count on a transport request.

Arguments:

    Request - Pointer to a TP_REQUEST block.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfRefRequest:  Entered, ReferenceCount: %x\n",
            Request->ReferenceCount);
    }

#if DBG
    StoreRequestHistory( Request, TRUE );
#endif

    ASSERT (Request->ReferenceCount > 0);

    result = InterlockedIncrement (&Request->ReferenceCount);

} /* NbfRefRequest */
#endif


VOID
NbfDerefRequest(
    IN PTP_REQUEST Request
    )

/*++

Routine Description:

    This routine dereferences a transport request by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbfDestroyRequest to remove it from the system.

Arguments:

    Request - Pointer to a transport request object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfDerefRequest:  Entered, ReferenceCount: %x\n",
            Request->ReferenceCount);
    }

#if DBG
    StoreRequestHistory( Request, FALSE );
#endif

    result = InterlockedDecrement (&Request->ReferenceCount);

    ASSERT (result >= 0);

    //
    // If we have deleted all references to this request, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the request any longer.
    //

    if (result == 0) {
        NbfDestroyRequest (Request);
    }

} /* NbfDerefRequest */


VOID
NbfCompleteRequest(
    IN PTP_REQUEST Request,
    IN NTSTATUS Status,
    IN ULONG Information
    )

/*++

Routine Description:

    This routine completes a transport request object, completing the I/O,
    stopping the timeout, and freeing up the request object itself.

Arguments:

    Request - Pointer to a transport request object.

    Status - Actual return status to be assigned to the request.  This
        value may be overridden if the timed-out bitflag is set in the request.

    Information - the information field for the I/O Status Block.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS FinalStatus = Status;
    NTSTATUS CopyStatus;
    BOOLEAN TimerWasSet;

    ASSERT (Status != STATUS_PENDING);

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint2 ("NbfCompleteRequest:  Entered Request %lx, Request->Flags %lx\n",
                    Request, Request->Flags);
    }

#if DBG
    if (Request->Completed) {
        NbfPrint1 ("attempt to completed already-completed request 0x%lx\n", Request);
        DbgBreakPoint ();
    }
    Request->Completed = TRUE;
#endif

    ACQUIRE_SPIN_LOCK (&Request->SpinLock, &oldirql);

    if ((Request->Flags & REQUEST_FLAGS_STOPPING) == 0) {
        Request->Flags |= REQUEST_FLAGS_STOPPING;

        //
        // Cancel the pending timeout on this request.  Not all requests
        // have their timer set.  If this request has the TIMER bit set,
        // then the timer needs to be cancelled.  If it cannot be cancelled,
        // then the timer routine will be run, so we just return and let
        // the timer routine worry about cleaning up this request.
        //

        if ((Request->Flags & REQUEST_FLAGS_TIMER) != 0) {
            Request->Flags &= ~REQUEST_FLAGS_TIMER;
            RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
            TimerWasSet = KeCancelTimer (&Request->Timer);

            if (TimerWasSet) {
                NbfDereferenceRequest ("Complete: stop timer", Request, RREF_TIMER);
                IF_NBFDBG (NBF_DEBUG_REQUEST) {
                    NbfPrint1 ("NbfCompleteRequest:  Canceled timer: %lx.\n", &Request->Timer);
                }
            }

        } else {
            RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);
        }

        Irp = Request->IoRequestPacket;

#ifdef RASAUTODIAL
        //
        // If this is a connect operation that has
        // returned with either STATUS_SUCCESS or
        // STATUS_BAD_NETWORK_PATH, then
        // inform the automatic connection driver.
        //
        if (fAcdLoadedG) {
            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            if (IrpSp->MinorFunction == TDI_CONNECT &&
                FinalStatus == STATUS_SUCCESS)
            {
                KIRQL adirql;
                BOOLEAN fEnabled;

                ACQUIRE_SPIN_LOCK(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                RELEASE_SPIN_LOCK(&AcdDriverG.SpinLock, adirql);
                if (fEnabled) {
                    NbfNoteNewConnection(
                      IrpSp->FileObject->FsContext,
                      (PDEVICE_CONTEXT)IrpSp->FileObject->DeviceObject);
                }
            }
        }
#endif // RASAUTODIAL

        //
        // For requests associated with a device context, we need
        // to copy the data from the temp buffer to the MDL and
        // free the temp buffer.
        //

        if (Request->ResponseBuffer != NULL) {

            if ((FinalStatus == STATUS_SUCCESS) ||
                (FinalStatus == STATUS_BUFFER_OVERFLOW)) {

                CopyStatus = TdiCopyBufferToMdl (
                                Request->ResponseBuffer,
                                0L,
                                Information,
                                Irp->MdlAddress,
                                0,
                                &Information);

                if (CopyStatus != STATUS_SUCCESS) {
                    FinalStatus = CopyStatus;
                }

            }

            ExFreePool (Request->ResponseBuffer);
            Request->ResponseBuffer = NULL;

        }

        //
        // Install the return code in the IRP so that when we call NbfDestroyRequest,
        // it will get completed with the proper return status.
        //

        Irp->IoStatus.Status = FinalStatus;
        Irp->IoStatus.Information = Information;

        //
        // The entire transport is done with this request.
        //

        NbfDereferenceRequest ("Complete", Request, RREF_CREATION);     // remove creation reference.

    } else {

        RELEASE_SPIN_LOCK (&Request->SpinLock, oldirql);

    }

} /* NbfCompleteRequest */


#if DBG
VOID
NbfRefSendIrp(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine increments the reference count on a send IRP.

Arguments:

    IrpSp - Pointer to the IRP's stack location.

Return Value:

    none.

--*/

{

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfRefSendIrp:  Entered, ReferenceCount: %x\n",
            IRP_SEND_REFCOUNT(IrpSp));
    }

    ASSERT (IRP_SEND_REFCOUNT(IrpSp) > 0);

    InterlockedIncrement (&IRP_SEND_REFCOUNT(IrpSp));

} /* NbfRefSendIrp */


VOID
NbfDerefSendIrp(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dereferences a transport send IRP by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IoCompleteRequest to actually complete the IRP.

Arguments:

    Request - Pointer to a transport send IRP's stack location.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfDerefSendIrp:  Entered, ReferenceCount: %x\n",
            IRP_SEND_REFCOUNT(IrpSp));
    }

    result = InterlockedDecrement (&IRP_SEND_REFCOUNT(IrpSp));

    ASSERT (result >= 0);

    //
    // If we have deleted all references to this request, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the request any longer.
    //

    if (result == 0) {

        PIRP Irp = IRP_SEND_IRP(IrpSp);

        IRP_SEND_REFCOUNT(IrpSp) = 0;
        IRP_SEND_IRP (IrpSp) = NULL;

        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    }

} /* NbfDerefSendIrp */
#endif


VOID
NbfCompleteSendIrp(
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    )

/*++

Routine Description:

    This routine completes a transport send IRP.

Arguments:

    Irp - Pointer to a send IRP.

    Status - Actual return status to be assigned to the request.  This
        value may be overridden if the timed-out bitflag is set in the request.

    Information - the information field for the I/O Status Block.

Return Value:

    none.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PTP_CONNECTION Connection;

    ASSERT (Status != STATUS_PENDING);

    Connection = IRP_SEND_CONNECTION(IrpSp);

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint2 ("NbfCompleteSendIrp:  Entered IRP %lx, connection %lx\n",
            Irp, Connection);
    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Information;

    NbfDereferenceSendIrp ("Complete", IrpSp, RREF_CREATION);     // remove creation reference.

    NbfDereferenceConnectionMacro ("Removing Connection", Connection, CREF_SEND_IRP);

} /* NbfCompleteSendIrp */


#if DBG
VOID
NbfRefReceiveIrpLocked(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine increments the reference count on a receive IRP.

Arguments:

    IrpSp - Pointer to the IRP's stack location.

Return Value:

    none.

--*/

{

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfRefReceiveIrpLocked:  Entered, ReferenceCount: %x\n",
            IRP_RECEIVE_REFCOUNT(IrpSp));
    }

    ASSERT (IRP_RECEIVE_REFCOUNT(IrpSp) > 0);

    IRP_RECEIVE_REFCOUNT(IrpSp)++;

} /* NbfRefReceiveIrpLocked */
#endif


VOID
NbfDerefReceiveIrp(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dereferences a transport receive IRP by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IoCompleteRequest to actually complete the IRP.

Arguments:

    Request - Pointer to a transport receive IRP's stack location.

Return Value:

    none.

--*/

{
    ULONG result;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfDerefReceiveIrp:  Entered, ReferenceCount: %x\n",
            IRP_RECEIVE_REFCOUNT(IrpSp));
    }

    result = ExInterlockedAddUlong (
                (PULONG)&IRP_RECEIVE_REFCOUNT(IrpSp),
                (ULONG)-1,
                (IRP_RECEIVE_CONNECTION(IrpSp)->LinkSpinLock));

    ASSERT (result > 0);

    //
    // If we have deleted all references to this request, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the request any longer.
    //

    if (result == 1) {

        PIRP Irp = IRP_RECEIVE_IRP(IrpSp);

        ExInterlockedInsertTailList(
            &(IRP_DEVICE_CONTEXT(IrpSp)->IrpCompletionQueue),
            &Irp->Tail.Overlay.ListEntry,
            &(IRP_DEVICE_CONTEXT(IrpSp)->Interlock));

    }

} /* NbfDerefReceiveIrp */


#if DBG
VOID
NbfDerefReceiveIrpLocked(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dereferences a transport receive IRP by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IoCompleteRequest to actually complete the IRP.

Arguments:

    Request - Pointer to a transport receive IRP's stack location.

Return Value:

    none.

--*/

{
    ULONG result;

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint1 ("NbfDerefReceiveIrpLocked:  Entered, ReferenceCount: %x\n",
            IRP_RECEIVE_REFCOUNT(IrpSp));
    }

    result = IRP_RECEIVE_REFCOUNT(IrpSp)--;

    ASSERT (result > 0);

    //
    // If we have deleted all references to this request, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the request any longer.
    //

    if (result == 1) {

        PIRP Irp = IRP_RECEIVE_IRP(IrpSp);

        ExInterlockedInsertTailList(
            &(IRP_DEVICE_CONTEXT(IrpSp)->IrpCompletionQueue),
            &Irp->Tail.Overlay.ListEntry,
            &(IRP_DEVICE_CONTEXT(IrpSp)->Interlock));

    }

} /* NbfDerefReceiveIrpLocked */
#endif


VOID
NbfCompleteReceiveIrp(
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    )

/*++

Routine Description:

    This routine completes a transport receive IRP.

    NOTE: THIS ROUTINE MUST BE CALLED WITH THE CONNECTION SPINLOCK
    HELD.

Arguments:

    Irp - Pointer to a receive IRP.

    Status - Actual return status to be assigned to the request.  This
        value may be overridden if the timed-out bitflag is set in the request.

    Information - the information field for the I/O Status Block.

Return Value:

    none.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PTP_CONNECTION Connection;

    ASSERT (Status != STATUS_PENDING);

    Connection = IRP_RECEIVE_CONNECTION(IrpSp);

    IF_NBFDBG (NBF_DEBUG_REQUEST) {
        NbfPrint2 ("NbfCompleteReceiveIrp:  Entered IRP %lx, connection %lx\n",
            Irp, Connection);
    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Information;

    NbfDereferenceReceiveIrpLocked ("Complete", IrpSp, RREF_CREATION);     // remove creation reference.

} /* NbfCompleteReceiveIrp */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\spnlckdb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    spnlckdb.c

Abstract:

    This module contains code which allows debugging of spinlock related NBF
    problems. Most of this code is conditional on the manifest constant
    NBF_LOCKS.

Author:

    David Beaver 13-Feb-1991
    (From Chuck Lenzmeier, Jan 1991)

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef NBF_LOCKS

KSPIN_LOCK NbfGlobalLock = NULL;
PKTHREAD NbfGlobalLockOwner = NULL;
ULONG NbfGlobalLockRecursionCount = 0;
ULONG NbfGlobalLockMaxRecursionCount = 0;
KIRQL NbfGlobalLockPreviousIrql = (KIRQL)-1;
BOOLEAN NbfGlobalLockPrint = 1;

#define PRINT_ERR if ( (NbfGlobalLockPrint & 1) != 0 ) DbgPrint
#define PRINT_INFO if ( (NbfGlobalLockPrint & 2) != 0 ) DbgPrint

VOID
NbfAcquireSpinLock(
    IN PKSPIN_LOCK Lock,
    OUT PKIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    )
{
    KIRQL previousIrql;

    PKTHREAD currentThread = KeGetCurrentThread( );

    if ( NbfGlobalLockOwner == currentThread ) {

        ASSERT( Lock != NULL ); // else entering NBF with lock held

        ASSERT( NbfGlobalLockRecursionCount != 0 );
        NbfGlobalLockRecursionCount++;
        if ( NbfGlobalLockRecursionCount > NbfGlobalLockMaxRecursionCount ) {
            NbfGlobalLockMaxRecursionCount = NbfGlobalLockRecursionCount;
        }

        PRINT_INFO( "NBF reentered from %s/%ld, new count %ld\n",
                    FileName, LineNumber, NbfGlobalLockRecursionCount );

    } else {

        ASSERT( Lock == NULL ); // else missing an ENTER_NBF call

        KeAcquireSpinLock( &NbfGlobalLock, &previousIrql );

        ASSERT( NbfGlobalLockRecursionCount == 0 );
        NbfGlobalLockOwner = currentThread;
        NbfGlobalLockPreviousIrql = previousIrql;
        NbfGlobalLockRecursionCount = 1;

        PRINT_INFO( "NBF entered from %s/%ld\n", FileName, LineNumber );

    }

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    return;

} // NbfAcquireSpinLock

VOID
NbfReleaseSpinLock(
    IN PKSPIN_LOCK Lock,
    IN KIRQL OldIrql,
    IN PSZ LockName,
    IN PSZ FileName,
    IN ULONG LineNumber
    )
{
    PKTHREAD currentThread = KeGetCurrentThread( );
    KIRQL previousIrql;

    ASSERT( NbfGlobalLockOwner == currentThread );
    ASSERT( NbfGlobalLockRecursionCount != 0 );
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    if ( --NbfGlobalLockRecursionCount == 0 ) {

        ASSERT( Lock == NULL ); // else not exiting NBF, but releasing lock

        NbfGlobalLockOwner = NULL;
        previousIrql = NbfGlobalLockPreviousIrql;
        NbfGlobalLockPreviousIrql = (KIRQL)-1;

        PRINT_INFO( "NBF exited from %s/%ld\n", FileName, LineNumber );

        KeReleaseSpinLock( &NbfGlobalLock, previousIrql );

    } else {

        ASSERT( Lock != NULL ); // else exiting NBF with lock held

        PRINT_INFO( "NBF semiexited from %s/%ld, new count %ld\n",
                    FileName, LineNumber, NbfGlobalLockRecursionCount );

    }

    return;

} // NbfReleaseSpinLock

VOID
NbfFakeSendCompletionHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    )
{
    ENTER_NBF;
    NbfSendCompletionHandler (ProtocolBindingContext, NdisPacket, NdisStatus);
    LEAVE_NBF;
}

VOID
NbfFakeTransferDataComplete (
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT BytesTransferred
    )
{
    ENTER_NBF;
    NbfTransferDataComplete (BindingContext, NdisPacket, NdisStatus, BytesTransferred);
    LEAVE_NBF;
}

#endif // def NBF_LOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\send.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiSend
        o   TdiSendDatagram

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NbfTdiSend(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiSend request for the transport provider.

    NOTE: THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql, cancelIrql;
    PTP_CONNECTION connection;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SEND parameters;
    PIRP TempIrp;

    //
    // Determine which connection this send belongs on.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    connection  = irpSp->FileObject->FsContext;

    //
    // Check that this is really a connection.
    //

    if ((irpSp->FileObject->FsContext2 == UlongToPtr(NBF_FILE_TYPE_CONTROL)) ||
        (connection->Size != sizeof (TP_CONNECTION)) ||
        (connection->Type != NBF_CONNECTION_SIGNATURE)) {
#if DBG
        NbfPrint2 ("TdiSend: Invalid Connection %lx Irp %lx\n", connection, Irp);
#endif
        return STATUS_INVALID_CONNECTION;
    }

#if DBG
    Irp->IoStatus.Information = 0;              // initialize it.
    Irp->IoStatus.Status = 0x01010101;          // initialize it.
#endif

    //
    // Interpret send options.
    //

#if DBG
    parameters = (PTDI_REQUEST_KERNEL_SEND)(&irpSp->Parameters);
    if ((parameters->SendFlags & TDI_SEND_PARTIAL) != 0) {
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint0 ("NbfTdiSend: TDI_END_OF_RECORD not found.\n");
        }
    }
#endif

    //
    // Now we have a reference on the connection object.  Queue up this
    // send to the connection object.
    //

    //
    // We would normally add a connection reference of type
    // CREF_SEND_IRP, however we delay doing this until we
    // know we are not going to call PacketizeSend with the
    // second parameter TRUE. If we do call that it assumes
    // we have not added the reference.
    //

    IRP_SEND_IRP(irpSp) = Irp;
    IRP_SEND_REFCOUNT(irpSp) = 1;

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    if ((connection->Flags & CONNECTION_FLAGS_READY) == 0) {

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        Irp->IoStatus.Status = connection->Status;
        Irp->IoStatus.Information = 0;

        NbfDereferenceSendIrp ("Complete", irpSp, RREF_CREATION);     // remove creation reference.

    } else {

        //
        // Once the reference is in, LinkSpinLock will stay valid.
        //

        NbfReferenceConnection ("Verify Temp Use", connection, CREF_BY_ID);
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        IoAcquireCancelSpinLock(&cancelIrql);
        ACQUIRE_DPC_SPIN_LOCK (connection->LinkSpinLock);

#if DBG
        NbfSends[NbfSendsNext].Irp = Irp;
        NbfSends[NbfSendsNext].Request = NULL;
        NbfSends[NbfSendsNext].Connection = (PVOID)connection;
        {
            ULONG i,j;
            PUCHAR va;
            PMDL mdl;

            mdl = Irp->MdlAddress;
            if (parameters->SendLength > TRACK_TDI_CAPTURE) {
                NbfSends[NbfSendsNext].Contents[0] = 0xFF;
            } else {
                NbfSends[NbfSendsNext].Contents[0] = (UCHAR)parameters->SendLength;
            }

            i = 1;
            while (i < TRACK_TDI_CAPTURE) {
                if (mdl == NULL) break;
                for ( va = MmGetSystemAddressForMdl (mdl),
                                            j = MmGetMdlByteCount (mdl);
                      (i < TRACK_TDI_CAPTURE) && (j > 0);
                      i++, j-- ) {
                    NbfSends[NbfSendsNext].Contents[i] = *va++;
                }
                mdl = mdl->Next;
            }
        }

        NbfSendsNext++;
        if (NbfSendsNext >= TRACK_TDI_LIMIT) NbfSendsNext = 0;
#endif

        //
        // If this IRP has been cancelled already, complete it now.
        //

        if (Irp->Cancel) {

#if DBG
            NbfCompletedSends[NbfCompletedSendsNext].Irp = Irp;
            NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_CANCELLED;
            NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

            NbfReferenceConnection("TdiSend cancelled", connection, CREF_SEND_IRP);
            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);
            IoReleaseCancelSpinLock(cancelIrql);

            NbfCompleteSendIrp (Irp, STATUS_CANCELLED, 0);
            KeLowerIrql (oldirql);

            NbfDereferenceConnection ("IRP cancelled", connection, CREF_BY_ID);   // release lookup hold.
            return STATUS_PENDING;
        }

        //
        // Insert onto the send queue, and make the IRP
        // cancellable.
        //

        InsertTailList (&connection->SendQueue,&Irp->Tail.Overlay.ListEntry);
        IoSetCancelRoutine(Irp, NbfCancelSend);

        //
        // Release the cancel spinlock out of order. We were at DPC level
        // when we acquired both the cancel and link spinlocks, so the irqls
        // don't need to be swapped.
        //
        ASSERT(cancelIrql == DISPATCH_LEVEL);
        IoReleaseCancelSpinLock(cancelIrql);

        //
        // If this connection is waiting for an EOR to appear because a non-EOR
        // send failed at some point in the past, fail this send. Clear the
        // flag that causes this if this request has the EOR set.
        //
        // Should the FailSend status be clearer here?
        //

        if ((connection->Flags & CONNECTION_FLAGS_FAILING_TO_EOR) != 0) {

            NbfReferenceConnection("TdiSend failing to EOR", connection, CREF_SEND_IRP);

            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

            //
            // Should we save status from real failure?
            //

            FailSend (connection, STATUS_LINK_FAILED, TRUE);

            parameters = (PTDI_REQUEST_KERNEL_SEND)(&irpSp->Parameters);
            if ( (parameters->SendFlags & TDI_SEND_PARTIAL) == 0) {
                connection->Flags &= ~CONNECTION_FLAGS_FAILING_TO_EOR;
            }

            KeLowerIrql (oldirql);

            NbfDereferenceConnection ("Failing to EOR", connection, CREF_BY_ID);   // release lookup hold.
            return STATUS_PENDING;
        }


        //
        // If the send state is either IDLE or W_EOR, then we should
        // begin packetizing this send.  Otherwise, some other event
        // will cause it to be packetized.
        //

        //
        // NOTE: If we call StartPacketizingConnection, we make
        // sure that it is the last operation we do on this
        // connection. This allows us to "hand off" the reference
        // we have to that function, which converts it into
        // a reference for being on the packetize queue.
        //

//        NbfPrint2 ("TdiSend: Sending, connection %lx send state %lx\n",
//            connection, connection->SendState);

        switch (connection->SendState) {

        case CONNECTION_SENDSTATE_IDLE:

            InitializeSend (connection);   // sets state to PACKETIZE

            //
            // If we can, packetize right now.
            //

            if (!(connection->Flags & CONNECTION_FLAGS_PACKETIZE)) {

                ASSERT (!(connection->Flags2 & CONNECTION_FLAGS2_STOPPING));
                connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

#if DBG
                NbfReferenceConnection ("Packetize", connection, CREF_PACKETIZE_QUEUE);
                NbfDereferenceConnection("temp TdiSend", connection, CREF_BY_ID);
#endif

                //
                // This releases the spinlock. Note that PacketizeSend
                // assumes that the current SendIrp has a reference
                // of type RREF_PACKET;
                //

#if DBG
                NbfReferenceSendIrp ("Packetize", irpSp, RREF_PACKET);
#else
                ++IRP_SEND_REFCOUNT(irpSp);       // OK since it was just queued.
#endif
                PacketizeSend (connection, TRUE);

            } else {

#if DBG
                NbfReferenceConnection("TdiSend packetizing", connection, CREF_SEND_IRP);
                NbfDereferenceConnection ("Stopping or already packetizing", connection, CREF_BY_ID);   // release lookup hold.
#endif

                RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

            }

            break;

        case CONNECTION_SENDSTATE_W_EOR:
            connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;

            //
            // Adjust the send variables on the connection so that
            // they correctly point to this new send.  We can't call
            // InitializeSend to do that, because we need to keep
            // track of the other outstanding sends on this connection
            // which have been sent but are a part of this message.
            //

            TempIrp = CONTAINING_RECORD(
                connection->SendQueue.Flink,
                IRP,
                Tail.Overlay.ListEntry);

            connection->sp.CurrentSendIrp = TempIrp;
            connection->sp.CurrentSendMdl = TempIrp->MdlAddress;
            connection->sp.SendByteOffset = 0;
            connection->CurrentSendLength +=
                IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(TempIrp));

            //
            // StartPacketizingConnection removes the CREF_BY_ID
            // reference.
            //

            NbfReferenceConnection("TdiSend W_EOR", connection, CREF_SEND_IRP);

            StartPacketizingConnection (connection, TRUE);
            break;

        default:
//            NbfPrint2 ("TdiSend: Sending, unknown state! connection %lx send state %lx\n",
//                connection, connection->SendState);
            //
            // The connection is in another state (such as
            // W_ACK or W_LINK), we just need to make sure
            // to call InitializeSend if the new one is
            // the first one on the list.
            //

            //
            // Currently InitializeSend sets SendState, we should fix this.
            //

            if (connection->SendQueue.Flink == &Irp->Tail.Overlay.ListEntry) {
                ULONG SavedSendState;
                SavedSendState = connection->SendState;
                InitializeSend (connection);
                connection->SendState = SavedSendState;
            }

#if DBG
            NbfReferenceConnection("TdiSend other", connection, CREF_SEND_IRP);
            NbfDereferenceConnection("temp TdiSend", connection, CREF_BY_ID);
#endif

            RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

        }

    }

    KeLowerIrql (oldirql);
    return STATUS_PENDING;

} /* TdiSend */


NTSTATUS
NbfTdiSendDatagram(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiSendDatagram request for the transport
    provider.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    KIRQL oldirql;
    PTP_ADDRESS_FILE addressFile;
    PTP_ADDRESS address;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    UINT MaxUserData;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_TRANSPORT_ADDRESS_FILE) {
        return STATUS_INVALID_ADDRESS;
    }

    addressFile  = irpSp->FileObject->FsContext;

    status = NbfVerifyAddressObject (addressFile);
    if (!NT_SUCCESS (status)) {
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint2 ("TdiSendDG: Invalid address %lx Irp %lx\n",
                    addressFile, Irp);
        }
        return status;
    }

    address = addressFile->Address;
    parameters = (PTDI_REQUEST_KERNEL_SENDDG)(&irpSp->Parameters);

    //
    // Check that the length is short enough.
    //

    MacReturnMaxDataSize(
        &address->Provider->MacInfo,
        NULL,
        0,
        address->Provider->MaxSendPacketSize,
        FALSE,
        &MaxUserData);

    if (parameters->SendLength >
        (MaxUserData - sizeof(DLC_FRAME) - sizeof(NBF_HDR_CONNECTIONLESS))) {

        NbfDereferenceAddress("tmp send datagram", address, AREF_VERIFY);
        return STATUS_INVALID_PARAMETER;

    }

    //
    // If we are on a disconnected RAS link, then fail the datagram
    // immediately.
    //

    if ((address->Provider->MacInfo.MediumAsync) &&
        (!address->Provider->MediumSpeedAccurate)) {

        NbfDereferenceAddress("tmp send datagram", address, AREF_VERIFY);
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Check that the target address includes a Netbios component.
    //

    if (!(NbfValidateTdiAddress(
             parameters->SendDatagramInformation->RemoteAddress,
             parameters->SendDatagramInformation->RemoteAddressLength)) ||
        (NbfParseTdiAddress(parameters->SendDatagramInformation->RemoteAddress, TRUE) == NULL)) {

        NbfDereferenceAddress("tmp send datagram", address, AREF_VERIFY);
        return STATUS_BAD_NETWORK_PATH;
    }

    ACQUIRE_SPIN_LOCK (&address->SpinLock,&oldirql);

    if ((address->Flags & (ADDRESS_FLAGS_STOPPING | ADDRESS_FLAGS_CONFLICT)) != 0) {

        RELEASE_SPIN_LOCK (&address->SpinLock,oldirql);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = (address->Flags & ADDRESS_FLAGS_STOPPING) ?
                    STATUS_NETWORK_NAME_DELETED : STATUS_DUPLICATE_NAME;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    } else {

        NbfReferenceAddress ("Send datagram", address, AREF_REQUEST);
        Irp->IoStatus.Information = parameters->SendLength;
        InsertTailList (
            &address->SendDatagramQueue,
            &Irp->Tail.Overlay.ListEntry);
        RELEASE_SPIN_LOCK (&address->SpinLock,oldirql);

        //
        // The request is queued.  Ship the next request at the head of the queue,
        // provided the completion handler is not active.  We serialize this so
        // that only one MDL and NBF datagram header needs to be statically
        // allocated for reuse by all send datagram requests.
        //

        (VOID)NbfSendDatagramsOnAddress (address);

    }

    NbfDereferenceAddress("tmp send datagram", address, AREF_VERIFY);

    return STATUS_PENDING;

} /* NbfTdiSendDatagram */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\sendeng.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    sendeng.c

Abstract:

    This module contains code that implements the send engine for the
    Jetbeui transport provider.  This code is responsible for the following
    basic activities, including some subordinate glue.

    1.  Packetizing TdiSend requests already queued up on a TP_CONNECTION
        object, using I-frame packets acquired from the PACKET.C module,
        and turning them into shippable packets and placing them on the
        TP_LINK's WackQ.  In the process of doing this, the packets are
        actually submitted as I/O requests to the Physical Provider, in
        the form of PdiSend requests.

    2.  Retiring packets queued to a TP_LINK's WackQ and returning them to
        the device context's pool for use by other links.  In the process
        of retiring acked packets, step 1 may be reactivated.

    3.  Resending packets queued to a TP_LINK's WackQ because of a reject
        condition on the link.  This involves no state update in the
        TP_CONNECTION object.

    4.  Handling of Send completion events from the Physical Provider,
        to allow proper synchronization of the reuse of packets.

    5.  Completion of TdiSend requests.  This is triggered by the receipt
        (in IFRAMES.C) of a DataAck frame, or by a combination of other
        frames when the proper protocol has been negotiated.  One routine
        in this routine is responsible for the actual mechanics of TdiSend
        request completion.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#if DBG
extern ULONG NbfSendsIssued;
extern ULONG NbfSendsCompletedInline;
extern ULONG NbfSendsCompletedOk;
extern ULONG NbfSendsCompletedFail;
extern ULONG NbfSendsPended;
extern ULONG NbfSendsCompletedAfterPendOk;
extern ULONG NbfSendsCompletedAfterPendFail;
#endif


//
// Temporary variables to control piggyback ack usage.
//
#define NbfUsePiggybackAcks   1
#if DBG
ULONG NbfDebugPiggybackAcks = 0;
#endif


#if DBG
//
// *** This is the original version of StartPacketizingConnection, which
//     is now a macro on the free build.  It has been left here as the
//     fully-commented version of the code.
//

VOID
StartPacketizingConnection(
    PTP_CONNECTION Connection,
    IN BOOLEAN Immediate
    )

/*++

Routine Description:

    This routine is called to place a connection on the PacketizeQueue
    of its device context object.  Then this routine starts packetizing
    the first connection on that queue.

    *** The Connection LinkSpinLock must be held on entry to this routine.

    *** THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Immediate - TRUE if the connection should be packetized
        immediately; FALSE if the connection should be queued
        up for later packetizing (implies that ReceiveComplete
        will be called in the future, which packetizes always).

        NOTE: If this is TRUE, it also implies that we have
        a connection reference of type CREF_BY_ID which we
        will "convert" into the CREF_PACKETIZE_QUEUE one.

Return Value:

    none.

--*/

{
    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("StartPacketizingConnection: Entered for connection %lx.\n",
                    Connection);
    }

    DeviceContext = Connection->Provider;

    //
    // If this connection's SendState is set to PACKETIZE and if
    // we are not already on the PacketizeQueue, then go ahead and
    // append us to the end of that queue, and remember that we're
    // on it by setting the CONNECTION_FLAGS_PACKETIZE bitflag.
    //
    // Also don't queue it if the connection is stopping.
    //

    if ((Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE) &&
        !(Connection->Flags & CONNECTION_FLAGS_PACKETIZE) &&
        (Connection->Flags & CONNECTION_FLAGS_READY)) {

        ASSERT (!(Connection->Flags2 & CONNECTION_FLAGS2_STOPPING));

        Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

        if (!Immediate) {
            NbfReferenceConnection ("Packetize", Connection, CREF_PACKETIZE_QUEUE);
        } else {
#if DBG
            NbfReferenceConnection ("Packetize", Connection, CREF_PACKETIZE_QUEUE);
            NbfDereferenceConnection("temp TdiSend", Connection, CREF_BY_ID);
#endif
        }

        ExInterlockedInsertTailList(
            &DeviceContext->PacketizeQueue,
            &Connection->PacketizeLinkage,
            &DeviceContext->SpinLock);

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    } else {

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        if (Immediate) {
            NbfDereferenceConnection("temp TdiSend", Connection, CREF_BY_ID);
        }
    }

    if (Immediate) {
        PacketizeConnections (DeviceContext);
    }

} /* StartPacketizingConnection */
#endif


VOID
PacketizeConnections(
    PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine attempts to packetize all connections waiting on the
    PacketizeQueue of the DeviceContext.


Arguments:

    DeviceContext - Pointer to a DEVICE_CONTEXT object.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p;
    PTP_CONNECTION Connection;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("PacketizeConnections: Entered for device context %lx.\n",
                    DeviceContext);
    }

    //
    // Pick connections off of the device context's packetization queue
    // until there are no more left to pick off.  For each one, we call
    // PacketizeSend.  Note this routine can be executed concurrently
    // on multiple processors and it doesn't matter; multiple connections
    // may be packetized concurrently.
    //

    while (TRUE) {

        p = ExInterlockedRemoveHeadList(
            &DeviceContext->PacketizeQueue,
            &DeviceContext->SpinLock);

        if (p == NULL) {
            break;
        }
        Connection = CONTAINING_RECORD (p, TP_CONNECTION, PacketizeLinkage);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        if (Connection->SendState != CONNECTION_SENDSTATE_PACKETIZE) {
            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfDereferenceConnection ("No longer packetizing", Connection, CREF_PACKETIZE_QUEUE);
        } else {
            NbfReferenceSendIrp ("Packetize", IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp), RREF_PACKET);
            PacketizeSend (Connection, FALSE);     // releases the lock.
        }
    }

} /* PacketizeConnections */


VOID
PacketizeSend(
    IN PTP_CONNECTION Connection,
    IN BOOLEAN Direct
    )

/*++

Routine Description:

    This routine packetizes the current TdiSend request on the specified
    connection as much as limits will permit.  A given here is that there
    is an active send on the connection that needs further packetization.

    NOTE: This routine is called with the connection spinlock held and
    returns with it released. THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Direct - TRUE if we are called from TdiSend. This implies that
    the connection does not have a reference of type CREF_SEND_IRP,
    which we need to add before we leave.

Return Value:

    none.

--*/

{
    ULONG MaxFrameSize, FrameSize;
    ULONG PacketBytes;
    PNDIS_BUFFER PacketDescriptor;
    PDEVICE_CONTEXT DeviceContext;
    PTP_PACKET Packet;
    NTSTATUS Status;
    PNBF_HDR_CONNECTION NbfHeader;
    BOOLEAN LinkCheckpoint;
    BOOLEAN SentPacket = FALSE;
    BOOLEAN ExitAfterSendOnePacket = FALSE;
    PIO_STACK_LOCATION IrpSp;
    ULONG LastPacketLength;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("PacketizeSend:  Entered for connection %lx.\n", Connection);
    }

    DeviceContext = Connection->Provider;

    ASSERT (Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE);

    //
    // Just loop until one of three events happens: (1) we run out of
    // packets from NbfCreatePacket, (2) we completely packetize the send,
    // or (3) we can't send any more packets because SendOnePacket failed.
    //

#if DBG

    //
    // Convert the queue reference into a packetize one. It is OK
    // to do this with the lock held because we know that the refcount
    // must already be at least one, so we don't drop to zero.
    //

    NbfReferenceConnection ("PacketizeSend", Connection, CREF_PACKETIZE);
    NbfDereferenceConnection ("Off packetize queue", Connection, CREF_PACKETIZE_QUEUE);
#endif

    MaxFrameSize = Connection->MaximumDataSize;
    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("PacketizeSend: MaxFrameSize for user data=%ld.\n", MaxFrameSize);
    }


    //
    // It is possible for a frame to arrive during the middle of this loop
    // (such as a NO_RECEIVE) that will put us into a new state (such as
    // W_RCVCONT).  For this reason, we have to check the state every time
    // (at the end of the loop).
    //

    do {

        if (!NT_SUCCESS (NbfCreatePacket (DeviceContext, Connection->Link, &Packet))) {

            //
            // We need a packet to finish packetizing the current send, but
            // there are no more packets available in the pool right now.
            // Set our send state to W_PACKET, and put this connection on
            // the PacketWaitQueue of the device context object.  Then,
            // when NbfDestroyPacket frees up a packet, it will check this
            // queue for starved connections, and if it finds one, it will
            // take a connection off the list and set its send state to
            // SENDSTATE_PACKETIZE and put it on the PacketizeQueue.
            //

            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint0 ("PacketizeSend:  NbfCreatePacket failed.\n");
            }
            Connection->SendState = CONNECTION_SENDSTATE_W_PACKET;

            //
            // Clear the PACKETIZE flag, indicating that we're no longer
            // on the PacketizeQueue or actively packetizing.  The flag
            // was set by StartPacketizingConnection to indicate that
            // the connection was already on the PacketizeQueue.
            //
            // Don't queue him if the connection is stopping.
            //

            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
#if DBG
            if (Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) {
                DbgPrint ("NBF: Trying to PacketWait stopping connection %lx\n", Connection);
                DbgBreakPoint();
            }
#endif
            Connection->Flags |= CONNECTION_FLAGS_W_PACKETIZE;
            if (!Connection->OnPacketWaitQueue) {
                Connection->OnPacketWaitQueue = TRUE;
                InsertTailList(
                    &DeviceContext->PacketWaitQueue,
                    &Connection->PacketWaitLinkage);
            }

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            if (!SentPacket) {
                NbfDereferenceSendIrp ("No packet", IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp), RREF_PACKET);
            }
            if (Direct) {
                NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
            }

            NbfDereferenceConnection ("No packet", Connection, CREF_PACKETIZE);
            return;

        }

        //
        // Set the length of the packet now, while only the
        // header is attached.
        //

        NbfSetNdisPacketLength(
            Packet->NdisPacket,
            Connection->Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION));

        // Add a reference count to the request, and keep track of
        // which request it is. We rely on NbfDestroyPacket to
        // remove the reference.

        IrpSp = IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp);

        Packet->Owner = IrpSp;
        // Packet->Action = PACKET_ACTION_IRP_SP;
        IF_NBFDBG (NBF_DEBUG_REQUEST) {
            NbfPrint2 ("PacketizeSend:  Packet %x ref IrpSp %x.\n", Packet, Packet->Owner);
        }

        //
        // For performance reasons, the first time through here on
        // a direct call, we have a IrpSp reference already.
        //

        if (SentPacket) {
            NbfReferenceSendIrp ("Packetize", IrpSp, RREF_PACKET);
        }

        //
        // Now build a DATA_ONLY_LAST header in this frame. If it
        // turns out we need a DFM, we change it. The header we copy
        // already has ResponseCorrelator set to our current correlator
        // and TransmitCorrelator set to the last one we received from
        // him (if we do not piggyback an ack, then we zero out
        // TransmitCorrelator).
        //

        NbfHeader = (PNBF_HDR_CONNECTION)&(Packet->Header[Connection->Link->HeaderLength + sizeof(DLC_I_FRAME)]);
        *(NBF_HDR_CONNECTION UNALIGNED *)NbfHeader = Connection->NetbiosHeader;

        ASSERT (RESPONSE_CORR(NbfHeader) != 0);

        //
        // Determine if we need the resynch bit here.
        //

        if (Connection->Flags & CONNECTION_FLAGS_RESYNCHING) {

            NbfHeader->Data2Low = 1;
            Connection->Flags &= ~CONNECTION_FLAGS_RESYNCHING;

        } else {

            NbfHeader->Data2Low = 0;

        }


        //
        // build an NDIS_BUFFER chain that describes the buffer we're using, and
        // thread it off the NdisBuffer. This chain may not complete the
        // packet, as the remaining part of the MDL chain may be shorter than
        // the packet.
        //

        FrameSize = MaxFrameSize;

        //
        // Check if we have less than FrameSize left to send.
        //

        if (Connection->sp.MessageBytesSent + FrameSize > Connection->CurrentSendLength) {

            FrameSize = Connection->CurrentSendLength - Connection->sp.MessageBytesSent;

        }


        //
        // Make a copy of the MDL chain for this send, unless
        // there are zero bytes left.
        //

        if (FrameSize != 0) {

            //
            // If the whole send will fit inside one packet,
            // then there is no need to duplicate the MDL
            // (note that this may include multi-MDL sends).
            //

            if ((Connection->sp.SendByteOffset == 0) &&
                (Connection->CurrentSendLength == FrameSize)) {

                PacketDescriptor = (PNDIS_BUFFER)Connection->sp.CurrentSendMdl;
                PacketBytes = FrameSize;
                Connection->sp.CurrentSendMdl = NULL;
                Connection->sp.SendByteOffset = FrameSize;
                Packet->PacketNoNdisBuffer = TRUE;

            } else {

                Status = BuildBufferChainFromMdlChain (
                            DeviceContext,
                            Connection->sp.CurrentSendMdl,
                            Connection->sp.SendByteOffset,
                            FrameSize,
                            &PacketDescriptor,
                            &Connection->sp.CurrentSendMdl,
                            &Connection->sp.SendByteOffset,
                            &PacketBytes);

                if (!NT_SUCCESS(Status)) {

                    if (NbfHeader->Data2Low) {
                        Connection->Flags |= CONNECTION_FLAGS_RESYNCHING;
                    }

                    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                    NbfDereferencePacket (Packet);       // remove creation hold.
                    goto BufferChainFailure;
                }

            }

            //
            // Chain the buffers to the packet, unless there
            // are zero bytes of data.
            //

            Connection->sp.MessageBytesSent += PacketBytes;
            NdisChainBufferAtBack (Packet->NdisPacket, PacketDescriptor);

        } else {

            PacketBytes = 0;
            Connection->sp.CurrentSendMdl = NULL;

        }

        {

            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                {PNDIS_BUFFER NdisBuffer;
                NdisQueryPacket(Packet->NdisPacket, NULL, NULL, &NdisBuffer, NULL);
                NbfPrint1 ("PacketizeSend: NDIS_BUFFER Built, chain is: %lx is Packet->Head\n", NdisBuffer);
                NdisGetNextBuffer (NdisBuffer, &NdisBuffer);
                while (NdisBuffer != NULL) {
                    NbfPrint1 ("                                    %lx is Next\n",
                        NdisBuffer);
                    NdisGetNextBuffer (NdisBuffer, &NdisBuffer);
                }}
            }

            //
            // Have we run out of Mdl Chain in this request?
            //

#if DBG
            if (PacketBytes < FrameSize) {
                ASSERT (Connection->sp.CurrentSendMdl == NULL);
            }
#endif

            if ((Connection->sp.CurrentSendMdl == NULL) ||
                (Connection->CurrentSendLength <= Connection->sp.MessageBytesSent)) {

                //
                // Yep. We know that we've exhausted the current request's buffer
                // here, so see if there's another request without EOF set that we
                // can build start throwing into this packet.
                //

                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                   NbfPrint0 ("PacketizeSend:  Used up entire request.\n");
                }

                if (!(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL)) {

                    //
                    // We are sending the last packet in a message.  Change
                    // the packet type and indicate in the connection object's
                    // send state that we are waiting for a DATA_ACK NetBIOS-
                    // level acknowlegement.
                    //

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint0 ("PacketizeSend:  Request has EOR, making pkt a DOL.\n");
                    }

                    //
                    // Keep track of how many consecutive sends we have done.
                    //

                    Connection->ConsecutiveSends++;
                    Connection->ConsecutiveReceives = 0;

                    //
                    // Change it to a DOL with piggyback ack allowed if wanted.
                    //

                    ASSERT (NbfHeader->Command == NBF_CMD_DATA_ONLY_LAST);
                    if (!(IRP_SEND_FLAGS(IrpSp) &
                                TDI_SEND_NO_RESPONSE_EXPECTED) &&
                            (Connection->ConsecutiveSends < 2)) {
                        if (NbfUsePiggybackAcks) {
                            NbfHeader->Data1 |= DOL_OPTIONS_ACK_W_DATA_ALLOWED;
                        }
                    }

                    Connection->SendState = CONNECTION_SENDSTATE_W_ACK;
                    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
                    ExitAfterSendOnePacket = TRUE;

                } else {

                    //
                    // We are sending the last packet in this request. If there
                    // are more requests in the connection's SendQueue, then
                    // advance complex send pointer to point to the next one
                    // in line.  Otherwise, if there aren't any more requests
                    // ready to packetize, then we enter the W_EOR state and
                    // stop packetizing. Note that we're waiting here for the TDI
                    // client to come up with data to send; we're just hanging out
                    // until then.
                    //
                    // DGB: Note that this will allow the last packet in the
                    // request to be smaller than the max packet length. This
                    // is not addressed anywhere that I can find in the NBF
                    // spec, and will be interesting to test against a non-NT
                    // NBF protocol.
                    //

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint0 ("PacketizeSend:  Request doesn't have EOR.\n");
                    }

                    NbfHeader->Command = NBF_CMD_DATA_FIRST_MIDDLE;

                    if (Connection->sp.CurrentSendIrp->Tail.Overlay.ListEntry.Flink == &Connection->SendQueue) {

                        Connection->SendState = CONNECTION_SENDSTATE_W_EOR;
                        Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
                        ExitAfterSendOnePacket = TRUE;

                    } else {

                        Connection->sp.CurrentSendIrp =
                            CONTAINING_RECORD (
                                Connection->sp.CurrentSendIrp->Tail.Overlay.ListEntry.Flink,
                                IRP,
                                Tail.Overlay.ListEntry);
                        Connection->sp.CurrentSendMdl =
                            Connection->sp.CurrentSendIrp->MdlAddress;
                        Connection->sp.SendByteOffset = 0;
                        Connection->CurrentSendLength +=
                            IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp));
                    }
                }

            } else {

                NbfHeader->Command = NBF_CMD_DATA_FIRST_MIDDLE;

            }

            //
            // Before we release the spinlock, see if we want to
            // piggyback an ack on here.
            //

            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {

                //
                // Turn off the flags. We don't take it off the queue,
                // that will be handled by the timer function.
                //

                Connection->DeferredFlags &=
                    ~(CONNECTION_FLAGS_DEFERRED_ACK | CONNECTION_FLAGS_DEFERRED_NOT_Q);

                ASSERT (DOL_OPTIONS_ACK_INCLUDED == DFM_OPTIONS_ACK_INCLUDED);

#if DBG
                if (NbfDebugPiggybackAcks) {
                    NbfPrint0("A");
                }
#endif

                //
                // TRANSMIT_CORR(NbfHeader) is already set correctly.
                //

                NbfHeader->Data1 |= DOL_OPTIONS_ACK_INCLUDED;

            } else {

                TRANSMIT_CORR(NbfHeader) = (USHORT)0;

            }

            //
            // To prevent a send "crossing" the receive and
            // causing a bogus piggyback ack timeout (this
            // only matters if a receive indication is in
            // progress).
            //

            Connection->CurrentReceiveAckQueueable = FALSE;

            SentPacket = TRUE;
            LastPacketLength =
                sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION) + PacketBytes;

            MacModifyHeader(
                 &DeviceContext->MacInfo,
                 Packet->Header,
                 LastPacketLength);

            Packet->NdisIFrameLength = LastPacketLength;

            ASSERT (Connection->LinkSpinLock == &Connection->Link->SpinLock);

            Status = SendOnePacket (Connection, Packet, FALSE, &LinkCheckpoint);

            if (Status == STATUS_LINK_FAILED) {

                //
                // If SendOnePacket failed due to the link being
                // dead, then we tear down the link.
                //

                FailSend (Connection, STATUS_LINK_FAILED, TRUE);                   // fail the send
                NbfDereferencePacket (Packet);            // remove creation hold.
                if (Direct) {
                    NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                }
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);

                return;

            } else {

                //
                // SendOnePacket returned success, so update our counters;
                //

                DeviceContext->TempIFrameBytesSent += PacketBytes;
                ++DeviceContext->TempIFramesSent;

                if ((Status == STATUS_SUCCESS) && LinkCheckpoint) {

                    //
                    // We are checkpointing; this means that SendOnePacket
                    // will already have set the state to W_LINK and turned
                    // off the PACKETIZE flag, so we should leave. When
                    // the checkpoint response is received, we will
                    // resume packetizing. We don't have to worry about
                    // doing all the other recovery stuff (resetting
                    // the piggyback ack flag, complex send pointer, etc.)
                    // because the send did in fact succeed.
                    //

                    if (Direct) {
#if DBG
                        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                        NbfDereferenceConnection ("Link checkpoint", Connection, CREF_PACKETIZE);
#endif
                    } else {
                        NbfDereferenceConnection ("Link checkpoint", Connection, CREF_PACKETIZE);
                    }
                    return;

                } else if (ExitAfterSendOnePacket ||
                           (Status == STATUS_MORE_PROCESSING_REQUIRED)) {

                    if (Direct) {
#if DBG
                        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                        NbfDereferenceConnection ("Packetize done", Connection, CREF_PACKETIZE);
#endif
                    } else {
                        NbfDereferenceConnection ("Packetize done", Connection, CREF_PACKETIZE);
                    }
                    return;

                }
            }
        }

BufferChainFailure:;

        //
        // Note that we may have fallen out of the BuildBuffer... if above with
        // Status set to STATUS_INSUFFICIENT_RESOURCES. if we have, we'll just
        // stick this connection back onto the packetize queue and hope the
        // system gets more resources later.
        //


        if (!NT_SUCCESS (Status)) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint0 ("PacketizeSend:  SendOnePacket failed.\n");
            }

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            //
            // Indicate we're waiting on favorable link conditions.
            //

            Connection->SendState = CONNECTION_SENDSTATE_W_LINK;

            //
            // Clear the PACKETIZE flag, indicating that we're no longer
            // on the PacketizeQueue or actively packetizing.  The flag
            // was set by StartPacketizingConnection to indicate that
            // the connection was already on the PacketizeQueue.
            //

            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            //
            // If we are exiting and we sent a packet without
            // polling, we need to start T1.
            //

            if (Direct) {

                //
                // We have to do the CREF_SEND_IRP reference that is missing.
                //

#if DBG
                NbfReferenceConnection("TdiSend", Connection, CREF_SEND_IRP);
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);
#endif
            } else {
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);
            }

            return;
        }

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // It is probable that a NetBIOS frame arrived while we released
        // the connection's spin lock, so our state has probably changed.
        // When we cycle around this loop again, we will have the lock
        // again, so we can test the connection's send state.
        //

    } while (Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE);

    //
    // Clear the PACKETIZE flag, indicating that we're no longer on the
    // PacketizeQueue or actively packetizing.  The flag was set by
    // StartPacketizingConnection to indicate that the connection was
    // already on the PacketizeQueue.
    //

    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);


    if (Direct) {
#if DBG
        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
        NbfDereferenceConnection ("PacketizeSend done", Connection, CREF_PACKETIZE);
#endif
    } else {
        NbfDereferenceConnection ("PacketizeSend done", Connection, CREF_PACKETIZE);
    }

} /* PacketizeSend */


VOID
CompleteSend(
    PTP_CONNECTION Connection,
    IN USHORT Correlator
    )

/*++

Routine Description:

    This routine is called because the connection partner acknowleged
    an entire message at the NetBIOS Frames Protocol level, either through
    a DATA_ACK response, or a RECEIVE_OUTSTANDING, or RECEIVE_CONTINUE,
    or NO_RECEIVE response where the number of bytes specified exactly
    matches the number of bytes sent in the message.  Here we retire all
    of the TdiSends on the connection's SendQueue up to and including the
    one with the TDI_END_OF_RECORD bitflag set.  For each request, we
    complete the I/O.

    NOTE: This function is called with the connection spinlock
    held and returns with it held, but it may release it in the
    middle. THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Correlator - The correlator in the DATA_ACK or piggybacked ack.

    OldIrqlP - Returns the IRQL at which the connection spinlock
        was acquired.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY p;
    BOOLEAN EndOfRecord;
    KIRQL cancelIrql;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("CompleteSend: Entered for connection %lx.\n", Connection);
    }


    //
    // Make sure that the correlator is the expect one, and
    // that we are in a good state (don't worry about locking
    // since this is an unusual case anyway).
    //

    if (Correlator != Connection->NetbiosHeader.ResponseCorrelator) {
        NbfPrint0 ("NbfCompleteSend: ack ignored, wrong correlator\n");
        return;
    }

    if (Connection->SendState != CONNECTION_SENDSTATE_W_ACK) {
        NbfPrint0 ("NbfCompleteSend: ack not expected\n");
        return;
    }

    //
    // Pick off TP_REQUEST objects from the connection's SendQueue until
    // we find one with an END_OF_RECORD mark embedded in it.
    //

    while (!(IsListEmpty(&Connection->SendQueue))) {

        //
        // We know for a fact that we wouldn't be calling this routine if
        // we hadn't received an acknowlegement for an entire message,
        // since NBF doesn't provide stream mode sends.  Therefore, we
        // know that we will run into a request with the END_OF_RECORD
        // mark set BEFORE we will run out of requests on that queue,
        // so there is no reason to check to see if we ran off the end.
        // Note that it's possible that the send has been failed and the
        // connection not yet torn down; if this has happened, we could be
        // removing from an empty queue here. Make sure that doesn't happen.
        //

        p = RemoveHeadList(&Connection->SendQueue);

        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation (Irp);

        EndOfRecord = !(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = Irp;
        NbfCompletedSends[NbfCompletedSendsNext].Request = NULL;
        NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_SUCCESS;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif
#if DBG
        IF_NBFDBG (NBF_DEBUG_TRACKTDI) {
            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_SENDS) != 0){
                NbfPrint1 ("CompleteSend: Completing send request %lx\n", Irp);
                if (++Connection->DeferredPasses >= 4) {
                    Connection->DeferredFlags &= ~CONNECTION_FLAGS_DEFERRED_SENDS;
                    Connection->DeferredPasses = 0;
                }

            }

        }
#endif


        //
        // Complete the send. Note that this may not actually call
        // IoCompleteRequest for the Irp until sometime later, if the
        // in-progress LLC resending going on below us needs to complete.
        //

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // Since the irp is no longer on the send list, the cancel routine
        // cannot find it and will just return. We must grab the cancel
        // spinlock to lock out the cancel function while we null out
        // the Irp->CancelRoutine field.
        //

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        NbfCompleteSendIrp (
                Irp,
                STATUS_SUCCESS,
                IRP_SEND_LENGTH(IrpSp));

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        ++Connection->TransmittedTsdus;

        if (EndOfRecord) {
            break;
        }

    }

    //
    // We've finished processing the current send.  Update our state.
    //
    // Note: The connection spinlock is held here.
    //

    Connection->SendState = CONNECTION_SENDSTATE_IDLE;

    //
    // If there is another send pending on the connection, then initialize
    // it and start packetizing it.
    //

    if (!(IsListEmpty (&Connection->SendQueue))) {

        InitializeSend (Connection);

        //
        // This code is similar to calling StartPacketizingConnection
        // with the second parameter FALSE.
        //

        if ((!(Connection->Flags & CONNECTION_FLAGS_PACKETIZE)) &&
            (Connection->Flags & CONNECTION_FLAGS_READY)) {

            Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

            NbfReferenceConnection ("Packetize", Connection, CREF_PACKETIZE_QUEUE);

            ExInterlockedInsertTailList(
                &Connection->Provider->PacketizeQueue,
                &Connection->PacketizeLinkage,
                &Connection->Provider->SpinLock);

        }

    }

    //
    // NOTE: We return with the lock held.
    //

} /* CompleteSend */


VOID
FailSend(
    IN PTP_CONNECTION Connection,
    IN NTSTATUS RequestStatus,
    IN BOOLEAN StopConnection
    )

/*++

Routine Description:

    This routine is called because something on the link caused this send to be
    unable to complete. There are a number of possible reasons for this to have
    happened, but all will fail with the common error STATUS_LINK_FAILED.
    or NO_RECEIVE response where the number of bytes specified exactly
    Here we retire all of the TdiSends on the connection's SendQueue up to
    and including the current one, which is the one that failed.

    Later - Actually, a send failing is cause for the entire circuit to wave
    goodbye to this life. We now simply tear down the connection completly.
    Any future sends on this connection will be blown away.

    NOTE: THIS FUNCTION MUST BE CALLED WITH THE SPINLOCK HELD.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY p;
    BOOLEAN EndOfRecord;
    BOOLEAN GotCurrent = FALSE;
    KIRQL cancelIrql;


    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("FailSend: Entered for connection %lx.\n", Connection);
    }


    //
    // Pick off IRP objects from the connection's SendQueue until
    // we get to this one. If this one does NOT have an EOF mark set, we'll
    // need to keep going until we hit one that does have EOF set. Note that
    // this may  cause us to continue failing sends that have not yet been
    // queued. (We do all this because NBF does not provide stream mode sends.)
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    NbfReferenceConnection ("Failing Send", Connection, CREF_COMPLETE_SEND);

    do {
        if (IsListEmpty (&Connection->SendQueue)) {

           //
           // got an empty list, so we've run out of send requests to fail
           // without running into an EOR. Set the connection flag that will
           // cause all further sends to be failed up to an EOR and get out
           // of here.
           //

           Connection->Flags |= CONNECTION_FLAGS_FAILING_TO_EOR;
           break;
        }
        p = RemoveHeadList (&Connection->SendQueue);
        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation (Irp);

        if (Irp == Connection->sp.CurrentSendIrp) {
           GotCurrent = TRUE;
        }
        EndOfRecord = !(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = Irp;
        NbfCompletedSends[NbfCompletedSendsNext].Status = RequestStatus;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        //
        // The following dereference will complete the I/O, provided removes
        // the last reference on the request object.  The I/O will complete
        // with the status and information stored in the Irp.  Therefore,
        // we set those values here before the dereference.
        //

        NbfCompleteSendIrp (Irp, RequestStatus, 0);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        ++Connection->TransmissionErrors;

    } while (!EndOfRecord & !GotCurrent);

    //
    // We've finished processing the current send.  Update our state.
    //

    Connection->SendState = CONNECTION_SENDSTATE_IDLE;
    Connection->sp.CurrentSendIrp = NULL;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    //
    // Blow away this connection; a failed send is a terrible thing to waste.
    // Note that we are not on any packetizing queues or similar things at this
    // point; we'll just disappear into the night.
    //

#if MAGIC
    if (NbfEnableMagic) {
        extern VOID NbfSendMagicBullet (PDEVICE_CONTEXT, PTP_LINK);
        NbfSendMagicBullet (Connection->Provider, Connection->Link);
    }
#endif

    if (StopConnection) {
#if DBG
        if (NbfDisconnectDebug) {
            STRING remoteName, localName;
            remoteName.Length = NETBIOS_NAME_LENGTH - 1;
            remoteName.Buffer = Connection->RemoteName;
            localName.Length = NETBIOS_NAME_LENGTH - 1;
            localName.Buffer = Connection->AddressFile->Address->NetworkName->NetbiosName;
            NbfPrint2( "FailSend stopping connection to %S from %S\n",
                &remoteName, &localName );
        }
#endif
        NbfStopConnection (Connection, STATUS_LINK_FAILED);
    }

#if DBG
    //DbgBreakPoint ();
#endif

    NbfDereferenceConnection ("FailSend", Connection, CREF_COMPLETE_SEND);

} /* FailSend */

#if DBG
//
// *** This is the original version of InitializeSend, which is now a macro.
//     It has been left here as the fully-commented version of the code.
//


VOID
InitializeSend(
    PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine is called whenever the next send on a connection should
    be initialized; that is, all of the fields associated with the state
    of the current send are set to refer to the first send on the SendQueue.

    WARNING:  This routine is executed with the Connection lock acquired
    since it must be atomically executed with the caller's setup.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("InitializeSend: Entered for connection %lx.\n", Connection);
    }

    ASSERT (!IsListEmpty (&Connection->SendQueue));

    Connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;
    Connection->FirstSendIrp =
        CONTAINING_RECORD (Connection->SendQueue.Flink, IRP, Tail.Overlay.ListEntry);
    Connection->FirstSendMdl = Connection->FirstSendIrp->MdlAddress;
    Connection->FirstSendByteOffset = 0;
    Connection->sp.MessageBytesSent = 0;
    Connection->sp.CurrentSendIrp = Connection->FirstSendIrp;
    Connection->sp.CurrentSendMdl = Connection->FirstSendMdl;
    Connection->sp.SendByteOffset = Connection->FirstSendByteOffset;
    Connection->CurrentSendLength =
        IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp));
    Connection->StallCount = 0;
    Connection->StallBytesSent = 0;

    //
    // The send correlator isn't used for much; it is used so we
    // can distinguish which send a piggyback ack is acking.
    //

    if (Connection->NetbiosHeader.ResponseCorrelator == 0xffff) {
        Connection->NetbiosHeader.ResponseCorrelator = 1;
    } else {
        ++Connection->NetbiosHeader.ResponseCorrelator;
    }

} /* InitializeSend */
#endif


VOID
ReframeSend(
    PTP_CONNECTION Connection,
    ULONG BytesReceived
    )

/*++

Routine Description:

    This routine is called to reset the send state variables in the connection
    object to correctly point to the first byte of data to be transmitted.
    In essence, this is the byte-level acknowlegement processor at the NetBIOS
    level for this transport.

    This is not straightforward because potentially multiple send requests
    may be posted to the connection to comprise a single message.  When a
    send request has its TDI_END_OF_RECORD option bitflag set, then that
    send is the last one to be sent in a logical message.  Therefore, we
    assume that the multiple-send scenario is the general case.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    BytesReceived - Number of bytes received thus far.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PMDL Mdl;
    ULONG Offset;
    ULONG BytesLeft;
    ULONG MdlBytes;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ReframeSend: Entered for connection %lx, Flags: %lx Current Mdl: %lx\n",
            Connection, Connection->Flags, Connection->sp.CurrentSendMdl);
    }

    //
    // The caller is responsible for restarting the packetization process
    // on this connection.  In some cases (i.e., NO_RECEIVE handler) we
    // don't want to start packetizing, so that's why we do it elsewhere.
    //

    //
    // Examine all of the send requests and associated MDL chains starting
    // with the first one at the head of the connection's SendQueue, advancing
    // our complex current send pointer through the requests and MDL chains
    // until we reach the byte count he's specified.
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    //
    // In the case where a local disconnect has been issued, and we get a frame
    // that causes us to reframe the send our FirstSendIrp and FirstMdl 
    // pointers are stale.  Catch this condition and prevent faults caused by
    // this.  A better fix would be to change the logic that switches the
    // connection sendstate from idle to W_LINK to not do that.  However, this
    // is a broader change than fixing it right here.
    //

    if (IsListEmpty(&Connection->SendQueue)) {
        RELEASE_DPC_SPIN_LOCK(Connection->LinkSpinLock);
        return;
    }

    BytesLeft = BytesReceived;
    Irp = Connection->FirstSendIrp;
    Mdl = Connection->FirstSendMdl;
    if (Mdl) {
        MdlBytes = MmGetMdlByteCount (Mdl);
    } else {
        MdlBytes = 0;      // zero-length send
    }
    Offset = Connection->FirstSendByteOffset;

#if DBG
    IF_NBFDBG (NBF_DEBUG_TRACKTDI) {
        NbfPrint3 ("ReFrameSend: Called with Connection %lx FirstSend %lx CurrentSend %lx\n",
            Connection, Connection->FirstSendIrp, Connection->sp.CurrentSendIrp);
        Connection->DeferredFlags |= CONNECTION_FLAGS_DEFERRED_SENDS;
        Connection->DeferredPasses = 0;
    }
#endif

    //
    // We loop through while we have acked bytes left to account for,
    // advancing our pointers and completing any sends that have been
    // completely acked.
    //

    while (BytesLeft != 0) {

        if (Mdl == NULL) {
            KIRQL cancelIrql;

            //
            // We have exhausted the MDL chain on this request, so it has
            // been implicitly acked.  That means we must complete the I/O
            // by dereferencing the request before we reframe further.
            //

            p = RemoveHeadList (&Connection->SendQueue);
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

            //
            // Since the irp is no longer on the list, the cancel routine
            // won't find it. Grab the cancel spinlock to synchronize
            // and complete the irp.
            //

            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(Irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);

            NbfCompleteSendIrp (Irp, STATUS_SUCCESS, Offset);

            //
            // Now continue with the next request in the list.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            p = Connection->SendQueue.Flink;
            if (p == &Connection->SendQueue) {

                ULONG DumpData[2];

                //
                // The byte acknowledgement was for more than the
                // total length of sends we have outstanding; to
                // avoid problems we tear down the connection.
                //
#if DBG
                NbfPrint2 ("NbfReframeSend: Got %d extra bytes acked on %lx\n",
                            BytesLeft, Connection);
                ASSERT (FALSE);
#endif
                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                DumpData[0] = Offset;
                DumpData[1] = BytesLeft;

                NbfWriteGeneralErrorLog(
                    Connection->Provider,
                    EVENT_TRANSPORT_BAD_PROTOCOL,
                    1,
                    STATUS_INVALID_NETWORK_RESPONSE,
                    L"REFRAME",
                    2,
                    DumpData);

                NbfStopConnection (Connection, STATUS_INVALID_NETWORK_RESPONSE);

                return;

            }

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            Mdl = Irp->MdlAddress;
            MdlBytes = MmGetMdlByteCount (Mdl);
            Offset = 0;

        } else if (MdlBytes > (Offset + BytesLeft)) {

            //
            // This MDL has more data than we really need.  Just use
            // part of it.  Then get out, because we're done.
            //

            Offset += BytesLeft;
            BytesLeft = 0;
            break;

        } else {

            //
            // This MDL does not have enough data to satisfy the ACK, so
            // use as much data as it has, and cycle around again.
            //

            Offset = 0;
            BytesLeft -= MdlBytes;
            Mdl = Mdl->Next;

            if (Mdl != NULL) {
                MdlBytes = MmGetMdlByteCount (Mdl);
            }

        }
    }

    //
    // Tmp debugging; we want to see if we got byte acked
    // for the entire send. This will break if we have
    // non-EOR sends.
    //

#if DBG
    if (BytesReceived != 0) {
        ASSERTMSG ("NbfReframeSend: Byte ack for entire send\n",
                        Mdl != NULL);
    }
#endif

    //
    // We've acked some data, possibly on a byte or message boundary.
    // We must pretend we're sending a new message all over again,
    // starting with the byte immediately after the last one he acked.
    //

    Connection->FirstSendIrp = Irp;
    Connection->FirstSendMdl = Mdl;
    Connection->FirstSendByteOffset = Offset;

    //
    // Since we haven't started sending this new reframed message yet,
    // we set our idea of the current complex send pointer to the first
    // complex send pointer.
    //

    Connection->sp.MessageBytesSent = 0;
    Connection->sp.CurrentSendIrp = Irp;
    Connection->sp.CurrentSendMdl = Mdl;
    Connection->sp.SendByteOffset = Offset;
    Connection->CurrentSendLength -= BytesReceived;
    Connection->StallCount = 0;
    Connection->StallBytesSent = 0;

#if DBG
    IF_NBFDBG (NBF_DEBUG_TRACKTDI) {

    {
        PLIST_ENTRY p;
        NbfPrint0 ("ReFrameSend: Walking Send List:\n");

        for (
            p = Connection->SendQueue.Flink;
            p != &Connection->SendQueue;
            p=p->Flink                     ) {

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            NbfPrint1 ("              Irp %lx\n", Irp);
        }
    }}
#endif

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

} /* ReframeSend */


VOID
NbfCancelSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a send.
    The send is found on the connection's send queue; if it is the
    current request it is cancelled and the connection is torn down,
    otherwise it is silently cancelled.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql, oldirql1;
    PIO_STACK_LOCATION IrpSp;
    PTP_CONNECTION Connection;
    PIRP SendIrp;
    PLIST_ENTRY p;
    BOOLEAN Found;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_SEND));

    Connection = IrpSp->FileObject->FsContext;

    //
    // Since this IRP is still in the cancellable state, we know
    // that the connection is still around (although it may be in
    // the process of being torn down).
    //


    //
    // See if this is the IRP for the current send request.
    //

    ACQUIRE_SPIN_LOCK (Connection->LinkSpinLock, &oldirql);
    NbfReferenceConnection ("Cancelling Send", Connection, CREF_COMPLETE_SEND);

    p = Connection->SendQueue.Flink;
    SendIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

    if (SendIrp == Irp) {

        //
        // yes, it is the first one on the send queue, so
        // trash the send/connection.  The first send is a special case
        // there are multiple pointers to the send request.  Just stop the 
        // connection.
        //

        //        p = RemoveHeadList (&Connection->SendQueue);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = SendIrp;
        NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_CANCELLED;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

        //
        // Prevent anyone from getting in to packetize before we
        // call NbfStopConnection.
        //

        Connection->SendState = CONNECTION_SENDSTATE_IDLE;

        RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
        DbgPrint("NBF: Canceled in-progress send %lx on %lxn",
                SendIrp, Connection);
#endif

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

        //
        // The following dereference will complete the I/O, provided removes
        // the last reference on the request object.  The I/O will complete
        // with the status and information stored in the Irp.  Therefore,
        // we set those values here before the dereference.
        //

        // NbfCompleteSendIrp (SendIrp, STATUS_CANCELLED, 0);

        //
        // Since we are cancelling the current send, blow away
        // the connection.
        //

        NbfStopConnection (Connection, STATUS_CANCELLED);

        KeLowerIrql (oldirql1);

    } else {

        //
        // Scan through the list, looking for this IRP. If we
        // cancel anything up to the first EOR on the list
        // we still tear down the connection since this would
        // mess up our packetizing otherwise. We set CancelledFirstEor
        // to FALSE when we pass an IRP without SEND_PARTIAL.
        //
        // NO MATTER WHAT WE MUST SHUT DOWN THE CONNECTION!!!!

#if 0
        if (!(IRP_SEND_FLAGS(IoGetCurrentIrpStackLocation(SendIrp)) & TDI_SEND_PARTIAL)) {
            CancelledFirstEor = FALSE;
        } else {
            CancelledFirstEor = TRUE;
        }
#endif

        Found = FALSE;
        p = p->Flink;
        while (p != &Connection->SendQueue) {

            SendIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            if (SendIrp == Irp) {

                //
                // Found it, remove it from the list here.
                //

                RemoveEntryList (p);

                Found = TRUE;

#if DBG
                NbfCompletedSends[NbfCompletedSendsNext].Irp = SendIrp;
                NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_CANCELLED;
                NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

                RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
                IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
                DbgPrint("NBF: Canceled queued send %lx on %lx\n",
                        SendIrp, Connection);
#endif

                //
                // The following dereference will complete the I/O, provided removes
                // the last reference on the request object.  The I/O will complete
                // with the status and information stored in the Irp.  Therefore,
                // we set those values here before the dereference.
                //

                KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

                NbfCompleteSendIrp (SendIrp, STATUS_CANCELLED, 0);
                //
                // STOP THE CONNECTION NO MATTER WHAT!!!
                //
                NbfStopConnection (Connection, STATUS_CANCELLED);

                KeLowerIrql (oldirql1);
                break;

            } 
#if 0
            else {

                if (CancelledFirstEor && (!(IRP_SEND_FLAGS(IoGetCurrentIrpStackLocation(SendIrp)) & TDI_SEND_PARTIAL))) {
                    CancelledFirstEor = FALSE;
                }
            }
#endif

            p = p->Flink;

        }

        if (!Found) {

            //
            // We didn't find it!
            //

#if DBG
            DbgPrint("NBF: Tried to cancel send %lx on %lx, not found\n",
                    Irp, Connection);
#endif
            RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
            IoReleaseCancelSpinLock (Irp->CancelIrql);
        }

    }

    NbfDereferenceConnection ("Cancelling Send", Connection, CREF_COMPLETE_SEND);

}


BOOLEAN
ResendPacket (
    PTP_LINK Link,
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine resends a packet on the link. Since this is a resend, we
    are careful to not reset the state unless all resends have completed.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - pointer to packet to be resent.

Return Value:

    True if resending should continue; FALSE otherwise.

--*/

{
    BOOLEAN PollFinal;
    PDLC_I_FRAME DlcHeader;
    UINT DataLength;


    //

    DlcHeader = (PDLC_I_FRAME)&(Packet->Header[Link->HeaderLength]);

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ReSendPacket: %lx NdisPacket: %lx # %x\n",
                Packet, Packet->NdisPacket,
                DlcHeader->RcvSeq >>1);
        IF_NBFDBG (NBF_DEBUG_PKTCONTENTS) {
            {PUCHAR q;
            USHORT i;
            q = Packet->Header;
            for (i=0;i<20;i++) {
                NbfPrint1 (" %2x",q[i]);
            }
            NbfPrint0 ("\n");}
        }
    }

    DataLength = Packet->NdisIFrameLength;

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    Link->WindowErrors++;

    PollFinal = (BOOLEAN)((DlcHeader->RcvSeq & DLC_I_PF) != 0);

    StopT2 (Link);   // since this is potentially acking some frames

    if (Link->Provider->MacInfo.MediumAsync) {
        if (PollFinal) {
            ASSERT (Packet->Link != NULL);
            NbfReferenceLink ("ResendPacket", Link, LREF_START_T1);
        } else {
            StartT1 (Link, 0);
        }
    } else {
        StartT1 (Link, PollFinal ? DataLength : 0);  // restart transmission timer
    }

    //
    // Update the expected next receive in case it's changed
    //

    if (PollFinal) {

        DlcHeader->RcvSeq = DLC_I_PF;    // set the poll bit.
        Link->SendState = SEND_STATE_CHECKPOINTING;

        Link->ResendingPackets = FALSE;

    } else {

        DlcHeader->RcvSeq = 0;

    }

    //
    // DlcHeader->RcvSeq has Link->NextReceive inserted by NbfNdisSend.
    //

    NbfReferencePacket (Packet); // so we don't remove it in send completion

    NbfReferenceLink ("ResendPacket", Link, LREF_NDIS_SEND);

    ASSERT (Packet->PacketSent == TRUE);
    Packet->PacketSent = FALSE;

    //
    // Update our "bytes resent" counters.
    //

    DataLength -=
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);


    ADD_TO_LARGE_INTEGER(
        &Link->Provider->Statistics.DataFrameBytesResent,
        DataLength);
    ++Link->Provider->Statistics.DataFramesResent;


    //
    // Send the packet (this release the link spinlock).
    //

    NbfNdisSend (Link, Packet);

    ++Link->PacketsResent;

    NbfDereferenceLink ("ResendPacket", Link, LREF_NDIS_SEND);

    //
    // if this packet has  POLL set, stop the resending so the
    // link doesn't get all twisted up.
    //

    if (PollFinal) {

        //
        // so we're in the state of having sent a poll and not
        // sending anything else until we get a final. This avoids
        // overrunning the remote. Note that we leave the routine
        // with state LINK_SENDSTATE_REJECTING, which guarentees
        // we won't start any new sends until we traverse through
        // this routine again.
        //
        //

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ResendLlcPackets (
    PTP_LINK Link,
    UCHAR AckSequenceNumber,
    BOOLEAN Resend
    )

/*++

Routine Description:

    This routine advances the state of a data link connection by retiring
    all of the packets on the link's WackQ that have send sequence numbers
    logically less than that number specified as the AckSequenceNumber, and
    resending those above that number. The packets are disposed of by
    dereferencing them.  We cannot simply destroy them because this
    acknowlegement might arrive even before the Physical Provider has had a
    chance to issue a completion event for the associated I/O.

    NOTE: This function is called with the link spinlock held and
    returns with it held, but it may release it in between. THIS
    ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    AckSequenceNumber - An unsigned number specifing the sequence number of
        the first packet within the window that is NOT acknowleged.

    Resend - if TRUE, resend packets. If FALSE, just remove them from the
        wackq and get out.

Return Value:

    none.

--*/

{
    PTP_PACKET packet;
    PLIST_ENTRY p, p1;
    UCHAR packetSeq;
    BOOLEAN passedAck = FALSE;
    PDLC_I_FRAME DlcHeader;
    SCHAR Difference;
    BOOLEAN ReturnValue = FALSE;
//    NDIS_STATUS ndisStatus;

    //
    // Move through the queue, releasing those we've been acked for and resending
    // others above that.
    //

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ResendLlcPackets:  Link %lx, Ack: %x, LinkLastAck: %x.\n",
            Link, AckSequenceNumber, Link->LastAckReceived);
        NbfPrint0 ("RLP: Walking WackQ, Packets:\n");
        p = Link->WackQ.Flink;              // p = ptr, 1st pkt's linkage.
        while (p != &Link->WackQ) {
            packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
            DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);
            NbfPrint4 ("RLP: Pkt: %lx # %x Flags: %d %d\n", packet,
            (UCHAR)(DlcHeader->SendSeq >> 1), packet->PacketSent, packet->PacketNoNdisBuffer);
            p = packet->Linkage.Flink;
        }
    }

    //
    // If somebody else is resending LLC packets (which means they
    // are in this function with Resend == TRUE), then ignore
    // this frame. This is because it may ack a frame that he
    // is in the middle of resending, which will cause problems.
    //
    // This isn't a great solution, we should keep track
    // of where the other guy is and avoid stepping on him. This
    // might mess up his walking of the queue however.
    //

    if (Link->ResendingPackets) {
        NbfPrint1("ResendLlcPackets: Someone else resending on %lx\n", Link);
        return TRUE;
    }

    //
    // We have already checked that AckSequenceNumber is reasonable.
    //

    Link->LastAckReceived = AckSequenceNumber;

    if (Resend) {

        //
        // Only one person can be resending or potentially resending
        // at one time.
        //

        Link->ResendingPackets = TRUE;
    }

    //
    // Resend as many packets as we have window to send. We spin through the
    // queue and remove those packets that have been acked or that are
    // sequence numbered logically below the current ack number. The flags
    // PACKET_FLAGS_RESEND and PACKET_FLAGS_SENT correspond to the three states
    // a packet on this queue can be in:
    //
    //  1) if _RESEND is set, the packet has not been acked
    //
    //  2) if _SENT is set, the packet send has completed (conversely, if NOT
    //      set, the packet has not yet been completely sent, thus it is
    //      unnecessary to resend it).
    //  3) if _RESEND and _SENT are both set, the packet has been sent and not
    //      acked and is grist for our mills.
    //  4) if neither is set, the world is coming to an end next Thursday.
    //

    p=Link->WackQ.Flink;
    while (p != &Link->WackQ) {
        packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
        DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);

        //
        // if both bits aren't set we can't do a thing with this packet, or,
        // for that matter, with the rest of the packet list. We can't
        // have reached the ack number yet, as these packets haven't even
        // completed sending.
        // (Later) actually, we can have reached passedAck, and if we did
        // we're in a world of hurt. We can't send more regular packets,
        // but we can't send any resend packets either. Force the link to
        // checkpoint and things will clear themselves up later.
        //

        if (!(packet->PacketSent)) {
            if (passedAck) {
                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                    NbfPrint2 ("ResendLLCPacket: Can't send WACKQ Packet RcvSeq %x %x \n",
                      DlcHeader->RcvSeq, DlcHeader->SendSeq);
                }

                if (Link->SendState != SEND_STATE_CHECKPOINTING) {

                    //
                    // Don't start checkpointing if we already are.
                    //

                    Link->SendState = SEND_STATE_CHECKPOINTING;
                    StopTi (Link);
                    StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));  // start checkpoint timeout.
                    Link->ResendingPackets = FALSE;

                    //
                    // Try this...in this case don't actually send
                    // an RR, since his response might put us right
                    // back here. When T1 expires we will recover.
                    //
                    // NbfSendRr (Link, TRUE, TRUE);

                } else {

                    Link->ResendingPackets = FALSE;

                }

                return TRUE;
            }

            //
            // Don't break, since passedAck is FALSE all we will
            // do in the next section is TpDereferencePacket, which
            // is correct.
            //
            // break;
        }

        //
        // This loop is somewhat schizo; at this point, if we've not yet reached
        // the ack number, we'll be ditching the packet. If we've gone through
        // the ack number, we'll be re-transmitting. Note that in the first
        // personality, we are always looking at the beginning of the list.
        //

        //
        // NOTE: Link spinlock is held here.
        //

        packetSeq = (UCHAR)(DlcHeader->SendSeq >> 1);
        if (!passedAck){

            //
            // Compute the signed difference here; see if
            // packetSeq is equal to or "greater than"
            // LastAckReceived.
            //

            Difference = packetSeq - Link->LastAckReceived;

            if (((Difference >= 0) && (Difference < 0x40)) ||
                (Difference < -0x40)) {

                //
                // We have found a packet on the queue that was
                // not acknowledged by LastAckReceived.
                //

                if (Link->SendState == SEND_STATE_CHECKPOINTING) {

                    //
                    // If we are checkpointing, we should not do any of
                    // the passedAck things (i.e. any of the things which
                    // potentially involve sending packets) - adb 7/30/91.
                    //

                    if (Resend) {
                        Link->ResendingPackets = FALSE;
                    }
                    return TRUE;
                }

                if (!Resend) {

                    //
                    // If we are not supposed to resend, then exit.
                    // Since there are still packets on the queue
                    // we restart T1.
                    //

                    StopTi (Link);
                    StartT1 (Link, 0);  // start checkpoint timeout.
                    return TRUE;
                }

                //
                // Lock out senders, so we maintain packet sequences properly
                //

                Link->SendState = SEND_STATE_REJECTING; // we're resending.

                passedAck = TRUE;

                //
                // Note that we don't advance the pointer to the next packet;
                // thus, we will resend this packet on the next pass through
                // the while loop (taking the passedAck branch).
                //

            } else {
                p1 = RemoveHeadList (&Link->WackQ);
                ASSERTMSG (" ResendLLCPacket: Packet not at queue head!\n", (p == p1));
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                ReturnValue = TRUE;
                NbfDereferencePacket (packet);

                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                p = Link->WackQ.Flink;
            }

        } else {
//            NbfPrint1 ("RLP: # %x\n",packetSeq);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            //
            // If this call returns FALSE (because we checkpoint)
            // it clears ResendingPacket before it returns.
            //

            if (!ResendPacket (Link, packet)) {
                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                return ReturnValue;
            }

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            p = p->Flink;
        }
    }

    //
    // NOTE: Link spinlock is held here.
    //

    if (passedAck) {

        //
        // If we exit through here with passedAck TRUE, it means that we
        // successfully called ResendPacket on every packet in the
        // WackQ, which means we did not resend a poll packet, so we
        // can start sending normally again. We have to clear
        // ResendingPackets here.
        //

        Link->SendState = SEND_STATE_READY;
        Link->ResendingPackets = FALSE;
        StartTi (Link);

    } else if (!Resend) {

        //
        // If Resend is FALSE (in which case passedAck will also be FALSE,
        // by the way), and the WackQ is empty, that means that we
        // successfully acknowledged all the packets on a non-final
        // frame. In this case T1 may be running, but in fact is not
        // needed since there are no sends outstanding.
        //

        if (Link->WackQ.Flink == &Link->WackQ) {
            StopT1 (Link);
        }
        Link->SendState = SEND_STATE_READY;
        StartTi (Link);

    } else {

        //
        // Resend is TRUE, but passedAck is FALSE; we came in
        // expecting to resend, but didn't. This means that
        // we have emptied the queue after receiving an
        // RR/f, i.e. this send window is done and we can
        // update our send window size, etc.
        //

        Link->ResendingPackets = FALSE;

        if (Link->Provider->MacInfo.MediumAsync) {
            return ReturnValue;
        }

        if (Link->WindowErrors > 0) {

            //
            // We had transmit errors on this window.
            //

            Link->PrevWindowSize = Link->SendWindowSize;

            //
            // We use 100 ms delay as the cutoff for a LAN.
            //

            if (Link->Delay < (100*MILLISECONDS)) {

                //
                // On a LAN, if we have a special case
                // if one packet was lost; this means the
                // final packet was retransmitted once. In
                // that case, we keep track of Consecutive
                // LastPacketLost, and if it reaches 2, then
                // we lock the send window at its current
                // value minus one.
                //

                if (Link->WindowErrors == 1) {

                    ++Link->ConsecutiveLastPacketLost;

                    if (Link->ConsecutiveLastPacketLost >= 2) {

                        //
                        // Freeze the window wherever it was.
                        //

                        if (Link->SendWindowSize > Link->Provider->MinimumSendWindowLimit) {
                            Link->MaxWindowSize = Link->SendWindowSize - 1;
                            Link->SendWindowSize = (UCHAR)Link->MaxWindowSize;
                        }

                    }

                    //
                    // Otherwise, we leave the window where it is.
                    //

                } else {

                    Link->ConsecutiveLastPacketLost = 0;
                    Link->SendWindowSize -= (UCHAR)Link->WindowErrors;

                }

            } else {

                //
                // On a WAN we cut the send window in half,
                // regardless of how many frames were retransmitted.
                //

                Link->SendWindowSize /= 2;
                Link->WindowsUntilIncrease = 1;   // in case Prev is also 1.
                Link->ConsecutiveLastPacketLost = 0;

            }

            if ((SCHAR)Link->SendWindowSize < 1) {
                Link->SendWindowSize = 1;
            }

            //
            // Reset our counters for the next window.
            //

            Link->WindowErrors = 0;

        } else {

            //
            // We have successfully sent a window of data, increase
            // the send window size unless we are at the limit.
            // We use 100 ms delay as the WAN/LAN cutoff.
            //

            if ((ULONG)Link->SendWindowSize < Link->MaxWindowSize) {

                if (Link->Delay < (100*MILLISECONDS)) {

                    //
                    // On a LAN, increase the send window by 1.
                    //
                    // Need to determine optimal window size.
                    //

                    Link->SendWindowSize++;

                } else {

                    //
                    // On a WAN, increase the send window by 1 until
                    // we hit PrevWindowSize, then do it more slowly.
                    //

                    if (Link->SendWindowSize < Link->PrevWindowSize) {

                        Link->SendWindowSize++;

                        //
                        // If we just increased it to the previous window
                        // size, prepare for the next time through here.
                        //

                        if (Link->SendWindowSize == Link->PrevWindowSize) {
                            Link->WindowsUntilIncrease = Link->SendWindowSize;
                        }

                    } else {

                        //
                        // We passed the previous size, so only update every
                        // WindowsUntilIncrease times.
                        //

                        if (--Link->WindowsUntilIncrease == 0) {

                            Link->SendWindowSize++;
                            Link->WindowsUntilIncrease = Link->SendWindowSize;

                        }
                    }
                }

                if ((ULONG)Link->SendWindowSize > Link->Provider->Statistics.MaximumSendWindow) {
                    Link->Provider->Statistics.MaximumSendWindow = Link->SendWindowSize;
                }

            }

            //
            // Clear this since we had no errors.
            //

            Link->ConsecutiveLastPacketLost = 0;

        }

    }

    return ReturnValue;

} /* ResendLlcPackets */


VOID
NbfSendCompletionHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by the I/O system to indicate that a connection-
    oriented packet has been shipped and is no longer needed by the Physical
    Provider.

Arguments:

    NdisContext - the value associated with the adapter binding at adapter
                  open time (which adapter we're talking on).

    NdisPacket/RequestHandle - A pointer to the NDIS_PACKET that we sent.

    NdisStatus - the completion status of the send.

Return Value:

    none.

--*/

{
    PSEND_PACKET_TAG SendContext;
    PTP_PACKET Packet;
    KIRQL oldirql1;
    ProtocolBindingContext;  // avoid compiler warnings

#if DBG
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbfSendsCompletedAfterPendFail++;
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint2 ("NbfSendComplete: Entered for packet %lx, Status %s\n",
                NdisPacket, NbfGetNdisStatus (NdisStatus));
        }
    } else {
        NbfSendsCompletedAfterPendOk++;
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint2 ("NbfSendComplete: Entered for packet %lx, Status %s\n",
                NdisPacket, NbfGetNdisStatus (NdisStatus));
        }
    }
#endif

    SendContext = (PSEND_PACKET_TAG)&NdisPacket->ProtocolReserved[0];

    switch (SendContext->Type) {
    case TYPE_I_FRAME:

        //
        // Just dereference the packet.  There are a couple possibilities here.
        // First, the I/O completion might happen before an ACK is received,
        // in which case this will remove one of the references, but not both.
        // Second, the LLC ACK for this packet may have already been processed,
        // in which case this will destroy the packet.  Third, this packet may
        // be resent, either before or after this call, in which case the deref
        // won't destroy the packet.
        //
        // NbfDereferencePacket will call PacketizeSend if it determines that
        // there is at least one connection waiting to be packetized because
        // of out-of-resource conditions or because its window has been opened.
        //

        Packet = ((PTP_PACKET)SendContext->Frame);

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

        if (Packet->Provider->MacInfo.MediumAsync) {

            if (Packet->Link) {

                ASSERT (Packet->NdisIFrameLength > 0);

                ACQUIRE_DPC_SPIN_LOCK (&Packet->Link->SpinLock);
                StartT1 (Packet->Link, Packet->NdisIFrameLength);
                RELEASE_DPC_SPIN_LOCK (&Packet->Link->SpinLock);

                NbfDereferenceLink ("Send completed", Packet->Link, LREF_START_T1);
            }

            if (Packet->PacketizeConnection) {

                PTP_CONNECTION Connection = IRP_SEND_CONNECTION((PIO_STACK_LOCATION)(Packet->Owner));
                PDEVICE_CONTEXT DeviceContext = Packet->Provider;

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                if ((Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE) &&
                    (Connection->Flags & CONNECTION_FLAGS_READY)) {

                    ASSERT (Connection->Flags & CONNECTION_FLAGS_PACKETIZE);

                    ACQUIRE_DPC_SPIN_LOCK(&DeviceContext->SpinLock);

                    NbfReferenceConnection ("Delayed packetizing", Connection, CREF_PACKETIZE_QUEUE);
                    InsertTailList(&DeviceContext->PacketizeQueue, &Connection->PacketizeLinkage);

                    if (!DeviceContext->WanThreadQueued) {

                        DeviceContext->WanThreadQueued = TRUE;
                        ExQueueWorkItem(&DeviceContext->WanDelayedQueueItem, DelayedWorkQueue);

                    }

                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

                } else {

                    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

                }

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                NbfDereferenceConnection ("PacketizeConnection FALSE", Connection, CREF_TEMP);

                Packet->PacketizeConnection = FALSE;

            }
        }
#if DBG
        if (Packet->PacketSent) {
            DbgPrint ("NbfSendCompletionHandler: Packet %lx already completed\n", Packet);
            DbgBreakPoint();
        }
#endif
        Packet->PacketSent = TRUE;

        NbfDereferencePacket (Packet);

        KeLowerIrql (oldirql1);
        break;

    case TYPE_UI_FRAME:

        //
        // just destroy the frame; name stuff doesn't depend on having any
        // of the sent message left around after the send completed.
        //

        NbfDestroyConnectionlessFrame ((PDEVICE_CONTEXT)SendContext->Owner,
                         (PTP_UI_FRAME)SendContext->Frame);
        break;

    case TYPE_ADDRESS_FRAME:

        //
        // Addresses get their own frames; let the address know it's ok to
        // use the frame again.
        //

        NbfSendDatagramCompletion ((PTP_ADDRESS)SendContext->Owner,
            NdisPacket,
            NdisStatus );
        break;
    }

    return;

} /* NbfSendCompletionHandler */


NTSTATUS
SendOnePacket(
    IN PTP_CONNECTION Connection,
    IN PTP_PACKET Packet,
    IN BOOLEAN ForceAck,
    OUT PBOOLEAN LinkCheckpoint OPTIONAL
    )

/*++

Routine Description:

    This routine sends a connection-oriented packet by calling the NDIS
    Send service.  At least one event will occur following
    (or during) the Send request's processing.  (1) The Send request
    will complete through the I/O system, calling IoCompleteRequest.
    (2) The sequenced packet will be acknowleged at the LLC level, or it
    will be rejected and reset at the LLC level.  If the packet is resent,
    then it remains queued at the TP_LINK object.  If the packet is ACKed,
    then is removed from the link's WackQ and the Action field in the
    TP_PACKET structure dictates what operation to perform next.

    NOTE: This routine is called with the link spinlock held. THIS
    ROUTINE MUST BE CALLED AT DPC LEVEL.

    NOTE: This routine will now accept all frames unless the link
    is down. If the link cannot send, the packet will be queued and
    sent when possible.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Packet - Pointer to a TP_PACKET object.

    ForceAck - Boolean that, if true, indicates this packet should always have
            the Poll bit set; this force the other side to ack immediately,
            which is necessary for correct session teardown.

    LinkCheckpoint - If specified, will return TRUE if the link has
            just entered a checkpoint state. In this case the status
            will be STATUS_SUCCESS, but the connection should stop
            packetizing now (in fact, to close a window, the connection
            is put into the W_LINK state if this status will be
            returned, so he must stop because somebody else may
            already be doing it).

Return Value:

    STATUS_LINK_FAILED - the link is dead or not ready.
    STATUS_SUCCESS - the packet has been sent.
    STATUS_INSUFFICIENT_RESOURCES - the packet has been queued.

--*/

{
    PTP_LINK Link;
    PDLC_I_FRAME DlcHeader;
    PNDIS_BUFFER ndisBuffer;
    ULONG SendsOutstanding;
    BOOLEAN Poll = FALSE;
    NTSTATUS Status;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint3 ("SendOnePacket: Entered, connection %lx, packet %lx DnisPacket %lx.\n",
                    Connection, Packet, Packet->NdisPacket);
    }

    Link = Connection->Link;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        UINT PLength, PCount;
        UINT BLength;
        PVOID BAddr;
        NdisQueryPacket(Packet->NdisPacket, &PCount, NULL, &ndisBuffer, &PLength);
        NbfPrint3 ("Sending Data Packet: %lx, Length: %lx Pages: %lx\n",
            Packet->NdisPacket, PLength, PCount);
        while (ndisBuffer != NULL) {
            NdisQueryBuffer(ndisBuffer, &BAddr, &BLength);
            NbfPrint3 ("Sending Data Packet: Buffer %08lx Length %08lx Va %08lx\n",
                ndisBuffer, BLength, BAddr);
            NdisGetNextBuffer (ndisBuffer, &ndisBuffer);
        }
    }

    //
    // If the general state of the link is not READY, then we can't ship.
    // This failure can be expected under some conditions, and may not cause
    // failure of the send.
    //

    if (Link->State != LINK_STATE_READY) {
        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint1 ("SendOnePacket:  Link state is not READY (%ld).\n", Link->State);
        }

        //
        // determine what to do with this problem. If we shouldn't be sending
        // here, percolate an error upward.
        //

        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint3 ("SendOnePacket: Link Bad state, link: %lx Link Flags %lx Link State %lx\n",
                Link, Link->Flags, Link->State);
        }
        return STATUS_LINK_FAILED;
    }


    SendsOutstanding = (((ULONG)Link->NextSend+128L-(ULONG)Link->LastAckReceived)%128L);

    //
    // Format LLC header while we've got the spinlock to atomically update
    // the link's state information.
    //

    DlcHeader = (PDLC_I_FRAME)&(Packet->Header[Link->HeaderLength]);
    DlcHeader->SendSeq = (UCHAR)(Link->NextSend << 1);
    Link->NextSend = (UCHAR)((Link->NextSend + 1) & 0x7f);
    DlcHeader->RcvSeq = 0;   // Link->NextReceive is inserted by NbfNdisSend

    //
    // Before we release the spinlock, we append the packet to the
    // end of the link's WackQ, so that if an ACK arrives before the NdisSend
    // completes, it will be on the queue already. Also, mark the packet as
    // needing resend, which is canceled by AckLLCPackets, and used by
    // ResendLLCPackets. Thus, all packets will need to be resent until they
    // are acked.
    //

    ASSERT (Packet->PacketSent == FALSE);

    InsertTailList (&Link->WackQ, &Packet->Linkage);
    //SrvCheckListIntegrity( &Link->WackQ, 200 );


    //
    // If the send state is not READY, we can't ship.
    // This failure is mostly caused by flow control or retransmit in progress,
    // and is never cause for failure of the send.
    //

    if ((Link->SendState != SEND_STATE_READY) ||
        (Link->LinkBusy) ||
        (SendsOutstanding >= (ULONG)Link->SendWindowSize)) {

        if ((Link->SendWindowSize == 1) || ForceAck) {
            DlcHeader->RcvSeq |= DLC_I_PF;                  // set the poll bit.
            if (Link->Provider->MacInfo.MediumAsync) {
                Packet->Link = Link;
            }
        }

        Packet->PacketSent = TRUE;        // allows it to be resent.

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

#if DBG
        if (Link->SendState != SEND_STATE_READY) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint1 ("SendOnePacket:  Link send state not READY (%ld).\n", Link->SendState);
            }
        } else if (Link->LinkBusy) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                PANIC ("SendOnePacket:  Link is busy.\n");
            }
        } else if (SendsOutstanding >= (ULONG)Link->SendWindowSize) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint3 ("SendOnePacket:  No link send window; N(S)=%ld,LAR=%ld,SW=%ld.\n",
                          Link->NextSend, Link->LastAckReceived, Link->SendWindowSize);
            }
        }
#endif

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reference the packet since it is given to the NDIS driver.
    //

#if DBG
    NbfReferencePacket (Packet);
#else
    ++Packet->ReferenceCount;     // OK since it is not queued anywhere.
#endif

    //
    // If this is the last I-frame in the window, then indicate that we
    // should checkpoint.  Also checkpoint if the sender is requesting
    // acknowledgement (currently on SendSessionEnd does this).
    // By default, this will also be a command frame.
    //

    if (((SendsOutstanding+1) >= (ULONG)Link->SendWindowSize) ||
            ForceAck) {
        Link->SendState = SEND_STATE_CHECKPOINTING;
        StopTi (Link);
        DlcHeader->RcvSeq |= DLC_I_PF;                  // set the poll bit.
        Poll = TRUE;

    }


    //
    // If we are polling, and the caller cares about it, then
    // we set LinkCheckpoint, and also set up the connection to
    // be waiting for resources. We do this now, before the send,
    // so that even if the ack is receive right away, we will
    // be in a good state. When we return LinkCheckpoint TRUE
    // the caller realizes that he no longer owns the right
    // to "packetize" and exits immediately.
    //
    // We also want to start our retransmission timer so, if this
    // packet gets dropped, we will know to retransmit it. The
    // exception is if LinkCheckpoint was specified, then we
    // only StartT1 of we are not polling (the caller will
    // ensure it is started if he exits before we poll).
    //

    if (ARGUMENT_PRESENT(LinkCheckpoint)) {

        if (Poll) {

            //
            // If the connection still has send state PACKETIZE,
            // then change it to W_LINK. If it is something else
            // (such as W_PACKET or W_ACK) then don't worry, when
            // that condition clears he will repacketize and the
            // link conditions will be re-examined. In all
            // case we turn off the PACKETIZE flag, because when
            // we return with LinkCheckpoint TRUE he will stop
            // packetizing, and to close the window we turn it
            // off now (before the NdisSend) rather than then.
            //

            ASSERT (Connection->LinkSpinLock == &Link->SpinLock);
            if (Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE) {
                Connection->SendState = CONNECTION_SENDSTATE_W_LINK;
            }
            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

            if (Link->Provider->MacInfo.MediumAsync) {
                Packet->Link = Link;
                NbfReferenceLink ("Send I-frame", Link, LREF_START_T1);
            } else {
                StartT1 (Link, Packet->NdisIFrameLength);
            }
            *LinkCheckpoint = TRUE;

        } else {

            StartT1 (Link, 0);
            *LinkCheckpoint = FALSE;

        }

    } else {

        //
        // If LinkCheckpoint is not true, then we are sending
        // an I-frame other than DFM/DOL. In this case, as
        // an optimization, we'll set W_LINK if a) we are
        // polling b) we are IDLE (to avoid messing up other
        // states such as W_ACK). This will avoid a window
        // where we don't go W_LINK until after the next
        // send tries to packetize and fails.
        //

        if (Poll) {

            ASSERT (Connection->LinkSpinLock == &Link->SpinLock);
            if (Connection->SendState == CONNECTION_SENDSTATE_IDLE) {
                Connection->SendState = CONNECTION_SENDSTATE_W_LINK;
            }

        }

        //
        // This is an optimization; we know that if LinkCheckpoint
        // is present than we are being called from PacketizeSend;
        // in this case the Link will have the LREF_CONNECTION
        // reference and the connection will have the CREF_PACKETIZE
        // reference, so we don't have to reference the link
        // again.
        //

        NbfReferenceLink ("SendOnePacket", Link, LREF_NDIS_SEND);


        //
        // Start the retransmission timer.
        //

        if (Link->Provider->MacInfo.MediumAsync) {
            if (Poll) {
                Packet->Link = Link;
                NbfReferenceLink ("ResendPacket", Link, LREF_START_T1);
            } else {
                StartT1 (Link, 0);
            }
        } else {
            StartT1 (Link, Poll ? Packet->NdisIFrameLength : 0);
        }

    }

    //
    // Since this I-frame contains an N(R), it is potentially ACKing some
    // previously received I-frames as reverse traffic.  So we stop our
    // delayed acknowlegement timer.
    //

    StopT2 (Link);

    if ((Link->Provider->MacInfo.MediumAsync) &&
        (ARGUMENT_PRESENT(LinkCheckpoint)) &&
        (Link->SendWindowSize >= 3) &&
        (!Poll) && (SendsOutstanding == (ULONG)(Link->SendWindowSize-2))) {

        Status = STATUS_MORE_PROCESSING_REQUIRED;

        Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;
        NbfReferenceConnection ("PacketizeConnection TRUE", Connection, CREF_TEMP);
        Packet->PacketizeConnection = TRUE;

    } else {

        Status = STATUS_SUCCESS;
    }

    //
    // Send the packet; no locks held. Note that if the send fails, we will
    // NOT fail upward; we allow things to continue onward. This lets us retry
    // the send multiple times before we give out; additionally, it keeps us
    // from failing obscurely when sending control Iframes.
    //
    // NOTE: NbfNdisSend releases the link spinlock.
    //

    NbfNdisSend (Link, Packet);

    Link->PacketsSent++;

    //
    // Remove the reference made above if needed.
    //

    if (!ARGUMENT_PRESENT(LinkCheckpoint)) {
        NbfDereferenceLink ("SendOnePacket", Link, LREF_NDIS_SEND);
    }

    return Status;

} /* SendOnePacket */


VOID
SendControlPacket(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine sends a connection-oriented packet by calling the Physical
    Provider's Send service.  While SendOnePacket is used to send an I-
    frame, this routine is used to send one of the following: RR, RNR, REJ,
    SABME, UA, DISC, DM, FRMR, TEST, and XID.

    NOTE: This function is called with the link spinlock held,
    and returns with it released. IT MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - Pointer to a TP_PACKET object.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    USHORT i;
    PUCHAR p;
    PNDIS_BUFFER ndisBuffer;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint3 ("SendControlPacket: Entered for link %lx, packet %lx, NdisPacket %lx\n 00:",
                Link, Packet, Packet->NdisPacket);
        IF_NBFDBG (NBF_DEBUG_PKTCONTENTS) {
            UINT PLength, PCount;
            UINT BLength;
            PVOID BAddr;
            p = Packet->Header;
            for (i=0;i<20;i++) {
                NbfPrint1 (" %2x",p[i]);
            }
            NbfPrint0 ("\n");
            NdisQueryPacket(Packet->NdisPacket, &PCount, NULL, &ndisBuffer, &PLength);
            NbfPrint3 ("Sending Control Packet: %lx, Length: %lx Pages: %lx\n",
                Packet->NdisPacket, PLength, PCount);
            while (ndisBuffer != NULL) {
                NdisQueryBuffer (ndisBuffer, &BAddr, &BLength);
                NbfPrint3 ("Sending Control Packet: Buffer %08lx Length %08lx Va %08lx\n",
                    ndisBuffer, BLength, BAddr);
                NdisGetNextBuffer (ndisBuffer, &ndisBuffer);
            }
        }
    }

    ASSERT (Packet->PacketSent == FALSE);

    NbfReferenceLink ("SendControlPacket", Link, LREF_NDIS_SEND);

    //
    // Send the packet (we have the lock, NbfNdisSend released
    // it.
    //

    NbfNdisSend (Link, Packet);

    NbfDereferenceLink ("SendControlPacket", Link, LREF_NDIS_SEND);

} /* SendControlPacket */


VOID
NbfNdisSend(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine is used to ensure that receive sequence numbers on
    packets are numbered correctly. It is called in place of NdisSend
    and after assigning the receive sequence number it locks out other
    sends until the NdisSend call has returned (not necessarily completed),
    insuring that the packets with increasing receive sequence numbers
    are queue in the right order by the MAC.

    NOTE: This routine is called with the link spinlock held,
    and it returns with it released. THIS ROUTINE MUST BE CALLED
    AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - Pointer to a TP_PACKET object.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PLIST_ENTRY p;
    PDLC_S_FRAME DlcHeader;
    PNDIS_PACKET TmpNdisPacket;
    ULONG result;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (Link->Provider->UniProcessor) {

        //
        // On a uni-processor, we can send without fear of
        // being interrupted by an incoming packet.
        //

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

        DlcHeader = (PDLC_S_FRAME)&(Packet->Header[Link->HeaderLength]);

        if ((DlcHeader->Command & DLC_U_INDICATOR) != DLC_U_INDICATOR) {

            //
            // It's not a U-frame, so we assign RcvSeq.
            //

            DlcHeader->RcvSeq |= (UCHAR)(Link->NextReceive << 1);

        }

#if DBG
        NbfSendsIssued++;
#endif

        INCREMENT_COUNTER (Link->Provider, PacketsSent);

#if PKT_LOG
        // Log this packet in connection's sent packets' queue
        NbfLogSndPacket(Link, Packet);
#endif // PKT_LOG

        if (Link->Loopback) {

            //
            // This packet is sent to ourselves; we should loop it
            // back.
            //

            NbfInsertInLoopbackQueue(
                Link->Provider,
                Packet->NdisPacket,
                Link->LoopbackDestinationIndex
                );

            NdisStatus = NDIS_STATUS_PENDING;

        } else {

            if (Link->Provider->NdisBindingHandle) {
            
                NdisSend (
                    &NdisStatus,
                    Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket);
            }
            else {
                NdisStatus = STATUS_INVALID_DEVICE_STATE;
            }
        }

        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint1 ("NbfNdisSend: NdisSend completed Status: %s.\n",
                      NbfGetNdisStatus(NdisStatus));
        }

        switch (NdisStatus) {

            case NDIS_STATUS_PENDING:
#if DBG
                NbfSendsPended++;
#endif
                break;

            case NDIS_STATUS_SUCCESS:
#if DBG
                NbfSendsCompletedInline++;
                NbfSendsCompletedOk++;
#endif
                NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket,
                    NDIS_STATUS_SUCCESS);
                break;

            default:
#if DBG
                NbfSendsCompletedInline++;
                NbfSendsCompletedFail++;
#endif
                NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket,
                    NDIS_STATUS_SUCCESS);

                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                    NbfPrint1 ("NbfNdisSend failed, status not Pending or Complete: %lx.\n",
                              NbfGetNdisStatus (NdisStatus));
                }
                break;

        }

    } else {

        //
        // If there is a send in progress, then queue this packet
        // and return.
        //

        if (Link->NdisSendsInProgress > 0) {

            p = (PLIST_ENTRY)(Packet->NdisPacket->MacReserved);
            InsertTailList (&Link->NdisSendQueue, p);
            ++Link->NdisSendsInProgress;
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            return;

        }

        //
        // No send in progress. Set the flag to true, and fill in the
        // receive sequence field in the packet (note that the RcvSeq
        // field is in the same place for I- and S-frames.
        //

        Link->NdisSendsInProgress = 1;

        while (TRUE) {

            DlcHeader = (PDLC_S_FRAME)&(Packet->Header[Link->HeaderLength]);

            if ((DlcHeader->Command & DLC_U_INDICATOR) != DLC_U_INDICATOR) {

                //
                // It's not a U-frame, so we assign RcvSeq.
                //

                DlcHeader->RcvSeq |= (UCHAR)(Link->NextReceive << 1);

            }

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

#if DBG
            NbfSendsIssued++;
#endif

            INCREMENT_COUNTER (Link->Provider, PacketsSent);

#if PKT_LOG
            // Log this packet in connection's sent packets' queue
            NbfLogSndPacket(Link, Packet);
#endif // PKT_LOG

            if (Link->Loopback) {

                //
                // This packet is sent to ourselves; we should loop it
                // back.
                //

                NbfInsertInLoopbackQueue(
                    Link->Provider,
                    Packet->NdisPacket,
                    Link->LoopbackDestinationIndex
                    );

                NdisStatus = NDIS_STATUS_PENDING;

            } else {

                if (Link->Provider->NdisBindingHandle) {
                
                    NdisSend (
                        &NdisStatus,
                        Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket);
                }
                else {
                    NdisStatus = STATUS_INVALID_DEVICE_STATE;
                }
            }

            //
            // Take the ref count down, which may allow others
            // to come through.
            //

            result = ExInterlockedAddUlong(
                         &Link->NdisSendsInProgress,
                         (ULONG)-1,
                         &Link->SpinLock);

            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint1 ("NbfNdisSend: NdisSend completed Status: %s.\n",
                          NbfGetNdisStatus(NdisStatus));
            }

            switch (NdisStatus) {

                case NDIS_STATUS_PENDING:
#if DBG
                    NbfSendsPended++;
#endif
                    break;

                case NDIS_STATUS_SUCCESS:
#if DBG
                    NbfSendsCompletedInline++;
                    NbfSendsCompletedOk++;
#endif
                    NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket,
                        NDIS_STATUS_SUCCESS);
                    break;

                default:
#if DBG
                    NbfSendsCompletedInline++;
                    NbfSendsCompletedFail++;
#endif
                    NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket,
                        NDIS_STATUS_SUCCESS);

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint1 ("NbfNdisSend failed, status not Pending or Complete: %lx.\n",
                                  NbfGetNdisStatus (NdisStatus));
                    }
                    break;

            }

            //
            // We have now sent a packet, see if any queued up while we
            // were doing it. If the count was zero after removing ours,
            // then anything else queued is being processed, so we can
            // exit.
            //

            if (result == 1) {
                return;
            }

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

            p = RemoveHeadList(&Link->NdisSendQueue);

            //
            // If the refcount was not zero, then nobody else should
            // have taken packets off since they would have been
            // blocked by us. So, the queue should not be empty.
            //

            ASSERT (p != &Link->NdisSendQueue);

            //
            // Get back the TP_PACKET by using the Frame pointer in the
            // ProtocolReserved field of the NDIS_PACKET.
            //

            TmpNdisPacket = CONTAINING_RECORD (p, NDIS_PACKET, MacReserved[0]);
            Packet = (PTP_PACKET)(((PSEND_PACKET_TAG)(&TmpNdisPacket->ProtocolReserved[0]))->Frame);

        }   // while loop


        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    }

}   /* NbfNdisSend */


VOID
RestartLinkTraffic(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine continues the activities of the connections on a link.

    NOTE: This function is called with the link spinlock held and
    it returns with it released. THIS FUNCTION MUST BE CALLED AT
    DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

Return Value:

    none.

--*/

{
    PTP_CONNECTION connection;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("RestartLinkTraffic:  Entered for link %lx.\n", Link);
    }

    //
    // Link conditions may have cleared up.  Make all connections on this
    // link eligible for more packetization if they are in W_LINK state.
    //

    for (p = Link->ConnectionDatabase.Flink;
         p != &Link->ConnectionDatabase;
         p = p->Flink) {

        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);

        ASSERT (connection->LinkSpinLock == &Link->SpinLock);

        //
        // If we tried to send a plain-ole data frame DFM/DOL, but
        // link conditions were not satisfactory, then we changed
        // send state to W_LINK.  Check for that now, and possibly
        // start repacketizing.
        //

        if (connection->SendState == CONNECTION_SENDSTATE_W_LINK) {
            if (!(IsListEmpty (&connection->SendQueue))) {

                connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;

                //
                // This is similar to calling StartPacketizingConnection
                // with the Immediate set to FALSE.
                //

                if (!(connection->Flags & CONNECTION_FLAGS_PACKETIZE) &&
                    (connection->Flags & CONNECTION_FLAGS_READY)) {

                    ASSERT (!(connection->Flags2 & CONNECTION_FLAGS2_STOPPING));
                    connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

                    NbfReferenceConnection ("Packetize", connection, CREF_PACKETIZE_QUEUE);

                    ExInterlockedInsertTailList(
                        &connection->Provider->PacketizeQueue,
                        &connection->PacketizeLinkage,
                        &connection->Provider->SpinLock);

                }

            } else {
                connection->SendState = CONNECTION_SENDSTATE_IDLE;
            }
        }

    }

    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

} /* RestartLinkTraffic */


VOID
NbfProcessWanDelayedQueue(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This is the thread routine which restarts packetizing
    that has been delayed on WAN to allow RRs to come in.
    This is very similar to PacketizeConnections.

Arguments:

    Parameter - A pointer to the device context.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    PLIST_ENTRY p;
    PTP_CONNECTION Connection;
    KIRQL oldirql;

    DeviceContext = (PDEVICE_CONTEXT)Parameter;

    //
    // Packetize all waiting connections
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);
    ASSERT (DeviceContext->WanThreadQueued);

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    while (!IsListEmpty(&DeviceContext->PacketizeQueue)) {

        p = RemoveHeadList(&DeviceContext->PacketizeQueue);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, PacketizeLinkage);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        if (Connection->SendState != CONNECTION_SENDSTATE_PACKETIZE) {
            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfDereferenceConnection ("No longer packetizing", Connection, CREF_PACKETIZE_QUEUE);
        } else {
            NbfReferenceSendIrp ("Packetize", IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp), RREF_PACKET);
            PacketizeSend (Connection, FALSE);     // releases the lock.
        }

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    }

    DeviceContext->WanThreadQueued = FALSE;

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    KeLowerIrql (oldirql);

}   /* NbfProcessWanDelayedQueue */


NTSTATUS
BuildBufferChainFromMdlChain (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PMDL CurrentMdl,
    IN ULONG ByteOffset,
    IN ULONG DesiredLength,
    OUT PNDIS_BUFFER *Destination,
    OUT PMDL *NewCurrentMdl,
    OUT ULONG *NewByteOffset,
    OUT ULONG *TrueLength
    )

/*++

Routine Description:

    This routine is called to build an NDIS_BUFFER chain from a source Mdl chain and
    offset into it. We assume we don't know the length of the source Mdl chain,
    and we must allocate the NDIS_BUFFERs for the destination chain, which
    we do from the NDIS buffer pool.

    The NDIS_BUFFERs that are returned are mapped and locked. (Actually, the pages in
    them are in the same state as those in the source MDLs.)

    If the system runs out of memory while we are building the destination
    NDIS_BUFFER chain, we completely clean up the built chain and return with
    NewCurrentMdl and NewByteOffset set to the current values of CurrentMdl
    and ByteOffset. TrueLength is set to 0.

Environment:

    Kernel Mode, Source Mdls locked. It is recommended, although not required,
    that the source Mdls be mapped and locked prior to calling this routine.

Arguments:

    BufferPoolHandle - The buffer pool to allocate buffers from.

    CurrentMdl - Points to the start of the Mdl chain from which to draw the
    packet.

    ByteOffset - Offset within this MDL to start the packet at.

    DesiredLength - The number of bytes to insert into the packet.

    Destination - returned pointer to the NDIS_BUFFER chain describing the packet.

    NewCurrentMdl - returned pointer to the Mdl that would be used for the next
        byte of packet. NULL if the source Mdl chain was exhausted.

    NewByteOffset - returned offset into the NewCurrentMdl for the next byte of
        packet. NULL if the source Mdl chain was exhausted.

    TrueLength - The actual length of the returned NDIS_BUFFER Chain. If less than
        DesiredLength, the source Mdl chain was exhausted.

Return Value:

    STATUS_SUCCESS if the build of the returned NDIS_BUFFER chain succeeded (even if
    shorter than the desired chain).

    STATUS_INSUFFICIENT_RESOURCES if we ran out of NDIS_BUFFERs while building the
    destination chain.

--*/
{
    ULONG AvailableBytes;
    PMDL OldMdl;
    PNDIS_BUFFER NewNdisBuffer;
    NDIS_STATUS NdisStatus;

    //

    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint3 ("BuildBufferChain: Mdl: %lx Offset: %ld Length: %ld\n",
            CurrentMdl, ByteOffset, DesiredLength);
    }

    AvailableBytes = MmGetMdlByteCount (CurrentMdl) - ByteOffset;
    if (AvailableBytes > DesiredLength) {
        AvailableBytes = DesiredLength;
    }

    OldMdl = CurrentMdl;
    *NewCurrentMdl = OldMdl;
    *NewByteOffset = ByteOffset + AvailableBytes;
    *TrueLength = AvailableBytes;


    //
    // Build the first NDIS_BUFFER, which could conceivably be the only one...
    //

    NdisCopyBuffer(
        &NdisStatus,
        &NewNdisBuffer,
        DeviceContext->NdisBufferPool,
        OldMdl,
        ByteOffset,
        AvailableBytes);

        
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        *NewByteOffset = ByteOffset;
        *TrueLength = 0;
        *Destination = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Destination = NewNdisBuffer;


//    IF_NBFDBG (NBF_DEBUG_SENDENG) {
//        PVOID PAddr, UINT PLen;
//        NdisQueryBuffer (NewNdisBuffer, &PAddr, &PLen);
//        NbfPrint4 ("BuildBufferChain: (start)Built Mdl: %lx Length: %lx, Next: %lx Va: %lx\n",
//            NewNdisBuffer, PLen, NDIS_BUFFER_LINKAGE(NewNdisBuffer), PAddr);
//    }

    //
    // Was the first NDIS_BUFFER enough data, or are we out of Mdls?
    //

    if ((AvailableBytes == DesiredLength) || (OldMdl->Next == NULL)) {
        if (*NewByteOffset >= MmGetMdlByteCount (OldMdl)) {
            *NewCurrentMdl = OldMdl->Next;
            *NewByteOffset = 0;
        }
        return STATUS_SUCCESS;
    }

    //
    // Need more data, so follow the in Mdl chain to create a packet.
    //

    OldMdl = OldMdl->Next;
    *NewCurrentMdl = OldMdl;

    while (OldMdl != NULL) {
        AvailableBytes = DesiredLength - *TrueLength;
        if (AvailableBytes > MmGetMdlByteCount (OldMdl)) {
            AvailableBytes = MmGetMdlByteCount (OldMdl);
        }

        NdisCopyBuffer(
            &NdisStatus,
            &(NDIS_BUFFER_LINKAGE(NewNdisBuffer)),
            DeviceContext->NdisBufferPool,
            OldMdl,
            0,
            AvailableBytes);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            //
            // ran out of resources. put back what we've used in this call and
            // return the error.
            //

            while (*Destination != NULL) {
                NewNdisBuffer = NDIS_BUFFER_LINKAGE(*Destination);
                NdisFreeBuffer (*Destination);
                *Destination = NewNdisBuffer;
            }

            *NewByteOffset = ByteOffset;
            *TrueLength = 0;
            *NewCurrentMdl = CurrentMdl;

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NewNdisBuffer = NDIS_BUFFER_LINKAGE(NewNdisBuffer);

        *TrueLength += AvailableBytes;
        *NewByteOffset = AvailableBytes;

//        IF_NBFDBG (NBF_DEBUG_SENDENG) {
//            PVOID PAddr, UINT PLen;
//            NdisQueryBuffer (NewNdisBuffer, &PAddr, &PLen);
//            NbfPrint4 ("BuildBufferChain: (continue) Built Mdl: %lx Length: %lx, Next: %lx Va: %lx\n",
//                NewNdisBuffer, PLen, NDIS_BUFFER_LINKAGE(NewNdisBuffer), PAddr);
//        }

        if (*TrueLength == DesiredLength) {
            if (*NewByteOffset == MmGetMdlByteCount (OldMdl)) {
                *NewCurrentMdl = OldMdl->Next;
                *NewByteOffset = 0;
            }
            return STATUS_SUCCESS;
        }
        OldMdl = OldMdl->Next;
        *NewCurrentMdl = OldMdl;

    } // while (mdl chain exists)

    *NewCurrentMdl = NULL;
    *NewByteOffset = 0;
    return STATUS_SUCCESS;

} // BuildBufferChainFromMdlChain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\testnbf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    testtdi.c

Abstract:

    Kernel Mode test program for any Tdi network provider. This routine is an
    example of how to use the TDI interface at the kernel level.

Author:

    Dave Beaver (DBeaver) 5 June 1991

Revision History:

--*/

#include "nbf.h"
#include <ctype.h>

#define TRANSPORT_NAME L"\\Device\\Nbf"

PSZ ServerName = "DCTDISERVER     ";
PSZ ClientName = "DCTDICLIENT     ";
PSZ  AnyName  =  "*               ";

static PUCHAR TextBuffer;               // dynamically allocated non-paged buffer.
ULONG   c9_Xmt = 0xff;
ULONG   c9_Rcv = 0xff;
ULONG   c9_Iteration = 0xffffffff;

static ULONG TextBufferLength;          // size of the above in bytes.
#define BUFFER_SIZE 0xffff
PUCHAR RBuff;
PUCHAR XBuff;
UCHAR c9_ListBlock[512];
UCHAR c9_ConnBlock[512];

extern KEVENT TdiSendEvent;
extern KEVENT TdiReceiveEvent;
extern KEVENT TdiServerEvent;

ULONG ApcContext;

NTSTATUS
TSTRCVCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    DbgPrint ("TSTRCVCompletion event: %lx\n" , Context);
//    KeSetEvent ((PKEVENT)Context, 0, TRUE);
    return STATUS_MORE_PROCESSING_REQUIRED;
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

#define InitWaitObject(_event)\
    KeInitializeEvent (\
        _event,\
        SynchronizationEvent,\
        FALSE)

VOID
NbfTestTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
TtdiOpenAddress (
    IN PHANDLE FileHandle,
    IN PSZ Name
    );

NTSTATUS
TtdiOpenConnection (
    IN PHANDLE FileHandle,
    IN ULONG ConnectionContext
    );


NTSTATUS
TtdiOpenAddress (
    IN PHANDLE FileHandle,
    IN PSZ Name)
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTDI_ADDRESS_NETBIOS AddressName;
    PTRANSPORT_ADDRESS Address;
    PTA_ADDRESS AddressType;
    int i;

    DbgPrint ("TtdiOpenAddress: Opening ");
    DbgPrint (Name);
    DbgPrint (".\n");
    RtlInitUnicodeString (&NameString, TRANSPORT_NAME);
    InitializeObjectAttributes (
        &ObjectAttributes,
        &NameString,
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePool (NonPagedPool, 100);
    if (EaBuffer == NULL) {
        DbgBreakPoint ();
    }

    EaBuffer->NextEntryOffset =0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = sizeof (TDI_ADDRESS_NETBIOS);

    for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
        EaBuffer->EaName[i] = TdiTransportAddress[i];
    }

    Address = (PTRANSPORT_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
    Address->TAAddressCount = 1;

    AddressType = (PTA_ADDRESS)((PUCHAR)Address + sizeof (Address->TAAddressCount));

    AddressType->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    AddressType->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;

    AddressName = (PTDI_ADDRESS_NETBIOS)((PUCHAR)AddressType +
       sizeof (AddressType->AddressType) + sizeof (AddressType->AddressLength));
    AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    for (i=0;i<16;i++) {
        AddressName->NetbiosName[i] = Name[i];
    }

    Status = IoCreateFile (
                 FileHandle,
                 0, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 FO_SYNCHRONOUS_IO,     // file attributes.
                 0,
                 0,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 (PUCHAR)&AddressName->NetbiosName[i] - (PUCHAR)EaBuffer + 1,                   // ea length
                 CreateFileTypeNone,
                 (PVOID)NULL,
                 0 );                    // EA length.

    if (!NT_SUCCESS( Status )) {
        DbgPrint ("TtdiOpenAddress:  FAILURE, NtCreateFile returned status code=%lC.\n", Status);
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("TtdiOpenAddress:  FAILURE, IoStatusBlock.Status contains status code=%lC.\n", Status);
    }

    DbgPrint ("TtdiOpenAddress:  returning\n");

    return Status;
} /* TtdiOpenAddress */


NTSTATUS
TtdiOpenConnection (IN PHANDLE FileHandle, IN ULONG ConnectionContext)
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    int i;

    DbgPrint ("TtdiOpenConnection: Opening Context %lx...\n ",
        ConnectionContext);
    RtlInitUnicodeString (&NameString, TRANSPORT_NAME);
    InitializeObjectAttributes (
        &ObjectAttributes,
        &NameString,
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePool (NonPagedPool, 100);
    if (EaBuffer == NULL) {
        DbgBreakPoint ();
    }

    EaBuffer->NextEntryOffset =0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (ULONG);
    for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
        EaBuffer->EaName[i] = TdiConnectionContext[i];
    }

    RtlMoveMemory (
        &EaBuffer->EaName[EaBuffer->EaValueLength + 1],
        &ConnectionContext,
        sizeof (PVOID));

    Status = NtCreateFile (
                 FileHandle,
                 0,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 FO_SYNCHRONOUS_IO,     // file attributes.
                 0,
                 0,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 100);                    // EA length.

    if (!NT_SUCCESS( Status )) {
        DbgPrint ("TtdiOpenConnection:  FAILURE, NtCreateFile returned status code=%lC.\n", Status);
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("TtdiOpenConnection:  FAILURE, IoStatusBlock.Status contains status code=%lC.\n", Status);
    }

    DbgPrint ("TtdiOpenConnection:  returning\n");

    return Status;
} /* TtdiOpenEndpoint */

NTSTATUS
CloseAddress (IN HANDLE FileHandle)
{
    NTSTATUS Status;

    Status = NtClose (FileHandle);

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("CloseAddress:  FAILURE, NtClose returned status code=%lC.\n", Status);
    } else {
        DbgPrint ("CloseAddress:  NT_SUCCESS.\n");
    }

    return Status;
} /* CloseAddress */


BOOLEAN
TtdiSend()
{
    USHORT i, Iteration, Increment;
    HANDLE RdrHandle, RdrConnectionHandle;
    KEVENT Event1;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL SendMdl, ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PUCHAR SendBuffer;
    ULONG SendBufferLength;
    PIRP Irp;

    Status = KeWaitForSingleObject (&TdiSendEvent, Suspended, KernelMode, FALSE, NULL);

    SendBufferLength = (ULONG)BUFFER_SIZE;
    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Send Test ******\n" );

    XBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (XBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for send buffer exiting\n");
        return FALSE;
    }
    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ClientName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&RdrHandle, AnyName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of client: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    //
    // Open the connection on the transport.
    //

    Status = TtdiOpenConnection (&RdrConnectionHandle, 1);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrConnectionHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &ConnectionObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);


    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    TdiBuildAssociateAddress (Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        RdrHandle);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Associate Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Send Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success AssociateAddress\n");
        }
    }

    //
    // Post a TdiConnect to the client endpoint.
    //

    RequestInformation.RemoteAddress = ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_CONNECT,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildConnect (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        0,
        &RequestInformation,
        &ReturnInformation);

    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Connect: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Iosb status Connect: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success Connect Iosb\n");
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Send Test:  Connect FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success Connect Immediate\n");
        }
    }

    DbgPrint( "\n****** Send Test:  SUCCESSFUL TdiConnect:  ******\n");

    //
    // Send/receive 1 or  10 messages.
    //

    SendBuffer =  (PUCHAR)ExAllocatePool (NonPagedPool, SendBufferLength);
    if (SendBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    SendMdl = IoAllocateMdl (SendBuffer, SendBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (SendMdl);

    MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
    if (MessageBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (ReceiveMdl);

    //
    // Cycle the buffer length from 0 up through the maximum for Tdi. after a
    // couple of shots at the full range in one byte steps, increment by ever
    // increasing amounts to get to the max.
    //

    CurrentBufferLength = 0;
    Increment = 1;
    for (Iteration=1; Iteration<(USHORT)c9_Iteration; Iteration++) {
        CurrentBufferLength += Increment;
        if (CurrentBufferLength > MessageBufferLength) {
            CurrentBufferLength = 0;
            Increment = 1;
        }
        if (CurrentBufferLength > 7500) {
            Increment++;
        }
        if ((USHORT)((Iteration / 100) * 100) == Iteration) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
        }
        for (i=0; i<(USHORT)CurrentBufferLength; i++) {
            SendBuffer [i] = (UCHAR)(i + Iteration % 256 );
            MessageBuffer [i] = 0;            // zap this with something.
        }

        //
        // Now issue a send on the client side.
        //

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_SEND,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildSend (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            ReceiveMdl,
            0,
            CurrentBufferLength);

        InitWaitObject (&Event1);

        Status = IoCallDriver (DeviceObject, Irp);

//        IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Send: %lC %d ******\n",
                    Status, Iteration );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Send Test:  FAILED Iosb status Send: %lC %d ******\n",
                    Status, Iteration );
                return FALSE;
            } else {
                DbgPrint ("********** Send Test:  Success SendIosb\n");
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Send Test:  Send FAILED  Status: %lC %d ******\n",
                Status, Iteration );
                return FALSE;
            } else {
                DbgPrint ("********** Send Test:  Success Send Immediate\n");
            }
        }

        if (Iosb1.Information != CurrentBufferLength) {
            DbgPrint ("SendTest: Bytes sent <> Send buffer size.\n");
            DbgPrint ("SendTest: BytesToSend=%ld.  BytesSent=%ld.\n",
                      CurrentBufferLength, Iosb1.Information);
        }

    }

    //
    // We're done with this endpoint.  Close it and get out.
    //

    Status = CloseAddress (RdrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on 2nd Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Send Test ******\n" );
    return TRUE;
} /* Send */


BOOLEAN
TtdiReceive()
{
    USHORT i, Iteration, Increment;
    SHORT j,k;
    HANDLE SvrHandle, SvrConnectionHandle;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL SendMdl, ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PUCHAR SendBuffer;
    ULONG SendBufferLength;
    PIRP Irp;
    KEVENT Event1;

    Status = KeWaitForSingleObject (&TdiReceiveEvent, Suspended, KernelMode, FALSE, NULL);

    SendBufferLength = (ULONG)BUFFER_SIZE;
    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Receive Test ******\n" );

    XBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (XBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for send buffer exiting\n");
        return FALSE;
    }
    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ClientName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&SvrHandle, ServerName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Address: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                SvrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Address: %lC ******\n", Status );
        return FALSE;
    }

    Status = TtdiOpenConnection (&SvrConnectionHandle, 2);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                SvrConnectionHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &ConnectionObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );


    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    DbgPrint ("Build Irp %lx, Handle %lx \n",
            Irp, SvrHandle);

    TdiBuildAssociateAddress (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        SvrHandle);
    InitWaitObject (&Event1);

    {
        PULONG Temp=(PULONG)IoGetNextIrpStackLocation (Irp);
        DbgPrint ("Built IrpSp %lx %lx %lx %lx %lx \n", *(Temp++),  *(Temp++),
            *(Temp++), *(Temp++), *(Temp++));
    }

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Associate Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success AssociateAddress\n");
        }
    }

    RequestInformation.RemoteAddress = ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);

    //
    // Post a TdiListen to the server endpoint.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_LISTEN,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildListen (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        0,
        &RequestInformation,
        &ReturnInformation);
    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Listen: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Listen Iosb status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success Listen IOSB\n");
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success Listen Immediate\n");
        }
    }


    DbgPrint ("\n****** Receive Test: LISTEN just completed! ******\n");

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ACCEPT,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildAccept (Irp, DeviceObject, ConnectionObject, NULL, NULL, &RequestInformation, NULL, 0);
    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Accept: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Accept Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test: Accept FAILED  Status: %lC ******\n", Status );
            return FALSE;
        }
    }

    //
    // We have the connection data now.  Sanity check it.
    //

    DbgPrint ("\n****** Receive Test:  LISTEN completed successfully! ******\n");

    //
    // Receive/receive 1 or  10 messages.
    //

    SendBuffer =  (PUCHAR)ExAllocatePool (NonPagedPool, SendBufferLength);
    if (SendBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    SendMdl = IoAllocateMdl (SendBuffer, SendBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (SendMdl);

    MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
    if (MessageBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (ReceiveMdl);

    //
    // Cycle the buffer length from 0 up through the maximum for Tdi. after a
    // couple of shots at the full range in one byte steps, increment by ever
    // increasing amounts to get to the max.
    //

    CurrentBufferLength = 0;
    Increment = 1;
    for (Iteration=1; Iteration<(USHORT)c9_Iteration; Iteration++) {
        CurrentBufferLength += Increment;
        if (CurrentBufferLength > MessageBufferLength) {
            CurrentBufferLength = 0;
            Increment = 1;
        }
        if (CurrentBufferLength > 7500) {
            Increment++;
        }
        if ((USHORT)((Iteration / 100) * 100) == Iteration) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
        }
        for (i=0; i<(USHORT)CurrentBufferLength; i++) {
            SendBuffer [i] = (UCHAR)(i + Iteration % 256 );
            MessageBuffer [i] = 0;            // zap this with something.
        }

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_RECEIVE,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildReceive (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            ReceiveMdl,
            MessageBufferLength);

        InitWaitObject (&Event1);

        Status = IoCallDriver (DeviceObject, Irp);

//        IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Receive: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Receive Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // The receive completed.  Make sure the data is correct.
        //

        if (Iosb1.Information != CurrentBufferLength) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
            DbgPrint ("ReceiveTest: Bytes received <> bytes sent.\n");
            DbgPrint ("ReceiveTest: BytesToSend=%ld.  BytesReceived=%ld.\n",
                      CurrentBufferLength, Iosb1.Information);
        }

        if (i == (USHORT)CurrentBufferLength) {
//                DbgPrint ("ReceiveTest: Message contains correct data.\n");
        } else {
            DbgPrint ("ReceiveTest: Message data corrupted at offset %lx of %lx.\n", (ULONG)i, (ULONG)SendBufferLength);
            DbgPrint ("ReceiveTest: Data around corrupted location:\n");
            for (j=-4;j<=3;j++) {
                DbgPrint ("%08lx  ", (ULONG) i+j*16);
                for (k=(SHORT)i+(j*(SHORT)16);k<(SHORT)i+((j+(SHORT)1)*(SHORT)16);k++) {
                    DbgPrint ("%02x",MessageBuffer [k]);
                }
                for (k=(SHORT)i+(j*(SHORT)16);k<(SHORT)i+((j+(SHORT)1)*(SHORT)16);k++) {
                    DbgPrint ("%c",MessageBuffer [k]);
                }
                DbgPrint ("\n");
            }
            DbgPrint ("ReceiveTest: End of Corrupt Data.\n");
        }
    }

    //
    // We're done with this endpoint.  Close it and get out.
    //

    Status = CloseAddress (SvrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on 1st Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Receive Test ******\n" );
    return TRUE;
} /* Receive */

BOOLEAN
TtdiServer()
{
    USHORT i;
    HANDLE RdrHandle, SrvConnectionHandle;
    KEVENT Event1;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PIRP Irp;

    Status = KeWaitForSingleObject (&TdiServerEvent, Suspended, KernelMode, FALSE, NULL);

    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Server Test ******\n" );

    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = AnyName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&RdrHandle, ServerName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Server Test:  FAILED on open of client: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    //
    // Now loop forever trying to get a connection from a remote client to
    // this server. We will create connections until we run out of resources,
    // and we will echo the data we are sent back along the same connection.
    // Sends and Receives are always asynchronous, while listens are
    // synchronous.
    //

    while (TRUE) {

        //
        // Open the connection on the transport.
        //

        Status = TtdiOpenConnection (&SrvConnectionHandle, 1);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Server Test:  FAILED on open of server Connection: %lC ******\n", Status );
            return FALSE;
        }

        Status = ObReferenceObjectByHandle (
                    SrvConnectionHandle,
                    0L,
                    NULL,
                    KernelMode,
                    (PVOID *) &ConnectionObject,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Server Test:  FAILED on open of server Connection: %lC ******\n", Status );
            return FALSE;
        }

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );

        //
        // Now register the device handler for receives
        //

//        Irp = TdiBuildInternalDeviceControlIrp (
//                    TDI_SET_EVENT_HANDLER,
//                    DeviceObject,
//                    ConnectionObject,
//                    &Event1,
//                    &Iosb1);

//        TdiBuildSetEventHandler (Irp,
//            DeviceObject,
//            ConnectionObject,
//            TSTRCVCompletion,
//            &Event1,
//            TDI_RECEIVE_HANDLER,
//            TdiTestReceiveHandler,
//            ConnectionObject);

//        Status = IoCallDriver (DeviceObject, Irp);

//       if (Status == STATUS_PENDING) {
//            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
//            if (!NT_SUCCESS(Status)) {
//                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Register: %lC ******\n", Status );
//                return FALSE;
//            }
//            if (!NT_SUCCESS(Iosb1.Status)) {
//                DbgPrint( "\n****** Server Test:  FAILED Register Iosb status: %lC ******\n", Status );
//                return FALSE;
//            }
//
//        } else {
//            if (!NT_SUCCESS (Status)) {
//                DbgPrint( "\n****** Server Test:  RegisterHandler FAILED  Status: %lC ******\n", Status );
//                return FALSE;
//            }
//        }

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_ASSOCIATE_ADDRESS,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildAssociateAddress (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            RdrHandle);

        Status = IoCallDriver (DeviceObject, Irp);

    //    IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Associate Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Server Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // Post a TdiListen to the server endpoint.
        //

        RequestInformation.RemoteAddress = ListenBlock;
        RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_LISTEN,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildListen (
            Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            0,
            &RequestInformation,
            NULL);

        Status = IoCallDriver (DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Listen: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Listen Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Server Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        DbgPrint ("\n****** Server Test: LISTEN just completed! ******\n");

        //
        // accept the connection from the remote
        //

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_ACCEPT,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildAccept (
            Irp,
            DeviceObject,
            ConnectionObject,
            NULL,
            NULL,
            &RequestInformation,
            NULL,
            0);

        Status = IoCallDriver (DeviceObject, Irp);

    //    IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Accept: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Accept Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Accept Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // Get a buffer for the continued read/write loop.
        //

        MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
        if (MessageBuffer == NULL) {
            DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
        }
        ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool (ReceiveMdl);

        //
        // have a receive buffer, and a connection; go ahead and read and write
        // until the remote disconnects.
        //

        while (TRUE) {

            KeInitializeEvent (
                        &Event1,
                        SynchronizationEvent,
                        FALSE);

            Irp = TdiBuildInternalDeviceControlIrp (
                        TDI_RECEIVE,
                        DeviceObject,
                        ConnectionObject,
                        &Event1,
                        &Iosb1);

            TdiBuildReceive (Irp,
                DeviceObject,
                ConnectionObject,
                TSTRCVCompletion,
                &Event1,
                ReceiveMdl,
                MessageBufferLength);

            InitWaitObject (&Event1);

            Status = IoCallDriver (DeviceObject, Irp);

            if (Status == STATUS_PENDING) {
                Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Receive: %lC ******\n", Status );
                    return FALSE;
                }
                if (!NT_SUCCESS(Iosb1.Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Receive Iosb status: %lC ******\n", Status );
                    return FALSE;
                }

            } else {
                if (!NT_SUCCESS (Status)) {

                    //
                    // Check to see if the remote has disconnected, which is
                    // the only reason for us shutting down/
                    //

                    if (Status == STATUS_REMOTE_DISCONNECT) {

                        //
                        // We've been disconnected from; get out
                        //

                        NtClose (SrvConnectionHandle);
                        break;
                    }

                    DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
                    return FALSE;
                } else {

                    //
                    // successful return, what length is the data?
                    //

                    CurrentBufferLength = Iosb1.Information;
                }
            }

            //
            // send the data back
            //

            KeInitializeEvent (
                        &Event1,
                        SynchronizationEvent,
                        FALSE);

            Irp = TdiBuildInternalDeviceControlIrp (
                        TDI_SEND,
                        DeviceObject,
                        ConnectionObject,
                        &Event1,
                        &Iosb1);

            TdiBuildSend (Irp,
                DeviceObject,
                ConnectionObject,
                TSTRCVCompletion,
                &Event1,
                ReceiveMdl,
                0,
                CurrentBufferLength);

            Status = IoCallDriver (DeviceObject, Irp);

            if (Status == STATUS_PENDING) {
                Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Send: %lC ******\n", Status );
                    return FALSE;
                }
                if (!NT_SUCCESS(Iosb1.Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Send Iosb status: %lC ******\n", Status );
                    return FALSE;
                }

            } else {
                if (!NT_SUCCESS (Status)) {

                    DbgPrint( "\n****** Receive Test: Send FAILED  Status: %lC ******\n", Status );
                    NtClose (SrvConnectionHandle);
                    break;

                }
            }
        } // end of receive/send while

        IoFreeMdl (ReceiveMdl);
        ExFreePool (MessageBuffer);

    }

    //
    // We're done with this address.  Close it and get out.
    //

    Status = CloseAddress (RdrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on 2nd Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Send Test ******\n" );
    return TRUE;
} /* Server */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\testtdi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tstrcv.c

Abstract:

    start receive side tests utility

Author:

    Dave Beaver (dbeaver) 24-Mar-1991

Revision History:

--*/

//
// download a ub board
//

typedef unsigned char	uchar_t;

#include <assert.h>
#include	<stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
//#include <windows.h>
#include <nbf.h>

#define TDIDEV	"\\Device\\Nbf"
char		Tdidevice[]	= TDIDEV;	/* default device */
char		*Tdidev	= Tdidevice;

HANDLE FileHandle;

VOID
usage(
    VOID
    );


NTSTATUS
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    STRING NameString;
    UNICODE_STRING unicodeString;
    PUCHAR buffer;
    ULONG IoControlCode;
    int n;
    CHAR c;

    for( n = 1; n < argc && argv[n][0] == '-' ; ++n ) {
        c = argv[n][1];

        switch( c )	{

        case 's':   // send test
            IoControlCode = IOCTL_TDI_SEND_TEST;
            break;

        case 'r':   // receive test
            IoControlCode = IOCTL_TDI_RECEIVE_TEST;

            break;

        case 'b':	/* both test */
            IoControlCode = IOCTL_TDI_SERVER_TEST;

        	   break;

        default:
        	   usage ();
        	   break;

        }
    }

    printf ("Opening TDI device: %s \n", Tdidev);
    RtlInitString (&NameString, Tdidev);
    Status = RtlAnsiStringToUnicodeString(
                 &unicodeString,
                 &NameString,
                 TRUE);

    buffer = (PUCHAR)malloc (100);

    Status = TdiOpenNetbiosAddress (&FileHandle, buffer, (PVOID)&NameString, NULL);

    RtlFreeUnicodeString(&unicodeString);
    free (buffer);

    if (!NT_SUCCESS( Status )) {
        printf ("FAILURE, Unable to open TDI driver %s, status: %lx.\n",
            Tdidev,Status);
        return (Status);
    }

    if (!(NT_SUCCESS( IoStatusBlock.Status ))) {
        printf ("FAILURE, Unable to open TDI driver %s, IoStatusBlock.Status: %lx.\n",
                Tdidev, IoStatusBlock.Status);
        return (IoStatusBlock.Status);
    }

    //
    // start the test
    //

    printf("Starting test.... ");
    Status = NtDeviceIoControlFile(
                  FileHandle,
                  NULL,
                  NULL,
                  NULL,
                  &IoStatusBlock,
                  IoControlCode,
                  NULL,
                  0,
                  NULL,
                  0);

    if (!NT_SUCCESS( Status )) {
         printf ("FAILURE, Unable to start test: %lx.\n", Status);
         return (Status);
    }

    if (!(NT_SUCCESS( IoStatusBlock.Status ))) {
         printf ("FAILURE, Unable to start test: %lx.\n", IoStatusBlock.Status);
         return (IoStatusBlock.Status);
    }

    NtClose (FileHandle);

    return STATUS_SUCCESS;

}


NTSTATUS
TdiOpenNetbiosAddress (
    IN OUT PHANDLE FileHandle,
    IN PUCHAR Buffer,
    IN PVOID DeviceName,
    IN PVOID Address)

/*++

Routine Description:

   Opens an address on the given file handle and device.

Arguments:

    FileHandle - the returned handle to the file object that is opened.

    Buffer - pointer to a buffer that the ea is to be built in. This buffer
        must be at least 40 bytes long.

    DeviceName - the Unicode string that points to the device object.

    Name - the address to be registered. If this pointer is NULL, the routine
        will attempt to open a "control channel" to the device; that is, it
        will attempt to open the file object with a null ea pointer, and if the
        transport provider allows for that, will return that handle.

Return Value:

    An informative error code if something goes wrong. STATUS_SUCCESS if the
    returned file handle is valid.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTRANSPORT_ADDRESS TAAddress;
    PTA_ADDRESS AddressType;
    PTDI_ADDRESS_NETBIOS AddressName;
    PSZ Name;
    ULONG Length;
    int i;

    if (Address != NULL) {
        Name = (PSZ)Address;
        try {
            Length = sizeof (FILE_FULL_EA_INFORMATION) +
                            sizeof (TRANSPORT_ADDRESS) +
                            sizeof (TDI_ADDRESS_NETBIOS);
            EaBuffer = (PFILE_FULL_EA_INFORMATION)Buffer;

            if (EaBuffer == NULL) {
                return STATUS_UNSUCCESSFUL;
            }

            EaBuffer->NextEntryOffset =0;
            EaBuffer->Flags = 0;
            EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
            EaBuffer->EaValueLength = sizeof (TDI_ADDRESS_NETBIOS) +
                                            sizeof (TRANSPORT_ADDRESS);

            for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
                EaBuffer->EaName[i] = TdiTransportAddress[i];
            }

            TAAddress = (PTRANSPORT_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
            TAAddress->TAAddressCount = 1;

            AddressType = (PTA_ADDRESS)((PUCHAR)TAAddress + sizeof (TAAddress->TAAddressCount));

            AddressType->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            AddressType->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;

            AddressName = (PTDI_ADDRESS_NETBIOS)((PUCHAR)AddressType +
               sizeof (AddressType->AddressType) + sizeof (AddressType->AddressLength));
            AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

            for (i=0;i<16;i++) {
                AddressName->NetbiosName[i] = Name[i];
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Couldn't touch the passed parameters; just return an error
            // status.
            //

            return GetExceptionCode();
        }
    } else {
        EaBuffer = NULL;
        Length = 0;
    }

    InitializeObjectAttributes (
        &ObjectAttributes,
        DeviceName,
        0,
        NULL,
        NULL);

    Status = NtCreateFile (
                 FileHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 0,                     // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access.
                 FILE_CREATE,           // create disposition.
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 Length);                    // EA length.

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
    }

    return Status;
} /* TdiOpenNetbiosAddress */

VOID
usage(
    VOID
    )
{
	printf( "usage:  tsttdi [-r] [-s] -[b]\n");
	printf( "usage:  -r run receive test.\n" );
	printf( "usage:  -b run server test.\n" );
	printf( "usage:  -s run send test.\n" );
	printf( "\n" );
	exit( 1 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\timer.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code that implements the lightweight timer system
    for the NBF protocol provider.  This is not a general-purpose timer system;
    rather, it is specific to servicing LLC (802.2) links with three timers
    each.

    Services are provided in macro form (see NBFPROCS.H) to start and stop
    timers.  This module contains the code that gets control when the timer
    in the device context expires as a result of calling kernel services.
    The routine scans the device context's link database, looking for timers
    that have expired, and for those that have expired, their expiration
    routines are executed.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

ULONG StartTimer = 0;
ULONG StartTimerSet = 0;
ULONG StartTimerT1 = 0;
ULONG StartTimerT2 = 0;
ULONG StartTimerDelayedAck = 0;
ULONG StartTimerLinkDeferredAdd = 0;
ULONG StartTimerLinkDeferredDelete = 0;


#if DBG
extern ULONG NbfDebugPiggybackAcks;
ULONG NbfDebugShortTimer = 0;
#endif

#if DBG
//
// These are temp, to track how the timers are working
//
ULONG TimerInsertsAtEnd = 0;
ULONG TimerInsertsEmpty = 0;
ULONG TimerInsertsInMiddle = 0;
#endif

//
// These are constants calculated by InitializeTimerSystem
// to be the indicated amound divided by the tick increment.
//

ULONG NbfTickIncrement = 0;
ULONG NbfTwentyMillisecondsTicks = 0;
ULONG NbfShortTimerDeltaTicks = 0;
ULONG NbfMaximumIntervalTicks = 0;     // usually 60 seconds in ticks

LARGE_INTEGER DueTimeDelta = { (ULONG)(-SHORT_TIMER_DELTA), -1 };

VOID
ExpireT2Timer(
    PTP_LINK Link
    );

VOID
StopStalledConnections(
    IN PDEVICE_CONTEXT DeviceContext
    );


ULONG
GetTimerInterval(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    GetTimerInterval returns the difference in time between the
    current time and Link->CurrentTimerStart (in ticks).
    We limit the interval to 60 seconds. A value of 0 may
    be returned which should be interpreted as 1/2.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    The interval.

--*/

{

    LARGE_INTEGER CurrentTick;
    LARGE_INTEGER Interval;


    //
    // Determine the current tick; the start tick has been saved
    // in Link->CurrentTimerStart.
    //

    KeQueryTickCount (&CurrentTick);

    //
    // Determine the difference between now and then.
    //

    Interval.QuadPart = CurrentTick.QuadPart -
	                        (Link->CurrentTimerStart).QuadPart;

    //
    // If the gap is too big, return 1 minute.
    //

    if (Interval.HighPart != 0 || (Interval.LowPart > NbfMaximumIntervalTicks)) {
        return NbfMaximumIntervalTicks;
    }

    return Interval.LowPart;

}   /* GetTimerInterval */


VOID
BackoffCurrentT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called if T1 expires and we are about to
    retransmit a poll frame. It backs off CurrentT1Timeout,
    up to a limit of 10 seconds.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //
    // do we need spinlock guarding for MP ?
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    ++Link->CurrentPollRetransmits;

    //
    // T1 backs off 1.5 times each time.
    //

    Link->CurrentT1Timeout += (Link->CurrentT1Timeout >> 1);

    //
    // Limit T1 to 10 seconds.
    //

    if (Link->CurrentT1Timeout > ((10 * SECONDS) / SHORT_TIMER_DELTA)) {
        Link->CurrentT1Timeout = (10 * SECONDS) / SHORT_TIMER_DELTA;
    }

}   /* BackoffCurrentT1Timeout */


VOID
UpdateBaseT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a response to a poll frame is
    received. StartT1 will have been called when the frame is
    sent. The routine updates the link's T1 timeout as well
    as delay and throughput.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{
    ULONG Delay;
    ULONG ShiftedTicksDelay;

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    Delay = GetTimerInterval (Link);

    if (Link->CurrentPollRetransmits == 0) {

        //
        // Convert the delay into NBF ticks, shifted by
        // DLC_TIMER_ACCURACY and also multiplied by 4.
        // We want to divide by SHORT_TIMER_DELTA, then
        // shift left by DLC_TIMER_ACCURACY+2. We divide
        // by NbfShortTimerDeltaTicks because the Delay
        // is returned in ticks.
        //
        // We treat a delay of 0 as 1/2, so we use 1
        // shifted left by (DLC_TIMER_ACCURACY+1).
        //

        if (Delay == 0) {

            ShiftedTicksDelay = (1 << (DLC_TIMER_ACCURACY + 1)) /
                                  NbfShortTimerDeltaTicks;

        } else {

            ShiftedTicksDelay = (Delay << (DLC_TIMER_ACCURACY + 2)) /
                                  NbfShortTimerDeltaTicks;

        }


        //
        // Use the timing information to update BaseT1Timeout,
        // if the last frame sent was large enough to matter
        // (we use half of the max frame size here). This is
        // so we don't shrink the timeout too much after sending
        // a short frame. However, we update even for small frames
        // if the last time we sent a poll we had to retransmit
        // it, since that means T1 is much too small and we should
        // increase it as much as we can. We also update for any
        // size frame if the new delay is bigger than the current
        // value, so we can ramp up quickly if needed.
        //

        if (ShiftedTicksDelay > Link->BaseT1Timeout) {

            //
            // If our new delay is more, than we weight it evenly
            // with the previous value.
            //

            Link->BaseT1Timeout = (Link->BaseT1Timeout +
                                   ShiftedTicksDelay) / 2;

        } else if (Link->CurrentT1Backoff) {

                //
                // If we got a retransmit last time, then weight
                // the new timer more heavily than usual.
                //

                Link->BaseT1Timeout = ((Link->BaseT1Timeout * 3) +
                                      ShiftedTicksDelay) / 4;

        } else if (Link->CurrentPollSize >= Link->BaseT1RecalcThreshhold) {

                //
                // Normally, the new timeout is 7/8 the previous value and
                // 1/8 the newly observed delay.
                //

                Link->BaseT1Timeout = ((Link->BaseT1Timeout * 7) +
                                      ShiftedTicksDelay) / 8;

        }

        //
        // Restrict the real timeout to a minimum based on
        // the link speed (always >= 400 ms).
        //

        if (Link->BaseT1Timeout < Link->MinimumBaseT1Timeout) {

            Link->BaseT1Timeout = Link->MinimumBaseT1Timeout;

        }


        //
        // Update link delay and throughput also. Remember
        // that a delay of 0 should be interpreted as 1/2.
        //

        UpdateDelayAndThroughput(
            Link,
            (Delay == 0) ?
                (NbfTickIncrement / 2) :
                (Delay * NbfTickIncrement));


        //
        // We had no retransmits last time, so go back to current base.
        //

        Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

        Link->CurrentT1Backoff = FALSE;

    } else {

        Link->CurrentT1Backoff = TRUE;

        if (!(Link->ThroughputAccurate)) {

            //
            // If we are just starting up, we have to update the
            // throughput even on a retransmit, so we get *some*
            // value there.
            //

            UpdateDelayAndThroughput(
                Link,
                (Delay == 0) ?
                    (NbfTickIncrement / 2) :
                    (Delay * NbfTickIncrement));

        }

    }

}   /* UpdateBaseT1Timeout */


VOID
CancelT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when we have not received any
    responses to a poll frame and are giving up rather
    than retransmitting.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //
    // do we need spinlock guarding for MP ?
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    //
    // We are stopping a polling condition, so reset T1.
    //

    Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

    Link->CurrentT1Backoff = FALSE;

    //
    // Again, this isn't safe on MP (or UP, maybe).
    //

    Link->CurrentPollOutstanding = FALSE;

}   /* CancelT1Timeout */


VOID
UpdateDelayAndThroughput(
    IN PTP_LINK Link,
    IN ULONG TimerInterval
    )

/*++

Routine Description:

    This routine is called when a response packet used to time
    link delay has been received. It is assumed that StartT1
    or FakeStartT1 was called when the initial packet was sent.

    NOTE: For now, we also calculate throughput based on this.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

    TimerInterval - The link delay measured.

Return Value:

    None.

--*/

{

    ULONG PacketSize;


    if (Link->Delay == 0xffffffff) {

        //
        // If delay is unknown, use this.
        //

        Link->Delay = TimerInterval;

    } else if (Link->CurrentPollSize <= 64) {

        //
        // Otherwise, for small frames calculate the new
        // delay by averaging with the old one.
        //

        Link->Delay = (Link->Delay + TimerInterval) / 2;

    }


    //
    // Calculate the packet size times the number of time units
    // in 10 milliseconds, which will allow us to calculate
    // throughput in bytes/10ms (we later multiply by 100
    // to obtain the real throughput in bytes/s).
    //
    // Given the size of MILLISECONDS, this allows packets of up
    // to ~20K, so for bigger packets we just assume that (since
    // throughput won't be an issue there).
    //

    if (Link->CurrentPollSize > 20000) {
        PacketSize = 20000 * (10 * MILLISECONDS);
    } else {
        PacketSize = Link->CurrentPollSize * (10*MILLISECONDS);
    }

    //
    // If throughput is not accurate, then we will use this
    // packet only to calculate it. To avoid being confused
    // by very small packets, assume a minimum size of 64.
    //

    if ((!Link->ThroughputAccurate) && (PacketSize < (64*(10*MILLISECONDS)))) {
        PacketSize = 64 * (10*MILLISECONDS);
    }

    //
    // PacketSize is going to be divided by TimerInterval;
    // to prevent a zero throughput, we boost it up if needed.
    //

    if (PacketSize < TimerInterval) {
        PacketSize = TimerInterval;
    }


    if (Link->CurrentPollSize >= 512) {

        //
        // Calculate throughput here by removing the established delay
        // from the time.
        //

        if ((Link->Delay + (2*MILLISECONDS)) < TimerInterval) {

            //
            // If the current delay is less than the new timer
            // interval (plus 2 ms), then subtract it off for a
            // more accurate throughput calculation.
            //

            TimerInterval -= Link->Delay;

        }

        //
        // We assume by this point (sending a > 512-byte frame) we
        // already have something established as Link->Throughput.
        //

        if (!(Link->ThroughputAccurate)) {

            Link->Throughput.QuadPart =
                                UInt32x32To64((PacketSize / TimerInterval), 100);

            Link->ThroughputAccurate = TRUE;

#if 0
            NbfPrint2 ("INT: %ld.%1.1d us\n",
                TimerInterval / 10, TimerInterval % 10);
            NbfPrint4 ("D: %ld.%1.1d us  T: %ld  (%d)/s\n",
                Link->Delay / 10, Link->Delay % 10,
                Link->Throughput.LowPart, Link->CurrentPollSize);
#endif

        } else {

            LARGE_INTEGER TwiceThroughput;

            //
            // New throughput is the average of the old throughput, and
            // the current packet size divided by the delay just observed.
            // First we calculate the sum, then we shift right by one.
            //

            TwiceThroughput.QuadPart = Link->Throughput.QuadPart +
                                UInt32x32To64((PacketSize / TimerInterval), 100);

            Link->Throughput.QuadPart = TwiceThroughput.QuadPart >> 1;
        }

    } else if (!(Link->ThroughputAccurate)) {

        //
        // We don't have accurate throughput, so just get an estimate
        // by ignoring the delay on this small frame.
        //

        Link->Throughput.QuadPart =
                            UInt32x32To64((PacketSize / TimerInterval), 100);

    }

}   /* UpdateDelayAndThroughput */


VOID
FakeStartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    )

/*++

Routine Description:

    This routine is called before sending a packet that will be used
    to time link delay, but where StartT1 will not be started.
    It is assumed that FakeUpdateBaseT1Timeout will be called
    when the response is received. This is used for timing
    frames that have a known immediate response, but are not
    poll frames.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

    PacketSize - The size of the packet that was just sent.

Return Value:

    None.

--*/

{

    Link->CurrentPollSize = PacketSize;
    KeQueryTickCount(&Link->CurrentTimerStart);

}   /* FakeStartT1 */


VOID
FakeUpdateBaseT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a response to a frame is
    received, and we called FakeStartT1 when the initial
    frame was sent. This is used for timing frames that have
    a known immediate response, but are not poll frames.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/


{
    ULONG Delay;

    Delay = GetTimerInterval (Link);

    //
    // Convert the delay into NBF ticks, shifted by
    // DLC_TIMER_ACCURACY and also multiplied by 4.
    // We want to divide by SHORT_TIMER_DELTA, then
    // shift left by DLC_TIMER_ACCURACY+2. We divide
    // by NbfShortTimerDeltaTicks because the Delay
    // is returned in ticks. We treat a Delay of 0
    // as 1/2 and calculate ((1/2) << x) as (1 << (x-1)).
    //
    // This timeout is treated as the correct value.
    //

    if (Delay == 0) {

        Link->BaseT1Timeout = (1 << (DLC_TIMER_ACCURACY + 1)) /
                                 NbfShortTimerDeltaTicks;

    } else {

        Link->BaseT1Timeout = (Delay << (DLC_TIMER_ACCURACY + 2)) /
                                 NbfShortTimerDeltaTicks;

    }

    //
    // Restrict the real timeout to a minimum based on
    // the link speed (always >= 400 ms).
    //

    if (Link->BaseT1Timeout < Link->MinimumBaseT1Timeout) {
        Link->BaseT1Timeout = Link->MinimumBaseT1Timeout;
    }

    Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

    //
    // Update link delay and throughput also.
    //

    UpdateDelayAndThroughput(
        Link,
        (Delay == 0) ?
            (NbfTickIncrement / 2) :
            (Delay * NbfTickIncrement));

}   /* FakeUpdateBaseT1Timeout */


VOID
StartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    )

/*++

Routine Description:

    This routine starts the T1 timer for the given link. If the link was
    already on the list, it is moved to the tail. If not, it is inserted at
    tail.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

    PollPacketSize - If a poll packet was just sent it is its size;
        otherwise this will be 0 (when non-poll I-frames are sent).

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;

    if (PacketSize > 0) {

        //
        // If we are sending an initial poll frame, then do timing stuff.
        //

        Link->CurrentPollRetransmits = 0;
        Link->CurrentPollSize = PacketSize;
        Link->CurrentPollOutstanding = TRUE;
        KeQueryTickCount(&Link->CurrentTimerStart);

    } else {

        Link->CurrentPollOutstanding = FALSE;

    }


    //
    // Insert us in the queue if we aren't in it.
    //

    Link->T1 = DeviceContext->ShortAbsoluteTime+Link->CurrentT1Timeout;

    if (!Link->OnShortList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnShortList) {
            Link->OnShortList = TRUE;
            InsertTailList (&DeviceContext->ShortList, &Link->ShortList);
        }

        if (!DeviceContext->a.i.ShortListActive) {

            StartTimerT1++;
            NbfStartShortTimer (DeviceContext);
            DeviceContext->a.i.ShortListActive = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }

}


VOID
StartT2(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine adds the given link to the T2 queue and starts the timer.
    If the link is already on the queue, it is moved to the queue end.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;


    if (DeviceContext->MacInfo.MediumAsync) {

        //
        // On an async line, expire it as soon as possible.
        //

        Link->T2 = DeviceContext->ShortAbsoluteTime;

    } else {

        Link->T2 = DeviceContext->ShortAbsoluteTime+Link->T2Timeout;

    }


    if (!Link->OnShortList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnShortList) {
            Link->OnShortList = TRUE;
            InsertTailList (&DeviceContext->ShortList, &Link->ShortList);
        }

        if (!DeviceContext->a.i.ShortListActive) {

            StartTimerT2++;
            NbfStartShortTimer (DeviceContext);
            DeviceContext->a.i.ShortListActive = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }

}


VOID
StartTi(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine adds the given link to the Ti queue and starts the timer.
    As above, if the link is already on the queue it is moved to the queue end.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;


    //
    // On an easily disconnected link, with only server connections
    // on this link, we set a long Ti timeout, and when it
    // expires with no activity we start checkpointing, otherwise
    // we assume things are OK.
    //

    if (DeviceContext->EasilyDisconnected && Link->NumberOfConnectors == 0) {
        Link->Ti = DeviceContext->LongAbsoluteTime + (2 * Link->TiTimeout);
        Link->TiStartPacketsReceived = Link->PacketsReceived;
    } else {
        Link->Ti = DeviceContext->LongAbsoluteTime+Link->TiTimeout;
    }


    if (!Link->OnLongList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnLongList) {
            Link->OnLongList = TRUE;
            InsertTailList (&DeviceContext->LongList, &Link->LongList);
        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }


}

#if DBG

VOID
StopT1(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    //
    // Again, this isn't safe on MP (or UP, maybe).
    //

    Link->CurrentPollOutstanding = FALSE;
    Link->T1 = 0;

}


VOID
StopT2(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    Link->ConsecutiveIFrames = 0;
    Link->T2 = 0;

}


VOID
StopTi(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    Link->Ti = 0;
}
#endif


VOID
ExpireT1Timer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's T1 timer expires.  T1 is the
    retransmission timer, and is used to remember that a response is
    expected to any of the following:  (1) a checkpoint, (2) a transmitted
    I-frame, (3) a SABME, or (4) a DISC.  Cases 3 and 4 are actually
    special forms of a checkpoint, since they are sent by this protocol
    implementation with the poll bit set, effectively making them a
    checkpoint sequence.

Arguments:

    Link - Pointer to the TP_LINK object whose T1 timer has expired.

Return Value:

    none.

--*/

{
    PDLC_I_FRAME DlcHeader;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireT1Timer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    switch (Link->State) {

        case LINK_STATE_ADM:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: State=ADM, timeout not expected.\n");
            }
            break;

        case LINK_STATE_READY:

            //
            // We've sent an I-frame and haven't received an acknowlegement
            // yet, or we are checkpointing, and must retry the checkpoint.
            // Another possibility is that we're rejecting, and he hasn't
            // sent anything yet.
            //

            switch (Link->SendState) {

                case SEND_STATE_DOWN:

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link READY but SendState=DOWN.\n");
                    }
                    break;

                case SEND_STATE_READY:

                    //
                    // We sent an I-frame and didn't get an acknowlegement.
                    // Initiate a checkpoint sequence.
                    //

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        {PTP_PACKET packet;
                        PLIST_ENTRY p;
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=READY .\n");
                        NbfDumpLinkInfo (Link);
                        p=Link->WackQ.Flink;
                        NbfPrint0 ("ExpireT1Timer: Link WackQ entries:\n");
                        while (p != &Link->WackQ) {
                            packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
                            DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);
                            NbfPrint2 ("                 %08lx  %03d\n", p,
                                (DlcHeader->SendSeq >> 1));
                            p = p->Flink;
                        }}
                    }

                    Link->SendRetries = (UCHAR)Link->LlcRetries;
                    Link->SendState = SEND_STATE_CHECKPOINTING;
                    // Don't BackoffT1Timeout yet.
                    NbfSendRr (Link, TRUE, TRUE);// send RR-c/p, StartT1, release lock
                    break;

                case SEND_STATE_REJECTING:

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=REJECTING.\n");
                        NbfPrint0 ("so what do we do here?  consult the manual...\n");
                    }
                    Link->SendState = SEND_STATE_CHECKPOINTING;
//                    Link->SendRetries = Link->LlcRetries;
//                    break;  // DGB: doing nothing is obviously wrong, we've
//                            // gotten a T1 expiration during resend. Try
//                            // an RR to say hey.

                case SEND_STATE_CHECKPOINTING:

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=CHECKPOINTING.\n");
                        NbfDumpLinkInfo (Link);
                    }
                    if (--Link->SendRetries == 0) {

                        //
                        // We have not gotten any response to RR-p packets,
                        // initiate orderly link teardown.
                        //

                        CancelT1Timeout (Link);      // we are stopping a polling state

                        Link->State = LINK_STATE_W_DISC_RSP;        // we are awaiting a DISC/f.
                        Link->SendState = SEND_STATE_DOWN;
                        Link->ReceiveState = RECEIVE_STATE_DOWN;
                        Link->SendRetries = (UCHAR)Link->LlcRetries;

                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                        NbfStopLink (Link);

                        StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
                        NbfSendDisc (Link, TRUE);  // send DISC-c/p.

#if DBG
                        if (NbfDisconnectDebug) {
                            NbfPrint0( "ExpireT1Timer sending DISC (checkpoint failed)\n" );
                        }
#endif
                    } else {

                        BackoffCurrentT1Timeout (Link);
                        NbfSendRr (Link, TRUE, TRUE); // send RR-c/p, StartT1, release lock.

                    }
                    break;

                default:

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint1 ("ExpireT1Timer: Link State=READY, SendState=%ld (UNKNOWN).\n",
                                  Link->SendState);
                    }
            }
            break;

        case LINK_STATE_CONNECTING:

            //
            // We sent a SABME-c/p and have not yet received UA-r/f.  This
            // means we must decrement the retry count and if it is not yet
            // zero, we issue another SABME command, because he has probably
            // dropped our first one.
            //

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);    // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no response to SABME)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in CONNECTING mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.
            } else {
                BackoffCurrentT1Timeout (Link);
                NbfSendSabme (Link, TRUE);  // send SABME/p, StartT1, release lock
            }
            break;

        case LINK_STATE_W_POLL:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: State=W_POLL, timeout not expected.\n");
            }
            break;

        case LINK_STATE_W_FINAL:

            //
            // We sent our initial RR-c/p and have not received his RR-r/f.
            // We have to restart the checkpoint, unless our retries have
            // run out, in which case we just abort the link.
            //

            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: Link State=W_FINAL.\n");
                NbfDumpLinkInfo (Link);
            }

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);    // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no final received)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_FINAL mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.

            } else {

                BackoffCurrentT1Timeout (Link);
                NbfSendRr (Link, TRUE, TRUE);    // send RR-c/p, StartT1, release lock

            }
            break;

        case LINK_STATE_W_DISC_RSP:

            //
            // We sent a DISC-c/p to disconnect this link and are awaiting
            // his response, either a UA-r/f or DM-r/f.  We have to issue
            // the DISC again, unless we've tried a few times, in which case
            // we just shut the link down.
            //

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint0 ("ExpireT1Timer: Link State=W_DISC_RESP.\n");
                NbfDumpLinkInfo (Link);
            }

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);         // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no response to DISC)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_DISC_RSP mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.

            } else {

                // we don't bother calling BackoffCurrentT1Timeout for DISCs.
                ++Link->CurrentPollRetransmits;
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));  // startup timer again.

                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfSendDisc (Link, TRUE);  // send DISC/p.

            }
            break;

        default:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint1 ("ExpireT1Timer: State=%ld (UNKNOWN), timeout not expected.\n",
                          Link->State);
            }
    }


} /* ExpireT1Timer */


VOID
ExpireT2Timer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's T2 timer expires.  T2 is the
    delayed acknowlegement timer in the LLC connection-oriented procedures.
    The T2 timer is started when a valid I-frame is received but not
    immediately acknowleged.  Then, if reverse I-frame traffic is sent,
    the timer is stopped, since the reverse traffic will acknowlege the
    received I-frames.  If no reverse I-frame traffic becomes available
    to send, then this timer fires, causing a RR-r/0 to be sent so as
    to acknowlege the received but as yet unacked I-frames.

Arguments:

    Link - Pointer to the TP_LINK object whose T2 timer has expired.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireT2Timer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    NbfSendRr (Link, FALSE, FALSE);      // send RR-r/f, release lock.

} /* ExpireT2Timer */


VOID
ExpireTiTimer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's Ti timer expires.  Ti is the
    inactivity timer, and serves as a keep-alive on a link basis, to
    periodically perform some protocol exchange with the remote connection
    partner that will implicitly reveal whether the link is still active
    or not.  This implementation simply uses a checkpoint sequence, but
    some other protocols may choose to add protocol, including sending
    a NetBIOS SESSION_ALIVE frame.  If a checkpoint sequence is already
    in progress, then we do nothing.

    This timer expiration routine is self-perpetuating; that is, it starts
    itself after finishing its tasks every time.

Arguments:

    Link - Pointer to the TP_LINK object whose Ti timer has expired.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireTiTimer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    if ((Link->State != LINK_STATE_ADM) &&
        (Link->State != LINK_STATE_W_DISC_RSP) &&
        (Link->SendState != SEND_STATE_CHECKPOINTING)) {

        IF_NBFDBG (NBF_DEBUG_TIMER) {
            NbfPrint0 ("ExpireTiTimer:  Entered.\n");
            NbfDumpLinkInfo (Link);
        }

        if (Link->Provider->EasilyDisconnected && Link->NumberOfConnectors == 0) {

            //
            // On an easily disconnected network with only server connections,
            // if there has been no activity in this timeout period then
            // we trash the connection.
            //

            if (Link->PacketsReceived == Link->TiStartPacketsReceived) {

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);   // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no final received)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_FINAL mode", Link, LREF_NOT_ADM);

            } else {

                //
                // There was traffic, restart the timer.
                //

                StartTi (Link);
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            }

        } else {

#if 0
            if ((Link->SendState == SEND_STATE_READY) &&
                (Link->T1 == 0) &&
                (!IsListEmpty (&Link->WackQ))) {

                //
                // If we think the link is idle but there are packets
                // on the WackQ, the link is messed up, disconnect it.
                //

                NbfPrint1 ("NBF: Link %d hung at Ti expiration, recovering\n", Link);
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);

            } else {
#endif

                Link->SendState = SEND_STATE_CHECKPOINTING;
                Link->PacketsSent = 0;
                Link->PacketsResent = 0;
                Link->PacketsReceived = 0;
                NbfSendRr (Link, TRUE, TRUE);    // send RR-c/p, StartT1, release lock.

#if 0
            }
#endif

        }

    } else {

        Link->PacketsSent = 0;
        Link->PacketsResent = 0;
        Link->PacketsReceived = 0;

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
        if (Link->SendState == SEND_STATE_REJECTING) {
            NbfPrint0 ("ExpireTiTimer: link state == rejecting, shouldn't be\n");
        }
#endif

    }

#if 0
    //
    // Startup the inactivity timer again.
    //

    if (Link->State != LINK_STATE_ADM) {
        StartTi (Link);
    }
#endif

} /* ExpireTiTimer */

#if 0

VOID
ExpirePurgeTimer(
    PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine is called when the device context's periodic adaptive
    window algorithm timer expires.  The timer perpetuates itself on a
    regular basis.

Arguments:

    DeviceContext - Pointer to the device context whose purge timer has expired.

Return Value:

    none.

--*/

{
    PTP_LINK Link;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpirePurgeTimer:  Entered.\n");
    }

    //
    // Scan through the link database on this device context and clear
    // their worst window size limit.  This will allow stuck links to
    // grow their window again even though they encountered temporary
    // congestion at the remote link station's adapter.
    //

    while (!IsListEmpty (&DeviceContext->PurgeList)) {
        p = RemoveHeadList (&DeviceContext->PurgeList);
        Link = CONTAINING_RECORD (p, TP_LINK, PurgeList);
        Link->WorstWindowSize = Link->MaxWindowSize;   // maximum window possible.

    }

    //
    // Restart purge timer.
    //

    DeviceContext->AdaptivePurge = DeviceContext->ShortAbsoluteTime + TIMER_PURGE_TICKS;


} /* ExpirePurgeTimer */
#endif


VOID
ScanShortTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any link-level timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    DeferredContext - Pointer to our DEVICE_CONTEXT object.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p, nextp;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    PTP_CONNECTION Connection;
    BOOLEAN RestartTimer = FALSE;
    LARGE_INTEGER CurrentTick;
    LARGE_INTEGER TickDifference;
    ULONG TickDelta;


    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    DeviceContext = DeferredContext;

    IF_NBFDBG (NBF_DEBUG_TIMERDPC) {
        NbfPrint0 ("ScanShortTimersDpc:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    //
    // This prevents anybody from starting the timer while we
    // are in this routine (the main reason for this is that it
    // makes it easier to determine whether we should restart
    // it at the end of this routine).
    //

    DeviceContext->ProcessingShortTimer = TRUE;

    //
    // Advance the up-counter used to mark time in SHORT_TIMER_DELTA units.  If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //


    KeQueryTickCount (&CurrentTick);

    TickDifference.QuadPart = CurrentTick.QuadPart -
                          (DeviceContext->ShortTimerStart).QuadPart;

    TickDelta = TickDifference.LowPart / NbfShortTimerDeltaTicks;
    if (TickDelta == 0) {
        TickDelta = 1;
    }

    DeviceContext->ShortAbsoluteTime += TickDelta;

    if (DeviceContext->ShortAbsoluteTime >= 0xf0000000) {

        ULONG Timeout;

        DeviceContext->ShortAbsoluteTime -= 0xe0000000;

        p = DeviceContext->ShortList.Flink;
        while (p != &DeviceContext->ShortList) {

            Link = CONTAINING_RECORD (p, TP_LINK, ShortList);

            Timeout = Link->T1;
            if (Timeout) {
                Link->T1 = Timeout - 0xe0000000;
            }

            Timeout = Link->T2;
            if (Timeout) {
                Link->T2 = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }

    //
    // now, as the timers are started, links are added to the end of the
    // respective queue for that timer. since we know the additions are
    // done in an orderly fashion and are sequential, we must only traverse
    // a particular timer list to the first entry that is greater than our
    // timer. That entry and all further entries will not need service.
    // When a timer is cancelled, we remove the link from the list. With all
    // of this fooling around, we wind up only visiting those links that are
    // actually in danger of timing out, minimizing time in this routine.
    //

    // T1 timers first; this is the link-level response expected timer, and is
    // the shortest one.
    // T2 timers. This is the iframe response expected timer, and is typically
    // about 300 ms.

    p = DeviceContext->ShortList.Flink;
    while (p != &DeviceContext->ShortList) {

        Link = CONTAINING_RECORD (p, TP_LINK, ShortList);

        ASSERT (Link->OnShortList);

        //
        // To avoid problems with the refcount being 0, don't
        // do this if we are in ADM.
        //

        if (Link->State != LINK_STATE_ADM) {

            if (Link->T1 && (DeviceContext->ShortAbsoluteTime > Link->T1)) {

                Link->T1 = 0;
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                ExpireT1Timer (Link);       // no spinlocks held
                INCREMENT_COUNTER (DeviceContext, ResponseTimerExpirations);

                ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            }

            if (Link->T2 && (DeviceContext->ShortAbsoluteTime > Link->T2)) {

                Link->T2 = 0;
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                ExpireT2Timer (Link);       // no spinlocks held
                INCREMENT_COUNTER (DeviceContext, AckTimerExpirations);

                ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            }

        }

        if (!Link->OnShortList) {

            //
            // The link has been taken out of the list while
            // we were processing it. In this (rare) case we
            // stop processing the whole list, we'll get it
            // next time.
            //

#if DBG
            DbgPrint ("NBF: Stop processing ShortList, %lx removed\n", Link);
#endif
            break;

        }

        nextp = p->Flink;

        if ((Link->T1 == 0) && (Link->T2 == 0)) {
            Link->OnShortList = FALSE;
            RemoveEntryList(p);

            //
            // Do another check; that way if someone slipped in between
            // the check of Link->Tx and the OnShortList = FALSE and
            // therefore exited without inserting, we'll catch that here.
            //

            if ((Link->T1 != 0) || (Link->T2 != 0)) {
                InsertTailList(&DeviceContext->ShortList, &Link->ShortList);
                Link->OnShortList = TRUE;
            }

        }

        p = nextp;

    }

    //
    // If the list is empty note that, otherwise ShortListActive
    // remains TRUE.
    //

    if (IsListEmpty (&DeviceContext->ShortList)) {
        DeviceContext->a.i.ShortListActive = FALSE;
    }

    //
    // NOTE: DeviceContext->TimerSpinLock is held here.
    //


    //
    // Connection Data Ack timers. This queue is used to indicate
    // that a piggyback ack is pending for this connection. We walk
    // the queue, for each element we check if the connection has
    // been on the queue for NbfDeferredPasses times through
    // here. If so, we take it off and send an ack. Note that
    // we have to be very careful how we walk the queue, since
    // it may be changing while this is running.
    //
    // NOTE: There is no expiration time for connections on this
    // queue; it "expires" every time ScanShortTimersDpc runs.
    //


    for (p = DeviceContext->DataAckQueue.Flink;
         p != &DeviceContext->DataAckQueue;
         p = p->Flink) {

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, DataAckLinkage);

        //
        // Skip this connection if it is not queued or it is
        // too recent to matter. We may skip incorrectly if
        // the connection is just being queued, but that is
        // OK, we will get it next time.
        //

        if (((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) == 0) &&
            ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_NOT_Q) == 0)) {
            continue;
        }

        TickDifference.QuadPart = CurrentTick.QuadPart -
                                      (Connection->ConnectStartTime).QuadPart;

        if ((TickDifference.HighPart == 0) &&
            (TickDifference.LowPart <= NbfTwentyMillisecondsTicks)) {
            continue;
        }

        NbfReferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        DeviceContext->DataAckQueueChanged = FALSE;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Check the correct connection flag, to ensure that a
        // send has not just taken him off the queue.
        //
        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        if (((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) &&
            ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_NOT_Q) == 0)) {

            //
            // Yes, we were waiting to piggyback an ack, but no send
            // has come along. Turn off the flags and send an ack.
            //
            // We have to ensure we nest the spin lock acquisition
            // correctly.
            //

            Connection->DeferredFlags &= ~CONNECTION_FLAGS_DEFERRED_ACK;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            INCREMENT_COUNTER (DeviceContext, PiggybackAckTimeouts);

#if DBG
            if (NbfDebugPiggybackAcks) {
                NbfPrint0("T");
            }
#endif

            NbfSendDataAck (Connection);

        } else {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        NbfDereferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // If the list has changed, then we need to stop processing
        // since p->Flink is not valid.
        //

        if (DeviceContext->DataAckQueueChanged) {
            break;
        }

    }

    if (IsListEmpty (&DeviceContext->DataAckQueue)) {
        DeviceContext->a.i.DataAckQueueActive = FALSE;
    }

#if 0

    //
    // NOTE: This is currently disabled, it may be reenabled
    // at some point - adamba 9/1/92
    //
    // If the adaptive purge timer has expired, then run the purge
    // algorithm on all affected links.
    //

    if (DeviceContext->ShortAbsoluteTime > DeviceContext->AdaptivePurge) {
        DeviceContext->AdaptivePurge = DeviceContext->ShortAbsoluteTime +
                                       TIMER_PURGE_TICKS;
        ExpirePurgeTimer (DeviceContext);
    }
#endif

    //
    // deferred processing. We will handle all link structure additions and
    // deletions here; we must be the exclusive user of the link tree to do
    // this. We verify that we are by examining the semaphore that tells us
    // how many readers of the tree are curretly processing it. If there are
    // any readers, we simply increment our "deferred processing locked out"
    // counter and do something else. If we defer too many times, we simply
    // bugcheck, as something is wrong somewhere in the system.
    //

    if (!IsListEmpty (&DeviceContext->LinkDeferred)) {
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // now do additions or deletions if we can.
        //

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        while (!IsListEmpty (&DeviceContext->LinkDeferred)) {
            p = RemoveHeadList (&DeviceContext->LinkDeferred);
            DeviceContext->DeferredNotSatisfied = 0;

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            //
            // now do an addition or deletion if we can.
            //

            Link = CONTAINING_RECORD (p, TP_LINK, DeferredList);

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint4 ("ScanShortTimersDPC: link off deferred queue %lx %lx %lx Flags: %lx \n",
                    Link, DeviceContext->LinkDeferred.Flink,
                    DeviceContext->LinkDeferred.Blink, Link->DeferredFlags);
            }
            Link->DeferredList.Flink = Link->DeferredList.Blink =
                                                    &Link->DeferredList;

            if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_MASK) == 0) {
                // Tried to do an operation we don't understand; whine.

                IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                    NbfPrint2 ("ScanTimerDPC: Attempting deferred operation on nothing! \nScanTimerDPC: Link: %lx, DeviceContext->DeferredQueue: %lx\n",
                        Link, &DeviceContext->LinkDeferred);
                      DbgBreakPoint ();
                }
                InitializeListHead (&DeviceContext->LinkDeferred);
                // We could have a hosed deferred operations queue here;
                // take some time to figure out if it is ok.

            }

            if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_ADD) != 0) {

                Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_ADD;

                if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {

                    //
                    // It is being added and deleted; just destroy it.
                    //
                    Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_DELETE;
                    NbfDestroyLink (Link);

                    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                        NbfPrint1 ("ScanTimerDPC: deferred processing: Add AND Delete link: %lx\n",Link);
                    }

                } else  {

                    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
                    NbfAddLinkToTree (DeviceContext, Link);
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
                    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                        NbfPrint1 ("ScanTimerDPC: deferred processing: Added link to tree: %lx\n",Link);
                    }

                }

            } else if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {
                Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_DELETE;
                NbfRemoveLinkFromTree (DeviceContext, Link);
                NbfDestroyLink (Link);

                IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                    NbfPrint1 ("ScanTimerDPC: deferred processing: returning link %lx to LinkPool.\n", Link);
                }

            }

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        }

        InitializeListHead (&DeviceContext->LinkDeferred);

        DeviceContext->a.i.LinkDeferredActive = FALSE;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    }


    //
    // Update the real counters from the temp ones.
    //

    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DataFrameBytesSent,
        DeviceContext->TempIFrameBytesSent);
    DeviceContext->Statistics.DataFramesSent += DeviceContext->TempIFramesSent;

    DeviceContext->TempIFrameBytesSent = 0;
    DeviceContext->TempIFramesSent = 0;

    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DataFrameBytesReceived,
        DeviceContext->TempIFrameBytesReceived);
    DeviceContext->Statistics.DataFramesReceived += DeviceContext->TempIFramesReceived;

    DeviceContext->TempIFrameBytesReceived = 0;
    DeviceContext->TempIFramesReceived = 0;


    //
    // Determine if we have to restart the timer.
    //

    DeviceContext->ProcessingShortTimer = FALSE;

    if (DeviceContext->a.AnyActive &&
        (DeviceContext->State != DEVICECONTEXT_STATE_STOPPING)) {

        RestartTimer = TRUE;

    }


    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    if (RestartTimer) {

        //
        // Start up the timer again.  Note that because we start the timer
        // after doing work (above), the timer values will slip somewhat,
        // depending on the load on the protocol.  This is entirely acceptable
        // and will prevent us from using the timer DPC in two different
        // threads of execution.
        //

        KeQueryTickCount(&DeviceContext->ShortTimerStart);
        START_TIMER(DeviceContext, 
                    SHORT_TIMER,
                    &DeviceContext->ShortSystemTimer,
                    DueTimeDelta,
                    &DeviceContext->ShortTimerSystemDpc);
    } else {

#if DBG
        if (NbfDebugShortTimer) {
            DbgPrint("x");
        }
#endif
        NbfDereferenceDeviceContext ("Don't restart short timer", DeviceContext, DCREF_SCAN_TIMER);

    }

    LEAVE_TIMER(DeviceContext, SHORT_TIMER);

    LEAVE_NBF;
    return;

} /* ScanShortTimersDpc */


VOID
ScanLongTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any long timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    DeferredContext - Pointer to our DEVICE_CONTEXT object.

Return Value:

    none.

--*/

{
    LARGE_INTEGER DueTime;
    PLIST_ENTRY p, nextp;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    DeviceContext = DeferredContext;

    IF_NBFDBG (NBF_DEBUG_TIMERDPC) {
        NbfPrint0 ("ScanLongTimersDpc:  Entered.\n");
    }
 
    //
    // Advance the up-counter used to mark time in LONG_TIMER_DELTA units.If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    if (++DeviceContext->LongAbsoluteTime == 0xf0000000) {

        ULONG Timeout;

        DeviceContext->LongAbsoluteTime = 0x10000000;

        p = DeviceContext->LongList.Flink;
        while (p != &DeviceContext->LongList) {

            Link = CONTAINING_RECORD (p, TP_LINK, LongList);

            Timeout = Link->Ti;
            if (Timeout) {
                Link->Ti = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }

    //
    // now, as the timers are started, links are added to the end of the
    // respective queue for that timer. since we know the additions are
    // done in an orderly fashion and are sequential, we must only traverse
    // a particular timer list to the first entry that is greater than our
    // timer. That entry and all further entries will not need service.
    // When a timer is cancelled, we remove the link from the list. With all
    // of this fooling around, we wind up only visiting those links that are
    // actually in danger of timing out, minimizing time in this routine.
    //


    //
    // Ti timers. This is the inactivity timer for the link, used when no
    // activity has occurred on the link in some time. We only check this
    // every four expirations of the timer since the granularity is usually
    // in the 30 second range.
    // NOTE: DeviceContext->TimerSpinLock is held here.
    //

    if ((DeviceContext->LongAbsoluteTime % 4) == 0) {

        p = DeviceContext->LongList.Flink;
        while (p != &DeviceContext->LongList) {

            Link = CONTAINING_RECORD (p, TP_LINK, LongList);

            ASSERT (Link->OnLongList);

            //
            // To avoid problems with the refcount being 0, don't
            // do this if we are in ADM.
            //

#if DBG
            if (Link->SendState == SEND_STATE_REJECTING) {
                NbfPrint0 ("Timer: link state == rejecting, shouldn't be\n");
            }
#endif

            if (Link->State != LINK_STATE_ADM) {

                if (Link->Ti && (DeviceContext->LongAbsoluteTime > Link->Ti)) {

                    Link->Ti = 0;
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                    ExpireTiTimer (Link);       // no spinlocks held
                    ++DeviceContext->TiExpirations;

                    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                }

            }

            if (!Link->OnLongList) {

                //
                // The link has been taken out of the list while
                // we were processing it. In this (rare) case we
                // stop processing the whole list, we'll get it
                // next time.
                //

#if DBG
                DbgPrint ("NBF: Stop processing LongList, %lx removed\n", Link);
#endif
                break;

            }

            nextp = p->Flink;

            if (Link->Ti == 0) {

                Link->OnLongList = FALSE;
                RemoveEntryList(p);

                if (Link->Ti != 0) {
                    InsertTailList(&DeviceContext->LongList, &Link->LongList);
                    Link->OnLongList = TRUE;
                }

            }

            p = nextp;

        }

    }


    //
    // Now scan the data ack queue, looking for connections with
    // no acks queued that we can get rid of.
    //
    // Note: The timer spinlock is held here.
    //

    p = DeviceContext->DataAckQueue.Flink;

    while (p != &DeviceContext->DataAckQueue && 
           !DeviceContext->DataAckQueueChanged) {

        Connection = CONTAINING_RECORD (DeviceContext->DataAckQueue.Flink, TP_CONNECTION, DataAckLinkage);

        if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {
            p = p->Flink;
            continue;
        }

        NbfReferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Have to check again, because the connection might
        // just have been stopped.
        //

        if (Connection->OnDataAckQueue) {
            Connection->OnDataAckQueue = FALSE;

            RemoveEntryList (&Connection->DataAckLinkage);

            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {
                InsertTailList (&DeviceContext->DataAckQueue, &Connection->DataAckLinkage);
                Connection->OnDataAckQueue = TRUE;
            }

            DeviceContext->DataAckQueueChanged = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        NbfDereferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Since we have changed the list, we can't tell if p->Flink
        // is valid, so break. The effect is that we gradually peel
        // connections off the queue.
        //

        break;

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);


    //
    // See if we got any multicast traffic last time.
    //

    if (DeviceContext->MulticastPacketCount == 0) {

        ++DeviceContext->LongTimeoutsWithoutMulticast;

        if (DeviceContext->EasilyDisconnected &&
            (DeviceContext->LongTimeoutsWithoutMulticast > 5)) {

            PLIST_ENTRY p;
            PTP_ADDRESS address;

            //
            // We have had five timeouts in a row with no
            // traffic, mark all the addresses as needing
            // reregistration next time a connect is
            // done on them.
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            for (p = DeviceContext->AddressDatabase.Flink;
                 p != &DeviceContext->AddressDatabase;
                 p = p->Flink) {

                address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);
                address->Flags |= ADDRESS_FLAGS_NEED_REREGISTER;

            }

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            DeviceContext->LongTimeoutsWithoutMulticast = 0;

        }

    } else {

        DeviceContext->LongTimeoutsWithoutMulticast = 0;

    }

    DeviceContext->MulticastPacketCount = 0;


    //
    // Every thirty seconds, check for stalled connections
    //

    ++DeviceContext->StalledConnectionCount;

    if (DeviceContext->StalledConnectionCount ==
            (USHORT)((30 * SECONDS) / LONG_TIMER_DELTA)) {

        DeviceContext->StalledConnectionCount = 0;
        StopStalledConnections (DeviceContext);

    }


    //
    // Scan for any uncompleted receive IRPs, this may happen if
    // the cable is pulled and we don't get any more ReceiveComplete
    // indications.

    NbfReceiveComplete((NDIS_HANDLE)DeviceContext);


    //
    // Start up the timer again.  Note that because we start the timer
    // after doing work (above), the timer values will slip somewhat,
    // depending on the load on the protocol.  This is entirely acceptable
    // and will prevent us from using the timer DPC in two different
    // threads of execution.
    //

    if (DeviceContext->State != DEVICECONTEXT_STATE_STOPPING) {
        DueTime.HighPart = -1;
        DueTime.LowPart = (ULONG)-(LONG_TIMER_DELTA);          // delta time to next click.
        START_TIMER(DeviceContext, 
                    LONG_TIMER,
                    &DeviceContext->LongSystemTimer,
                    DueTime,
                    &DeviceContext->LongTimerSystemDpc);
    } else {
        NbfDereferenceDeviceContext ("Don't restart long timer", DeviceContext, DCREF_SCAN_TIMER);
    }

    LEAVE_TIMER(DeviceContext, LONG_TIMER);
    
    LEAVE_NBF;
    return;

} /* ScanLongTimersDpc */


VOID
StopStalledConnections(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine is called from ScanLongTimersDpc every 30 seconds.
    It checks for connections that have not made any progress in
    their sends in the last two minutes, and stops them.

Arguments:

    DeviceContext - The device context to check.

Return Value:

    none.

--*/

{

    PTP_ADDRESS Address, PrevAddress;
    PTP_CONNECTION Connection, StalledConnection;
    PLIST_ENTRY p, q;


    //
    // If we have crossed a thirty-second interval, then
    // check each address for connections that have not
    // made any progress in two minutes.
    //

    PrevAddress = NULL;

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    for (p = DeviceContext->AddressDatabase.Flink;
         p != &DeviceContext->AddressDatabase;
         p = p->Flink) {

        Address = CONTAINING_RECORD (
                    p,
                    TP_ADDRESS,
                    Linkage);

        if ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        //
        // By referencing the address, we ensure that it will stay
        // in the AddressDatabase, this its Flink will stay valid.
        //

        NbfReferenceAddress("checking for dead connections", Address, AREF_TIMER_SCAN);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        if (PrevAddress) {
            NbfDereferenceAddress ("done checking", PrevAddress, AREF_TIMER_SCAN);
        }

        //
        // Scan this addresses connection database for connections
        // that have not made progress in the last two minutes; we
        // kill the first one we find.
        //

        StalledConnection = NULL;

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

        for (q = Address->ConnectionDatabase.Flink;
            q != &Address->ConnectionDatabase;
            q = q->Flink) {

            Connection = CONTAINING_RECORD (q, TP_CONNECTION, AddressList);

            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            if (!IsListEmpty (&Connection->SendQueue)) {

                //
                // If there is a connection on the queue...
                //

                if (Connection->StallBytesSent == Connection->sp.MessageBytesSent) {

                    //
                    // ...and it has not made any progress...
                    //

                    if (Connection->StallCount >= 4) {

                        //
                        // .. four times in a row, the connection is dead.
                        //

                        if (!StalledConnection) {
                            StalledConnection = Connection;
                            NbfReferenceConnection ("stalled", Connection, CREF_STALLED);
                        }
#if DBG
                        DbgPrint ("NBF: Found connection %lx [%d for %d] stalled on %lx\n",
                            Connection, Connection->StallBytesSent, Connection->StallCount, Address);
#endif

                    } else {

                        //
                        // If it is stuck, increment the count.
                        //

                        ++Connection->StallCount;

                    }

                } else {

                    Connection->StallBytesSent = Connection->sp.MessageBytesSent;

                }

            }

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);


        }

        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

        if (StalledConnection) {

            PTP_LINK Link = StalledConnection->Link;

#if DBG
            DbgPrint("NBF: Stopping stalled connection %lx, link %lx\n", StalledConnection, Link);
#endif

            FailSend (StalledConnection, STATUS_IO_TIMEOUT, TRUE);                   // fail the send
            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            if (Link->State == LINK_STATE_READY) {
                CancelT1Timeout (Link);
                Link->State = LINK_STATE_W_DISC_RSP;
                Link->SendState = SEND_STATE_DOWN;
                Link->ReceiveState = RECEIVE_STATE_DOWN;
                Link->SendRetries = (UCHAR)Link->LlcRetries;
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
                NbfSendDisc (Link, TRUE);  // send DISC-c/p.
            } else {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);
            }

            NbfDereferenceConnection ("stalled", StalledConnection, CREF_STALLED);

        }

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        PrevAddress = Address;

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    if (PrevAddress) {
        NbfDereferenceAddress ("done checking", PrevAddress, AREF_TIMER_SCAN);
    }

}   /* StopStalledConnections */


VOID
NbfStartShortTimer(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine starts the short timer, if it is not already running.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{

    //
    // Start the timer unless it the DPC is already running (in
    // which case it will restart the timer itself if needed),
    // or some list is active (meaning the timer is already
    // queued up).
    //
    // We use a trick to check all four active lists at the
    // same time, but this depends on some alignment and
    // size assumptions.
    //

    ASSERT (sizeof(ULONG) >= 3 * sizeof(BOOLEAN));
    ASSERT ((PVOID)&DeviceContext->a.AnyActive ==
            (PVOID)&DeviceContext->a.i.ShortListActive);

    StartTimer++;

    if ((!DeviceContext->ProcessingShortTimer) &&
        (!(DeviceContext->a.AnyActive))) {

#if DBG
        if (NbfDebugShortTimer) {
            DbgPrint("X");
        }
#endif

        NbfReferenceDeviceContext ("Start short timer", DeviceContext, DCREF_SCAN_TIMER);

        KeQueryTickCount(&DeviceContext->ShortTimerStart);
        StartTimerSet++;
        START_TIMER(DeviceContext, 
                    SHORT_TIMER,
                    &DeviceContext->ShortSystemTimer,
                    DueTimeDelta,
                    &DeviceContext->ShortTimerSystemDpc);
    }

}   /* NbfStartShortTimer */


VOID
NbfInitializeTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine initializes the lightweight timer system for the transport
    provider.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{
    LARGE_INTEGER DueTime;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("NbfInitializeTimerSystem:  Entered.\n");
    }

    ASSERT(TIMERS_INITIALIZED(DeviceContext));
    
    //
    // Set these up.
    //

    NbfTickIncrement = KeQueryTimeIncrement();

    if (NbfTickIncrement > (20 * MILLISECONDS)) {
        NbfTwentyMillisecondsTicks = 1;
    } else {
        NbfTwentyMillisecondsTicks = (20 * MILLISECONDS) / NbfTickIncrement;
    }

    if (NbfTickIncrement > (SHORT_TIMER_DELTA)) {
        NbfShortTimerDeltaTicks = 1;
    } else {
        NbfShortTimerDeltaTicks = (SHORT_TIMER_DELTA) / NbfTickIncrement;
    }

    //
    // MaximumIntervalTicks represents 60 seconds, unless the value
    // when shifted out by the accuracy required is too big.
    //

    if ((((ULONG)0xffffffff) >> (DLC_TIMER_ACCURACY+2)) > ((60 * SECONDS) / NbfTickIncrement)) {
        NbfMaximumIntervalTicks = (60 * SECONDS) / NbfTickIncrement;
    } else {
        NbfMaximumIntervalTicks = ((ULONG)0xffffffff) >> (DLC_TIMER_ACCURACY + 2);
    }

    //
    // The AbsoluteTime cycles between 0x10000000 and 0xf0000000.
    //

    DeviceContext->ShortAbsoluteTime = 0x10000000;   // initialize our timer click up-counter.
    DeviceContext->LongAbsoluteTime = 0x10000000;   // initialize our timer click up-counter.

    DeviceContext->AdaptivePurge = TIMER_PURGE_TICKS;

    DeviceContext->MulticastPacketCount = 0;
    DeviceContext->LongTimeoutsWithoutMulticast = 0;

    KeInitializeDpc(
        &DeviceContext->ShortTimerSystemDpc,
        ScanShortTimersDpc,
        DeviceContext);

    KeInitializeDpc(
        &DeviceContext->LongTimerSystemDpc,
        ScanLongTimersDpc,
        DeviceContext);

    KeInitializeTimer (&DeviceContext->ShortSystemTimer);

    KeInitializeTimer (&DeviceContext->LongSystemTimer);

    DueTime.HighPart = -1;
    DueTime.LowPart = (ULONG)-(LONG_TIMER_DELTA);

    ENABLE_TIMERS(DeviceContext);

    //
    // One reference for the long timer.
    //

    NbfReferenceDeviceContext ("Long timer active", DeviceContext, DCREF_SCAN_TIMER);

    START_TIMER(DeviceContext, 
                LONG_TIMER,
                &DeviceContext->LongSystemTimer,
                DueTime,
                &DeviceContext->LongTimerSystemDpc);

} /* NbfInitializeTimerSystem */


VOID
NbfStopTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine stops the lightweight timer system for the transport
    provider.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{

    //
    // If timers are currently executing timer code, then this
    // function blocks until they are done executing. Also
    // no new timers will be allowed to be queued after this.
    //
    
    {
        if (KeCancelTimer(&DeviceContext->LongSystemTimer)) {
            LEAVE_TIMER(DeviceContext, LONG_TIMER);
            NbfDereferenceDeviceContext ("Long timer cancelled", DeviceContext, DCREF_SCAN_TIMER);
        }

        if (KeCancelTimer(&DeviceContext->ShortSystemTimer)) {
            LEAVE_TIMER(DeviceContext, SHORT_TIMER);
            NbfDereferenceDeviceContext ("Short timer cancelled", DeviceContext, DCREF_SCAN_TIMER);
        }
    }

    DISABLE_TIMERS(DeviceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\uframes.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    uframes.c

Abstract:

    This module contains a routine called NbfProcessUi, that gets control
    from routines in DLC.C when a DLC UI frame is received.  Here we
    decode the encapsulated connectionless NetBIOS frame and dispatch
    to the correct NetBIOS frame handler.

    The following frame types are cracked by routines in this module:

        o    NBF_CMD_ADD_GROUP_NAME_QUERY
        o    NBF_CMD_ADD_NAME_QUERY
        o    NBF_CMD_NAME_IN_CONFLICT
        o    NBF_CMD_STATUS_QUERY
        o    NBF_CMD_TERMINATE_TRACE
        o    NBF_CMD_DATAGRAM
        o    NBF_CMD_DATAGRAM_BROADCAST
        o    NBF_CMD_NAME_QUERY
        o    NBF_CMD_ADD_NAME_RESPONSE
        o    NBF_CMD_NAME_RECOGNIZED
        o    NBF_CMD_STATUS_RESPONSE
        o    NBF_CMD_TERMINATE_TRACE2

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode, DISPATCH_LEVEL.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



VOID
NbfListenTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is executed as a DPC at DISPATCH_LEVEL when the timeout
    period for the session setup after listening a connection occurs. This
    will occur if the remote has discovered our name and we do not get a
    connection started within some reasonable period of time. In this
    routine we simply tear down the connection (and, most likely, the link
    associated with it).

Arguments:

    Dpc - Pointer to a system DPC object.

    DeferredContext - Pointer to the TP_CONNECTION block representing the
        request that has timed out.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    none.

--*/

{
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    Connection = (PTP_CONNECTION)DeferredContext;

    //
    // If this connection is being run down, then we can't do anything.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
            ((Connection->Flags & CONNECTION_FLAGS_WAIT_SI) == 0)) {

        //
        // The connection is stopping, or the SESSION_INITIALIZE
        // has already been processed.
        //

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx stopping.\n",
                        Connection);
        }

        NbfDereferenceConnection ("Listen timeout, ignored", Connection, CREF_TIMER);
        LEAVE_NBF;
        return;
    }

    //
    // We connected to the link before sending the NAME_RECOGNIZED,
    // so we disconnect from it now.
    //

#if DBG
    if (NbfDisconnectDebug) {
        STRING remoteName, localName;
        remoteName.Length = NETBIOS_NAME_LENGTH - 1;
        remoteName.Buffer = Connection->RemoteName;
        localName.Length = NETBIOS_NAME_LENGTH - 1;
        localName.Buffer = Connection->AddressFile->Address->NetworkName->NetbiosName;
        NbfPrint2( "NbfListenTimeout disconnecting connection to %S from %S\n",
            &remoteName, &localName );
    }
#endif

    //
    // BUBGUG: This is really ugly and I doubt it is correct.
    //

    if ((Connection->Flags2 & CONNECTION_FLAGS2_ACCEPTED) != 0) {

        //
        // This connection is up, we stop it.
        //

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, accepted.\n",
                        Connection);
        }

        //
        // Set this so that the client will get a disconnect
        // indication.
        //

        Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
        NbfStopConnection (Connection, STATUS_IO_TIMEOUT);

    } else if (Connection->Link != (PTP_LINK)NULL) {

        //
        // This connection is from a listen...we want to
        // silently reset the listen.
        //

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, listen restarted.\n",
                        Connection);
        }

        Connection->Flags &= ~CONNECTION_FLAGS_WAIT_SI;
        Connection->Flags2 &= ~CONNECTION_FLAGS2_REMOTE_VALID;
        Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        NbfDereferenceConnection ("Timeout", Connection, CREF_LINK);
        (VOID)NbfDisconnectFromLink (Connection, FALSE);

    } else {

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, link down.\n",
                        Connection);
        }

    }


    NbfDereferenceConnection("Listen Timeout", Connection, CREF_TIMER);

    LEAVE_NBF;
    return;

} /* ListenTimeout */


NTSTATUS
ProcessAddGroupNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_GROUP_NAME_QUERY frame.  Because
    our caller has already verified that the destination name in the frame
    matches the transport address passed to us, we must simply transmit an
    ADD_NAME_RESPONSE frame and exit with STATUS_ABANDONED.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.
    When we return any other status code, including STATUS_ABANDONED, the
    caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_UI_FRAME RawFrame;  // ptr to allocated connectionless frame.
    UINT HeaderLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;

    UNREFERENCED_PARAMETER (SourceAddress);
    UNREFERENCED_PARAMETER (Address);

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessAddGroupNameQuery %lx: [%.16s].\n", Address, Header->DestinationName);
    }

    //
    // Allocate a UI frame from the pool.
    //

    if (NbfCreateConnectionlessFrame (DeviceContext, &RawFrame) != STATUS_SUCCESS) {
        return STATUS_ABANDONED;        // no resources to do this.
    }


    //
    // Build the MAC header. ADD_NAME_RESPONSE frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        ResponseSR,
        SourceRoutingLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructAddNameResponse (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NETBIOS_NAME_TYPE_GROUP,        // type of name is GROUP.
        RESPONSE_CORR(Header),          // correlator from rec'd frame.
        (PUCHAR)Header->SourceName);    // NetBIOS name being responded to.

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                    // no loopback.

    return STATUS_ABANDONED;            // don't forward frame to other addr's.
} /* ProcessAddGroupNameQuery */


NTSTATUS
ProcessAddNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_NAME_QUERY frame.  Because
    our caller has already verified that the destination name in the frame
    matches the transport address passed to us, we must simply transmit an
    ADD_NAME_RESPONSE frame and exit with STATUS_ABANDONED.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_UI_FRAME RawFrame;  // ptr to allocated connectionless frame.
    UINT HeaderLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;

    Address, SourceAddress; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessAddNameQuery %lx: [%.16s].\n", Address, Header->DestinationName);
    }

    //
    // Allocate a UI frame from the pool.
    //

    if (NbfCreateConnectionlessFrame (DeviceContext, &RawFrame) != STATUS_SUCCESS) {
        return STATUS_ABANDONED;        // no resources to do this.
    }


    //
    // Build the MAC header. ADD_NAME_RESPONSE frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        ResponseSR,
        SourceRoutingLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructAddNameResponse (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NETBIOS_NAME_TYPE_UNIQUE,       // type of name is UNIQUE.
        RESPONSE_CORR(Header),          // correlator from received frame.
        (PUCHAR)Header->SourceName);    // NetBIOS name being responded to

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                    // no loopback.

    return STATUS_ABANDONED;            // don't forward frame to other addr's.
} /* ProcessAddNameQuery */


NTSTATUS
ProcessNameInConflict(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_IN_CONFLICT frame.
    Although we can't disrupt any traffic on this address, it is considered
    invalid and cannot be used for any new address files or new connections.
    Therefore, we just mark the address as invalid.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    DeviceContext, Header, SourceAddress; // prevent compiler warnings


    //
    // Ignore this if we are registering/deregistering (the name will
    // go away anyway) or if we have already marked this name as
    // in conflict and logged an error.
    //

    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameInConflict %lx: address marked [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;
    }

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessNameInConflict %lx: [%.16s].\n", Address, Header->SourceName);
    }

#if 0
    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    Address->Flags |= ADDRESS_FLAGS_CONFLICT;

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    DbgPrint ("NBF: Name-in-conflict on <%.16s> from ", Header->DestinationName);
    DbgPrint ("%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
        SourceAddress->Address[0],
        SourceAddress->Address[1],
        SourceAddress->Address[2],
        SourceAddress->Address[3],
        SourceAddress->Address[4],
        SourceAddress->Address[5]);
#endif

    NbfWriteGeneralErrorLog(
        Address->Provider,
        EVENT_TRANSPORT_BAD_PROTOCOL,
        2,
        STATUS_DUPLICATE_NAME,
        L"NAME_IN_CONFLICT",
        16/sizeof(ULONG),
        (PULONG)(Header->DestinationName));

    return STATUS_ABANDONED;

} /* ProcessNameInConflict */


NTSTATUS
NbfIndicateDatagram(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PUCHAR Dsdu,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine processes an incoming DATAGRAM or DATAGRAM_BROADCAST frame.
    BROADCAST and normal datagrams have the same receive logic, except
    for broadcast datagrams Address will be the broadcast address.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Dsdu - Pointer to a Mdl buffer that contains the received datagram.
        The first byte of information in the buffer is the first byte in
        the NetBIOS connectionless header, and it is already negotiated that
        the data link layer will provide at least the entire NetBIOS header
        as contiguous data.

    Length - The length of the MDL pointed to by Dsdu.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PLIST_ENTRY p, q;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG IndicateBytesCopied, MdlBytesCopied, BytesToCopy;
    TA_NETBIOS_ADDRESS SourceName;
    TA_NETBIOS_ADDRESS DestinationName;
    PTDI_CONNECTION_INFORMATION remoteInformation;
    ULONG returnLength;
    PTP_ADDRESS_FILE addressFile, prevaddressFile;
    PTDI_CONNECTION_INFORMATION DatagramInformation;
    TDI_ADDRESS_NETBIOS * DatagramAddress;
    PNBF_HDR_CONNECTIONLESS Header = (PNBF_HDR_CONNECTIONLESS)Dsdu;

    IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
        NbfPrint0 ("NbfIndicateDatagram:  Entered.\n");
    }

    //
    // If this datagram wasn't big enough for a transport header, then don't
    // let the caller look at any data.
    //

    if (Length < sizeof(NBF_HDR_CONNECTIONLESS)) {
        IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
            NbfPrint0 ("NbfIndicateDatagram: Short datagram abandoned.\n");
        }
        return STATUS_ABANDONED;
    }

    //
    // Update our statistics.
    //

    ++DeviceContext->Statistics.DatagramsReceived;
    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DatagramBytesReceived,
        Length - sizeof(NBF_HDR_CONNECTIONLESS));


    //
    // Call the client's ReceiveDatagram indication handler.  He may
    // want to accept the datagram that way.
    //

    TdiBuildNetbiosAddress ((PUCHAR)Header->SourceName, FALSE, &SourceName);
    TdiBuildNetbiosAddress ((PUCHAR)Header->DestinationName, FALSE, &DestinationName);


    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    //
    // Find the first open address file in the list.
    //

    p = Address->AddressFileDatabase.Flink;
    while (p != &Address->AddressFileDatabase) {
        addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
        if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
            p = p->Flink;
            continue;
        }
        NbfReferenceAddressFile(addressFile);
        break;
    }

    while (p != &Address->AddressFileDatabase) {

        //
        // do we have a datagram receive request outstanding? If so, we will
        // satisfy it first. We run through the receive datagram queue
        // until we find a datagram with no remote address or with
        // this sender's address as its remote address.
        //

        for (q = addressFile->ReceiveDatagramQueue.Flink;
            q != &addressFile->ReceiveDatagramQueue;
            q = q->Flink) {

            irp = CONTAINING_RECORD (q, IRP, Tail.Overlay.ListEntry);
            DatagramInformation = ((PTDI_REQUEST_KERNEL_RECEIVEDG)
                &((IoGetCurrentIrpStackLocation(irp))->
                    Parameters))->ReceiveDatagramInformation;

            if (DatagramInformation &&
                (DatagramInformation->RemoteAddress) &&
                (DatagramAddress = NbfParseTdiAddress(DatagramInformation->RemoteAddress, FALSE)) &&
                (!RtlEqualMemory(
                    Header->SourceName,
                    DatagramAddress->NetbiosName,
                    NETBIOS_NAME_LENGTH))) {
                continue;
            }
            break;
        }

        if (q != &addressFile->ReceiveDatagramQueue) {
            KIRQL  cancelIrql;


            RemoveEntryList (q);
            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
                NbfPrint0 ("NbfIndicateDatagram: Receive datagram request found, copying.\n");
            }

            //
            // Copy the actual user data.
            //

            MdlBytesCopied = 0;

            BytesToCopy = Length - sizeof(NBF_HDR_CONNECTIONLESS);

            if ((BytesToCopy > 0) && irp->MdlAddress) {
                status = TdiCopyBufferToMdl (
                             Dsdu,
                             sizeof(NBF_HDR_CONNECTIONLESS),       // offset
                             BytesToCopy,                          // length
                             irp->MdlAddress,
                             0,
                             &MdlBytesCopied);
            } else {
                status = STATUS_SUCCESS;
            }

            //
            // Copy the addressing information.
            //

            irpSp = IoGetCurrentIrpStackLocation (irp);
            remoteInformation =
                ((PTDI_REQUEST_KERNEL_RECEIVEDG)(&irpSp->Parameters))->
                                                        ReturnDatagramInformation;
            if (remoteInformation != NULL) {
                try {
                    if (remoteInformation->RemoteAddressLength != 0) {
                        if (remoteInformation->RemoteAddressLength >=
                                               sizeof (TA_NETBIOS_ADDRESS)) {

                            RtlCopyMemory (
                             (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                             &SourceName,
                             sizeof (TA_NETBIOS_ADDRESS));

                            returnLength = sizeof(TA_NETBIOS_ADDRESS);
                            remoteInformation->RemoteAddressLength = returnLength;

                        } else {

                            RtlCopyMemory (
                             (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                             &SourceName,
                             remoteInformation->RemoteAddressLength);

                            returnLength = remoteInformation->RemoteAddressLength;
                            remoteInformation->RemoteAddressLength = returnLength;

                        }

                    } else {

                        returnLength = 0;
                    }

                    status = STATUS_SUCCESS;

                } except (EXCEPTION_EXECUTE_HANDLER) {

                    returnLength = 0;
                    status = GetExceptionCode ();

                }

            }

            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);
            irp->IoStatus.Information = MdlBytesCopied;
            irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (irp, IO_NETWORK_INCREMENT);

            NbfDereferenceAddress ("Receive DG done", Address, AREF_REQUEST);

        } else {

            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            //
            // no receive datagram requests; is there a kernel client?
            //

            if (addressFile->RegisteredReceiveDatagramHandler) {

                IndicateBytesCopied = 0;

                status = (*addressFile->ReceiveDatagramHandler)(
                             addressFile->ReceiveDatagramHandlerContext,
                             sizeof (TA_NETBIOS_ADDRESS),
                             &SourceName,
                             0,
                             NULL,
                             TDI_RECEIVE_COPY_LOOKAHEAD,
                             Length - sizeof(NBF_HDR_CONNECTIONLESS),  // indicated
                             Length - sizeof(NBF_HDR_CONNECTIONLESS),  // available
                             &IndicateBytesCopied,
                             Dsdu + sizeof(NBF_HDR_CONNECTIONLESS),
                             &irp);

                if (status == STATUS_SUCCESS) {

                    //
                    // The client accepted the datagram and so we're done.
                    //

                } else if (status == STATUS_DATA_NOT_ACCEPTED) {

                    //
                    // The client did not accept the datagram and we need to satisfy
                    // a TdiReceiveDatagram, if possible.
                    //

                    IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
                        NbfPrint0 ("NbfIndicateDatagram: Picking off a rcv datagram request from this address.\n");
                    }
                    status = STATUS_MORE_PROCESSING_REQUIRED;

                } else if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                    //
                    // The client returned an IRP that we should queue up to the
                    // address to satisfy the request.
                    //

                    irp->IoStatus.Status = STATUS_PENDING;  // init status information.
                    irp->IoStatus.Information = 0;
                    irpSp = IoGetCurrentIrpStackLocation (irp); // get current stack loctn.
                    if ((irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL) ||
                        (irpSp->MinorFunction != TDI_RECEIVE_DATAGRAM)) {
                        irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                        return status;
                    }

                    //
                    // Now copy the actual user data.
                    //

                    MdlBytesCopied = 0;

                    BytesToCopy = Length - sizeof(NBF_HDR_CONNECTIONLESS) - IndicateBytesCopied;

                    if ((BytesToCopy > 0) && irp->MdlAddress) {
                        status = TdiCopyBufferToMdl (
                                     Dsdu,
                                     sizeof(NBF_HDR_CONNECTIONLESS) + IndicateBytesCopied,
                                     BytesToCopy,
                                     irp->MdlAddress,
                                     0,
                                     &MdlBytesCopied);
                    } else {
                        status = STATUS_SUCCESS;
                    }

                    irp->IoStatus.Information = MdlBytesCopied;
                    irp->IoStatus.Status = status;
                    LEAVE_NBF;
                    IoCompleteRequest (irp, IO_NETWORK_INCREMENT);
                    ENTER_NBF;
                }
            }
        }

        //
        // Save this to dereference it later.
        //

        prevaddressFile = addressFile;

        //
        // Reference the next address file on the list, so it
        // stays around.
        //

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

        p = p->Flink;
        while (p != &Address->AddressFileDatabase) {
            addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
            if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                p = p->Flink;
                continue;
            }
            NbfReferenceAddressFile(addressFile);
            break;
        }

        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

        //
        // Now dereference the previous address file with
        // the lock released.
        //

        NbfDereferenceAddressFile (prevaddressFile);

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    }    // end of while loop

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    return status;                      // to dispatcher.
} /* NbfIndicateDatagram */


NTSTATUS
ProcessNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_QUERY frame.  There are two
    types of NAME_QUERY frames, with basically the same layout.  If the
    session number in the frame is 0, then the frame is really a request
    for information about the name, and not a request to establish a
    session.  If the session number is non-zero, then the frame is a
    connection request that we use to satisfy a listen.

    With the new version of TDI, we now indicate the user that a request
    for connection has been received, iff there is no outstanding listen.
    If this does occur, the user can return a connection that is to be used
    to accept the connection on.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_UI_FRAME RawFrame;
    PTP_CONNECTION Connection;
    PTP_LINK Link;
    UCHAR NameType;
    BOOLEAN ConnectIndicationBlocked = FALSE;
    PLIST_ENTRY p;
    UINT HeaderLength;
    PUCHAR GeneralSR;
    UINT GeneralSRLength;
    BOOLEAN UsedListeningConnection = FALSE;
    PTP_ADDRESS_FILE addressFile, prevaddressFile;
    PIRP acceptIrp;

    CONNECTION_CONTEXT connectionContext;
    TA_NETBIOS_ADDRESS RemoteAddress;

    //
    // If we are just registering or deregistering this address, then don't
    // allow state changes.  Just throw the packet away, and let the frame
    // distributor try the next address.
    //
    // Also drop it if the address is in conflict.
    //

    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameQuery %lx: address not stable [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_SUCCESS;
    }

    //
    // Process this differently depending on whether it is a find name
    // request or an incoming connection.
    //

    if (Header->Data2Low == 0) {

        //
        // This is a find-name request.  Respond with a NAME_RECOGNIZED frame.
        //
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameQuery %lx: find name [%.16s].\n", Address, Header->SourceName);
        }

        NbfSendNameRecognized(
            Address,
            0,                   // LSN 0 == FIND_NAME response
            Header,
            SourceAddress,
            SourceRouting,
            SourceRoutingLength);

        return STATUS_ABANDONED;        // don't allow multiple responses.

    } else { // (if Data2Low is non-zero)

        //
        // This is an incoming connection request.  If we have a listening
        // connection on this address, then continue with the connection setup.
        // If there is no outstanding listen, then indicate any kernel mode
        // clients that want to know about this frame. If a listen was posted,
        // then a connection has already been set up for it.  The LSN field of
        // the connection is set to 0, so we look for the first 0 LSN in the
        // database.
        //

        //
        // First, check if we already have an active connection with
        // this remote on this address. If so, we resend the NAME_RECOGNIZED
        // if we have not yet received the SESSION_INITIALIZE; otherwise
        // we ignore the frame.
        //

        //
        // If successful this adds a reference of type CREF_LISTENING.
        //

        if (Connection = NbfLookupRemoteName(Address, (PUCHAR)Header->SourceName, Header->Data2Low)) {

            //
            // We have an active connection on this guy, see if he
            // still appears to be waiting to a NAME_RECOGNIZED.
            //

            if (((Connection->Flags & CONNECTION_FLAGS_WAIT_SI) != 0) &&
                (Connection->Link != (PTP_LINK)NULL) &&
                (Connection->Link->State == LINK_STATE_ADM)) {

                //
                // Yes, he must have dropped a previous NAME_RECOGNIZED
                // so we send another one.
                //

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2("Dup NAME_QUERY found: %lx [%.16s]\n", Connection, Header->SourceName);
                }

                NbfSendNameRecognized(
                    Address,
                    Connection->Lsn,
                    Header,
                    SourceAddress,
                    SourceRouting,
                    SourceRoutingLength);

            } else {

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2("Dup NAME_QUERY ignored: %lx [%.16s]\n", Connection, Header->SourceName);
                }

            }

            NbfDereferenceConnection ("Lookup done", Connection, CREF_LISTENING);

            return STATUS_ABANDONED;

        }

        // If successful, this adds a reference which is removed before
        // this function returns.

        Connection = NbfLookupListeningConnection (Address, (PUCHAR)Header->SourceName);
        if (Connection == NULL) {

            //
            // not having a listening connection is not reason to bail out here.
            // we need to indicate to the user that a connect attempt occurred,
            // and see if there is a desire to use this connection. We
            // indicate in order to all address files that are
            // using this address.
            //
            // If we already have an indication pending on this address,
            // we ignore this frame (the NAME_QUERY may have come from
            // a different address, but we can't know that). Also, if
            // there is already an active connection on this remote
            // name, then we ignore the frame.
            //


            ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

            p = Address->AddressFileDatabase.Flink;
            while (p != &Address->AddressFileDatabase) {
                addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
                if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                    p = p->Flink;
                    continue;
                }
                NbfReferenceAddressFile(addressFile);
                break;
            }

            while (p != &Address->AddressFileDatabase) {

                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

                if ((addressFile->RegisteredConnectionHandler == TRUE) &&
                    (!addressFile->ConnectIndicationInProgress)) {


                    TdiBuildNetbiosAddress (
                        (PUCHAR)Header->SourceName,
                        FALSE,
                        &RemoteAddress);

                    addressFile->ConnectIndicationInProgress = TRUE;

                    //
                    // we have a connection handler, now indicate that a connection
                    // attempt occurred.
                    //

                    status = (addressFile->ConnectionHandler)(
                                 addressFile->ConnectionHandlerContext,
                                 sizeof (TA_NETBIOS_ADDRESS),
                                 &RemoteAddress,
                                 0,
                                 NULL,
                                 0,
                                 NULL,
                                 &connectionContext,
                                 &acceptIrp);

                    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                        //
                        // the user has connected a currently open connection, but
                        // we have to figure out which one it is.
                        //

                        //
                        // If successful this adds a reference of type LISTENING
                        // (the same what NbfLookupListeningConnection adds).
                        //

                        Connection = NbfLookupConnectionByContext (
                                        Address,
                                        connectionContext);

                        if (Connection == NULL) {

                            //
                            // We have to tell the client that
                            // his connection is bogus (or has this
                            // already happened??).
                            //

                            NbfPrint0("STATUS_MORE_PROCESSING, connection not found\n");
                            addressFile->ConnectIndicationInProgress = FALSE;
                            acceptIrp->IoStatus.Status = STATUS_INVALID_CONNECTION;
                            IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                            goto whileend;    // try next address file

                        } else {

                            if (Connection->AddressFile->Address != Address) {
                                addressFile->ConnectIndicationInProgress = FALSE;

                                NbfPrint0("STATUS_MORE_PROCESSING, address wrong\n");
                                NbfStopConnection (Connection, STATUS_INVALID_ADDRESS);
                                NbfDereferenceConnection("Bad Address", Connection, CREF_LISTENING);
                                Connection = NULL;
                                acceptIrp->IoStatus.Status = STATUS_INVALID_ADDRESS;
                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                goto whileend;    // try next address file
                            }

                            //
                            // OK, we have a valid connection. If the response to
                            // this connection was disconnect, we need to reject
                            // the connection request and return. If it was accept
                            // or not specified (to be done later), we simply
                            // fall through and continue processing on the U Frame.
                            //
                            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                            if ((Connection->Flags2 & CONNECTION_FLAGS2_DISCONNECT) != 0) {

//                                Connection->Flags2 &= ~CONNECTION_FLAGS2_DISCONNECT;
                                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                                NbfPrint0("STATUS_MORE_PROCESSING, disconnect\n");
                                addressFile->ConnectIndicationInProgress = FALSE;
                                NbfDereferenceConnection("Disconnecting", Connection, CREF_LISTENING);
                                Connection = NULL;
                                acceptIrp->IoStatus.Status = STATUS_INVALID_CONNECTION;
                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                goto whileend;    // try next address file
                            }

                        }

                        //
                        // Make a note that we have to set
                        // addressFile->ConnectIndicationInProgress to
                        // FALSE once the address is safely stored
                        // in the connection.
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint4 ("ProcessNameQuery %lx: indicate DONE, context %lx conn %lx [%.16s].\n", Address, connectionContext, Connection, Header->SourceName);
                        }
                        IF_NBFDBG (NBF_DEBUG_SETUP) {
                            NbfPrint6 ("Link is %x-%x-%x-%x-%x-%x\n",
                                        SourceAddress->Address[0],
                                        SourceAddress->Address[1],
                                        SourceAddress->Address[2],
                                        SourceAddress->Address[3],
                                        SourceAddress->Address[4],
                                        SourceAddress->Address[5]);
                        }

                        //
                        // Set up our flags...we turn on REQ_COMPLETED
                        // so that disconnect will be indicated if the
                        // connection goes down before a session init
                        // is received.
                        //

                        Connection->Flags2 &= ~CONNECTION_FLAGS2_STOPPING;
                        Connection->Status = STATUS_PENDING;
                        Connection->Flags2 |= (CONNECTION_FLAGS2_ACCEPTED |
                                               CONNECTION_FLAGS2_REQ_COMPLETED);
                        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                        ConnectIndicationBlocked = TRUE;
                        NbfDereferenceAddressFile (addressFile);
                        acceptIrp->IoStatus.Status = STATUS_SUCCESS;
                        IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);
                        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);
                        break;    // exit the while

#if 0
                    } else if (status == STATUS_EVENT_PENDING) {

                        //
                        // user has returned a connectionContext, use that for further
                        // processing of the connection. First validate it so
                        // we can know we won't just start a connection and never
                        // finish.
                        //
                        //
                        // If successful this adds a reference of type LISTENING
                        // (the same what NbfLookupListeningConnection adds).
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint3 ("ProcessNameQuery %lx: indicate PENDING, context %lx [%.16s].\n", Address, connectionContext, Header->SourceName);
                        }


                        Connection = NbfLookupConnectionByContext (
                                        Address,
                                        connectionContext);

                        if (Connection == NULL) {

                            //
                            // We have to tell the client that
                            // his connection is bogus (or has this
                            // already happened??).
                            //

                            NbfPrint0("STATUS_MORE_PROCESSING, but connection not found\n");
                            addressFile->ConnectIndicationInProgress = FALSE;

                            goto whileend;    // try next address file.

                        } else {

                            if (Connection->AddressFile->Address != Address) {
                                addressFile->ConnectIndicationInProgress = FALSE;
                                NbfStopConnection (Connection, STATUS_INVALID_ADDRESS);
                                NbfDereferenceConnection("Bad Address", Connection, CREF_LISTENING);
                                Connection = NULL;

                                goto whileend;    // try next address file.
                            }

                        }

                        //
                        // Make a note that we have to set
                        // addressFile->ConnectionIndicatInProgress to
                        // FALSE once the address is safely stored
                        // in the connection.
                        //

                        ConnectIndicationBlocked = TRUE;
                        NbfDereferenceAddressFile (addressFile);
                        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);
                        break;    // exit the while
#endif

                    } else if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        //
                        // we know the address, but can't create a connection to
                        // use on it. This gets passed to the network as a response
                        // saying I'm here, but can't help.
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint2 ("ProcessNameQuery %lx: indicate RESOURCES [%.16s].\n", Address, Header->SourceName);
                        }

                        addressFile->ConnectIndicationInProgress = FALSE;

                        //
                        // We should send a NR with LSN 0xff, indicating
                        // no resources, but LM 2.0 does not interpret
                        // that correctly. So, we send LSN 0 (no listens)
                        // instead.
                        //

                        NbfSendNameRecognized(
                            Address,
                            0,
                            Header,
                            SourceAddress,
                            SourceRouting,
                            SourceRoutingLength);

                        NbfDereferenceAddressFile (addressFile);
                        return STATUS_ABANDONED;

                    } else {

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint2 ("ProcessNameQuery %lx: indicate invalid [%.16s].\n", Address, Header->SourceName);
                        }

                        addressFile->ConnectIndicationInProgress = FALSE;

                        goto whileend;    // try next address file

                    } // end status ifs

                } else {

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint2 ("ProcessNameQuery %lx: no handler [%.16s].\n", Address, Header->SourceName);
                    }

                    goto whileend;     // try next address file

                } // end no indication handler

whileend:
                //
                // Jumping here is like a continue, except that the
                // addressFile pointer is advanced correctly.
                //

                //
                // Save this to dereference it later.
                //

                prevaddressFile = addressFile;

                //
                // Reference the next address file on the list, so it
                // stays around.
                //

                ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

                p = p->Flink;
                while (p != &Address->AddressFileDatabase) {
                    addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
                    if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                        p = p->Flink;
                        continue;
                    }
                    NbfReferenceAddressFile(addressFile);
                    break;
                }

                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

                //
                // Now dereference the previous address file with
                // the lock released.
                //

                NbfDereferenceAddressFile (prevaddressFile);

                ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

            } // end of loop through the address files.

            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            if (Connection == NULL) {

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2 ("ProcessNameQuery %lx: no connection [%.16s].\n", Address, Header->SourceName);
                }

                //
                // We still did not find a connection after looping
                // through the address files.
                //

                NbfSendNameRecognized(
                    Address,
                    0,                   // LSN 0 == No listens
                    Header,
                    SourceAddress,
                    SourceRouting,
                    SourceRoutingLength);

                //
                // We used to return MORE_PROCESSING_REQUIRED, but
                // since we matched with this address, no other
                // address is going to match, so abandon it.
                //

                return STATUS_ABANDONED;

            }

        } else { // end connection == null

            UsedListeningConnection = TRUE;

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameQuery %lx: found listen %lx: [%.16s].\n", Address, Connection, Header->SourceName);
            }

        }


        //
        // At this point the connection has a reference of type
        // CREF_LISTENING. Allocate a UI frame from the pool.
        //

        status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
        if (!NT_SUCCESS (status)) {                // no resources to respond.
            PANIC ("ProcessNameQuery: Can't get UI Frame, dropping query\n");
            if (ConnectIndicationBlocked) {
                addressFile->ConnectIndicationInProgress = FALSE;
            }
            if (UsedListeningConnection) {
                Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;
            } else {
                Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;
                NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
            }
            NbfDereferenceConnection("Can't get UI Frame", Connection, CREF_LISTENING);
            return STATUS_ABANDONED;
        }

        //
        // Build the MAC header. NAME_RECOGNIZED frames go out as
        // general-route source routing.
        //

        MacReturnGeneralRouteSR(
            &DeviceContext->MacInfo,
            &GeneralSR,
            &GeneralSRLength);


        MacConstructHeader (
            &DeviceContext->MacInfo,
            RawFrame->Header,
            SourceAddress->Address,
            DeviceContext->LocalAddress.Address,
            sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
            GeneralSR,
            GeneralSRLength,
            &HeaderLength);


        //
        // Build the DLC UI frame header.
        //

        NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
        HeaderLength += sizeof(DLC_FRAME);


        //
        // Before we continue, store the remote guy's transport address
        // into the TdiListen's TRANSPORT_CONNECTION buffer.  This allows
        // the client to determine who called him.
        //

        Connection->CalledAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        TdiCopyLookaheadData(
            Connection->CalledAddress.NetbiosName,
            Header->SourceName,
            16,
            DeviceContext->MacInfo.CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

        RtlCopyMemory( Connection->RemoteName, Connection->CalledAddress.NetbiosName, 16 );
        Connection->Flags2 |= CONNECTION_FLAGS2_REMOTE_VALID;

        if (ConnectIndicationBlocked) {
            addressFile->ConnectIndicationInProgress = FALSE;
        }

        //
        // Now formulate a reply.
        //

        NameType = (UCHAR)((Address->Flags & ADDRESS_FLAGS_GROUP) ?
                            NETBIOS_NAME_TYPE_GROUP : NETBIOS_NAME_TYPE_UNIQUE);

        //
        // We have a listening connection on the address now. Create a link
        // for it to be associated with and make that link ready. Respond to
        // the sender with a name_recognized frame.  then we will receive our
        // first connection-oriented frame, SESSION_INITIALIZE, handled
        // in IFRAMES.C.  Then we respond with SESSION_CONFIRM, and then
        // the TdiListen completes.
        //

        // If successful, this adds a link reference which is removed
        // in NbfDisconnectFromLink. It does NOT add a link reference.

        status = NbfCreateLink (
                     DeviceContext,
                     SourceAddress,         // remote hardware address.
                     SourceRouting,
                     SourceRoutingLength,
                     LISTENER_LINK,         // for loopback link
                     &Link);                // resulting link.

        if (NT_SUCCESS (status)) {             // link established.

            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            // If successful, this adds a connection reference
            // which is removed in NbfDisconnectFromLink

            if (((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) &&
                ((status = NbfConnectToLink (Link, Connection)) == STATUS_SUCCESS)) {

                Connection->Flags |= CONNECTION_FLAGS_WAIT_SI; // wait for SI.
                Connection->Retries = 1;
                Connection->Rsn = Header->Data2Low; // save remote LSN.
                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                NbfWaitLink (Link);          // start link going.

                ConstructNameRecognized (   // build a good response.
                    (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
                    NameType,               // type of local name.
                    Connection->Lsn,        // return our LSN.
                    RESPONSE_CORR(Header),  // new xmit corr.
                    0,                      // our response correlator (unused).
                    Header->DestinationName,// our NetBIOS name.
                    Header->SourceName);    // his NetBIOS name.


                HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);
                NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

                //
                // Now, to avoid problems with hanging listens, we'll start the
                // connection timer and give a limited period for the connection
                // to succeed. This avoids waiting forever for those first few
                // frames to be exchanged. When the timeout occurs, the
                // the dereference will cause the circuit to be torn down.
                //
                // The maximum delay we can accomodate on a link is
                // NameQueryRetries * NameQueryTimeout (assuming the
                // remote has the same timeous). There are three
                // exchanges of packets until the SESSION_INITIALIZE
                // shows up, to be safe we multiply by four.
                //

                NbfStartConnectionTimer(
                    Connection,
                    NbfListenTimeout,
                    4 * DeviceContext->NameQueryRetries * DeviceContext->NameQueryTimeout);

                NbfSendUIFrame (
                    DeviceContext,
                    RawFrame,
                    TRUE);            // loopback if needed.

                IF_NBFDBG (NBF_DEBUG_SETUP) {
                    NbfPrint2("Connection %lx on link %lx\n", Connection, Link);
                }

                NbfDereferenceConnection("ProcessNameQuery", Connection, CREF_LISTENING);
                return STATUS_ABANDONED;    // successful!
            }

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            //
            // We don't have a free LSN to allocate, so fall through to
            // report "no resources".
            //

            // We did a link reference since NbfCreateLink succeeded,
            // but since NbfConnectToLink failed we will never remove
            // that reference in NbfDisconnectFromLink, so do it here.

            NbfDereferenceLink ("No more LSNS", Link, LREF_CONNECTION);

            ASSERT (Connection->Lsn == 0);

        }

        //
        // If we fall through here, then we couldn't get resources to set
        // up this connection, so just send him a "no resources" reply.
        //

        if (UsedListeningConnection) {

            Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;   // put this back.

        } else {

            Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;
            NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);

        }

        //
        // We should send a NR with LSN 0xff, indicating
        // no resources, but LM 2.0 does not interpret
        // that correctly. So, we send LSN 0 (no listens)
        // instead.
        //

        ConstructNameRecognized (
            (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
            NameType,
            0,                                  // LSN=0 means no listens
            RESPONSE_CORR(Header),
            0,
            Header->DestinationName,            // our NetBIOS name.
            Header->SourceName);                // his NetBIOS name.

        HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);
        NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

        NbfSendUIFrame (
            DeviceContext,
            RawFrame,
            TRUE);                        // loopback if needed.

        NbfDereferenceConnection("ProcessNameQuery done", Connection, CREF_LISTENING);
    }

    return STATUS_ABANDONED;

} /* ProcessNameQuery */


NTSTATUS
ProcessAddNameResponse(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_NAME_RESPONSE frame.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    BOOLEAN SendNameInConflict = FALSE;
    UNREFERENCED_PARAMETER(DeviceContext);

    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    //
    // If we aren't trying to register this address, then the sender of
    // this frame is bogus.  We cannot allow our state to change based
    // on the reception of a random frame.
    //

    if (!(Address->Flags & ADDRESS_FLAGS_REGISTERING)) {
        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);
        IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_UFRAMES) {
            NbfPrint2("ProcessAddNameResponse %lx: not registering [%.16s]\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;        // just destroy the packet.
    }

    //
    // Unfortunately, we are registering this address and another host
    // on the network is also attempting to register the same NetBIOS
    // name on the same network.  Because he got to us first, we cannot
    // register our name.  Thus, the address must die. We set this flag
    // and on the next timeout we will shut down.
    //

    Address->Flags |= ADDRESS_FLAGS_DUPLICATE_NAME;

    if (Header->Data2Low == NETBIOS_NAME_TYPE_UNIQUE) {

        //
        // If we have already gotten a response from someone saying
        // this address is uniquely owned, then make sure any future
        // responses come from the same MAC address.
        //

        if ((*((LONG UNALIGNED *)Address->UniqueResponseAddress) == 0) &&
            (*((SHORT UNALIGNED *)(&Address->UniqueResponseAddress[4])) == 0)) {

            RtlMoveMemory(Address->UniqueResponseAddress, SourceAddress->Address, 6);

        } else if (!RtlEqualMemory(
                       Address->UniqueResponseAddress,
                       SourceAddress->Address,
                       6)) {

            if (!Address->NameInConflictSent) {
                SendNameInConflict = TRUE;
            }

        }

    } else {

        //
        // For group names, make sure nobody else decided that it was
        // a unique address.
        //

        if ((*((LONG UNALIGNED *)Address->UniqueResponseAddress) != 0) ||
            (*((SHORT UNALIGNED *)(&Address->UniqueResponseAddress[4])) != 0)) {

            if (!Address->NameInConflictSent) {
                SendNameInConflict = TRUE;
            }

        }

    }

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    if (SendNameInConflict) {

        Address->NameInConflictSent = TRUE;
        NbfSendNameInConflict(
            Address,
            (PUCHAR)Header->DestinationName);

    }


    IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_UFRAMES) {
        NbfPrint2("ProcessAddNameResponse %lx: stopping [%.16s]\n", Address, Header->SourceName);
    }

    return STATUS_ABANDONED;            // done with this frame.
} /* ProcessAddNameResponse */


NTSTATUS
ProcessNameRecognized(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_RECOGNIZED frame.  This frame
    is received because we issued a NAME_QUERY frame to actively initiate
    a connection with a remote host.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION Connection;
    PTP_LINK Link;
    BOOLEAN TimerCancelled;


    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameRecognized %lx: address not stable [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;        // invalid address state, drop packet.
    }

    //
    // Find names and connections both require a TP_CONNECTION to work.
    // In either case, the ConnectionId field of the TP_CONNECTION object
    // was sent as the response correlator in the NAME_QUERY frame, so
    // we should get the same correlator back in this frame in the
    // transmit correlator.  Because this number is unique across
    // all the connections on an address, we can determine if the frame
    // was for this address or not.
    //

    // this causes a reference which is removed before this function returns.

    Connection = NbfLookupConnectionById (
                    Address,
                    TRANSMIT_CORR(Header));

    //
    // has he been deleted while we were waiting?
    //

    if (Connection == NULL) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameRecognized %lx: no connection [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;
    }

    //
    // This frame is a response to a NAME_QUERY frame that we previously
    // sent to him.  Either he's returning "insufficient resources",
    // indicating that a session cannot be established, or he's initiated
    // his side of the connection.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {

        //
        // Connection is stopping, don't process this.
        //

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint3 ("ProcessNameRecognized %lx: connection %lx stopping [%.16s].\n", Address, Connection, Header->SourceName);
        }

        NbfDereferenceConnection("Name Recognized, stopping", Connection, CREF_BY_ID);

        return STATUS_ABANDONED;
    }

    if (Header->Data2Low == 0x00 ||
        (Header->Data2Low > 0x00 && (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR_FN))) {     // no listens, or FIND.NAME response.

        if (!(Connection->Flags2 & CONNECTION_FLAGS2_CONNECTOR)) {

            //
            // This is just a find name request, we are not trying to
            // establish a connection.  Currently, there is no reason
            // for this to occur, so just save some room to add this
            // extra feature later to support NETBIOS find name.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx not connector [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection("Unexpected FN Response", Connection, CREF_BY_ID);
            return STATUS_ABANDONED;            // we processed the frame.
        }

        //
        // We're setting up a session.  If we are waiting for the first NAME
        // RECOGNIZED, then setup the link and send the second NAME_QUERY.
        // If we're waiting for the second NAME_RECOGNIZED, then he didn't
        // have an LSN to finish the connection, so tear it down.
        //

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR_FN) {

            //
            // Now that we know the data link address of the remote host
            // we're connecting to, we need to create a TP_LINK object to
            // represent the data link between these two machines.  If there
            // is already a data link there, then the object will be reused.
            //

            Connection->Flags2 &= ~CONNECTION_FLAGS2_WAIT_NR_FN;

            if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                //
                // The Netbios address we are connecting to is a
                // unique name

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint3 ("ProcessNameRecognized %lx: connection %lx send 2nd NQ [%.16s].\n", Address, Connection, Header->SourceName);
                }


                // If successful, this adds a link reference which is removed
                // in NbfDisconnectFromLink

                status = NbfCreateLink (
                             DeviceContext,
                             SourceAddress,         // remote hardware address.
                             SourceRouting,
                             SourceRoutingLength,
                             CONNECTOR_LINK,        // for loopback link
                             &Link);                // resulting link.

                if (!NT_SUCCESS (status)) {            // no resources.
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("No Resources for link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                // If successful, this adds a connection reference which is
                // removed in NbfDisconnectFromLink. It does NOT add a link ref.

                if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
                    ((status = NbfConnectToLink (Link, Connection)) != STATUS_SUCCESS)) {

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    // Connection stopping or no LSN's available on this link.
                    // We did a link reference since NbfCreateLink succeeded,
                    // but since NbfConnectToLink failed we will never remove
                    // that reference in NbfDisconnectFromLink, so do it here.

                    NbfDereferenceLink ("Can't connect to link", Link, LREF_CONNECTION);       // most likely destroys this.

                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("Cant connect to link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                (VOID)InterlockedIncrement(&Link->NumberOfConnectors);

            } else {

                //
                // We are connecting to a group name; we have to
                // assign an LSN now, but we don't connect to
                // the link until we get a committed name response.
                //

                Connection->Flags2 |= CONNECTION_FLAGS2_GROUP_LSN;

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint3 ("ProcessNameRecognized %lx: connection %lx send 2nd NQ GROUP [%.16s].\n", Address, Connection, Header->SourceName);
                }

                if (NbfAssignGroupLsn(Connection) != STATUS_SUCCESS) {

                    //
                    // Could not find an empty LSN; have to fail.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection("Can't get group LSN", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;

                }

            }


            //
            // Send the second NAME_QUERY frame, committing our LSN to
            // the remote guy.
            //

            Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NR;
            Connection->Retries = (USHORT)DeviceContext->NameQueryRetries;
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            NbfStartConnectionTimer (
                Connection,
                ConnectionEstablishmentTimeout,
                DeviceContext->NameQueryTimeout);

            KeQueryTickCount (&Connection->ConnectStartTime);

            NbfSendNameQuery(
                Connection,
                TRUE);

            NbfDereferenceConnection ("Done with lookup", Connection, CREF_BY_ID); // release lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        } else if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            if (Connection->Link) {

                if (RtlEqualMemory(
                        Connection->Link->HardwareAddress.Address,
                        SourceAddress->Address,
                        6)) {

                    //
                    // Unfortunately, he's telling us that he doesn't have resources
                    // to allocate an LSN. We set a flag to record this and
                    // ignore the frame.
                    //

                    Connection->Flags2 |= CONNECTION_FLAGS2_NO_LISTEN;
                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint3 ("ProcessNameRecognized %lx: connection %lx no listens [%.16s].\n", Address, Connection, Header->SourceName);
                    }

                } else {

                    //
                    // This response comes from a different remote from the
                    // last one. For unique names this indicates a duplicate
                    // name on the network.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                        if (!Address->NameInConflictSent) {

                            Address->NameInConflictSent = TRUE;
                            NbfSendNameInConflict(
                                Address,
                                (PUCHAR)Header->SourceName);

                        }
                    }

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint3 ("ProcessNameRecognized %lx: connection %lx name in conflict [%.16s].\n", Address, Connection, Header->SourceName);
                    }

                }

            } else {

                //
                // The response came back so fast the connection is
                // not stable, ignore it.
                //

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            NbfDereferenceConnection ("No remote resources", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        } else {

            //
            // Strange state.  This should never happen, because we should be
            // either waiting for a first or second name recognized frame.  It
            // is possible that the remote station received two frames because
            // of our retransmits, and so he responded to both.  Toss the frame.
            //

            if (Connection->Link) {

                if (!RtlEqualMemory(
                        Connection->Link->HardwareAddress.Address,
                        SourceAddress->Address,
                        6)) {

                    //
                    // This response comes from a different remote from the
                    // last one. For unique names this indicates a duplicate
                    // name on the network.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                        if (!Address->NameInConflictSent) {

                            Address->NameInConflictSent = TRUE;
                            NbfSendNameInConflict(
                                Address,
                                (PUCHAR)Header->SourceName);

                        }

                    }

                } else {

                    //
                    // This is the same remote, just ignore it.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                }

            } else {

                //
                // The response came back so fast the connection is
                // not stable, ignore it.
                //

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }

    } else if (Header->Data2Low == 0xff) { // no resources to complete connection.

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            //
            // The recipient of our previously-sent NAME_QUERY frame that we sent
            // to actively establish a connection has unfortunately run out of
            // resources and cannot setup his side of the connection.  We have to
            // report "no resources" on the TdiConnect.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx no resources [%.16s].\n", Address, Connection, Header->SourceName);
            }

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint0 ("ProcessNameRecognized:  No resources.\n");
            }

            NbfStopConnection (Connection, STATUS_REMOTE_RESOURCES);
            NbfDereferenceConnection ("No Resources", Connection, CREF_BY_ID);   // release our lookup hold.
            return STATUS_ABANDONED;                // we processed the frame.

        } else {

            //
            // We don't have a committed NAME_QUERY out there, so
            // we ignore this frame.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected no resources [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }

    } else {    // Data2Low is in the range 0x01-0xfe

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            //
            // This is a successful response to a second NAME_QUERY we sent when
            // we started processing a TdiConnect request.  Clear the "waiting
            // for Name Recognized" bit in the connection flags so that the
            // connection timer doesn't blow us away when it times out.
            //
            //         What prevents the timeout routine from running while
            //         we're in here and destroying the connection/link by
            //         calling NbfStopConnection?
            //

            Connection->Flags2 &= ~CONNECTION_FLAGS2_WAIT_NR;

            //
            // Before we continue, store the remote guy's transport address
            // into the TdiConnect's TRANSPORT_CONNECTION buffer.  This allows
            // the client to determine who responded to his TdiConnect.
            //
            // this used to be done prior to sending the second
            // Name Query, but since I fixed the Buffer2 problem, meaning
            // that I really do overwrite the input buffer with the
            // output buffer, that was screwing up the second query.
            // Note that doing the copy after sending is probably unsafe
            // in the case where the second Name Recognized arrives
            // right away.
            //

            Connection->CalledAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            TdiCopyLookaheadData(
                Connection->CalledAddress.NetbiosName,
                Header->SourceName,
                16,
                DeviceContext->MacInfo.CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

            RtlCopyMemory( Connection->RemoteName, Header->SourceName, 16 );

            Connection->Rsn = Header->Data2Low;     // save his remote LSN.

            //
            // Save the correlator from the NR for eventual use in the
            // SESSION_INITIALIZE frame.
            //

            Connection->NetbiosHeader.TransmitCorrelator = RESPONSE_CORR(Header);

            //
            // Cancel the timer; it would have no effect since WAIT_NR
            // is not set, but there is no need for it to run. We cancel
            // it with the lock held so it won't interfere with the
            // timer's use when a connection is closing.
            //

            TimerCancelled = KeCancelTimer (&Connection->Timer);

            if ((Connection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) != 0) {

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                //
                // The Netbios address we are connecting to is a
                // group name; we need to connect to the link
                // now that we have the committed session.
                //

                // If successful, this adds a link reference which is removed
                // in NbfDisconnectFromLink

                status = NbfCreateLink (
                             DeviceContext,
                             SourceAddress,         // remote hardware address.
                             SourceRouting,
                             SourceRoutingLength,
                             CONNECTOR_LINK,        // for loopback link
                             &Link);                // resulting link.

                if (!NT_SUCCESS (status)) {            // no resources.
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("No Resources for link", Connection, CREF_BY_ID);

                    if (TimerCancelled) {
                        NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
                    }

                    return STATUS_ABANDONED;
                }

                ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                // If successful, this adds a connection reference which is
                // removed in NbfDisconnectFromLink. It does NOT add a link ref.

                if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
                    ((status = NbfConnectToLink (Link, Connection)) != STATUS_SUCCESS)) {

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (TimerCancelled) {
                        NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
                    }

                    // Connection stopping or no LSN's available on this link.
                    // We did a link reference since NbfCreateLink succeeded,
                    // but since NbfConnectToLink failed we will never remove
                    // that reference in NbfDisconnectFromLink, so do it here.

                    NbfDereferenceLink ("Can't connect to link", Link, LREF_CONNECTION);       // most likely destroys this.

                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("Cant connect to link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                (VOID)InterlockedIncrement(&Link->NumberOfConnectors);

            } else {

                //
                // It's to a unique address, we set up the link
                // before we sent out the committed NAME_QUERY.
                //

                Link = Connection->Link;

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx session up! [%.16s].\n", Address, Connection, Header->SourceName);
            }

            //
            // When we sent the committed NAME_QUERY, we stored that
            // time in Connection->ConnectStartTime; we can now use
            // that for a rough estimate of the link delay, if this
            // is the first connection on the link. For async lines
            // we do not do this because the delay introduced by the
            // gateway messes up the timing.
            //

            if (!DeviceContext->MacInfo.MediumAsync) {

                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

                if (Link->State == LINK_STATE_ADM) {

                    //
                    // HACK: Set the necessary variables in the link
                    // so that FakeUpdateBaseT1Timeout works. These
                    // variables are the same ones that FakeStartT1 sets.
                    //

                    Link->CurrentPollSize = Link->HeaderLength + sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS);
                    Link->CurrentTimerStart = Connection->ConnectStartTime;
                    FakeUpdateBaseT1Timeout (Link);

                }

                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            }

            if (TimerCancelled) {
                NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
            }

            NbfActivateLink (Connection->Link);      // start link going.

            //
            // We'll get control again in LINK.C when the data link has either
            // been established, denied, or destroyed.  This happens at I/O
            // completion time from NbfCreateLink's PdiConnect request.
            //

        } else {

            //
            // We don't have a committed NAME_QUERY out there, so
            // we ignore this frame.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected session up! [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }


    }

    NbfDereferenceConnection("ProcessNameRecognized lookup", Connection, CREF_BY_ID);
    return STATUS_ABANDONED;            // don't distribute packet.
} /* ProcessNameRecognized */


NTSTATUS
NbfProcessUi(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR Header,
    IN PUCHAR DlcHeader,
    IN ULONG DlcLength,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    OUT PTP_ADDRESS * DatagramAddress
    )

/*++

Routine Description:

    This routine receives control from the data link provider as an
    indication that a DLC UI-frame has been received on the data link.
    Here we dispatch to the correct UI-frame handler.

    Part of this routine's job is to optionally distribute the frame to
    every address that needs to look at it.
    We accomplish this by lock-stepping through the address database,
    and for each address that matches the address this frame is aimed at,
    calling the frame handler.

Arguments:

    DeviceContext - Pointer to our device context.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    Header - Points to the MAC header of the incoming packet.

    DlcHeader - Points to the DLC header of the incoming packet.

    DlcLength - Actual length in bytes of the packet, starting at the
        DlcHeader.

    SourceRouting - Source routing information in the MAC header.

    SourceRoutingLength - The length of SourceRouting.

    DatagramAddress - If this function returns STATUS_MORE_PROCESSING_
        REQUIRED, this will be the address the datagram should be
        indicated to.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_ADDRESS Address;
    PNBF_HDR_CONNECTIONLESS UiFrame;
    NTSTATUS status;
    PLIST_ENTRY Flink;
    UCHAR MatchType;
    BOOLEAN MatchedAddress;
    PUCHAR MatchName;
    ULONG NetbiosLength = DlcLength - 3;

    UiFrame = (PNBF_HDR_CONNECTIONLESS)(DlcHeader + 3);

    //
    // Verify that this frame is long enough to examine and that it
    // has the proper signature.  We can't test the signature as a
    // 16-bit word as specified in the NetBIOS Formats and Protocols
    // manual because this is processor-dependent.
    //

    if ((NetbiosLength < sizeof (NBF_HDR_CONNECTIONLESS)) ||
        (HEADER_LENGTH(UiFrame) != sizeof (NBF_HDR_CONNECTIONLESS)) ||
        (HEADER_SIGNATURE(UiFrame) != NETBIOS_SIGNATURE)) {

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint0 ("NbfProcessUi: Bad size or NetBIOS signature.\n");
        }
        return STATUS_ABANDONED;        // frame too small or too large.
    }

    //
    // If this frame has a correlator with the high bit on, it was due
    // to a FIND.NAME request; we don't handle those here since they
    // are not per-address.
    //

    if ((UiFrame->Command == NBF_CMD_NAME_RECOGNIZED) &&
        (TRANSMIT_CORR(UiFrame) & 0x8000)) {

        //
        // Make sure the frame is sent to our reserved address;
        // if not, drop it.
        //

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return NbfProcessQueryNameRecognized(
                       DeviceContext,
                       Header,
                       UiFrame);
        } else {

            return STATUS_ABANDONED;

        }
    }

    //
    // If this is a STATUS_RESPONSE, process that separately.
    //

    if (UiFrame->Command == NBF_CMD_STATUS_RESPONSE) {

        //
        // Make sure the frame is sent to our reserved address;
        // if not, drop it.
        //

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return STATUS_MORE_PROCESSING_REQUIRED;

        } else {

            return STATUS_ABANDONED;

        }
    }

    //
    // If this is a STATUS_QUERY, check if it is to our reserved
    // address. If so, we process it. If not, we fall through to
    // the normal checking. This ensures that queries to our
    // reserved address are always processed, even if nobody
    // has opened that address yet.
    //

    if (UiFrame->Command == NBF_CMD_STATUS_QUERY) {

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return NbfProcessStatusQuery(
                       DeviceContext,
                       NULL,
                       UiFrame,
                       SourceAddress,
                       SourceRouting,
                       SourceRoutingLength);

        }

    }

    //
    // We have a valid connectionless NetBIOS protocol frame that's not a
    // datagram, so deliver it to every address which matches the destination
    // name in the frame.  Some frames
    // (NAME_QUERY) cannot be delivered to multiple recipients.  Therefore,
    // if a frame handler returns STATUS_MORE_PROCESSING_REQUIRED, we continue
    // through the remaining addresses. Otherwise simply get out and assume
    // that the frame was eaten.  Thus, STATUS_SUCCESS means that the handler
    // ate the frame and that no other addresses can have it.
    //

    //
    // Determine what kind of lookup we want to do.
    //

    switch (UiFrame->Command) {

    case NBF_CMD_NAME_QUERY:
    case NBF_CMD_DATAGRAM:
    case NBF_CMD_DATAGRAM_BROADCAST:
    case NBF_CMD_ADD_NAME_QUERY:
    case NBF_CMD_STATUS_QUERY:
    case NBF_CMD_ADD_NAME_RESPONSE:
    case NBF_CMD_NAME_RECOGNIZED:

        MatchType = NETBIOS_NAME_TYPE_EITHER;
        break;

    case NBF_CMD_ADD_GROUP_NAME_QUERY:
    case NBF_CMD_NAME_IN_CONFLICT:

        MatchType = NETBIOS_NAME_TYPE_UNIQUE;
        break;

    default:
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("NbfProcessUi: Frame delivered; Unrecognized command %x.\n",
                UiFrame->Command);
        }
        return STATUS_SUCCESS;
        break;

    }

    if ((UiFrame->Command == NBF_CMD_ADD_GROUP_NAME_QUERY) ||
        (UiFrame->Command == NBF_CMD_ADD_NAME_QUERY)) {

        MatchName = (PUCHAR)UiFrame->SourceName;

    } else if (UiFrame->Command == NBF_CMD_DATAGRAM_BROADCAST) {

        MatchName = NULL;

    } else {

        MatchName = (PUCHAR)UiFrame->DestinationName;

    }

    if (MatchName && DeviceContext->AddressCounts[MatchName[0]] == 0) {
        status = STATUS_ABANDONED;
        goto RasIndication;
    }


    MatchedAddress = FALSE;

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    for (Flink = DeviceContext->AddressDatabase.Flink;
         Flink != &DeviceContext->AddressDatabase;
         Flink = Flink->Flink) {

        Address = CONTAINING_RECORD (
                    Flink,
                    TP_ADDRESS,
                    Linkage);

        if ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        if (NbfMatchNetbiosAddress (Address,
                                    MatchType,
                                    MatchName)) {

            NbfReferenceAddress ("UI Frame", Address, AREF_PROCESS_UI);   // prevent address from being destroyed.
            MatchedAddress = TRUE;
            break;

        }
    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    if (MatchedAddress) {

        //
        // If the datagram's destination name does not match the address's
        // network name and TSAP components, then skip this address.  Some
        // frames have the source and destination names backwards for this
        // algorithm, so we account for that here.  Also, broadcast datagrams
        // have no destination name in the frame, but get delivered to every
        // address anyway.
        //

#if 0
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            USHORT i;
            NbfPrint0 ("NbfProcessUi: SourceName: ");
            for (i=0;i<16;i++) {
                NbfPrint1 ("%c",UiFrame->SourceName[i]);
            }
            NbfPrint0 (" Destination Name:");
            for (i=0;i<16;i++) {
                NbfPrint1 ("%c",UiFrame->DestinationName[i]);
            }
            NbfPrint0 ("\n");
        }
#endif

        //
        // Deliver the frame to the current address.
        //

        switch (UiFrame->Command) {

        case NBF_CMD_NAME_QUERY:

            status = ProcessNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_DATAGRAM:
        case NBF_CMD_DATAGRAM_BROADCAST:

            //
            // Reference the datagram so it sticks around until the
            // ReceiveComplete, when it is processed.
            //

            if ((Address->Flags & ADDRESS_FLAGS_CONFLICT) == 0) {
                NbfReferenceAddress ("Datagram indicated", Address, AREF_PROCESS_DATAGRAM);
                *DatagramAddress = Address;
                status = STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                status = STATUS_ABANDONED;
            }
            break;

        case NBF_CMD_ADD_GROUP_NAME_QUERY:

            //
            // did this frame originate with us? If so, we don't want to
            // do any processing of it.
            //

            if (RtlEqualMemory (
                    SourceAddress,
                    DeviceContext->LocalAddress.Address,
                    DeviceContext->MacInfo.AddressLength)) {

                if ((Address->Flags & ADDRESS_FLAGS_REGISTERING) != 0) {
                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint0 ("NbfProcessUI: loopback AddGroupNameQuery dropped\n");
                    }
                    status = STATUS_ABANDONED;
                    break;
                }
            }

            status = ProcessAddGroupNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);
            break;

        case NBF_CMD_ADD_NAME_QUERY:

            //
            // did this frame originate with us? If so, we don't want to
            // do any processing of it.
            //

            if (RtlEqualMemory (
                    SourceAddress,
                    DeviceContext->LocalAddress.Address,
                    DeviceContext->MacInfo.AddressLength)) {

                if ((Address->Flags & ADDRESS_FLAGS_REGISTERING) != 0) {
                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint0 ("NbfProcessUI: loopback AddNameQuery dropped\n");
                    }
                    status = STATUS_ABANDONED;
                    break;
                }
            }

            status = ProcessAddNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);
            break;

        case NBF_CMD_NAME_IN_CONFLICT:

            status = ProcessNameInConflict (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_STATUS_QUERY:

            status = NbfProcessStatusQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_ADD_NAME_RESPONSE:

            status = ProcessAddNameResponse (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_NAME_RECOGNIZED:

            status = ProcessNameRecognized (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        default:

            ASSERT(FALSE);

        } /* switch on NetBIOS frame command code */

        NbfDereferenceAddress ("Done", Address, AREF_PROCESS_UI);     // done with previous address.

    } else {

        status = STATUS_ABANDONED;

    }


RasIndication:;

    //
    // Let the RAS clients have a crack at this if they want
    //

    if (DeviceContext->IndicationQueuesInUse) {

        //
        // If RAS has datagram indications posted, and this is a
        // datagram that nobody wanted, then receive it anyway.
        //

        if ((UiFrame->Command == NBF_CMD_DATAGRAM) &&
            (status == STATUS_ABANDONED)) {

            *DatagramAddress = NULL;
            status = STATUS_MORE_PROCESSING_REQUIRED;

        } else if ((UiFrame->Command == NBF_CMD_ADD_NAME_QUERY) ||
            (UiFrame->Command == NBF_CMD_ADD_GROUP_NAME_QUERY) ||
            (UiFrame->Command == NBF_CMD_NAME_QUERY)) {

            NbfActionQueryIndication(
                 DeviceContext,
                 UiFrame);

        }
    }


    return status;

} /* NbfProcessUi */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the user process and can ( when
    built in a debug kernel) will log to either the console or through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/


#if DBG

#include <netb.h>
#include <stdarg.h>
#include <stdio.h>

ULONG NbDllDebug = 0x0;
#define NB_DLL_DEBUG_NCB        0x00000001  // print all NCB's submitted
#define NB_DLL_DEBUG_NCB_BUFF   0x00000002  // print buffers for NCB's submitted

BOOL UseConsole = FALSE;
BOOL UseLogFile = TRUE;
HANDLE LogFile = INVALID_HANDLE_VALUE;
#define LOGNAME                 (LPTSTR) TEXT("netbios.log")

LONG NbMaxDump = 128;

//  Macro used in DisplayNcb
#define DISPLAY_COMMAND( cmd )              \
    case cmd: NbPrintf(( #cmd )); break;

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

VOID
DisplayNcb(
    IN PNCBI pncbi
    )
/*++

Routine Description:

    This routine displays on the standard output stream the contents
    of the Ncb.

Arguments:

    IN PNCBI - Supplies the NCB to be displayed.

Return Value:

    none.

--*/
{
    if ( (NbDllDebug & NB_DLL_DEBUG_NCB) == 0 ) {
        return;
    }

    NbPrintf(( "PNCB         %#010lx\n", pncbi));

    NbPrintf(( "ncb_command  %#04x ",  pncbi->ncb_command));
    switch ( pncbi->ncb_command & ~ASYNCH ) {
    DISPLAY_COMMAND( NCBCALL );
    DISPLAY_COMMAND( NCBLISTEN );
    DISPLAY_COMMAND( NCBHANGUP );
    DISPLAY_COMMAND( NCBSEND );
    DISPLAY_COMMAND( NCBRECV );
    DISPLAY_COMMAND( NCBRECVANY );
    DISPLAY_COMMAND( NCBCHAINSEND );
    DISPLAY_COMMAND( NCBDGSEND );
    DISPLAY_COMMAND( NCBDGRECV );
    DISPLAY_COMMAND( NCBDGSENDBC );
    DISPLAY_COMMAND( NCBDGRECVBC );
    DISPLAY_COMMAND( NCBADDNAME );
    DISPLAY_COMMAND( NCBDELNAME );
    DISPLAY_COMMAND( NCBRESET );
    DISPLAY_COMMAND( NCBASTAT );
    DISPLAY_COMMAND( NCBSSTAT );
    DISPLAY_COMMAND( NCBCANCEL );
    DISPLAY_COMMAND( NCBADDGRNAME );
    DISPLAY_COMMAND( NCBENUM );
    DISPLAY_COMMAND( NCBUNLINK );
    DISPLAY_COMMAND( NCBSENDNA );
    DISPLAY_COMMAND( NCBCHAINSENDNA );
    DISPLAY_COMMAND( NCBLANSTALERT );
    DISPLAY_COMMAND( NCBFINDNAME );

    //  Extensions
    DISPLAY_COMMAND( NCALLNIU );
    DISPLAY_COMMAND( NCBQUICKADDNAME );
    DISPLAY_COMMAND( NCBQUICKADDGRNAME );
    DISPLAY_COMMAND( NCBACTION );

    default: NbPrintf(( " Unknown type")); break;
    }
    if ( pncbi->ncb_command  & ASYNCH ) {
        NbPrintf(( " | ASYNCH"));
    }


    NbPrintf(( "\nncb_retcode  %#04x\n",  pncbi->ncb_retcode));
    NbPrintf(( "ncb_lsn      %#04x\n",  pncbi->ncb_lsn));
    NbPrintf(( "ncb_num      %#04x\n",  pncbi->ncb_num));

    NbPrintf(( "ncb_buffer   %#010lx\n",pncbi->ncb_buffer));
    NbPrintf(( "ncb_length   %#06x\n",  pncbi->ncb_length));

    NbPrintf(( "\nncb_callname and ncb->name\n"));
    FormattedDump( pncbi->cu.ncb_callname, NCBNAMSZ );
    FormattedDump( pncbi->ncb_name, NCBNAMSZ );

    if (((pncbi->ncb_command & ~ASYNCH) == NCBCHAINSEND) ||
        ((pncbi->ncb_command & ~ASYNCH) == NCBCHAINSENDNA)) {
        NbPrintf(( "ncb_length2  %#06x\n",  pncbi->cu.ncb_chain.ncb_length2));
        NbPrintf(( "ncb_buffer2  %#010lx\n",pncbi->cu.ncb_chain.ncb_buffer2));
    }

    NbPrintf(( "ncb_rto      %#04x\n",  pncbi->ncb_rto));
    NbPrintf(( "ncb_sto      %#04x\n",  pncbi->ncb_sto));
    NbPrintf(( "ncb_post     %lx\n",    pncbi->ncb_post));
    NbPrintf(( "ncb_lana_num %#04x\n",  pncbi->ncb_lana_num));
    NbPrintf(( "ncb_cmd_cplt %#04x\n",  pncbi->ncb_cmd_cplt));

    NbPrintf(( "ncb_reserve\n"));
    FormattedDump( ((PNCB)pncbi)->ncb_reserve, 14 );

    NbPrintf(( "ncb_next\n"));
    FormattedDump( (PCHAR)&pncbi->u.ncb_next, sizeof( LIST_ENTRY) );
    NbPrintf(( "ncb_iosb\n"));
    FormattedDump( (PCHAR)&pncbi->u.ncb_iosb, sizeof( IO_STATUS_BLOCK ) );
    NbPrintf(( "ncb_event %#04x\n",  pncbi->ncb_event));

    if ( (NbDllDebug & NB_DLL_DEBUG_NCB_BUFF) == 0 ) {
        NbPrintf(( "\n\n" ));
        return;
    }

    switch ( pncbi->ncb_command & ~ASYNCH ) {
    case NCBSEND:
    case NCBCHAINSEND:
    case NCBDGSEND:
    case NCBSENDNA:
    case NCBCHAINSENDNA:
        if ( pncbi->ncb_retcode == NRC_PENDING ) {

            //
            //  If pending then presumably we have not displayed the ncb
            //  before. After its been sent there isn't much point in displaying
            //  the buffer again.
            //

            NbPrintf(( "ncb_buffer contents:\n"));
            FormattedDump( pncbi->ncb_buffer, pncbi->ncb_length );
        }
        break;

    case NCBRECV:
    case NCBRECVANY:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBENUM:
    case NCBASTAT:
    case NCBSSTAT:
    case NCBFINDNAME:
        if ( pncbi->ncb_retcode != NRC_PENDING ) {
            //  Buffer has been loaded with data
            NbPrintf(( "ncb_buffer contents:\n"));
            FormattedDump( pncbi->ncb_buffer, pncbi->ncb_length );
        }
        break;

    case NCBCANCEL:
        //  Buffer has been loaded with the NCB to be cancelled
        NbPrintf(( "ncb_buffer contents:\n"));
        FormattedDump( pncbi->ncb_buffer, sizeof(NCB));
        break;
    }
    NbPrintf(( "\n\n" ));
}

VOID
NbPrint(
    char *Format,
    ...
    )
/*++

Routine Description:

    This routine is equivalent to printf with the output being directed to
    stdout.

Arguments:

    IN  char *Format - Supplies string to be output and describes following
        (optional) parameters.

Return Value:

    none.

--*/
{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    if ( NbDllDebug == 0 ) {
        return;
    }


    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    if ( UseConsole ) {
        DbgPrint( "%s", OutputBuffer );
    } else {
        length = strlen( OutputBuffer );
        if ( LogFile == INVALID_HANDLE_VALUE ) {
            if ( UseLogFile ) {
                LogFile = CreateFile( LOGNAME,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
                if ( LogFile == INVALID_HANDLE_VALUE ) {
                    // Could not access logfile so use stdout instead
                    UseLogFile = FALSE;
                    LogFile = GetStdHandle(STD_OUTPUT_HANDLE);
                }
            } else {
                // Use the applications stdout file.
                LogFile = GetStdHandle(STD_OUTPUT_HANDLE);
            }
        }

        WriteFile( LogFile , (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // NbPrint

void
FormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if ( len > NbMaxDump ) {
        len = NbMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NbPrintf (("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NbPrintf (("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\tnetbios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetbios.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

    Jerome Nantel (w-jeromn) 23 August 1991

        Add Event Signaling testing

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_CONSOLE_APP
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "
#define TIMEOUT 60000   // Time out for wait, set at 1 minute
#define Hi  "Come here Dave, I need you"

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//  Hard code lana-num that is mapped to XNS

int Limit = 20;

VOID
usage (
    VOID
    )
{
    printf("usage: tnetbios [-n:lan number][-h][-e] <remote computername> <my computername>\n");
    printf("                 -n specifies the lan number (0 is the default)\n");
    printf("                 -h specifies that addresses are hexadecimal numbers \n");
    printf("                     rather than strings.\n");
    printf("                 -e test event signaling for ASYNC calls.  \n");
    printf("                 final two arguments are the remote and local computer names.\n");
}

int
main (argc, argv)
   int argc;
   char *argv[];
{
    NCB myncb;
    CHAR Buffer[128];
    CHAR Buffer2[128];
    int i,j;
    CHAR localName[16];
    CHAR remoteName[16];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    ULONG lanNumber=0;
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    BOOLEAN tevent=FALSE;
    UCHAR lsn;
    UCHAR name_number;
    HANDLE event;

    if ( argc < 3 || argc > 6) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            case 'e':
                tevent = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlen( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlen( argv[i] ));
            }

        }
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    if (tevent) {
        /* Testing event signaling to handle async calls */
        if (( event = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL ) {
            /* Could not get event handle.  Abort */
            printf("Could not test event signaling.\n");
            tevent=FALSE;
        }
    }

    printf( "Starting NetBios\n" );
    {
        LANA_ENUM Enum;
        ClearNcb( &myncb );
        myncb.ncb_command = NCBENUM;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_length = sizeof(Enum);
        myncb.ncb_buffer = &Enum;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            printf( " Enum Failed %x\n", myncb.ncb_retcode );
            return 1;
        }
    }

    //   Reset

    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 0;           // Request resources
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    myncb.ncb_callname[0] = 0;   // 16 sessions
    myncb.ncb_callname[1] = 0;   // 16 commands
    myncb.ncb_callname[2] = 0;   // 8 names
    Netbios( &myncb );

    //   Add name
    ClearNcb( &myncb );
    myncb.ncb_command = NCBADDNAME;
    RtlMoveMemory( myncb.ncb_name, localName, lstrlen(localName));
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );

    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( " Addname Failed %x\n", myncb.ncb_retcode );
        return 1;
    }
    name_number = myncb.ncb_num;

    {
        struct {
            ADAPTER_STATUS AdapterInfo;
            NAME_BUFFER Names[16];
        } AdapterStatus;
        //   Adapter Status
        ClearNcb( &myncb );
        myncb.ncb_command = NCBASTAT;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_length = sizeof( AdapterStatus );
        myncb.ncb_buffer = (CHAR *)&AdapterStatus;
        Netbios( &myncb );
    }
    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( " Adapter Status Failed %x\n", myncb.ncb_retcode );
        return 1;
    }

    for ( j = 0; j <= Limit; j++ ) {

        //   Call
        ClearNcb( &myncb );
        myncb.ncb_command = NCBCALL | ASYNCH;
        RtlMoveMemory( myncb.ncb_name, localName, lstrlen(localName ));
        RtlMoveMemory( myncb.ncb_callname, remoteName, lstrlen( remoteName ));
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_rto = myncb.ncb_rto = 0;//10;  10*500 milliseconds timeout
        myncb.ncb_num = name_number;
        if ( tevent ) myncb.ncb_event = event;
        while ( TRUE) {
            printf("\nStart NCB CALL ");
            Netbios( &myncb );
            printf( " Call returned " );
            if ( tevent ) {
            if ( WaitForSingleObject( event, TIMEOUT ) ) {
                // Wait timed out, no return
                printf("ERROR: Wait timed out, event not signaled.\n");
            }
            } else {
               while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
               printf( "." );
               Sleep(500);

               }
            }
            lsn = myncb.ncb_lsn;

            if ( myncb.ncb_retcode == NRC_GOODRET ) {
                // Success
                printf( " Call completed\n" );
                break;
            }
            printf( " Call completed with error %lx, retry\n", myncb.ncb_retcode );
        }

        for ( i = 0; i <=j ; i++ ) {

            //   Send
            ClearNcb( &myncb );
            myncb.ncb_command = NCBSEND;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Hi );
            myncb.ncb_buffer = Buffer;
            myncb.ncb_lsn = lsn;
            RtlMoveMemory( Buffer, Hi, sizeof( Hi ));
            Netbios( &myncb );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }

            //   Receive
            ClearNcb( &myncb );
            myncb.ncb_command = NCBRECV | ASYNCH;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Buffer2 );
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            if ( tevent ) myncb.ncb_event = event;
                Netbios( &myncb );
                printf( "R" );
            if ( tevent ) {
            if ( WaitForSingleObject( event, TIMEOUT ) ) {
                // Wait timed out, no return
                printf("ERROR: Wait timed out, event not signaled.\n");
            }
            } else {
               while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
               printf( "." );
               Sleep(500);

               }
            }
            printf( "r" );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
            // printf( ":%s\n", Buffer2);
        }

        //  Hangup
        ClearNcb( &myncb );
        myncb.ncb_command = NCBHANGUP;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_lsn = lsn;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 1;           // Free resources
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );
    printf( "Ending NetBios\n" );

    if (tevent ) {
      // Close handle
      CloseHandle( event );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\netbios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netbios.c

Abstract:

    This is the component of netbios that runs in the user process
    passing requests to \Device\Netbios.

Author:

    Colin Watson (ColinW) 15-Mar-91

Revision History:

    Ram Cherala (RamC) 31-Aug-95 Added a try/except around the code which
                                 calls the post routine in SendAddNcbToDriver
                                 function. Currently if there is an exception
                                 in the post routine this thread will die
                                 before it has a chance to call the
                                 "AddNameThreadExit" function to decrement
                                 the trhead count. This will result in not
                                 being able to shut down the machine without
                                 hitting the reset switch.
--*/

/*
Notes:

     +-----------+  +------------+   +------------+
     |           |  |            |   |            |
     | User      |  | User       |   | Worker     |
     | Thread 1  |  | Thread 2   |   | thread in  |
     |           |  |            |   | a Post Rtn.|
     +-----+-----+  +-----+------+   +------+-----+
           |Netbios(pncb);|Netbios(pncb);   |
           v              v                 |
     +-----+--------------+-----------------+------+
     |                          ----->    Worker   |    NETAPI.DLL
     |                         WorkQueue  thread   |
     |                          ----->             |
     +--------------------+------------------------+
                          |
                +---------+---------+
                |                   |
                | \Device\Netbios   |
                |                   |
                +-------------------+

The netbios Worker thread is created automatically by the Netbios call
when it determines that the user threads are calling Netbios() with
calls that use a callback routine (called a Post routine in the NetBIOS
specification).

When a worker thread has been created, all requests will be sent via
the WorkQueue to the worker thread for submission to \Device\Netbios.
This ensures that send requests go on the wire in the same
order as the send ncb's are presented. Because the IO system cancels all
a threads requests when it terminates, the use of the worker thread allows
such a request inside \Device\Netbios to complete normally.

All Post routines are executed by the Worker thread. This allows any Win32
synchronization mechanisms to be used between the Post routine and the
applications normal code.

The Worker thread terminates when the process exits or when it gets
an exception such as an access violation.

In addition. If the worker thread gets an addname it will create an
extra thread which will process the addname and then die. This solves
the problem that the netbios driver will block the users thread during an
addname (by calling NtCreateFile) even if the caller specified ASYNCH. The
same code is also used for ASTAT which also creates handles and can take a
long time now that we support remote adapter status.

*/

#include <netb.h>
#include <lmcons.h>
#include <netlib.h>

#if defined(UNICODE)
#define NETBIOS_SERVICE_NAME L"netbios"
#else
#define NETBIOS_SERVICE_NAME "netbios"
#endif

BOOL Initialized;

CRITICAL_SECTION Crit;      //  protects WorkQueue & initialization.

LIST_ENTRY WorkQueue;       //  queue to worker thread.

HANDLE Event;               //  doorbell used when WorkQueue added too.

HANDLE WorkerHandle;        //  Return value when worker thread created.
HANDLE WaiterHandle;        //  Return value when waiter thread created.

HANDLE NB;                  //  This processes handle to \Device\Netbios.

HANDLE ReservedEvent;       //  Used for synchronous calls
LONG   EventUse;            //  Prevents simultaneous use of ReservedEvent

HANDLE AddNameEvent;        //  Doorbell used when an AddName worker thread
                            //  exits.
volatile LONG   AddNameThreadCount;


//
// Event used to wait for STOP notification from the Kernel mode NETBIOS.SYS
//

HANDLE StopEvent;

IO_STATUS_BLOCK StopStatusBlock;


#if AUTO_RESET

//
// Event used to wait for RESET notification from the Kernel mode NETBIOS.SYS
// Adapters
//

CRITICAL_SECTION    ResetCS;        // protects access to LanaResetList

LIST_ENTRY          LanaResetList;

NCB                 OutputNCB;

HANDLE              LanaResetEvent; // Event signalled when a new adapter is
                                    // bound to netbios and it needs to be reset

IO_STATUS_BLOCK     ResetStatusBlock;

#endif

HMODULE             g_hModule;


//
// netbios command history
//

NCB_INFO g_QueuedHistory[16];
DWORD g_dwNextQHEntry = 0;

NCB_INFO g_DeQueuedHistory[16];
DWORD g_dwNextDQHEntry = 0;

NCB_INFO g_SyncCmdsHistory[16];
DWORD g_dwNextSCEntry = 0;




VOID
SpinUpAddnameThread(
    IN PNCBI pncb
    );

VOID
AddNameThreadExit(
    VOID
    );

DWORD
SendAddNcbToDriver(
    IN PVOID Context
    );

DWORD
StartNetBIOSDriver(
    VOID
    );

#if AUTO_RESET
VOID
ResetLanaAndPostListen(
);
#endif

NTSTATUS
StartNB(
    OUT OBJECT_ATTRIBUTES *pobjattr,
    IN UNICODE_STRING *punicode,
    OUT IO_STATUS_BLOCK *piosb
)
/*++

Routine Description:

    This routine is a worker function of Netbios. It will try to start NB
    service.

Arguments:
    OUT pobjattr - object attribute
    IN punicode - netbios file name
    OUT piosb - ioblock

Return Value:

    The function value is the status of the operation.

--*/
{
    //
    // Open a handle to \\Device\Netbios
    //

    InitializeObjectAttributes(
            pobjattr,                       // obj attr to initialize
            punicode,                       // string to use
            OBJ_CASE_INSENSITIVE,           // Attributes
            NULL,                           // Root directory
            NULL);                          // Security Descriptor

    return NtCreateFile(
                &NB,                        // ptr to handle
                GENERIC_READ                // desired...
                | GENERIC_WRITE,            // ...access
                pobjattr,                   // name & attributes
                piosb,                      // I/O status block.
                NULL,                       // alloc size.
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_DELETE           // share...
                | FILE_SHARE_READ
                | FILE_SHARE_WRITE,         // ...access
                FILE_OPEN_IF,               // create disposition
                0,                          // ...options
                NULL,                       // EA buffer
                0L );                       // Ea buffer len
}


unsigned char APIENTRY
Netbios(
    IN PNCB pncb
    )
/*++

Routine Description:

    This routine is the applications entry point into netapi.dll to support
    netbios 3.0 conformant applications.

Arguments:

    IN PNCB pncb- Supplies the NCB to be processed. Contents of the NCB and
        buffers pointed to by the NCB will be modified in conformance with
        the netbios 3.0 specification.

Return Value:

    The function value is the status of the operation.

Notes:

    The reserved field is used to hold the IO_STATUS_BLOCK.

    Even if the application specifies ASYNCH, the thread may get blocked
    for a period of time while we open transports, create worker threads
    etc.

--*/
{
    //
    //  pncbi saves doing lots of type casting. The internal form includes
    //  the use of the reserved fields.
    //

    PNCBI pncbi = (PNCBI) pncb;

    NTSTATUS ntStatus;

    BOOL    bPending = FALSE;



    if ( ((ULONG_PTR)pncbi & 3) != 0)
    {
        //
        //  NCB must be 32 bit aligned
        //

        pncbi->ncb_retcode = pncbi->ncb_cmd_cplt = NRC_BADDR;
        return NRC_BADDR;
    }


    //
    // using this field to fix bug # 293765
    //

    pncbi-> ncb_reserved = 0;


    //
    //  Conform to Netbios 3.0 specification by flagging request in progress
    //

    pncbi->ncb_retcode = pncbi->ncb_cmd_cplt = NRC_PENDING;

    DisplayNcb( pncbi );

    if ( !Initialized )
    {
        EnterCriticalSection( &Crit );

        //
        //  Check again to see if another thread got into the critical section
        //  and initialized the worker thread.
        //

        if ( !Initialized )
        {

            IO_STATUS_BLOCK iosb;
            OBJECT_ATTRIBUTES objattr;
            UNICODE_STRING unicode;

            HANDLE Threadid;
            BOOL Flag;


            //
            // 1. start netbios driver
            //

            //
            // Open handle to \\Device\Netbios
            //

            RtlInitUnicodeString( &unicode, NB_DEVICE_NAME);

            ntStatus = StartNB( &objattr, &unicode, &iosb );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                //
                // Load the driver
                //

                DWORD err = 0;

                err = StartNetBIOSDriver();

                if ( err )
                {
                    pncbi->ncb_retcode = NRC_OPENERR;
                    pncbi->ncb_cmd_cplt = NRC_OPENERR;

                    NbPrintf( ( "[NETAPI32] Failed to load driver : %lx\n",
                                 err ));

                    LeaveCriticalSection( &Crit );

                    return pncbi->ncb_cmd_cplt;
                }

                else
                {
                    //
                    // Driver loaded.
                    // Open handle to \\Device\Netbios
                    //

                    ntStatus = StartNB( &objattr, &unicode, &iosb );

                    if ( !NT_SUCCESS( ntStatus ) )
                    {
                        pncbi->ncb_retcode = NRC_OPENERR;
                        pncbi->ncb_cmd_cplt = NRC_OPENERR;

                        NbPrintf( ( "[NETAPI32] Failed to open handle : %X\n",
                                     ntStatus ));

                        LeaveCriticalSection( &Crit );

                        return pncbi->ncb_cmd_cplt;
                    }
                }
            }


            //
            // 2. create a reserved (reusable) event for internal use
            //

            ntStatus = NtCreateEvent(
                            &ReservedEvent, EVENT_ALL_ACCESS,
                            NULL, SynchronizationEvent, FALSE
                            );

            if ( !NT_SUCCESS( ntStatus) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Reserved Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }

            EventUse = 1;


            //
            //  Initialize shared datastructures
            //

            //
            // create a queue for work items to be queued to the Worker thread
            //

            InitializeListHead( &WorkQueue );


            //
            // 4. create an event to communicate with the Worker thread
            //

            ntStatus = NtCreateEvent(
                        &Event, EVENT_ALL_ACCESS,
                        NULL, SynchronizationEvent, FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


            //
            // 5.
            // create an event to synchronize ADD name operations with
            // Lana Reset operations.  Both these are performed in separate
            // threads and RESET operations are gated by the ADD names
            //

            ntStatus = NtCreateEvent(
                        &AddNameEvent, EVENT_ALL_ACCESS,
                        NULL, NotificationEvent, FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create AddName Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


            //
            // 6. Create an event to register for stop notification.
            //

            ntStatus = NtCreateEvent(
                        &StopEvent,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create StopEvent Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


#if AUTO_RESET

            //
            // 7. Create an event to register for reset notification.
            //

            ntStatus = NtCreateEvent(
                        &LanaResetEvent,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create StopEvent Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( StopEvent );
                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }
#endif

            //
            // 8. create a worker thread to handle async. Netbios requests
            //

            {
                TCHAR   szFileName[MAX_PATH + 1];

                GetModuleFileName(g_hModule, szFileName,
                                  sizeof(szFileName) / sizeof(TCHAR));
                szFileName[MAX_PATH] = 0;

                LoadLibrary(szFileName);
            }

            WaiterHandle = CreateThread(
                            NULL,   //  Standard thread attributes
                            0,      //  Use same size stack as users
                                    //  application
                            NetbiosWaiter,
                                    //  Routine to start in new thread
                            0,      //  Parameter to thread
                            0,      //  No special CreateFlags
                            (LPDWORD)&Threadid
                            );

            if ( WaiterHandle == NULL )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Waiter thread" ) );

                LeaveCriticalSection( &Crit );

                NtClose( StopEvent );
                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }

            NbPrintf( ( "Waiter handle: %lx, threadid %lx\n", WaiterHandle, Threadid ) );
        }

        Initialized = TRUE;

        LeaveCriticalSection( &Crit );

    }


    //
    // Verify that handle to \\Device\Netbios is still open.
    //

    if ( NB == NULL )
    {
        pncbi->ncb_retcode = NRC_OPENERR;
        pncbi->ncb_cmd_cplt = NRC_OPENERR;

        NbPrintf( ("[NETAPI32] Netbios service has been stopped\n") );

        return pncbi->ncb_cmd_cplt;
    }


    //
    // Disallow simultaneous use of both event and callback routine.
    // This will cut down the test cases by disallowing a weird feature.
    //

    if ( (  ( pncbi->ncb_command & ASYNCH) != 0) &&
            ( pncbi->ncb_event) &&
            ( pncbi->ncb_post ) )
    {
        pncbi->ncb_retcode = NRC_ILLCMD;
        pncbi->ncb_cmd_cplt = NRC_ILLCMD;

        NbPrintf( ( "[NETAPI32] Event and Post Routine specified\n" ) );

        return pncbi->ncb_cmd_cplt;
    }



    //
    // if synchronous command
    //

    if ( (pncb->ncb_command & ASYNCH) == 0 )
    {
        NTSTATUS Status;
        LONG EventOwned;


        // NbPrint( ("[NETAPI32] Synchronpus netbios call\n") );


        //
        //  Caller wants a synchronous call so ignore ncb_post and ncb_event.
        //
        //  We need an event so that we can pause if STATUS_PENDING is returned.
        //

        EventOwned = InterlockedDecrement( &EventUse );

        //
        //  If EventUse went from 1 to 0 then we obtained ReservedEvent
        //

        if ( EventOwned == 0)
        {
            pncbi->ncb_event = ReservedEvent;
        }
        else
        {
            InterlockedIncrement( &EventUse );

            Status = NtCreateEvent(
                        &pncbi->ncb_event, EVENT_ALL_ACCESS,
                        NULL, SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( Status ) )
            {
                //
                //  Failed to create event
                //

                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create event : %X\n", Status ) );

                return pncbi->ncb_cmd_cplt;
            }
        }


        pncbi-> ncb_post = NULL;

        //
        // Check if the worker thread has been created.  If it has queue workitem
        // to it.  Else use the caller's thread to execute synchronous NCB command
        //

        if ( WorkerHandle == NULL )
        {
            ADD_SYNCCMD_ENTRY(pncbi);

            //
            // Worker thread has not been created.  Execute in the context of
            // invoker's thread.
            //

            SendNcbToDriver( pncbi );
        }

        else
        {
            //
            // Queue Netbios command to worker thread and wait for APC to fire
            //

            QueueToWorker( pncbi );
        }


        do
        {
            ntStatus = NtWaitForSingleObject(
                            pncbi->ncb_event, TRUE, NULL
                            );

        } while ( ( ntStatus == STATUS_USER_APC ) ||
                  ( ntStatus == STATUS_ALERTED) );


        ASSERT( ntStatus == STATUS_SUCCESS );

        if ( !NT_SUCCESS(ntStatus) )
        {
            NbPrintf(( "[NETAPI32] NtWaitForSingleObject failed: %X\n", ntStatus ) );

            pncbi->ncb_retcode = NRC_SYSTEM;
            pncbi->ncb_cmd_cplt = NRC_SYSTEM;
        }


        //
        // release the local event used to wait for
        // completion of netbios command
        //

        if ( EventOwned == 0)
        {
            InterlockedIncrement( &EventUse );
        }
        else
        {
            NtClose( pncbi->ncb_event );
        }

        pncbi-> ncb_event = NULL;
    }

    else
    {
        //
        // Async netbios command.  Queue to worker thread
        //

        //
        // Check if worker exists.
        //

        if ( WorkerHandle == NULL )
        {
            EnterCriticalSection( &Crit );

            //
            // verify that worker thread has not been created by
            // while this thread was waiting in EnterCriticalSection
            //

            if ( WorkerHandle == NULL )
            {
               HANDLE Threadid;
               BOOL Flag;

               //
               // create a worker thread to handle async. Netbios requests
               //

               WorkerHandle = CreateThread(
                               NULL,   //  Standard thread attributes
                               0,      //  Use same size stack as users
                                       //  application
                               NetbiosWorker,
                                       //  Routine to start in new thread
                               0,      //  Parameter to thread
                               0,      //  No special CreateFlags
                               (LPDWORD)&Threadid
                               );

               if ( WorkerHandle == NULL )
               {
                   pncbi->ncb_retcode = NRC_SYSTEM;
                   pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                   NbPrintf( ( "[NETAPI32] Failed to create Worker thread" ) );

                   LeaveCriticalSection( &Crit );

                   return pncbi->ncb_cmd_cplt;
               }

               Flag = SetThreadPriority(
                           WorkerHandle,
                           THREAD_PRIORITY_ABOVE_NORMAL
                           );

               ASSERT( Flag == TRUE );

               if ( Flag != TRUE )
               {
                   NbPrintf(
                    ("[NETAPI32] Worker SetThreadPriority: %lx\n", GetLastError() )
                    );
               }

               AddNameThreadCount = 0;

               NbPrintf( ( "Worker handle: %lx, threadid %lx\n", WorkerHandle, Threadid ) );
           }

           LeaveCriticalSection( &Crit );
       }

       // NbPrint( ("[NETAPI32] Asynchronpus netbios call\n") );

       bPending = TRUE;
       QueueToWorker( pncbi );
    }


    switch ( pncb->ncb_command & ~ASYNCH )
    {
    case NCBRECV:
    case NCBRECVANY:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBENUM:
    case NCBASTAT:
    case NCBSSTAT:
    case NCBCANCEL:
    case NCBCALL:
        DisplayNcb( pncbi );
    }


    if ( bPending )
    {
        return NRC_GOODRET;
    }
    else
    {
        return pncbi->ncb_cmd_cplt;
    }

} // NetBios



DWORD
StartNetBIOSDriver(
    VOID
)
/*++

Routine Description:

    Starts the netbios.sys driver using the service controller

Arguments:

    none

Returns:

    Error return from service controller.

++*/
{

    DWORD err = NO_ERROR;
    SC_HANDLE hSC;
    SC_HANDLE hSCService;


    hSC = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );

    if (hSC == NULL)
    {
        return(GetLastError());
    }

    hSCService = OpenService( hSC, NETBIOS_SERVICE_NAME, SERVICE_START );

    if (hSCService == NULL)
    {
        CloseServiceHandle(hSC);
        return(GetLastError());
    }

    if ( !StartService( hSCService, 0, NULL ) )
    {
        err = GetLastError();
    }
    CloseServiceHandle(hSCService);
    CloseServiceHandle(hSC);


    if ( err )
    {
        NbPrintf( ("[NETAPI32] LEAVING StartNetBIOSDriver, Error : %d\n", err) );
    }

    return(err);

}



VOID
QueueToWorker(
    IN PNCBI pncb
    )
/*++

Routine Description:

    This routine queues an ncb to the worker thread.

Arguments:

    IN PNCBI pncb - Supplies the NCB to be processed. Contents of the NCB and
        buffers pointed to by the NCB will be modified in conformance with
        the netbios 3.0 specification.

Return Value:

    The function value is the status of the operation.

--*/
{
    if ( pncb->ncb_event != NULL ) {
        NtResetEvent( pncb->ncb_event, NULL );
    }

    EnterCriticalSection( &Crit );

    if ( pncb-> ncb_reserved == 0 ) {
        InsertTailList( &WorkQueue, &pncb->u.ncb_next );
        pncb-> ncb_reserved = 1;

        //
        // Note queued distory
        //

        ADD_QUEUE_ENTRY(pncb);
    }

    LeaveCriticalSection( &Crit );

    //  Make sure the worker is awake to perform the request
    NtSetEvent(Event, NULL);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
NetbiosWorker(
    IN LPVOID Parameter
    )
/*++

Routine Description:

    This routine processes ASYNC requests made with the callback interface.
    The reasons for using a seperate thread are:

        1)  If a thread makes an async request and exits while the request
        is outstanding then the request will be cancelled by the IO system.

        2)  A seperate thread must be used so that the users POST routine
        can use normal synchronization APIs to access shared data structures.
        If the users thread is used then deadlock can and will happen.

    The POST routine operates in the context of the worker thread. There are
    no restrictions on what the POST routine can do. For example it can
    submit another ASYNCH request if desired. It will add it to the queue
    of work and set the event as normal.

    The worker thread will die when the process terminates.

Arguments:

    IN PULONG Parameter - supplies an unused parameter.

Return Value:

    none.

--*/
{
    NTSTATUS Status;


    while ( TRUE)
    {
        //
        //  Wait for a request to be placed onto the work queue.
        //

        //
        //  Must wait alertable so that the Apc (post) routine is called.
        //

        Status = NtWaitForSingleObject( Event, TRUE, NULL );

        if ( ( Status == STATUS_SUCCESS ) && ( NB != NULL ) )
        {
            EnterCriticalSection( &Crit );

            //
            // remove each Netbios request and forward it to the NETBIOS driver
            //

            while ( !IsListEmpty( &WorkQueue ) )
            {
                PLIST_ENTRY entry;
                PNCBI pncb;

                entry = RemoveHeadList(&WorkQueue);

                //
                //  Zero out reserved field again
                //

                entry->Flink = entry->Blink = 0;

                pncb = CONTAINING_RECORD( entry, NCBI, u.ncb_next );

                ADD_DEQUEUE_ENTRY(pncb);

                LeaveCriticalSection( &Crit );


                //  Give ncb to the driver specifying the callers APC routine

                if ( (pncb->ncb_command & ~ASYNCH) == NCBRESET )
                {
                    //
                    //  We may have threads adding names. Wait until
                    //  they are complete before submitting the reset.
                    //  Addnames and resets are rare so this should rarely
                    //  affect an application.
                    //

                    EnterCriticalSection( &Crit );

                    NtResetEvent( AddNameEvent, NULL );

                    while ( AddNameThreadCount != 0 )
                    {
                        LeaveCriticalSection( &Crit );

                        NtWaitForSingleObject( AddNameEvent, TRUE, NULL );

                        EnterCriticalSection( &Crit );

                        NtResetEvent( AddNameEvent, NULL );
                    }

                    LeaveCriticalSection( &Crit );
                }


                //
                //  SendNcbToDriver must not be in a critical section since the
                //  request may block if its a non ASYNCH request.
                //

                if (( (pncb->ncb_command & ~ASYNCH) != NCBADDNAME ) &&
                    ( (pncb->ncb_command & ~ASYNCH) != NCBADDGRNAME ) &&
                    ( (pncb->ncb_command & ~ASYNCH) != NCBASTAT ))
                {
                    SendNcbToDriver( pncb );
                }
                else
                {
                    SpinUpAddnameThread( pncb );
                }

                EnterCriticalSection( &Crit );

            }

            LeaveCriticalSection( &Crit );
        }
        else
        if ( NB == NULL )
        {

        }
    }

    return 0;

    UNREFERENCED_PARAMETER( Parameter );
}

DWORD
NetbiosWaiter(
    IN LPVOID Parameter
    )
/*++

Routine Description:

    This routine pends IOCTLs with the kernel mde component of Netbios and
    wait for them to complete.  The reason for a separate thread is that
    these IOCTLs cannot be pended in the context of the user threads as
    exiting the user thread will cause the IOCTL to get cancelled.

    In addition this thread is created at Netbios initialization (refer
    Netbios function) which could (and is) called from the DLL main of
    applications.  So the initialization code cannot wait for this thread
    to be created and initialized due to NT serialization of library
    loads and thread creation.

    To merge this thread with the Worker thread was deemed risky.  To do
    this the worker thread would execute all ASYNC requests and SYNC
    requests would be executed in the context of the user's thread.  This
    was a break from the the previous model where the once the Worker
    thread was created all requests (ASYNC and SYNC) would be executed
    in the context of the worker thread.  To preserve the previous mode
    of operation a separate wait thread was created.  **** There may be
    a better way to do this **** with only one thread but I am not sure.

Arguments:

    IN PULONG Parameter - supplies an unused parameter.

Return Value:

    none.

--*/
{

#if AUTO_RESET

#define POS_STOP            0
#define POS_RESET           1

#endif


    NTSTATUS Status;


    //
    // Send an IOCTL down to the kernel mode Netbios driver, to register
    // for stop notification.  This call should return STATUS_PENDING.
    // The event specified "StopEvent" will be signalled when the netbios
    // driver is being unloaded.
    //

    Status = NtDeviceIoControlFile(
                    NB,
                    StopEvent,
                    NULL, NULL,
                    &StopStatusBlock,
                    IOCTL_NB_REGISTER_STOP,
                    NULL, 0,
                    NULL, 0
                    );

    if ( ( Status != STATUS_PENDING ) &&
         ( Status != STATUS_SUCCESS ) )
    {
        NbPrintf(
            ("[NETAPI32] : Netbios IOCTL for STOP failed with status %lx\n", Status)
            );
    }


#if AUTO_RESET

    Status = NtDeviceIoControlFile(
                    NB,
                    LanaResetEvent,
                    NULL, NULL,
                    &ResetStatusBlock,
                    IOCTL_NB_REGISTER_RESET,
                    NULL, 0,
                    (PVOID) &OutputNCB, sizeof( NCB )
                    );

    if ( ( Status != STATUS_PENDING ) &&
         ( Status != STATUS_SUCCESS ) )
    {
        //
        // Failed to register reset notification.
        //

        NbPrintf(
            ("[NETAPI32] : Netbios : Failed to register Reset event\n" )
            );
    }

#endif


    while ( TRUE )
    {

#if AUTO_RESET

        HANDLE Events[] = {  StopEvent, LanaResetEvent };

        Status = NtWaitForMultipleObjects( 2, Events, WaitAny, TRUE, NULL );

        if ( Status == POS_STOP )
        {
            Status = NtClose( NB );
            InterlockedExchangePointer( (PVOID *) &NB, NULL );

            NbPrintf( ("[NETAPI32] Stop event signaled, Status : %lx\n", Status) );

        }

        else
        if ( ( Status == POS_RESET ) && (NB != NULL ) )
        {
            NbPrintf( ("[NETAPI32] Reset event signaled\n") );

            ResetLanaAndPostListen();
        }
#else

        Status = NtWaitForSingleObject( StopEvent, TRUE, NULL );

        if ( Status == STATUS_SUCCESS )
        {
            NbPrintf( ("[NETAPI32] Stop event signaled\n") );

            NtClose( NB );
            InterlockedExchangePointer( (PVOID *) &NB, NULL );
        }
#endif

    }

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

VOID
SendNcbToDriver(
    IN PNCBI pncb
    )
/*++

Routine Description:

    This routine determines the Device Ioctl code to be used to send the
    ncb to \Device\Netbios and then does the call to send the request
    to the driver.

Arguments:

    IN PNCBI pncb - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    NTSTATUS ntstatus;

    char * buffer;
    unsigned short length;

    //  Use NULL for the buffer if only the NCB is to be passed.

    switch ( pncb->ncb_command & ~ASYNCH ) {
    case NCBSEND:
    case NCBSENDNA:
    case NCBRECV:
    case NCBRECVANY:
    case NCBDGSEND:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBASTAT:
    case NCBFINDNAME:
    case NCBSSTAT:
    case NCBENUM:
    case NCBACTION:
        buffer = pncb->ncb_buffer;
        length = pncb->ncb_length;
        break;

    case NCBCANCEL:
        //  The second buffer points to the NCB to be cancelled.
        buffer = pncb->ncb_buffer;
        length = sizeof(NCB);
        NbPrintf(( "[NETAPI32] Attempting to cancel PNCB: %lx\n", buffer ));
        DisplayNcb( (PNCBI)buffer );
        break;

    case NCBCHAINSEND:
    case NCBCHAINSENDNA:
        {
            PUCHAR BigBuffer;   //  Points to the start of BigBuffer, not
                                //  the start of user data.
            PUCHAR FirstBuffer;

            //
            //  There is nowhere in the NCB to save the address of BigBuffer.
            //  The address is needed to free BigBuffer when the transfer is
            //  complete. At the start of BigBuffer, 4 bytes are used to store
            //  the user supplied ncb_buffer value which is restored later.
            //

            BigBuffer = RtlAllocateHeap(
                RtlProcessHeap(), 0,
                sizeof(pncb->ncb_buffer) +
                pncb->ncb_length +
                pncb->cu.ncb_chain.ncb_length2);

            if ( BigBuffer == NULL ) {

                NbPrintf(( "[NETAPI32] The Netbios BigBuffer Allocation failed: %lx\n",
                    pncb->ncb_length + pncb->cu.ncb_chain.ncb_length2));
                pncb->ncb_retcode = NRC_NORES;
                pncb->ncb_cmd_cplt = NRC_NORES;
                pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
                PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
                return;
            }

            NbPrintf(( "[NETAPI32] BigBuffer Allocation: %lx\n", BigBuffer));

            //  Save users buffer address.
            RtlMoveMemory(
                BigBuffer,
                &pncb->ncb_buffer,
                sizeof(pncb->ncb_buffer));

            FirstBuffer = pncb->ncb_buffer;

            pncb->ncb_buffer = BigBuffer;

            //  Copy the user data.
            try {

                RtlMoveMemory(
                    sizeof(pncb->ncb_buffer) + BigBuffer,
                    &FirstBuffer[0],
                    pncb->ncb_length);

                RtlMoveMemory(
                    sizeof(pncb->ncb_buffer) + BigBuffer + pncb->ncb_length,
                    &pncb->cu.ncb_chain.ncb_buffer2[0],
                    pncb->cu.ncb_chain.ncb_length2);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                pncb->ncb_retcode = NRC_BUFLEN;
                pncb->ncb_cmd_cplt = NRC_BUFLEN;
                pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
                ChainSendPostRoutine( pncb, &pncb->u.ncb_iosb, 0);
                return;
            }

            NbPrintf(( "[NETAPI32] Submit chain send pncb: %lx, event: %lx, post: %lx. \n",
                pncb,
                pncb->ncb_event,
                pncb->ncb_post));

            ntstatus = NtDeviceIoControlFile(
                NB,
                NULL,
                ChainSendPostRoutine,                   //  APC Routine
                pncb,                                   //  APC Context
                &pncb->u.ncb_iosb,                      //  IO Status block
                IOCTL_NB_NCB,
                pncb,                                   //  InputBuffer
                sizeof(NCB),
                sizeof(pncb->ncb_buffer) + BigBuffer,   //  Outputbuffer
                pncb->ncb_length + pncb->cu.ncb_chain.ncb_length2);

            if ((ntstatus != STATUS_SUCCESS) &&
                (ntstatus != STATUS_PENDING) &&
                (ntstatus != STATUS_HANGUP_REQUIRED)) {
                NbPrintf(( "[NETAPI32] The Netbios Chain Send failed: %X\n", ntstatus ));

                if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
                    pncb->ncb_retcode = NRC_BUFLEN;
                } else {
                    pncb->ncb_retcode = NRC_SYSTEM;
                }
                ChainSendPostRoutine( pncb, &pncb->u.ncb_iosb, 0);
            }

            NbPrintf(( "[NETAPI32] PNCB: %lx completed, status:%lx, ncb_retcode: %#04x\n",
                pncb,
                ntstatus,
                pncb->ncb_retcode ));

            return;
        }


#if AUTO_RESET

    //
    // added to fix bug : 170107
    //

    //
    // Remember the parameters used in reseting a LANA. LANAs need to
    // be automatically re-reset when they get unbound and bound back to
    // netbios.sys.  This happens in the case of TCPIP devices that renew
    // their IP addresses.
    //

    case NCBRESET :
    {
        PRESET_LANA_NCB prlnTmp;
        PLIST_ENTRY     ple, pleHead;

        buffer = NULL;
        length = 0;


        NbPrintf( (
            "[NETAPI32] : Netbios : reseting adapter %d\n",
            pncb-> ncb_lana_num
            ) );

        //
        // Add Reset NCB to global list
        //

        EnterCriticalSection( &ResetCS );

        //
        // check if already present
        //

        pleHead = &LanaResetList;

        for ( ple = pleHead-> Flink; ple != pleHead; ple = ple-> Flink )
        {
            prlnTmp = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

            if ( prlnTmp-> ResetNCB.ncb_lana_num == pncb-> ncb_lana_num )
            {
                break;
            }
        }


        if ( ple == pleHead )
        {
            //
            // NO reset was performed before for this LANA
            //

            //
            // allocate a NCB entry and copy the NCB used
            //

            prlnTmp = HeapAlloc(
                        GetProcessHeap(), 0, sizeof( RESET_LANA_NCB )
                        );

            if ( prlnTmp == NULL )
            {
                NbPrintf( (
                    "[NETAPI32] : Netbios : Failed to allocate RESET_LANA_NCB"
                    ) );

                LeaveCriticalSection( &ResetCS );

                break;
            }


            ZeroMemory( prlnTmp, sizeof( RESET_LANA_NCB ) );

            InitializeListHead( &prlnTmp-> leList );

            CopyMemory( &prlnTmp-> ResetNCB, pncb, FIELD_OFFSET( NCB, ncb_cmd_cplt ) );

            InsertTailList( &LanaResetList, &prlnTmp-> leList );
        }

        else
        {
            //
            // Lana was previously reset.  Overwrite old parameters.
            //

            CopyMemory( &prlnTmp-> ResetNCB, pncb, FIELD_OFFSET( NCB, ncb_cmd_cplt ) );
        }


        //
        // clear out event/post completion routine when saving the ResetNCB.
        // When this NCB is used to re-issue the reset command, there is no
        // post completion processing to be done.
        //

        prlnTmp-> ResetNCB.ncb_event = NULL;
        prlnTmp-> ResetNCB.ncb_post = NULL;

        //
        // when a reset is re-issued it will always a ASYNC command.
        //

        prlnTmp-> ResetNCB.ncb_command = pncb-> ncb_command | ASYNCH;


        LeaveCriticalSection( &ResetCS );

        break;
    }

#endif

    default:
        buffer = NULL;
        length = 0;
        break;
    }

    // NbPrintf(( "[NETAPI32] Submit pncb: %lx, event: %lx, post: %lx. \n",
    //    pncb,
    //    pncb->ncb_event,
    //    pncb->ncb_post));

    ntstatus = NtDeviceIoControlFile(
                    NB,
                    NULL,
                    PostRoutineCaller,  //  APC Routine
                    pncb,               //  APC Context
                    &pncb->u.ncb_iosb,  //  IO Status block
                    IOCTL_NB_NCB,
                    pncb,               //  InputBuffer
                    sizeof(NCB),
                    buffer,             //  Outputbuffer
                    length );

    if ((ntstatus != STATUS_SUCCESS) &&
        (ntstatus != STATUS_PENDING) &&
        (ntstatus != STATUS_HANGUP_REQUIRED)) {
        NbPrintf(( "[NETAPI32] The Netbios NtDeviceIoControlFile failed: %X\n", ntstatus ));

        NbPrintf(( "[NETAPI32] PNCB: %lx completed, status:%lx, ncb_retcode: %#04x,"
                   "ncb_cmd_cmplt: %#04x\n", pncb, ntstatus, pncb->ncb_retcode,
                   pncb-> ncb_cmd_cplt ));

        if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
            pncb->ncb_retcode = NRC_BUFLEN;
        } else {
            pncb->ncb_retcode = NRC_SYSTEM;
        }
        PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
    }

    return;

}

VOID
SpinUpAddnameThread(
    IN PNCBI pncb
    )
/*++

Routine Description:

    Spin up an another thread so that the worker thread does not block while
    the blocking fsctl is being processed.

Arguments:

    IN PNCBI pncb - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    HANDLE Threadid;
    HANDLE AddNameHandle;

    EnterCriticalSection( &Crit );
    AddNameThreadCount++;
    NtResetEvent( AddNameEvent, NULL );
    LeaveCriticalSection( &Crit );

    AddNameHandle = CreateThread(
                        NULL,   //  Standard thread attributes
                        0,      //  Use same size stack as users
                                //  application
                        SendAddNcbToDriver,
                                //  Routine to start in new thread
                        pncb,   //  Parameter to thread
                        0,      //  No special CreateFlags
                        (LPDWORD)&Threadid);

    if ( AddNameHandle == NULL ) {
        //
        //  Wait a couple of seconds just in case this is a burst
        //  of addnames and we have run out of resources creating
        //  threads. In a couple of seconds one of the other
        //  addname threads should complete.
        //

        Sleep(2000);

        AddNameHandle = CreateThread(
                        NULL,   //  Standard thread attributes
                        0,      //  Use same size stack as users
                                //  application
                        SendAddNcbToDriver,
                                //  Routine to start in new thread
                        pncb,   //  Parameter to thread
                        0,      //  No special CreateFlags
                        (LPDWORD)&Threadid);

        if ( AddNameHandle == NULL ) {

            //
            //  Retry failed. Lower the counts to their values prior to
            //  calling SpinUpAddNameThread
            //

            AddNameThreadExit();

            pncb->ncb_retcode = NRC_NORES;
            NbPrintf(( "[NETAPI32] Create Addname Worker Thread failed\n" ));
            pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
            PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
        } else {
            CloseHandle( AddNameHandle );
        }
    } else {
        CloseHandle( AddNameHandle );
    }
}

VOID
AddNameThreadExit(
    VOID
    )
/*++

Routine Description:

    Keep counts accurate so that any resets being processed by the main
    worker thread block appropriately.

Arguments:

    none.

Return Value:

    none.

--*/
{
    EnterCriticalSection( &Crit );
    AddNameThreadCount--;
    if (AddNameThreadCount == 0) {
        NtSetEvent(AddNameEvent, NULL);
    }
    LeaveCriticalSection( &Crit );
}

DWORD
SendAddNcbToDriver(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to post an addname or adapter status ensuring
    that the worker thread does not block.

Arguments:

    IN PVOID Context - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    PNCBI pncb = (PNCBI) Context;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    HANDLE LocalEvent;
    UCHAR  command;
    NTSTATUS ntstatus;
    char * buffer;
    unsigned short length;

    try {
        command = pncb->ncb_command;
        post = pncb->ncb_post;
        event = pncb->ncb_event;

        ntstatus = NtCreateEvent( &LocalEvent,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE );

        if ( !NT_SUCCESS(ntstatus) ) {
            pncb->ncb_retcode = NRC_NORES;
            NbPrintf(( "[NETAPI32] Could not create event\n" ));
            pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
            PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
            AddNameThreadExit();
            return 0;
        }

        //
        //  While the NCB is submitted the driver can modify the contents
        //  of the NCB. We will ensure that this thread waits until the addname
        //  completes before it exits.
        //

        pncb->ncb_command = pncb->ncb_command  & ~ASYNCH;

        if ( pncb->ncb_command == NCBASTAT ) {

            buffer = pncb->ncb_buffer;
            length = pncb->ncb_length;

        } else {

            ASSERT( (pncb->ncb_command == NCBADDNAME) ||
                    (pncb->ncb_command == NCBADDGRNAME) ||
                    (pncb->ncb_command == NCBASTAT) );

            buffer = NULL;
            length = 0;
        }

        ntstatus = NtDeviceIoControlFile(
                        NB,
                        LocalEvent,
                        NULL,               //  APC Routine
                        NULL,               //  APC Context
                        &pncb->u.ncb_iosb,  //  IO Status block
                        IOCTL_NB_NCB,
                        pncb,               //  InputBuffer
                        sizeof(NCB),
                        buffer,             //  Outputbuffer
                        length );

        if ((ntstatus != STATUS_SUCCESS) &&
            (ntstatus != STATUS_PENDING) &&
            (ntstatus != STATUS_HANGUP_REQUIRED)) {
            NbPrintf(( "[NETAPI32] The Netbios NtDeviceIoControlFile failed: %X\n", ntstatus ));

            if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
                pncb->ncb_retcode = NRC_BUFLEN;
            } else {
                pncb->ncb_retcode = NRC_SYSTEM;
            }
        } else {
            do {
                ntstatus = NtWaitForSingleObject(
                              LocalEvent,
                              TRUE,
                              NULL );

            } while ( (ntstatus == STATUS_USER_APC) ||
                      (ntstatus == STATUS_ALERTED) );

            ASSERT(ntstatus == STATUS_SUCCESS);
        }

        pncb->ncb_command = command;

        //  Set the flag that indicates that the NCB is now completed.
        pncb->ncb_cmd_cplt = pncb->ncb_retcode;

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent( event, NULL );
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncb );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncb ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    NtClose( LocalEvent );

    AddNameThreadExit();

    ExitThread(0);
    return 0;
}


VOID
PostRoutineCaller(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    )
/*++

Routine Description:

    This routine is supplied by SendNcbToDriver to the Io system when
    a Post routine is to be called directly.

Arguments:

    IN PVOID Context - supplies the NCB post routine to be called.

    IN PIO_STATUS_BLOCK Status.

    IN ULONG Reserved.

Return Value:

    none.

--*/
{
    PNCBI pncbi = (PNCBI) Context;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    UCHAR  command;

    try {

        if ( Status->Status == STATUS_HANGUP_REQUIRED ) {
            HangupConnection( pncbi );
        }

        //
        //  Save the command, post routine and the handle to the event so that if the other thread is
        //  polling the cmd_cplt flag or the event awaiting completion and immediately trashes
        //  the NCB, we behave appropriately.
        //
        post = pncbi->ncb_post;
        event = pncbi->ncb_event;
        command = pncbi->ncb_command;

        //  Set the flag that indicates that the NCB is now completed.
        pncbi->ncb_cmd_cplt = pncbi->ncb_retcode;

        //
        // NCB may be queued again
        //

        EnterCriticalSection( &Crit );
        pncbi->ncb_reserved = 0;
        LeaveCriticalSection( &Crit );

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent( event, NULL );
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncbi );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncbi ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    UNREFERENCED_PARAMETER( Reserved );
}

VOID
ChainSendPostRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    )
/*++

Routine Description:

    This routine is supplied by SendNcbToDriver to the Io system when
    a chain send ncb is being processed. When the send is complete,
    this routine deletes the BigBuffer used to hold the two parts of
    the chain send. It then calls a post routine if the user supplied one.

Arguments:

    IN PVOID Context - supplies the NCB post routine to be called.

    IN PIO_STATUS_BLOCK Status.

    IN ULONG Reserved.

Return Value:

    none.

--*/
{
    PNCBI pncbi = (PNCBI) Context;
    PUCHAR BigBuffer;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    UCHAR  command;

    BigBuffer = pncbi->ncb_buffer;

    try {

        //  Restore the users NCB contents.
        RtlMoveMemory(
            &pncbi->ncb_buffer,
            BigBuffer,
            sizeof(pncbi->ncb_buffer));

        NbPrintf(( "[NETAPI32] ChainSendPostRoutine PNCB: %lx, Status: %X\n", pncbi, Status->Status ));
        DisplayNcb( pncbi );

        if ( Status->Status == STATUS_HANGUP_REQUIRED ) {
            HangupConnection( pncbi );
        }

        //
        //  Save the command, post routine and the handle to the event so that if the other thread is
        //  polling the cmd_cplt flag or the event awaiting completion and immediately trashes
        //  the NCB, we behave appropriately.
        //
        post = pncbi->ncb_post;
        event = pncbi->ncb_event;
        command = pncbi->ncb_command;

        //  Set the flag that indicates that the NCB is now completed.
        pncbi->ncb_cmd_cplt = pncbi->ncb_retcode;

        //
        // NCB may be queued again
        //

        EnterCriticalSection( &Crit );
        pncbi->ncb_reserved = 0;
        LeaveCriticalSection( &Crit );

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent(event, NULL);
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncbi );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncbi ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    RtlFreeHeap( RtlProcessHeap(), 0, BigBuffer);


    UNREFERENCED_PARAMETER( Reserved );
}

VOID
HangupConnection(
    PNCBI pUserNcb
    )
/*++

Routine Description:

    This routine generates a hangup for the connection. This allows orderly
    cleanup of the connection block in the driver.

    The return value from the hangup is not used. If the hangup overlaps with
    a reset or a hangup then the hangup will have no effect.

    The user application is unaware that this operation is being performed.

Arguments:

    IN PNCBI pUserNcb - Identifies the connection to be hung up.

Return Value:

    none.

--*/
{
    NCBI ncbi;
    NTSTATUS Status;

    RtlZeroMemory( &ncbi, sizeof (NCB) );
    ncbi.ncb_command = NCBHANGUP;
    ncbi.ncb_lsn = pUserNcb->ncb_lsn;
    ncbi.ncb_lana_num = pUserNcb->ncb_lana_num;
    ncbi.ncb_retcode = ncbi.ncb_cmd_cplt = NRC_PENDING;

    Status = NtCreateEvent( &ncbi.ncb_event,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE );

    if ( !NT_SUCCESS(Status) ) {
        //
        //  Failed to create event. Cleanup of the Cb will have to wait until
        //  the user decides to do another request or exits.
        //
        NbPrintf(( "[NETAPI32] Hangup Session PNCBI: %lx failed to create event!\n" ));
        return;
    }

    Status = NtDeviceIoControlFile(
        NB,
        ncbi.ncb_event,
        NULL,               //  APC Routine
        NULL,               //  APC Context
        &ncbi.u.ncb_iosb,   //  IO Status block
        IOCTL_NB_NCB,
        &ncbi,              //  InputBuffer
        sizeof(NCB),
        NULL,               //  Outputbuffer
        0 );

    //
    //  We must always wait to allow the Apc to fire
    //

    do {
        Status = NtWaitForSingleObject(
            ncbi.ncb_event,
            TRUE,
            NULL );

    } while ( (Status == STATUS_USER_APC) ||
              (Status == STATUS_ALERTED) );

    ASSERT(Status == STATUS_SUCCESS);

    if (! NT_SUCCESS(Status)) {
        NbPrintf(( "[NETAPI32] The Netbios NtWaitForSingleObject failed: %X\n", Status ));
    }

    NtClose( ncbi.ncb_event );

}

BOOLEAN
NetbiosInitialize(
    HMODULE hModule
    )
/*++

Routine Description:

    This routine is called each time a process that uses netapi.dll
    starts up.

Arguments:

    IN HMODULE hModule - Handle to module instance (netapi32.dll)

Return Value:

    TRUE if initialized successfully, FALSE otherwise.

--*/
{

    Initialized = FALSE;
    WorkerHandle = NULL;
    __try {
        InitializeCriticalSection( &Crit );
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return (FALSE);

    }

#if AUTO_RESET

    __try {
        InitializeCriticalSection( &ResetCS );
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DeleteCriticalSection( &Crit );
        return (FALSE);

    }

    InitializeListHead( &LanaResetList );
    RtlZeroMemory( &OutputNCB, sizeof( NCB ) );

#endif

    g_hModule = hModule;

    return (TRUE);

}

VOID
NetbiosDelete(
    VOID
    )
/*++

Routine Description:

    This routine is called each time a process that uses netapi.dll
    Exits. It resets all lana numbers that could have been used by this
    process. This will cause all Irp's in the system to be completed
    because all the Connection and Address handles will be closed tidily.

Arguments:

    none.

Return Value:

    none.

--*/
{

#if AUTO_RESET

    PLIST_ENTRY ple;
    PRESET_LANA_NCB prln;

    while ( !IsListEmpty( &LanaResetList ) )
    {
        ple = RemoveHeadList( &LanaResetList );

        prln = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

        HeapFree( GetProcessHeap(), 0, prln );
    }

    DeleteCriticalSection( &ResetCS );

#endif

    DeleteCriticalSection( &Crit );
    if ( Initialized == FALSE ) {
        //  This process did not use Netbios.
        return;
    }

    NtClose(NB);
}



#if AUTO_RESET

VOID
ResetLanaAndPostListen(
)
/*++

Routine Description:

    This routine is invoked in response to new LANA being indicated to
    NETBIOS.SYS.  When this occurs the IOCTL posted by this user-mode
    component of netbios (to listen for new LANA indications) is completed.
    In response the new LANA is reset if it had previously been reset.

    In addition the routine re-posts the listen to the kernel mode
    component of netbios (NETBIOS.SYS).  An exception to this is if
    the LANA number to be reset is 255 ( MAX_LANA + 1 ).  This is a
    special case that indicates the NETBIOS.SYS is stopping and listen
    should not be reposted in this case.


Arguments:

    none.

Return Value:

    none.

--*/
{

    NTSTATUS Status;
    PRESET_LANA_NCB prln;
    PLIST_ENTRY ple, pleHead;


    NbPrintf( ("[NETAPI32] : Netbios : Entered ResetLanaAndPostListen \n") );


    //
    // Check if the LANA number is valid.
    //

    if ( OutputNCB.ncb_lana_num != ( MAX_LANA + 1 ) )
    {
        EnterCriticalSection( &ResetCS );

        //
        // find which lana needs a reset
        //

        NbPrintf( (
            "[NETAPI32] : Netbios : Looking for Lana %d\n", OutputNCB.ncb_lana_num
            ) );


        pleHead = &LanaResetList;

        for ( ple = pleHead-> Flink; ple != pleHead; ple = ple-> Flink )
        {
            prln = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

            if ( prln-> ResetNCB.ncb_lana_num == OutputNCB.ncb_lana_num )
            {
                //
                // found Lana that needs reseting
                //

                break;
            }
        }


        //
        // if found send reset
        //

        if ( ple != pleHead )
        {
            //
            // Send Reset to NETBIOS.SYS
            //

            QueueToWorker( (PNCBI) &prln-> ResetNCB );
        }

        else
        {
            NbPrintf( (
                "[NETAPI32] : Netbios : Lana %d not found\n",
                OutputNCB.ncb_lana_num
                ) );
        }

        LeaveCriticalSection( &ResetCS );

        OutputNCB.ncb_lana_num = 0;


        //
        // post listen again
        //

        Status = NtDeviceIoControlFile(
                        NB,
                        LanaResetEvent,
                        NULL, NULL,
                        &ResetStatusBlock,
                        IOCTL_NB_REGISTER_RESET,
                        NULL, 0,
                        (PVOID) &OutputNCB, sizeof( NCB )
                        );

        if ( ( Status != STATUS_PENDING ) &&
             ( Status != STATUS_SUCCESS ) )
        {
            //
            // Failed to register reset notification.
            //

            NbPrintf(
                ("[NETAPI32] : Netbios : Failed to register Reset event\n" )
                );
        }
    }

    else
    {
        NbPrintf( (
            "[NETAPI32] : Netbios : LANA 255 indicated, no Listen posted\n"
            ) )
    }

    NbPrintf( ("[NETAPI32] : Netbios : Leaving ResetLanaAndPostListen \n") );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\netb.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netbios.h

Abstract:

    This is the main include file for the component of netbios that runs
    in the user process.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nb30.h>
#include <nb30p.h>
#include <netbios.h>

//
//  Internal version of the ncb layout that uses the reserved area to hold
//  the list entry when passing ncb's to the worker thread and the IO status
//  block used when the ncb is passed to the netbios device driver.
//

#include <packon.h>

        struct _CHAIN_SEND {
            WORD ncb_length2;
            PUCHAR ncb_buffer2;
        };

#include <packoff.h>

//
//  Use packing to ensure that the cu union is not forced to word alignment.
//  All elements of this structure are naturally aligned.
//

typedef struct _NCBI {
    UCHAR   ncb_command;            /* command code                   */
    volatile UCHAR   ncb_retcode;   /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    union {
        UCHAR   ncb_callname[NCBNAMSZ];/* blank-padded name of remote */
        struct _CHAIN_SEND ncb_chain;
    } cu;
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * );
                                    /* POST routine address           */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    volatile UCHAR   ncb_cmd_cplt;  /* 0xff => commmand pending       */

    // Make driver specific use of the reserved area of the NCB.
    WORD    ncb_reserved;           /* return to natural alignment    */
    union {
        LIST_ENTRY      ncb_next;   /* queued to worker thread        */
        IO_STATUS_BLOCK ncb_iosb;   /* used for Nt I/O interface      */
    } u;

    HANDLE          ncb_event;      /* HANDLE to Win32 event          */
    } NCBI, *PNCBI;

C_ASSERT(FIELD_OFFSET(NCBI, cu) == FIELD_OFFSET(NCB, ncb_callname));
C_ASSERT(FIELD_OFFSET(NCBI, ncb_event) == FIELD_OFFSET(NCB, ncb_event));
C_ASSERT(FIELD_OFFSET(NCBI, ncb_name) == FIELD_OFFSET(NCB, ncb_name));


#if AUTO_RESET

typedef struct _RESET_LANA_NCB {
    LIST_ENTRY  leList;
    NCB         ResetNCB;
    } RESET_LANA_NCB, *PRESET_LANA_NCB;

#endif

VOID
QueueToWorker(
    IN PNCBI pncb
    );

DWORD
NetbiosWorker(
    IN LPVOID Parameter
    );

DWORD
NetbiosWaiter(
    IN LPVOID Parameter
    );
    
VOID
SendNcbToDriver(
    IN PNCBI pncb
    );

VOID
PostRoutineCaller(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    );

VOID
ChainSendPostRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    );

VOID
HangupConnection(
    PNCBI pUserNcb
    );



//
// debugging info for tracking the workqueue corruption
//

typedef struct _NCB_INFO {
    PNCBI   pNcbi;
    NCBI    Ncb;
    DWORD   dwTimeQueued;
    DWORD   dwQueuedByThread;
    DWORD   dwReserved;
} NCB_INFO, *PNCB_INFO;

extern NCB_INFO g_QueuedHistory[];
extern DWORD g_dwNextQHEntry;

extern NCB_INFO g_DeQueuedHistory[];
extern DWORD g_dwNextDQHEntry;

extern NCB_INFO g_SyncCmdsHistory[];
extern DWORD g_dwNextSCEntry;


#define ADD_NEW_ENTRY(Hist, Index, pNcb)                        \
{                                                               \
    (Hist)[(Index)].pNcbi = (pNcb);                              \
    (Hist)[(Index)].Ncb = *(pNcb);                              \
    (Hist)[(Index)].dwTimeQueued = GetTickCount();              \
    (Hist)[(Index)].dwQueuedByThread = GetCurrentThreadId();    \
    Index = ((Index) + 1) % 16;                                \
}

#define ADD_QUEUE_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_QueuedHistory, g_dwNextQHEntry, pNcb)

#define ADD_DEQUEUE_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_DeQueuedHistory, g_dwNextDQHEntry, pNcb)

#define ADD_SYNCCMD_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_SyncCmdsHistory, g_dwNextSCEntry, pNcb)


#if DBG

VOID
DisplayNcb(
    IN PNCBI pncbi
    );

#define NbPrintf(String) NbPrint String;

VOID
NbPrint(
    char *Format,
    ...
    );

#else

//  Dispose of debug statements in non-debug builds.
#define DisplayNcb( pncb ) {};

#define NbPrintf( String ) {};

#endif
//  End of Debug related definitions

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\tnetcall.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetcall.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

    Jerome Nantel (w-jeromn) 23 August 1991

        Add Event Signaling testing

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_CONSOLE_APP
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "
#define TIMEOUT 60000   // Time out for wait, set at 1 minute
#define Hi  "Come here Dave, I need you"
#define SEND 1
#define RCV  0


NCB myncb[2];
CHAR Buffer[16384+1024];
CHAR Buffer2[16384+1024];
ULONG lanNumber=0;
UCHAR lsn;
HANDLE twoEvent[2];
int count;  // frame count
BOOLEAN verbose=FALSE;
BOOLEAN rxany=FALSE;
BOOLEAN rxanyany=FALSE;
BOOLEAN input=TRUE;
BOOLEAN output=TRUE;
int QuietCount = 50;
UCHAR name_number;

VOID
usage (
    VOID
    )
{
    printf("usage: tsrnetb -c|l [-[a|r]] [-[i|o]] [-n:lan number][-h] <remote computername> <my computername>\n");
    printf("                 -c specifies calling, -l specifies listener\n");
    printf("                 -a specifies rx any, any, -r specifies rx any\n");
    printf("                 -i specifies rx only, -o specifies tx only\n");
    printf("                 -d specifies delay with alerts on each tx/rx\n");
    printf("                 -n specifies the lan number (0 is the default)\n");
    printf("                 -h specifies that addresses are hexadecimal numbers \n");
    printf("                     rather than strings.\n");
    printf("                 -g use group name for the connection\n");
    printf("                 -v verbose\n");
    printf("                 -s silent\n");
    printf("                 -t token ring, lan status alert (names ignored)\n");
    printf("                 -q quiet (print r every 50 receives\n");
    printf("                 final two arguments are the remote and local computer names.\n");
}

VOID
ClearNcb( PNCB pncb ) {
    RtlZeroMemory( pncb , sizeof (NCB) );
    RtlMoveMemory( pncb->ncb_name,     SPACES, sizeof(SPACES)-1 );
    RtlMoveMemory( pncb->ncb_callname, SPACES, sizeof(SPACES)-1 );
}

VOID StartSend()
{

    ClearNcb( &(myncb[0]) );
    if ( output == FALSE ) {
        ResetEvent(twoEvent[SEND]);
        return;
    }
    myncb[0].ncb_command = NCBSEND | ASYNCH;
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_buffer = Buffer;
    myncb[0].ncb_lsn = lsn;
    myncb[0].ncb_event = twoEvent[SEND];
    RtlMoveMemory( Buffer, Hi, sizeof( Hi ));
    sprintf( Buffer, "%s %d\n", Hi, count );
    if ( verbose == TRUE ) {
        printf( "Tx: %s", Buffer );
    }
    count++;
    myncb[0].ncb_length = (WORD)sizeof(Buffer);
    Netbios( &(myncb[0]) );

}

VOID StartRcv()
{
    ClearNcb( &(myncb[1]) );
    if ( input == FALSE ) {
        ResetEvent(twoEvent[RCV]);
        return;
    }
    if ((rxany == FALSE) &&
        (rxanyany == FALSE)) {
        myncb[1].ncb_command = NCBRECV | ASYNCH;
    } else {
        myncb[1].ncb_command = NCBRECVANY | ASYNCH;
    }
    myncb[1].ncb_lana_num = (UCHAR)lanNumber;
    myncb[1].ncb_length = sizeof( Buffer2 );
    myncb[1].ncb_buffer = Buffer2;
    if ( rxany == FALSE ) {
        if ( rxanyany == FALSE ) {
            myncb[1].ncb_lsn = lsn;
        } else {
            myncb[1].ncb_num = 0xff;
        }
    } else{
            myncb[1].ncb_num = name_number;
    }
    myncb[1].ncb_lsn = lsn;
    myncb[1].ncb_event = twoEvent[RCV];
    Netbios( &(myncb[1]) );
}

int
_cdecl
main (argc, argv)
   int argc;
   char *argv[];
{

    int i,j;
    int rcvCount=0;
    CHAR localName[17];
    CHAR remoteName[17];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    BOOLEAN listen=FALSE;
    BOOLEAN quiet=FALSE;
    BOOLEAN delay=FALSE;
    BOOLEAN group=FALSE;
    BOOLEAN silent=FALSE;
    BOOLEAN lanalert=FALSE;
    DWORD tevent;
    BOOLEAN ttwo=FALSE;

    if ( argc < 4 || argc > 9) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            case 'c':
                listen = FALSE;
                break;
            case 'a':
                rxany = TRUE;
                break;
            case 'r':
                rxanyany = TRUE;
                break;
            case 'i':
                output = FALSE;
                break;
            case 'o':
                input = FALSE;
                break;
            case 'd':
                delay = FALSE;
                break;
            case 'l':
                listen = TRUE;
                break;
            case 'q':
                quiet = TRUE;
                silent = TRUE;
                break;
            case 'g':
                group = TRUE;
                break;
            case 'v':
                verbose = TRUE;
                break;
            case 's':
                silent = TRUE;
                break;
            case 't':
                lanalert = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlenA( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlenA( argv[i] ));
            }

        }
    }
    if ((rxany == TRUE) &&
        (rxanyany == TRUE)) {
        usage();
        return 1;
    }
    if ((input == FALSE) &&
        (output == FALSE)) {
        usage();
        return 1;
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    for ( i=0; i<2; i++ ) {
        if (( twoEvent[i] = CreateEvent( NULL, TRUE, FALSE, NULL )) == NULL ) {
            /* Could not get event handle.  Abort */
            printf("Could not test event signaling.\n");
            return 1;
        }
    }

    printf( "Starting NetBios\n" );

    //   Reset
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBRESET;
    myncb[0].ncb_lsn = 0;           // Request resources
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_callname[0] = 0;   // 16 sessions
    myncb[0].ncb_callname[1] = 0;   // 16 commands
    myncb[0].ncb_callname[2] = 0;   // 8 names
    myncb[0].ncb_callname[3] = 0;   // Don't want the reserved address
    Netbios( &(myncb[0]) );

    if ( lanalert == TRUE ) {
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBLANSTALERT;
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        Netbios( &(myncb[0]) );
        if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
            printf( " LanStatusAlert failed %x", myncb[1].ncb_retcode);
        }
        return 0;
    }

    //   Add name
    ClearNcb( &(myncb[0]) );
    if ( group == FALSE) {
        myncb[0].ncb_command = NCBADDNAME;
    } else {
        myncb[0].ncb_command = NCBADDGRNAME;
    }
    RtlMoveMemory( myncb[0].ncb_name, localName, 16);
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &(myncb[0]) );
    name_number = myncb[0].ncb_num;

    if ( listen == FALSE ) {
        //   Call
        printf( "\nStarting Call " );
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBCALL | ASYNCH;
        RtlMoveMemory( myncb[0].ncb_name, localName, 16);
        RtlMoveMemory( myncb[0].ncb_callname,remoteName, 16);
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        myncb[0].ncb_sto = myncb[0].ncb_rto = 120; // 120*500 milliseconds timeout
        myncb[0].ncb_num = name_number;
        myncb[0].ncb_event = twoEvent[0];
        while ( TRUE) {
            printf("\nStart NCB CALL ");
            Netbios( &(myncb[0]) );
            printf( " Call returned " );
            if ( myncb[0].ncb_cmd_cplt == NRC_PENDING ) {
                if ( WaitForSingleObject( twoEvent[0], TIMEOUT ) ) {
                    // Wait timed out, no return
                    printf("ERROR: Wait timed out, event not signaled.\n");
                }
            }
            printf( " Call completed\n" );
            lsn = myncb[0].ncb_lsn;

            if ( myncb[0].ncb_retcode == NRC_GOODRET ) {
                // Success
                break;
            }
            printf("Call completed with error %lx, retry", myncb[0].ncb_retcode );
            Sleep(5);
        }
    } else {
        printf( "\nStarting Listen " );

        //   Listen
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBLISTEN | ASYNCH;
        RtlMoveMemory( myncb[0].ncb_name, localName, 16);
        RtlMoveMemory( myncb[0].ncb_callname, remoteName, 16);
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        myncb[0].ncb_sto = myncb[0].ncb_rto = 120; // 120*500 milliseconds timeout
        myncb[0].ncb_num = name_number;
        Netbios( &(myncb[0]) );
        printf( "Listen returned " );
        while ( myncb[0].ncb_cmd_cplt == NRC_PENDING ) {
            printf( "." );
            Sleep(500);

        }
        printf( " Listen completed\n" );

        if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
            printf("ERROR: Could not establish session.\n");
            return 1;
        }

        lsn = myncb[0].ncb_lsn;

    }

    count = 0;
    StartSend();
    StartRcv();

    while ( TRUE ) {

        tevent = WaitForMultipleObjects(2, twoEvent, FALSE, TIMEOUT);

        switch ( tevent ) {
        case SEND :
            // Send completed, start a new one.
            if ( silent == FALSE ) {
                printf("S");
            }
            if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
                printf( "Send failed %x", myncb[0].ncb_retcode);
                goto Cleanup;
            }
            if ( delay == TRUE ) {
                //  Wait alertable - useful for debugging APC problems.
                NtWaitForSingleObject(
                    twoEvent[SEND],
                    TRUE,
                    NULL );
            }

            StartSend();
            break;

        case RCV :
            if ( silent == FALSE ) {
                printf("R");
            }
            if ( (quiet == TRUE) && (QuietCount-- == 0) ) {
                printf("R");
                QuietCount = 50;
            }
            if ( myncb[1].ncb_retcode != NRC_GOODRET ) {
                printf( " Receive failed %x", myncb[1].ncb_retcode);
                goto Cleanup;
            } else {
                if ( verbose == TRUE ) {
                    printf( "Rx: %s", Buffer2 );
                }
            }
            // Receive completed, start a new one.

            if ( delay == TRUE ) {
                //  Wait alertable
                NtWaitForSingleObject(
                    twoEvent[RCV],
                    TRUE,
                    NULL );
            }

            StartRcv();
            rcvCount++;
            break;

        default:
            printf("WARNING: Wait timed out, no event signaled.\n");
            break;
        }

    }
Cleanup:
    //  Hangup
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBHANGUP;
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_lsn = lsn;
    Netbios( &(myncb[0]) );
    if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
        printf( " Hangup failed %x", myncb[1].ncb_retcode);
    }

    //   Reset
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBRESET;
    myncb[0].ncb_lsn = 1;           // Free resources
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &(myncb[0]) );
    printf( "Ending NetBios\n" );

    // Close handles
    CloseHandle( twoEvent[0] );
    CloseHandle( twoEvent[1] );

    return 0;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\address.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    address object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//nclude <zwapi.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbAddName)
#pragma alloc_text(PAGE, NbOpenAddress)
#pragma alloc_text(PAGE, NbAddressClose)
#pragma alloc_text(PAGE, NbSetEventHandler)
#pragma alloc_text(PAGE, SubmitTdiRequest)
#pragma alloc_text(PAGE, NewAb)
#endif

NTSTATUS
NbAddName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to add a name to the name table so that the
    name is available for listens etc. If the name is already in the table
    then reject the request. If an error is found by NewAb then it is
    recorded directly in the NCB.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation. This is always
    STATUS_SUCCESS because the operations called by this routine are all
    synchronous. We must never return an error status since this would
    prevent the ncb from being copied back.

--*/

{

    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PSZ Name = pdncb->ncb_name;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint(( "\n** AAAAADDDDDDName *** pdncb %lx\n", pdncb ));
    }

    //
    //  NewAb is used in file.c to add the reserved name. Check here
    //  for an application using a special name.
    //

    if (( pdncb->ncb_name[0] == '*' ) ||
        ( pdncb->ncb_name[0] == '\0' )) {
        NCB_COMPLETE( pdncb, NRC_NOWILD );
    } else {
        NewAb( IrpSp, pdncb );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NbDeleteName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to delete a name. To perform this operation
    the AddressHandle to the transport is closed and the Address Block
    is deleted.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("[NETBIOS] NbDeleteName : FCB : %lx lana: %lx Address:\n", 
                   pfcb, pdncb->ncb_lana_num ));
        NbFormattedDump( (PUCHAR) pdncb->ncb_name, sizeof(NAME) );
    }

    if (( pdncb->ncb_name[0] == '*' ) ||
        ( pdncb->ncb_name[0] == '\0' )) {
        NCB_COMPLETE( pdncb, NRC_NOWILD );
        return STATUS_SUCCESS;
    }

    LOCK( pfcb, OldIrql );

    ppab = FindAb( pfcb, pdncb, FALSE );

    if ( ppab != NULL ) {

        if (( (*ppab)->NameNumber == 0) ||
            ( (*ppab)->NameNumber == MAXIMUM_ADDRESS)) {
                UNLOCK( pfcb, OldIrql );
                NCB_COMPLETE( pdncb, NRC_NAMERR );
        } else {

            if ( ((*ppab)->Status & 0x7) != REGISTERED) {
                    UNLOCK( pfcb, OldIrql );
                    NCB_COMPLETE( pdncb, NRC_TOOMANY ); // Try later.
            } else {
                if ( FindActiveSession( pfcb, pdncb, ppab ) == TRUE ) {
                    // When all the sessions close, the name will be deleted.
                    UNLOCK_SPINLOCK( pfcb, OldIrql );
                    CleanupAb( ppab, FALSE );
                    UNLOCK_RESOURCE( pfcb );
                    NCB_COMPLETE( pdncb, NRC_ACTSES );
                } else {
                    UNLOCK_SPINLOCK( pfcb, OldIrql );
                    CleanupAb( ppab, TRUE );
                    UNLOCK_RESOURCE( pfcb );
                    NCB_COMPLETE( pdncb, NRC_GOODRET );
                }
            }
        }
    } else {
        UNLOCK( pfcb, OldIrql );
        //  FindAb has already set the completion code.
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NbOpenAddress (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PUNICODE_STRING pusDeviceName,
    IN UCHAR LanNumber,
    IN PDNCB pdncb OPTIONAL
    )
/*++

Routine Description:

    This routine uses the transport to create an entry in the NetBIOS
    table with the value of "Name". It will re-use an existing entry if
    "Name" already exists.

    Note: This synchronous call may take a number of seconds. If this matters
    then the caller should specify ASYNCH and a post routine so that it is
    performed by the thread created by the netbios dll routines.

    If pdncb == NULL then a special handle is returned that is capable of
    administering the transport. For example to execute an ASTAT.

Arguments:

    FileHandle - Pointer to where the filehandle is to be returned.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - supplies the device names for the lana number.

    LanNumber - supplies the network adapter to be opened.

    pdncb - Pointer to either an NCB or NULL.

Return Value:

    The function value is the status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaLength;
    TA_NETBIOS_ADDRESS Address;
    ULONG ShareAccess;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();


    IF_NBDBG (NB_DEBUG_ADDRESS) {
        if ( pdncb ) {
            NbPrint( ("NbOpenAddress: Opening lana: %lx, Address:\n",
                LanNumber ));
            NbFormattedDump( pdncb->ncb_name, NCBNAMSZ );
            if ( pdncb->ncb_command == NCBADDBROADCAST ) {
                NbPrint (("NbOpenAddress: Opening Broadcast Address length: %x\n",
                    pdncb->ncb_length));
            }
        } else {
            NbPrint( ("NbOpenAddress: Opening lana: %lx Control Channel\n",
                LanNumber));
        }
    }

    InitializeObjectAttributes (
        &ObjectAttributes,
        pusDeviceName,
        0,
        NULL,
        NULL);

    if ( ARGUMENT_PRESENT( pdncb ) ) {

        EaLength =  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TA_NETBIOS_ADDRESS); // EA length

        EaBuffer = (PFILE_FULL_EA_INFORMATION)
            ExAllocatePoolWithTag( NonPagedPool, EaLength, 'eSBN' );

        if (EaBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        EaBuffer->NextEntryOffset = 0;
        EaBuffer->Flags = 0;
        EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

        EaBuffer->EaValueLength = sizeof (TA_NETBIOS_ADDRESS);

        RtlMoveMemory( EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength + 1 );

        //
        // Create a copy of the NETBIOS address descriptor in a local
        // first, in order to avoid alignment problems.
        //

        Address.TAAddressCount = 1;
        Address.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;

        if ( pdncb->ncb_command == NCBADDBROADCAST ) {
            Address.Address[0].AddressLength = pdncb->ncb_length;
        } else {
            Address.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
        }

        if (((pdncb->ncb_command & ~ASYNCH) == NCBADDNAME) ||
            ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME)) {

            ShareAccess = 0;    //  Exclusive access


            if ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME) {
                Address.Address[0].Address[0].NetbiosNameType =
                    TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            } else {
                Address.Address[0].Address[0].NetbiosNameType =
                    TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            }

        } else {
            if ((pdncb->ncb_command & ~ASYNCH) == NCBADDRESERVED) {
                //
                //  NB30 non-conformance!
                //  We allow multiple applications to use name number 1. This is so that we can
                //  conveniently run multiple dos applications which all have address 1.
                //

                ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access
                Address.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            } else {
                //  Group names and Broadcast addresses.
                ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access

                if ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDGRNAME) {
                    Address.Address[0].Address[0].NetbiosNameType =
                        TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP;
                } else {
                    Address.Address[0].Address[0].NetbiosNameType =
                        TDI_ADDRESS_NETBIOS_TYPE_GROUP;
                }
            }
        }

        RtlMoveMemory(
            Address.Address[0].Address[0].NetbiosName,
            pdncb->ncb_name,
            NCBNAMSZ
            );

        RtlMoveMemory (
            &EaBuffer->EaName[EaBuffer->EaNameLength + 1],
            &Address,
            sizeof(TA_NETBIOS_ADDRESS)
            );

    } else {
        ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access
        EaBuffer = NULL;
        EaLength = 0;
    }

    if (PsGetCurrentProcess() != NbFspProcess) {
	
		KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }

    IF_NBDBG( NB_DEBUG_ADDRESS )
    {
        if ( ARGUMENT_PRESENT( pdncb ) )
        {
            NbPrint( ( 
                "NbOpenAddress : Create file invoked on lana for : %d\n",
                pdncb-> ncb_lana_num
                ) );
        
            NbFormattedDump( pdncb-> ncb_name, NCBNAMSZ );
        }
        
        else
        {
            NbPrint( ( 
                "NbOpenAddress : Create file invoked for \n"
                ) );
        
            NbPrint( ( "Control channel\n" ) );
        }
    }
    
    Status = ZwCreateFile (
                 FileHandle,
                 GENERIC_READ | GENERIC_WRITE, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // Allocation size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 ShareAccess,
                 FILE_CREATE,
                 0,                     // create options.
                 EaBuffer,
                 EaLength
                 );

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    //  Obtain a referenced pointer to the file object.
    if (NT_SUCCESS( Status )) {
        Status = ObReferenceObjectByHandle (
                                    *FileHandle,
                                    0,
                                    NULL,
                                    KernelMode,
                                    Object,
                                    NULL
                                    );

        if (!NT_SUCCESS(Status)) {
            NTSTATUS localstatus;

            IF_NBDBG( NB_DEBUG_ADDRESS )
            {
                if ( ARGUMENT_PRESENT( pdncb ) )
                {
                    NbPrint( ( 
                        "NbOpenAddress : error : file closed on lana %d for \n",
                        pdncb-> ncb_lana_num
                    ) );
            
                    NbFormattedDump( pdncb-> ncb_name, NCBNAMSZ );
                }
                else
                {
                    NbPrint( ( 
                        "NbOpenAddress : error : file closed on lana for \n"
                    ) );
                    
                    NbPrint( ( "Control channel\n" ) );
                }
            }
            
            localstatus = ZwClose( *FileHandle);

            ASSERT(NT_SUCCESS(localstatus));

            *FileHandle = NULL;
        }
    }

    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    if ( EaBuffer ) {
        ExFreePool( EaBuffer );
    }

    IF_NBDBG (NB_DEBUG_ADDRESS ) {
        NbPrint( ("NbOpenAddress Status:%X, IoStatus:%X.\n", Status, IoStatusBlock.Status));
    }

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS( Status )) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("NbOpenAddress:  FAILURE, status code=%X.\n", Status));
        }
        return Status;
    }

    return Status;
}

PAB
NewAb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    )

/*++

Routine Description:

Arguments:
`
    IrpSp - Pointer to current IRP stack frame.

    pdncb - Pointer to the ncb being processed.

Return Value:

    The new Cb.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PAB pab;
    PFCB pfcb = FileObject->FsContext2;
    PLANA_INFO plana;
    int index;
    ULONG NameLength;
    UNICODE_STRING  usDeviceName;
    HANDLE          hFileHandle = NULL;
    PFILE_OBJECT    pfoFileObject = NULL;
    

    PAGED_CODE();


    RtlInitUnicodeString( &usDeviceName, NULL);
    

    KeEnterCriticalRegion();
    
    //  Prevent resets while we add the name
    ExAcquireResourceSharedLite ( &pfcb->AddResource, TRUE );

    LOCK_RESOURCE( pfcb );

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("[NETBIOS] NewAb: FCB : %lx lana: %lx Address:\n", pfcb, 
                   pdncb->ncb_lana_num ));
        NbFormattedDump( (PUCHAR) pdncb->ncb_name, sizeof(NAME) );
    }

    if ( ( pfcb == NULL ) ||
         ( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].MaximumLength == 0 ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].Buffer == NULL ) ) {
        //  no such adapter
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }

    if ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) {
        //  adapter not installed
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }
    
    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    if ( pdncb->ncb_command == NCBADDRESERVED ) {
        index = 1;
        NameLength = NCBNAMSZ;
    } else {
        if ( pdncb->ncb_command == NCBADDBROADCAST ) {
            index = MAXIMUM_ADDRESS;
            NameLength = pdncb->ncb_length;
        } else {

            //
            //  Ensure that the user has not added too many names or attempted to
            //  add the same name twice. If not then scan the address table looking
            //  for the next available slot.
            //

            IF_NBDBG (NB_DEBUG_ADDRESS) {
                NbPrint( ("NewAb: AddressCount: %lx, MaximumAddress %lx\n",
                    plana->AddressCount,
                    plana->MaximumAddresses ));
            }

            //
            //  If the application has added the number of names requested
            //  or has filled the table, refuse the request.
            //

            if ( plana->MaximumAddresses == plana->AddressCount) {

                NCB_COMPLETE( pdncb, NRC_NAMTFUL );
                UNLOCK_RESOURCE( pfcb );
                ExReleaseResourceLite( &pfcb->AddResource );
                KeLeaveCriticalRegion();
                return NULL;
            }

            //
            //  Scan the name table and ensure that the name isn't already
            //  there.
            //

            if (( FindAb(pfcb, pdncb, FALSE) != NULL) ||
                ( pdncb->ncb_retcode != NRC_NOWILD)) {

                //
                //  error is set to DUPNAME iff FindAb found the name
                //  in all other cases FindAb sets the error code and sets
                //  returns the address block.
                //

                NCB_COMPLETE( pdncb, NRC_DUPNAME );
                UNLOCK_RESOURCE( pfcb );
                ExReleaseResourceLite( &pfcb->AddResource );
                KeLeaveCriticalRegion();
                return NULL;
            }

            //
            //  Find the appropriate name number to use.
            //

            index = plana->NextAddress;
            while ( plana->AddressBlocks[index] != NULL ) {
                index++;
                if ( index == MAXIMUM_ADDRESS ) {
                    index = 2;
                }
            }

            //  reset retcode so that NCB_COMPLETE will process the NCB.
            pdncb->ncb_retcode = NRC_PENDING;

            NameLength = NCBNAMSZ;
        }
    }

    if ( plana->AddressBlocks[index] != NULL ) {
        NCB_COMPLETE( pdncb, NRC_DUPNAME );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }
    pab = ExAllocatePoolWithTag (NonPagedPool, sizeof(AB), 'aSBN');

    if (pab==NULL) {
        NCB_COMPLETE( pdncb, NbMakeNbError( STATUS_INSUFFICIENT_RESOURCES ) );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }

    pab->AddressHandle = NULL;
    pab->AddressObject = NULL;
    pab->DeviceObject = NULL;
    pab->NameNumber = (UCHAR)index;
    pab->pLana = plana;
    InitializeListHead(&pab->ReceiveAnyList);
    InitializeListHead(&pab->ReceiveDatagramList);
    InitializeListHead(&pab->ReceiveBroadcastDatagramList);
    pab->NameLength = (UCHAR)NameLength;
    RtlMoveMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ);

    if (((pdncb->ncb_command & ~ASYNCH) == NCBADDNAME) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME)) {

        pab->Status = REGISTERING | UNIQUE_NAME;

    } else {

        pab->Status = REGISTERING | GROUP_NAME;

    }

    pab->CurrentUsers = 1;
    plana->AddressBlocks[index] = pab;
    pab->Signature = AB_SIGNATURE;


    if (( pdncb->ncb_command != NCBADDRESERVED ) &&
        ( pdncb->ncb_command != NCBADDBROADCAST )) {
        plana->AddressCount++;
        plana->NextAddress = index + 1;
        if ( plana->NextAddress == MAXIMUM_ADDRESS ) {
            plana->NextAddress = 2;
        }
    }


    Status = AllocateAndCopyUnicodeString( 
                &usDeviceName, &pfcb-> pDriverName[ pdncb-> ncb_lana_num ]
             );
    
    if ( !NT_SUCCESS( Status ) )
    {
        NCB_COMPLETE( pdncb, NRC_NORESOURCES);
        
        ExFreePool( pab );
        plana->AddressBlocks[index] = NULL;

        if (( pdncb->ncb_command != NCBADDRESERVED ) &&
            ( pdncb->ncb_command != NCBADDBROADCAST )) {

            plana->AddressCount--;
        }
        
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();

        return NULL;
    }
    
    //  Unlock so other Ncb's can be processed while adding the name.

    UNLOCK_RESOURCE( pfcb );

    Status = NbOpenAddress (
                &hFileHandle,
                (PVOID *)&pfoFileObject,
                &usDeviceName,
                pdncb->ncb_lana_num,
                pdncb
                );
    
    LOCK_RESOURCE( pfcb );

    //
    // In the interval when no locks were held it is possible that
    // the Lana could have been unbound.  Verify that Lana is still
    // present before accessing it.
    //
    
    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint(( "\n  FAILED on open of %s  %X ******\n",
                pdncb->ncb_name,
                Status ));
        }

        if ( pfcb->ppLana[pdncb->ncb_lana_num] == plana )
        {
            //
            // Lana is still available.  Do normal error processing
            //
            
            NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
            
            ExFreePool( pab );
            plana->AddressBlocks[index] = NULL;

            if (( pdncb->ncb_command != NCBADDRESERVED ) &&
                ( pdncb->ncb_command != NCBADDBROADCAST )) {

                plana->AddressCount--;
            }
        }

        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();

        if ( usDeviceName.Buffer != NULL )
        {
            ExFreePool( usDeviceName.Buffer );
        }

        return NULL;
    }

    else
    {
        //
        // NbOpenAddress succeeded.  Make sure Lana is still there.
        //

        if ( plana == pfcb->ppLana[pdncb->ncb_lana_num] )
        {
            //
            // assume if lana is uncahnged pab points to a valid address
            // block entry.  Update the fields.
            //

            pab-> AddressHandle = hFileHandle;
            pab-> AddressObject = pfoFileObject;
        }

        else
        {
            //
            // Lana presumed to be removed on account of an unbind.
            //

            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            
            UNLOCK_RESOURCE( pfcb );

            ExReleaseResourceLite( &pfcb->AddResource );
            KeLeaveCriticalRegion();

            NbAddressClose( hFileHandle, (PVOID) pfoFileObject );

            if ( usDeviceName.Buffer != NULL )
            {
                ExFreePool( usDeviceName.Buffer );
            }

            return NULL;
        }
    }

    //  Inform the application of the address number.
    pdncb->ncb_num = (UCHAR) index;

    //
    //  Register the event handlers for this address.
    //

    //  Get the address of the device object for the endpoint.

    pab->DeviceObject = IoGetRelatedDeviceObject(pab->AddressObject);

    //
    //  No connections are made using the broadcast address so don't register disconnect or
    //  receive indication handlers. The ReceiveDatagram handler will get registered if the
    //  application requests a receive broadcast datagram. This will cut down the cpu load
    //  when the application is not interested in broadcasts. We always register the error
    //  indication handler on the broadcast address because it is the only address which is
    //  always open to the transport.
    //

    if ( pdncb->ncb_command != NCBADDBROADCAST ) {
        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_RECEIVE,
                                    (PVOID)NbTdiReceiveHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_DISCONNECT,
                                    (PVOID)NbTdiDisconnectHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_RECEIVE_DATAGRAM,
                                    (PVOID)NbTdiDatagramHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        pab->ReceiveDatagramRegistered = TRUE;
    } else {
        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_ERROR,
                                    (PVOID)NbTdiErrorHandler,
                                    plana);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        pab->ReceiveDatagramRegistered = FALSE;
    }

    pab->Status |= REGISTERED;

    UNLOCK_RESOURCE( pfcb );

    ExReleaseResourceLite( &pfcb->AddResource );
    KeLeaveCriticalRegion();

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }
    
    NCB_COMPLETE( pdncb, NRC_GOODRET );

    return pab;
}

VOID
CleanupAb(
    IN PPAB ppab,
    IN BOOLEAN CloseAddress
    )
/*++

Routine Description:

    This closes the handles in the Ab and deletes the Address Block.

    During this routine we need the spinlock held to prevent an indication accessing
    a Receive while we are cancelling it.

    Note: Resource must be held before calling this routine.

Arguments:

    pab - Address of the pointer to the Ab to be destroyed.

    CloseAddress - TRUE if Address block is to be destroyed immediately.

Return Value:

    nothing.

--*/

{

    PAB pab = *ppab;
    PAB pab255;
    PFCB pfcb = (*ppab)->pLana->pFcb;
    PLANA_INFO plana = (*ppab)->pLana;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PLIST_ENTRY ReceiveEntry;

    LOCK_SPINLOCK( pfcb, OldIrql );

    ASSERT( pab->Signature == AB_SIGNATURE );
    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("CleanupAb ppab: %lx, pab: %lx, CurrentUsers: %lx, State: %x\n",
            ppab,
            pab,
            pab->CurrentUsers,
            pab->Status));

        NbFormattedDump( (PUCHAR)&pab->Name, sizeof(NAME) );
    }

    if ( (pab->Status & 0x7) != DEREGISTERED ) {
        PDNCB pdncb;

        pab->Status |= DEREGISTERED;

        //
        //  This is the first time through so cancel all the receive datagram
        //  requests for this address.


        while ( (pdncb = DequeueRequest( &pab->ReceiveDatagramList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        while ( (pdncb = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        while ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        //  The IBM Mif081 test requires ReceiveBroadcast Any with this name to be cancelled.

        pab255 = plana->AddressBlocks[MAXIMUM_ADDRESS];

        //
        // check for null pointer.  Added to fix stress bug
        //
        //  V Raman
        //
        
        if ( pab255 != NULL )
        {
            ReceiveEntry = pab255->ReceiveBroadcastDatagramList.Flink;

            while ( ReceiveEntry != &pab255->ReceiveBroadcastDatagramList ) {
            
                PLIST_ENTRY NextReceiveEntry = ReceiveEntry->Flink;

                PDNCB pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

                if ( pab->NameNumber == pdncb->ncb_num ) {
                    PIRP Irp;

                    RemoveEntryList( &pdncb->ncb_next );

                    Irp = pdncb->irp;

                    IoAcquireCancelSpinLock(&Irp->CancelIrql);

                    //
                    //  Remove the cancel request for this IRP. If its cancelled then its
                    //  ok to just process it because we will be returning it to the caller.
                    //

                    Irp->Cancel = FALSE;

                    IoSetCancelRoutine(Irp, NULL);

                    IoReleaseCancelSpinLock(Irp->CancelIrql);

                    UNLOCK_SPINLOCK( pfcb, OldIrql );

                    NCB_COMPLETE( pdncb, NRC_NAMERR );

                    pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

                    NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );

                    LOCK_SPINLOCK( pfcb, OldIrql );

                }
                    
                ReceiveEntry = NextReceiveEntry;
            }
        }
        
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        CloseListens( pfcb, ppab );
        LOCK_SPINLOCK( pfcb, OldIrql );
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    if ( ( pab->AddressHandle != NULL ) &&
         (( CloseAddress == TRUE ) || ( pab->CurrentUsers == 1 )) ){

        IF_NBDBG( NB_DEBUG_ADDRESS )
        {
            NbPrint( (
            "CleanupAb : Close file invoked for \n"
            ) );

            NbFormattedDump( (PUCHAR) &pab-> Name, sizeof( NAME ) );
        }
            
        NbAddressClose( pab->AddressHandle, pab->AddressObject );

        pab->AddressHandle = NULL;
    }

    DEREFERENCE_AB(ppab);

}


VOID
NbAddressClose(
    IN HANDLE AddressHandle,
    IN PVOID Object
    )
/*++

Routine Description:

    Remove close the handle and dereference the address.

Arguments:

    AddressHandle

    Object

Return Value:

    None.

--*/
{
    NTSTATUS    localstatus;
    KAPC_STATE	ApcState;

    PAGED_CODE();

    ObDereferenceObject( Object );

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);
        localstatus = ZwClose( AddressHandle);
        ASSERT(NT_SUCCESS(localstatus));
        KeUnstackDetachProcess(&ApcState);
    } else {
        localstatus = ZwClose( AddressHandle);
        ASSERT(NT_SUCCESS(localstatus));
    }
}


PPAB
FindAb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IncrementUsers
    )
/*++

Routine Description:

    This routine uses the callers lana number and Name to find the Address
    Block that corresponds to the Ncb. Note, it returns the address of the
    relevant plana->AddressBlocks entry so that deletion of the address
    block is simpler.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Ab is chained onto.

    pdncb - Supplies the connection id from the applications point of view.

    IncrementUsers - TRUE iff performing a listen or call so increment CurrentUsers

Return Value:

    Address of the pointer to the address block or NULL.

--*/
{
    PLANA_INFO plana;
    PAB pab;
    int index;

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("FindAb pfcb: %lx, lana: %lx Failed, returning NULL\n",
                pfcb,
                pdncb->ncb_lana_num));
        }
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("FindAb pfcb: %lx, lana: %lx, lsn: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            pdncb->ncb_lsn));
    }

    for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
        pab = plana->AddressBlocks[index];
        if (( pab != NULL ) &&
            (RtlEqualMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ))) {

            ASSERT( pab->Signature == AB_SIGNATURE );

            IF_NBDBG (NB_DEBUG_ADDRESS) {
                NbPrint( ("ppab %lx, pab: %lx, state:%x\n",
                    &plana->AddressBlocks[index],
                    plana->AddressBlocks[index],
                    pab->Status));

                NbFormattedDump( (PUCHAR)&pab->Name, sizeof(NAME) );
            }

            if ( (pab->Status & 0x07) != REGISTERED ) {
                NCB_COMPLETE( pdncb, NRC_NOWILD );
                //
                //  The name is in a bad state. Tell NewAb not to add the name by
                //  returning non-null. Don't reference the AB.
                //
                if (( (pdncb->ncb_command & ~ ASYNCH) == NCBADDNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBQUICKADDNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBQUICKADDGRNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBADDGRNAME )) {
                    return &plana->AddressBlocks[index];
                } else {
                    //  Not NewAb so return Null as usual.
                    return NULL;
                }
            }

            if ( IncrementUsers == TRUE ) {
                REFERENCE_AB(pab);
            }
            return &plana->AddressBlocks[index];
        }
    }

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("Failed return NULL\n"));
    }

    NCB_COMPLETE( pdncb, NRC_NOWILD );
    return NULL;
}

PPAB
FindAbUsingNum(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN UCHAR NameNumber
    )
/*++

Routine Description:

    This routine uses the callers lana number and name number to find the
    Address Block that corresponds to the Ncb.
    Note, it returns the address of the relevant plana->AddressBlocks entry
    so that deletion of the address block is simpler.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Ab is chained onto.

    pdncb - Supplies the applications NCB.

    NameNumber - Supplies the name number to look for. This is not equal to pdncb->ncb_num
        when manipulating broadcast datagrams.

Return Value:

    Address of the pointer to the address block or NULL.

--*/
{
    PLANA_INFO plana;

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("FindAbUsingNum pfcb: %lx, lana: %lx Failed, returning NULL\n",
                pfcb,
                pdncb->ncb_lana_num));
        }
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("FindAbUsingNum pfcb: %lx, lana: %lx, num: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            NameNumber));
    }

    if (( NameNumber < (UCHAR)MAXIMUM_ADDRESS ) &&
        ( plana->AddressBlocks[NameNumber] != NULL) &&
        (( plana->AddressBlocks[NameNumber]->Status & 0x7) == REGISTERED )) {
            return &plana->AddressBlocks[NameNumber];
    }

    //
    //  The user is allowed to receive any and receive broadcast
    //  datagrams on address 255.
    //

    if ((( NameNumber == MAXIMUM_ADDRESS ) &&
         ( plana->AddressBlocks[NameNumber] != NULL)) &&
        (( (pdncb->ncb_command & ~ASYNCH) == NCBRECVANY ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECVBC ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGSENDBC ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECV ))) {
            return &plana->AddressBlocks[NameNumber];
    }

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("Failed return NULL\n"));
    }
    NCB_COMPLETE( pdncb, NRC_ILLNN );

    return NULL;
}

NTSTATUS
NbSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID Context - Supplies the PAB or PLANA_INFO associated with this event.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    PAGED_CODE();

    Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = SubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}


NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, NbCompletionEvent, &Event, TRUE, TRUE, TRUE);

    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject(&Event, // Object to wait on.
                                    Executive,  // Reason for waiting
                                    KernelMode, // Processor mode
                                    FALSE,      // Alertable
                                    NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            IoFreeIrp ( Irp );
            return Status;
        }

        Status = Irp->IoStatus.Status;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\lib\tnetbl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetbios.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "

#define Hi  "Come here Dave, I need you"

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//  Hard code lana-num that is mapped to XNS

#define XNS 1
int Limit = 20;

VOID
usage (
    VOID
    )
{
    printf("usage: tnetbl [-n:lan number][-h] <remote computername> <my computername>\n");
    printf("               -n specifies the lan number (0 is the default)\n");
    printf("               -h specifies that addresses are hexadecimal numbers \n");
    printf("                   rather than strings.\n");
    printf("               final two arguments are the remote and local computer names.\n");
}

int
main (argc, argv)
   int argc;
   char *argv[];
{
    NCB myncb;
    CHAR Buffer2[128];
    int i,j;
    CHAR localName[16];
    CHAR remoteName[16];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    ULONG lanNumber=0;
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    UCHAR lsn;
    UCHAR name_number;
    USHORT length;

    if ( argc < 3 || argc > 5) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlen( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlen( argv[i] ));
            }

        }
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 0;           // Request resources
    myncb.ncb_lana_num = lanNumber;
    myncb.ncb_callname[0] = 0;   // 16 sessions
    myncb.ncb_callname[1] = 0;   // 16 commands
    myncb.ncb_callname[2] = 0;   // 8 names
    Netbios( &myncb );

    //   AddName
    ClearNcb( &myncb );
    myncb.ncb_command = NCBADDNAME;
    RtlMoveMemory( myncb.ncb_name, localName, 16);
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );

    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( "Addname returned an error %lx", myncb.ncb_retcode );
        return 1;
    }
    name_number = myncb.ncb_num;

    printf( "Starting Listen test\n" );

    for ( j = 0; j <= Limit; j++ ) {

        printf( "\nStarting Listen " );

        //   Listen
        ClearNcb( &myncb );
        myncb.ncb_command = NCBLISTEN | ASYNCH;
        RtlMoveMemory( myncb.ncb_name, localName, 16);
        RtlMoveMemory( myncb.ncb_callname, remoteName, 16);
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_rto = myncb.ncb_rto = 0; //10;  10*500 milliseconds timeout
        myncb.ncb_num = name_number;
        Netbios( &myncb );
        printf( "Listen returned " );
        while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
            printf( "." );
            Sleep(500);

        }
        printf( " Listen completed\n" );

        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }

        lsn = myncb.ncb_lsn;

        while ( 1 ) {

            //   Receive
            ClearNcb( &myncb );
            myncb.ncb_command = NCBRECV | ASYNCH;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Buffer2 );
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            Netbios( &myncb );
            printf( "R" );
            while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
//                printf( "." );
//                Sleep(250);

            }
            printf( "r" );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
            //printf( ":%s\n", Buffer2);
            length = myncb.ncb_length;

            //   Send
            ClearNcb( &myncb );
            myncb.ncb_command = NCBSEND;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = length;
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            Netbios( &myncb );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
        }

        //  Hangup
        ClearNcb( &myncb );
        myncb.ncb_command = NCBHANGUP;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_lsn = lsn;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 1;           // Free resources
    Netbios( &myncb );
    printf( "Ending NetBios\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the kernel and logs through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/


#if DBG

#include <nb.h>

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

LONG NetbiosMaxDump = 128;

//  Macro used in DisplayNcb
#define DISPLAY_COMMAND( cmd )              \
    case cmd: NbPrint(( #cmd )); break;

VOID
NbDisplayNcb(
    IN PDNCB pdncb
    )
/*++

Routine Description:

    This routine displays on the standard output stream the contents
    of the Ncb.

Arguments:

    IN PDNCB - Supplies the NCB to be displayed.

Return Value:

    none.

--*/
{

    NbPrint(( "PDNCB         %#010lx\n", pdncb));

    NbPrint(( "ncb_command  %#04x ",  pdncb->ncb_command));
    switch ( pdncb->ncb_command & ~ASYNCH ) {
    DISPLAY_COMMAND( NCBCALL );
    DISPLAY_COMMAND( NCBLISTEN );
    DISPLAY_COMMAND( NCBHANGUP );
    DISPLAY_COMMAND( NCBSEND );
    DISPLAY_COMMAND( NCBRECV );
    DISPLAY_COMMAND( NCBRECVANY );
    DISPLAY_COMMAND( NCBCHAINSEND );
    DISPLAY_COMMAND( NCBDGSEND );
    DISPLAY_COMMAND( NCBDGRECV );
    DISPLAY_COMMAND( NCBDGSENDBC );
    DISPLAY_COMMAND( NCBDGRECVBC );
    DISPLAY_COMMAND( NCBADDNAME );
    DISPLAY_COMMAND( NCBDELNAME );
    DISPLAY_COMMAND( NCBRESET );
    DISPLAY_COMMAND( NCBASTAT );
    DISPLAY_COMMAND( NCBSSTAT );
    DISPLAY_COMMAND( NCBCANCEL );
    DISPLAY_COMMAND( NCBADDGRNAME );
    DISPLAY_COMMAND( NCBENUM );
    DISPLAY_COMMAND( NCBUNLINK );
    DISPLAY_COMMAND( NCBSENDNA );
    DISPLAY_COMMAND( NCBCHAINSENDNA );
    DISPLAY_COMMAND( NCBLANSTALERT );
    DISPLAY_COMMAND( NCBFINDNAME );
    DISPLAY_COMMAND( NCBACTION );
    DISPLAY_COMMAND( NCBQUICKADDNAME );
    DISPLAY_COMMAND( NCBQUICKADDGRNAME );
    DISPLAY_COMMAND( NCALLNIU );
    case NCBADDRESERVED: NbPrint(( "Add reserved address(Internal)" )); break;
    case NCBADDBROADCAST: NbPrint(( "Add Broadcast address(Internal)" )); break;
    default: NbPrint(( " Unknown type")); break;
    }
    if ( pdncb->ncb_command  & ASYNCH ) {
        NbPrint(( " | ASYNCH"));
    }


    NbPrint(( "\nncb_retcode  %#04x\n",  pdncb->ncb_retcode));
    NbPrint(( "ncb_lsn      %#04x\n",  pdncb->ncb_lsn));
    NbPrint(( "ncb_num      %#04x\n",  pdncb->ncb_num));
    NbPrint(( "ncb_buffer   %#010lx\n",pdncb->ncb_buffer));
    NbPrint(( "ncb_length   %#06x\n",  pdncb->ncb_length));

    if ((( pdncb->ncb_command & ~ASYNCH ) == NCBCALL) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCALLNIU) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGSEND) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGRECV) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGSENDBC) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGRECVBC) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBADDNAME) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBADDGRNAME) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBLISTEN)) {

        NbPrint(( "\nncb_callname and ncb->name\n"));
        NbFormattedDump( pdncb->ncb_callname, NCBNAMSZ );
        NbFormattedDump( pdncb->ncb_name, NCBNAMSZ );
        NbPrint(( "ncb_rto      %#04x\n",  pdncb->ncb_rto));
        NbPrint(( "ncb_sto      %#04x\n",  pdncb->ncb_sto));
    }

    NbPrint(( "ncb_post     %lx\n",    pdncb->ncb_post));
    NbPrint(( "ncb_lana_num %#04x\n",  pdncb->ncb_lana_num));
    NbPrint(( "ncb_cmd_cplt %#04x\n\n",  pdncb->ncb_cmd_cplt));

}


void
NbFormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if ( len > NetbiosMaxDump ) {
        len = NetbiosMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NbPrint( ("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NbPrint( ("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\devobj.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    devobj.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.

    The device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the provider, called the context.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, NbCreateDeviceContext)

#endif


NTSTATUS
NbCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    DeviceContext - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

    RegistryPath - The name of the Netbios node in the registry.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_CONTEXT deviceContext;
    PAGED_CODE();


    //
    // Create the device object for NETBEUI.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof (DEVICE_CONTEXT) + RegistryPath->Length - sizeof (DEVICE_OBJECT),
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }
    //  DeviceContext contains:
    //      the device object
    //      Intialized
    //      RegistryPath

    deviceContext = (PDEVICE_CONTEXT)deviceObject;

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    //  Determine the IRP stack size that we should "export".
    //

    deviceObject->StackSize = GetIrpStackSize(
                                  RegistryPath,
                                  NB_DEFAULT_IO_STACKSIZE);

    deviceContext->RegistryPath.MaximumLength = RegistryPath->Length;
    deviceContext->RegistryPath.Buffer = (PWSTR)(deviceContext+1);
    RtlCopyUnicodeString( &deviceContext->RegistryPath, RegistryPath );

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction [IRP_MJ_CREATE] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NbDispatch;

    DriverObject-> DriverUnload = NbDriverUnload;

    *DeviceContext = deviceContext;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    translation between Netbios error codes and NTSTATUS codes.

Author:

    Colin Watson (ColinW) 28-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
struct {
    unsigned char NbError;
    NTSTATUS NtStatus;
} Nb_Error_Map[] = {
    { NRC_GOODRET         , STATUS_SUCCESS},
    { NRC_PENDING         , STATUS_PENDING},
    { NRC_ILLCMD          , STATUS_INVALID_DEVICE_REQUEST},
    { NRC_BUFLEN          , STATUS_INVALID_PARAMETER},
    { NRC_CMDTMO          , STATUS_IO_TIMEOUT},
    { NRC_INCOMP          , STATUS_BUFFER_OVERFLOW},
    { NRC_INCOMP          , STATUS_BUFFER_TOO_SMALL},
    { NRC_SNUMOUT         , STATUS_INVALID_HANDLE},
    { NRC_NORES           , STATUS_INSUFFICIENT_RESOURCES},
    { NRC_CMDCAN          , STATUS_CANCELLED},
    { NRC_INUSE           , STATUS_DUPLICATE_NAME},
    { NRC_NAMTFUL         , STATUS_TOO_MANY_NAMES},
    { NRC_LOCTFUL         , STATUS_TOO_MANY_SESSIONS},
    { NRC_REMTFUL         , STATUS_REMOTE_NOT_LISTENING},
    { NRC_NOCALL	  , STATUS_BAD_NETWORK_PATH},
    { NRC_NOCALL	  , STATUS_HOST_UNREACHABLE},
    { NRC_NOCALL          , STATUS_CONNECTION_REFUSED},
    { NRC_LOCKFAIL        , STATUS_WORKING_SET_QUOTA},
    { NRC_SABORT	  , STATUS_REMOTE_DISCONNECT},
    { NRC_SABORT	  , STATUS_CONNECTION_RESET},
    { NRC_SCLOSED         , STATUS_LOCAL_DISCONNECT},
    { NRC_SABORT          , STATUS_LINK_FAILED},
    { NRC_DUPNAME         , STATUS_SHARING_VIOLATION},
    { NRC_SYSTEM          , STATUS_UNSUCCESSFUL},
    { NRC_BUFLEN          , STATUS_ACCESS_VIOLATION},
    { NRC_ILLCMD          , STATUS_NONEXISTENT_EA_ENTRY}
};

#define NUM_NB_ERRORS sizeof(Nb_Error_Map) / sizeof(Nb_Error_Map[0])

unsigned char
NbMakeNbError(
    IN NTSTATUS Error
    )
/*++

Routine Description:

    This routine converts the NTSTATUS to and NBCB error.

Arguments:

    Error   -   Supplies the NTSTATUS to be converted.

Return Value:

    The mapped error.

--*/
{
    int i;

    for (i=0;i<NUM_NB_ERRORS;i++) {
        if (Nb_Error_Map[i].NtStatus == Error) {

            IF_NBDBG (NB_DEBUG_ERROR_MAP) {
                NbPrint( ("NbMakeNbError %X becomes  %x\n",
                Error,
                Nb_Error_Map[i].NbError));
            }

            return Nb_Error_Map[i].NbError;
        }
    }
    IF_NBDBG (NB_DEBUG_ERROR_MAP) {
        NbPrint( ("NbMakeNbError %X becomes  %x\n", Error, NRC_SYSTEM ));
    }

    return NRC_SYSTEM;

}

NTSTATUS
NbLanStatusAlert(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is used to save a lan_status_alert NCB for a
    particular network adapter.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PLANA_INFO plana;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint(( "\n****** Start of NbLanStatusAlert ****** pdncb %lx\n", pdncb ));
    }

    LOCK( pfcb, OldIrql );

    if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {

        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    if (( pfcb->ppLana[pdncb->ncb_lana_num] == (LANA_INFO *) NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbPrint( (" not found\n"));
        }

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return STATUS_SUCCESS;
    }

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    QueueRequest(&plana->LanAlertList, pdncb, Irp, pfcb, OldIrql, FALSE);

    return STATUS_PENDING;
}

VOID
CancelLanAlert(
    IN PFCB pfcb,
    IN PDNCB pdncb
    )
/*++

Routine Description:

    This routine is used to cancel a lan_status_alert NCB for a
    particular network adapter.

Arguments:

    pfcb - Supplies a pointer to the Fcb that the NCB refers to.

    pdncb - Pointer to the NCB.

Return Value:

    none.

--*/

{
    PLANA_INFO plana;
    PLIST_ENTRY Entry;
    PLIST_ENTRY NextEntry;

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint(( "\n****** Start of CancelLanAlert ****** pdncb %lx\n", pdncb ));
    }

    if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return;
    }

    if (( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return;
    }

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    for (Entry = plana->LanAlertList.Flink ;
         Entry != &plana->LanAlertList ;
         Entry = NextEntry) {
        PDNCB pAnotherNcb;

        NextEntry = Entry->Flink;

        pAnotherNcb = CONTAINING_RECORD( Entry, DNCB, ncb_next);
        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbDisplayNcb( pAnotherNcb );
        }

        if ( (PUCHAR)pAnotherNcb->users_ncb == pdncb->ncb_buffer) {
            //  Found the request to cancel
            PIRP Irp;

            IF_NBDBG (NB_DEBUG_LANSTATUS) {
                NbPrint(( "Found request to cancel\n" ));
            }
            RemoveEntryList( &pAnotherNcb->ncb_next );

            Irp = pAnotherNcb->irp;

            IoAcquireCancelSpinLock(&Irp->CancelIrql);

            //
            //  Remove the cancel request for this IRP. If its cancelled then its
            //  ok to just process it because we will be returning it to the caller.
            //

            Irp->Cancel = FALSE;

            IoSetCancelRoutine(Irp, NULL);

            IoReleaseCancelSpinLock(Irp->CancelIrql);

            NCB_COMPLETE( pAnotherNcb, NRC_CMDCAN );

            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

            NbCompleteRequest( Irp, STATUS_SUCCESS );

            NCB_COMPLETE( pdncb, NRC_GOODRET );

            return;
        }
    }
    NCB_COMPLETE( pdncb, NRC_CANOCCR );

    return;
}

NTSTATUS
NbTdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is called on any error indications passed back from the
    transport. It implements LAN_STATUS_ALERT.

Arguments:

    IN PVOID Context - Supplies the pfcb for the address.

    IN NTSTATUS Status - Supplies the error.

Return Value:

    NTSTATUS - Status of event indication

--*/

{
    PLANA_INFO plana = (PLANA_INFO) Context;
    PDNCB pdncb;

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint( ("NbTdiErrorHandler PLANA: %lx, Status %X\n", plana, Status));
    }

    ASSERT( plana->Signature == LANA_INFO_SIGNATURE);

    while ( (pdncb = DequeueRequest( &plana->LanAlertList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbPrint( ("NbTdiErrorHandler complete pdncb: %lx\n", pdncb ));
        }

        NCB_COMPLETE( pdncb, NbMakeNbError( Status) );

        pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        NbCheckAndCompleteIrp32(pdncb->irp);

        NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\file.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    file control block object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include "ntos.h"
//#include <zwapi.h>


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NewFcb)
#pragma alloc_text(PAGE, CleanupFcb)
#pragma alloc_text(PAGE, OpenLana)
#pragma alloc_text(PAGE, NbBindHandler)
#pragma alloc_text(PAGE, NbPowerHandler)
#pragma alloc_text(PAGE, NbTdiBindHandler)
#pragma alloc_text(PAGE, NbTdiUnbindHandler)
#endif


#if AUTO_RESET

VOID
NotifyUserModeNetbios(
    IN  PFCB_ENTRY      pfe
);
#endif


VOID
DumpDeviceList(
    IN      PFCB        pfcb
);


NTSTATUS
NewFcb(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called when the dll opens \Device\Netbios. It
    creates all the lana structures and adds the name for the "burnt
    in" prom address on each adapter. Note the similarity to the routine
    NbAstat when looking at this function.

Arguments:

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    //
    //  Allocate the user context and store it in the DeviceObject.
    //

    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFCB NewFcb = NULL;
    UCHAR ucIndex;
    NTSTATUS Status;
    PFCB_ENTRY pfe = NULL;
    BOOLEAN bCleanupResource = FALSE;


    PAGED_CODE();


    do
    {
        //
        // allocate FCB
        //
    
        NewFcb = ExAllocatePoolWithTag (NonPagedPool, sizeof(FCB), 'fSBN');
        FileObject->FsContext2 = NewFcb;

        if ( NewFcb == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate FCB\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory( NewFcb, sizeof( FCB ) );
        
        NewFcb->Signature = FCB_SIGNATURE;

        NewFcb->TimerRunning = FALSE;

        NewFcb-> RegistrySpace = NULL;


        //
        // Allocate for the LanaInfo array 
        //
    
        NewFcb->ppLana = ExAllocatePoolWithTag (
                            NonPagedPool,
                            sizeof(PLANA_INFO) * (MAX_LANA + 1),
                            'fSBN'
                            );

        if ( NewFcb->ppLana == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate Lana info list\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // Allocate for driver name list
        //
        
        NewFcb-> pDriverName = ExAllocatePoolWithTag (
                                    NonPagedPool,
                                    sizeof(UNICODE_STRING) * (MAX_LANA + 1),
                                    'fSBN'
                                    );

        if ( NewFcb-> pDriverName == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate device name list\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // Initialize Lana info list, driver name list
        //
        
        for ( ucIndex = 0; ucIndex <= MAX_LANA; ucIndex++ ) 
        {
            NewFcb->ppLana[ ucIndex ] = NULL;
            RtlInitUnicodeString( &NewFcb-> pDriverName[ ucIndex ], NULL );
        }


        //
        // allocate and initialize FCB list entry
        //
    
        pfe = ExAllocatePoolWithTag( NonPagedPool, sizeof( FCB_ENTRY ), 'fSBN' );
    
        if ( pfe == NULL )
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate FCB list entry\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        InitializeListHead( &pfe-> leList );
        
#if AUTO_RESET

        InitializeListHead( &pfe-> leResetList );
        InitializeListHead( &pfe-> leResetIrp );
#endif

        pfe-> pfcb = NewFcb;
        pfe-> peProcess = PsGetCurrentProcess();


        //
        // Initialize locks
        //
    
        KeInitializeSpinLock( &NewFcb->SpinLock );
        ExInitializeResourceLite( &NewFcb->Resource );
        ExInitializeResourceLite( &NewFcb->AddResource );
        bCleanupResource = TRUE;
        

        //
        // allocate work item
        //
        
        NewFcb->WorkEntry = IoAllocateWorkItem( (PDEVICE_OBJECT)DeviceContext );

        if ( NewFcb->WorkEntry == NULL )
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate work ite,\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // retrieve global info
        //
    
        LOCK_GLOBAL();

        NewFcb-> MaxLana = g_ulMaxLana;

        RtlCopyMemory( &NewFcb-> LanaEnum, &g_leLanaEnum, sizeof( LANA_ENUM ) );


        //
        // copy all active device names
        //

        Status = STATUS_SUCCESS;
        
        for ( ucIndex = 0; ucIndex <= g_ulMaxLana; ucIndex++ )
        {
            if ( ( g_pusActiveDeviceList[ ucIndex ].MaximumLength != 0 ) &&
                 ( g_pusActiveDeviceList[ ucIndex ].Buffer != NULL ) ) 
            {
                Status = AllocateAndCopyUnicodeString( 
                            &NewFcb-> pDriverName[ ucIndex ],
                            &g_pusActiveDeviceList[ ucIndex ]
                            );

                if ( !NT_SUCCESS( Status ) )
                {
                    NbPrint( ( 
                        "Netbios : failed to allocate device name for lana %d\n",
                        ucIndex
                        ) );

                    break;
                }
            }
        }


        if ( !NT_SUCCESS( Status ) )
        {
            UNLOCK_GLOBAL();
            break;
        }

        
        //
        // Add FCB to global list of FCBs
        //

        InsertHeadList( &g_leFCBList, &pfe-> leList );
    
        UNLOCK_GLOBAL();

    
        IF_NBDBG (NB_DEBUG_FILE)
        {
            NbPrint(("Enumeration of transports completed:\n"));
            NbFormattedDump( (PUCHAR)&NewFcb->LanaEnum, sizeof(LANA_ENUM));
        }

        return STATUS_SUCCESS;

    } while ( FALSE );


    //
    // error condition.  cleanup all allocations.
    //

    if ( NewFcb != NULL )
    {
        //
        // free the list of driver names
        //
        
        if ( NewFcb-> pDriverName != NULL )
        {
            for ( ucIndex = 0; ucIndex <= MAX_LANA; ucIndex++ )
            {
                if ( NewFcb-> pDriverName[ ucIndex ].Buffer != NULL )
                {
                    ExFreePool( NewFcb-> pDriverName[ ucIndex ].Buffer );
                }
            }

            ExFreePool( NewFcb-> pDriverName );
        }


        //
        // free the lana list
        //
        
        if ( NewFcb-> ppLana != NULL )
        {
            ExFreePool( NewFcb-> ppLana );
        }


        //
        // Free the work item
        //

        if ( NewFcb->WorkEntry != NULL )
        {
            IoFreeWorkItem( NewFcb->WorkEntry );
        }
        

        //
        // Delete resources
        //
        
        if ( bCleanupResource )
        {
            ExDeleteResourceLite( &NewFcb-> Resource );
            
            ExDeleteResourceLite( &NewFcb-> AddResource );
        }

        //
        // free the FCB
        //
        
        ExFreePool( NewFcb );


        //
        // free the global FCB entry
        //

    }

    if ( pfe != NULL )
    {
        ExFreePool( pfe ) ;
    }
    
   
    FileObject->FsContext2 = NULL;
    
    return Status;
    
} /* NewFcb */



VOID
OpenLana(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called when an application resets an adapter allocating
    resources. It creates all the lana structure and adds the name for the
    "burnt in" prom address as well as finding the broadcast address.

    Note the similarity to the routine NbAstat when looking at this function.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    KEVENT Event1;
    PLANA_INFO plana;
    HANDLE TdiHandle;
    PFILE_OBJECT TdiObject;
    PDEVICE_OBJECT DeviceObject;
    PMDL SaveMdl;
    int temp;
    PRESET_PARAMETERS InParameters;
    PRESET_PARAMETERS OutParameters;
    UCHAR Sessions;
    UCHAR Commands;
    UCHAR Names;
    BOOLEAN Exclusive;

    UCHAR   ucInd = 0;
    
    UNICODE_STRING usDeviceName;

    
    //
    //  Ncb and associated buffer to be used in adapter status to get the
    //  prom address.
    //

    DNCB ncb;
    struct _AdapterStatus {
        ADAPTER_STATUS AdapterInformation;
        NAME_BUFFER Nb;
    } AdapterStatus;
    PMDL AdapterStatusMdl = NULL;

    struct _BroadcastName {
        TRANSPORT_ADDRESS Address;
        UCHAR Padding[NCBNAMSZ];
    } BroadcastName;
    PMDL BroadcastMdl = NULL;

    PAGED_CODE();


    RtlInitUnicodeString( &usDeviceName, NULL);

    
    LOCK_RESOURCE( pfcb );
    
    //
    // check lana specified is valid
    //
    
    if ( ( pdncb->ncb_lana_num > pfcb->MaxLana) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].MaximumLength == 0 ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].Buffer == NULL ) )
    {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return;
    }

    
    //
    // since no locks are held when invoking NbOpenAddress, no fields of 
    // pfcb should be passed to it.  This is because pfcb might be 
    // modified by a bind or unbind notification 
    //
    
    Status = AllocateAndCopyUnicodeString( 
                &usDeviceName, &pfcb-> pDriverName[ pdncb-> ncb_lana_num ]
                );

    if ( !NT_SUCCESS( Status ) ) 
    {
        NCB_COMPLETE( pdncb, NRC_NORES );
        UNLOCK_RESOURCE( pfcb );
        goto exit;
    }
                
    UNLOCK_RESOURCE( pfcb );
    


    //
    //  Calculate the lana limits from the users NCB.
    //

    InParameters = (PRESET_PARAMETERS)&pdncb->ncb_callname;
    OutParameters = (PRESET_PARAMETERS)&pdncb->ncb_name;

    if ( InParameters->sessions == 0 ) {
        Sessions = 16;
    } else {
        if ( InParameters->sessions > MAXIMUM_CONNECTION ) {
            Sessions = MAXIMUM_CONNECTION;
        } else {
            Sessions = InParameters->sessions;
        }
    }

    if ( InParameters->commands == 0 ) {
        Commands = 16;
    } else {
        Commands = InParameters->commands;
    }

    if ( InParameters->names == 0 ) {
        Names = 8;
    } else {
        if ( InParameters->names > MAXIMUM_ADDRESS-2 ) {
            Names = MAXIMUM_ADDRESS-2;
        } else {
            Names = InParameters->names;
        }
    }

    Exclusive = (BOOLEAN)(InParameters->name0_reserved != 0);

    //  Copy the parameters back into the NCB

    ASSERT( sizeof(RESET_PARAMETERS) == 16);
    RtlZeroMemory( OutParameters, sizeof( RESET_PARAMETERS ));

    OutParameters->sessions = Sessions;
    OutParameters->commands = Commands;
    OutParameters->names = Names;
    OutParameters->name0_reserved = (UCHAR)Exclusive;

    //  Set all the configuration limits to their maximum.

    OutParameters->load_sessions = 255;
    OutParameters->load_commands = 255;
    OutParameters->load_names = MAXIMUM_ADDRESS;
    OutParameters->load_stations = 255;
    OutParameters->load_remote_names = 255;

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Lana:%x Sessions:%x Names:%x Commands:%x Reserved:%x\n",
            pdncb->ncb_lana_num,
            Sessions,
            Names,
            Commands,
            Exclusive));
    }

    //
    //  Build the internal datastructures.
    //

    AdapterStatusMdl = IoAllocateMdl( &AdapterStatus,
        sizeof( AdapterStatus ),
        FALSE,  // Secondary Buffer
        FALSE,  // Charge Quota
        NULL);

    if ( AdapterStatusMdl == NULL ) {
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return;
    }

    BroadcastMdl = IoAllocateMdl( &BroadcastName,
        sizeof( BroadcastName ),
        FALSE,  // Secondary Buffer
        FALSE,  // Charge Quota
        NULL);

    if ( BroadcastMdl == NULL ) {
        IoFreeMdl( AdapterStatusMdl );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return;
    }

    MmBuildMdlForNonPagedPool (AdapterStatusMdl);

    MmBuildMdlForNonPagedPool (BroadcastMdl);

    KeInitializeEvent (
            &Event1,
            SynchronizationEvent,
            FALSE);

    //
    //  For each potential network, open the device driver and
    //  obtain the reserved name and the broadcast address.
    //


    //
    //  Open a handle for doing control functions
    //

    Status = NbOpenAddress ( 
                &TdiHandle, (PVOID*)&TdiObject, 
                &usDeviceName, pdncb->ncb_lana_num, NULL 
                );

    if (!NT_SUCCESS(Status)) {
        //  Adapter not installed
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        goto exit;
    }


    LOCK_RESOURCE( pfcb );

    //
    // verify that device still exists.  Here you cannot check the 
    // Lana info structure for the lana (correponding to the device),
    // since it is expected to be NULL.  Instead check that the device
    // name is valid.
    //

    if ( pfcb-> pDriverName[ pdncb->ncb_lana_num ].Buffer == NULL )
    {
        //
        // device presumed removed on account of unbind.
        //
        
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        UNLOCK_RESOURCE( pfcb );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }
    
    
    if ( pfcb->ppLana[pdncb->ncb_lana_num] != NULL ) {
        //  Attempting to open the lana twice in 2 threads.

        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_TOOMANY );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }

    
    plana = pfcb->ppLana[pdncb->ncb_lana_num] =
        ExAllocatePoolWithTag (NonPagedPool,
        sizeof(LANA_INFO), 'lSBN');

    if ( plana == (PLANA_INFO) NULL ) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }

    plana->Signature = LANA_INFO_SIGNATURE;
    plana->Status = NB_INITIALIZING;
    plana->pFcb = pfcb;
    plana->ControlChannel = TdiHandle;

    for ( temp = 0; temp <= MAXIMUM_CONNECTION; temp++ ) {
        plana->ConnectionBlocks[temp] = NULL;
    }

    for ( temp = 0; temp <= MAXIMUM_ADDRESS; temp++ ) {
        plana->AddressBlocks[temp] = NULL;
    }

    InitializeListHead( &plana->LanAlertList);

    //  Record the user specified limits in the Lana datastructure.

    plana->NextConnection = 1;
    plana->ConnectionCount = 0;
    plana->MaximumConnection = Sessions;
    plana->NextAddress = 2;
    plana->AddressCount = 0;
    plana->MaximumAddresses = Names;

    DeviceObject = IoGetRelatedDeviceObject( TdiObject );
    plana->ControlFileObject = TdiObject;
    plana->ControlDeviceObject = DeviceObject;

    SaveMdl = Irp->MdlAddress;  // TdiBuildQuery modifies MdlAddress

    if ( Exclusive == TRUE ) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint(("Query adapter status\n" ));
        }
        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_ADAPTER_STATUS,
                AdapterStatusMdl);

        Status = IoCallDriver (DeviceObject, Irp);
        if ( Status == STATUS_PENDING ) {
            do {
                Status = KeWaitForSingleObject(
                            &Event1, Executive, KernelMode, TRUE, NULL
                            );
            } while (Status == STATUS_ALERTED);
            
            if (!NT_SUCCESS(Status)) {
                NbAddressClose( TdiHandle, TdiObject );
                ExFreePool( plana );
                pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
                UNLOCK_RESOURCE( pfcb );
                NCB_COMPLETE( pdncb, NRC_SYSTEM );
                goto exit;
            }
            Status = Irp->IoStatus.Status;
        }

        //
        //  The transport may have extra names added so the buffer may be too short.
        //  Ignore the too short problem since we will have all the data we require.
        //

        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Now discover the broadcast address.
    //

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Query broadcast address\n" ));
    }

    if (NT_SUCCESS(Status)) {
        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_BROADCAST_ADDRESS,
                BroadcastMdl);

        Status = IoCallDriver (DeviceObject, Irp);
        if ( Status == STATUS_PENDING ) {
            do {
                Status = KeWaitForSingleObject(
                            &Event1, Executive, KernelMode, TRUE, NULL
                            );
            } while ( Status == STATUS_ALERTED );
            
            if (!NT_SUCCESS(Status)) {
                NbAddressClose( TdiHandle, TdiObject );
                ExFreePool( plana );
                pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
                UNLOCK_RESOURCE( pfcb );
                NCB_COMPLETE( pdncb, NRC_SYSTEM );
                goto exit;
            }
            Status = Irp->IoStatus.Status;
        }
    }

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Query broadcast address returned:\n" ));
        NbFormattedDump(
            (PUCHAR)&BroadcastName,
            sizeof(BroadcastName) );
    }

    //  Cleanup the callers Irp
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->MdlAddress = SaveMdl;


    if ( !NT_SUCCESS( Status )) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" Astat or query broadcast returned error: %lx\n", Status ));
        }

        NbAddressClose( TdiHandle, TdiObject );
        ExFreePool( plana );
        pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        goto exit;
    }

    if ( Exclusive == TRUE) {
        int i;
        //
        //  Grab exclusive access to the reserved address
        //
        //
        //  We now have an adapter status structure containing the
        //  prom address. Move the address to where NewAb looks and
        //  pretend an addname has just been requested.
        //

        ncb.ncb_command = NCBADDRESERVED;
        ncb.ncb_lana_num = pdncb->ncb_lana_num;
        ncb.ncb_retcode = NRC_PENDING;

        for ( i=0; i<10 ; i++ ) {
            ncb.ncb_name[i] = '\0';
        }
        RtlMoveMemory( ncb.ncb_name+10,
            AdapterStatus.AdapterInformation.adapter_address,
            6);

        //
        // It appears that NewAb is called while holding pfcb-> Resource.
        //
        NewAb( IrpSp, &ncb );

        if ( ncb.ncb_retcode != NRC_GOODRET ) {
            IF_NBDBG (NB_DEBUG_FILE) {
                NbPrint((" Add of reserved name failed Lana:%x\n", pdncb->ncb_lana_num));
            }

            plana->Status = NB_ABANDONED;
            UNLOCK_RESOURCE( pfcb );
            CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            goto exit;
        }
    }


    //
    //  Add the broadcast address. Use a special command code
    //  to ensure address 255 is used.
    //

    ncb.ncb_length = BroadcastName.Address.Address[0].AddressLength;
    ncb.ncb_command = NCBADDBROADCAST;
    ncb.ncb_lana_num = pdncb->ncb_lana_num;
    ncb.ncb_retcode = NRC_PENDING;
    ncb.ncb_cmd_cplt = NRC_PENDING;
    RtlMoveMemory( ncb.ncb_name,
        ((PTDI_ADDRESS_NETBIOS)&BroadcastName.Address.Address[0].Address)->NetbiosName,
        NCBNAMSZ );


    //
    // It appears that NewAb is called while holding pfcb-> Resource.
    //
    NewAb( IrpSp, &ncb );

    if ( ncb.ncb_retcode != NRC_GOODRET ) {
        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" Add of broadcast name failed Lana:%x\n", pdncb->ncb_lana_num));
        }

        plana->Status = NB_ABANDONED;
        UNLOCK_RESOURCE( pfcb );
        CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        goto exit;
    }

    plana->Status = NB_INITIALIZED;
    NCB_COMPLETE( pdncb, NRC_GOODRET );
    UNLOCK_RESOURCE( pfcb );

exit:
    if ( AdapterStatusMdl != NULL ) 
    { 
        IoFreeMdl( AdapterStatusMdl );
    }
    
    if ( BroadcastMdl != NULL ) 
    {
        IoFreeMdl( BroadcastMdl );
    }

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }
    return;

}

VOID
CleanupFcb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB pfcb
    )
/*++

Routine Description:

    This deletes any Connection Blocks pointed to by the File Control Block
    and then deletes the File Control Block. This routine is only called
    when a close IRP has been received.

Arguments:

    IrpSp - Pointer to current IRP stack frame.

    pfcb - Pointer to the Fcb to be deallocated.

Return Value:

    nothing.

--*/

{
    NTSTATUS    nsStatus;
    ULONG lana_index;
    PLIST_ENTRY ple = NULL;
    PFCB_ENTRY pfe = NULL;


    
    PAGED_CODE();

    //
    //  To receive a Close Irp, the IO system has determined that there
    //  are no handles open in the driver. To avoid some race conditions
    //  in this area, we always have an Irp when queueing work to the Fsp.
    //  this prevents structures disappearing on the Fsp and also makes
    //  it easier to cleanup in this routine.
    //

    //
    //  for each network adapter that is allocated, close all addresses
    //  and connections, deleting any memory that is allocated.
    //

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("CleanupFcb:%lx\n", pfcb ));
    }


    //
    // remove FCB pointer from the global list of FCB pointers
    //
    
    LOCK_GLOBAL();

    for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
    {
        pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

        if ( pfe-> pfcb == pfcb )
        {
            RemoveEntryList( ple );
            ExFreePool( pfe );

            IF_NBDBG (NB_DEBUG_CREATE_FILE)
            {
                NbPrint( ("Netbios FCB entry removed from global list\n" ) );
            }

            break;
        }
    }

    UNLOCK_GLOBAL();


    //
    // FCB pointed to by pfcb is now free from access by bind/unbind handlers.
    //
    
    LOCK_RESOURCE( pfcb );
    if ( pfcb->TimerRunning == TRUE ) {

        KEVENT TimerCancelled;

        KeInitializeEvent (
                &TimerCancelled,
                SynchronizationEvent,
                FALSE);

        pfcb->TimerCancelled = &TimerCancelled;
        pfcb->TimerRunning = FALSE;
        UNLOCK_RESOURCE( pfcb );

        if ( KeCancelTimer (&pfcb->Timer) == FALSE ) {

            //
            //  The timeout was in the Dpc queue. Wait for it to be
            //  processed before continuing.
            //

            do {
                nsStatus = KeWaitForSingleObject(
                            &TimerCancelled, Executive, KernelMode, 
                            TRUE, NULL
                            );
            } while (nsStatus == STATUS_ALERTED);
        }

    } else {
        UNLOCK_RESOURCE( pfcb );
    }

    for ( lana_index = 0; lana_index <= pfcb->MaxLana; lana_index++ ) {
        CleanupLana( pfcb, lana_index, TRUE);

        if ( pfcb-> pDriverName[ lana_index ].Buffer != NULL )
        {
            ExFreePool( pfcb-> pDriverName[ lana_index ].Buffer );
        }
    }

    ExDeleteResourceLite( &pfcb->Resource );
    ExDeleteResourceLite( &pfcb->AddResource );

    IrpSp->FileObject->FsContext2 = NULL;

    ExFreePool( pfcb-> pDriverName );
    ExFreePool( pfcb->ppLana );

    //
    // Free the work item
    //

    IoFreeWorkItem( pfcb->WorkEntry );
        

    ExFreePool( pfcb );
}


VOID
CleanupLana(
    IN PFCB pfcb,
    IN ULONG lana_index,
    IN BOOLEAN delete
    )
/*++

Routine Description:

    This routine completes all the requests on a particular adapter. It
    removes all connections and addresses.
Arguments:

    pfcb - Pointer to the Fcb to be deallocated.

    lana_index - supplies the adapter to be cleaned.

    delete - if TRUE the memory for the lana structure should be freed.

Return Value:

    nothing.

--*/

{
    PLANA_INFO plana;
    int index;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PDNCB pdncb;

    LOCK( pfcb, OldIrql );

    plana = pfcb->ppLana[lana_index];

    if ( plana != NULL ) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" CleanupLana pfcb: %lx lana %lx\n", pfcb, lana_index ));
        }

        if (( plana->Status == NB_INITIALIZING ) ||
            ( plana->Status == NB_DELETING )) {
            //  Possibly trying to reset it twice?
            UNLOCK( pfcb, OldIrql );
            return;
        }
        plana->Status = NB_DELETING;

        //  Cleanup the control channel and abandon any tdi-action requests.


        if ( plana->ControlChannel != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            IF_NBDBG( NB_DEBUG_CALL )
            {
                NbPrint( (
                "NbAddressClose : Close file invoked for %d\n",
                lana_index
                ) );

                NbPrint( ( "Control channel\n" ) );
            }
            
            NbAddressClose( plana->ControlChannel, plana->ControlFileObject );

            LOCK_SPINLOCK( pfcb, OldIrql );

            plana->ControlChannel = NULL;

        }

        while ( (pdncb = DequeueRequest( &plana->LanAlertList)) != NULL ) {

            //
            //  Any error will do since the user is closing \Device\Netbios
            //  and is therefore exiting.
            //

            NCB_COMPLETE( pdncb, NRC_SCLOSED );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
        }


        for ( index = 0; index <= MAXIMUM_CONNECTION; index++) {
            if ( plana->ConnectionBlocks[index] != NULL ) {
                IF_NBDBG (NB_DEBUG_FILE) {
                    NbPrint(("Call CleanupCb Lana:%x Lsn: %x\n", lana_index, index ));
                }
                plana->ConnectionBlocks[index]->DisconnectReported = TRUE;
                UNLOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
                CleanupCb( &plana->ConnectionBlocks[index], NULL );
                LOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
            }
        }

        for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
            if ( plana->AddressBlocks[index] != NULL ) {
                IF_NBDBG (NB_DEBUG_FILE) {
                    NbPrint((" CleanupAb Lana:%x index: %x\n", lana_index, index ));
                }
                UNLOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
                CleanupAb( &plana->AddressBlocks[index], TRUE );
                LOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
            }
        }

        if ( delete == TRUE ) {
            pfcb->ppLana[lana_index] = NULL;
            ExFreePool( plana );
        }

    }

    UNLOCK( pfcb, OldIrql );
}



//----------------------------------------------------------------------------
// NbTdiBindHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------
VOID
NbBindHandler(
    IN      TDI_PNP_OPCODE      PnPOpcode,
    IN      PUNICODE_STRING     DeviceName,
    IN      PWSTR               MultiSZBindList
    )
{

    PWSTR   pwCur = NULL;

    if ( PnPOpcode == TDI_PNP_OP_ADD )
    {
        NbTdiBindHandler( DeviceName, MultiSZBindList );
    }

    else if ( PnPOpcode == TDI_PNP_OP_DEL )
    {
        NbTdiUnbindHandler( DeviceName );
    }

}

//----------------------------------------------------------------------------
// NbTdiPowerHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------

NTSTATUS
NbPowerHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PNET_PNP_EVENT      pnpeEvent,
    IN      PTDI_PNP_CONTEXT    ptpcContext1,
    IN      PTDI_PNP_CONTEXT    ptpcContext2
)
{
    return STATUS_SUCCESS;
}


//----------------------------------------------------------------------------
// NbTdiBindHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------

VOID
NbTdiBindHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PWSTR               pwszMultiSZBindList
    )
{

    NTSTATUS nsStatus;
    
    UCHAR       ucInd = 0, ucIndex = 0, ucNewLana = 0, ucLana = 0;
    BOOLEAN     bRes = FALSE;
    ULONG       ulMaxLana = 0;
    PWSTR       pwszBind = NULL;

    UNICODE_STRING  usCurDevice;
    
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    
    PLANA_MAP   pLanaMap = NULL; 

    PLIST_ENTRY ple = NULL;
    
    PFCB_ENTRY pfe = NULL;

    PFCB pfcb = NULL;
    
#if AUTO_RESET
    PRESET_LANA_ENTRY prle;
#endif
    

    PAGED_CODE();

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n++++ Netbios : TdiBindHandler : entered for device : %ls ++++\n",
            pusDeviceName-> Buffer 
            ) );
    }


    do
    {
        //
        // read the registry for the Lana Map
        //

        nsStatus = GetLanaMap( &g_usRegistryPath, &pkvfi );
        
        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : GetLanaMap failed with status %lx\n", nsStatus 
                ) );
            break;
        }

        pLanaMap = (PLANA_MAP) ( (PUCHAR) pkvfi + pkvfi-> DataOffset );
        

        //
        // get Max Lana
        //

        nsStatus = GetMaxLana( &g_usRegistryPath, &ulMaxLana );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : GetMaxLana failed with status %lx\n", nsStatus 
                ) );
            break;
        }

        
        //
        // figure out Lana for this device.  Verify that it is enumerated.
        //

        ucIndex = 0;
        
        pwszBind = pwszMultiSZBindList;

        while ( *pwszBind != 0 )
        {
            RtlInitUnicodeString( &usCurDevice, pwszBind );

            if ( !RtlCompareUnicodeString(
                    &usCurDevice,
                    pusDeviceName,
                    FALSE
                    ) )
            {
                //
                // new device found
                //

                bRes = TRUE;
                break;
            }

            ucIndex++;
            
            pwszBind += wcslen( pwszBind ) + 1;
        }


        //
        // if device was not found error out
        //

        if ( !bRes )
        {
            NbPrint( (
                "Netbios : device %ls not found in bind string\n",
                pusDeviceName-> Buffer
                ) );
            break;
        }


        //
        // verify lana number is valid
        //
        
        if ( pLanaMap[ ucIndex ].Lana > ulMaxLana )
        {
            NbPrint( (
                "Netbios : Device lana %d, Max Lana %d\n",
                pLanaMap[ ucIndex ].Lana, ulMaxLana
                ) );
            break;
        }


        //
        // open device to ensure that it works.
        //

        bRes = NbCheckLana ( pusDeviceName );

        if ( !bRes )
        {
            NbPrint( ( 
                "Netbios : NbCheckLana failed to open device %ls\n", 
                pusDeviceName-> Buffer 
                ) );
            break;
        }

      
        //
        // create a copy of this device name.
        //
        nsStatus = AllocateAndCopyUnicodeString( 
                        &usCurDevice,
                        pusDeviceName
                        );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : Failed to allocate for global device name %x\n",
                nsStatus
                ) );
            break;
        }


        ucNewLana = pLanaMap[ ucIndex ].Lana;

        IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
        {
            NbPrint( ("Netbios : Lana for device is %d\n", ucNewLana ) );
        }
        
        //
        // update global info.
        //

        LOCK_GLOBAL();

        //
        //  verify that lana is not previously used.
        //
        if ( g_pusActiveDeviceList[ ucNewLana ].Buffer != NULL )
        {
            NbPrint( ( 
                "Netbios : Lana %d already in use by %ls\n",
                ucNewLana, g_pusActiveDeviceList[ ucNewLana ].Buffer
                ) );
                
            UNLOCK_GLOBAL();
			ExFreePool(usCurDevice.Buffer);
            break;
        }
        

        //
        //  update maxlana
        //  update lana enum if device is enumerated.
        //
        
        g_ulMaxLana = ulMaxLana;


        if ( pLanaMap[ ucIndex ].Enum )
        {
            g_leLanaEnum.lana[ g_leLanaEnum.length ] = ucNewLana;
            g_leLanaEnum.length++;
        }
        

        //
        //  add to active device list
        //
        RtlInitUnicodeString( 
            &g_pusActiveDeviceList[ ucNewLana ], usCurDevice.Buffer 
            );


        //
        //  for each FCB
        //      Acquire locks
        //      update MaxLana
        //      update LanaEnum
        //      update driver list
        //        

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            pfcb = pfe-> pfcb;
            
            LOCK_RESOURCE( pfcb );


            //
            // Add device name to list of drivers for this FCB.
            // If allocation fails for any FCB stop adding to any further
            // FCBs you are out of memory
            //

            nsStatus = AllocateAndCopyUnicodeString( 
                            &pfcb-> pDriverName[ ucNewLana ],
                            pusDeviceName
                            );

            if ( !NT_SUCCESS( nsStatus ) )
            {
                NbPrint( (
                    "Netbios : Failed to allocate for device name %x\n",
                    nsStatus
                    ) );
                    
                UNLOCK_RESOURCE( pfcb );

                break;
            }

            else
            {
                pfcb-> MaxLana = ulMaxLana;

                pfcb-> LanaEnum.lana[ pfcb-> LanaEnum.length ] = ucNewLana;

                pfcb-> LanaEnum.length++;
            }

            IF_NBDBG( NB_DEBUG_LIST_LANA )
            {
                DumpDeviceList( pfcb );
            }
        
            
            UNLOCK_RESOURCE( pfcb );


#if AUTO_RESET

            //
            // add this list of lana to be reset
            //

            prle = ExAllocatePoolWithTag( 
                        NonPagedPool, sizeof( RESET_LANA_ENTRY ), 'fSBN' 
                        );

            if ( prle == NULL )
            {
                NbPrint( ("Failed to allocate RESET_LANA_ENTRY\n") );
                continue;
            }

            InitializeListHead( &prle-> leList );
            prle-> ucLanaNum = ucNewLana;
            InsertTailList( &pfe-> leResetList, &prle-> leList );

            //
            // Notify the user mode apps that a new LANA has been added.
            //

            NotifyUserModeNetbios( pfe );
#endif
        }

        UNLOCK_GLOBAL();
            

    } while ( FALSE );


    //
    // deallocate LanaMap
    //

    if ( pkvfi != NULL )
    {
        ExFreePool( pkvfi );
    }

    
    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( (
            "\n---- Netbios : TdiBindHandler exited for device : %ls ----\n", 
            pusDeviceName-> Buffer
            ) );
    }

    return;
}



//----------------------------------------------------------------------------
// NbTdiUnbindHandler
//
// Call back function that process a TDI unbind notification that indicates
// a device has been removed.
//----------------------------------------------------------------------------

VOID
NbTdiUnbindHandler(
    IN      PUNICODE_STRING     pusDeviceName
    )
{

    UCHAR       ucLana = 0, ucInd = 0;
    ULONG       ulMaxLana;
    PLIST_ENTRY ple = NULL;
    PFCB_ENTRY  pfe = NULL;
    PFCB        pfcb = NULL;

    NTSTATUS    nsStatus;
    

    PAGED_CODE();

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n++++ Netbios : TdiUnbindHandler : entered for device : %ls ++++\n",
            pusDeviceName-> Buffer 
            ) );
    }


    do
    {
        //
        // Acquire Global lock
        //

        LOCK_GLOBAL();


        //
        // find device in global active device list and remove it.
        //

        for ( ucLana = 0; ucLana <= g_ulMaxLana; ucLana++ )
        {
            if ( g_pusActiveDeviceList[ ucLana ].Buffer == NULL )
            {
                continue;
            }
            
            if ( !RtlCompareUnicodeString(
                    &g_pusActiveDeviceList[ ucLana ],
                    pusDeviceName,
                    FALSE
                    ) )
            {
                ExFreePool( g_pusActiveDeviceList[ ucLana ].Buffer );
            
                RtlInitUnicodeString( &g_pusActiveDeviceList[ ucLana ], NULL );
            
                break;
            }
        }


        //
        // device was not found.  There is nothing more to be done.
        //
    
        if ( ucLana > g_ulMaxLana )
        {
            UNLOCK_GLOBAL();
            NbPrint( ( 
                "Netbios : device not found %ls\n", pusDeviceName-> Buffer
                ) );

            break;
        }
    

        //
        // Update Max Lana
        //

        nsStatus = GetMaxLana( &g_usRegistryPath, &g_ulMaxLana );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            UNLOCK_GLOBAL();
            NbPrint( (
                "Netbios : GetMaxLana failed with status %lx\n", nsStatus 
                ) );
            break;
        }
        

        //
        // update global Lana enum
        //

        for ( ucInd = 0; ucInd < g_leLanaEnum.length; ucInd++ )
        {
            if ( ucLana == g_leLanaEnum.lana[ ucInd ] )
            {
                break;
            }
        }


        if ( ucInd < g_leLanaEnum.length ) 
        {
            //
            // device present in Lana Enum.  Remove it
            // by sliding over the rest of the lana enum.
            //

            RtlCopyBytes( 
                &g_leLanaEnum.lana[ ucInd ],
                &g_leLanaEnum.lana[ ucInd + 1],
                g_leLanaEnum.length - ucInd - 1
                );

            g_leLanaEnum.length--;
        }

        
        //
        // Walk the list of FCB and remove this device from each FCB.
        // clean up for this resource.
        //

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            pfcb = pfe-> pfcb;
            

            //
            // update max lana, lana enum.
            // delete device name and cleanup lana
            //
 
            LOCK_RESOURCE( pfcb );


            //
            // update global structures
            //
            
            pfcb-> MaxLana = g_ulMaxLana;

            RtlCopyMemory( &pfcb-> LanaEnum, &g_leLanaEnum, sizeof( LANA_ENUM ) );

        
            //
            // remove device from list of active device
            //
            
            if ( pfcb-> pDriverName[ ucLana ].Buffer != NULL )
            {
                ExFreePool( pfcb-> pDriverName[ ucLana ].Buffer );

                RtlInitUnicodeString( &pfcb-> pDriverName[ ucLana ], NULL );
            }

            IF_NBDBG( NB_DEBUG_LIST_LANA )
            {
                DumpDeviceList( pfcb );
            }
        

            //
            // clean up lana info for this device.
            //
            
            if ( pfcb-> ppLana[ ucLana ] != NULL )
            {
                UNLOCK_RESOURCE( pfcb );
                CleanupLana( pfcb, ucLana, TRUE );
            }

            else
            {
                UNLOCK_RESOURCE( pfcb );
            }
        }

        UNLOCK_GLOBAL();

    } while ( FALSE );


    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n---- Netbios : TdiUnbindHandler : exited for device : %ls ----\n", 
            pusDeviceName-> Buffer 
            ) );
    }

    return;    
}



#if AUTO_RESET

VOID
NotifyUserModeNetbios(
    IN  PFCB_ENTRY      pfe
)
/*++

Description :
    This routine notifies the mode component of NETBIOS in NETAPI32.DLL
    of new LANAs that have been bound to NETBIOS.  This is done by 
    completing IRPs that have been pended with the kernel mode component.

Arguements :
    pfe - Pointer to FCB entry.

Return Value :
    None

Environment :
    Called in the context of the TDI bind handler.  Assumes that the GLOBAL
    resource lock is held when invoking this call.
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    PIRP pIrp;

    KIRQL irql;

    PLIST_ENTRY  ple, pleNode;

    PRESET_LANA_ENTRY   prle;
    
    PNCB pUsersNCB;
#if defined(_WIN64)
    PNCB32 pUsersNCB32;
#endif

    

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( 
            ("\n++++ Netbios : ENTERED NotifyUserModeNetbios : %p ++++\n", pfe)
            );
    }

    
    //
    // Complete each of the pending IRPs to signal the reset lana event.
    // This causes netapi32.dll to reset the specified LANA
    //
    
    
    if ( !IsListEmpty( &pfe-> leResetIrp ) )
    {
        //
        // get the first LANA that needs resetting
        //

        ple = RemoveHeadList( &pfe-> leResetList );

        prle = CONTAINING_RECORD( ple, RESET_LANA_ENTRY, leList );


        //
        // Acquire the spin lock for the IRP
        //
        
        IoAcquireCancelSpinLock( &irql );

        pleNode = RemoveHeadList( &pfe-> leResetIrp );

        pIrp = CONTAINING_RECORD( pleNode, IRP, Tail.Overlay.ListEntry );

        IoSetCancelRoutine( pIrp, NULL );

        pIrp->IoStatus.Status       = STATUS_SUCCESS;
        
        //
        // Return the LANA number.
        //
#if defined(_WIN64)
        if (IoIs32bitProcess(pIrp))
        {
            pUsersNCB32 = (PNCB32) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB32->ncb_lana_num = prle-> ucLanaNum;
            pIrp->IoStatus.Information  = sizeof( NCB32 );
        }
        else
#else
        {
            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB->ncb_lana_num = prle-> ucLanaNum;
            pIrp->IoStatus.Information  = sizeof( NCB );
        }
#endif
        
        IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
        {
            NbPrint( 
                ("\n++++ Netbios : IRP %p, LANA %d\n", pIrp, prle-> ucLanaNum)
                );

            NbPrint( 
                ("Output Buffer %p, System Buffer %p ++++\n", 
                 pIrp-> UserBuffer, pIrp-> AssociatedIrp.SystemBuffer )
                );
        }
        
        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock( irql );

        IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );
    }


    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( 
            ("\n++++ Netbios : EXITING NotifyUserModeNetbios : %p ++++\n", pfe)
            );
    }

}

#endif


VOID
DumpDeviceList(
    IN      PFCB        pfcb
)
{

    UCHAR ucInd = 0, ucInd1 = 0;

    
    //
    // for each Lana, print device name, lana, enumerated or not.
    //

    NbPrint( ( 
        "\n++++ Netbios : list of current devices ++++\n"
        ) );

    for ( ucInd = 0; ucInd <= pfcb-> MaxLana; ucInd++ )
    {
        if ( pfcb-> pDriverName[ucInd].Buffer == NULL )
        {
            continue;
        }

        NbPrint( ( "Lana : %d\t", ucInd ) );

        for ( ucInd1 = 0; ucInd1 < pfcb-> LanaEnum.length; ucInd1++ )
        {
            if ( pfcb-> LanaEnum.lana[ ucInd1 ] == ucInd )
            {
                break;
            }
        }

        if ( ucInd1 < pfcb-> LanaEnum.length )
        {
            NbPrint( ( "Enabled \t" ) );
        }
        else
        {
            NbPrint( ( "Disabled\t" ) );
        }

        NbPrint( ( "%ls\n", pfcb-> pDriverName[ ucInd ].Buffer ) );
    }

    NbPrint( ("++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nb.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    device object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include <zwapi.h>
//#include <ntos.h>

typedef ADAPTER_STATUS  UNALIGNED *PUADAPTER_STATUS;
typedef NAME_BUFFER     UNALIGNED *PUNAME_BUFFER;
typedef SESSION_HEADER  UNALIGNED *PUSESSION_HEADER;
typedef SESSION_BUFFER  UNALIGNED *PUSESSION_BUFFER;

#if DBG
ULONG NbDebug = 0;
#endif

#if PAGED_DBG
ULONG ThisCodeCantBePaged;
#endif

PEPROCESS NbFspProcess = NULL;

//
// for PNP the list of devices is not static and hence cannot be read
// from the registry.  A global list of active devices is maintained.
// This list is updated by the bind and unbind handlers.  In addition
// to the device list the MaxLana and the LanaEnum also need to be
// updated to reflect the presence/absence of devices.
//

ULONG               g_ulMaxLana;

LANA_ENUM           g_leLanaEnum;

PUNICODE_STRING     g_pusActiveDeviceList;

HANDLE              g_hBindHandle;

UNICODE_STRING      g_usRegistryPath;


//
// every load of the netapi32.dll results in an open call (IRP_MJ_CREATE)
// call to the netbios.sys driver.  Each open creates an FCB that contains
// a list of devices, MaxLana and a LanaEnum.  Each FCB needs to be updated
// to reflect the changes to the active device list.
//
// In addition the LanaInfo structure corresponding to a Lana that has
// been unbound needs to be cleaned up.
//

LIST_ENTRY          g_leFCBList;

ERESOURCE           g_erGlobalLock;


//
// Each application that uses the NETBIOS api (via the netapi32.dll),
// opens a handle to \\Device\Netbios.  This file handle is not closed
// until netapi32.dll is unloaded.
//
// In order to be able to unload netbios.sys these handles have to be
// closed. To force these handles to be closed, the NETAPI32.DLL now
// posts an IOCTL (IOCTL_NB_REGISTER) to listen for shutdown
// notifications.  The IRPs corresponding to these IOCTLs are pended,
//
// When the driver is being stopped (unloaded), the pended IRPs are
// completed indicating to netapi32 that it needs to close the open
// handles on \\Device\netbios.
//
// Once all the handles have been closed NETBIOS.SYS can be unloaded.
//

ERESOURCE           g_erStopLock;       // protects g_ulNumOpens and
                                        // g_dwnetbiosState

DWORD               g_dwNetbiosState;

ULONG               g_ulNumOpens;


LIST_ENTRY          g_leWaitList;

KEVENT              g_keAllHandlesClosed;



NTSTATUS
NbAstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

VOID
CopyAddresses(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbFindName(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbSstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

VOID
CopySessionStatus(
    IN PDNCB pdncb,
    IN PCB pcb,
    IN PUSESSION_HEADER pSessionHeader,
    IN PUSESSION_BUFFER* ppSessionBuffer,
    IN PULONG pLengthRemaining
    );

NTSTATUS
NbEnum(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbReset(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbAction(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbCancel(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    );


//
// Pnp Stop related functions
//

NTSTATUS
NbRegisterWait(
    IN      PIRP                pIrp
    );

VOID
CancelIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
NbStop(
    );


#if AUTO_RESET

NTSTATUS
NbRegisterReset(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
);

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NbDispatch)
#pragma alloc_text(PAGE, NbDeviceControl)
#pragma alloc_text(PAGE, NbOpen)
#pragma alloc_text(PAGE, NbClose)
#pragma alloc_text(PAGE, NbAstat)
#pragma alloc_text(PAGE, NbEnum)
#pragma alloc_text(PAGE, NbReset)
#pragma alloc_text(PAGE, NbFindName)
#pragma alloc_text(PAGE, AllocateAndCopyUnicodeString)

#endif

NTSTATUS
NbCompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the Netbios driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("NbCompletion event: %lx, Irp: %lx, DeviceObject: %lx\n",
            Context,
            Irp,
            DeviceObject));
    }

    KeSetEvent((PKEVENT )Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
FindNameCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the TDI Irp used to issue a Find Name to netbt.
    It's main job is to clear the MdlAddress field in the IRP since it was
    borrowed from the original user mode IRP.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - User supplied context arg (not used)

Return Value:

    STATUS_SUCCESS

--*/
{
    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("FindNameCompletion: Irp: %lx, DeviceObject: %lx\n",
            Irp,
            DeviceObject));
    }

    Irp->MdlAddress = NULL;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );
}

NTSTATUS
NbCompletionPDNCB(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by setting the length and status bytes
    in the NCB supplied in context.

    Send requests have additional processing to remove the send request from
    the connection block send list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    NTSTATUS Status = STATUS_SUCCESS;


    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint(("NbCompletionPDNCB pdncb: %lx, Command: %lx, Lana: %lx,"
            "Status: %lx, Length: %lx\n",
            Context,
            pdncb-> ncb_command,
            pdncb-> ncb_lana_num,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information));
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        NCB_COMPLETE( pdncb, NRC_GOODRET );

    } else {

        if (((pdncb->ncb_command & ~ASYNCH) == NCBRECV ) ||
            ((pdncb->ncb_command & ~ASYNCH) == NCBRECVANY )) {

            if ( Irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {

                PIRP LocalIrp = NULL;
                KIRQL OldIrql;              //  Used when SpinLock held.
                PPCB ppcb;
                PDEVICE_OBJECT LocalDeviceObject;

                LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

                //
                //  The transport will not indicate again so we must put
                //  another receive down if we can.
                //  If an Irp cannot be built then BuildReceiveIrp will
                //  set ReceiveIndicated.
                //

                ppcb = FindCb( pdncb->pfcb, pdncb, FALSE );

                if ( ppcb != NULL ) {

                    LocalDeviceObject = (*ppcb)->DeviceObject;

                    LocalIrp = BuildReceiveIrp( *ppcb );


                }

                UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );

                if ( LocalIrp != NULL ) {
                    IoCallDriver (LocalDeviceObject, LocalIrp);
                }

            }

        }

        NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );

    }

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

    //
    //  Remove the Send request from the send queue. We have to scan
    //  the queue because they may be completed out of order if a send
    //  is rejected because of resource limitations.
    //

    if (((pdncb->ncb_command & ~ASYNCH) == NCBSEND ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSEND ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBSENDNA ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSENDNA )) {
        PLIST_ENTRY SendEntry;
        PPCB ppcb;
        KIRQL OldIrql;                      //  Used when SpinLock held.

        LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

        ppcb = FindCb( pdncb->pfcb, pdncb, FALSE );

        //
        //  If the connection block still exists remove the send. If the connection
        //  has gone then we no longer need to worry about maintaining the list.
        //

        if ( ppcb != NULL ) {
            #if DBG
            BOOLEAN Found = FALSE;
            #endif
            PCB pcb = *ppcb;

            for (SendEntry = pcb->SendList.Flink ;
                 SendEntry != &pcb->SendList ;
                 SendEntry = SendEntry->Flink) {

                PDNCB pSend = CONTAINING_RECORD( SendEntry, DNCB, ncb_next);

                if ( pSend == pdncb ) {

                    #if DBG
                    Found = TRUE;
                    #endif

                    RemoveEntryList( &pdncb->ncb_next );
                    break;
                }

            }

            ASSERT( Found == TRUE);

            //
            //  If the session is being hung up then we may wish to cleanup the connection
            //  as well. STATUS_HANGUP_REQUIRED will cause the dll to manufacture
            //  another hangup. The manufactured hangup will complete along with
            //  pcb->pdncbHangup. This method is used to ensure that when a
            //  hangup is delayed by an outstanding send and the send finally
            //  completes, that the user hangup completes after all operations
            //  on the connection.
            //

            if (( IsListEmpty( &pcb->SendList) ) &&
                ( pcb->pdncbHangup != NULL )) {

                IF_NBDBG (NB_DEBUG_COMPLETE) {
                    NbPrint( ("NbCompletionPDNCB Hangup session: %lx\n", ppcb ));
                }

                Status = STATUS_HANGUP_REQUIRED;
            }
        }

        UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    Irp->IoStatus.Status = Status;

    NbCheckAndCompleteIrp32(Irp);

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine performs initialization of the NetBIOS driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of the Netbios node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;
    //STRING AnsiNameString;


    //
    // bind handler info.
    //

    TDI_CLIENT_INTERFACE_INFO tcii;
    PWSTR wsClientName = NETBIOS;
    UNICODE_STRING usClientName;
    UCHAR ucInd = 0;



    PAGED_CODE();

    //

#ifdef MEMPRINT
    MemPrintInitialize ();
#endif

    //
    //  Create the device object for NETBIOS. For now, we simply create
    //  \Device\Netbios using a unicode string.
    //

    NbFspProcess = PsGetCurrentProcess();

    RtlInitUnicodeString( &UnicodeString, NB_DEVICE_NAME);

    status = NbCreateDeviceContext (DriverObject,
                 &UnicodeString,
                 &DeviceContext,
                 RegistryPath);

    if (!NT_SUCCESS (status)) {
        NbPrint( ("NbInitialize: Netbios failed to initialize\n"));
        return status;
    }

    //
    // PnP additions - V Raman
    //

    //
    // save registry path.
    //

    g_usRegistryPath.Buffer = (PWSTR) ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( WCHAR ) * (RegistryPath-> Length + 1),
                                'fSBN'
                                );

    if ( g_usRegistryPath.Buffer == NULL )
    {
        NbPrint( (
            "DriverEntry : Netbios failed to allocate memory for registry path\n"
            ) );
        return STATUS_NO_MEMORY;
    }


    g_usRegistryPath.MaximumLength =
        sizeof( WCHAR ) * (RegistryPath-> Length + 1);

    RtlCopyUnicodeString( &g_usRegistryPath, RegistryPath );


    //
    // Save lana information.
    //

    status = GetMaxLana( &g_usRegistryPath, &g_ulMaxLana );

    if ( !NT_SUCCESS( status ) )
    {
        ExFreePool( g_usRegistryPath.Buffer );
        return status;
    }


    //
    // On starup there are no devices and no Lanas enabled.
    //

    g_leLanaEnum.length = 0;

    g_pusActiveDeviceList = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( UNICODE_STRING ) * ( MAX_LANA + 1 ),
                                'fSBN'
                                );

    if ( g_pusActiveDeviceList == NULL )
    {
        ExFreePool( g_usRegistryPath.Buffer );

        NbPrint( (
            "DriverEntry : Netbios failed to allocate memory for device list\n"
            ) );

        return STATUS_NO_MEMORY;
    }

    for ( ucInd = 0; ucInd <= MAX_LANA; ucInd++ )
    {
        RtlInitUnicodeString( &g_pusActiveDeviceList[ ucInd ], NULL );
    }


    //
    // There are no FCBs.
    //

    InitializeListHead( &g_leFCBList );

    ExInitializeResourceLite( &g_erGlobalLock );



    InitializeListHead( &g_leWaitList );

    ExInitializeResourceLite( &g_erStopLock );

    KeInitializeEvent( &g_keAllHandlesClosed, SynchronizationEvent, FALSE );

    g_ulNumOpens = 0;

    g_dwNetbiosState = NETBIOS_RUNNING;


    DeviceContext->Initialized = TRUE;


    //
    // set up binding handlers
    //

    RtlZeroMemory( &tcii, sizeof( TDI_CLIENT_INTERFACE_INFO ) );

    tcii.TdiVersion = TDI_CURRENT_VERSION;

    RtlInitUnicodeString( &usClientName, wsClientName );
    tcii.ClientName = &usClientName;


    tcii.BindingHandler = NbBindHandler;
    tcii.PnPPowerHandler = NbPowerHandler;

    status = TdiRegisterPnPHandlers(
                &tcii,
                sizeof( TDI_CLIENT_INTERFACE_INFO ),
                &g_hBindHandle
                );

    if ( status != STATUS_SUCCESS )
    {
        //
        // failed to register bind/unbind handlers
        //

        NbPrint( (
            "Netbios : DriverEntry : failed to register Bind handlers %0x\n", status
            ) );

        g_hBindHandle = NULL;


        ExDeleteResourceLite( &g_erStopLock );


        ExDeleteResourceLite( &g_erGlobalLock );

        ExFreePool( g_pusActiveDeviceList );

        ExFreePool( g_usRegistryPath.Buffer );

        DeviceContext->Initialized = FALSE;

        return status;
    }


    IF_NBDBG (NB_DEBUG_DISPATCH) {
        NbPrint( ("NbInitialize: Netbios initialized.\n"));
    }

    return (status);
}


VOID
NbDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the unload routine for the NB device driver.
    In response to an unload request this function deletes the
    "\\device\netbios" created by DriverEntry.

Arguments:

    DriverObject - Pointer to the driver object created by the system

Return Value:

    None

--*/

{
    NTSTATUS    nsStatus;

    UCHAR       ucIndex = 0;


    nsStatus = TdiDeregisterPnPHandlers( g_hBindHandle );

    if ( !NT_SUCCESS( nsStatus ) )
    {
        NbPrint( (
            "Netbios : NbDriverUnload : Failed to de-register bind handler\n"
            ) );
    }


    //
    // all opens to Netbios have been closed.
    // All devices have been unbound
    //    remove all global resources
    //

    LOCK_GLOBAL();

    for ( ucIndex = 0; ucIndex < g_ulMaxLana; ucIndex++ )
    {
        if ( g_pusActiveDeviceList[ ucIndex ].Buffer != NULL )
        {
            ExFreePool ( g_pusActiveDeviceList[ ucIndex ].Buffer );
        }
    }

    ExDeleteResourceLite( &g_erStopLock );

    ExFreePool( g_pusActiveDeviceList );

    ExFreePool( g_usRegistryPath.Buffer );

    UNLOCK_GLOBAL();

    ExDeleteResourceLite( &g_erGlobalLock );

    IoDeleteDevice( DriverObject-> DeviceObject );
}



NTSTATUS
NbDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the NB device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_CONTEXT DeviceContext;

    PAGED_CODE();

    //
    // Check to see if NB has been initialized; if not, don't allow any use.
    //

    DeviceContext = (PDEVICE_CONTEXT)DeviceObject;
    if (!DeviceContext->Initialized) {
        NbCompleteRequest( Irp, STATUS_SUCCESS);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (IrpSp->MajorFunction) {

        //
        // The Create function opens a handle that can be used with fsctl's
        // to build all interesting operations.
        //

        case IRP_MJ_CREATE:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CREATE.\n"));
            }

            //
            // check if netbios is in the process of stopping
            //

            LOCK_STOP();

            if ( g_dwNetbiosState == NETBIOS_STOPPING )
            {
                //
                // fail the CREATE operation and quit
                //

                Status = STATUS_NO_SUCH_DEVICE;
                Irp->IoStatus.Information = 0;

                UNLOCK_STOP();
            }

            else
            {
                //
                // netbios is still running.  Increment count of
                // open handles
                //

                g_ulNumOpens++;

                IF_NBDBG (NB_DEBUG_DISPATCH)
                {
                    NbPrint( ( "[NETBIOS] : NbOpen OpenCount %d\n", g_ulNumOpens ) );
                }

                UNLOCK_STOP();

                Status = NbOpen ( DeviceContext, IrpSp );
                Irp->IoStatus.Information = FILE_OPENED;

                //
                // if NbOpen failed, decrement count and return error
                //

                if ( !NT_SUCCESS( Status ) )
                {
                    LOCK_STOP();

                    g_ulNumOpens--;

                    IF_NBDBG (NB_DEBUG_DISPATCH)
                    {
                        NbPrint( ( "[NETBIOS] : NbOpen Open Error %lx, numopens : %d\n", Status, g_ulNumOpens ) );
                    }

                    //
                    // check if netbios is in the process of being stopped
                    //

                    if ( ( g_ulNumOpens == 0 ) &&
                         ( g_dwNetbiosState == NETBIOS_STOPPING ) )
                    {
                        //
                        // signal the stopping thread
                        //

                        KeSetEvent( &g_keAllHandlesClosed, 0, FALSE );

                        IF_NBDBG (NB_DEBUG_DISPATCH)
                        {
                            NbPrint( ( "[NETBIOS] : NbOpen error %lx; ", Status ) );
                            NbPrint( ( "Set stop event\n" ) );
                        }
                    }

                    UNLOCK_STOP();
                }
            }
            break;

        //
        // The Close function closes a transport , terminates
        // all outstanding transport activity on the transport, and unbinds
        // the from its transport address, if any. If this
        // is the last transport endpoint bound to the address, then
        // the address is removed by the provider.
        //

        case IRP_MJ_CLOSE:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CLOSE.\n"));
            }


            Status = NbClose( IrpSp);

            if ( NT_SUCCESS( Status ) )
            {

                LOCK_STOP();

                g_ulNumOpens--;

                IF_NBDBG (NB_DEBUG_DISPATCH)
                {
                    NbPrint( ( "[NETBIOS] : NbClose OpenCount %d\n", g_ulNumOpens ) );
                }

                if ( ( g_ulNumOpens == 0 ) &&
                     ( g_dwNetbiosState == NETBIOS_STOPPING ) )
                {
                    //
                    // netbios is shutting down and this is the
                    // last open file handle, signal the stopping
                    // thread
                    //

                    KeSetEvent( &g_keAllHandlesClosed, 0, FALSE );

                    IF_NBDBG (NB_DEBUG_DISPATCH)
                    {
                        NbPrint( ( "[NETBIOS] : NbClose, Set stop event\n" ) );
                    }
                }

                UNLOCK_STOP();
            }

            break;

        //
        // The DeviceControl function is the main path to the transport
        // driver interface.  Every TDI request is assigned a minor
        // function code that is processed by this function.
        //

        case IRP_MJ_DEVICE_CONTROL:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_DEVICE_CONTROL, Irp: %lx.\n", Irp ));
            }

            Status = NbDeviceControl (DeviceObject, Irp, IrpSp);

            if ((Status != STATUS_PENDING) &&
                (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_NB_NCB)) {

                //
                // Bug # : 340042
                //
                // Set the IoStatus.Information field only for IOCTL_NB_NCB.
                // For other IOCTLs it is either irrelevant or the IOCTL processing
                // will set it itself
                //

                //
                //  Tell IopCompleteRequest how much to copy back when the
                //  request completes. We need to do this for cases where
                //  NbCompletionPDNCB is not used.
                //
                Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            }

#if DBG
            if ( (Status != STATUS_SUCCESS) &&
                 (Status != STATUS_PENDING ) &&
                 (Status != STATUS_HANGUP_REQUIRED )) {

               IF_NBDBG (NB_DEBUG_DISPATCH) {
                   NbPrint( ("NbDispatch: Invalid status: %X.\n", Status ));
                   ASSERT( FALSE );
               }
            }
#endif
            break;

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, ignore it. We will do all the work on the close Irp.
        //

        case IRP_MJ_CLEANUP:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CLEANUP.\n"));
            }
            Status = STATUS_SUCCESS;
            break;

        default:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: OTHER (DEFAULT).\n"));
            }
            Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status == STATUS_PENDING) {
        IF_NBDBG (NB_DEBUG_DISPATCH) {
            NbPrint( ("NbDispatch: request PENDING from handler.\n"));
        }
    } else {
        IF_NBDBG (NB_DEBUG_DISPATCH) {
            NbPrint( ("NbDispatch: request COMPLETED by handler.\n"));
        }

        /*
         * Thunk the NCB back to 32-bit compatible
         * structure if the caller is a 32-bit app.
         */
        NbCheckAndCompleteIrp32(Irp);

        NbCompleteRequest( Irp, Status);
    }

    return Status;
} /* NbDispatch */

NTSTATUS
NbDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dispatches NetBios request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNCB pUsersNcb;
    PDNCB pdncb = NULL;
    PUCHAR Buffer2;
    ULONG Buffer2Length;
    ULONG RequestLength;
    BOOLEAN Is32bitProcess;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
        NbPrint( ("NbDeviceControl: Entered...\n"));
    }

    switch ( IrpSp->Parameters.DeviceIoControl.IoControlCode )
    {
        case IOCTL_NB_NCB :
            break;

        case IOCTL_NB_REGISTER_STOP :
            Status = NbRegisterWait( Irp );
            return Status;

        case IOCTL_NB_STOP :
            Status = NbStop();
            return Status;

#if AUTO_RESET
        case IOCTL_NB_REGISTER_RESET :
            Status = NbRegisterReset( Irp, IrpSp );
            return Status;
#endif

        default:
        {
            IF_NBDBG (NB_DEBUG_DEVICE_CONTROL)
            {
                NbPrint( ("NbDeviceControl: invalid request type.\n"));
            }

            return STATUS_INVALID_DEVICE_REQUEST;
        }

    }


    //
    //  Caller provided 2 buffers. The first is the NCB.
    //  The second is an optional buffer for send or receive data.
    //  Since the Netbios driver only operates in the context of the
    //  calling application, these buffers are directly accessable.
    //  however they can be deleted by the user so try-except clauses are
    //  required.
    //

    pUsersNcb = (PNCB)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    RequestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    Buffer2 = Irp->UserBuffer;
    Buffer2Length = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

#if defined(_WIN64)
    Is32bitProcess = IoIs32bitProcess(Irp);
    if (Is32bitProcess == TRUE) {
        if (RequestLength != sizeof( NCB32 )) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
#endif

    if ( RequestLength != sizeof( NCB ) ) {
        return STATUS_INVALID_PARAMETER;
    }
#if defined(_WIN64)
    }
#endif

    try {

        //
        // Probe the input buffer
        //

        if (ExGetPreviousMode() != KernelMode) {
            ProbeForWrite(pUsersNcb, RequestLength, 4);
        }

        //
        //  Create a copy of the NCB and convince the IO system to
        //  copy it back (and deallocate it) when the IRP completes.
        //

        Irp->AssociatedIrp.SystemBuffer =
            ExAllocatePoolWithTag( NonPagedPool, sizeof( DNCB ), 'nSBN' );

        if (Irp->AssociatedIrp.SystemBuffer == NULL) {
            //
            //  Since we cannot allocate the drivers copy of the NCB, we
            //  must turn around and use the original Ncb to return the error.
            //

#if defined(_WIN64)
            if (Is32bitProcess) {
                NCB32 *pUsersNcb32 = (PNCB32)
                                     IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                pUsersNcb32->ncb_retcode = NRC_NORES;
            } else {
#endif
                pUsersNcb->ncb_retcode  = NRC_NORES;

#if defined(_WIN64)
            }
#endif

            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

            return STATUS_SUCCESS;
        }

        //
        // Tell the IO system where to copy the ncb back to during
        // IoCompleteRequest.
        //

        Irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER |
                        IRP_INPUT_OPERATION );

        Irp->UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;


        //  In the driver we should now use our copy of the NCB
        pdncb = Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
        if (Is32bitProcess == TRUE) {
            RtlZeroMemory(pdncb, sizeof( DNCB ));
            NbThunkNcb((PNCB32)pUsersNcb, pdncb);
        } else {
#endif
        RtlMoveMemory( pdncb,
                       pUsersNcb,
                       FIELD_OFFSET( DNCB, ncb_cmd_cplt )+1 );

#if defined(_WIN64)
        }
#endif
        //
        //  Save the users virtual address for the NCB just in case the
        //  virtual address is supplied in an NCBCANCEL. This is the same
        //  as Irp->UserBuffer.
        //

        pdncb->users_ncb = pUsersNcb;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
            NbPrint( ("NbDeviceControl: Exception1 %X.\n", Status));
        }

        if (pdncb != NULL) {
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
        }

        return Status;
    }

    if ( Buffer2Length ) {

        //  Mdl will be freed by IopCompleteRequest.
        Irp->MdlAddress = IoAllocateMdl( Buffer2,
                                     Buffer2Length,
                                     FALSE,
                                     FALSE,
                                     Irp  );
        ASSERT( Irp->MdlAddress != NULL );


        //
        // Added by V Raman for bug fix : 127223
        //
        // Check if MDL allocate failed and return.
        //

        if ( Irp-> MdlAddress == NULL )
        {
            IF_NBDBG(NB_DEBUG_DEVICE_CONTROL)
                NbPrint( ("[NETBIOS] NbDeviceControl: Failed to allocate MDL") );

            NCB_COMPLETE( pdncb, NRC_NORES );
            return STATUS_SUCCESS;
        }


        try {
            MmProbeAndLockPages( Irp->MdlAddress,
                                Irp->RequestorMode,
                                (LOCK_OPERATION) IoModifyAccess);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
                NbPrint( ("NbDeviceControl: Exception2 %X.\n", Status));
                NbPrint( ("NbDeviceControl: IoContolCode: %lx, Fcb: %lx,"
                      " ncb_command %lx, Buffer2Length: %lx\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode,
                        IrpSp->FileObject->FsContext2,
                        pdncb->ncb_command,
                        Buffer2Length));
            }
            if ( Irp->MdlAddress != NULL ) {
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
            }
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
            return STATUS_SUCCESS;
        }
    } else {
        ASSERT( Irp->MdlAddress == NULL );
    }

    IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
        NbPrint( ("NbDeviceControl: Fcb: %lx, Ncb: %lx"
              " ncb_command %lx, ncb_lana_num: %lx\n",
                IrpSp->FileObject->FsContext2,
                pdncb,
                pdncb->ncb_command,
                pdncb->ncb_lana_num));
    }

    switch ( pdncb->ncb_command & ~ASYNCH ) {

    case NCBCALL:
    case NCALLNIU:
        Status = NbCall( pdncb, Irp, IrpSp );
        break;

    case NCBCANCEL:
        Status = NbCancel( pdncb, Irp, IrpSp );
        break;

    case NCBLISTEN:
        Status = NbListen( pdncb, Irp, IrpSp );
        break;

    case NCBHANGUP:
        Status = NbHangup( pdncb, Irp, IrpSp );
        break;

    case NCBASTAT:
        Status = NbAstat( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBFINDNAME:
        Status = NbFindName( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBSSTAT:
        Status = NbSstat( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBENUM:
        NbEnum( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBRECV:
        Status = NbReceive( pdncb, Irp, IrpSp, Buffer2Length, FALSE, 0 );
        break;

    case NCBRECVANY:
        Status = NbReceiveAny( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBDGRECV:
    case NCBDGRECVBC:
        Status = NbReceiveDatagram( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBSEND:
    case NCBSENDNA:
    case NCBCHAINSEND:
    case NCBCHAINSENDNA:
        Status = NbSend( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBDGSEND:
    case NCBDGSENDBC:
        Status = NbSendDatagram( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBADDNAME:
    case NCBADDGRNAME:
    case NCBQUICKADDNAME:
    case NCBQUICKADDGRNAME:
        NbAddName( pdncb, IrpSp );
        break;

    case NCBDELNAME:
        NbDeleteName( pdncb, IrpSp );
        break;

    case NCBLANSTALERT:
        Status = NbLanStatusAlert( pdncb, Irp, IrpSp );
        break;

    case NCBRESET:
        Status = NbReset( pdncb, Irp, IrpSp );
        break;

    case NCBACTION:
        Status = NbAction( pdncb, Irp, IrpSp);
        break;

    //  The following are No-operations that return success for compatibility
    case NCBUNLINK:
    case NCBTRACE:
        NCB_COMPLETE( pdncb, NRC_GOODRET );
        break;

    default:
        NCB_COMPLETE( pdncb, NRC_ILLCMD );
        break;
    }

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );

} /* NbDeviceControl */

NTSTATUS
NbOpen(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

Arguments:

    DeviceContext - Includes the name of the netbios node in the registry.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PAGED_CODE();

    return NewFcb( DeviceContext, IrpSp );
} /* NbOpen */


NTSTATUS
NbClose(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to close an existing handle.  This
    involves running down all of the current and pending activity associated
    with the handle, and dereferencing structures as appropriate.

Arguments:

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    PAGED_CODE();

    if (pfcb!=NULL) {

        CleanupFcb( IrpSp, pfcb );

    }

    return STATUS_SUCCESS;
} /* NbClose */

NTSTATUS
NbAstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return the adapter status. It queries the
    transport for the main adapter status data such as number of FRMR frames
    received and then uses CopyAddresses to fill in the status for the names
    that THIS application has added.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TA_NETBIOS_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN ChangedMode=FALSE;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    UNICODE_STRING usDeviceName;


    PAGED_CODE();

    RtlInitUnicodeString( &usDeviceName, NULL );


    if ( Buffer2Length >= sizeof(ADAPTER_STATUS) ) {
        KEVENT Event1;
        NTSTATUS Status;
        HANDLE TdiHandle;
        PFILE_OBJECT TdiObject;
        PDEVICE_OBJECT DeviceObject;

        RtlInitUnicodeString( &usDeviceName, NULL );


        //
        // for PNP
        //

        LOCK_RESOURCE( pfcb );


        if ( ( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
             ( pfcb->pDriverName[pdncb->ncb_lana_num].MaximumLength == 0 ) ||
             ( pfcb->pDriverName[pdncb->ncb_lana_num].Buffer == NULL ) ) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        if (( pfcb == NULL ) ||
            (pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
            (pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
            NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        Status = AllocateAndCopyUnicodeString(
                    &usDeviceName, &pfcb->pDriverName[pdncb->ncb_lana_num]
                    );

        if ( !NT_SUCCESS( Status ) )
        {
            NCB_COMPLETE( pdncb, NRC_NORESOURCES );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }


        UNLOCK_RESOURCE( pfcb );


        //  NULL returns a handle for doing control functions
        Status = NbOpenAddress (
                    &TdiHandle, (PVOID*)&TdiObject, &usDeviceName,
                    pdncb->ncb_lana_num, NULL
                    );

        if (!NT_SUCCESS(Status)) {
            IF_NBDBG (NB_DEBUG_ASTAT) {
                NbPrint(( "\n  FAILED on open of Tdi: %X ******\n", Status ));
            }
            NCB_COMPLETE( pdncb, NRC_SYSTEM );

            ExFreePool( usDeviceName.Buffer );

            return STATUS_SUCCESS;
        }

        KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

        DeviceObject = IoGetRelatedDeviceObject( TdiObject );

        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_ADAPTER_STATUS,
                Irp->MdlAddress);

        if ( pdncb->ncb_callname[0] != '*') {
            //
            //  Remote Astat. The variables used to specify the remote adapter name
            //  are kept the same as those in connect.c to aid maintenance.
            //
            PIO_STACK_LOCATION NewIrpSp = IoGetNextIrpStackLocation (Irp);

            ConnectBlock.TAAddressCount = 1;
            ConnectBlock.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            ConnectBlock.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
            temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock.Address[0].Address;

            temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

            RequestInformation.RemoteAddress = &ConnectBlock;
            RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                    sizeof (TDI_ADDRESS_NETBIOS);
            ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&NewIrpSp->Parameters)
                ->RequestConnectionInformation = &RequestInformation;

             PreviousMode = Irp->RequestorMode;
             Irp->RequestorMode = KernelMode;
             ChangedMode=TRUE;


        } else {

            //
            //  Avoid situation where adapter has more names added than the process and
            //  then extra names get added to the end of the buffer.
            //

            //
            //  Map the users buffer now so that the whole buffer is mapped (not
            //  just sizeof ADAPTER_STATUS).
            //

            if (Irp->MdlAddress) {
                if (MmGetSystemAddressForMdlSafe(
                        Irp->MdlAddress, NormalPagePriority
                        ) == NULL) {

                    IF_NBDBG (NB_DEBUG_ASTAT) {
                        NbPrint(( "\nFAILED on mapping MDL ******\n" ));
                    }
                    NCB_COMPLETE( pdncb, NRC_SYSTEM );
                    ExFreePool( usDeviceName.Buffer );
                    return STATUS_SUCCESS;
                }

            } else {

                ASSERT(FALSE);
            }

            Irp->MdlAddress->ByteCount = sizeof(ADAPTER_STATUS);

        }

        IoCallDriver (DeviceObject, Irp);

        if (ChangedMode) {
            Irp->RequestorMode = PreviousMode;
        }

        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);


        //
        //  Restore length now that the transport has filled in no more than
        //  is required of it.
        //

        if (Irp->MdlAddress) {
            Irp->MdlAddress->ByteCount = Buffer2Length;
        }

        NbAddressClose( TdiHandle, TdiObject );

        if (!NT_SUCCESS(Status)) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            ExFreePool( usDeviceName.Buffer );
            return Status;
        }

        Status = Irp->IoStatus.Status;
        if (( Status == STATUS_BUFFER_OVERFLOW ) &&
            ( pdncb->ncb_callname[0] == '*')) {
            //
            //  This is a local ASTAT. Don't worry if there was not enough room in the
            //  users buffer for all the addresses that the transport knows about. There
            //  only needs to be space for the names the user has added and we will check
            //  that later.
            //
            Status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(Status)) {

            pdncb->ncb_length = (WORD)Irp->IoStatus.Information;
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );

        } else {

            if (  pdncb->ncb_callname[0] == '*') {
                //
                //  Append the addresses and Netbios maintained counts.
                //

                CopyAddresses(
                     pdncb,
                     Irp,
                     IrpSp,
                     Buffer2Length);
                //  CopyAddresses completes the NCB appropriately.

            } else {

                pdncb->ncb_length = (WORD)Irp->IoStatus.Information;
                NCB_COMPLETE( pdncb, NRC_GOODRET );

            }
        }

    } else {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    }


    //
    //  Because the completion routine returned STATUS_MORE_PROCESSING_REQUIRED
    //  NbAstat must return a status other than STATUS_PENDING so that the
    //  users Irp gets completed.
    //

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }

    ASSERT( Status != STATUS_PENDING );

    return Status;

    UNREFERENCED_PARAMETER( IrpSp );
}

VOID
CopyAddresses(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to finish the adapter status.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    none.

--*/
{
    ULONG LengthRemaining = Buffer2Length - sizeof(ADAPTER_STATUS);

    PUADAPTER_STATUS pAdapter;
    PUNAME_BUFFER pNameArray;
    int NextEntry = 0;  // Used to walk pNameArray

    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PLANA_INFO plana;
    int index;          //  Used to access AddressBlocks
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];
    if ((plana == NULL ) ||
        (plana->Status != NB_INITIALIZED)) {
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
        UNLOCK( pfcb, OldIrql );
        return;
    }

    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        pAdapter = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
        if (pAdapter == NULL) {
            NCB_COMPLETE( pdncb, NRC_NORES );
            UNLOCK( pfcb, OldIrql );
            return;
        }
    } else {

        ASSERT(FALSE);
		return;
    }

    pNameArray = (PUNAME_BUFFER)((PUCHAR)pAdapter + sizeof(ADAPTER_STATUS));

    pAdapter->rev_major = 0x03;
    pAdapter->rev_minor = 0x00;
    pAdapter->free_ncbs = 255;
    pAdapter->max_cfg_ncbs = 255;
    pAdapter->max_ncbs = 255;

    pAdapter->pending_sess = 0;
    for ( index = 0; index <= MAXIMUM_CONNECTION; index++ ) {
        if ( plana->ConnectionBlocks[index] != NULL) {
            pAdapter->pending_sess++;
        }
    }

    pAdapter->max_cfg_sess = (WORD)plana->MaximumConnection;
    pAdapter->max_sess = (WORD)plana->MaximumConnection;
    pAdapter->name_count = 0;

    //  Don't include the reserved address so start at index=2.
    for ( index = 2; index < MAXIMUM_ADDRESS; index++ ) {

        if ( plana->AddressBlocks[index] != NULL ) {

            if ( LengthRemaining >= sizeof(NAME_BUFFER) ) {

                RtlCopyMemory( (PUCHAR)&pNameArray[NextEntry],
                    &plana->AddressBlocks[index]->Name,
                    sizeof(NAME));
                pNameArray[NextEntry].name_num =
                    plana->AddressBlocks[index]->NameNumber;
                pNameArray[NextEntry].name_flags =
                    plana->AddressBlocks[index]->Status;

                LengthRemaining -= sizeof(NAME_BUFFER);
                NextEntry++;
                pAdapter->name_count++;

            } else {

                NCB_COMPLETE( pdncb, NRC_INCOMP );
                goto exit;

            }
        }
    }

    NCB_COMPLETE( pdncb, NRC_GOODRET );

exit:
    pdncb->ncb_length = (unsigned short)( sizeof(ADAPTER_STATUS) +
                                        ( sizeof(NAME_BUFFER) * NextEntry));
    UNLOCK( pfcb, OldIrql );
}

NTSTATUS
NbFindName(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return the result of a name query.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TA_NETBIOS_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    KEVENT Event1;
    HANDLE TdiHandle;
    PFILE_OBJECT TdiObject;
    PDEVICE_OBJECT DeviceObject;

    UNICODE_STRING usDeviceName;

    PIRP nbtIrp;
    PIO_STACK_LOCATION nbtIrpSp;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();


    if ((pfcb == NULL) || (Buffer2Length < (sizeof(FIND_NAME_HEADER) + sizeof(FIND_NAME_BUFFER)))) {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString( &usDeviceName, NULL );

    LOCK_RESOURCE( pfcb );

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        (pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        (pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
        return STATUS_SUCCESS;
    }

    if ( ( pfcb->pDriverName[pdncb->ncb_lana_num].MaximumLength == 0 ) ||
         ( pfcb->pDriverName[pdncb->ncb_lana_num].Buffer == NULL ) ) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    Status = AllocateAndCopyUnicodeString(
                &usDeviceName, &pfcb->pDriverName[pdncb->ncb_lana_num]
                );

    if ( !NT_SUCCESS( Status ) )
    {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return STATUS_SUCCESS;
    }


    UNLOCK_RESOURCE( pfcb );


    // NULL returns a handle for doing control functions
    Status = NbOpenAddress (
                &TdiHandle, (PVOID*)&TdiObject, &usDeviceName,
                pdncb->ncb_lana_num, NULL
                );

    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_ASTAT) {
            NbPrint(( "\n  FAILED on open of Tdi: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        ExFreePool( usDeviceName.Buffer );
        return STATUS_SUCCESS;
    }

    KeInitializeEvent (
            &Event1,
            SynchronizationEvent,
            FALSE);

    DeviceObject = IoGetRelatedDeviceObject( TdiObject );

    //
    // DDK sez we shouldn't hijack the user mode IRP. We create one of our own
    // to issue to Netbt for the query.
    //
    nbtIrp = TdiBuildInternalDeviceControlIrp(TdiBuildQueryInformation,
                                              DeviceObject,
                                              TdiObject,
                                              &Event1,
                                              &ioStatus);

    if ( nbtIrp == NULL ) {
        IF_NBDBG (NB_DEBUG_ASTAT) {
            NbPrint(( "\n  FAILED to allocate internal Irp for Tdi: %X ******\n", ioStatus.Status ));
        }
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        ExFreePool( usDeviceName.Buffer );
        return STATUS_SUCCESS;
    }

    IF_NBDBG (NB_DEBUG_ASTAT) {
        NbPrint(("NbFindName: Allocated IRP %08x for TdiBuildQueryInfo\n", nbtIrp ));
    }

    //
    // we use our own find name completion routine. We "borrow" the MDL from
    // the user mode IRP, hence it must be cleared from the TDI IRP before it
    // is completed. Findname's completion routine takes care of that detail.
    //
    TdiBuildQueryInformation( nbtIrp,
            DeviceObject,
            TdiObject,
            FindNameCompletion,
            0,
            TDI_QUERY_FIND_NAME,
            Irp->MdlAddress);

    nbtIrpSp = IoGetNextIrpStackLocation (nbtIrp);

    //
    //  The variables used to specify the remote adapter name
    //  are kept the same as those in connect.c to aid maintenance.
    //

    ConnectBlock.TAAddressCount = 1;
    ConnectBlock.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock.Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

    RequestInformation.RemoteAddress = &ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);
    ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&nbtIrpSp->Parameters)
        ->RequestConnectionInformation = &RequestInformation;

    Status = IoCallDriver (DeviceObject, nbtIrp);

    if ( Status == STATUS_PENDING ) {
        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);
    }

    NbAddressClose( TdiHandle, TdiObject );

    if (NT_SUCCESS(Status)) {
        Status = ioStatus.Status;
    }

    if (!NT_SUCCESS(Status)) {
        NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
        Status = STATUS_SUCCESS;
    } else {
        pdncb->ncb_length = (WORD)ioStatus.Information;
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    //
    //  Because the completion routine returned STATUS_MORE_PROCESSING_REQUIRED
    //  NbFindName must return a status other than STATUS_PENDING so that the
    //  users Irp gets completed.
    //

    ASSERT( Status != STATUS_PENDING );

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }

    return Status;
}

NTSTATUS
NbSstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return session status. It uses only structures
    internal to this driver.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Buffer2Length >= sizeof(SESSION_HEADER) ) {

        PFCB pfcb = IrpSp->FileObject->FsContext2;
        PLANA_INFO plana;
        int index;
        PUSESSION_HEADER pSessionHeader = NULL;
        PUSESSION_BUFFER pSessionBuffer = NULL;
        ULONG LengthRemaining;
        PAB pab;
        KIRQL OldIrql;                      //  Used when SpinLock held.

        //
        //  Prevent indications from the transport, post routines being called
        //  and another thread making a request while manipulating the netbios
        //  data structures.
        //

        LOCK( pfcb, OldIrql );

        if (pdncb->ncb_lana_num > pfcb->MaxLana ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        if (( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == (LANA_INFO *) NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        plana = pfcb->ppLana[pdncb->ncb_lana_num];

        if ( pdncb->ncb_name[0] != '*') {
            PPAB ppab = FindAb(pfcb, pdncb, FALSE);
            if ( ppab == NULL) {
                UNLOCK( pfcb, OldIrql );
                pdncb->ncb_retcode = NRC_PENDING;
                NCB_COMPLETE( pdncb, NRC_NOWILD );
                return STATUS_SUCCESS;
            }
            pab = *ppab;
        }

        //
        //  Map the users buffer so we can poke around inside
        //

        if (Irp->MdlAddress) {
            pSessionHeader = MmGetSystemAddressForMdlSafe(
                                Irp->MdlAddress, NormalPagePriority);
        }

        if ((Irp->MdlAddress == NULL) ||
            (pSessionHeader == NULL)) {

            UNLOCK( pfcb, OldIrql );
            pdncb->ncb_retcode = NRC_PENDING;
            NCB_COMPLETE( pdncb, NRC_NORES );
            return STATUS_SUCCESS;
        }

        pSessionHeader->sess_name = 0;
        pSessionHeader->num_sess = 0;
        pSessionHeader->rcv_dg_outstanding = 0;
        pSessionHeader->rcv_any_outstanding = 0;

        if ( pdncb->ncb_name[0] == '*') {
            for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
                if ( plana->AddressBlocks[index] != NULL ) {
                    PLIST_ENTRY Entry;

                    pab = plana->AddressBlocks[index];

                    for (Entry = pab->ReceiveDatagramList.Flink ;
                        Entry != &pab->ReceiveDatagramList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_dg_outstanding++ ;
                    }
                    for (Entry = pab->ReceiveBroadcastDatagramList.Flink ;
                        Entry != &pab->ReceiveBroadcastDatagramList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_dg_outstanding++ ;
                    }
                    for (Entry = pab->ReceiveAnyList.Flink ;
                        Entry != &pab->ReceiveAnyList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_any_outstanding++;
                    }
                }
            }

            pSessionHeader->sess_name = MAXIMUM_ADDRESS;

        } else {
            PLIST_ENTRY Entry;
            PAB pab255;

            //  Add entries for this name alone.
            for (Entry = pab->ReceiveDatagramList.Flink ;
                Entry != &pab->ReceiveDatagramList ;
                Entry = Entry->Flink) {
                pSessionHeader->rcv_dg_outstanding++ ;
            }
            pab255 = plana->AddressBlocks[MAXIMUM_ADDRESS];
            for (Entry = pab255->ReceiveBroadcastDatagramList.Flink ;
                Entry != &pab255->ReceiveBroadcastDatagramList ;
                Entry = Entry->Flink) {
                PDNCB pdncbEntry = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                if ( pdncbEntry->ncb_num == pab->NameNumber ) {
                    pSessionHeader->rcv_dg_outstanding++ ;
                }
            }
            for (Entry = pab->ReceiveAnyList.Flink ;
                Entry != &pab->ReceiveAnyList ;
                Entry = Entry->Flink) {
                pSessionHeader->rcv_any_outstanding++;
            }
            pSessionHeader->sess_name = pab->NameNumber;
        }

        LengthRemaining = Buffer2Length - sizeof(SESSION_HEADER);
        pSessionBuffer = (PUSESSION_BUFFER)( pSessionHeader+1 );

        for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {
            CopySessionStatus( pdncb,
                plana->ConnectionBlocks[index],
                pSessionHeader,
                &pSessionBuffer,
                &LengthRemaining);

        }

        /*        Undocumented Netbios 3.0 feature, returned length == requested
                  length and not the length of data returned. The following
                  expression gives the number of bytes actually used.
        pdncb->ncb_length = (USHORT)
                            (sizeof(SESSION_HEADER)+
                            (sizeof(SESSION_BUFFER) * pSessionHeader->num_sess));
        */

        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_GOODRET );

    } else {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( IrpSp );

}

VOID
CopySessionStatus(
    IN PDNCB pdncb,
    IN PCB pcb,
    IN PUSESSION_HEADER pSessionHeader,
    IN PUSESSION_BUFFER* ppSessionBuffer,
    IN PULONG pLengthRemaining
    )
/*++

Routine Description:

    This routine is called to determine if a session should be added
    to the callers buffer and if so it fills in the data. If there is an
    error it records the problem in the callers NCB.

Arguments:

    pdncb - Pointer to the NCB.

    pcb - Connection Block for a particular session

    pSessionHeader - Start of the callers buffer

    ppSessionBuffer - Next position to fill in inside the users buffer.

    pLengthRemaining - size in bytes remaining to be filled.

Return Value:

    none.

--*/
{
    PAB pab;
    PLIST_ENTRY Entry;

    if ( pcb == NULL ) {
        return;
    }

    pab = *(pcb->ppab);

    if (( pdncb->ncb_name[0] == '*') ||
        (RtlEqualMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ))) {

        pSessionHeader->num_sess++;

        if ( *pLengthRemaining < sizeof(SESSION_BUFFER) ) {
            NCB_COMPLETE( pdncb, NRC_INCOMP );
            return;
        }

        (*ppSessionBuffer)->lsn = pcb->SessionNumber;
        (*ppSessionBuffer)->state = pcb->Status;
        RtlMoveMemory((*ppSessionBuffer)->local_name, &pab->Name, NCBNAMSZ);
        RtlMoveMemory((*ppSessionBuffer)->remote_name, &pcb->RemoteName, NCBNAMSZ);

        (*ppSessionBuffer)->sends_outstanding = 0;
        (*ppSessionBuffer)->rcvs_outstanding = 0;

        for (Entry = pcb->SendList.Flink ;
             Entry != &pcb->SendList ;
             Entry = Entry->Flink) {
            (*ppSessionBuffer)->sends_outstanding++;
        }

        for (Entry = pcb->ReceiveList.Flink ;
             Entry != &pcb->ReceiveList ;
             Entry = Entry->Flink) {
            (*ppSessionBuffer)->rcvs_outstanding++;
        }

        *ppSessionBuffer +=1;
        *pLengthRemaining -= sizeof(SESSION_BUFFER);

    }

}

NTSTATUS
NbEnum(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to discover the available lana numbers.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Buffer2;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    PAGED_CODE();

    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        Buffer2 = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                    NormalPagePriority);
        if (Buffer2 == NULL) {
            Buffer2Length = 0;
        }
    } else {

        //
        //  Either a zero byte read/write or the request only has an NCB.
        //

        Buffer2 = NULL;
        Buffer2Length = 0;
    }


    //
    // For PNP
    //

    LOCK_RESOURCE( pfcb );

    //  Copy over as much information as the user allows.

    if ( (ULONG)pfcb->LanaEnum.length + 1 > Buffer2Length ) {
        if ( Buffer2Length > 0 ) {
            RtlMoveMemory( Buffer2, &pfcb->LanaEnum, Buffer2Length);
        }
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    } else {
        RtlMoveMemory(
            Buffer2,
            &pfcb->LanaEnum,
            (ULONG)pfcb->LanaEnum.length + 1 );

        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    UNLOCK_RESOURCE( pfcb );

    return Status;

}

NTSTATUS
NbReset(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to reset an adapter. Until an adapter is reset,
    no access to the lan is allowed.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    BOOLEAN bCleanupLana = FALSE;


    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_FILE | NB_DEBUG_CREATE_FILE) {
        NbPrint(( "\n**** RRRRRRRRESETT ***** LANA : %x, pdncb %lx\n",
                   pdncb-> ncb_lana_num, pdncb ));
        NbPrint(( "FCB : %lx\n", pfcb ));
    }

    LOCK_RESOURCE( pfcb );

    // MaxLana is really the last assigned lana number hence > not >=
    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    if ( pfcb->ppLana[pdncb->ncb_lana_num] != NULL ) {
        bCleanupLana = TRUE;
    }

    UNLOCK_RESOURCE( pfcb );


    //
    //  Wait till all addnames are completed and prevent any new
    //  ones while we reset the lana. Note We lock out addnames for all
    //  lanas. This is ok since addnames are pretty rare as are resets.
    //

    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite( &pfcb->AddResource, TRUE);

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\nNbReset have resource exclusive\n" ));
    }

    if ( bCleanupLana ) {
        CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
    }

    if ( pdncb->ncb_lsn == 0 ) {
        //  Allocate resources
        OpenLana( pdncb, Irp, IrpSp );
    } else {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    //  Allow more addnames
    ExReleaseResourceLite( &pfcb->AddResource );

    KeLeaveCriticalRegion();

    return STATUS_SUCCESS;
}

NTSTATUS
NbAction(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to access a transport specific extension. Netbios does not know
    anything about what the extension does.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbAction ****** pdncb %lx\n", pdncb ));
    }

    //
    //  The operation can only be performed on one handle so if the NCB specifies both
    //  a connection and an address then reject the request.
    //

    if (( pdncb->ncb_lsn != 0) &&
        ( pdncb->ncb_num != 0)) {
        NCB_COMPLETE( pdncb, NRC_ILLCMD );  //  No really good errorcode for this
        return STATUS_SUCCESS;
    }

    if ( pdncb->ncb_length < sizeof(ACTION_HEADER) ) {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
        return STATUS_SUCCESS;
    }

    if ( (ULONG_PTR)pdncb->ncb_buffer & 3 ) {
        NCB_COMPLETE( pdncb, NRC_BADDR ); // Buffer not word aligned
        return STATUS_SUCCESS;
    }

    LOCK( pfcb, OldIrql );

    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    if ( pdncb->ncb_lsn != 0) {
        //  Use handle associated with this connection
        PPCB ppcb;

        ppcb = FindCb( pfcb, pdncb, FALSE);

        if ( ppcb == NULL ) {
            //  FindCb has put the error in the NCB
            UNLOCK( pfcb, OldIrql );
            if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
                //  Tell dll to hangup the connection.
                return STATUS_HANGUP_REQUIRED;
            } else {
                return STATUS_SUCCESS;
            }
        }
        pcb = *ppcb;

        if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_SCLOSED );
            return STATUS_SUCCESS;
        }

        TdiBuildAction (Irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = pcb->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit connection: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;
    } else if ( pdncb->ncb_num != 0) {
        //  Use handle associated with this name
        PPAB ppab;
        PAB pab;

        ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num  );

        if ( ppab == NULL ) {
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }
        pab = *ppab;

        TdiBuildAction (Irp,
            pab->DeviceObject,
            pab->AddressObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = pab->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit address: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;

    } else {
        //  Use the control channel
        PLANA_INFO plana;

        if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
            ( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        plana = pfcb->ppLana[pdncb->ncb_lana_num];

        TdiBuildAction (Irp,
            plana->ControlDeviceObject,
            plana->ControlFileObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = plana->ControlDeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit control: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;
    }

}

NTSTATUS
NbCancel(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to cancel the ncb pointed to by NCB_BUFFER.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PDNCB target;   // Mapped in location of the USERS NCB. Not the drivers copy of the DNCB!
    BOOL SpinLockHeld;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbCancel ****** pdncb %lx\n", pdncb ));
    }


    LOCK( pfcb, OldIrql );
    SpinLockHeld = TRUE;

    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }


    if (( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }


    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        target = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
    }

    if ((Irp->MdlAddress == NULL) ||
        (target == NULL )) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_CANOCCR );
        return STATUS_SUCCESS;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbDisplayNcb( target );
    }

    try {
        if ( target->ncb_lana_num == pdncb->ncb_lana_num ) {
            switch ( target->ncb_command & ~ASYNCH ) {

            case NCBCALL:
            case NCALLNIU:
            case NCBLISTEN:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {

                    PPCB ppcb;
                    UCHAR ucLana;

                    UNLOCK_SPINLOCK(pfcb, OldIrql);
                    SpinLockHeld = FALSE;

                    //
                    // Probe the NCB buffer
                    //

                    if (ExGetPreviousMode() != KernelMode) {
                        ProbeForRead(pdncb->ncb_buffer, sizeof(NCB), 4);
                    }


                    //
                    // Get the Lana number for the NCB being cancelled
                    // This is to prevent dereferencing the user buffer
                    // once the spinlock has been taken (bug #340218)
                    //

                    ucLana = ((PNCB)(pdncb->ncb_buffer))->ncb_lana_num;

                    LOCK_SPINLOCK(pfcb, OldIrql);
                    SpinLockHeld = TRUE;

                    //
                    //  Search for the correct ppcb. We cannot use FindCb
                    //  because the I/O system will not copy back the ncb_lsn
                    //  field into target until the I/O request completes.
                    //

                    //
                    // Note : Though we are passing in the user buffer to
                    // the following routine, the buffer is never dereferenced
                    // in the routine.  It is passed in only for address comp.
                    // and should not result in a pagefault ever, (with the
                    // spinlock held)
                    //

                    ppcb = FindCallCb( pfcb, (PNCB)pdncb->ncb_buffer, ucLana);

                    if (( ppcb == NULL ) ||
                        ((*ppcb)->pdncbCall->ncb_cmd_cplt != NRC_PENDING ) ||
                        (( (*ppcb)->Status != CALL_PENDING ) &&
                         ( (*ppcb)->Status != LISTEN_OUTSTANDING ))) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                    } else {
                        NCB_COMPLETE( (*ppcb)->pdncbCall, NRC_CMDCAN );
                        SpinLockHeld = FALSE;
                        (*ppcb)->DisconnectReported = TRUE;
                        UNLOCK_SPINLOCK( pfcb, OldIrql );
                        CleanupCb( ppcb, NULL );
                        NCB_COMPLETE( pdncb, NRC_GOODRET );
                    }
                }
                break;

            case NCBHANGUP:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                        PPCB ppcb = FindCb( pfcb, target, FALSE );
                        if (( ppcb != NULL ) &&
                            ((*ppcb)->Status == HANGUP_PENDING )) {
                            PDNCB pdncbHangup;
                            //  Restore the session status and remove the hangup.
                            (*ppcb)->Status = SESSION_ESTABLISHED;
                            pdncbHangup = (*ppcb)->pdncbHangup;
                            (*ppcb)->pdncbHangup = NULL;
                            if ( pdncbHangup != NULL ) {
                                NCB_COMPLETE( pdncbHangup, NRC_CMDCAN );
                                pdncbHangup->irp->IoStatus.Information =
                                    FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                                NbCompleteRequest( pdncbHangup->irp ,STATUS_SUCCESS);
                            }
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                        } else {
                            //  Doesn't look like this is a real hangup so refuse.
                            NCB_COMPLETE( pdncb, NRC_CANCEL );
                        }
                }
                break;

            case NCBASTAT:
                NCB_COMPLETE( pdncb, NRC_CANOCCR );
                break;

            case NCBLANSTALERT:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    CancelLanAlert( pfcb, pdncb );
                }
                break;

            case NCBRECVANY:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, target->ncb_num );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveAnyList.Flink ;
                         Entry != &(*ppab)->ReceiveAnyList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            case NCBDGRECV:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, target->ncb_num );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveDatagramList.Flink ;
                         Entry != &(*ppab)->ReceiveDatagramList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            case NCBDGRECVBC:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, MAXIMUM_ADDRESS );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveBroadcastDatagramList.Flink ;
                         Entry != &(*ppab)->ReceiveBroadcastDatagramList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            //  Session cancels close the connection.

            case NCBRECV:
            case NCBSEND:
            case NCBSENDNA:
            case NCBCHAINSEND:
            case NCBCHAINSENDNA:

                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPCB ppcb;
                    ppcb = FindCb( pfcb, target, FALSE);
                    if ( ppcb == NULL ) {
                        //  No such connection
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                    } else {
                        PDNCB pTarget = NULL;
                        PLIST_ENTRY Entry;
                        if ((target->ncb_command & ~ASYNCH) == NCBRECV ) {
                            for (Entry = (*ppcb)->ReceiveList.Flink ;
                                 Entry != &(*ppcb)->ReceiveList;
                                 Entry = Entry->Flink) {

                                pTarget = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                                if ( pTarget->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                                    break;
                                }
                                pTarget = NULL;

                            }
                        } else {
                            for (Entry = (*ppcb)->SendList.Flink ;
                                 Entry != &(*ppcb)->SendList;
                                 Entry = Entry->Flink) {

                                pTarget = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                                if ( pTarget->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                                    break;
                                }
                                pTarget = NULL;
                            }
                        }

                        if ( pTarget != NULL ) {
                            //  pTarget points to the real Netbios drivers DNCB.
                            NCB_COMPLETE( pTarget, NRC_CMDCAN );
                            SpinLockHeld = FALSE;
                            (*ppcb)->DisconnectReported = TRUE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );
                            CleanupCb( ppcb, NULL );
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                        } else {
                            NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        }
                    }
                }
                break;

            default:
                NCB_COMPLETE( pdncb, NRC_CANCEL );  // Invalid command to cancel
                break;

            }
        } else {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        if ( SpinLockHeld == TRUE ) {
            UNLOCK( pfcb, OldIrql );
        } else {
            UNLOCK_RESOURCE( pfcb );
        }

        IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
            NTSTATUS Status = GetExceptionCode();
            NbPrint( ("NbCancel: Exception1 %X.\n", Status));
        }

        NCB_COMPLETE( pdncb, NRC_INVADDRESS );
        return STATUS_SUCCESS;
    }

    if ( SpinLockHeld == TRUE ) {
        UNLOCK( pfcb, OldIrql );
    } else {
        UNLOCK_RESOURCE( pfcb );
    }

    NCB_COMPLETE( pdncb, NRC_GOODRET );

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER( Irp );
}

VOID
QueueRequest(
    IN PLIST_ENTRY List,
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PFCB pfcb,
    IN KIRQL OldIrql,
    IN BOOLEAN Head)
/*++

Routine Description:

    This routine is called to add a dncb to List.

    Note: QueueRequest UNLOCKS the fcb. This means the resource and
    spinlock are owned when this routine is called.

Arguments:

    List - List of pdncb's.

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    pfcb & OldIrql - Used to free locks

    Head - TRUE if pdncb should be inserted at head of list

Return Value:

    None.

--*/

{

    pdncb->irp = Irp;

    pdncb->pfcb = pfcb;

    IoMarkIrpPending( Irp );

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    if ( Head == FALSE ) {
        InsertTailList(List, &pdncb->ncb_next);
    } else {
        InsertHeadList(List, &pdncb->ncb_next);
    }

    if (Irp->Cancel) {

        //
        //  CancelRoutine will lock the resource & spinlock and try to find the
        //  request from scratch. It may fail to find the request if it has
        //  been picked up by an indication from the transport.
        //

        UNLOCK( pfcb, OldIrql );

        CancelRoutine (NULL, Irp);

    } else {

        IoSetCancelRoutine(Irp, CancelRoutine);

        IoReleaseCancelSpinLock (Irp->CancelIrql);

        UNLOCK( pfcb, OldIrql );
    }

}

PDNCB
DequeueRequest(
    IN PLIST_ENTRY List
    )
/*++

Routine Description:

    This routine is called to remove a dncb from List.

    Assume fcb spinlock held.

Arguments:

    List - List of pdncb's.

Return Value:

    PDNCB or NULL.

--*/
{
    PIRP Irp;
    PDNCB pdncb;
    PLIST_ENTRY ReceiveEntry;

    if (IsListEmpty(List)) {
        //
        //  There are no waiting request announcement FsControls, so
        //  return success.
        //

        return NULL;
    }

    ReceiveEntry = RemoveHeadList( List);

    pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

    Irp = pdncb->irp;

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    //
    //  Remove the cancel request for this IRP. If its cancelled then its
    //  ok to just process it because we will be returning it to the caller.
    //

    Irp->Cancel = FALSE;

    IoSetCancelRoutine(Irp, NULL);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    return pdncb;

}

VOID
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the IO system wants to cancel a queued
    request. The netbios driver queues LanAlerts, Receives and Receive
    Datagrams

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Ignored.
    IN PIRP Irp - Irp to cancel.

Return Value:

    None

--*/

{
    PFCB pfcb;
    PDNCB pdncb;
    DNCB LocalCopy;
    PLIST_ENTRY List = NULL;
    PPAB ppab;
    PPCB ppcb;
    PFILE_OBJECT FileObject;
    KIRQL OldIrql;

    //
    //  Clear the cancel routine from the IRP - It can't be cancelled anymore.
    //

    IoSetCancelRoutine(Irp, NULL);

    //
    //  Remove all the info from the pdncb that we will need to find the
    //  request. Once we release the cancel spinlock this request could be
    //  completed by another action so it is possible that we will not find
    //  the request to cancel.
    //

    pdncb = Irp->AssociatedIrp.SystemBuffer;

    RtlMoveMemory( &LocalCopy, pdncb, sizeof( DNCB ) );
    IF_NBDBG (NB_DEBUG_IOCANCEL) {
        NbPrint(( "IoCancel Irp %lx\n", Irp ));
        NbDisplayNcb(&LocalCopy);
    }

#if DBG
#ifdef _WIN64
    pdncb = (PDNCB)0xDEADBEEFDEADBEEF;
#else
    pdncb = (PDNCB)0xDEADBEEF;
#endif
#endif

    pfcb = LocalCopy.pfcb;

    //
    //  Reference the FileObject associated with this Irp. This will stop
    //  the callers handle to \device\netbios from closing and therefore
    //  the fcb will not get deleted while we try to lock the fcb.
    //
    FileObject = (IoGetCurrentIrpStackLocation (Irp))->FileObject;
    ObReferenceObject(FileObject);
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    LOCK( pfcb, OldIrql );
    //
    //  We now have exclusive access to all CB's and AB's with their associated
    //  lists.
    //

    switch ( LocalCopy.ncb_command & ~ASYNCH ) {
    case NCBRECV:

        ppcb = FindCb( pfcb, &LocalCopy, TRUE);
        if ( ppcb != NULL ) {
            List = &(*ppcb)->ReceiveList;
        }
        break;

    case NCBRECVANY:
        ppab = FindAbUsingNum( pfcb, &LocalCopy, LocalCopy.ncb_num );
        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveAnyList;
        }
        break;

    case NCBDGRECVBC:
        ppab = FindAbUsingNum( pfcb, &LocalCopy, MAXIMUM_ADDRESS  );

        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveBroadcastDatagramList;
        }
        break;

    case NCBDGRECV:

        ppab = FindAbUsingNum( pfcb, &LocalCopy, LocalCopy.ncb_num );

        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveDatagramList;
        }
        break;

    case NCBLANSTALERT:
        List = &(pfcb->ppLana[LocalCopy.ncb_lana_num]->LanAlertList);
        break;

    }


    if ( List != NULL ) {

        //
        //  We have a list to scan for canceled pdncb's
        //

        PLIST_ENTRY Entry;

RestartScan:

        for (Entry = List->Flink ;
             Entry != List ;
             Entry = Entry->Flink) {

            PDNCB p = CONTAINING_RECORD( Entry, DNCB, ncb_next);

            IoAcquireCancelSpinLock( &p->irp->CancelIrql );

            if ( p->irp->Cancel ) {

                RemoveEntryList( &p->ncb_next );

                NCB_COMPLETE( p, NRC_CMDCAN );

                p->irp->IoStatus.Status = STATUS_SUCCESS;
                p->irp->IoStatus.Information =
                    FIELD_OFFSET( DNCB, ncb_cmd_cplt );

                IoSetCancelRoutine( p->irp, NULL );

                IoReleaseCancelSpinLock( p->irp->CancelIrql );

                IoCompleteRequest( p->irp, IO_NETWORK_INCREMENT);
                goto RestartScan;
            }

            IoReleaseCancelSpinLock( p->irp->CancelIrql );
        }
    }

    UNLOCK( pfcb, OldIrql );
    ObDereferenceObject(FileObject);
}


NTSTATUS
AllocateAndCopyUnicodeString(
    IN  OUT PUNICODE_STRING     pusDest,
    IN      PUNICODE_STRING     pusSource
)

/*++

Routine Description :
    This function allocates and copies a unicode string.


Arguements :
    pusDest : Destination that the unicode string is to be copied

    pusSource : Source string that is to be copied


Return Value :
    STATUS_SUCCESS if function is successful.

    STATUS_NO_MEMORY if function fails to allocate buffer for the dest.

Environment :

--*/

{

    PAGED_CODE();


    pusDest-> Buffer = ExAllocatePoolWithTag(
                        NonPagedPool, pusSource-> MaximumLength, 'nSBN'
                        );

    if ( pusDest-> Buffer == NULL )
    {
        return STATUS_NO_MEMORY;
    }

    pusDest-> MaximumLength = pusSource-> MaximumLength;

    RtlCopyUnicodeString( pusDest, pusSource );

    return STATUS_SUCCESS;
}



NTSTATUS
NbRegisterWait(
    IN      PIRP                pIrp
)
/*++

Routine Description :
    This function marks the specified IRP as pending and inserts it into
    the global list of IRP that are waiting for stop notification.  These
    IRPs will be completed when netbios is being stopped.
    N.B : NbStop


Arguements :
    pIrp :  IRP that needs to be pending until netbios is being stopped


Return value :


Environment :
    This function is invoked in response to a IOCTL_NB_REGISTER sent down
    by a user mode component.  Acquires/releases the CancelSpinLock and
    g_keStopLock.

--*/
{

    KIRQL   irql;

    NTSTATUS status;


    LOCK_STOP();

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: ENTERED NbRegisterWait, Stop status %d, "
                  "Num Opens %d\n", g_dwNetbiosState, g_ulNumOpens ) );
    }


    if ( g_dwNetbiosState == NETBIOS_STOPPING )
    {
        //
        // Netbios is shutting down, complete this IRP, right away
        //

        status = STATUS_SUCCESS;
    }

    else
    {
        //
        // setup the cancellation routine and pend this IRP
        //

        IoAcquireCancelSpinLock( &irql );

        IoMarkIrpPending( pIrp );

        InsertTailList( &g_leWaitList, &(pIrp->Tail.Overlay.ListEntry) );

        IoSetCancelRoutine( pIrp, CancelIrp );

        IoReleaseCancelSpinLock( irql );

        status = STATUS_PENDING;
    }

    UNLOCK_STOP();

    return status;
}


VOID
CancelIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)

/*++

Routine Description :
    This function cancels an IRP that has been pended on behalf of a
    user mode process.  This is invoked when the user-mode process
    the had an open FileHandle to this device closes the handle.

Arguments :
    DeviceObject : DeviceObject correponding to the Filehandle that was closed

    Irp : Pended Irp that is being cancelled.

Return Value :


Environment :
    Invoked by the IO subsystem when an open Filehandle to \\Device\netbios is
    closed.  This is invoked while holding the CancelSpinLock.

--*/
{
    //
    // Mark this Irp as cancelled
    //

    Irp->IoStatus.Status        = STATUS_CANCELLED;
    Irp->IoStatus.Information   = 0;

    //
    // Take off our own list
    //

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // Release cancel spin lock which the IO system acquired
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
}



NTSTATUS
NbStop(
)

/*++

Routine Description :

    This function initiates the process of stopping the netbios driver.
    It does this by completing the pending stop-notification IRPs.  The
    user mode components (netapi32.dll) which have open file handles are
    expected to close these handles when the pending IRPs have been
    completed.  After completing the IRPs this function waits for
    all the open handles to be closed.

Arguments :

Return Value :
    STATUS_SUCCESS if all the handles were closed, STATUS_TIMEOUT if
    the wait timed out.

Environment :

    This function is invoked from Services.exe when the netbios driver
    is to be stopped.  This is special case behavior for netbios.
    This function acquires (and releases) the global lock g_erStopLock
    and the CancelSpinLock

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIRP pIrp;

    BOOLEAN bWait = FALSE ;

    DWORD dwTimeOut = 10000 * 1000 * 15;

    LARGE_INTEGER TimeOut;

    KIRQL irql;

    PLIST_ENTRY  pleNode;

#if AUTO_RESET

    PLIST_ENTRY ple;

    PFCB_ENTRY  pfe;

    PNCB        pUsersNCB;
#endif

    //
    // Acquire the lock protecting stop related data.
    //

    LOCK_STOP();

    //
    // Decrement Num Opens, since an extra open has been performed to
    // send the stop IOCTL
    //

    g_ulNumOpens--;


    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: ENTERED NbStop, Stop status %d, "
                  "Num Opens %d\n", g_dwNetbiosState, g_ulNumOpens ) );
    }

    //
    // set netbios state to stopping
    //

    g_dwNetbiosState = NETBIOS_STOPPING;

    if ( g_ulNumOpens )
    {
        //
        // if there are open file handles to \\Device\Netbios,
        // wait for them to close
        //

        bWait = TRUE;
    }


#if AUTO_RESET

    LOCK_GLOBAL();

#endif

    //
    // Complete each of the pending IRPs to signal the stop event.
    // This causes netapi32.dll to close the open handles
    //

    IoAcquireCancelSpinLock( &irql );

    while ( !IsListEmpty( &g_leWaitList ) )
    {
        pleNode = RemoveHeadList( &g_leWaitList );

        pIrp = CONTAINING_RECORD( pleNode, IRP, Tail.Overlay.ListEntry );

        IoSetCancelRoutine( pIrp, NULL );

        pIrp->IoStatus.Status       = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Information  = 0;


        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock( irql );

        IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );


        //
        // Reaquire the lock
        //

        IoAcquireCancelSpinLock(&irql);
    }

#if AUTO_RESET

    //
    // Complete IRPs that have been pended for notfication
    // of a new LANA (in case the LANA needs to be automatically
    // reset)
    //

    for ( pleNode = g_leFCBList.Flink;
          pleNode != &g_leFCBList;
          pleNode = pleNode-> Flink )
    {
        pfe = CONTAINING_RECORD( pleNode, FCB_ENTRY, leList );

        if ( !IsListEmpty( &pfe-> leResetIrp ) )
        {
            ple = RemoveHeadList( &pfe-> leResetIrp );

            pIrp = CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );

            IoSetCancelRoutine( pIrp, NULL );

            pIrp->IoStatus.Status       = STATUS_SUCCESS;

            pIrp->IoStatus.Information  = sizeof( NCB );


            //
            // Set the LANA to be reset to special value since NETBIOS
            // is stopping
            //

            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB->ncb_lana_num = MAX_LANA + 1;


            NbCheckAndCompleteIrp32(pIrp);
            //
            // release lock to complete the IRP
            //

            IoReleaseCancelSpinLock( irql );

            IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );


            //
            // Reaquire the lock
            //

            IoAcquireCancelSpinLock(&irql);
        }
    }

#endif

    IoReleaseCancelSpinLock( irql );


#if AUTO_RESET

    UNLOCK_GLOBAL();

#endif

    //
    // release stop lock
    //

    UNLOCK_STOP();


    //
    // if there are open file handles wait for them to stop
    //

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: NbStop : Wait %d\n", bWait ) );
    }


    if ( bWait )
    {
        TimeOut.QuadPart = Int32x32To64( -1, dwTimeOut );

        do
        {
            ntStatus = KeWaitForSingleObject(
                            &g_keAllHandlesClosed, Executive, KernelMode,
                            TRUE, &TimeOut
                        );

        } while (ntStatus == STATUS_ALERTED);
    }

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        LOCK_STOP();

        NbPrint( ("[NETBIOS]: LEAVING NbStop, Stop status %d, "
                  "Num Opens %d\n", ntStatus, g_ulNumOpens ) );

        UNLOCK_STOP();
    }

    return ntStatus;
}



#if AUTO_RESET

NTSTATUS
NbRegisterReset(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp

)
/*++

Routine Description :
    This function marks the specified IRP as pending and inserts it into
    the global FCB list.  This IRP will be completed when an adapter is bound
    to netbios, thereby notifying the user mode of a new adapter.

Arguements :
    pIrp :  IRP that needs to be pending until an adapater (LANA) is bound
            to netbios


Return value :


Environment :
    This function is invoked in response to a IOCTL_NB_REGISTER_RESET sent down
    by a user mode component.  Acquires/releases the CancelSpinLock and
    g_erGlobalLost.

--*/
{

    NTSTATUS            Status;

    PFCB                pfcb;

    PLIST_ENTRY         ple;

    PFCB_ENTRY          pfe;

    PRESET_LANA_ENTRY   prle;

    PNCB                pUsersNCB;

    KIRQL               irql;

    ULONG               RequiredLength;



    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( ("\n++++ Netbios : ENTERED NbRegisterReset : ++++\n") );
    }


    LOCK_STOP();

    do
    {
        //
        // Check if Netbios is stopping
        //

        if ( g_dwNetbiosState == NETBIOS_STOPPING )
        {
            NbPrint( ("[NETBIOS] : NbRegisterReset : Netbios is stopping\n") );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // Acquire the global lock
        //

        LOCK_GLOBAL();


        //
        // find the FCB for the user-mode application that sent down
        // the IOCTL
        //

        pfcb = pIrpSp-> FileObject-> FsContext2;

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            if ( pfe-> pfcb == pfcb )
            {
                break;
            }
        }


        //
        // if the FCB is not found, print error and quit
        //

        if ( ple == &g_leFCBList )
        {
            UNLOCK_GLOBAL();

            NbPrint(
                ("[NETBIOS] : NbRegisterReset : FCB %p not found\n", pfcb )
                );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // Fix for bug 297936, buffer validation
        //
        RequiredLength = sizeof(NCB);
#if defined(_WIN64)
        if (IoIs32bitProcess(pIrp) == TRUE)
        {
            RequiredLength = sizeof(NCB32);
        }
#endif
        if (pIrpSp-> Parameters.DeviceIoControl.OutputBufferLength < RequiredLength)
        {
            UNLOCK_GLOBAL();

            NbPrint(
                ("[NETBIOS] : NbRegisterReset : Output buffer too small\n")
                );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // If there are outstanding LANA that are queued,
        // -    Remove the first one from the queue
        // -    Set the LANA in the output buffer for the IRP
        // -    complete the IRP
        //

        if ( !IsListEmpty( &pfe-> leResetList ) )
        {
            ple = RemoveHeadList( &pfe-> leResetList );

            prle = CONTAINING_RECORD( ple, RESET_LANA_ENTRY, leList );

            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB-> ncb_lana_num = prle-> ucLanaNum;
            pIrp->IoStatus.Information  = sizeof( NCB );

            ExFreePool( prle );

            Status = STATUS_SUCCESS;

            pIrp->IoStatus.Status = STATUS_SUCCESS;

            UNLOCK_GLOBAL();

            IF_NBDBG( NB_DEBUG_CREATE_FILE )
            {
                NbPrint( (
                    "FCB %p : Reset for LANA %d\n", pfcb,
                    pUsersNCB->ncb_lana_num
                    ) );
            }

            break;
        }


        //
        // No outstanding LANAs that need reseting
        // -    Acquire the Cancel spin lock
        // -    Set the Cancel Routine
        //

        IoAcquireCancelSpinLock( &irql );

        IoMarkIrpPending( pIrp );

        InsertTailList( &pfe-> leResetIrp, &(pIrp->Tail.Overlay.ListEntry) );

        IoSetCancelRoutine( pIrp, CancelIrp );

        IoReleaseCancelSpinLock( irql );

        Status = STATUS_PENDING;

        UNLOCK_GLOBAL();


    } while ( FALSE );


    UNLOCK_STOP();


    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( ("\n++++ Netbios : Exiting NbRegisterReset : %lx ++++\n", Status ) );
    }

    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\connect.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    connection block.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include <zwapi.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbCall)
#pragma alloc_text(PAGE, NbListen)
#pragma alloc_text(PAGE, NbCallCommon)
#pragma alloc_text(PAGE, NbOpenConnection)
#pragma alloc_text(PAGE, NewCb)
#pragma alloc_text(PAGE, CloseConnection)
#endif

LARGE_INTEGER Timeout = { 0xffffffff, 0xffffffff};

NTSTATUS
NbCall(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to make a VC.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbCall ****** pdncb %lx\n", pdncb ));
    }

    LOCK_RESOURCE( pfcb );

    ppcb = NbCallCommon( pdncb, IrpSp );

    if ( ppcb == NULL ) {
        //
        //  The error has been stored in the copy of the NCB. Return
        //  success so the NCB gets copied back.
        //
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;

    pcb->Status = CALL_PENDING;
    if (( pdncb->ncb_command & ~ASYNCH ) == NCBCALL ) {
        PTA_NETBIOS_ADDRESS pConnectBlock =
            ExAllocatePoolWithTag ( NonPagedPool, sizeof(TA_NETBIOS_ADDRESS), 'ySBN');
        PTDI_ADDRESS_NETBIOS temp;

        if ( pConnectBlock == NULL ) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        pConnectBlock->TAAddressCount = 1;
        pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
        pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
        temp = pConnectBlock->Address[0].Address;

        temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
        RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

        //
        //  Post a TdiConnect to the server. This may take a long time so return
        //  STATUS_PENDING so that the application thread gets free again if
        //  it specified ASYNC.
        //

        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);
        pdncb->Information.RemoteAddress = pConnectBlock;
    } else {
        //  XNS NETONE name call
        PTA_NETONE_ADDRESS pConnectBlock =
            ExAllocatePoolWithTag ( NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                          sizeof (TDI_ADDRESS_NETONE), 'xSBN' );

        PTDI_ADDRESS_NETONE temp;

        if ( pConnectBlock == NULL ) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        pConnectBlock->TAAddressCount = 1;
        pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETONE;
        pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETONE);
        temp = pConnectBlock->Address[0].Address;

        temp->NetoneNameType = TDI_ADDRESS_NETONE_TYPE_UNIQUE;
        RtlMoveMemory( &temp->NetoneName[0], pdncb->ncb_callname, NCBNAMSZ );

        //
        //  Post a TdiConnect to the server. This may take a long time so return
        //  STATUS_PENDING so that the application thread gets free again if
        //  it specified ASYNC.
        //

        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETONE);
        pdncb->Information.RemoteAddress = pConnectBlock;
    }

    pdncb->ReturnInformation.RemoteAddress = NULL;
    pdncb->ReturnInformation.RemoteAddressLength = 0;

    pdncb->Information.UserDataLength = 0;
    pdncb->Information.OptionsLength = 0;

    TdiBuildConnect (Irp,
                     pcb->DeviceObject,
                     pcb->ConnectionObject,
                     NbCallCompletion,
                     pdncb,
                     &Timeout, // default timeout
                     &pdncb->Information,
                     NULL);

    IoMarkIrpPending( Irp );
    IoCallDriver (pcb->DeviceObject, Irp);

    //
    // The transport has extracted all information from RequestInformation so we can safely
    // exit the current scope.
    //

    UNLOCK_RESOURCE( pfcb );

    return STATUS_PENDING;

}

NTSTATUS
NbCallCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp after an attempt to perform a TdiConnect
    or TdiListen/TdiAccept has been returned by the transport.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    PFCB pfcb = IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext2;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbCallCompletion pdncb: %lx\n" , Context));
    }

    if ( pdncb->Information.RemoteAddress != NULL ) {
        ExFreePool( pdncb->Information.RemoteAddress );
        pdncb->Information.RemoteAddress = NULL;
    }

    if ( pdncb->ReturnInformation.RemoteAddress != NULL ) {
        ExFreePool( pdncb->ReturnInformation.RemoteAddress );
        pdncb->ReturnInformation.RemoteAddress = NULL;
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
    Status = Irp->IoStatus.Status;

    LOCK_SPINLOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE);

    if (( ppcb == NULL ) ||
        ( (*ppcb)->Status == HANGUP_PENDING )) {

        //
        //  The connection has been closed.
        //  Repair the Irp so that the NCB gets copied back.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_SUCCESS;

    } else {
        if ( NT_SUCCESS( Status ) ) {
            (*ppcb)->Status = SESSION_ESTABLISHED;
            NCB_COMPLETE( pdncb, NRC_GOODRET );

        } else {

            //
            //  We need to close down the connection but we are at DPC level
            //  so tell the dll to insert a hangup.
            //

            NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );
            (*ppcb)->Status = SESSION_ABORTED;

            //  repair the Irp so that the NCB gets copied back.
            Irp->IoStatus.Status = STATUS_HANGUP_REQUIRED;
            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            Status = STATUS_HANGUP_REQUIRED;
        }
    }
    if ( ppcb != NULL ) {
        (*ppcb)->UsersNcb = NULL;
    }
    UNLOCK_SPINLOCK( pfcb, OldIrql );

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbCallCompletion exit pdncb: %lx, Status %X\n", pdncb, Status ));
    }


    NbCheckAndCompleteIrp32(Irp);

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
NbListen(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to make a VC by waiting for a call.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    PTA_NETBIOS_ADDRESS pConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbListen ****** pdncb %lx\n", pdncb ));
    }

    LOCK_RESOURCE( pfcb );

    ppcb = NbCallCommon( pdncb, IrpSp );

    if ( ppcb == NULL ) {
        //
        //  The error has been stored in the copy of the NCB. Return
        //  success so the NCB gets copied back.
        //
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;

    pcb->Status = LISTEN_OUTSTANDING;

    //
    //  Build the listen. We either need to tell the transport which
    //  address we are prepared to accept a call from or we need to
    //  supply a buffer for the transport to tell us where the
    //  call came from.
    //

    pConnectBlock = ExAllocatePoolWithTag ( NonPagedPool, sizeof(TA_NETBIOS_ADDRESS), 'zSBN');

    if ( pConnectBlock == NULL ) {
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pConnectBlock->TAAddressCount = 1;
    pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    temp = pConnectBlock->Address[0].Address;
    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);

    if ( pdncb->ncb_callname[0] == '*' ) {
        //  If the name starts with an asterisk then we accept anyone.
        pdncb->ReturnInformation.RemoteAddress = pConnectBlock;
        pdncb->ReturnInformation.RemoteAddressLength =
            sizeof (TRANSPORT_ADDRESS) + sizeof (TDI_ADDRESS_NETBIOS);

        pdncb->Information.RemoteAddress = NULL;
        pdncb->Information.RemoteAddressLength = 0;

    } else {

        RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

        pdncb->Information.RemoteAddress = pConnectBlock;
        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);

        pdncb->ReturnInformation.RemoteAddress = NULL;
        pdncb->ReturnInformation.RemoteAddressLength = 0;
    }


    //
    //  Post a TdiListen to the server. This may take a long time so return
    //  STATUS_PENDING so that the application thread gets free again if
    //  it specified ASYNC.
    //

    TdiBuildListen (Irp,
                     pcb->DeviceObject,
                     pcb->ConnectionObject,
                     NbListenCompletion,
                     pdncb,
                     TDI_QUERY_ACCEPT,
                     &pdncb->Information,
                     ( pdncb->ncb_callname[0] == '*' )? &pdncb->ReturnInformation
                                                      : NULL
                     );

    IoMarkIrpPending( Irp );
    IoCallDriver (pcb->DeviceObject, Irp);

    UNLOCK_RESOURCE( pfcb );

    return STATUS_PENDING;

}

NTSTATUS
NbListenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when a TdiListen has been returned by the transport.
    We can either reject or accept the call depending on the remote address.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    PFCB pfcb = IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbListenCompletion pdncb: %lx status: %X\n" , Context, Irp->IoStatus.Status));
    }


    //
    // bug # : 73260
    //
    // Added check to see if Status is valid
    //
    
    if ( NT_SUCCESS( Irp-> IoStatus.Status ) )
    {
        if ( pdncb->Information.RemoteAddress != NULL ) {

            ExFreePool( pdncb->Information.RemoteAddress );
            pdncb->Information.RemoteAddress = NULL;

        } else {

            //
            //  This was a listen accepting a call from any address. Return
            //  the remote address.
            //
            PTA_NETBIOS_ADDRESS pConnectBlock;

            ASSERT( pdncb->ReturnInformation.RemoteAddress != NULL );

            pConnectBlock = pdncb->ReturnInformation.RemoteAddress;

            RtlMoveMemory(
                pdncb->ncb_callname,
                pConnectBlock->Address[0].Address->NetbiosName,
                NCBNAMSZ );

            ExFreePool( pdncb->ReturnInformation.RemoteAddress );
            pdncb->ReturnInformation.RemoteAddress = NULL;
        }
    } else {
        if ( pdncb->Information.RemoteAddress != NULL ) {
            ExFreePool( pdncb->Information.RemoteAddress );
            pdncb->Information.RemoteAddress = NULL;
        } else {
            ExFreePool( pdncb->ReturnInformation.RemoteAddress );
            pdncb->ReturnInformation.RemoteAddress = NULL;
        }
    }

    
    LOCK_SPINLOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE );

    if (( ppcb == NULL ) ||
        ( (*ppcb)->Status == HANGUP_PENDING )) {

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        //
        //  The connection has been closed.
        //  Repair the Irp so that the NCB gets copied back.
        //

        NCB_COMPLETE( pdncb, NRC_NAMERR );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_SUCCESS;

    } 

    //
    // bug # : 70837
    //
    // Added check for cancelled listens
    //
    
    else if ( ( (*ppcb)-> Status == SESSION_ABORTED ) ||
              ( !NT_SUCCESS( Irp-> IoStatus.Status ) ) )
    {
        UNLOCK_SPINLOCK( pfcb, OldIrql );

        if ( (*ppcb)-> Status == SESSION_ABORTED ) 
        {
            NCB_COMPLETE( pdncb, NRC_CMDCAN );
        }
        else
        {
            (*ppcb)-> Status = SESSION_ABORTED;
            NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );
        }

        //
        //  repair the Irp so that the NCB gets copied back.
        //  Tell the dll to hangup the connection.
        //

        Irp->IoStatus.Status = STATUS_HANGUP_REQUIRED;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_HANGUP_REQUIRED;
    }

    else
    {
        PDEVICE_OBJECT DeviceObject;

        
        pcb = *ppcb;

        DeviceObject = pcb-> DeviceObject;
        

        //  Tell application how many bytes were transferred
        pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

        RtlMoveMemory(
            &pcb->RemoteName,
            pdncb->ncb_callname,
            NCBNAMSZ );

        //
        //  Tell IopCompleteRequest how much to copy back when the request
        //  completes.
        //

        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        TdiBuildAccept (Irp,
                         pcb->DeviceObject,
                         pcb->ConnectionObject,
                         NbCallCompletion,
                         pdncb,
                         NULL,
                         NULL);
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        IoCallDriver (DeviceObject, Irp);

        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }


    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbListenCompletion exit pdncb: %lx, Status: %X\n" , pdncb, Status));
    }

    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
        NbCheckAndCompleteIrp32(Irp);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    return Status;
    UNREFERENCED_PARAMETER( DeviceObject );
}

PPCB
NbCallCommon(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine contains the common components used in creating a
    connection either by a TdiListen or TdiCall.

Arguments:

    pdncb - Pointer to the NCB.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the address of the pointer in the ConnectionBlocks to
    the connection block for this call.


--*/

{
    PPCB ppcb = NULL;
    PCB pcb = NULL;
    PAB pab;
    PPAB ppab;
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PIRP IIrp;
    KEVENT Event1;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb1;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    //
    //  Initialize the lsn so that if we return an error and the application
    //  ignores it then we will not reuse a valid lsn.
    //
    pdncb->ncb_lsn = 0;

    ppcb = NewCb( IrpSp, pdncb );

    if ( ppcb == NULL ) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  FAILED on create Cb of %s\n", pdncb->ncb_name));
        }

        return NULL;    //  NewCb will have filled in the error code.
    }

    pcb = *ppcb;
    ppab = pcb->ppab;
    pab = *ppab;

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    //
    // Open the connection on the transport.
    //

    Status = NbOpenConnection (&pcb->ConnectionHandle, (PVOID*)&pcb->ConnectionObject, pfcb, ppcb, pdncb);
    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  FAILED on open of server Connection: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        return NULL;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "NbCallCommon: Associate address\n"));
    }

    pcb->DeviceObject = IoGetRelatedDeviceObject( pcb->ConnectionObject );

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }

    IIrp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                pcb->DeviceObject,
                pcb->ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildAssociateAddress (
                IIrp,
                pcb->DeviceObject,
                pcb->ConnectionObject,
                NULL,
                NULL,
                pab->AddressHandle);

    Status = IoCallDriver (pcb->DeviceObject, IIrp);

    if (Status == STATUS_PENDING) {

        //
        // Wait for event to be signalled while ignoring alerts
        //
        
        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);
        
        if (!NT_SUCCESS(Status)) {
            IF_NBDBG (NB_DEBUG_CALL) {
                NbPrint(( "\n  FAILED Event1 Wait: %X ******\n", Status ));
            }
            NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
            if (ProcessAttached) {
                KeUnstackDetachProcess(&ApcState);
            }
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            return NULL;
        }
        Status = Iosb1.Status;
    }

    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  AssociateAddress FAILED  Status: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        return NULL;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "NbCallCommon: returning ppcb: %lx\n", ppcb ));
    }
    return ppcb;
}

NTSTATUS
NbHangup(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to hangup a VC. This cancels all receives
    and waits for all pending sends to complete before returning. This
    functionality is offered directly by the underlying TDI driver so
    NetBIOS just passes the Irp down to the transport.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Supplies Io request packet describing the Hangup NCB.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPCB ppcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    NTSTATUS Status;

    LOCK( pfcb, OldIrql );

    pdncb->pfcb = pfcb;
    pdncb->irp = Irp;
    ppcb = FindCb( pfcb, pdncb, FALSE );

    if ( ppcb == NULL ) {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;  //  Connection gone already
    }

    if ((*ppcb)->Status == SESSION_ESTABLISHED ) {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    } else {
        if (((*ppcb)->Status == SESSION_ABORTED ) ||
            ((*ppcb)->Status == HANGUP_PENDING )) {
            NCB_COMPLETE( pdncb, NRC_SCLOSED );
        } else {
            NCB_COMPLETE( pdncb, NRC_TOOMANY ); // try later
            UNLOCK( pfcb, OldIrql );;
            return STATUS_SUCCESS;
        }
    }

    (*ppcb)->Status = HANGUP_PENDING;
    (*ppcb)->DisconnectReported = TRUE;

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    Status = CleanupCb( ppcb, pdncb );

    UNLOCK_RESOURCE( pfcb );

    return Status;
}

NTSTATUS
NbOpenConnection (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PFCB pfcb,
    IN PVOID ConnectionContext,
    IN PDNCB pdncb
    )
/*++

Routine Description:

    Makes a call to a remote address.
Arguments:

    FileHandle - Pointer to where the handle to the Transport for this virtual
        connection should be stored.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - Supplies the fcb and therefore the DriverName for this lana.

    ConnectionContext -  Supplies the Cb to be used with this connection on
        all indications from the transport. Its actually the address of
        the pcb in the ConnectionBlocks array for this lana.

    pdncb - Supplies the ncb requesting the new virtual connection.

Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    InitializeObjectAttributes (
        &ObjectAttributes,
        &pfcb->pDriverName[pdncb->ncb_lana_num],
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePoolWithTag (NonPagedPool,
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT), 'eSBN' );
    if (EaBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

    RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

    RtlMoveMemory (
        &EaBuffer->EaName[EaBuffer->EaNameLength + 1],
        &ConnectionContext,
        sizeof (CONNECTION_CONTEXT));

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }


    IF_NBDBG( NB_DEBUG_CALL )
    {
        NbPrint( (
            "NbOpenConnection: Create file invoked on %d for \n", 
            pdncb-> ncb_lana_num
            ) );

        NbFormattedDump( pdncb-> ncb_callname, NCBNAMSZ );
    }
    
    Status = ZwCreateFile (
                 FileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // block size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 0,
                 FILE_CREATE,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT) ); // EA length.

    ExFreePool( EaBuffer );

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS( Status )) {
        Status = ObReferenceObjectByHandle (
                    *FileHandle,
                    0L,
                    NULL,
                    KernelMode,
                    Object,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            NTSTATUS localstatus;

            IF_NBDBG( NB_DEBUG_CALL )
            {
                NbPrint( (
                    "NbOpenConnection: error : Close file invoked for %d\n", 
                    pdncb-> ncb_lana_num 
                    ) );
            }
            
            localstatus = ZwClose( *FileHandle);

            ASSERT(NT_SUCCESS(localstatus));

            *FileHandle = NULL;
        }
    }


    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("NbOpenConnection Status:%X, IoStatus:%X.\n", Status, IoStatusBlock.Status));
    }


    if (!NT_SUCCESS( Status )) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("NbOpenConnection:  FAILURE, status code=%X.\n", Status));
        }
        return Status;
    }

    return Status;
} /* NbOpenConnection */

PPCB
NewCb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    )
/*++

Routine Description:

Arguments:

    IrpSp - Pointer to current IRP stack frame.

    pdncb - Supplies the ncb requesting the new virtual connection.

Return Value:

    The address of the pointer to the new Cb in the ConnectionBlocks
    Array.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PCB pcb;
    PPCB ppcb = NULL;
    PFCB pfcb = FileObject->FsContext2;
    PLANA_INFO plana;
    int index;
    PPAB ppab;

    PAGED_CODE();

    if (pdncb->ncb_lana_num > pfcb->MaxLana ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        IF_NBDBG (NB_DEBUG_CALL) {
            if ( pfcb == NULL ) {
                NbPrint( ("NewCb pfcb==NULL\n"));
            } else {
                if ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) {
                    NbPrint( ("NewCb pfcb->ppLana[%x]==NULL\n",
                        pdncb->ncb_lana_num));
                } else {
                    NbPrint( ("NewCb pfcb->ppLana[%x]->Status = %x\n",
                        pdncb->ncb_lana_num,
                        pfcb->ppLana[pdncb->ncb_lana_num]->Status));
                }
            }
        }

        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }
    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    if ( plana->ConnectionCount == plana->MaximumConnection ) {
        NCB_COMPLETE( pdncb, NRC_LOCTFUL );
        return NULL;
    }

    ppab = FindAb( pfcb, pdncb, TRUE );

    if ( ppab == NULL ) {
        //
        //  This application is only allowed to use names that have been
        //  addnamed by this application or the special address 0.
        //
        return NULL;

    }

    //  FindAb has incremented the number of CurrentUsers for this address block.

    //
    //  Find the appropriate session number to use.
    //

    index = plana->NextConnection;
    while ( plana->ConnectionBlocks[index] != NULL ) {
        index++;
        if ( index > MAXIMUM_CONNECTION ) {
            index = 1;
        }
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("NewCb pfcb: %lx, plana: %lx, index: %lx, ppcb: %lx, pcb: %lx\n",
                pfcb,
                pdncb->ncb_lana_num,
                index,
                &plana->ConnectionBlocks[index],
                plana->ConnectionBlocks[index] ));
        }
    }

    plana->ConnectionCount++;
    plana->NextConnection = index + 1;
    if ( plana->NextConnection > MAXIMUM_CONNECTION ) {
        plana->NextConnection = 1;
    }

    //
    //  Fill in the LSN so that the application will be able
    //  to reference this connection in the future.
    //

    pdncb->ncb_lsn = (unsigned char)index;

    ppcb = &plana->ConnectionBlocks[index];

    *ppcb = pcb = ExAllocatePoolWithTag (NonPagedPool, sizeof(CB), 'cSBN');

    if (pcb==NULL) {

        DEREFERENCE_AB(ppab);
        NCB_COMPLETE( pdncb, NbMakeNbError( STATUS_INSUFFICIENT_RESOURCES ) );
        return NULL;
    }

    pcb->ppab = ppab;
    pcb->ConnectionHandle = NULL;
    pcb->ConnectionObject = NULL;
    pcb->DeviceObject = NULL;
    pcb->pLana = plana;
    pcb->ReceiveIndicated = 0;
    pcb->DisconnectReported = FALSE;
    InitializeListHead(&pcb->ReceiveList);
    InitializeListHead(&pcb->SendList);
    RtlMoveMemory( &pcb->RemoteName, pdncb->ncb_callname, NCBNAMSZ);
    pcb->Adapter = plana;
    pcb->SessionNumber = (UCHAR)index;
    pcb->ReceiveTimeout = pdncb->ncb_rto;
    pcb->SendTimeout = pdncb->ncb_sto;

    //
    //  Fill in the Users virtual address so we can cancel the Listen/Call
    //  if the user desires.
    //

    pcb->UsersNcb = pdncb->users_ncb;
    pcb->pdncbCall = pdncb;
    pcb->pdncbHangup = NULL;

    if (( pcb->ReceiveTimeout != 0 ) ||
        ( pcb->SendTimeout != 0 )) {
        NbStartTimer( pfcb );
    }

    pcb->Signature = CB_SIGNATURE;
    pcb->Status = 0;    //  An invalid value!

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("NewCb pfcb: %lx, ppcb: %lx, pcb= %lx, lsn %lx\n",
            pfcb,
            ppcb,
            pcb,
            index));
    }

    return ppcb;
} /* NewCb */

NTSTATUS
CleanupCb(
    IN PPCB ppcb,
    IN PDNCB pdncb OPTIONAL
    )
/*++

Routine Description:

    This closes the handles in the Cb and dereferences the objects.

    Note: Resource must be held before calling this routine.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

    pdncb - Optional Address of the Hangup DNCB.

Return Value:

    STATUS_PENDING if Hangup held due to an outstanding send. Otherwise STATUS_SUCCESS

--*/

{
    PCB pcb;
    PDNCB pdncbHangup;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PFCB pfcb;
    PDNCB pdncbtemp;
    PDNCB pdncbReceiveAny;

    if ( ppcb == NULL ) {
        ASSERT( FALSE );
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb ppcb: %lx, pdncb: %lx\n", ppcb, pdncb));
        }
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;
    pfcb = pcb->pLana->pFcb;

    LOCK_SPINLOCK( pfcb, OldIrql );
    ppab = (*ppcb)->ppab;

    if ( pcb == NULL ) {
        ASSERT( FALSE );
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb ppcb: %lx, pcb %lx, pdncb %lx\n", ppcb, pcb, pdncb));
        }
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }

    ASSERT( pcb->Signature == CB_SIGNATURE );

    //
    //  Set pcb->pdncbHangup to NULL. This prevents NbCompletionPDNCB from queueing a CleanupCb
    //  if we Close the connection and cause sends to get returned.
    //

    pdncbHangup = pcb->pdncbHangup;
    pcb->pdncbHangup = NULL;

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CleanupCb ppcb: %lx, pcb= %lx\n", ppcb, pcb));
    }

    //
    //  If this is a Hangup (only time pdncb != NULL
    //  and we do not have a hangup on this connection
    //  and there are outstanding sends then delay the hangup.
    //

    if (( pdncb != NULL ) &&
        ( pdncbHangup == NULL ) &&
        ( !IsListEmpty(&pcb->SendList) )) {

        ASSERT(( pdncb->ncb_command & ~ASYNCH ) == NCBHANGUP );

        //
        //  We must wait up to 20 seconds for the send to complete before removing the
        //  connection.
        //

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb delaying Hangup, waiting for send to complete\n"));
        }

        pcb->pdncbHangup = pdncb;
        //  reset retcode so that NCB_COMPLETE will process the next NCB_COMPLETE.
        pcb->pdncbHangup->ncb_retcode = NRC_PENDING;
        pdncb->tick_count = 40;
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        NbStartTimer( pfcb );
        return STATUS_PENDING;
    }

    pcb->Status = SESSION_ABORTED;

    //  Cancel all the receive requests for this connection.

    while ( (pdncbtemp = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

        NCB_COMPLETE( pdncbtemp, NRC_SCLOSED );

        pdncbtemp->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        NbCompleteRequest( pdncbtemp->irp, STATUS_SUCCESS );
        pcb->DisconnectReported = TRUE;

    }

    if (pcb->DisconnectReported == FALSE) {
        //
        //  If there is a receive any on the name associated with this connection then
        //  return one receive any to the application. If there are no receive any's then
        //  don't worry. The spec says to do this regardless of whether we have told
        //  the application that the connection is closed using a receive or send.
        //  Indeed the spec says to do this even if the application gave us a hangup!
        //

        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );

            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_SUCCESS );
            pcb->DisconnectReported = TRUE;

        } else {

            PAB pab255 = pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];
            //
            //  If there is a receive any for any name then
            //  return one receive any to the application. If there are no receive any
            //  any's then don't worry.
            //

            if ( (pdncbReceiveAny = DequeueRequest( &pab255->ReceiveAnyList)) != NULL ) {

                pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
                pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;
                NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );

                pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                NbCompleteRequest( pdncbReceiveAny->irp, STATUS_SUCCESS );
                pcb->DisconnectReported = TRUE;

            }
        }
    }


    UNLOCK_SPINLOCK( pfcb, OldIrql );

    CloseConnection( ppcb, 20000 );

    LOCK_SPINLOCK( pfcb, OldIrql );

    //
    //  Any sends will have been returned to the caller by now because of the NtClose on the
    //  ConnectionHandle. Tell the caller that the hangup is complete if we have a hangup.
    //

    if ( pdncbHangup != NULL ) {
        NCB_COMPLETE( pdncbHangup, NRC_GOODRET );
        pdncbHangup->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        NbCompleteRequest( pdncbHangup->irp, STATUS_SUCCESS );
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CleanupCb pcb: %lx, ppab: %lx, AddressHandle: %lx\n",
            pcb,
            ppab,
            (*ppab)->AddressHandle));

        NbFormattedDump( (PUCHAR)&(*ppab)->Name, sizeof(NAME) );
    }

    //
    //  IBM test Mif081.c states that it is not necessary to report the disconnection
    //  of a session if the name has already been deleted.
    //

    if (( pcb->DisconnectReported == TRUE ) ||
        ( ((*ppab)->Status & 7 ) == DEREGISTERED )) {
        pcb->Adapter->ConnectionCount--;
        *ppcb = NULL;

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        DEREFERENCE_AB( ppab );
        ExFreePool( pcb );

    } else {
        UNLOCK_SPINLOCK( pfcb, OldIrql );
    }
    return STATUS_SUCCESS;
}

VOID
AbandonConnection(
    IN PPCB ppcb
    )
/*++

Routine Description:

    This routine examines the connection block and attempts to find a request to
    send a session abort status plus it completes the Irp with STATUS_HANGUP_REQUIRED.
    It always changes the status of the connection so that further requests are correctly
    rejected. Upon getting the STATUS_HANGUP_REQUIRED, the dll will submit a hangup NCB
    which will call CleanupCb.

    This round about method is used because of the restrictions caused by being at Dpc or Apc
    level and in the wrong context when the transport indicates that the connection is to
    be cleaned up.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

Return Value:

    None.

--*/

{
    PCB pcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PFCB pfcb;
    PPAB ppab;
    PDNCB pdncb;
    PDNCB pdncbReceiveAny;

    pcb = *ppcb;

    if (pcb != NULL)
    {
        pfcb = pcb->pLana->pFcb;

        LOCK_SPINLOCK( pfcb, OldIrql );

        ASSERT( pcb->Signature == CB_SIGNATURE );

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("AbandonConnection ppcb: %lx, pcb= %lx\n", ppcb, pcb));
        }
        pcb->Status = SESSION_ABORTED;

        while ( (pdncb = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncb, NRC_SCLOSED );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        if ( pcb->pdncbHangup != NULL ) {
            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pcb->pdncbHangup, NRC_SCLOSED );
            pcb->pdncbHangup->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pcb->pdncbHangup->irp, STATUS_HANGUP_REQUIRED );
            pcb->pdncbHangup = NULL;
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        //
        //  If there is a receive any on the name associated with this connection then
        //  return one receive any to the application.
        //

        ppab = (*ppcb)->ppab;
        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );
            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        //
        //  If there is a receive any any with the lana associated with this connection then
        //  return one receive any to the application. If there are no receive any's then
        //  don't worry.

        ppab = &pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];
        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );
            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        UNLOCK_SPINLOCK( pfcb, OldIrql );
    }

    return;
}

VOID
CloseConnection(
    IN PPCB ppcb,
    IN DWORD dwTimeOutInMS
    )
/*++

Routine Description:

    This routine examines the connection block and attempts to close the connection
    handle to the transport. This will complete all outstanding requests.

    This routine assumes the spinlock is not held but the resource is.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

    dwTimeOutInMS - Timeout value in milliseconds for Disconnect 

Return Value:

    None.

--*/

{
    PCB pcb;
    NTSTATUS localstatus;

    PAGED_CODE();

    pcb = *ppcb;

    ASSERT( pcb->Signature == CB_SIGNATURE );

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CloseConnection ppcb: %lx, pcb= %lx\n", ppcb, pcb));
    }

    if ( pcb->ConnectionHandle ) {
        HANDLE Handle;

        Handle = pcb->ConnectionHandle;
        pcb->ConnectionHandle = NULL;

        //
        //  If we have a connection, request an orderly disconnect.
        //

        if ( pcb->ConnectionObject != NULL ) {
            PIRP Irp;
            LARGE_INTEGER DisconnectTimeout;

            DisconnectTimeout.QuadPart = Int32x32To64( dwTimeOutInMS, -10000 );

            Irp = IoAllocateIrp( pcb->DeviceObject->StackSize, FALSE);

            //
            //  If we cannot allocate an Irp, the ZwClose will cause a disorderly
            //  disconnect.
            //

            if (Irp != NULL) {
                TdiBuildDisconnect(
                    Irp,
                    pcb->DeviceObject,
                    pcb->ConnectionObject,
                    NULL,
                    NULL,
                    &DisconnectTimeout,
                    TDI_DISCONNECT_RELEASE,
                    NULL,
                    NULL);

                SubmitTdiRequest(pcb->ConnectionObject, Irp);

                IoFreeIrp(Irp);
            }

            // Remove reference put on in NbOpenConnection

            ObDereferenceObject( pcb->ConnectionObject );

            pcb->DeviceObject = NULL;
            pcb->ConnectionObject = NULL;
        }

        IF_NBDBG( NB_DEBUG_CALL )
        {
            NbPrint( (
                "CloseConnection : Close file invoked for \n"
            ) );

            NbFormattedDump( (PUCHAR) &pcb-> RemoteName, sizeof( NAME ) );
        }
            

        if (PsGetCurrentProcess() != NbFspProcess) {
            KAPC_STATE	ApcState;

            KeStackAttachProcess(NbFspProcess, &ApcState);
            localstatus = ZwClose( Handle);
            ASSERT(NT_SUCCESS(localstatus));
            KeUnstackDetachProcess(&ApcState);
        } else {
            localstatus = ZwClose( Handle);
            ASSERT(NT_SUCCESS(localstatus));
        }
    }
    return;
}

PPCB
FindCb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IgnoreState
    )
/*++

Routine Description:

    This routine uses the callers lana number and LSN to find the Cb.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Cb is chained onto.

    pdncb - Supplies the connection id from the applications point of view.

    IgnoreState - Return even if connection in error.

Return Value:

    The address of the pointer to the connection block or NULL.

--*/

{
    PPCB ppcb;
    UCHAR Status;

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("FindCb pfcb: %lx, lana: %lx, lsn: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            pdncb->ncb_lsn));
    }

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    if (( pdncb->ncb_lsn > MAXIMUM_CONNECTION ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->ConnectionBlocks[pdncb->ncb_lsn] == NULL)) {

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( (" not found\n"));
        }

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return NULL;
    }

    ppcb = &(pfcb->ppLana[pdncb->ncb_lana_num]->ConnectionBlocks[pdncb->ncb_lsn]);
    Status = (*ppcb)->Status;

    //
    //  Hangup and session status can be requested whatever state the
    //  connections in. Call and Listen use FindCb only to find and modify
    //  the Status so they are allowed also.
    //

    if (( Status != SESSION_ESTABLISHED ) &&
        ( !IgnoreState )) {

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("FindCb Status %x\n", Status));
        }

        if (( pdncb->ncb_retcode == NRC_PENDING ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBHANGUP ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBSSTAT ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBCALL ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCALLNIU ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBLISTEN )) {

            if ( Status == SESSION_ABORTED ) {

                (*ppcb)->DisconnectReported = TRUE;
                NCB_COMPLETE( pdncb, NRC_SCLOSED );

            } else {

                NCB_COMPLETE( pdncb, NRC_TOOMANY ); // Try again later

            }

            //
            //  On hangup we want to pass the connection back to give
            //  cleanupcb a chance to destroy the connection. For all
            //  other requests return NULL.
            //

            if (( pdncb->ncb_command & ~ASYNCH) != NCBHANGUP ) {
                return NULL;
            }

        }
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( (", ppcb= %lx\n", ppcb ));
    }

    ASSERT( (*ppcb)->Signature == CB_SIGNATURE );

    return ppcb;
}

BOOL
FindActiveSession(
    IN PFCB pfcb,
    IN PDNCB pdncb OPTIONAL,
    IN PPAB ppab
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pdncb - Supplies the ncb requesting the Delete Name.

    ppab - Supplies (indirectly) the TDI handle to scan for.

Return Value:

    TRUE iff there is an active session found using this handle.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana = (*ppab)->pLana;
    int index;

    if ( ARGUMENT_PRESENT(pdncb) ) {
        if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return FALSE;
        }

        if (( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return FALSE;
        }
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("FindActiveSession index:%x connections ppab: %lx = ppab: %lx state: %x\n",
                index,
                plana->ConnectionBlocks[index]->ppab,
                ppab,
                plana->ConnectionBlocks[index]->Status));
        }
        //  Look for active sessions on this address.
        if (( plana->ConnectionBlocks[index]->ppab == ppab ) &&
            ( plana->ConnectionBlocks[index]->Status == SESSION_ESTABLISHED )) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
CloseListens(
    IN PFCB pfcb,
    IN PPAB ppab
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    ppab - All listens using this address are to be closed.

Return Value:

    none.

--*/

{
    PLANA_INFO plana;
    int index;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = (*ppab)->pLana;
    LOCK_SPINLOCK( pfcb, OldIrql );

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CloseListen index:%x connections ppab: %lx = ppab: %lx state: %x\n",
                index,
                plana->ConnectionBlocks[index]->ppab,
                ppab,
                plana->ConnectionBlocks[index]->Status));
        }
        //  Look for a listen on this address.
        if (( plana->ConnectionBlocks[index]->ppab == ppab ) &&
            ( plana->ConnectionBlocks[index]->Status == LISTEN_OUTSTANDING )) {
            PDNCB pdncb = plana->ConnectionBlocks[index]->pdncbCall;
            NCB_COMPLETE( pdncb, NRC_NAMERR );
            plana->ConnectionBlocks[index]->DisconnectReported = TRUE;
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            CleanupCb( &plana->ConnectionBlocks[index], NULL);
            LOCK_SPINLOCK( pfcb, OldIrql );
        }
    }
    UNLOCK_SPINLOCK( pfcb, OldIrql );
}

PPCB
FindCallCb(
    IN PFCB pfcb,
    IN PNCB pncb,
    IN UCHAR ucLana
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pncb - Supplies the USERS VIRTUAL address CALL or LISTEN ncb to be
           cancelled.

Return Value:

    The address of the pointer to the connection block or NULL.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana;
    int index;

    if ( ucLana > pfcb->MaxLana ) {
        return NULL;
    }

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[ucLana] == NULL ) ||
        ( pfcb->ppLana[ucLana]->Status != NB_INITIALIZED)) {
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[ucLana];

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if (( plana->ConnectionBlocks[index] != NULL ) &&
            ( plana->ConnectionBlocks[index]->UsersNcb == pncb )) {
            return &plana->ConnectionBlocks[index];
        }
    }

    return NULL;
}

PPCB
FindReceiveIndicated(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    )
/*++

Routine Description:


    Find either a connection with a receive indicated or one that has been
    disconnected but not reported yet.

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pdncb - Supplies the ncb with the receive any.

    ppab - Supplies (indirectly) the TDI handle to scan for.

Return Value:

    PPCB - returns the connection with the indicated receive.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana;
    int index;

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    for ( index=0 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        if ( pdncb->ncb_num == MAXIMUM_ADDRESS) {

            //  ReceiveAny on Any address
            if (( plana->ConnectionBlocks[index]->ReceiveIndicated != 0 ) ||
                (( plana->ConnectionBlocks[index]->Status == SESSION_ABORTED ) &&
                 ( plana->ConnectionBlocks[index]->DisconnectReported == FALSE ))) {
                PPAB ppab;

                pdncb->ncb_lsn = (UCHAR)index;
                ppab = plana->ConnectionBlocks[index]->ppab;
                pdncb->ncb_num = (*ppab)->NameNumber;
                return &plana->ConnectionBlocks[index];
            }
        } else {
            if ( plana->ConnectionBlocks[index]->ppab == ppab ) {
                //  This connection is using the correct address.
                if (( plana->ConnectionBlocks[index]->ReceiveIndicated != 0 ) ||
                    (( plana->ConnectionBlocks[index]->Status == SESSION_ABORTED ) &&
                     ( plana->ConnectionBlocks[index]->DisconnectReported == FALSE ))) {
                    pdncb->ncb_lsn = (UCHAR)index;
                    return &plana->ConnectionBlocks[index];
                }
            }
        }
    }

    return NULL;
}

NTSTATUS
NbTdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators
    )
/*++

Routine Description:

    This routine is called when a session is disconnected from a remote
    machine.

Arguments:

    IN PVOID EventContext,
    IN PCONNECTION_CONTEXT ConnectionContext,
    IN ULONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectIndicators

Return Value:

    NTSTATUS - Status of event indicator

--*/

{


    IF_NBDBG (NB_DEBUG_CALL) {
        PPCB ppcb = ConnectionContext;
        NbPrint( ("NbTdiDisconnectHandler ppcb: %lx, pcb %lx\n", ppcb, (*ppcb)));
    }

    AbandonConnection( (PPCB)ConnectionContext );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(EventContext);
    UNREFERENCED_PARAMETER(DisconnectDataLength);
    UNREFERENCED_PARAMETER(DisconnectData);
    UNREFERENCED_PARAMETER(DisconnectInformationLength);
    UNREFERENCED_PARAMETER(DisconnectInformation);
    UNREFERENCED_PARAMETER(DisconnectIndicators);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nb32.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nb32.c

Abstract:

    This module contains routines to support thunking 32-bit NetBIOS IOCTLs
    on Win64.

Author:

    Samer Arafeh (SamerA) 11-June-2000

Environment:

    Kernel mode

Revision History:

--*/

#if defined(_WIN64)

#include "nb.h"



NTSTATUS
NbThunkNcb(
    IN PNCB32 Ncb32,
    OUT PDNCB Dncb)

/*++

Routine Description:

    This routine converts the input NCB structure received from the
    32-bit app, into a 64-bit compatible structure

Arguments:

    Ncb32 - Pointer to the NCB received from the 32-bit app.

    Dncb   - Pointer to the structure to receive the 64-bit NCB after
             thunking the 32-bit one.

Return Value:

    The function returns the status of the operation.

--*/
{
    Dncb->ncb_command  = Ncb32->ncb_command;
    Dncb->ncb_retcode  = Ncb32->ncb_retcode;
    Dncb->ncb_lsn      = Ncb32->ncb_lsn;
    Dncb->ncb_num      = Ncb32->ncb_num;
    Dncb->ncb_buffer   = (PUCHAR)Ncb32->ncb_buffer;
    Dncb->ncb_length   = Ncb32->ncb_length;
    
    RtlCopyMemory(Dncb->ncb_callname,
                  Ncb32->ncb_callname,
                  sizeof(Dncb->ncb_callname)) ;

    RtlCopyMemory(Dncb->ncb_name,
                  Ncb32->ncb_name,
                  sizeof(Dncb->ncb_name));

    Dncb->ncb_rto      = Ncb32->ncb_rto;
    Dncb->ncb_sto      = Ncb32->ncb_sto;
    Dncb->ncb_post     = (void (*)(struct _NCB *))
                         Ncb32->ncb_post;
    Dncb->ncb_lana_num = Ncb32->ncb_lana_num;
    Dncb->ncb_cmd_cplt = Ncb32->ncb_cmd_cplt;

    return STATUS_SUCCESS;
}


NTSTATUS
NbCompleteIrp32(
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine completes an NCB Irp if it has been received
    from a 32-bit appliation. The caller should verify that the Irp
    is coming from a 32-bit context.

Arguments:

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function returns the status of the operation.

--*/
{
    PDNCB Dncb;
    PNCB32 Ncb32;
    ULONG Count;

    
    //
    // Conver the 64-bit NCB to a 32-bit compatible NCB
    // before the IO MGR copies it back to the supplied 
    // user-mode buffer
    //
    if ((Irp->Flags & (IRP_BUFFERED_IO | IRP_INPUT_OPERATION)) == 
         (IRP_BUFFERED_IO | IRP_INPUT_OPERATION))
    {
        Dncb  = (PDNCB) Irp->AssociatedIrp.SystemBuffer;
        Ncb32 = (PNCB32) Dncb;

        if ((Irp->IoStatus.Information > 0) &&
            (!NT_ERROR(Irp->IoStatus.Status)) &&
            (InterlockedCompareExchange(&Dncb->Wow64Flags, TRUE, FALSE) == FALSE))
        {

            Ncb32->ncb_command  = Dncb->ncb_command;
            Ncb32->ncb_retcode  = Dncb->ncb_retcode;
            Ncb32->ncb_lsn      = Dncb->ncb_lsn;
            Ncb32->ncb_num      = Dncb->ncb_num;
            Ncb32->ncb_buffer   = (UCHAR * POINTER_32)PtrToUlong(Dncb->ncb_buffer);
            Ncb32->ncb_length   = Dncb->ncb_length;

            for (Count=0 ; Count<sizeof(Ncb32->ncb_callname) ; Count++)
            {
                Ncb32->ncb_callname[Count] = Dncb->ncb_callname[Count];
            }

            for (Count=0 ; Count<sizeof(Ncb32->ncb_name) ; Count++)
            {
                Ncb32->ncb_name[Count] = Dncb->ncb_name[Count];
            }

            Ncb32->ncb_rto      = Dncb->ncb_rto;
            Ncb32->ncb_sto      = Dncb->ncb_sto;
            Ncb32->ncb_post     = (void (* POINTER_32)(struct _NCB *))
                                   PtrToUlong(Dncb->ncb_post);
            Ncb32->ncb_lana_num = Dncb->ncb_lana_num;
            Ncb32->ncb_cmd_cplt = Dncb->ncb_cmd_cplt;

            Irp->IoStatus.Information = FIELD_OFFSET(NCB32, ncb_cmd_cplt);
        }
    }

    return STATUS_SUCCESS;
}



#endif  // (_WIN64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nbdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbdebug.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/



#ifndef _NBPROCS_
#define _NBPROCS_

//
// DEBUGGING SUPPORT.  DBG is a macro that is turned on at compile time
// to enable debugging code in the system.  If this is turned on, then
// you can use the IF_NBDBG(flags) macro in the NB code to selectively
// enable a piece of debugging code in the driver.  This macro tests
// NbDebug, a global ULONG defined in NB.C.
//

#if DBG

#define NB_DEBUG_DISPATCH      0x00000001      // nb.c
#define NB_DEBUG_DEVOBJ        0x00000002      // devobj.c
#define NB_DEBUG_COMPLETE      0x00000004      // nb.c
#define NB_DEBUG_CALL          0x00000008      // nb.c
#define NB_DEBUG_ASTAT         0x00000010      // nb.c
#define NB_DEBUG_SEND          0x00000020      // nb.c
#define NB_DEBUG_ACTION        0x00000040      // nb.c
#define NB_DEBUG_FILE          0x00000080      // file.c
#define NB_DEBUG_APC           0x00000100      // apc.c
#define NB_DEBUG_ERROR_MAP     0x00000200      // error.c
#define NB_DEBUG_LANSTATUS     0x00000400      // error.c
#define NB_DEBUG_ADDRESS       0x00000800      // address.c
#define NB_DEBUG_RECEIVE       0x00001000      // receive.c
#define NB_DEBUG_IOCANCEL      0x00002000      // nb.c

#define NB_DEBUG_CREATE_FILE   0x00004000      // used in address.c and connect.c
#define NB_DEBUG_LIST_LANA     0x00008000

#define NB_DEBUG_DEVICE_CONTROL 0x00040000

//#define NB_DEBUG_LANA_ERROR    0x00010000
//#define NB_DEBUG_ADDRESS_COUNT 0x00020000

#define NB_DEBUG_NCBS          0x04000000      // Used by NCB_COMPLETE in nb.h
#define NB_DEBUG_LOCKS         0x20000000      // nb.h
#define NB_DEBUG_TIMER         0x40000000      // timer.c
#define NB_DEBUG_NCBSBRK       0x80000000      // Used by NCB_COMPLETE in nb.h

extern ULONG NbDebug;                          // in NB.C.

//
//  VOID
//  IF_NBDBG(
//      IN PSZ Message
//      );
//

#define IF_NBDBG(flags)                                     \
    if (NbDebug & (flags))

#define NbPrint(String) DbgPrint String

#define InternalError(String) {                                     \
    DbgPrint("[NETBIOS]: Internal error : File %s, Line %d\n",      \
              __FILE__, __LINE__);                                  \
    DbgPrint String;                                                \
}

#else

#define IF_NBDBG(flags)                                     \
    if (0)

#define NbPrint(String) { NOTHING;}

#define NbDisplayNcb(String) { NOTHING;}

#define NbFormattedDump(String, String1) { NOTHING;}

#define InternalError(String) {                             \
    KeBugCheck(FILE_SYSTEM);                                \
}

#endif

#endif // def _NBPROCS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nb.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nb.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/

#ifndef _NB_
#define _NB_

#include <ntifs.h>

//#include <ntos.h>
#include <windef.h>
#include <status.h>
#include <tdikrnl.h>                       // Transport Driver Interface.
#include <nb30.h>
#include <nb30p.h>
#include <netpnp.h>

#include "nbconst.h"                    // private NETBEUI constants.
#include "nbtypes.h"                    // private NETBEUI types.
#include "nbdebug.h"                    // private NETBEUI debug defines.
#include "nbprocs.h"                    // private NETBEUI function prototypes.

#ifdef MEMPRINT
#include "memprint.h"                   // drt's memory debug print
#endif

extern PEPROCESS    NbFspProcess;


extern ULONG                g_ulMaxLana;

extern LANA_ENUM            g_leLanaEnum;

extern PUNICODE_STRING      g_pusActiveDeviceList;

extern HANDLE               g_hBindHandle;

extern UNICODE_STRING       g_usRegistryPath;

extern LIST_ENTRY           g_leFCBList;

extern ERESOURCE            g_erGlobalLock;



#if DBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "NETBIOS: Pageable code called at IRQL %d.  File %s, Line %d\n", KeGetCurrentIrql(), __FILE__, __LINE__ )); \
        ASSERT(FALSE); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
extern ULONG ThisCodeCantBePaged;
#else
#define PAGED_CODE_CHECK()
#endif


#if PAGED_DBG
#define ACQUIRE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeAcquireSpinLock(a, b);                    \
    }
#define RELEASE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeReleaseSpinLock(a, b);                    \
    }

#else
#define ACQUIRE_SPIN_LOCK(a, b) KeAcquireSpinLock(a, b)
#define RELEASE_SPIN_LOCK(a, b) KeReleaseSpinLock(a, b)
#endif



//
//  Macro for filling in the status for an NCB.
//

#define NCB_COMPLETE( _pdncb, _code ) {                                 \
    UCHAR _internal_copy = _code;                                       \
    IF_NBDBG (NB_DEBUG_COMPLETE) {                                      \
        NbPrint (("%s %d NCB_COMPLETE: %lx, %lx\n" ,                    \
         __FILE__, __LINE__, _pdncb, _internal_copy ));                 \
    }                                                                   \
    if (((PDNCB)_pdncb)->ncb_retcode  == NRC_PENDING) {                 \
        ((PDNCB)_pdncb)->ncb_retcode  = _internal_copy;                 \
    } else {                                                            \
        IF_NBDBG (NB_DEBUG_NCBS) {                                      \
            NbPrint((" Status already set!!!!!!!!\n"));                 \
            IF_NBDBG (NB_DEBUG_NCBSBRK) {                               \
                DbgBreakPoint();                                        \
            }                                                           \
        }                                                               \
    }                                                                   \
    IF_NBDBG (NB_DEBUG_NCBS) {                                          \
        NbDisplayNcb( (PDNCB)_pdncb );                                  \
    }                                                                   \
    IF_NBDBG (NB_DEBUG_COMPLETE)                                        \
    {                                                                   \
        if ( ( (_code) == NRC_BRIDGE ) ||                               \
             ( (_code) == NRC_ENVNOTDEF ) )                             \
        {                                                               \
            DbgPrint("\n[NETBIOS]: NCB_COMPLETE : File %s,"             \
                     " line %d\n", __FILE__, __LINE__);                 \
            DbgPrint("LANA %x, Command %x ",                            \
                     ((PDNCB)_pdncb)->ncb_lana_num,                     \
                     ((PDNCB)_pdncb)->ncb_command );                    \
            DbgPrint("Return %x, Cmplt %x\n",                           \
                      ((PDNCB)_pdncb)->ncb_retcode,                     \
                      ((PDNCB)_pdncb)->ncb_cmd_cplt );                  \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_name, 16 );           \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_callname, 16 );       \
        }                                                               \
        else if ( ( ( (_code) == NRC_DUPNAME ) ||                       \
                    ( (_code) == NRC_INUSE ) ) &&                       \
                  ( ((PDNCB)_pdncb)-> ncb_command != NCBADDGRNAME ) )   \
        {                                                               \
            DbgPrint("\n[NETBIOS]: NCB_COMPLETE : DUPNAME : File %s,"   \
                     "line %d\n", __FILE__, __LINE__);                  \
            DbgPrint("LANA %x, Command %x ",                            \
                     ((PDNCB)_pdncb)->ncb_lana_num,                     \
                     ((PDNCB)_pdncb)->ncb_command );                    \
            DbgPrint("Return %x, Cmplt %x\n",                           \
                     ((PDNCB)_pdncb)->ncb_retcode,                      \
                     ((PDNCB)_pdncb)->ncb_cmd_cplt );                   \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_name, 16 );           \
            if ( ((PDNCB)_pdncb)->ncb_name[15] == 0x3)                  \
            {                                                           \
                DbgPrint("Messenger Name, dup ok\n");                   \
            }                                                           \
            else                                                        \
            {                                                           \
                IF_NBDBG(NB_DEBUG_NCBSBRK) DbgBreakPoint();             \
            }                                                           \
        }                                                               \
    }                                                                   \
}


//++
//
//  VOID
//  NbCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--
#define NbCompleteRequest(IRP,STATUS) {                 \
    (IRP)->IoStatus.Status = (STATUS);                  \
    IoCompleteRequest( (IRP), IO_NETWORK_INCREMENT );   \
}


#if defined(_WIN64)
#define NbCheckAndCompleteIrp32(Irp)                    \
{                                                       \
    if (IoIs32bitProcess(Irp) == TRUE)                  \
    {                                                   \
        NbCompleteIrp32(Irp);                           \
    }                                                   \
}
#else
#define NbCheckAndCompleteIrp32(Irp)
#endif                
//
//  Normally the driver wants to prohibit other threads making
//  requests (using a resource) and also prevent indication routines
//  being called (using a spinlock).
//
//  To do this LOCK and UNLOCK are used. IO system calls cannot
//  be called with a spinlock held so sometimes the ordering becomes
//  LOCK, UNLOCK_SPINLOCK <do IO calls> UNLOCK_RESOURCE.
//

#define LOCK(PFCB, OLDIRQL)   {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint (("%s %d LOCK: %lx %lx %lx\n" ,                 \
         __FILE__, __LINE__, (PFCB) ));                         \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &(PFCB)->Resource, TRUE);   \
    ACQUIRE_SPIN_LOCK( &(PFCB)->SpinLock, &(OLDIRQL));          \
}

#define LOCK_RESOURCE(PFCB)   {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_RESOURCE: %lx, %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB)));                          \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &(PFCB)->Resource, TRUE);   \
}

#define LOCK_GLOBAL()   {                                       \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_GLOBAL: %lx, %lx\n" ,              \
         __FILE__, __LINE__));                                  \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &g_erGlobalLock, TRUE);     \
}

#define LOCK_STOP()   {                                         \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_STOP: %lx, %lx\n" ,                \
         __FILE__, __LINE__));                                  \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &g_erStopLock, TRUE);       \
}


#define LOCK_SPINLOCK(PFCB, OLDIRQL)   {                        \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d LOCK_SPINLOCK: %lx %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB)));                          \
    }                                                           \
    ACQUIRE_SPIN_LOCK( &(PFCB)->SpinLock, &(OLDIRQL));          \
}

#define UNLOCK(PFCB, OLDIRQL) {                                 \
    UNLOCK_SPINLOCK( PFCB, OLDIRQL );                           \
    UNLOCK_RESOURCE( PFCB );                                    \
}

#define UNLOCK_GLOBAL()   {                                     \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d UNLOCK_GLOBAL: %lx, %lx\n" ,            \
         __FILE__, __LINE__));                                  \
    }                                                           \
    ExReleaseResourceLite( &g_erGlobalLock );                   \
    KeLeaveCriticalRegion();                                    \
}


#define UNLOCK_STOP()   {                                       \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d UNLOCK_STOP: %lx, %lx\n" ,              \
         __FILE__, __LINE__));                                  \
    }                                                           \
    ExReleaseResourceLite( &g_erStopLock );                     \
    KeLeaveCriticalRegion();                                    \
}

#define UNLOCK_RESOURCE(PFCB) {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d RESOURCE: %lx, %lx %lx\n" ,            \
         __FILE__, __LINE__, (PFCB) ));                         \
    }                                                           \
    ExReleaseResourceLite( &(PFCB)->Resource );                 \
    KeLeaveCriticalRegion();                                    \
}

#define UNLOCK_SPINLOCK(PFCB, OLDIRQL) {                        \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d SPINLOCK: %lx, %lx %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB), (OLDIRQL)));               \
    }                                                           \
    RELEASE_SPIN_LOCK( &(PFCB)->SpinLock, (OLDIRQL) );          \
}


//  Assume resource held when modifying CurrentUsers
#define REFERENCE_AB(PAB) {                                     \
    (PAB)->CurrentUsers++;                                      \
    IF_NBDBG (NB_DEBUG_ADDRESS) {                               \
        NbPrint( ("ReferenceAb %s %d: %lx, NewCount:%lx\n",     \
            __FILE__, __LINE__,                                 \
            PAB,                                                \
            (PAB)->CurrentUsers));                              \
        NbFormattedDump( (PUCHAR)&(PAB)->Name, sizeof(NAME) );  \
    }                                                           \
}

//  Resource must be held before dereferencing the address block

#define DEREFERENCE_AB(PPAB) {                                  \
    IF_NBDBG (NB_DEBUG_ADDRESS) {                               \
        NbPrint( ("DereferenceAb %s %d: %lx, OldCount:%lx\n",   \
            __FILE__, __LINE__, *PPAB, (*PPAB)->CurrentUsers)); \
        NbFormattedDump( (PUCHAR)&(*PPAB)->Name, sizeof(NAME) );\
    }                                                           \
    (*PPAB)->CurrentUsers--;                                    \
    if ( (*PPAB)->CurrentUsers == 0 ) {                         \
        if ( (*PPAB)->AddressHandle != NULL ) {                 \
            IF_NBDBG (NB_DEBUG_ADDRESS) {                       \
                NbPrint( ("DereferenceAb: Closing: %lx\n",      \
                    (*PPAB)->AddressHandle));                   \
            }                                                   \
            NbAddressClose( (*PPAB)->AddressHandle,             \
                                 (*PPAB)->AddressObject );      \
            (*PPAB)->AddressHandle = NULL;                      \
        }                                                       \
        (*PPAB)->pLana->AddressCount--;                         \
        ExFreePool( *PPAB );                                    \
        *PPAB = NULL;                                           \
    }                                                           \
}



//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
      #define try_return(S)  { S; goto try_exit; }

#define NETBIOS_STOPPING    1
#define NETBIOS_RUNNING     2;


#endif // def _NB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nbprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbprocs.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/


//
// address.c
//

NTSTATUS
NbSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    );

NTSTATUS
NbAddName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbDeleteName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbOpenAddress (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PUNICODE_STRING pusDeviceName,
    IN UCHAR LanNumber,
    IN PDNCB pdncb OPTIONAL
    );

PAB
NewAb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PDNCB pdncb
    );

VOID
CleanupAb(
    IN PPAB ppab,
    IN BOOLEAN CloseAddress
    );

VOID
NbAddressClose(
    IN HANDLE AddressHandle,
    IN PVOID Object
    );

PPAB
FindAb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IncrementUsers
    );

PPAB
FindAbUsingNum(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN UCHAR NameNumber
    );

BOOL
FindActiveSession(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    );

VOID
CloseListens(
    IN PFCB pfcb,
    IN PPAB ppab
    );

NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    );

//
// connect.c
//

NTSTATUS
NbCall(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbCallCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbListen(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbListenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbAcceptCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PPCB
NbCallCommon(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbHangup(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbOpenConnection (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PFCB pfcb,
    IN PVOID ConnectionContext,
    IN PDNCB pdncb
    );

PPCB
NewCb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    );

NTSTATUS
CleanupCb(
    IN PPCB ppcb,
    IN PDNCB pdncb OPTIONAL
    );

VOID
AbandonConnection(
    IN PPCB ppcb
    );

VOID
CloseConnection(
    IN PPCB ppcb,
    IN DWORD dwTimeOutinMS
    );

PPCB
FindCb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IgnoreState
    );

NTSTATUS
NbTdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators
    );

PPCB
FindCallCb(
    IN PFCB pfcb,
    IN PNCB pncb,
    IN UCHAR ucLana
    );

PPCB
FindReceiveIndicated(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    );

#if DBG

//
// debug.c
//

VOID
NbDisplayNcb(
    IN PDNCB pdncb
    );

VOID
NbFormattedDump(
    PCHAR far_p,
    LONG  len
    );

#endif

//
// devobj.c
//

NTSTATUS
NbCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext,
    IN PUNICODE_STRING RegistryPath
    );

//
// error.c
//

unsigned char
NbMakeNbError(
    IN NTSTATUS Error
    );

NTSTATUS
NbLanStatusAlert(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CancelLanAlert(
    IN PFCB pfcb,
    IN PDNCB pdncb
    );

NTSTATUS
NbTdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    );

//
// file.c
//

NTSTATUS
NewFcb(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CleanupFcb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB pfcb
    );

VOID
OpenLana(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CleanupLana(
    IN PFCB pfcb,
    IN ULONG lana_index,
    IN BOOLEAN delete
    );


VOID
NbBindHandler(
    IN      TDI_PNP_OPCODE      PnpOpcode,
    IN      PUNICODE_STRING     DeviceName,
    IN      PWSTR               MultiSzBindList
	);
	
NTSTATUS
NbPowerHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PNET_PNP_EVENT      pnpeEvent,
    IN      PTDI_PNP_CONTEXT    ptpcContext1,
    IN      PTDI_PNP_CONTEXT    ptpcContext2
);


VOID
NbTdiBindHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PWSTR               pwszMultiSZBindList
    );
    
VOID
NbTdiUnbindHandler(
    IN      PUNICODE_STRING     pusDeviceName
    );


//
// nb.c
//

NTSTATUS
NbCompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbCompletionPDNCB(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbClose(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
NbDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NbDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbOpen(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
QueueRequest(
    IN PLIST_ENTRY List,
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PFCB pfcb,
    IN KIRQL OldIrql,
    IN BOOLEAN Head);

PDNCB
DequeueRequest(
    IN PLIST_ENTRY List
    );

NTSTATUS
AllocateAndCopyUnicodeString(
    IN  OUT PUNICODE_STRING     pusDest,
    IN      PUNICODE_STRING     pusSource
);


//
// receive.c
//

NTSTATUS
NbReceive(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length,
    IN BOOLEAN Locked,
    IN KIRQL LockedIrql
    );

NTSTATUS
NbReceiveAny(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbTdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

PIRP
BuildReceiveIrp (
    IN PCB pcb
    );

NTSTATUS
NbReceiveDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbTdiDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
//  registry.c
//

CCHAR
GetIrpStackSize(
    IN PUNICODE_STRING RegistryPath,
    IN CCHAR DefaultValue
    );

NTSTATUS
ReadRegistry(
    IN PUNICODE_STRING pucRegistryPath,
    IN PFCB NewFcb,
    IN BOOLEAN bCreateDevice
    );

NTSTATUS
GetLanaMap(
    IN      PUNICODE_STRING                 pusRegistryPath,
    IN  OUT PKEY_VALUE_FULL_INFORMATION *   ppkvfi
    );
    
NTSTATUS
GetMaxLana(
    IN      PUNICODE_STRING     pusRegistryPath,
    IN  OUT PULONG              pulMaxLana
    );

VOID
NbFreeRegistryInfo (
    IN PFCB pfcb
    );

BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    );

//
// send.c
//

NTSTATUS
NbSend(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbSendDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

//
// timer.c
//

VOID
NbStartTimer(
    IN PFCB pfcb
    );

VOID
NbTimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NbTimer(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    ) ;

#if defined(_WIN64)

//
// nb32.c
//
NTSTATUS
NbThunkNcb(
    IN PNCB32 Ncb32,
    OUT PDNCB Dncb);

NTSTATUS
NbCompleteIrp32(
    IN OUT PIRP Irp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nbtypes.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbtypes.h

Abstract:

    This module defines private data structures and types for the NT
    Netbios provider.

Author:

    Colin Watson (ColinW) 15-Mar-1991

Revision History:

--*/

#ifndef _NBTYPES_
#define _NBTYPES_

//
// Retrospective patches to netbios
//

//
// These function prototypes are declared here since they are present only
// "ntddk.h" but not in "ntifs.h", but Ke*tachProcess functions are declared only
// in "ntifs.h" and not in "ntddk.h".  The only way to get both seems to be
// this hack.  Appreciate any input on how to do this w/o re-declaring these
// functions here.
//

#ifndef _IO_

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );

#endif


//
// This structure defines a NETBIOS name as a character array for use when
// passing preformatted NETBIOS names between internal routines.  It is
// not a part of the external interface to the transport provider.
//

#define NETBIOS_NAME_SIZE 16

typedef struct _NAME {
    UCHAR InternalName[NETBIOS_NAME_SIZE];
} NAME, *PNAME;

//
// Drivers Network Control Block.
//  The NCB provided by the dll is copied into a DNCB structure. When the
//  NCB is completed, then the contents up to and including ncb_cmd_cplt
//  are copied back into the NCB provided by the application.
//

typedef struct _DNCB {

    //
    //  First part of the DNCB is identical to the Netbios 3.0 NCB without
    //  the reserved fields.
    //

    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (*ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */

    //  Start of variables that are private to the Netbios driver

    LIST_ENTRY ncb_next;            /* receive and send chain from CB */
    PIRP    irp;                    /* Irp used to provide NCB to the */
                                    /* driver                         */
    PNCB    users_ncb;              /* Users Virtual address          */
    struct _FCB* pfcb;              /* Send and Receive NCB's only    */

    UCHAR   tick_count;             /* used for ncb_rto/sto processing*/

    //  The following data structures are used for datagrams.
    TDI_CONNECTION_INFORMATION Information;
    TDI_CONNECTION_INFORMATION ReturnInformation; /* Who sent it?     */
    TA_NETBIOS_ADDRESS RemoteAddress;
    ULONG Wow64Flags;               /* Flags used to indeify whether this
                                       structure has been thunked if it
                                       came from 32-bit land */

} DNCB, *PDNCB;

#if defined(_WIN64)

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block. This is the same structure element-layout
 * as the one issued from 32-bit application.
 */
typedef struct _NCB32 {

    //
    //  First part of the DNCB is identical to the Netbios 3.0 NCB without
    //  the reserved fields.
    //

    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    UCHAR * POINTER_32  ncb_buffer; /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (* POINTER_32 ncb_post)( struct _NCB * ); /* POST routine address*/
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */

    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    
    void * POINTER_32 ncb_event;    /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */

} NCB32, *PNCB32;

#endif

//
//  The following structure overlays ncb_callname when ncb_command is ncb_reset
//

typedef struct _RESET_PARAMETERS {
    UCHAR sessions;
    UCHAR commands;
    UCHAR names;
    UCHAR name0_reserved;
    UCHAR pad[4];
    UCHAR load_sessions;
    UCHAR load_commands;
    UCHAR load_names;
    UCHAR load_stations;
    UCHAR pad1[2];
    UCHAR load_remote_names;
    UCHAR pad2;
} RESET_PARAMETERS, *PRESET_PARAMETERS;

//
//  Address Block
//  pointed to by the Fcb for this application. One per name added due
//  to an AddName or AddGroupName
//

//  values for State field in the AB structure.

#define AB_UNIQUE  0
#define AB_GROUP   1

typedef struct _AB {
    ULONG Signature;

    //  Data items used to access transport when name was added
    HANDLE AddressHandle;
    PFILE_OBJECT AddressObject;         //  Pointer used in transport calls
    PDEVICE_OBJECT DeviceObject;        //  Pointer used in transport calls

    //  Data items used by the application to identify this Ab.
    UCHAR NameNumber;                   //  Index into AddressBlocks;
    UCHAR Status;
    UCHAR NameLength;                   //  Used when Name is for Broadcasts.
    NAME Name;                          //  our blank-padded netname
    ULONG CurrentUsers;                 //  1 for addname + n listens + m calls
    BOOL ReceiveDatagramRegistered;
    struct _LANA_INFO * pLana;
    LIST_ENTRY ReceiveAnyList;
    LIST_ENTRY ReceiveDatagramList;
    LIST_ENTRY ReceiveBroadcastDatagramList;

} AB, *PAB, **PPAB;

//
//  Connection Block
//  pointed to by the Fcb for this application. One per open connection
//  or listen.
//

typedef struct _CB {
    ULONG Signature;
    //  Data items used to access transport

    PPAB ppab;                          //  Associated address block
    HANDLE ConnectionHandle;
    PFILE_OBJECT ConnectionObject;      //  Pointer used in transport calls
    PDEVICE_OBJECT DeviceObject;        //  Pointer used in transport calls

    //  Structures used to process NCB's

    int ReceiveIndicated;
    BOOLEAN DisconnectReported;
    LIST_ENTRY ReceiveList;
    LIST_ENTRY SendList;
    NAME RemoteName;
    struct _LANA_INFO* Adapter;
    UCHAR SessionNumber;                //  Index into ConnectionBlocks;
    UCHAR Status;
    UCHAR ReceiveTimeout;               //  0 = no timeout, units=500ms
    UCHAR SendTimeout;                  //  0 = no timeout, units=500ms
    PNCB  UsersNcb;                     //  Users Virtual address used for
                                        //  the Listen or Call NCB.
    PDNCB pdncbCall;                    //  the Listen or Call DNCB.
    PDNCB pdncbHangup;

    struct _LANA_INFO * pLana;
} CB, *PCB, **PPCB;

//  Per network adapter information is held in the LAN Adapter structure

typedef struct _LANA_INFO {
    ULONG Signature;
    ULONG Status;
    PCB ConnectionBlocks[MAXIMUM_CONNECTION+1];
    PAB AddressBlocks[MAXIMUM_ADDRESS+1];   // Last entry is for broadcast name
    LIST_ENTRY LanAlertList;                // list of Alert PDNCBs

    HANDLE ControlChannel;
    PFILE_OBJECT ControlFileObject;
    PDEVICE_OBJECT ControlDeviceObject;

    //
    //  Addresses are allocated modulo 253. NextAddress is the next address to start
    //  looking for an unused name number. AddressCount is the number of names in use.
    //  MaximumAddress is tha limit set when the adapter was reset.
    //

    int NextAddress;
    int AddressCount;
    int MaximumAddresses;

    //
    //  Connections are allocated modulo 254. NextConnection is the next LSN to start
    //  looking for an unused number. ConnectionCount is the number of LSNs in use.
    //  MaximumConnection is tha limit set when the adapter was reset.
    //

    int NextConnection;
    int ConnectionCount;
    int MaximumConnection;

    struct _FCB* pFcb;

} LANA_INFO, *PLANA_INFO;


typedef struct _DEVICE_CONTEXT {
    DEVICE_OBJECT DeviceObject;         //  The IO systems device object.
    BOOLEAN Initialized;                //  TRUE iff NB init succeeded.
    UNICODE_STRING RegistryPath;        //  Netbios node in registry.
} DEVICE_CONTEXT, *PDEVICE_CONTEXT;


//
//  File Control Block
//  pointed to by FsContext2 in the FileObject associated with the
//  applications handle. LANA_INFO structures will be created as the
//  application supplies different ncb_lana numbers in NCBs. Initially
//  they are all NULL.
//

typedef struct _FCB {
    ULONG Signature;
    ERESOURCE Resource;                 //  Prevents two requests from
                                        //  corrupting the drivers data
                                        //  structures.
    KSPIN_LOCK SpinLock;                //  locks out indication routines.
    ERESOURCE AddResource;              //  Prevents a reset while an addname
                                        //  is in progress. Always acquire
                                        //  AddResource before Resource.
    ULONG MaxLana;
    PLANA_INFO *ppLana;
    LANA_ENUM LanaEnum;                 //  Win32 Netbios 3.0 structure.
    PUNICODE_STRING pDriverName;        // Device\Nbf\Elnkii1 etc
    PUCHAR RegistrySpace;               //  Registry.c workspace

    //  Timer related datastructures.

    PKEVENT TimerCancelled;             //  Used when exiting the driver.
    BOOLEAN TimerRunning;
    KTIMER Timer;                       // kernel timer for this request.
    KDPC Dpc;                           // DPC object for timeouts.

    PIO_WORKITEM WorkEntry;             // used for timeouts.

} FCB, *PFCB;


typedef struct _TA_ADDRESS_NETONE {
    int TAAddressCount;
    struct _NetoneAddr {
        USHORT AddressLength;       // length in bytes of this address == 22
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_NETONE
        TDI_ADDRESS_NETONE Address[1];
    } Address [1];
} TA_NETONE_ADDRESS, *PTA_NETONE_ADDRESS;

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;


//
// structure of each element in global list of FCBs
//

#if AUTO_RESET

typedef struct _FCB_ENTRY {
    LIST_ENTRY          leList;
    LIST_ENTRY          leResetList;
    PFCB                pfcb;
    PEPROCESS           peProcess;
    LIST_ENTRY          leResetIrp;

} FCB_ENTRY, *PFCB_ENTRY;


//
// structure with LANA number to be reset
//

typedef struct _RESET_LANA_ENTRY {
    LIST_ENTRY          leList;
    UCHAR               ucLanaNum;
} RESET_LANA_ENTRY, *PRESET_LANA_ENTRY;

#else

typedef struct _FCB_ENTRY {
    LIST_ENTRY          leList;
    PFCB                pfcb;
    PEPROCESS           peProcess;

} FCB_ENTRY, *PFCB_ENTRY;

#endif

#endif // def _NBTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\receive.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains code which processes all read NCB's including
    both session and datagram based transfers.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

PDNCB
FindReceive (
    IN PCB pcb
    );

VOID
ReturnDatagram(
    IN PAB pab,
    IN PVOID SourceAddress,
    IN PDNCB pdncb,
    IN BOOL MultipleReceive
    );

NTSTATUS
NbCompletionBroadcast(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbReceive(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length,
    IN BOOLEAN Locked,
    IN KIRQL LockedIrql
    )
/*++

Routine Description:

    This routine is called to read a buffer of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

    Locked - TRUE if the spinlock is already held.

    LockedIrql - OldIrql if Locked == TRUE.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    if ( Locked != TRUE ) {
        LOCK( pfcb, OldIrql );
    } else {
        OldIrql = LockedIrql;
    }

    ppcb = FindCb( pfcb, pdncb, FALSE);

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    if ( ppcb == NULL ) {
        //  FindCb has put the error in the NCB

        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive on invalid connection\n" ));
        }

        if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
            //  Tell dll to hangup the connection.
            return STATUS_HANGUP_REQUIRED;
        } else {
            return STATUS_SUCCESS;
        }
    }
    pcb = *ppcb;
    pdncb->tick_count = pcb->ReceiveTimeout;

    if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {

        UNLOCK( pfcb, OldIrql );

        NCB_COMPLETE( pdncb, NRC_SCLOSED );
        return STATUS_SUCCESS;
    }

    if ( pcb->ReceiveIndicated == 0 ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive, queue receive pcb: %lx, pdncb: %lx\n", pcb, pdncb ));
        }

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&pcb->ReceiveList, pdncb, Irp, pfcb, OldIrql, FALSE);

    } else {
        PDEVICE_OBJECT DeviceObject;

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive, submit receive pcb: %lx, pdncb: %lx\n", pcb, pdncb ));
        }

        IoMarkIrpPending( Irp );

        pcb->ReceiveIndicated = 0;

        TdiBuildReceive (Irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress,
            0,
            Buffer2Length);

        //  Save the DeviceObject before pcb gets released by UNLOCK

        DeviceObject = pcb->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoCallDriver (DeviceObject, Irp);

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //
    }

    Status = STATUS_PENDING;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive: %X, %X\n", Status, Irp->IoStatus.Status ));
    }

    return Status;
    UNREFERENCED_PARAMETER( Buffer2Length );
}

NTSTATUS
NbReceiveAny(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to read a buffer of data from any session on
    a particular address, provided there is not a read on that address
    already.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPCB ppcb;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num );

    if ( ppab == NULL ) {
        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive any on invalid connection\n" ));
        }
        return STATUS_SUCCESS;
    }

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    //
    //  If there is already a receive any on the address block then add
    //  this request to the tail of the queue. If the list is empty then
    //  look for a connection on this address flagged as having a receive
    //  indicated. Either queue the request if there are no indications or
    //  satisfy the indicated receive any with this request.
    //

    if ( !IsListEmpty( &(*ppab)->ReceiveAnyList )) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive any with receive any list non empty\n" ));
            ppcb = FindReceiveIndicated( pfcb, pdncb, ppab );
            if ( ppcb != NULL ) {
                NbPrint(( " ppcb: %lx has a receive indicated( %lx )!\n",
                    ppcb,
                    (*ppcb)->ReceiveIndicated));
                ASSERT( FALSE );
            }
        }

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&(*ppab)->ReceiveAnyList, pdncb, Irp, pfcb, OldIrql, FALSE);

        return STATUS_PENDING;
    }

    //
    //  Find either a connection with a receive indicated or one that has been
    //  disconnected but not reported yet.
    //

    ppcb = FindReceiveIndicated( pfcb, pdncb, ppab );

    if ( ppcb == NULL ) {
        //  No connections with receive indications set.

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&(*ppab)->ReceiveAnyList, pdncb, Irp, pfcb, OldIrql, FALSE);

        return STATUS_PENDING;
    } else {
        //  FindReceiveIndicated has set the LSN appropriately in the NCB

        //  Note : NbReceive will unlock the spinlock & resource
        return NbReceive( pdncb, Irp, IrpSp, Buffer2Length, TRUE, OldIrql );

    }
}

NTSTATUS
NbTdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an NCB arrives from the network, it will look for a
    connection for this address with an appropriate read outstanding.
    The connection that has the read associated with it is indicated by the
    context parameter.

    If it finds an appropriate read it processes the NCB.

Arguments:

    IN PVOID ReceiveEventContext - Context provided for this event - pab
    IN PVOID ConnectionContext  - Connection Context - pcb
    IN USHORT ReceiveFlags      - Flags describing the message
    IN ULONG BytesIndicated     - Number of bytes available at indication time
    IN ULONG BytesAvailable     - Number of bytes available to receive
    OUT PULONG BytesTaken       - Number of bytes consumed by redirector.
    IN PVOID Tsdu               - Data from remote machine.
    OUT PIRP *IoRequestPacket   - I/O request packet filled in if received data


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PCB pcb = *(PPCB)ConnectionContext;
    PAB pab = *(pcb->ppab);
    PFCB pfcb = pab->pLana->pFcb;
    PDNCB pdncb;

    *IoRequestPacket = NULL;

    LOCK_SPINLOCK( pfcb, OldIrql );

    if (( pcb == NULL ) ||
        ( pcb->Status != SESSION_ESTABLISHED )) {

        //
        //  The receive indication came in after we had an
        //  allocation error on the Irp to be used for orderly disconnect.
        //  If the Irp allocation fails then we should ignore receives
        //  since we are in the process of putting down a ZwClose on this
        //  connection.
        //

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_DATA_NOT_ACCEPTED;
    }


    pdncb = FindReceive( pcb );

    if ( pdncb == NULL ) {

        pcb->ReceiveIndicated = 1;

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_DATA_NOT_ACCEPTED;
    }

    pcb->ReceiveIndicated = 0;

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    //
    //  If this is the simple case where all the data required has been
    //  indicated and it all fits in the buffer then copy the packet
    //  contents directly into the users buffer rather than returning the
    //  Irp. This should always be faster than returning an Irp to the
    //  transport.
    //

    if (( BytesAvailable <= pdncb->ncb_length ) &&
        ( BytesAvailable == BytesIndicated ) &&
        ( ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE )) {

        PIRP Irp = pdncb->irp;

        if ( BytesAvailable != 0 ) {

            PUCHAR UsersBuffer = MmGetSystemAddressForMdlSafe(
                                    Irp->MdlAddress, NormalPagePriority);

            if (UsersBuffer == NULL) {
                pcb->ReceiveIndicated = 1;

                return STATUS_DATA_NOT_ACCEPTED;
            }
            
            TdiCopyLookaheadData(
                UsersBuffer,
                Tsdu,
                BytesAvailable,
                ReceiveFlags);
        }

        *BytesTaken = BytesAvailable;

        pdncb->ncb_length = (WORD)BytesAvailable;

        NCB_COMPLETE( pdncb, NRC_GOODRET );

        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        NbCompleteRequest(Irp,STATUS_SUCCESS);

        return STATUS_SUCCESS;

    } else {

        TdiBuildReceive (pdncb->irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            pdncb->irp->MdlAddress,
            0,
            pdncb->ncb_length);

        IoSetNextIrpStackLocation( pdncb->irp );

        *IoRequestPacket = pdncb->irp;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    UNREFERENCED_PARAMETER( ReceiveEventContext );
    UNREFERENCED_PARAMETER( Tsdu );
}

PIRP
BuildReceiveIrp (
    IN PCB pcb
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an NCB arrives from the network and also when
    a receive completes with STATUS_BUFFER_OVERFLOW.

    If no Irp is available then this routine sets ReceiveIndicated so
    that the next appropriate receive will be passed to the transport.

Arguments:

    IN PCB pcb - Supplies the connection which should put a receive Irp
                down if it has one available.

Return Value:

    PDNCB to be satisfied by this receive request

--*/
{
    PDNCB pdncb = FindReceive( pcb );

    if ( pdncb == NULL ) {

        pcb->ReceiveIndicated = 1;

        return NULL;
    }

    TdiBuildReceive (pdncb->irp,
        pcb->DeviceObject,
        pcb->ConnectionObject,
        NbCompletionPDNCB,
        pdncb,
        pdncb->irp->MdlAddress,
        0,
        pdncb->ncb_length);

    pcb->ReceiveIndicated = 0;

    return pdncb->irp;
}

PDNCB
FindReceive (
    IN PCB pcb
    )
/*++

Routine Description:

    It is called when an NCB arrives from the network and also when
    a receive completes with STATUS_BUFFER_OVERFLOW.

Arguments:

    IN PCB pcb - Supplies the connection which should put a receive Irp
                down if it has one available.

Return Value:

    PDNCB to be satisfied by this receive request

--*/

{
    PAB pab;
    PFCB pfcb;
    PDNCB pdncb;

    pab = *(pcb->ppab);
    pfcb = pab->pLana->pFcb;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "NB receive handler pcb: %lx\n", pcb ));
    }

    ASSERT( pcb->Signature == CB_SIGNATURE );

    //
    //  If there is a receive in the list then hand over the data.
    //


    if ( (pdncb = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receive handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        return pdncb;
    }

    //
    //  No receives on this connection. Is there a receive any for this
    //  address?
    //

    ASSERT( pab != NULL );

    if ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receiveANY handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        pdncb->ncb_num = pab->NameNumber;
        pdncb->ncb_lsn = pcb->SessionNumber;

        return pdncb;
    }

    //
    //  No receives on this connection. Is there a receive any for any
    //  address on this adapter?
    //

    pab = pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];

    ASSERT( pab != NULL );

    if ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receiveANYANY handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        pdncb->ncb_num = pab->NameNumber;
        pdncb->ncb_lsn = pcb->SessionNumber;

        return pdncb;
    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the data yet.
    //

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive handler ignored receive, pcb: %lx\n", pcb ));
    }

    return NULL;
}

NTSTATUS
NbReceiveDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to read a buffer of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    NTSTATUS Status;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num  );

    if ( ppab == NULL ) {
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }

    //  Build the ReceiveInformation datastructure in the DNCB.


    if ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECVBC ) {
        //
        //  Receive broadcast commands can be requested on any valid
        //  name number but once accepted, they are treated seperately
        //  from the name. To implement this, the driver queues the
        //  receives on address 255.
        //

        ppab = FindAbUsingNum( pfcb, pdncb, MAXIMUM_ADDRESS  );

        if ((ppab == NULL) || (pdncb->ncb_num == MAXIMUM_ADDRESS) ) {

            NCB_COMPLETE( pdncb, NRC_ILLNN );
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB Bdatagram receive, queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                ppab, (*ppab), pdncb ));
        }

        if ( (*ppab)->ReceiveDatagramRegistered == FALSE) {

            (*ppab)->ReceiveDatagramRegistered = TRUE;
            UNLOCK_SPINLOCK( pfcb, OldIrql);

            Status = NbSetEventHandler( (*ppab)->DeviceObject,
                                        (*ppab)->AddressObject,
                                        TDI_EVENT_RECEIVE_DATAGRAM,
                                        (PVOID)NbTdiDatagramHandler,
                                        (*ppab));

            if (Status != STATUS_SUCCESS)
			{
				return(Status);
			}

            LOCK_SPINLOCK( pfcb, OldIrql);
        }

        //
        //  When one receive broadcast is received, we must satisfy all the receive
        //  broadcasts. To do this, the largest receive is placed at the head of the queue.
        //  When a datagram is received, this receive is given to the transport to fill in
        //  with data. In the completion routine this driver propogates the same data to
        //  the other receive datagram requests.
        //

        IoMarkIrpPending( Irp );

        if ( !IsListEmpty( &(*ppab)->ReceiveBroadcastDatagramList) ) {
            PDNCB pdncbHead = CONTAINING_RECORD( &(*ppab)->ReceiveBroadcastDatagramList.Flink , DNCB, ncb_next);
            if ( pdncb->ncb_length >= pdncbHead->ncb_length ) {
                IF_NBDBG (NB_DEBUG_RECEIVE) {
                    NbPrint(( "\n  NB Bdatagram receive, Head of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                        ppab, (*ppab), pdncb ));
                }
                //  Note: QueueRequest UNLOCKS the fcb.
                QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, TRUE);
            } else {
                IF_NBDBG (NB_DEBUG_RECEIVE) {
                    NbPrint(( "\n  NB Bdatagram receive, Tail of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                        ppab, (*ppab), pdncb ));
                }
                QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
            }

        } else {
            IF_NBDBG (NB_DEBUG_RECEIVE) {
                NbPrint(( "\n  NB Bdatagram receive, Tail2 of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                    ppab, (*ppab), pdncb ));
            }
            QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
        }

    } else {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB datagram receive, queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                ppab, (*ppab), pdncb ));
        }

        QueueRequest(&(*ppab)->ReceiveDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
    }

    Status = STATUS_PENDING;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB datagram receive: %X, %X\n", Status, Irp->IoStatus.Status ));
    }

    return Status;
    UNREFERENCED_PARAMETER( Buffer2Length );
}

NTSTATUS
NbTdiDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an NCB arrives from the network, it will look for a
    the address with an appropriate read datagram outstanding.
    The address that has the read associated with it is indicated by the
    context parameter.

    If it finds an appropriate read it processes the NCB.

Arguments:

    IN PVOID TdiEventContext - Context provided for this event - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket       // TdiReceive IRP if MORE_PROCESSING_REQUIRED.


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    PAB pab = (PAB)TdiEventContext;
    PAB pab255;

    PDNCB pdncb;
    PFCB pfcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    pfcb = pab->pLana->pFcb;
    LOCK_SPINLOCK( pfcb, OldIrql );

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "NB receive datagram handler pfcb: %lx, pab: %lx\n", pfcb, pab ));
    }

    *IoRequestPacket = NULL;

    ASSERT( pab->Signature == AB_SIGNATURE );

    //  If its address 255 then we are receiving a broadcast datagram.

    if ( pab->NameNumber == MAXIMUM_ADDRESS ) {

        if ( (pdncb = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {

            ReturnDatagram(
                pab,
                SourceAddress,
                pdncb,
                !IsListEmpty( &pab->ReceiveBroadcastDatagramList));

            *IoRequestPacket = pdncb->irp;

            IoSetNextIrpStackLocation( pdncb->irp );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return STATUS_MORE_PROCESSING_REQUIRED;

        }

        //
        //  Transport will complete the processing of the request, we don't
        //  want the datagram.
        //

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receive BD handler ignored receive, pab: %lx\n", pab ));
        }

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    //  Check the address block looking for a Receive Datagram.
    //

    if ( (pdncb = DequeueRequest( &pab->ReceiveDatagramList)) != NULL ) {

        ReturnDatagram(
            pab,
            SourceAddress,
            pdncb,
            FALSE);

        *IoRequestPacket = pdncb->irp;

        IoSetNextIrpStackLocation( pdncb->irp );

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    //  Check to see if there is a receive any datagram.
    //

    //  look at the list on address 255.

    pab255 = pab->pLana->AddressBlocks[MAXIMUM_ADDRESS];

    if ( (pdncb = DequeueRequest( &pab255->ReceiveDatagramList)) != NULL ) {

        ReturnDatagram(
            pab255,
            SourceAddress,
            pdncb,
            FALSE);

        pdncb->ncb_num = pab->NameNumber;

        *IoRequestPacket = pdncb->irp;

        IoSetNextIrpStackLocation( pdncb->irp );

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive datagram handler ignored receive, pab: %lx\n", pab ));
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    return STATUS_DATA_NOT_ACCEPTED;

    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( BytesTaken );
    UNREFERENCED_PARAMETER( Tsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( ReceiveDatagramFlags );
}


VOID
ReturnDatagram(
    IN PAB pab,
    IN PVOID SourceAddress,
    IN PDNCB pdncb,
    IN BOOL MultipleReceive
    )
/*++

Routine Description:

    This routine is used to provide the Irp for a receive datagram to
    the transport.

Arguments:

    IN PAB pab  -   Supplies the address block associated with the NCB.
    IN PVOID SourceAddress - Supplies the sender of the datagram.
    IN PDNCB pdncb  -   Supplies the NCB to be satisfied.
    IN BOOL MultipleReceive - True if the special Receive Broadcast datagram completion
                handler is to be used.

Return Value:

    none.

--*/

{
    PIRP Irp = pdncb->irp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB BDatagramreceive handler pab: %lx, ncb: %lx\n",
            pab, pdncb ));
    }

    //  Copy the name into the NCB for return to the application.
    RtlMoveMemory(
        pdncb->ncb_callname,
        ((PTA_NETBIOS_ADDRESS)SourceAddress)->Address[0].Address[0].NetbiosName,
        NCBNAMSZ
        );

    //  Tell TDI we do not want to specify any filters.
    pdncb->Information.RemoteAddress = 0;
    pdncb->Information.RemoteAddressLength = 0;
    pdncb->Information.UserData = NULL;
    pdncb->Information.UserDataLength = 0;
    pdncb->Information.Options = NULL;
    pdncb->Information.OptionsLength = 0;

    //  Tell TDI we do not want any more information on the remote name.
    pdncb->ReturnInformation.RemoteAddress = 0;
    pdncb->ReturnInformation.RemoteAddressLength = 0;
    pdncb->ReturnInformation.UserData = NULL;
    pdncb->ReturnInformation.UserDataLength = 0;
    pdncb->ReturnInformation.Options = NULL;
    pdncb->ReturnInformation.OptionsLength = 0;

    CompletionRoutine = ( MultipleReceive == FALSE ) ? NbCompletionPDNCB: NbCompletionBroadcast;

    ASSERT(Irp->MdlAddress != NULL);

    TdiBuildReceiveDatagram (Irp,
        pab->DeviceObject,
        pab->AddressObject,
        CompletionRoutine,
        pdncb,
        Irp->MdlAddress,
        pdncb->ncb_length,
        &pdncb->Information,
        &pdncb->ReturnInformation,
        0);

    return;
}


NTSTATUS
NbCompletionBroadcast(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine takes the completed datagram receive and copies the data in the buffer
    to all the other receive broadcast datagram requests.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PUCHAR pData;
    UCHAR NcbStatus;
    PAB pab;
    PDNCB pdncbNext;

    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("NbCompletionBroadcast pdncb: %lx, Status: %X, Length %lx\n",
            Context,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information ));
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {
        NcbStatus = NRC_GOODRET;
    } else {
        NcbStatus = NbMakeNbError( Irp->IoStatus.Status );
    }

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

    pData = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);

    if (pData != NULL) {
    
        LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

        pab = *(FindAbUsingNum( pdncb->pfcb, pdncb, MAXIMUM_ADDRESS ));

        //
        //  For each request on the queue, copy the data, update the NCb and complete the IRP.
        //

        while ( (pdncbNext = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {
            PUCHAR pNextData;
            WORD Length;

            IF_NBDBG (NB_DEBUG_COMPLETE) {
                NbPrint( ("NbCompletionBroadcast pdncb: %lx, Length %lx\n",
                    pdncbNext,
                    Irp->IoStatus.Information ));
            }

            ASSERT(pdncbNext->irp->MdlAddress != NULL);

            if (pdncbNext->irp->MdlAddress != NULL ) {
                pNextData = MmGetSystemAddressForMdlSafe(
                                pdncbNext->irp->MdlAddress, NormalPagePriority
                                );
            }

            if ((pdncbNext->irp->MdlAddress == NULL) ||
                (pNextData == NULL)) {
                Length = 0;
            }

            else {
                Length = min( pdncb->ncb_length, pdncbNext->ncb_length);
                pdncbNext->ncb_length = Length;
                RtlMoveMemory( pNextData, pData, Length );
            }

            if (( Length != pdncb->ncb_length ) &&
                ( NcbStatus == NRC_GOODRET )) {
                if (Length == 0) {
                    NCB_COMPLETE( pdncbNext, NRC_NORES );
                }
                else {
                    NCB_COMPLETE( pdncbNext, NRC_INCOMP );
                }
            } else {
                NCB_COMPLETE( pdncbNext, NcbStatus );
            }
            pdncbNext->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest(pdncbNext->irp, STATUS_SUCCESS );

        }

        UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );
    }

    NCB_COMPLETE( pdncb, NcbStatus );
    
    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\nbconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbconst.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/


#ifndef _NBCONST_
#define _NBCONST_

//
// MAJOR PROTOCOL IDENTIFIERS THAT CHARACTERIZE THIS DRIVER.
//

#define MAXIMUM_LANA                254
#define MAXIMUM_CONNECTION          254
#define MAXIMUM_ADDRESS             255

//
//  Default number of I/O stack locations in a Netbios Irp.  This value
//  is used if the Netbios\Parameters\IrpStackSize registry value is
//  missing.
//

#define NB_DEFAULT_IO_STACKSIZE     4

//
//  private ncb_command values used to add special names. Applications
//  cannot use these. Used in file.c and address.c
//

#define NCBADDRESERVED              0x7f
#define NCBADDBROADCAST             0x7e

//
//  Signature values for the major netbios driver structures.
//

#define NB_SIGNATURE_BASE           0xB1050000

#define AB_SIGNATURE                (NB_SIGNATURE_BASE + 0x000000ab)
#define CB_SIGNATURE                (NB_SIGNATURE_BASE + 0x000000cb)
#define FCB_SIGNATURE               (NB_SIGNATURE_BASE + 0x00000001)
#define LANA_INFO_SIGNATURE         (NB_SIGNATURE_BASE + 0x00000002)

//
//  PLANA status values
//

#define NB_INITIALIZING             0x00000001
#define NB_INITIALIZED              0x00000002
#define NB_DELETING                 0x00000003
#define NB_ABANDONED                0x00000004

//
// NT uses a system time measured in 100 nanosecnd intervals. define convenient
// constants for setting the timer.
//

#define MICROSECONDS                10
#define MILLISECONDS                10000                   // MICROSECONDS*1000
#define SECONDS                     10000000                // MILLISECONDS*1000

//
//  Names used for registry access
//

#define REGISTRY_LINKAGE            L"Linkage"
#define REGISTRY_PARAMETERS         L"Parameters"
#define REGISTRY_BIND               L"Bind"
#define REGISTRY_LANA_MAP           L"LanaMap"
#define REGISTRY_MAX_LANA           L"MaxLana"
#define REGISTRY_IRP_STACK_SIZE     L"IrpStackSize"


#define NETBIOS                     L"Netbios"

//
// prefix for NBF deive names
//

#define NBF_DEVICE_NAME_PREFIX      L"\\DEVICE\\NBF_"

#endif // _NBCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\send.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains code which processes all send NCB's including
    both session and datagram based transfers.

Author:

    Colin Watson (ColinW) 12-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

NTSTATUS
NbSend(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to send a buffer full of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE);

    if ( ppcb == NULL ) {
        //  FindCb has put the error in the NCB
        UNLOCK( pfcb, OldIrql );
        if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
            //  Tell dll to hangup the connection.
            return STATUS_HANGUP_REQUIRED;
        } else {
            return STATUS_SUCCESS;
        }
    }
    pcb = *ppcb;

    if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_SCLOSED );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    TdiBuildSend (Irp,
        pcb->DeviceObject,
        pcb->ConnectionObject,
        NbCompletionPDNCB,
        pdncb,
        Irp->MdlAddress,
        (((pdncb->ncb_command & ~ASYNCH) == NCBSENDNA ) ||
         ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSENDNA ))?
                TDI_SEND_NO_RESPONSE_EXPECTED : 0,
        Buffer2Length);

    DeviceObject = pcb->DeviceObject;

    InsertTailList(&pcb->SendList, &pdncb->ncb_next);
    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;
    pdncb->tick_count = pcb->SendTimeout;

    UNLOCK( pfcb, OldIrql );

    IoMarkIrpPending( Irp );
    IoCallDriver (DeviceObject, Irp);

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND submit: %X\n", Irp->IoStatus.Status  ));
    }

    //
    //  Transport will complete the request. Return pending so that
    //  netbios does not complete as well.
    //

    return STATUS_PENDING;

}

NTSTATUS
NbSendDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to SendDatagram a buffer full of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPAB ppab;
    PAB pab;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND Datagram submit, pdncb %lx\n", pdncb  ));
    }

    LOCK( pfcb, OldIrql );
    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num );

    if ( ppab == NULL ) {
        //  FindAb has put the error in the NCB
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }
    pab = *ppab;

    pdncb->Information.RemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);
    pdncb->Information.RemoteAddress = &pdncb->RemoteAddress;

    pdncb->RemoteAddress.TAAddressCount = 1;
    pdncb->RemoteAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pdncb->RemoteAddress.Address[0].Address[0].NetbiosNameType =
        TDI_ADDRESS_TYPE_NETBIOS;

    if ( (pdncb->ncb_command & ~ASYNCH) == NCBDGSENDBC ) {
        PPAB ppab255 = FindAbUsingNum( pfcb, pdncb, MAXIMUM_ADDRESS );

        if ( ppab255 == NULL ) {
            //  FindAb has put the error in the NCB
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }

        pdncb->RemoteAddress.Address[0].AddressLength = (*ppab255)->NameLength;

        RtlMoveMemory(
            pdncb->RemoteAddress.Address[0].Address[0].NetbiosName,
            &(*ppab255)->Name,
            (*ppab255)->NameLength
            );

    } else {

        pdncb->RemoteAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);

        RtlMoveMemory(
            pdncb->RemoteAddress.Address[0].Address[0].NetbiosName,
            pdncb->ncb_callname,
            NCBNAMSZ
            );
    }

    pdncb->Information.UserDataLength = 0;
    pdncb->Information.UserData = NULL;
    pdncb->Information.OptionsLength = 0;
    pdncb->Information.Options = NULL;

    TdiBuildSendDatagram (Irp,
        pab->DeviceObject,
        pab->AddressObject,
        NbCompletionPDNCB,
        pdncb,
        Irp->MdlAddress,
        Buffer2Length,
        &pdncb->Information);

    DeviceObject = pab->DeviceObject;
    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    UNLOCK( pfcb, OldIrql );

    IoMarkIrpPending( Irp );
    IoCallDriver (DeviceObject, Irp);

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND Datagram submit: %X\n", Irp->IoStatus.Status  ));
    }

    //
    //  Transport will complete the request. Return pending so that
    //  netbios does not complete as well.
    //

    return STATUS_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\registry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This contains all routines necessary to load the lana number to device pathname
    mapping and the Lana Enum record.

Author:

    Colin Watson (colinw) 14-Mar-1992

Revision History:


Notes:
    The fcb holds an area for registry workspace. this is where the strings
    used to hold the DriverNames will be held in a single allocation.

    build with -DUTILITY to run as a test application.
--*/

#include "Nb.h"
//#include <zwapi.h>
//#include <stdlib.h>
#include <crt\stdlib.h>


#define DEFAULT_VALUE_SIZE 4096

#define ROUNDUP_TO_LONG(x) (((x) + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1))

#ifdef UTILITY
#define ZwClose NtClose
#define ZwCreateKey NtCreateKey
#define ZwOpenKey NtOpenKey
#define ZwQueryValueKey NtQueryValueKey
#define ExFreePool free
#endif

//
// Local functions used to access the registry.
//

NTSTATUS
NbOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE LinkageHandle,
    OUT PHANDLE ParametersHandle
    );

VOID
NbCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    );

NTSTATUS
NbReadLinkageInformation(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle,
    IN PFCB pfcb,
    IN BOOL bDeviceCreate
    );

ULONG
NbReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    );


//
// Local function used to determine is specified device is Pnp enabled
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, GetIrpStackSize)
#pragma alloc_text(PAGE, ReadRegistry)
#pragma alloc_text(PAGE, NbFreeRegistryInfo)
#pragma alloc_text(PAGE, NbOpenRegistry)
#pragma alloc_text(PAGE, NbCloseRegistry)
#pragma alloc_text(PAGE, NbReadLinkageInformation)
#pragma alloc_text(PAGE, NbReadSingleParameter)
#pragma alloc_text(PAGE, NbCheckLana)
#endif

CCHAR
GetIrpStackSize(
    IN PUNICODE_STRING RegistryPath,
    IN CCHAR DefaultValue
    )
/*++

Routine Description:

    This routine is called by NbCreateDeviceContext to get the IRP
    stack size to be "exported" by the NetBIOS device.

Arguments:

    RegistryPath - The name of Nb's node in the registry.
    DefaultValue - IRP stack size to be used if no registry value present.

Return Value:

    CCHAR - IRP stack size to be stored in the device object.

--*/
{
    HANDLE LinkageHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    ULONG stackSize;

    PAGED_CODE();

    Status = NbOpenRegistry (RegistryPath, &LinkageHandle, &ParametersHandle);

    if (Status != STATUS_SUCCESS) {
        return DefaultValue;
    }

    //
    // Read the stack size value from the registry.
    //

    stackSize = NbReadSingleParameter(
                    ParametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    DefaultValue );

    if ( stackSize > 255 ) {
        stackSize = 255;
    }

    NbCloseRegistry (LinkageHandle, ParametersHandle);

    return (CCHAR)stackSize;

}

NTSTATUS
ReadRegistry(
    IN PUNICODE_STRING pusRegistryPath,
    IN PFCB NewFcb,
    IN BOOLEAN bDeviceCreate
    )
/*++

Routine Description:

    This routine is called by Nb to get information from the registry,
    starting at RegistryPath to get the parameters.

Arguments:

    DeviceContext - Supplies RegistryPath. The name of Nb's node in the registry.
    NewFcb - Destination for the configuration information.

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    HANDLE LinkageHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;

    PAGED_CODE();

    NewFcb->RegistrySpace = NULL; //  No registry workspace.
    NewFcb->LanaEnum.length = 0;


    Status = NbOpenRegistry ( pusRegistryPath, &LinkageHandle, &ParametersHandle);

    if (Status != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Read in the NDIS binding information (if none is present
    // the array will be filled with all known drivers).
    //

    Status = NbReadLinkageInformation (
                LinkageHandle,
                ParametersHandle,
                NewFcb,
                bDeviceCreate);

    NbCloseRegistry (LinkageHandle, ParametersHandle);

    return Status;

}


//----------------------------------------------------------------------------
// GetLanaMap
//
// retrieves the lana map structure.
// Allocates the memory required for the lana map structure that must be 
// deallocated after use.
//----------------------------------------------------------------------------

NTSTATUS
GetLanaMap(
    IN      PUNICODE_STRING                     pusRegistryPath,
    IN  OUT PKEY_VALUE_FULL_INFORMATION *       ppkvfi
    )
{
    HANDLE hLinkage = NULL;
    HANDLE hParameters = NULL;
    NTSTATUS nsStatus;

    PKEY_VALUE_FULL_INFORMATION pkvfiValue = NULL;
    ULONG ulValueSize;

    PWSTR wsLanaMapName = REGISTRY_LANA_MAP;
    UNICODE_STRING usLanaMap;

    ULONG ulBytesWritten;



    PAGED_CODE();


    do
    {
        *ppkvfi = NULL;

        
        //
        // open registry keys
        //
        
        nsStatus = NbOpenRegistry ( pusRegistryPath, &hLinkage, &hParameters );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            break;
        }

        
        //
        // allocate for lana map.
        //
        
        pkvfiValue = ExAllocatePoolWithTag( 
                        PagedPool, MAXIMUM_LANA * sizeof( LANA_MAP ), 'rSBN' 
                        );

        if ( pkvfiValue == NULL )
        {
            nsStatus = STATUS_UNSUCCESSFUL;
            NbPrint( (
                "GetLanaMap : Allocation failed for %d bytes\n", DEFAULT_VALUE_SIZE
                 ) );
            break;
        }

        ulValueSize = MAXIMUM_LANA * sizeof( LANA_MAP );

        
        //
        // query "LanaMap" value
        //

        RtlInitUnicodeString (&usLanaMap, wsLanaMapName);

        nsStatus = ZwQueryValueKey(
                             hLinkage,
                             &usLanaMap,
                             KeyValueFullInformation,
                             pkvfiValue,
                             ulValueSize,
                             &ulBytesWritten
                             );

        if (!NT_SUCCESS(nsStatus)) 
        {
            NbPrint ( (
                "GetLanaMap : failed querying lana map key %x", nsStatus 
                ) );
            break;
        }

        if ( ulBytesWritten == 0 ) 
        {
            nsStatus = STATUS_UNSUCCESSFUL;
            NbPrint ( ("GetLanaMap : querying lana map key returned 0 bytes") );
            break;
        }


        *ppkvfi = pkvfiValue;

        NbCloseRegistry (hLinkage, hParameters);

        return nsStatus;
        
    } while (FALSE);


    if ( pkvfiValue != NULL )
    {
        ExFreePool( pkvfiValue );
    }
    
    NbCloseRegistry (hLinkage, hParameters);
    
    return nsStatus;
}

//----------------------------------------------------------------------------
// GetMaxLana
//
// retrieves the MaxLana value from the netbios parameters key.
//----------------------------------------------------------------------------

NTSTATUS
GetMaxLana(
    IN      PUNICODE_STRING     pusRegistryPath,
    IN  OUT PULONG              pulMaxLana
    )
{
    HANDLE hLinkage = NULL;
    HANDLE hParameters = NULL;
    NTSTATUS nsStatus;

    UCHAR ucBuffer[ 256 ];
    PKEY_VALUE_FULL_INFORMATION pkvfiValue = 
        (PKEY_VALUE_FULL_INFORMATION) ucBuffer;
    ULONG ulValueSize;
    

    PWSTR wsMaxLana = REGISTRY_MAX_LANA;
    UNICODE_STRING usMaxLana;

    ULONG ulBytesWritten;



    PAGED_CODE();

    do
    {
        *pulMaxLana = 0;

        
        //
        // open registry keys
        //
        
        nsStatus = NbOpenRegistry ( pusRegistryPath, &hLinkage, &hParameters );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( ("GetMaxLana : Failed to open registry" ) );
            nsStatus = STATUS_UNSUCCESSFUL;
            break;
        }


        //
        // allocate for key value.
        //
        
        ulValueSize = sizeof( ucBuffer );

        
        //
        // query "MaxLana" value
        //

        RtlInitUnicodeString (&usMaxLana, wsMaxLana);

        nsStatus = ZwQueryValueKey(
                             hParameters,
                             &usMaxLana,
                             KeyValueFullInformation,
                             pkvfiValue,
                             ulValueSize,
                             &ulBytesWritten
                             );

        if (!NT_SUCCESS(nsStatus)) 
        {
            NbPrint ( (
                "GetMaxLana : failed querying lana map key %x", nsStatus 
                ) );
            break;
        }

        if ( ulBytesWritten == 0 ) 
        {
            NbPrint ( ("GetMaxLana : querying lana map key returned 0 bytes") );
            nsStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        *pulMaxLana = *( (PULONG) ( (PUCHAR) pkvfiValue + pkvfiValue-> DataOffset ) );
        
        NbCloseRegistry (hLinkage, hParameters);

        return nsStatus;
        
    } while ( FALSE );
    

    NbCloseRegistry (hLinkage, hParameters);
    
    return nsStatus;
}



VOID
NbFreeRegistryInfo (
    IN PFCB pfcb
    )

/*++

Routine Description:

    This routine is called by Nb to get free any storage that was allocated
    by NbConfigureTransport in producing the specified CONFIG_DATA structure.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if ( pfcb->RegistrySpace != NULL ) {
        ExFreePool( pfcb->RegistrySpace );
        pfcb->RegistrySpace = NULL;
    }

}

NTSTATUS
NbOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE LinkageHandle,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by Nb to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

    NOTE: If the key "ClearRegistry" exists in ntuser.cfg, then
    this routine will remove any existing registry values for Nb
    (but still create the tree if it doesn't exist) and return
    FALSE.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE NbConfigHandle;
    NTSTATUS Status;
    HANDLE LinkHandle;
    HANDLE ParamHandle;
    PWSTR LinkageString = REGISTRY_LINKAGE;
    PWSTR ParametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING LinkageKeyName;
    UNICODE_STRING ParametersKeyName;
    OBJECT_ATTRIBUTES TmpObjectAttributes;
    ULONG Disposition;

    PAGED_CODE();

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwCreateKey(
                 &NbConfigHandle,
                 KEY_WRITE,
                 &TmpObjectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &Disposition);     // disposition

    if (!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Open the Nb linkages key.
    //

    RtlInitUnicodeString (&LinkageKeyName, LinkageString);

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        &LinkageKeyName,            // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NbConfigHandle,            // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey(
                 &LinkHandle,
                 KEY_READ,
                 &TmpObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        ZwClose (NbConfigHandle);
        return Status;
    }


    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&ParametersKeyName, ParametersString);

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        &ParametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NbConfigHandle,            // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey(
                 &ParamHandle,
                 KEY_READ,
                 &TmpObjectAttributes);
    if (!NT_SUCCESS(Status)) {

        ZwClose (LinkHandle);
        ZwClose (NbConfigHandle);
        return Status;
    }

    *LinkageHandle = LinkHandle;
    *ParametersHandle = ParamHandle;


    //
    // All keys successfully opened or created.
    //

    ZwClose (NbConfigHandle);
    return STATUS_SUCCESS;

}   /* NbOpenRegistry */

VOID
NbCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by Nb to close the registry. It closes
    the handles passed in and does any other work needed.

Arguments:

    LinkageHandle - The handle used to read linkage information.

    ParametersHandle - The handle used to read other parameters.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ZwClose (LinkageHandle);
    ZwClose (ParametersHandle);

}   /* NbCloseRegistry */

NTSTATUS
NbReadLinkageInformation(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle,
    IN PFCB pfcb,
    IN BOOL bCreateDevice
    )

/*++

Routine Description:

    This routine is called by Nb to read its linkage information
    from the registry. If there is none present, then ConfigData
    is filled with a list of all the adapters that are known
    to Nb.

Arguments:

    LinkageHandle - Supplies the Linkage key in netbios
    ParametersHandle

    pfcb - Describes Nb's current configuration.

Return Value:

    Status

--*/

{
    PWSTR BindName = REGISTRY_BIND;
    UNICODE_STRING BindString;
    NTSTATUS Status;

    PKEY_VALUE_FULL_INFORMATION Value = NULL;
    ULONG ValueSize;

    PWSTR LanaMapName = REGISTRY_LANA_MAP;
    UNICODE_STRING LanaMapString;
    PLANA_MAP pLanaMap;

    ULONG BytesWritten;
    UINT ConfigBindings = 0;
    PWSTR CurBindValue;
    UINT index;

    PAGED_CODE();

    pfcb->MaxLana = NbReadSingleParameter( ParametersHandle, REGISTRY_MAX_LANA, -1 );

    if (pfcb->MaxLana > MAXIMUM_LANA) {
        return STATUS_INVALID_PARAMETER;
    }

    NbPrint( (
        "Netbios : NbReadLinkageInformation : MaxLana = %d\n", 
        pfcb-> MaxLana 
        ) );

    //
    // Read the "Bind" key.
    //

    RtlInitUnicodeString (&BindString, BindName);

#ifdef UTILITY
    Value = malloc( DEFAULT_VALUE_SIZE);
#else
    Value = ExAllocatePoolWithTag(PagedPool, DEFAULT_VALUE_SIZE, 'rSBN');
#endif

    if ( Value == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ValueSize = DEFAULT_VALUE_SIZE;

    pfcb->RegistrySpace = NULL;

    try {

        Status = ZwQueryValueKey(
                             LinkageHandle,
                             &BindString,
                             KeyValueFullInformation,
                             Value,
                             ValueSize,
                             &BytesWritten
                             );

        if ( Status == STATUS_BUFFER_OVERFLOW) {

            ExFreePool( Value );

            //  Now request with exactly the right size
            ValueSize = BytesWritten;

#ifdef UTILITY
            Value = malloc( ValueSize);
#else
            Value = ExAllocatePoolWithTag(PagedPool, ValueSize, 'rSBN');
#endif

            if ( Value == NULL ) {
                try_return( Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            Status = ZwQueryValueKey(
                                 LinkageHandle,
                                 &BindString,
                                 KeyValueFullInformation,
                                 Value,
                                 ValueSize,
                                 &BytesWritten
                                );
        }

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        if ( BytesWritten == 0 ) {
            try_return( Status = STATUS_ILL_FORMED_SERVICE_ENTRY);
        }


        //
        // Alloc space for Registry stuff as well as pDriverName array.
        //
    #ifdef UTILITY
        pfcb->RegistrySpace = malloc(ROUNDUP_TO_LONG(BytesWritten - Value->DataOffset) +
            (sizeof(UNICODE_STRING) * (pfcb->MaxLana+1)));
    #else
        pfcb->RegistrySpace = ExAllocatePoolWithTag(PagedPool,
            ROUNDUP_TO_LONG(BytesWritten - Value->DataOffset) +
            (sizeof(UNICODE_STRING) * (pfcb->MaxLana+1)), 'rSBN');
    #endif

        if ( pfcb->RegistrySpace == NULL ) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlMoveMemory(pfcb->RegistrySpace,
                        (PUCHAR)Value + Value->DataOffset,
                        BytesWritten - Value->DataOffset);

        pfcb->pDriverName =
            (PUNICODE_STRING) ((PBYTE) pfcb->RegistrySpace +
            ROUNDUP_TO_LONG(BytesWritten-Value->DataOffset));

        //
        // Read the "LanaMap" key into Storage.
        //

        RtlInitUnicodeString (&LanaMapString, LanaMapName);

        Status = ZwQueryValueKey(
                             LinkageHandle,
                             &LanaMapString,
                             KeyValueFullInformation,
                             Value,
                             ValueSize,
                             &BytesWritten
                             );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        if ( BytesWritten == 0 ) {
            try_return( Status = STATUS_ILL_FORMED_SERVICE_ENTRY);
        }

        //  Point pLanaMap at the data from the registry.
        pLanaMap = (PLANA_MAP)((PUCHAR)Value + Value->DataOffset);

        //
        // For each binding, initialize the drivername string.
        //

        for ( index = 0 ; index <= pfcb->MaxLana ; index++ ) {
            //  Initialize unused drivernames to NULL name
            RtlInitUnicodeString (&pfcb->pDriverName[index], NULL);
        }

        CurBindValue = (PWCHAR)pfcb->RegistrySpace;

        
        IF_NBDBG( NB_DEBUG_FILE )
        {
    		NbPrint( ("NETBIOS: Enumerating lanas ...\n") );
        }
        
        while (*CurBindValue != 0) {

            if ((ConfigBindings > pfcb->MaxLana) ||
                (pLanaMap[ConfigBindings].Lana > pfcb->MaxLana)) {
                try_return( Status = STATUS_INVALID_PARAMETER);
            }

            RtlInitUnicodeString (
                &pfcb->pDriverName[pLanaMap[ConfigBindings].Lana],
               CurBindValue);

            //
            // Only non PNP devices are created here.  PnP devices 
            // are created as required in the bind handler in file.c
            //
            // V Raman
            //
            
            if ( bCreateDevice                                          &&
                 pLanaMap[ConfigBindings].Enum != FALSE ) {
                 
				if (NbCheckLana (
						&pfcb->pDriverName[pLanaMap[ConfigBindings].Lana])) 
				{
					//
					//  Record that the lana number is enabled
					//

					pfcb->LanaEnum.lana[pfcb->LanaEnum.length] =
						pLanaMap[ConfigBindings].Lana;
					pfcb->LanaEnum.length++;

                    IF_NBDBG( NB_DEBUG_FILE )
                    {
					    NbPrint( ("NETBIOS: Lana %d (%ls) added OK.\n",
						    pLanaMap[ConfigBindings].Lana, CurBindValue) );
					}
				}

				else
				{
    			    IF_NBDBG( NB_DEBUG_FILE )
	    		    {
		    			NbPrint( ("NETBIOS: Lana's %d %ls could not be opened.\n",
			    			pLanaMap[ConfigBindings].Lana, CurBindValue) );
			    	}
                }
            }
            
			else
			{
			    IF_NBDBG( NB_DEBUG_FILE )
			    {
				    NbPrint( ("NbReadLinkageInformation : Lana %d (%ls) is not enumerated.\n",
						pLanaMap[ConfigBindings].Lana, CurBindValue) );
			    }
            }

            ++ConfigBindings;

            //
            // Now advance the "Bind" value.
            //

            CurBindValue += wcslen(CurBindValue) + 1;

        }

        try_return( Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if ( !NT_SUCCESS(Status) ) {
            ExFreePool( pfcb->RegistrySpace );
            pfcb->RegistrySpace = NULL;
        }

        if ( Value != NULL ) {
            ExFreePool( Value );
        }
    }

    return Status;

}   /* NbReadLinkageInformation */

ULONG
NbReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by Nb to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    ULONG InformationBuffer[16];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION Information =
        (PKEY_VALUE_FULL_INFORMATION)InformationBuffer;
    UNICODE_STRING ValueKeyName;
    ULONG InformationLength;
    LONG ReturnValue;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString (&ValueKeyName, ValueName);

    Status = ZwQueryValueKey(
                 ParametersHandle,
                 &ValueKeyName,
                 KeyValueFullInformation,
                 (PVOID)Information,
                 sizeof (InformationBuffer),
                 &InformationLength);

    if ((Status == STATUS_SUCCESS) && (Information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&ReturnValue,
            ((PUCHAR)Information) + Information->DataOffset,
            sizeof(ULONG));

        if (ReturnValue < 0) {

            ReturnValue = DefaultValue;

        }

    } else {

        ReturnValue = DefaultValue;

    }

    return ReturnValue;

}   /* NbReadSingleParameter */


BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    )
/*++

Routine Description:

    This routine uses the transport to create an entry in the NetBIOS
    table with the value of "Name". It will re-use an existing entry if
    "Name" already exists.

    Note: This synchronous call may take a number of seconds. If this matters
    then the caller should specify ASYNCH and a post routine so that it is
    performed by the thread created by the netbios dll routines.

    If pdncb == NULL then a special handle is returned that is capable of
    administering the transport. For example to execute an ASTAT.

Arguments:

    FileHandle - Pointer to where the filehandle is to be returned.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - supplies the device names for the lana number.

    LanNumber - supplies the network adapter to be opened.

    pdncb - Pointer to either an NCB or NULL.

Return Value:

    The function value is the status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;

    PAGED_CODE();

    InitializeObjectAttributes (
        &ObjectAttributes,
        DeviceName,
        0,
        NULL,
        NULL);

    Status = ZwCreateFile (
                 &FileHandle,
                 GENERIC_READ | GENERIC_WRITE, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // Allocation size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 FILE_SHARE_WRITE,
                 FILE_CREATE,
                 0,                     // create options.
                 NULL,
                 0
                 );


    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS( Status )) {
        NTSTATUS localstatus;
		
        localstatus = ZwClose( FileHandle);

        ASSERT(NT_SUCCESS(localstatus));
		return TRUE;
	}
	else {

	    NbPrint( ( 
	        "NbCheckLana : Create file failed for %s with code %x iostatus %x\n",
	        DeviceName-> Buffer, Status, IoStatusBlock.Status
	        ) );
		return FALSE;
	}
}


#ifdef UTILITY
void
_cdecl
main (argc, argv)
   int argc;
   char *argv[];
{
    DEVICE_CONTEXT DeviceContext;
    FCB NewFcb;
    RtlInitUnicodeString(&DeviceContext.RegistryPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Netbios");
    ReadRegistry(
     &DeviceContext,
     &NewFcb
    );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\sys\timer.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code which implements the receive and send timeouts
    for each connection. Netbios timeouts are specified in 0.5 second units.

    For each application using Netbios there is a single timer started
    when the first connection specifies a non-zero rto or sto. This regular
    1 second pulse is used for all connections by this application. It
    is stopped when the application exits (and closes the connection to
    \Device\Netbios).

    If a send timesout the connection is disconnected as per Netbios 3.0.
    Individual receives can timeout without affecting the session.

Author:

    Colin Watson (ColinW) 15-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbStartTimer)
#pragma alloc_text(PAGE, NbTimer)
#endif

VOID
RunTimerForLana(
    PFCB pfcb,
    PLANA_INFO plana,
    int index
    );

VOID
NbStartTimer(
    IN PFCB pfcb
    )
/*++

Routine Description:

    This routine starts the timer ticking for this FCB.

Arguments:

    pfcb - Pointer to our FCB.

Return Value:

    none.

--*/
{
    LARGE_INTEGER DueTime;

    PAGED_CODE();

    DueTime.QuadPart = Int32x32To64( 500, -MILLISECONDS );

    // This is the first connection with timeouts specified.

    //
    // set up the timer so that every 500 milliseconds we scan all the
    // connections for timed out receive and sends.
    //

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("Start the timer for fcb: %lx\n", pfcb));
    }

    if ( pfcb->TimerRunning == TRUE ) {
        return;
    }

    KeInitializeDpc (
        &pfcb->Dpc,
        NbTimerDPC,
        pfcb);

    KeInitializeTimer (&pfcb->Timer);

    pfcb->TimerRunning = TRUE;

    (VOID)KeSetTimer (
        &pfcb->Timer,
        DueTime,
        &pfcb->Dpc);
}

VOID
NbTimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is called to search for timed out send and receive
    requests. This routine is called at raised Irql.

Arguments:

    Context - Pointer to our FCB.

Return Value:

    none.

--*/

{
    PFCB pfcb = (PFCB) Context;

    IoQueueWorkItem( 
        pfcb->WorkEntry, NbTimer, DelayedWorkQueue, pfcb
        );

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
}

VOID
NbTimer(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
{
    ULONG lana_index;
    int index;
    PFCB pfcb = (PFCB) Context;

    LARGE_INTEGER DueTime;

    PAGED_CODE();

    //
    //  For each network adapter that is allocated, scan each connection.
    //


    LOCK_RESOURCE(pfcb);

    IF_NBDBG (NB_DEBUG_TIMER) {
        NbPrint((" NbTimeout\n" ));
    }

    if ( pfcb->TimerRunning != TRUE ) {

        //
        // Driver is being closed. We are trying to cancel the timer
        // but the dpc was already fired. Set the timer cancelled event
        //  to the signalled state and exit.
        //

        UNLOCK_RESOURCE(pfcb);
        KeSetEvent( pfcb->TimerCancelled, 0, FALSE);
        return;
    }

    for ( lana_index = 0; lana_index <= pfcb->MaxLana; lana_index++ ) {

        //  For each network.

        PLANA_INFO plana = pfcb->ppLana[lana_index];

        if (( plana != NULL ) &&
            ( plana->Status == NB_INITIALIZED)) {

            //  For each connection on that network.

            for ( index = 1; index <= MAXIMUM_CONNECTION; index++) {

                if ( plana->ConnectionBlocks[index] != NULL ) {

                    RunTimerForLana(pfcb, plana, index);
                }
            }
        }

    }

    DueTime.QuadPart = Int32x32To64( 500, -MILLISECONDS );

    (VOID)KeSetTimer (
            &pfcb->Timer,
            DueTime,
            &pfcb->Dpc);

    UNLOCK_RESOURCE(pfcb);
}

VOID
RunTimerForLana(
    PFCB pfcb,
    PLANA_INFO plana,
    int index
    )
{

    KIRQL OldIrql;          //  Used when SpinLock held.
    PPCB ppcb;
    PCB pcb;

    ppcb = &plana->ConnectionBlocks[index];
    pcb = *ppcb;

    if (( pcb->Status != SESSION_ESTABLISHED ) &&
        ( pcb->Status != HANGUP_PENDING )) {
            //  Only examine valid connections.
            return;
    }

    LOCK_SPINLOCK( pfcb, OldIrql );

    if (( pcb->ReceiveTimeout != 0 ) &&
        ( !IsListEmpty( &pcb->ReceiveList))) {
        PDNCB pdncb;
        PLIST_ENTRY ReceiveEntry = pcb->ReceiveList.Flink;

        pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

        if ( pdncb->tick_count <= 1) {
            PIRP Irp = pdncb->irp;

            // Read request timed out.

            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout Read pncb: %lx\n", pdncb));
            }

            NCB_COMPLETE( pdncb, NRC_CMDTMO );

            RemoveEntryList( &pdncb->ncb_next );

            IoAcquireCancelSpinLock(&Irp->CancelIrql);

            //
            //  Remove the cancel request for this IRP. If its cancelled then its
            //  ok to just process it because we will be returning it to the caller.
            //

            Irp->Cancel = FALSE;

            IoSetCancelRoutine(Irp, NULL);

            IoReleaseCancelSpinLock(Irp->CancelIrql);

            //  repair the Irp so that the NCB gets copied back.
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information =
            FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            IoCompleteRequest( Irp, IO_NETWORK_INCREMENT);

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Read pdncb: %lx, count: %x\n", pdncb, pdncb->tick_count));
            }
            pdncb->tick_count -= 1;
        }
    }

    if (( pcb->SendTimeout != 0 ) &&
        (!IsListEmpty( &pcb->SendList))) {
        PDNCB pdncb;
        PLIST_ENTRY SendEntry = pcb->SendList.Flink;

        pdncb = CONTAINING_RECORD( SendEntry, DNCB, ncb_next);
        if ( pdncb->tick_count <= 1) {
            // Send request timed out- hangup connection.

            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout send pncb: %lx\n", pdncb));
            }

            NCB_COMPLETE( pdncb, NRC_CMDTMO );

            pcb->Status = SESSION_ABORTED;

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            CloseConnection( ppcb, 1000 );

            //
            //  No need to worry about looking for a timed out hangup, the session
            //  will be closed as soon as the transport cancels the send.
            //

            return;

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Write pdncb: %lx, count: %x\n", pdncb, pdncb->tick_count));
            }
            pdncb->tick_count -= 1;
        }
    }

    if (( pcb->pdncbHangup != NULL ) &&
        ( pcb->Status == HANGUP_PENDING )) {
        if ( pcb->pdncbHangup->tick_count <= 1) {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout send pncb: %lx\n", pcb->pdncbHangup));
            }

            NCB_COMPLETE( pcb->pdncbHangup, NRC_CMDTMO );

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            AbandonConnection( ppcb );

            LOCK_SPINLOCK( pfcb, OldIrql );

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Hangup pdncb: %lx, count: %x\n",
                                    pcb->pdncbHangup,
                                    pcb->pdncbHangup->tick_count));
            }
            pcb->pdncbHangup->tick_count -= 1;
        }
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\debug.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Debug.h

Abstract:

    This file contains debug printing constants for NBT.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#ifndef _DEBUGNBT_H
#define _DEBUGNBT_H

//
// Debug support.. this macro defines a check on a global flag that
// selectively enables and disables debugging in different parts of NBT
// NbtDebug is a global ULONG declared in driver.c
//
#if DBG
extern ULONG    NbtDebug;
#endif // DBG

// Assert support
#ifdef _NTDRIVER_
#if DBG
#undef ASSERT
#undef ASSERTMSG

#define ASSERT( exp )                   \
    if (!(exp)) {                       \
        DbgPrint( "Assertion \"%s\" failed at file %s, line %d\n", #exp, __FILE__, __LINE__ );  \
        if (NbtConfig.BreakOnAssert)    \
            DbgBreakPoint();            \
    }

#define ASSERTMSG( msg, exp )           \
    if (!exp) {                         \
        DbgPrint( "Message: %s\nAssertion \"%s\" failed at file %s, line %d\n", msg, #exp, __FILE__, __LINE__ );    \
        if (NbtConfig.BreakOnAssert)    \
            DbgBreakPoint();            \
    }

#endif // DBG
#endif // _NTDRIVER_

#if DBG
#define IF_DBG(flags)   if(NbtDebug & flags)

#define NBT_DEBUG_REGISTRY     0x00000001    // registry.c
#define NBT_DEBUG_DRIVER       0x00000002    // driver.c
#define NBT_DEBUG_NTUTIL       0x00000004    // ntutil.c
#define NBT_DEBUG_TDIADDR      0x00000008    // tdiaddr.c
#define NBT_DEBUG_TDICNCT      0x00000010    // tidaddr.c
#define NBT_DEBUG_NETBIOS_EX   0x00000020    // NETBIOS_EX address type debugging
#define NBT_DEBUG_NAME         0x00000040    // name.c
#define NBT_DEBUG_NTISOL       0x00000080    // ntisol.c
#define NBT_DEBUG_NBTUTILS     0x00000100    // nbtutils.c
#define NBT_DEBUG_NAMESRV      0x00000200    // namesrv.c
#define NBT_DEBUG_HNDLRS       0x00000400    // hndlrs.c
#define NBT_DEBUG_PROXY        0x00000800    // proxy.c
#define NBT_DEBUG_HASHTBL      0x00001000    // hashtbl.c
#define NBT_DEBUG_UDPSEND      0x00002000    // udpsend.c
#define NBT_DEBUG_TDIOUT       0x00004000    // tdiout.c
#define NBT_DEBUG_SEND         0x00008000    // sends
#define NBT_DEBUG_RCV          0x00010000    // rcvs
#define NBT_DEBUG_RCVIRP       0x00020000    // rcv irp processing
#define NBT_DEBUG_INDICATEBUFF 0x00040000    // tdihndlrs.c indicate buffer
#define NBT_DEBUG_REFRESH      0x00080000    // refresh logic
#define NBT_DEBUG_REF          0x00100000    // reference counts
#define NBT_DEBUG_DISCONNECT   0x00200000    // Disconnects
#define NBT_DEBUG_FILLIRP      0x00400000    // Filling the Irp(Rcv)
#define NBT_DEBUG_LMHOST       0x00800000    // Lmhost file stuff
#define NBT_DEBUG_FASTPATH     0x01000000    // Rcv code - fast path
#define NBT_DEBUG_WINS         0x02000000    // Wins Interface debug
#define NBT_DEBUG_PNP_POWER    0x04000000    // NT PNP debugging
#define NBT_DEBUG_HANDLES      0x08000000    // To debug Handle RefCount issues
#define NBT_DEBUG_TDIHNDLR     0x10000000    // tdihndlr.c
#define NBT_DEBUG_MEMFREE      0x20000000    // memory alloc/free
#define NBT_DEBUG_KDPRINTS     0x80000000    // KdPrint output

//----------------------------------------------------------------------------
//
// Remove Debug spew on Debug builds!
//
#ifndef VXD
#undef KdPrint
#define KdPrint(_x_)                            \
   if (NbtDebug & NBT_DEBUG_KDPRINTS)           \
   {                                            \
        DbgPrint _x_;                           \
   }
#endif  // !VXD
//----------------------------------------------------------------------------

#else
#define IF_DBG(flags)
#endif

/*
 * Software Tracing
 */
#define WPP_CONTROL_GUIDS   WPP_DEFINE_CONTROL_GUID(CtlGuid,(bca7bd7f,b0bf,4051,99f4,03cfe79664c1), \
        WPP_DEFINE_BIT(NBT_TRACE_DNS)                                       \
        WPP_DEFINE_BIT(NBT_TRACE_OUTBOUND)                                  \
        WPP_DEFINE_BIT(NBT_TRACE_INBOUND)                                   \
        WPP_DEFINE_BIT(NBT_TRACE_DISCONNECT)                                \
        WPP_DEFINE_BIT(NBT_TRACE_LOWER_EDGE)                                \
        WPP_DEFINE_BIT(NBT_TRACE_IOCTL)                                     \
        WPP_DEFINE_BIT(NBT_TRACE_PNP)                                       \
        WPP_DEFINE_BIT(NBT_TRACE_NAMESRV)                                   \
        WPP_DEFINE_BIT(NBT_TRACE_SEND)                                      \
        WPP_DEFINE_BIT(NBT_TRACE_RECV)                                      \
        WPP_DEFINE_BIT(NBT_TRACE_SENDDGRAM)                                 \
        WPP_DEFINE_BIT(NBT_TRACE_RECVDGRAM)                                 \
        WPP_DEFINE_BIT(NBT_TRACE_LOCALNAMES)                                \
        WPP_DEFINE_BIT(NBT_TRACE_REMOTECACHE)                               \
        WPP_DEFINE_BIT(NBT_TRACE_PROXY)                                     \
        WPP_DEFINE_BIT(NBT_TRACE_VERBOSE)                                   \
    )

//
// Enable Software Tracing on all builds
//
#ifndef _NBT_WMI_SOFTWARE_TRACING_
    #define _NBT_WMI_SOFTWARE_TRACING_
#endif

#ifndef _NBT_WMI_SOFTWARE_TRACING_
/*
 * Totally turn off software tracing
 */
#   define NbtTrace(l,m)
#   define WPP_ENABLED()            (0)
#   define WPP_LEVEL_ENABLED(LEVEL) (0)
#define WPP_LOGNBTNAME(x)
#else
int nbtlog_strnlen(char *p, int n);
static CHAR NBTLOGNAME=0;
#define WPP_LOGNBTNAME(x) \
    WPP_LOGPAIR(nbtlog_strnlen((char*)x,15),x) WPP_LOGPAIR(1,&NBTLOGNAME)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbios\winsock\wshnetbs.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    WshNetbs.c

Abstract:

    This module contains necessary routines for the Netbios
    Windows Sockets Helper DLL.  This DLL provides the
    transport-specific support necessary for the Windows Sockets DLL to
    _access any Netbios transport.

Author:

    David Treadwell (davidtr)    19-Jul-1992

Revision History:

--*/

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <wchar.h>

#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>

//
// Structure and variables to define the triples supported by Netbios.
// The first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE VcMappingTriples[] = { AF_NETBIOS, SOCK_SEQPACKET, 0 };

MAPPING_TRIPLE DgMappingTriples[] = { AF_NETBIOS, SOCK_DGRAM,     0 };

//
// Structure defined for holding transport (provider) information for
// each Netbios transport loaded on the machine.
//

typedef struct _WSHNETBS_PROVIDER_INFO {
    UCHAR Enum;
    UCHAR LanaNumber;
    INT ProtocolNumber;
    PWSTR ProviderName;
} WSHNETBS_PROVIDER_INFO, *PWSHNETBS_PROVIDER_INFO;

PWSHNETBS_PROVIDER_INFO ProviderInfo;
PVOID ProviderNames = NULL;
ULONG ProviderCount;

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;

PLANA_MAP LanaMap;

//
// Maintain all of the config parameters in one memory
// block so we can replace it when info changes.
//
typedef struct _WSHNETBS_CONFIG_INFO {
    LONG    ReferenceCount;     // Reference count to keep the info for
                                // the sockets that are already open
                                // until they are closed
    UCHAR   Blob[1];
} WSHNETBS_CONFIG_INFO, *PWSHNETBS_CONFIG_INFO;
PWSHNETBS_CONFIG_INFO ConfigInfo;
#define REFERENCE_CONFIG_INFO(_info)    \
    InterlockedIncrement (&_info->ReferenceCount)

#define DEREFERENCE_CONFIG_INFO(_info)                      \
    ASSERT (_info->ReferenceCount>0);                       \
    if (InterlockedDecrement (&_info->ReferenceCount)==0) { \
        RtlFreeHeap( RtlProcessHeap( ), 0, _info );         \
    }
//
// Synchronize changes in configuration info
//
RTL_CRITICAL_SECTION ConfigInfoLock;

//
// Registry key and event to monitor changes in configuration info.
//
HKEY    NetbiosKey = NULL;
LARGE_INTEGER NetbiosUpdateTime = {0,0};

//

//
// The socket context structure for this DLL.  Each open Netbios socket will
// have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHNETBS_SOCKET_CONTEXT {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
    PWSHNETBS_PROVIDER_INFO Provider;
    PWSHNETBS_CONFIG_INFO   ConfigInfo;
} WSHNETBS_SOCKET_CONTEXT, *PWSHNETBS_SOCKET_CONTEXT;

//
// The GUID identifying this provider.
//

GUID NetBIOSProviderGuid = { /* 8d5f1830-c273-11cf-95c8-00805f48a192 */
    0x8d5f1830,
    0xc273,
    0x11cf,
    {0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
    };


INT
LoadProviderInfo (
    VOID
    );


BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{
    NTSTATUS    status;
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        status = RtlInitializeCriticalSection (&ConfigInfoLock);
        if (!NT_SUCCESS (status)) {
            return FALSE;
        }
        //
        // Ignore error here, we'll retry if necessary.
        //
        LoadProviderInfo ();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:

        //
        // If the process is terminating, do not bother to do any
        // resource deallocation as the system will do it automatically.
        //

        if ( Context != NULL ) {
            return TRUE;
        }

        if ( ConfigInfo != NULL ) {
            DEREFERENCE_CONFIG_INFO (ConfigInfo);
            ConfigInfo = NULL;
        }
        if (NetbiosKey!=NULL) {
            RegCloseKey (NetbiosKey);
            NetbiosKey = NULL;
        }

        RtlDeleteCriticalSection (&ConfigInfoLock);


        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_NB *sockaddr = (PSOCKADDR_NB)Sockaddr;

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->snb_family != AF_NETBIOS ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_NB) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Netbios only supports "normal" addresses.
    //

    SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE and SO_DONTROUTE.  This routine is called by
    the winsock DLL when a level/option name combination is passed
    to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // No other options are supported for Netbios sockets.

    return WSAEINVAL;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  Netbios doesn't
    currently support the concept of a wildcard socket address.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wildcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PSOCKADDR_NB sockaddr = (PSOCKADDR_NB)Sockaddr;
    HANDLE providerHandle;
    TDI_REQUEST_QUERY_INFORMATION tdiQuery;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING providerName;
    PWSHNETBS_SOCKET_CONTEXT context = (PWSHNETBS_SOCKET_CONTEXT)HelperDllSocketContext;
    ADAPTER_STATUS adapterStatusInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // We're going to return a Netbios sockaddr with a unique name
    // which is the premanent name of the Lana.
    //

    sockaddr->snb_family = AF_NETBIOS;
    sockaddr->snb_type = NETBIOS_UNIQUE_NAME;

    sockaddr->snb_name[0] = '\0';
    sockaddr->snb_name[1] = '\0';
    sockaddr->snb_name[2] = '\0';
    sockaddr->snb_name[3] = '\0';
    sockaddr->snb_name[4] = '\0';
    sockaddr->snb_name[5] = '\0';
    sockaddr->snb_name[6] = '\0';
    sockaddr->snb_name[7] = '\0';
    sockaddr->snb_name[8] = '\0';
    sockaddr->snb_name[9] = '\0';

    *SockaddrLength = sizeof(SOCKADDR_NB);

    //
    // We'll do a query directly to the TDI provider to get the
    // permanent address for this Lana.  First open a control channel to
    // the provider.
    //

    RtlInitUnicodeString( &providerName, context->Provider->ProviderName );

    InitializeObjectAttributes(
        &objectAttributes,
        &providerName,
        OBJ_INHERIT | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a control channel to the provider.
    //

    status = NtCreateFile(
                 &providerHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                     // AllocationSize
                 0L,                                       // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE,       // ShareAccess
                 FILE_OPEN_IF,                             // CreateDisposition
                 FILE_SYNCHRONOUS_IO_NONALERT,             // CreateOptions
                 NULL,
                 0
                 );
    if ( !NT_SUCCESS(status) ) {
        return WSAENOBUFS;
    }

    //
    // Do the actual query adapter status.
    //

    RtlZeroMemory( &tdiQuery, sizeof(tdiQuery) );

    tdiQuery.QueryType = TDI_QUERY_ADAPTER_STATUS;

    status = NtDeviceIoControlFile(
                 providerHandle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 IOCTL_TDI_QUERY_INFORMATION,
                 &tdiQuery,
                 sizeof(tdiQuery),
                 &adapterStatusInfo,
                 sizeof(adapterStatusInfo)
                 );
    if ( status != STATUS_SUCCESS && status != STATUS_BUFFER_OVERFLOW ) {
        NtClose( providerHandle );
        return WSAENOBUFS;
    }

    //
    // Close the handle to the provider, we're done with it.
    //

    NtClose( providerHandle );

    //
    // Copy the six bytes of adapter address to the end of the Netbios
    // name.
    //

    sockaddr->snb_name[10] = adapterStatusInfo.adapter_address[0];
    sockaddr->snb_name[11] = adapterStatusInfo.adapter_address[1];
    sockaddr->snb_name[12] = adapterStatusInfo.adapter_address[2];
    sockaddr->snb_name[13] = adapterStatusInfo.adapter_address[3];
    sockaddr->snb_name[14] = adapterStatusInfo.adapter_address[4];
    sockaddr->snb_name[15] = adapterStatusInfo.adapter_address[5];

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(VcMappingTriples) + sizeof(DgMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(VcMappingTriples) / sizeof(VcMappingTriples[0])
                     + sizeof(DgMappingTriples) / sizeof(DgMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory(
        Mapping->Mapping,
        VcMappingTriples,
        sizeof(VcMappingTriples)
        );
    RtlMoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(VcMappingTriples),
        DgMappingTriples,
        sizeof(DgMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context;
    ULONG i;
    BOOLEAN found = FALSE;
    INT error;

    //
    // Only sockets of types SOCK_SEQPACKET and SOCK_DGRAM are supported
    // by Netbios providers.
    //

    if ( *SocketType != SOCK_SEQPACKET && *SocketType != SOCK_DGRAM ) {
        return WSAESOCKTNOSUPPORT;
    }

    if ((error=LoadProviderInfo ())!=NO_ERROR) {
        if (error!=ERROR_NOT_ENOUGH_MEMORY)
            error = WSASYSCALLFAILURE;
        return error;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Treat 0x80000000 just like 0--EnumProtocols() returns 0x80000000
    // for lana 0 because GetAddressByName uses 0 as the protocol array
    // terminator.
    //

    if ( *Protocol == 0x80000000 ) {
        *Protocol = 0;
    }

    RtlEnterCriticalSection (&ConfigInfoLock);
    
    //
    // If the Protocol parameter is less than or equal to zero, then
    // it specifies a Lana number.  Otherwise, it specifies an actual
    // protocol number.  Loop through our array of providers looking
    // for one with a matching Lana or protocol value.
    //

    for ( i = 0; i < ProviderCount; i++ ) {

        if ( ( *Protocol <= 0 && -*Protocol == ProviderInfo[i].LanaNumber &&
                   ProviderInfo[i].Enum != 0 )

             ||

             (*Protocol == ProviderInfo[i].ProtocolNumber && *Protocol != 0) ) {

            REFERENCE_CONFIG_INFO (ConfigInfo);
            context->ConfigInfo = ConfigInfo;
            context->Provider = &ProviderInfo[i];
            found = TRUE;

            break;
        }
    }

    RtlLeaveCriticalSection (&ConfigInfoLock);

    //
    // If we didn't find a hit, fail.
    //

    if ( found ) {

        //
        // Indicate the name of the TDI device that will service this
        // socket.
        //

        RtlInitUnicodeString(
            TransportDeviceName,
            context->Provider->ProviderName
            );

        //
        // Initialize the context for the socket.
        //

        context->AddressFamily = *AddressFamily;
        context->SocketType = *SocketType;
        context->Protocol = *Protocol;
    

        //
        // Tell the Windows Sockets DLL which state transitions we're
        // interested in being notified of.  The only times we need to be
        // called is after a connect has completed so that we can turn on
        // the sending of keepalives if SO_KEEPALIVE was set before the
        // socket was connected, when the socket is closed so that we can
        // free context information, and when a connect fails so that we
        // can, if appropriate, dial in to the network that will support the
        // connect attempt.
        //

        *NotificationEvents = WSH_NOTIFY_CLOSE;

        //
        // Everything worked, return success.
        //

        *HelperDllSocketContext = context;
        return NO_ERROR;
    }


    RtlFreeHeap( RtlProcessHeap( ), 0, context );
    return WSAEPROTONOSUPPORT;
} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    //
    // We should only be called when the socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // Dereference config info and free the socket context.
        //

        DEREFERENCE_CONFIG_INFO (context->ConfigInfo);

        RtlFreeHeap( RtlProcessHeap( ), 0, HelperDllSocketContext );

    } else {

        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE and SO_DONTROUTE.  This routine is called by the
    winsock DLL when a level/option name combination is passed to
    setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHNETBS_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHNETBS_SOCKET_CONTEXT parentContext;
            INT one = 1;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHNETBS_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            return NO_ERROR;
        }
    }

    //
    // No other options are supported for Netbios sockets.
    //

    return WSAEINVAL;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DWORD bytesRequired;
    DWORD i;
    PPROTOCOL_INFO protocolInfo;
    PCHAR namePointer;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about NETBIOS protocol information.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    if (LoadProviderInfo ()!=NO_ERROR) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = 0;

    for ( i = 0; i < ProviderCount; i++ ) {
        bytesRequired += sizeof(PROTOCOL_INFO) * 2;
        bytesRequired +=
            ((wcslen( ProviderInfo[i].ProviderName ) + 1) * sizeof(WCHAR)) * 2;
    }

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in info for each Netbios provider.
    //

    namePointer = (PCHAR)lpProtocolBuffer + *lpdwBufferLength;
    protocolInfo = lpProtocolBuffer;

    for ( i = 0; i < ProviderCount * 2; i++ ) {

        protocolInfo[i].dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                           XP_GUARANTEED_ORDER |
                                           XP_MESSAGE_ORIENTED |
                                           XP_FRAGMENTATION;
        protocolInfo[i].iAddressFamily = AF_NETBIOS;
        protocolInfo[i].iMaxSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iMinSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iSocketType = SOCK_SEQPACKET;

        //
        // Return the lana number, but convert 0 to 0x80000000 so that
        // we do not confuse GetAddressByName.  That API uses 0 as the
        // protocol array terminator.
        //

        protocolInfo[i].iProtocol = -1*ProviderInfo[i/2].LanaNumber;
        if ( protocolInfo[i].iProtocol == 0 ) {
            protocolInfo[i].iProtocol = 0x80000000;
        }

        protocolInfo[i].dwMessageSize = 64000;


        namePointer =
         ( namePointer -
             ( (wcslen( ProviderInfo[i/2].ProviderName ) + 1) * sizeof(WCHAR) ) );
        protocolInfo[i].lpProtocol = (LPWSTR)namePointer;
        wcscpy( protocolInfo[i].lpProtocol, ProviderInfo[i/2].ProviderName );

        i++;
        protocolInfo[i].dwServiceFlags = XP_CONNECTIONLESS |
                                           XP_MESSAGE_ORIENTED |
                                           XP_SUPPORTS_BROADCAST |
                                           XP_FRAGMENTATION;
        protocolInfo[i].iAddressFamily = AF_NETBIOS;
        protocolInfo[i].iMaxSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iMinSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iSocketType = SOCK_DGRAM;

        protocolInfo[i].iProtocol = -1*ProviderInfo[i/2].LanaNumber;
        if ( protocolInfo[i].iProtocol == 0 ) {
            protocolInfo[i].iProtocol = 0x80000000;
        }

        protocolInfo[i].dwMessageSize = 64000;

        namePointer =
         ( namePointer -
             ( (wcslen( ProviderInfo[i/2].ProviderName ) + 1) * sizeof(WCHAR) ) );
        protocolInfo[i].lpProtocol = (LPWSTR)namePointer;
        wcscpy( protocolInfo[i].lpProtocol, ProviderInfo[i/2].ProviderName );
    }

    *lpdwBufferLength = bytesRequired;

    return ProviderCount * 2;

} // WSHEnumProtocols


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"NetBIOS" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &NetBIOSProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


#define ALIGN_TO_MAX_NATURAL(_sz)  \
        (((_sz) + (MAX_NATURAL_ALIGNMENT-1)) & (~(MAX_NATURAL_ALIGNMENT-1)))
INT
LoadProviderInfo (
    VOID
    )
{
    INT error;
    HKEY netbiosKey = NULL;
    ULONG providerListLength;
    ULONG lanaMapLength;
    ULONG type;
    ULONG i;
    PWSTR currentProviderName;
    PWSHNETBS_CONFIG_INFO configInfo = NULL;
    PLANA_MAP lanaMap;
    PWSHNETBS_PROVIDER_INFO providerInfo;
    PVOID providerNames;
    ULONG providerCount;
    LARGE_INTEGER lastWriteTime;


    if (NetbiosKey==NULL) {
        //
        // Read the registry for information on all Netbios providers,
        // including Lana numbers, protocol numbers, and provider device
        // names.  First, open the Netbios key in the registry.
        //

        error = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"SYSTEM\\CurrentControlSet\\Services\\Netbios\\Linkage",
                    0,
                    MAXIMUM_ALLOWED,
                    &netbiosKey
                    );
        if ( error != NO_ERROR ) {
            goto error_exit;
        }
    }
    else {
        //
        // Key is already opened, use it.
        //
        netbiosKey = NetbiosKey;
    }

    //
    // Check if data has changed since last time we read it.
    //
    error = RegQueryInfoKey (
                netbiosKey,     // handle to key to query
                NULL,           // address of buffer for class string
                NULL,           // address of size of class string buffer
                NULL,           // reserved
                NULL,           // address of buffer for number of 
                                // subkeys
                NULL,           // address of buffer for longest subkey 
                                // name length
                NULL,           // address of buffer for longest class 
                                // string length
                NULL,           // address of buffer for number of value 
                                // entries
                NULL,           // address of buffer for longest 
                                // value name length
                NULL,           // address of buffer for longest value 
                                // data length  
                NULL,           // address of buffer for security 
                                // descriptor length
                (PFILETIME)&lastWriteTime 
                                // address of buffer for last write 
                                // time
                );
    if (error!=NO_ERROR) {
        goto error_exit;
    }

    if (NetbiosKey!=NULL && lastWriteTime.QuadPart==NetbiosUpdateTime.QuadPart) {
        return NO_ERROR;
    }

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //

    providerListLength = 0;

    error = RegQueryValueExW(
                netbiosKey,
                L"Bind",
                NULL,
                &type,
                NULL,
                &providerListLength
                );
    if ( error != ERROR_MORE_DATA && error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // If the list of providers is empty, then Netbios is installed
    // but has no bindings.  Special-case a quit right here, since
    // the LanaMap value in the registry may be non-empty.
    //

    if ( providerListLength <= sizeof(WCHAR) ) {
        goto error_exit;
    }

    error = RegQueryValueExW(
                netbiosKey,
                L"LanaMap",
                NULL,
                &type,
                NULL,
                &lanaMapLength
                );
    if ( error != ERROR_MORE_DATA && error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //

    providerCount = lanaMapLength / sizeof(LANA_MAP);

    //
    // Allocate enough memory to hold the blob.
    //

    configInfo = RtlAllocateHeap( RtlProcessHeap( ), 0,
                    ALIGN_TO_MAX_NATURAL(FIELD_OFFSET (WSHNETBS_CONFIG_INFO, Blob)) +
                    ALIGN_TO_MAX_NATURAL(providerListLength) + 
                    ALIGN_TO_MAX_NATURAL(lanaMapLength) +
                    providerCount * sizeof(WSHNETBS_PROVIDER_INFO)
                    );
    if ( configInfo == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    configInfo->ReferenceCount = 1;
    providerNames = (PVOID)((PUCHAR)configInfo + ALIGN_TO_MAX_NATURAL(FIELD_OFFSET (WSHNETBS_CONFIG_INFO, Blob)));
    lanaMap = (PVOID)((PUCHAR)providerNames + ALIGN_TO_MAX_NATURAL(providerListLength));
    providerInfo = (PVOID)((PUCHAR)lanaMap +  ALIGN_TO_MAX_NATURAL(lanaMapLength));


    //
    // Get the list of transports from the registry.
    //

    error = RegQueryValueExW(
                netbiosKey,
                L"Bind",
                NULL,
                &type,
                (PVOID)providerNames,
                &providerListLength
                );
    if ( error != NO_ERROR ) {
        goto error_exit;
    }

    error = RegQueryValueExW(
                netbiosKey,
                L"LanaMap",
                NULL,
                &type,
                (PVOID)lanaMap,
                &lanaMapLength
                );
    if ( error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Fill in the array or provider information.
    //

    for ( currentProviderName = providerNames, i = 0;
          *currentProviderName != UNICODE_NULL && i < providerCount;
          currentProviderName += wcslen( currentProviderName ) + 1, i++ ) {

        providerInfo[i].Enum = lanaMap[i].Enum;
        providerInfo[i].LanaNumber = lanaMap[i].Lana;
        providerInfo[i].ProtocolNumber = lanaMap[i].Lana;
        providerInfo[i].ProviderName = currentProviderName;
    }

    if (i<providerCount) {
        error = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }


    RtlEnterCriticalSection (&ConfigInfoLock);
    if (ConfigInfo!=NULL) {
        DEREFERENCE_CONFIG_INFO (ConfigInfo);
    }
    if (NetbiosKey==NULL) {
        NetbiosKey = netbiosKey;
        netbiosKey = NULL;
    }

    NetbiosUpdateTime = lastWriteTime;
    ConfigInfo = configInfo;
    LanaMap = lanaMap;
    ProviderInfo = providerInfo;
    ProviderCount = providerCount;
    RtlLeaveCriticalSection (&ConfigInfoLock);

    if (netbiosKey!=NULL && netbiosKey!=NetbiosKey) {
        RegCloseKey (netbiosKey);
    }


    return NO_ERROR;

error_exit:

    if (netbiosKey!=NULL && netbiosKey!=NetbiosKey) {
        RegCloseKey (netbiosKey);
    }

    if ( configInfo != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, configInfo );
    }


    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\hosts.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lmhosts.h

Abstract:

    This is the header file for the lmhosts facility of the nbt driver.

Author:

    Eric Chin (ericc)           April 28, 1992

Revision History:

--*/
#ifndef _LMHOSTS_H_
#define _LMHOSTS_H_



//
// Configuration Defaults
//
// Only the first MAX_PARSE_BYTES of each line in the lmhosts file is
// examined.
//

#define DATABASEPATH                "\\SystemRoot\\nt\\system32\\drivers\\etc"

#define LMHOSTSFILE                 "lmhosts"           // name of lmhosts file

#define MAX_FILE_IO_THREADS         1                   // threads to read
                                                        //   lmhosts file
#ifdef VXD
#define DEF_PRELOAD                 100                 // Default entries to preload
#define MAX_PRELOAD                 500                 // Max cache entries to preload
#else
#define DEF_PRELOAD                 1000                // Default entries to preload
#define MAX_PRELOAD                 2000                // max cache entries to preload
#endif

#define MAX_MEMBERS_INTERNET_GROUP    50                // max size of internet group

//
// Reserved Keywords in the lmhosts File
//
#define BEG_ALT_TOKEN               "#BEGIN_ALTERNATE"  // alternate block
#define DOMAIN_TOKEN                "#DOM:"             // specifies LM domain
#define END_ALT_TOKEN               "#END_ALTERNATE"    // alternate block
#define INCLUDE_TOKEN               "#INCLUDE"          // include a file
#define PRELOAD_TOKEN               "#PRE"              // preload this entry
#define NOFNR_TOKEN                 "#NOFNR"            // no find name request


//
// Macro Definitions
//

//#define min(x, y)                   ((x) < (y) ? (x) : (y))



//
// Public Definitions
//
//
// For each file that is opened, a LM_FILE object is created.
//
typedef struct _LM_FILE
{
#ifndef VXD
    KSPIN_LOCK      f_lock;                     //  protects this object
    LONG            f_refcount;                 //  current no of references
#endif

    HANDLE          f_handle;                   //  handle from ZwOpenFile()
    LONG            f_lineno;                   //  current line number

#ifndef VXD
    LARGE_INTEGER   f_fileOffset;               //  current offset into file

    PUCHAR          f_current;                  //  buffer position to read
    PUCHAR          f_limit;                    //  last byte + 1 of buffer
    PUCHAR          f_buffer;                   //  start of buffer
#else
    PUCHAR          f_linebuffer;               //  line buffer
    PUCHAR          f_buffer;                   //  file buffer
    BOOL            f_EOF ;                     //  TRUE if EOF
    ULONG           f_CurPos ;                  //  Current Pos. in File Buffer
    ULONG           f_EndOfData ;               //  Last valid data in File Buffer
    PUCHAR          f_BackUp;                   //  copy here In case of #INCLUDE
#endif

} LM_FILE, *PLM_FILE;


//
// The LM_IPADDRESS_LIST object contains pertinent information about a
// group of ip addresses.
//
//
typedef struct _LM_IPADDRESS_LIST
{

    KSPIN_LOCK      i_rcntlock;                 // protects i_refcount
    LONG            i_refcount;                 // current no of references
    KSPIN_LOCK      i_lock;                     // only when adding to i_addrs[]
    int             i_maxaddrs;                 // max capacity of i_addrs[]
    int             i_numaddrs;                 // current no of ip addresses
    unsigned long   i_addrs[1];                 // the array of ip addresses

} LM_IPADDRESS_LIST, *PLM_IPADDRESS_LIST;


//
// An LM_PARSE_FUNCTION may be called recursively to handle #INCLUDE
// directives in an lmhosts file.
//
//
typedef unsigned long (* LM_PARSE_FUNCTION) (
    IN PUCHAR   path,                    // file to parse
    IN PUCHAR   target OPTIONAL,                  // NetBIOS name
    IN CHAR     RecurseLevel,                    // process #INCLUDE's ?
    OUT BOOLEAN *NoFindName                     // do not do find name
);


//
// The LM_WORK_ITEM object is the interface between lm_lookup() and
// LmFindName().
//
//
typedef struct _LM_WORK_ITEM
{                  // work for io thread(s)

    LIST_ENTRY      w_list;                     //  links to other items
//    mblk_t         *w_mp;                       //  STREAMS buffer

} LM_WORK_ITEM, *PLM_WORK_ITEM;



//
// Private Function Prototypes
//
int
LmAddToDomAddrList (
    IN PUCHAR name,
    IN unsigned long inaddr
    );

NTSTATUS
LmCloseFile (
    IN PLM_FILE handle
    );

NTSTATUS
LmCreateThreads (
    IN int nthreads
    );

NTSTATUS
LmDeleteAllDomAddrLists (
    VOID
    );

VOID
LmDerefDomAddrList(
    PLM_IPADDRESS_LIST arrayp
    );

char *
LmExpandName (
    OUT PUCHAR dest,
    IN PUCHAR source,
    IN UCHAR last
    );

PUCHAR
LmFgets (
    IN PLM_FILE pfile,
    OUT int *nbytes
    );

NTSTATUS
LmFindName (
    VOID
    );

PLM_IPADDRESS_LIST
LmGetDomAddrList (
    PUCHAR name
    );

unsigned long
LmGetIpAddr (
    IN PUCHAR path,
    IN PUCHAR target,
    IN CHAR   RecurseDepth,
    OUT BOOLEAN *NoFindName
    );

NTSTATUS
LmGetFullPath (
    IN PUCHAR  target,
    OUT PUCHAR *path
    );

unsigned long
LmInclude(
    IN PUCHAR            file,
    IN LM_PARSE_FUNCTION function,
    IN PUCHAR            argument,
    IN CHAR              RecurseDepth,
    OUT BOOLEAN          *NoFindName
    );

NTSTATUS
LmInitDomAddrLists (
    VOID
    );

VOID
LmLogOpenError (
    IN PUCHAR path,
    IN NTSTATUS unused
    );

VOID
LmLogSyntaxError (
    IN LONG lineno
    );

PLM_FILE
LmOpenFile (
    IN PUCHAR path
    );

int
LmPreloadEntry (
    IN PUCHAR name,
    IN unsigned long inaddr,
    IN unsigned int NoFNR
    );

BOOLEAN
LmPutCacheEntry (
//    IN mblk_t *mp,
    IN unsigned char *name,
    IN unsigned long inaddr,
    IN unsigned int ttl,
    IN LONG     nb_flags,
    IN unsigned int NoFNR
    );

NTSTATUS
LmTerminateThreads(
    VOID
    );

//
// Functions Imported from ..\common
//
extern unsigned long
inet_addr(
    IN char *cp
    );




#endif // _LMHOSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\ctemacro.h ===
//----------------------------------------------------------------------------
//
//  ctemacro.c
//
//  This file contains macros for the common transport environment - similar
//  to the way that ctestuff.c contains common procedures.
//
#ifndef _CTEMACRO_H_
#define _CTEMACRO_H_

#ifndef VXD
#define NT 1
#include <cxport.h>

#ifdef  _PNP_POWER_
#define _PNP_POWER_DBG_ 1
#endif  // _PNP_POWER_

char LastLockFile[255] ;
int  LastLockLine ;
char LastUnlockFile[255] ;
int LastUnlockLine ;
#endif


#ifdef VXD

#ifdef DEBUG
#define DBG_PRINT   1
#else
#endif  // DEBUG

#endif  // VXD

//----------------------------------------------------------------------------
#define IS_UNIQUE_ADDR(IpAddress) ((((PUCHAR)(&IpAddress))[3]) < ((UCHAR)0xe0))
//----------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// This HACK is being to avoid NetBT from logging Events whenever the Messenger
// name goes into conflict.  This is TEMPORARY ONLY, and the proper fix (post NT5)
// is:
// 1)   Change the Duplicate name error to a Warning
// 2)   Log the name + Device on which error occurred + IP address
//
#define IS_MESSENGER_NAME(_pName)   \
    (_pName[15] == 0x03)
//------------------------------------------------------------------------------


//  VOID
//  NTDereferenceObject(
//        PFILE_OBJECT   pFileObject
//        )

/*++
Routine Description:

    This routine dereferences an object.


--*/
#ifdef VXD
//
//  No equivalent for Vxd
//
#define NTDereferenceObject( fileobject )
#else //VXD
#define NTDereferenceObject( fileobject ) ObDereferenceObject( fileobject)
#endif

//----------------------------------------------------------------------------
//  VOID
//  CHECK_PTR(
//        PVOID   SpinLock,
//        )

/*++
Routine Description:

    This routine checks if a ptr points to freed memory


--*/

#if DBG
#define CHECK_PTR(_Ptr) \
    ASSERT(MmIsAddressValid(_Ptr));
#else

#define CHECK_PTR(_Ptr)
#endif


#ifndef VXD
/*++
    This macro verifies that an IRP passed to IoCallDriver() is
    set up to call the CompletionRoutine in all cases.
--*/
#if DBG
#define CHECK_COMPLETION(__pIrp)\
            {\
                PIO_STACK_LOCATION __pIrpSp = IoGetNextIrpStackLocation(__pIrp);\
                BOOL CompletionWillBeCalled =\
                    ( __pIrpSp->Control & ( SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL ) )\
                    == ( SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL );\
                ASSERT ( CompletionWillBeCalled );\
            }
#else   // DBG
#define CHECK_COMPLETION(__pIrp)
#endif  // DBG
#endif  // VXD

//
// Macros
//

//++
//
// LARGE_INTEGER
// CTEConvertMillisecondsTo100ns(
//     IN LARGE_INTEGER MsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     MsTime - Time in milliseconds.
//
// Return Value:
//
//     Time in hundreds of nanoseconds.
//
//--

#define CTEConvertMillisecondsTo100ns(MsTime) \
            RtlExtendedIntegerMultiply(MsTime, 10000)


//++
//
// LARGE_INTEGER
// CTEConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

    // Used in the conversion of 100ns times to milliseconds.
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#define SHIFT10000 13
extern LARGE_INTEGER Magic10000;

#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

//----------------------------------------------------------------------------
//
//  CTELockHandle
//

#ifndef VXD

    //
    //  The Spinlock structure is different between the NT driver and the VXD
    //  driver.  This macro is defined in cxport.h when compiling as a VXD.
    //
    #define CTELockHandle               KIRQL
#endif

//----------------------------------------------------------------------------
//  VOID
//  CTESpinLock(
//        tCONNECTELE   Structure,
//        CTELockHandle OldIrqLevel
//        )

/*++
Routine Description:

    This Routine acquires a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/
#ifndef VXD
#if DBG
#define CTESpinLock(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    AcquireSpinLockDebug(&(DataStruct)->LockInfo,&OldIrqLevel,__LINE__); \
    strcpy( LastLockFile, __FILE__ ) ;                                    \
    LastLockLine = __LINE__ ;                                             \
}
#else
#define CTESpinLock(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    CTEGetLock(&(DataStruct)->LockInfo.SpinLock,&(OldIrqLevel));                       \
}
#endif
#else
#ifdef DEBUG

#define CTESpinLock(DataStruct,OldIrqLevel)                               \
{                                                                         \
    CTEGetLock( &(DataStruct)->LockInfo.SpinLock, &OldIrqLevel ) ;                 \
}

#else
#define CTESpinLock(DataStruct,OldIrqLevel)
#endif // !DEBUG
#endif


//----------------------------------------------------------------------------
//  VOID
//  CTESpinFree(
//        PVOID   SpinLock,
//        CTELockHandle OldIrqLevel
//        )
/*++
Routine Description:

    This Routine releases a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinFree(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    strcpy( LastUnlockFile, __FILE__ ) ;                                      \
    LastUnlockLine = __LINE__ ;                                               \
    FreeSpinLockDebug(&(DataStruct)->LockInfo,OldIrqLevel,__LINE__); \
}
#else
#define CTESpinFree(DataStruct,OldIrqLevel)                    \
{                                                              \
    CTEFreeLock((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock),(OldIrqLevel));  \
}
#endif
#else
#ifdef DEBUG

#define CTESpinFree(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    CTEFreeLock( &(DataStruct)->LockInfo.SpinLock, OldIrqLevel ) ;                     \
}

#else
#define CTESpinFree(DataStruct,OldIrqLevel)
#endif
#endif
//----------------------------------------------------------------------------
//  VOID
//  CTESpinLockAtDpc(
//        tCONNECTELE   Structure
//        )

/*++
Routine Description:

    This Routine acquires a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinLockAtDpc(DataStruct)                                       \
{                                                                          \
    AcquireSpinLockAtDpcDebug(&(DataStruct)->LockInfo,__LINE__);                     \
    strcpy( LastLockFile, __FILE__ ) ;                                    \
    LastLockLine = __LINE__ ;                                             \
}
#else // DBG
#define CTESpinLockAtDpc(DataStruct)                                       \
{                                                                          \
    CTEGetLockAtDPC((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock));               \
}
#endif // DBG
#else // VXD
#define CTESpinLockAtDpc(DataStruct)
#endif  // VXD


//----------------------------------------------------------------------------
//  VOID
//  CTESpinFreeAtDpc(
//        PVOID   SpinLock,
//        CTELockHandle OldIrqLevel
//        )
/*++
Routine Description:

    This Routine releases a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinFreeAtDpc(DataStruct)                                        \
{                                                                           \
    strcpy( LastUnlockFile, __FILE__ ) ;                                    \
    LastUnlockLine = __LINE__ ;                                             \
    FreeSpinLockAtDpcDebug(&(DataStruct)->LockInfo,__LINE__);                        \
}
#else // DBG
#define CTESpinFreeAtDpc(DataStruct)                    \
{                                                              \
    CTEFreeLockFromDPC((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock));  \
}
#endif // DBG
#else  // VXD
#define CTESpinFreeAtDpc(DataStruct)
#endif // VXD


//----------------------------------------------------------------------------
//
//  VOID
//  CTEVerifyHandle(
//      IN  PVOID   pDataStruct,
//      IN  ULONG   Verifier,
//      IN  VOID    TypeofStruct,
//      OUT NTSTATUS *pRet
//        )
/*++
Routine Description:

    This Routine checks that a handle pts to a data structure with the
    correct verifier in it.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#if DBG
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)    \
{                                                                     \
        if ((_pDataStruct) &&                                         \
            ((((_TypeofStruct *)(_pDataStruct))->Verify) == (_Verifier)))    \
             *_ret=STATUS_SUCCESS;                                    \
        else                                                          \
        {                                                             \
            ASSERTMSG("Invalid Handle Passed to Nbt",0);              \
            return(STATUS_INVALID_HANDLE);                            \
        }                                                             \
}
#else
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)
#endif // DBG

#else
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)    \
{                                                                     \
    if ((((_TypeofStruct *)(_pDataStruct))->Verify) == (_Verifier))    \
         *_ret=STATUS_SUCCESS;                                    \
    else                                                          \
        return(STATUS_INVALID_HANDLE);                            \
}
#endif

#define NBT_VERIFY_HANDLE(s, V)                                           \
    ((s) && (s->Verify == V))

#define NBT_VERIFY_HANDLE2(s, V1, V2)                                      \
    ((s) && ((s->Verify == V1) || (s->Verify == V2)))


//----------------------------------------------------------------------------
//
//  VOID
//      CTEIoComplete( IN  CTE_IRP       * pIrp,
//                     IN  NTSTATUS        StatusCompletion,
//                     IN  ULONG           cbBytes
//                   );
//
/*++
Routine Description:

    Completes the requested IO packet.  For NT this involves calling the IO
    subsytem.  As a VxD, the Irp is a pointer to the NCB so we set the status
    variables appropriately and call the post routine if present.

Arguments:

    pIrp - Packet to complete
    StatusCompletion - Status of the completion
    cbBytes - Dependent on the type of IO

Return Value:

--*/
#ifndef VXD

#define PCTE_MDL PMDL
#define CTE_IRP  IRP
#define PCTE_IRP PIRP
#define CTE_ADDR_HANDLE PFILE_OBJECT

#define CTEIoComplete( pIrp, StatusCompletion, cbBytes )         \
    NTIoComplete( pIrp, StatusCompletion, cbBytes )

#else
#define PCTE_MDL        PVOID
#define CTE_IRP         NCB
#define PCTE_IRP        PNCB
#define PIRP            PNCB
#define CTE_ADDR_HANDLE PVOID
#define PFILE_OBJECT    CTE_ADDR_HANDLE

#define CTEIoComplete( pIrp, StatusCompletion, cbBytes )          \
    VxdIoComplete( pIrp, StatusCompletion, cbBytes )

#endif

//----------------------------------------------------------------------------
//
//  ULONG
//      CTEMemCmp( PVOID S1, PVOID S2, ULONG Length )
//
/*++
Routine Description:

    Compares two memory regions and returns the byte count at which the
    compare failed.  The return value will equal Length if the memory
    regions are identical.

Arguments:

    S1, S2 - Memory source 1 and 2 to compare
    Length - Count of bytes to compare

Return Value:

--*/
//
// CXPORT.H defines this macro differntly and they did it after we had
// it here, so undef their definition so we can use ours without getting
// warnings.
//
#undef CTEMemCmp

#ifndef VXD
#define CTEMemCmp( S1, S2, Length ) RtlCompareMemory( (S1), (S2), (Length) )
#else
//
//  Same thing as RtlCompareMemory except avoid standard call decoration
//
#define CTEMemCmp( S1, S2, Length ) VxdRtlCompareMemory( (S1), (S2), (Length) )
#endif

//----------------------------------------------------------------------------
//
//  LOGICAL
//      CTEMemEqu( PVOID S1, PVOID S2, ULONG Length )
//
/*++
Routine Description:

    Compares two memory regions and returns a value of TRUE is the regions
    match. Otherwise, FALSE is returned.

Arguments:

    S1, S2 - Memory source 1 and 2 to compare
    Length - Count of bytes to compare

Return Value:

--*/

#ifndef VXD
#define CTEMemEqu( S1, S2, Length ) RtlEqualMemory( (S1), (S2), (Length) )
#else
//
//  Same thing as RtlEqualMemory except avoid standard call decoration
//
#define CTEMemEqu( S1, S2, Length ) ( VxdRtlCompareMemory( (S1), (S2), (Length) ) == (Length) )
#endif

//----------------------------------------------------------------------------
//
//  Define away any try and except clauses when we are a VXD
//

#ifndef VXD
#define CTE_try     try
#define CTE_except  except
#else
#define CTE_try
#define CTE_except( x ) if ( 0 )
#endif

//
//  Misc. memory routines that get mapped when compiling as a VXD
//

#ifdef VXD
#define CTEZeroMemory( pDest, uLength )  CTEMemSet( pDest, 0, uLength )
#define CTEMemFree( p )                  CTEFreeMem( p )
#endif
//----------------------------------------------------------------------------
/*++
PVOID
CTEAllocMem(
        USHORT  Size
        )
Routine Description:

    This Routine allocates memory for NT drivers by calling ExAllocatePool
    It uses the definition of CTEAllocMem from cxport.h

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' tbN')
#endif
#endif

#ifndef VXD
#ifdef POOL_TAGGING
#define NBT_TAG(x) (((x)<<24)|'\0tbN')
#define NBT_TAG2(x) ( ((x & 0xff)<<24) | ((x & 0xff00)<<8) | '\0bN' )
#define NbtAllocMem(size,__tag__) ExAllocatePoolWithTag(NonPagedPool,(size),(__tag__))
#else  // POOL_TAGGING
#define NBT_TAG(x) 0
#define NBT_TAG2(x) 0
#define NbtAllocMem(size,__tag__) ExAllocatePool(NonPagedPool,(size))
#endif // POOL_TAGGING
#else  // POOL_TAGGING
#define NBT_TAG(x) 0
#define NBT_TAG2(x) 0
#define NbtAllocMem(size,__tag__) CTEAllocMem((size))
#endif // VXD

#ifdef VXD
#ifdef DEBUG
#undef CTEAllocMem
#define CTEAllocMem DbgAllocMem
#undef CTEFreeMem
#define CTEFreeMem  DbgFreeMem
#undef CTEMemFree
#define CTEMemFree  DbgFreeMem
PVOID DbgAllocMem( DWORD ReqSize );
VOID DbgFreeMem( PVOID  pBufferToFree );
VOID DbgMemCopy( PVOID pDestBuf, PVOID pSrcBuf, ULONG Length );
#endif
#endif

//----------------------------------------------------------------------------
/*++
PVOID
CTEAllocInitMem(
        ULONG  Size
        )
Routine Description:

    This Routine allocates memory and if nbt is a Vxd and it's called during
    DeviceInit time, will refill the heap and retry the allocation before
    failing.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#define CTEAllocInitMem(Size)   \
     ExAllocatePool(NonPagedPool, Size)
#endif

//----------------------------------------------------------------------------
/*++
VOID
CTEMemFree(
        PVOID  pMem
        )
Routine Description:

    This Routine frees memory for NT drivers by calling ExFreePool

Arguments:

    pMem - ptr to memory

Return Value:

    NONE

--*/
#ifndef VXD
#define CTEMemFree(pMem)    \
{                             \
    IF_DBG(NBT_DEBUG_MEMFREE)     \
    KdPrint(("Nbt.CTEMemFree: pmemfree = %X,lin %d in file %s\n",pMem,__LINE__,__FILE__)); \
    CTEFreeMem(pMem);  \
}
#endif

//----------------------------------------------------------------------------
/*++
VOID
CTEZeroMemory(
        PVOID   pDest,
        ULONG   uLength
        )
Routine Description:

    This Routine sets memory to a single byte value

Arguments:

    pDest       - dest address
    uLength     - number to zero

Return Value:

    NONE

--*/

#ifndef VXD
#define CTEZeroMemory(pDest,uLength)   \
    RtlZeroMemory(pDest,uLength)
#endif

//----------------------------------------------------------------------------
/*++
NTSTATUS
CTEReadIniString(
        HANDLE    ParmHandle,
        LPTSTR    KeyName,
        LPTSTR  * ppStringBuff
        )
Routine Description:

    This routine retrieves a string from the users configuration profile

Arguments:

    ParmHandle   - Registry handle
    KeyName      - Name of value to retrieve
    ppStringBuff - Pointer to allocated buffer containing found string

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#define CTEReadIniString( ParmHandle, KeyName, ppStringBuff )   \
     NTReadIniString( ParmHandle, KeyName, ppStringBuff )
#else
#define CTEReadIniString( ParmHandle, KeyName, ppStringBuff )   \
     VxdReadIniString( KeyName, ppStringBuff )
#endif

//----------------------------------------------------------------------------
/*++
ULONG
CTEReadSingleHexParameter(
        HANDLE    ParmHandle,
        LPTSTR    KeyName,
        ULONG     Default,
        ULONG     Minimum
        )
Routine Description:

    This routine retrieves a value in hex from the .ini file or registry

Arguments:

    ParmHandle   - Registry handle
    KeyName      - Name of value to retrieve
    Default      - Default value if not present
    Minimum      - Minimum value if present

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#define CTEReadSingleIntParameter( ParmHandle, KeyName, Default, Minimum ) \
    NbtReadSingleParameter( ParmHandle, KeyName, Default, Minimum )

#define CTEReadSingleHexParameter( ParmHandle, KeyName, Default, Minimum ) \
    NbtReadSingleParameter( ParmHandle, KeyName, Default, Minimum )
#else
#define CTEReadSingleIntParameter( ParmHandle, KeyName, Default, Minimum ) \
    GetProfileInt( ParmHandle, KeyName, Default, Minimum )

#define CTEReadSingleHexParameter( ParmHandle, KeyName, Default, Minimum ) \
    GetProfileHex( ParmHandle, KeyName, Default, Minimum )
#endif

//----------------------------------------------------------------------------
//
// NBT_REFERENCE_XXX(_pXXX)
//
/*++
Routine Description:

    Increments the reference count

Arguments:

    - the structure to be referenced

Return Value:
    None
--*/

//----------------------------------------------------------------------------
#define NBT_REFERENCE_CONNECTION( _pConnEle, _RefContext )               \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pConnEle=<%x:%d->%d>, <%d:%s>\n",     \
            _pConnEle,_pConnEle->RefCount,(_pConnEle->RefCount+1),__LINE__,__FILE__));  \
    ASSERT ((_pConnEle->Verify==NBT_VERIFY_CONNECTION) || (_pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN)); \
    InterlockedIncrement(&_pConnEle->RefCount);             \
    ASSERT (++_pConnEle->References[_RefContext]);          \
}

#define NBT_REFERENCE_LOWERCONN( _pLowerConn, _RefContext )              \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pLowerConn=<%x:%d->%d>, <%d:%s>\n",   \
            _pLowerConn,_pLowerConn->RefCount,(_pLowerConn->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (_pLowerConn->Verify == NBT_VERIFY_LOWERCONN);   \
    InterlockedIncrement(&_pLowerConn->RefCount);           \
    ASSERT (++_pLowerConn->References[_RefContext]);        \
}

#define NBT_REFERENCE_CLIENT( _pClient )                  \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pClient=<%x:%d->%d>, <%d:%s>\n",     \
            _pClient,_pClient->RefCount,(_pClient->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (NBT_VERIFY_HANDLE (_pClient, NBT_VERIFY_CLIENT));         \
    ASSERT (NBT_VERIFY_HANDLE (_pClient->pAddress, NBT_VERIFY_ADDRESS));         \
    InterlockedIncrement(&_pClient->RefCount);              \
}

#define NBT_REFERENCE_ADDRESS( _pAddrEle, _Context )        \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pAddrEle=<%x:%d->%d>, <%d:%s>\n",     \
            _pAddrEle,_pAddrEle->RefCount,(_pAddrEle->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (NBT_VERIFY_HANDLE (_pAddrEle, NBT_VERIFY_ADDRESS));       \
    InterlockedIncrement(&_pAddrEle->RefCount);             \
}

#define NBT_REFERENCE_NAMEADDR(_pNameAddr, _RefContext)     \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pNameAddr=<%x:%d->%d>, <%d:%s>\n",    \
            _pNameAddr,_pNameAddr->RefCount,(_pNameAddr->RefCount+1),__LINE__,__FILE__));    \
    ASSERT ((_pNameAddr->Verify == LOCAL_NAME) ||           \
            (_pNameAddr->Verify == REMOTE_NAME));           \
    InterlockedIncrement(&_pNameAddr->RefCount);            \
    ASSERT (++_pNameAddr->References[_RefContext]);         \
}

#define NBT_REFERENCE_TRACKER( _pTracker )                  \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pTracker=<%x:%d->%d>, <%d:%s>\n",     \
            _pTracker,_pTracker->RefCount,(_pTracker->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (_pTracker->Verify == NBT_VERIFY_TRACKER);       \
    InterlockedIncrement(&_pTracker->RefCount);             \
}

//----------------------------------------------------------------------------
//
// NBT_DEREFERENCE_XXX(_pXXX)
//
/*++
Routine Description:

    Wrapper for the real Derefencing routine

Arguments:

    - the structure to be de-referenced

Return Value:
    None
--*/

//----------------------------------------------------------------------------
#define NBT_DEREFERENCE_LOWERCONN( _pLowerConn, _RefContext, fJointLockHeld )   \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pLowerConn=<%x:%d->%d>, <%d:%s>\n",   \
            _pLowerConn,_pLowerConn->RefCount,(_pLowerConn->RefCount-1),__LINE__,__FILE__));                \
    ASSERT (_pLowerConn->Verify == NBT_VERIFY_LOWERCONN);   \
    NbtDereferenceLowerConnection(_pLowerConn, _RefContext, fJointLockHeld);    \
}

#define NBT_SWAP_REFERENCE_LOWERCONN(_pLowerConn, _RefContextOld, _RefContextNew, _fLowerLockHeld)    \
{                                                           \
    CTELockHandle       OldIrqSwap;                         \
                                                            \
    if (!_fLowerLockHeld)                                   \
    {                                                       \
        CTESpinLock (_pLowerConn, OldIrqSwap);              \
    }                                                       \
    ASSERT (NBT_VERIFY_HANDLE (_pLowerConn, NBT_VERIFY_LOWERCONN));   \
    ASSERT (_pLowerConn->RefCount);                         \
    ASSERT (++_pLowerConn->References[_RefContextNew]);     \
    ASSERT (_pLowerConn->References[_RefContextOld]--);     \
    if (!_fLowerLockHeld)                                   \
    {                                                       \
        CTESpinFree (_pLowerConn, OldIrqSwap);              \
    }                                                       \
}

#define NBT_DEREFERENCE_NAMEADDR(_pNameAddr, _RefContext, _fLocked) \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pNameAddr=<%x:%d->%d>, <%d:%s>\n",    \
            _pNameAddr,_pNameAddr->RefCount,(_pNameAddr->RefCount-1),__LINE__,__FILE__));                   \
    ASSERT ((_pNameAddr->Verify==LOCAL_NAME) || (_pNameAddr->Verify==REMOTE_NAME));                         \
    NbtDereferenceName(_pNameAddr, _RefContext, _fLocked);  \
}

#define NBT_DEREFERENCE_TRACKER( _pTracker, _fLocked )      \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pTracker=<%x:%d->%d>, <%d:%s>\n",     \
            _pTracker,_pTracker->RefCount,(_pTracker->RefCount-1),__LINE__,__FILE__));                      \
    ASSERT (_pTracker->Verify == NBT_VERIFY_TRACKER);       \
    NbtDereferenceTracker(_pTracker, _fLocked);             \
}

#define NBT_DEREFERENCE_CONNECTION( _pConnEle, _RefContext )\
{                                                           \
    NbtDereferenceConnection(_pConnEle, _RefContext);       \
}

#define NBT_DEREFERENCE_CLIENT( _pClient )                  \
{                                                           \
    NbtDereferenceClient(_pClient);                         \
}

#define NBT_DEREFERENCE_ADDRESS( _pAddressEle, _Context )   \
{                                                           \
    NbtDereferenceAddress(_pAddressEle, _Context);          \
}

//----------------------------------------------------------------------------
//
// CTEExInitializeResource(Resource)
//
/*++
Routine Description:

    Initializes the Resource structure by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExInitializeResource( _Resource )            \
    ExInitializeResourceLite(_Resource)
#else
#define CTEExInitializeResource( _Resource )
#endif

//----------------------------------------------------------------------------
//
// CTEExAcquireResourceExclusive(Resource,Wait)
//
/*++
Routine Description:

    Acquires the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExAcquireResourceExclusive( _Resource, _Wait )   \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(_Resource,_Wait);
#else
#define CTEExAcquireResourceExclusive( _Resource, _Wait )
#endif

//----------------------------------------------------------------------------
//
// CTEExReleaseResource(Resource)
//
/*++
Routine Description:

    Releases the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExReleaseResource( _Resource )       \
    ExReleaseResourceLite(_Resource);               \
    KeLeaveCriticalRegion();
#else
#define CTEExReleaseResource( _Resource )

#endif

//----------------------------------------------------------------------------
//
// PUSH_LOCATION(Spot)
//
/*++
Routine Description:

    This macro is used for debugging the receive code.  It puts a byte value
    into a circular list of byte values so that previous history can be traced
    through the receive code.

Arguments:

    Spot    - the location to put in the list

Return Value:

    None

--*/
#if DBG
extern unsigned char  pLocBuff[256];
extern unsigned char  CurrLoc;
#define PUSH_LOCATION( _Spot) \
{                                  \
    if (++CurrLoc == 256)           \
    {                               \
        CurrLoc = 0;                \
    }                               \
    pLocBuff[CurrLoc] = _Spot;      \
}
#else
#define PUSH_LOCATION( _Spot )
#endif

#if DBG
extern unsigned char  Buff[256];
extern unsigned char  Loc;
#define LOCATION( _Spot) \
{                                  \
    if (++Loc == 256)           \
    {                               \
        Loc = 0;                \
    }                               \
    Buff[Loc] = _Spot;      \
}
#else
#define LOCATION( _Spot )
#endif

//----------------------------------------------------------------------------
//
// CTEQueueForNonDispProcessing( DelayedWorkerRoutine,
//                               pTracker,
//                               pClientContext,
//                               ClientCompletion,
//                               pDeviceContext,
//                               fJointLockHeld) ;
//
/*++
Routine Description:

    This macro queues a request for a callback that can't be performed in
    the current context (such as dispatch processing).

    In NT, this calls NTQueueToWorkerThread.

    As a VxD, we schedule an event that calls the specified routine.

Arguments:

    pTracker - pointer to a tDGRAM_SEND_TRACKING structure (or NULL).
    pClietContext - Context to pass to CallBackRoutine
    ClientCompletion -
    CallBackRoutine - Procedure to call at outside the current context

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#else
#define CTEQueueForNonDispProcessing( DelayedWorkerRoutine,                 \
                                      pTracker,                             \
                                      pClientContext,                       \
                                      ClientCompletion,                     \
                                      pDeviceContext,                       \
                                      fJointLockHeld)                       \
    VxdScheduleDelayedCall( DelayedWorkerRoutine, pTracker, pClientContext, \
                            ClientCompletion, pDeviceContext, TRUE )


//  For Win98, we also need a function which schedules a call
//  outside of a critical section

#define CTEQueueForNonCritNonDispProcessing( DelayedWorkerRoutine           \
                                             pTracker,                      \
                                             pClientContext,                \
                                             ClientCompletion,              \
                                             pDeviceContext)                \
    VxdScheduleDelayedCall( DelayedWorkerRoutine, pTracker, pClientContext, \
                            ClientCompletion, pDeviceContext, FALSE )

#endif

//----------------------------------------------------------------------------
//
// CTESystemUpTime( OUT PTIME    pTime );
//
/*++
Routine Description:

    This macro returns the current system time in clock tics or whatever
    in the value pTime.  For NT this is a Large Integer.  For the VXD it is
    a ULONG.

Arguments:

    pTime

Return Value:

    NONE
--*/
#ifndef VXD
#define CTESystemTime   LARGE_INTEGER
#define CTEQuerySystemTime( _Time )    \
    KeQuerySystemTime( &(_Time) )

// the lower 4 bits appear to be zero always...!!
#define RandomizeFromTime( Time, Mod )  \
    ((Time.LowTime >> 8) % Mod)
#else
#define CTESystemTime    ULONG
#define CTEQuerySystemTime( _Time )    \
    _Time = CTESystemUpTime()
#define RandomizeFromTime( Time, Mod )  \
    ((Time >> 4) % Mod)
#endif

//----------------------------------------------------------------------------
//
// CTEPagedCode();
//
/*++
Routine Description:

    This macro is used in NT to check if the Irql is above zero. All
    coded that is pageable has this macro call to catch any code that might
    be marked as pageable when in fact it isn't.

Arguments:

    none

Return Value:

    NONE
--*/
#ifndef VXD
#define CTEPagedCode() PAGED_CODE()
#else
#define CTEPagedCode()
#ifdef CHICAGO
#ifdef DEBUG
#undef CTEPagedCode
#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#endif
#endif
#endif


//----------------------------------------------------------------------------
//
// CTEMakePageable(Page,Routine);
//
/*++
Routine Description:

    This macro is used in NT to activate teh alloc_text pragma, to put
    a procedure in the pageable code segment.

Arguments:

    none

Return Value:

    NONE
--*/
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#define INIT _ITEXT
// #define PAGE _PTEXT  "vmm.h" has a macro for this.  We override it later.
#endif // CHICAGO


//----------------------------------------------------------------------------
//
// NTSetCancelRoutine(pIrp,Routine);
//
/*++
Routine Description:

    This macro removes the call to set the cancel routine for an irp from the
    VXD environment.

Arguments:

    none

Return Value:

    NONE
--*/
#ifdef VXD
#define NTSetCancelRoutine(_pIrp,_CancelRoutine,_pDeviceContext)   (0)
#define NTCheckSetCancelRoutine(_pIrp,_CancelRoutine,_pDeviceContext) (0)
#define NTClearContextCancel(pWiContext) (0)
#endif

//----------------------------------------------------------------------------
//
// NbtLogEvent(LogEvent,status)
//
/*++
Routine Description:

    This macro removes the call to the log routine for the Vxd environment


Arguments:

    none

Return Value:

    NONE
--*/
#ifdef VXD
#define NbtLogEvent(LogEvent,status,Info)
#endif

//----------------------------------------------------------------------------
//
// CTEGetTimeout(_pTimeout);
//
/*++
Routine Description:

    This macro gets the timeout value for a connect attempt
    VXD environment.

Arguments:

    none

Return Value:

    NONE
--*/
#ifndef VXD
#define CTEGetTimeout(pTimeout,pRetTime) \
{                                       \
    LARGE_INTEGER   _Timeout;                \
    ULONG           Remainder;              \
    _Timeout.QuadPart = -(((PLARGE_INTEGER)pTimeout)->QuadPart); \
    _Timeout = RtlExtendedLargeIntegerDivide(_Timeout,MILLISEC_TO_100NS,&Remainder);\
    *pRetTime = (ULONG)_Timeout.LowPart; \
}
#else
//
//  VXD timeout is a pointer to a ULONG
//
#define CTEGetTimeout(_pTimeout, pRet ) (*pRet = ((ULONG) _pTimeout ? *((PULONG)_pTimeout) : 0 ))
#endif

//----------------------------------------------------------------------------
//
// CTEAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEAttachFsp(_pAttached, _Context)      \
{                                               \
    if (PsGetCurrentProcess() != NbtFspProcess) \
    {                                           \
        KeAttachProcess((PRKPROCESS)NbtFspProcess);\
        *_pAttached = TRUE;                     \
    }                                           \
    else                                        \
    {                                           \
        *_pAttached = FALSE;                    \
    }                                           \
}
#else
#define CTEAttachFsp( _pAttached, _Context )
#endif

//----------------------------------------------------------------------------
//
// CTEAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEDetachFsp(_Attached, _Context)                 \
{                                               \
    if (_Attached)                              \
    {                                           \
        KeDetachProcess();                      \
    }                                           \
}
#else
#define CTEDetachFsp(_Attached, _Context)
#endif

//----------------------------------------------------------------------------
//
// CTEResetIrpPending(PIRP pIrp)
//
/*++
Routine Description:

    This macro resets the irp pending bit in an irp.

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEResetIrpPending(pIrp)      \
{                                               \
    PIO_STACK_LOCATION pIrpsp;                  \
    pIrpsp = IoGetCurrentIrpStackLocation(pIrp);\
    pIrpsp->Control &= ~SL_PENDING_RETURNED;    \
}
#else
#define CTEResetIrpPending( a )
#endif

//----------------------------------------------------------------------------
//
// CTESaveClientSecurity(pClientEle)
//
/*++
Routine Description:

    This macro saves the client thread security context so that it can be used
    later to impersonate the client when a remote lmhosts file is openned.

Arguments:

Return Value:


--*/
#ifndef VXD
#define CTESaveClientSecurity(_pClientEle)                    \
    /*SaveClientSecurity(_pClientEle)*/
#else
#define CTESaveClientSecurity(_pClientEle)
#endif

//----------------------------------------------------------------------------
//
// IMPERSONATE_CLIENT(pClientSecurity)
//
/*++
Routine Description:

    This macro sets an excutive worker thread to impersonate a client
    thread so that remote lmhost files can be openned by that thread.

Arguments:

Return Value:


--*/
#ifndef VXD
#define IMPERSONATE_CLIENT(_pClientSecurity)                    \
        /*SeImpersonateClient((_pClientSecurity),NULL)*/
#else
#define IMPERSONATE_CLIENT(_pClientSecurity)
#endif
//----------------------------------------------------------------------------
//
// STOP_IMPERSONATE_CLIENT(pClientSecurity)
//
/*++
Routine Description:

    This macro sets an excutive worker thread NOT to impersonate a client.

Arguments:

Return Value:


--*/
#ifndef VXD
#define STOP_IMPERSONATE_CLIENT(_pClientSecurity)    \
    /*NtSetInformationThread(PsGetCurrentThread(),ThreadImpersonationToken,NULL,sizeof(HANDLE))*/
#else
#define STOP_IMPERSONATE_CLIENT(_pClientSecurity)
#endif

//----------------------------------------------------------------------------
//
// DELETE_CLIENT_SECURITY(pTracker)
//
/*++
Routine Description:

    This macro deletes a client security.

Arguments:

Return Value:


--*/
#ifndef VXD
#define DELETE_CLIENT_SECURITY(_pTracker)    \
    /*    NtDeleteClientSecurity(_pTracker)*/
#else
#define DELETE_CLIENT_SECURITY(_pTracker)
#endif


#ifdef VXD  // Taken from ntrtl.h (Vxd doesn't include NT Headers)

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
#endif // VXD


#endif // _CTEMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\nbtinfo.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    NbtInfo.h

    This file contains the NBT Info APIs



    FILE HISTORY:
        Johnl       13-Dec-1993     Created

*/

#ifndef _NBTINFO_H_
#define _NBTINFO_H_

VOID AddrChngNotification( PVOID Context,
                           ULONG OldIpAddress,
                           ULONG NewIpAddress,
                           ULONG NewMask ) ;



#endif //!_NBTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\oscfgnbt.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

#ifndef OSCFG_INCLUDED
#define OSCFG_INCLUDED


#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))

//#define net_long(x) (((net_short((x)&0xffff)) << 16) | net_short((((x)&0xffff0000L)>>16)))
#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))
#endif
#define MIN(a,b)    ((a) < (b) ? (a) : (b))
#define MAX(a,b)    ((a) > (b) ? (a) : (b))


#ifdef  VXD
/////////////////////////////////////////////////////////////////////////////
//
// VXD definitions
//
////////////////////////////////////////////////////////////////////////////

#include <stddef.h>

#ifndef CHICAGO

#pragma code_seg("_LTEXT", "LCODE")
#pragma data_seg("_LDATA", "LCODE")

//* pragma bodies for bracketing of initialization code.

#define BEGIN_INIT  code_seg("_ITEXT", "ICODE")
#define BEGIN_INIT_DATA data_seg("_IDATA", "ICODE")
#define END_INIT    code_seg()
#define END_INIT_DATA data_seg()

#else // CHICAGO

#define INNOCUOUS_PRAGMA warning(4:4206)   // Source File is empty

#define BEGIN_INIT      INNOCUOUS_PRAGMA
#define BEGIN_INIT_DATA INNOCUOUS_PRAGMA
#define END_INIT        INNOCUOUS_PRAGMA
#define END_INIT_DATA   INNOCUOUS_PRAGMA

#endif // CHICAGO

#else // VXD
#ifdef NT

//////////////////////////////////////////////////////////////////////////////
//
// NT definitions
//
//////////////////////////////////////////////////////////////////////////////

#include <ntos.h>
#include <zwapi.h>

#define BEGIN_INIT
#define END_INIT

#else // NT

/////////////////////////////////////////////////////////////////////////////
//
// Definitions for additional environments go here
//
/////////////////////////////////////////////////////////////////////////////

#error Environment specific definitions missing

#endif // NT

#endif  // VXD


#endif // OSCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\nbtprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Nbtprocs.h

Abstract:

    This file contains the OS independent function prototypes.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:
        Johnl   05-Apr-1993     Hacked on to support VXD

--*/


#ifndef _NBTPROCS_H_
#define _NBTPROCS_H_

#include "types.h"

#ifndef VXD
    #include <ntprocs.h>
#else
    #include <vxdprocs.h>
#endif

//---------------------------------------------------------------------
//  FROM NAMESRV.C
//
NTSTATUS
NbtRegisterName(
    IN    enum eNbtLocation   Location,
    IN    ULONG               IpAddress,
    IN    PCHAR               pName,
    IN    tNAMEADDR           *pNameAddrIn,
    IN    tCLIENTELE          *pClientEle,
    IN    PVOID               pClientCompletion,
    IN    USHORT              uAddressType,
    IN    tDEVICECONTEXT      *pDeviceContext
    );

NTSTATUS
ReleaseNameOnNet(
    tNAMEADDR           *pNameAddr,
    PCHAR               pScope,
    PVOID               pClientCompletion,
    ULONG               NodeType,
    tDEVICECONTEXT      *pDeviceContext
    );

VOID
NameReleaseDone(
    PVOID               pContext,
    NTSTATUS            status
    );

NTSTATUS
RegOrQueryFromNet(
    IN  BOOL                fReg,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  PCHAR               pName,
    IN  PUCHAR              pScope
    );

NTSTATUS
QueryNameOnNet(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  USHORT                  uType,
    IN  tDGRAM_SEND_TRACKING    *pClientContextTracker,
    IN  PVOID                   pClientCompletion,
    IN  ULONG                   NodeType,
    IN  tNAMEADDR               *pNameAddrIn,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  CTELockHandle           *pJointLockOldIrq
    );

#ifdef MULTIPLE_WINS
NTSTATUS
ContinueQueryNameOnNet(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN PUCHAR                   pName,
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    QueryCompletion,
    IN OUT BOOLEAN              *pfNameReferenced
    );
#endif

VOID
CompleteClientReq(
    COMPLETIONCLIENT        pClientCompletion,
    tDGRAM_SEND_TRACKING    *pTracker,
    NTSTATUS                status
    );

VOID
NodeStatusTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RefreshRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
WakeupRefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RemoteHashTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
SessionKeepAliveTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
IncrementNameStats(
    IN ULONG           StatType,
    IN BOOLEAN         IsNameServer
    );

VOID
SaveBcastNameResolved(
    IN PUCHAR          pName
    );

//---------------------------------------------------------------------
//  FROM NAME.C

VOID
FreeRcvBuffers(
    tCONNECTELE     *pConnEle,
    CTELockHandle   *pOldIrq
    );

NTSTATUS
NbtRegisterCompletion(
    IN  tCLIENTELE *pClientEle,
    IN  NTSTATUS    Status);

NTSTATUS
NbtOpenAddress(
    IN  TDI_REQUEST          *pRequest,
    IN  TA_ADDRESS           *pTaAddress,
    IN  tIPADDRESS           IpAddress,
    IN  tDEVICECONTEXT       *pContext,
    IN  PVOID                pIrp);

NTSTATUS
NbtOpenConnection(
    IN  TDI_REQUEST         *pRequest,
    IN  CONNECTION_CONTEXT  pConnectionContext,
    IN  tDEVICECONTEXT      *pContext);

NTSTATUS
NbtOpenAndAssocConnection(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tCONNECTELE         *pConnEle,
    OUT tLOWERCONNECTION    **ppLowerConn,
    IN  UCHAR               Identifier
    );

NTSTATUS
NbtAssociateAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  tCLIENTELE          *pClientEle,
    IN  PVOID               pIrp);

NTSTATUS
NbtDisassociateAddress(
    IN  TDI_REQUEST         *pRequest
    );

NTSTATUS
NbtCloseAddress(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp);

NTSTATUS
NbtCleanUpAddress(
    IN  tCLIENTELE      *pClientEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtCloseConnection(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp);

NTSTATUS
NbtCleanUpConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    );

VOID
RelistConnection(
    IN  tCONNECTELE *pConnEle
        );

NTSTATUS
CleanupConnectingState(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  CTELockHandle   *OldIrq,
    IN  CTELockHandle   *OldIrq2
    );

NTSTATUS
NbtConnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

tNAMEADDR *
FindNameRemoteThenLocal(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    OUT PULONG                  plNameType
    );

VOID
SessionStartupContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
SessionStartupTimeoutCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    );

VOID
SessionStartupTimeout (
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
QueueCleanup(
    IN  tCONNECTELE     *pConnEle,
    IN  CTELockHandle   *pOldIrqJointLock,
    IN  CTELockHandle   *pOldIrqConnEle
    );

NTSTATUS
NbtDisconnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  ULONG                       Flags,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PTDI_CONNECTION_INFORMATION pReturnInfo,
    IN  PIRP                        pIrp);

NTSTATUS
NbtSend(
        IN  TDI_REQUEST     *pRequest,
        IN  USHORT          Flags,
        IN  ULONG           SendLength,
        OUT LONG            *pSentLength,
        IN  PVOID           *pBuffer,
        IN  tDEVICECONTEXT  *pContext,
        IN  PIRP            pIrp
        );

NTSTATUS
NbtSendDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pSendInfo,
        IN  LONG                        SendLength,
        IN  LONG                        *pSentLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        );

NTSTATUS
SendDgram(
        IN  tNAMEADDR               *pNameAddr,
        IN  tDGRAM_SEND_TRACKING    *pTracker
        );
NTSTATUS

BuildSendDgramHdr(
        IN  ULONG           SendLength,
        IN  tDEVICECONTEXT  *pDeviceContext,
        IN  PCHAR           pSourceName,
        IN  PCHAR           pDestinationName,
        IN  ULONG           NameLength,
        IN  PVOID           pBuffer,
        OUT tDGRAMHDR       **ppDgramHdr,
        OUT tDGRAM_SEND_TRACKING    **ppTracker
        );

VOID
NodeStatusDone(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

NTSTATUS
NbtSendNodeStatus(
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PCHAR                           pName,
    IN  PULONG                          pIpAddrsList,
    IN  PVOID                           ClientContext,
    IN  PVOID                           CompletionRoutine
    );

NTSTATUS
NbtQueryFindName(
    IN  PTDI_CONNECTION_INFORMATION     pInfo,
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PIRP                            pIrp,
    IN  BOOLEAN                         IsIoctl
    );

NTSTATUS
CopyFindNameData(
    IN  tNAMEADDR              *pNameAddr,
    IN  PIRP                   pIrp,
    IN  tDGRAM_SEND_TRACKING   *pTracker
    );

NTSTATUS
NbtListen(
    IN  TDI_REQUEST                 *pRequest,
    IN  ULONG                       Flags,
    IN  TDI_CONNECTION_INFORMATION  *pRequestConnectInfo,
    OUT TDI_CONNECTION_INFORMATION  *pReturnConnectInfo,
    IN  PVOID                       pIrp);

NTSTATUS
NbtAccept(
        IN  TDI_REQUEST                 *pRequest,
        IN  TDI_CONNECTION_INFORMATION  *pAcceptInfo,
        OUT TDI_CONNECTION_INFORMATION  *pReturnAcceptInfo,
        IN  PIRP                        pIrp);

NTSTATUS
NbtReceiveDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pReceiveInfo,
        IN  PTDI_CONNECTION_INFORMATION pReturnedInfo,
        IN  LONG                        ReceiveLength,
        IN  LONG                        *pReceivedLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        );

NTSTATUS
NbtSetEventHandler(
    tCLIENTELE  *pClientEle,
    int         EventType,
    PVOID       pEventHandler,
    PVOID       pEventContext
    );

NTSTATUS
NbtAddEntryToRemoteHashTable(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN USHORT           NameAddFlag,
    IN PUCHAR           Name,
    IN ULONG            IpAddress,
    IN ULONG            Ttl,
    IN UCHAR            name_flags
    );

NTSTATUS
NbtQueryAdapterStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppAdapterStatus,
    OUT PLONG           pSize,
    enum eNbtLocation   Location
    );

NTSTATUS
NbtQueryConnectionList(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppConnList,
    IN OUT PLONG         pSize
    );

VOID
DelayedNbtResyncRemoteCache(
    IN  PVOID                   Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    );

NTSTATUS
NbtQueryBcastVsWins(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppBuffer,
    IN OUT PLONG         pSize
    );

NTSTATUS
NbtNewDhcpAddress(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress,
    ULONG           SubnetMask);

VOID
FreeTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN ULONG                    Actions
    );

NTSTATUS
DatagramDistribution(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  tNAMEADDR               *pNameAddr
    );

VOID
DeleteAddressElement(
    IN  tADDRESSELE    *pAddress
    );

VOID
DeleteClientElement(
    IN  tCLIENTELE    *pClientEle
    );

VOID
ReleaseNameCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

NTSTATUS
DisconnectLower(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                state,
    IN  ULONG                Flags,
    IN  PVOID                Timeout,
    IN  BOOLEAN              Wait
    );

extern
USHORT
GetTransactId(
    );

NTSTATUS
NbtDeleteLowerConn(
    IN tLOWERCONNECTION   *pLowerConn
    );

tDEVICECONTEXT *
GetAndRefNextDeviceFromNameAddr(
    IN  tNAMEADDR               *pNameAddr
    );

tDEVICECONTEXT *
GetDeviceFromInterface(
    IN  tIPADDRESS      IpAddress,
    IN  BOOLEAN         fReferenceDevice
    );

VOID
NbtDereferenceName(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       RefContext,
    IN  BOOLEAN     fLocked
    );

VOID
NbtDereferenceLowerConnection(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               RefContext,
    IN  BOOLEAN             fJointLockHeld
    );

VOID
NbtDereferenceTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN BOOLEAN                  fLocked
    );

NTSTATUS
NbtDereferenceAddress(
    IN tADDRESSELE  *pAddressEle,
    IN ULONG        Context
    );

VOID
NbtDereferenceConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  ULONG           RefContext
    );

VOID
NbtDereferenceClient(
    IN tCLIENTELE   *pClientEle
    );

//---------------------------------------------------------------------
//
// FROM TDICNCT.C
//
NTSTATUS
NbtTdiOpenConnection (
    IN tLOWERCONNECTION     *pLowerConn,
    IN tDEVICECONTEXT       *pDeviceContext
    );

NTSTATUS
NbtTdiAssociateConnection(
    IN  PFILE_OBJECT        pFileObject,
    IN  HANDLE              Handle
    );

NTSTATUS
NbtTdiCloseConnection(
    IN tLOWERCONNECTION   *pLowerConn
    );

NTSTATUS
NbtTdiCloseAddress(
    IN tLOWERCONNECTION   *pLowerConn
    );


//---------------------------------------------------------------------
//
// FROM TDIADDR.C
//
NTSTATUS
NbtTdiOpenAddress (
    OUT PHANDLE             pFileHandle,
    OUT PDEVICE_OBJECT      *pDeviceObject,
    OUT PFILE_OBJECT        *pFileObject,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT               PortNumber,
    IN  ULONG               IpAddress,
    IN  ULONG               Flags
    );

NTSTATUS
NbtTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbtTdiOpenControl (
    IN  tDEVICECONTEXT      *pDeviceContext
    );

//---------------------------------------------------------------------
//
// FROM NBTUTILS.C
//

BOOLEAN
IsEntryInList(
    PLIST_ENTRY     pEntryToFind,
    PLIST_ENTRY     pListToSearch
    );

void
FreeList(
    PLIST_ENTRY pHead,
    PLIST_ENTRY pFreeQ);

void
NbtFreeAddressObj(
    tADDRESSELE *pBlk);

void
NbtFreeClientObj(
    tCLIENTELE    *pBlk);

void
FreeConnectionObj(
    tCONNECTELE    *pBlk);

tCLIENTELE *
NbtAllocateClientBlock(
    tADDRESSELE     *pAddrEle,
    tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtAddPermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtAddPermanentNameNotFound(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

VOID
NbtRemovePermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
ConvertDottedDecimalToUlong(
    IN  PUCHAR               pInString,
    OUT PULONG               IpAddress);

NTSTATUS
NbtInitQ(
    PLIST_ENTRY pListHead,
    LONG        iSizeBuffer,
    LONG        iNumBuffers);

NTSTATUS
NbtInitTrackerQ(
    LONG        iNumBuffers
    );

tDGRAM_SEND_TRACKING *
NbtAllocTracker(
    IN  VOID
    );

NTSTATUS
NbtGetBuffer(
    PLIST_ENTRY         pListHead,
    PLIST_ENTRY         *ppListEntry,
    enum eBUFFER_TYPES  eBuffType);

NTSTATUS
NewInternalAddressFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );

VOID
DeleteInternalAddress(
    IN PTA_NETBT_INTERNAL_ADDRESS pNetBT
    );

NTSTATUS
GetNetBiosNameFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    );

NTSTATUS
ConvertToAscii(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PCHAR            *pScope,
    OUT PULONG           pNameSize
    );

PCHAR
ConvertToHalfAscii(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pScope,
    IN  ULONG            ScopeSize
    );

ULONG
Nbt_inet_addr(
    IN  PCHAR            pName,
    IN  ULONG            Flags
    );

NTSTATUS
BuildQueryResponse(
    IN   USHORT           sNameSize,
    IN   tNAMEHDR         *pNameHdr,
    IN   ULONG            uTtl,
    IN   ULONG            IpAddress,
    OUT  ULONG            uNumBytes,
    OUT  PVOID            pResponse,
    IN   PVOID            pName,
    IN   USHORT           NameType,
    IN   USHORT           RetCode
    );

NTSTATUS
GetTracker(
    OUT tDGRAM_SEND_TRACKING    **ppTracker,
    IN  enum eTRACKER_TYPE      TrackerType);

NTSTATUS
GetIrp(
    OUT PIRP *ppIrp);

VOID
NbtFreeIrp (
    IN PIRP pIrp
    );

ULONG
CountLocalNames(IN tNBTCONFIG  *pNbtConfig
    );

ULONG
CountUpperConnections(
    IN tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
DisableInboundConnections(
    IN   tDEVICECONTEXT *pDeviceContext
    );

ULONG
CloseLowerConnections(
    IN  PLIST_ENTRY  pLowerConnFreeHead
    );

NTSTATUS
ReRegisterLocalNames(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  BOOLEAN         fSendNameRelease
    );

VOID
NbtStopRefreshTimer(
    );

NTSTATUS
strnlen(
    PUCHAR  SrcString,
    LONG    MaxBufferLength,
    LONG    *pStringLen
    );

//---------------------------------------------------------------------
//
// FROM hndlrs.c
//

NTSTATUS
RcvHandlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer
    );

NTSTATUS
Inbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    );
NTSTATUS
Outbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer
    );
NTSTATUS
RejectAnyData(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );

VOID
RejectSession(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               StatusCode,
    IN  ULONG               SessionStatus,
    IN  BOOLEAN             SendNegativeSessionResponse
    );

VOID
GetIrpIfNotCancelled(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    );

NTSTATUS
FindSessionEndPoint(
    IN  VOID UNALIGNED  *pTsdu,
    IN  PVOID           ConnectionContext,
    IN  ULONG           BytesIndicated,
    OUT tCLIENTELE      **ppClientEle,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength
    );

VOID
SessionRetry(
    IN PVOID               pContext,
    IN PVOID               pContext2,
    IN tTIMERQENTRY        *pTimerQEntry
    );

tCONNECTELE *
SearchConnectionList(
    IN  tCLIENTELE           *pClientEle,
    IN  PVOID                pClientContext
    );

NTSTATUS
ConnectHndlrNotOs (
    IN PVOID                pConnectionContext,
    IN LONG                 RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    OUT CONNECTION_CONTEXT  *ppConnectionId
    );

NTSTATUS
DisconnectHndlrNotOs (
    PVOID           EventContext,
    PVOID           ConnectionContext,
    ULONG           DisconnectDataLength,
    PVOID           pDisconnectData,
    ULONG           DisconnectInformationLength,
    PVOID           pDisconnectInformation,
    ULONG           DisconnectIndicators
    );

NTSTATUS
DgramHndlrNotOs(
    IN  PVOID               ReceiveEventContext,
    IN  ULONG               SourceAddrLength,
    IN  PVOID               pSourceAddr,
    IN  ULONG               OptionsLength,
    IN  PVOID               pOptions,
    IN  ULONG               ReceiveDatagramFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              pBytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppRcvBuffer,
    OUT tCLIENTLIST         **ppAddressEle
    );

NTSTATUS
NameSrvHndlrNotOs (
    IN tDEVICECONTEXT     *pDeviceContext,
    IN PVOID              pSrcAddress,
    IN tNAMEHDR UNALIGNED *pNameSrv,
    IN ULONG              uNumBytes,
    IN BOOLEAN            fBroadcast
    );

//---------------------------------------------------------------------
//
// FROM proxy.c
//

NTSTATUS
ReleaseResponseFromNet(
    IN  tDEVICECONTEXT     *pDeviceContext,
    IN  PVOID              pSrcAddress,
    IN  tNAMEHDR UNALIGNED *pNameHdr,
    IN  LONG               NumBytes
    );

NTSTATUS
ProxyQueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

NTSTATUS
ProxyDoDgramDist(
    IN  tDGRAMHDR           UNALIGNED *pDgram,
    IN  DWORD               DgramLen,
    IN  tNAMEADDR           *pNameAddr,
    IN  tDEVICECONTEXT      *pDeviceContext
    );


VOID
ProxyTimerComplFn (
  IN PVOID            pContext,
  IN PVOID            pContext2,
  IN tTIMERQENTRY    *pTimerQEntry
 );

VOID
ProxyRespond (
    IN  tQUERYRESP      *pQuery,
    IN  PUCHAR          pName,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  tNAMEHDR        *pNameHdr,
    IN  ULONG           lNameSize,
    IN  ULONG           SrcAddress,
    IN  PTDI_ADDRESS_IP pAddressIp
 );

//---------------------------------------------------------------------
//
// FROM hashtbl.c
//
NTSTATUS
CreateHashTable(
    tHASHTABLE          **pHashTable,
    LONG                NumBuckets,
    enum eNbtLocation   LocalRemote
    );

#ifdef _PNP_POWER_
VOID
DestroyHashTables(
    );
#endif  // _PNP_POWER_

NTSTATUS
LockAndAddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    );


NTSTATUS
AddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    );

NTSTATUS
DeleteFromHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName
    );

tNAMEADDR *
LockAndFindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    );

tNAMEADDR *
FindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    );

NTSTATUS
ChgStateOfScopedNameInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    DWORD               NewState
    );

NTSTATUS
FindInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    tNAMEADDR           **pNameAddress
    );

NTSTATUS
FindNoScopeInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    tNAMEADDR           **pNameAddress
    );

NTSTATUS
UpdateHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               IpAddress,
    BOOLEAN             bGroup,
    tNAMEADDR           **ppNameAddr
    );

//---------------------------------------------------------------------
//
// FROM timer.c
//

NTSTATUS
InitTimerQ(
    VOID
    );

#ifdef _PNP_POWER_
NTSTATUS
DestroyTimerQ(
    );
#endif  // _PNP_POWER_

NTSTATUS
InterlockedCallCompletion(
    IN  tTIMERQENTRY    *pTimer,
    IN  NTSTATUS        status
    );

NTSTATUS
StartTimer(
    IN  PVOID           CompletionRoutine,
    IN  ULONG           DeltaTime,
    IN  PVOID           Context,
    IN  PVOID           Context2,
    IN  PVOID           ContextClient,
    IN  PVOID           CompletionClient,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tTIMERQENTRY    **ppTimerEntry,
    IN  USHORT          Retries,
    BOOLEAN             fLocked);

NTSTATUS
StopTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    OUT COMPLETIONCLIENT *pClient,
    OUT PVOID            *ppContext
    );


VOID
DelayedNbtStartWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    );

VOID
DelayedNbtStopWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    );

//---------------------------------------------------------------------
//
// FROM udpsend.c
//

NTSTATUS
UdpSendQueryNs(
    PCHAR               pName,
    PCHAR               pScope
    );
NTSTATUS
UdpSendQueryBcast(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  tDGRAM_SEND_TRACKING    *pSentList
    );
NTSTATUS
UdpSendRegistrationNs(
    PCHAR               pName,
    PCHAR               pScope
    );

NTSTATUS
UdpSendNSBcast(
    IN tNAMEADDR             *pNameAddr,
    IN PCHAR                 pScope,
    IN tDGRAM_SEND_TRACKING  *pSentList,
    IN PVOID                 pCompletionRoutine,
    IN PVOID                 pClientContext,
    IN PVOID                 pClientCompletion,
    IN ULONG                 Retries,
    IN ULONG                 Timeout,
    IN enum eNSTYPE          eNsType,
	IN BOOL					 SendFlag
    );

VOID
NameDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    );

NTSTATUS
UdpSendResponse(
    IN  ULONG                   lNameSize,
    IN  tNAMEHDR   UNALIGNED    *pNameHdrIn,
    IN  tNAMEADDR               *pNameAddr,
    IN  PTDI_ADDRESS_IP         pDestIpAddress,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  ULONG                   Rcode,
    IN  enum eNSTYPE            NsType,
    IN  CTELockHandle           OldIrq
    );

NTSTATUS
UdpSendDatagram(
    IN  tDGRAM_SEND_TRACKING       *pDgramTracker,
    IN  ULONG                      IpAddress,
    IN  PVOID                      pCompletionRoutine,
    IN  PVOID                      CompletionContext,
    IN  USHORT                     Port,
    IN  ULONG                      Service
    );

PVOID
CreatePdu(
    IN  PCHAR       pName,
    IN  PCHAR       pScope,
    IN  ULONG       IpAddress,
    IN  USHORT      NameType,
    IN enum eNSTYPE eNsType,
    OUT PVOID       *pHdrs,
    OUT PULONG      pLength,
    IN  tDGRAM_SEND_TRACKING    *pTracker
    );

NTSTATUS
TcpSessionStart(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  ULONG                      IpAddress,
    IN  tDEVICECONTEXT             *pDeviceContext,
    IN  PVOID                      pCompletionRoutine,
    IN  ULONG                      Port
    );

NTSTATUS
TcpSendSessionResponse(
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  ULONG                      lStatusCode,
    IN  ULONG                      lSessionStatus
    );

NTSTATUS
TcpSendSession(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  tLOWERCONNECTION           *LowerConn,
    IN  PVOID                      pCompletionRoutine
    );

NTSTATUS
SendTcpDisconnect(
    IN  tLOWERCONNECTION       *pLowerConnId
    );

NTSTATUS
TcpDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  PVOID                      Timeout,
    IN  ULONG                      Flags,
    IN  BOOLEAN                    Wait
    );

VOID
FreeTrackerOnDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker
    );

VOID
QueryRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
DisconnectDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);


//---------------------------------------------------------------------
//
// FROM tdiout.c
//
NTSTATUS
TdiSendDatagram(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PTDI_CONNECTION_INFORMATION     pSendDgramInfo,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tDGRAM_SEND_TRACKING            *pDgramTracker
    );

NTSTATUS
TdiConnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  ULONG_PTR                       lTimeout,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    OUT PVOID                           pIrp
    );
NTSTATUS
TdiSend(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  USHORT                          sFlags,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tBUFFER                         *pSendBuffer,
    IN  ULONG                           Flags
    );

NTSTATUS
TdiDisconnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PVOID                           lTimeout,
    IN  ULONG                           Flags,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PCTE_IRP                        pClientIrp,
    IN  BOOLEAN                         Wait
    );

//---------------------------------------------------------------------
//
// FROM inbound.c
//
NTSTATUS
QueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags,
    IN  BOOLEAN             fBroadcast
    );

NTSTATUS
RegResponseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

NTSTATUS
CheckRegistrationFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

NTSTATUS
NameReleaseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

NTSTATUS
WackFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

VOID
SetupRefreshTtl(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  tNAMEADDR           *pNameAddr,
    IN  LONG                lNameSize
    );

#ifdef MULTIPLE_WINS
BOOLEAN
IsNameServerForDevice(
    IN  ULONG               SrcAddress,
    IN  tDEVICECONTEXT      *pDevContext
    );
#endif

BOOLEAN
SrcIsNameServer(
    IN  ULONG                SrcAddress,
    IN  USHORT               SrcPort
    );

VOID
SwitchToBackup(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

BOOLEAN
SrcIsUs(
    IN  ULONG                SrcAddress
    );

NTSTATUS
FindOnPendingList(
    IN  PUCHAR                  pName,
    IN  tNAMEHDR UNALIGNED      *pNameHdr,
    IN  BOOLEAN                 DontCheckTransactionId,
    IN  ULONG                   BytesToCompare,
    OUT tNAMEADDR               **ppNameAddr
    );


//---------------------------------------------------------------------
//
// FROM init.c
//
NTSTATUS
InitNotOs(
    void
    ) ;

NTSTATUS
InitTimersNotOs(
    void
    );

NTSTATUS
StopInitTimers(
    void
    );

VOID
ReadParameters(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

VOID
ReadParameters2(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

//---------------------------------------------------------------------
//
// FROM parse.c
//
unsigned long
LmGetIpAddr (
    IN PUCHAR    path,
    IN PUCHAR    target,
    IN CHAR      RecurseDepth,
    OUT BOOLEAN  *bFindName
    );

VOID
RemovePreloads (
         );

VOID
SetNameState(
    IN tNAMEADDR    *pNameAddr,
    IN  PULONG      pIpList,
    IN  BOOLEAN     IpAddrResolved
    );

LONG
PrimeCache(
    IN  PUCHAR  path,
    IN  PUCHAR   ignored,
    IN  CHAR     RecurseDepth,
    OUT BOOLEAN *ignored2
    );

NTSTATUS
NtProcessLmHSvcIrp(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PVOID           *pBuffer,
    IN  LONG            Size,
    IN  PCTE_IRP        pIrp,
    IN  enum eNbtLmhRequestType RequestType
    );

VOID
NbtCompleteLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  ULONG                   *IpList,
    IN  enum eNbtLmhRequestType RequestType,
    IN  ULONG                   lNameLength,
    IN  PWSTR                   pwsName,
    IN  BOOLEAN                 IpAddrResolved
    );

NTSTATUS
NbtProcessLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  enum eNbtLmhRequestType RequestType
    );

VOID
StartLmHostTimer(
    NBT_WORK_ITEM_CONTEXT   *pContext,
    IN BOOLEAN              fLockedOnEntry
    );

NTSTATUS
LmHostQueueRequest(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  PVOID                   pDeviceContext
    );

VOID
TimeoutLmHRequests(
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  BOOLEAN             fLocked,
    IN  CTELockHandle       *pJointLockOldIrq
    );

tNAMEADDR *
FindInDomainList (
    IN PUCHAR           pName,
    IN PLIST_ENTRY      pDomainHead
    );

//---------------------------------------------------------------------
//
// Delayed (Non-Dpc) Worker routines:
//
typedef
VOID
(*PNBT_WORKER_THREAD_ROUTINE)(
    tDGRAM_SEND_TRACKING    *pTracker,
    PVOID                   pClientContext,
    PVOID                   ClientCompletion,
    tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\hndlrs.c
//
VOID
DelayedAllocLowerConn(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedAllocLowerConnSpecial(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedCleanupAfterDisconnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\Inbound.c
//
VOID
ExtractServerNameCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    );

VOID
CopyNodeStatusResponseCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    );

//
// In nbt\Name.c
//
VOID
DelayedReConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedSendDgramDist (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused1,
    IN  tDEVICECONTEXT          *Unused2
    );

VOID
DelayedWipeOutLowerconn(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\NameSrv.c
//
VOID
DelayedNextRefresh(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedRefreshBegin(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedSessionKeepAlive(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\NbtUtils.c
//
VOID
DelayedFreeAddrObj(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\parse.c
//
VOID
DelayedScanLmHostFile (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

#ifndef VXD
//
// In nt\NtIsol.c
//
NTSTATUS
DelayedNbtProcessConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nt\NtUtil.c
//
VOID
DelayedNbtDeleteDevice(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );
#endif  // !VXD

#define MIN(x,y)    (((x) < (y)) ? (x) : (y))
#define MAX(x,y)    (((x) > (y)) ? (x) : (y))

int check_unicode_string(IN PUNICODE_STRING str);

NTSTATUS
PickBestAddress(
    IN  tNAMEADDR       *pNameAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tIPADDRESS      *pIpAddress
    );

#endif // _NBTPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\ntprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    NTProcs.c

Abstract:


    This file contains the function prototypes that are specific to the NT
    portion of the NBT driver.

Author:

    Johnl   29-Mar-1993     Created

Revision History:

--*/



#ifndef VXD

//---------------------------------------------------------------------
//
//  FROM DRIVER.C
//
NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    );


USHORT
GetDriverName(
    IN  PFILE_OBJECT pfileobj,
    OUT PUNICODE_STRING name
    );

int
shortreply(
    IN PIRP     pIrp,
    IN int      status,
    IN int      nbytes
    );

//---------------------------------------------------------------------
//
//  FROM NTISOL.C
//
NTSTATUS
NTOpenControl(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTOpenAddr(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea);

NTSTATUS
NTOpenConnection(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea);

VOID
NTSetFileObjectContexts(
    IN  PIRP            pIrp,
    IN  PVOID           FsContext,
    IN  PVOID           FsContext2);

VOID
NTCompleteIOListen(
    IN  tCLIENTELE        *pClientEle,
    IN  NTSTATUS          Status);

VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength);

VOID
NTCompleteRegistration(
    IN  tCLIENTELE        *pClientEle,
    IN  NTSTATUS          Status);

NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCloseAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

VOID
NTClearFileObjectContext(
    IN  PIRP            pIrp
    );

NTSTATUS
NTCloseConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress);

NTSTATUS
NTCheckSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress);

NTSTATUS
NTCleanUpAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCleanUpConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

VOID
NbtCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelListen(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP Irp
    );

VOID
NbtCancelRcvDgram(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelDgramSend(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NTAccept(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTDisAssociateAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTConnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTDisconnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTListen(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);


NTSTATUS
NTQueryInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTReceive(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTReceiveDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSend(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetEventHandler(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP                   pIrp,
    IN  PVOID                  CancelRoutine,
    IN  tDEVICECONTEXT         *pDeviceContext
    );

NTSTATUS
NbtSetCancelRoutine(
    IN  PIRP                   pIrp,
    IN  PVOID                  CancelRoutine,
    IN  tDEVICECONTEXT         *pDeviceContext
    );

VOID
NbtCancelSession(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelWaitForLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NTSendSession(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  tLOWERCONNECTION      *pLowerConn,
    IN  PVOID                 pCompletion
    );

VOID
NTSendDgramNoWindup(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  ULONG                 IpAddress,
    IN  PVOID                 pCompletion);

NTSTATUS
NTQueueToWorkerThread(
    IN OUT NBT_WORK_ITEM_CONTEXT * pContext,
    IN  PVOID                   DelayedWorkerRoutine,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 fJointLockHeld
    );

#ifdef _PNP_POWER_
VOID
NTExecuteWorker(
    IN  PVOID     pContextInfo
    );
#endif

VOID
SecurityDelete(
    IN  PVOID     pContext
    );

NTSTATUS
NbtSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN ULONG        ToiType,
    IN ULONG        InfoBufferValue
    );

NTSTATUS
DispatchIoctls(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp);

NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    );

VOID
NTClearContextCancel(
    IN NBT_WORK_ITEM_CONTEXT    *pContext
    );

VOID
NbtCancelFindName(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );


//---------------------------------------------------------------------
//
// FROM TDIADDR.C
//

NTSTATUS
NbtProcessIPRequest(
    IN ULONG        IPControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    );

//---------------------------------------------------------------------
//
// FROM NTUTIL.C
//

#ifdef _PNP_POWER_
NTSTATUS
NbtAllocAndInitDevice(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    );
#endif  // _PNP_POWER_

NTSTATUS
NbtCreateDeviceObject(
    PUNICODE_STRING     pBindName,
    PUNICODE_STRING     pExportName,
    tADDRARRAY          *pAddrs,
    tDEVICECONTEXT      **ppDeviceContext,
    enum eNbtDevice     DeviceType
    );

VOID
NbtDeleteDevice(
    IN  PVOID       pContext
    );

BOOLEAN
NBT_REFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    ULONG               ReferenceContext,
    IN BOOLEAN          fLocked
    );

VOID
NBT_DEREFERENCE_DEVICE(
    IN  tDEVICECONTEXT  *pDeviceContext,
    ULONG               ReferenceContext,
    IN BOOLEAN          fLocked
    );

tDEVICECONTEXT *
GetDeviceWithIPAddress(
    tIPADDRESS          IpAddress
    );

NTSTATUS
NbtProcessDhcpRequest(
    tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
ConvertToUlong(
    IN  PUNICODE_STRING      pucAddress,
    OUT ULONG                *pulValue);


NTSTATUS
NbtCreateAddressObjects(
    IN  ULONG                IpAddress,
    IN  ULONG                SubnetMask,
    OUT tDEVICECONTEXT       *pDeviceContext);

VOID
NbtGetMdl(
    PMDL    *ppMdl,
    enum eBUFFER_TYPES eBuffType);

NTSTATUS
NbtInitMdlQ(
    PSINGLE_LIST_ENTRY pListHead,
    enum eBUFFER_TYPES eBuffType);

NTSTATUS
NTZwCloseFile(
    IN  HANDLE      Handle
    );


NTSTATUS
NTReReadRegistry(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN BOOL bDoRefresh
    );

NTSTATUS
NbtInitIrpQ(
    PLIST_ENTRY pListHead,
    int iNumBuffers);

NTSTATUS
NbtLogEvent(
    IN ULONG             EventCode,
    IN NTSTATUS          Status,
    IN ULONG             Location
    );

VOID
DelayedNbtLogDuplicateNameEvent(
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

NTSTATUS
SaveClientSecurity(
    IN  tDGRAM_SEND_TRACKING      *pTracker
    );

VOID
NtDeleteClientSecurity(
    IN  tDGRAM_SEND_TRACKING    *pTracker
    );

VOID
LogLockOperation(
    char          operation,
    PKSPIN_LOCK   PSpinLock,
    KIRQL         OldIrql,
    KIRQL         NewIrql,
    char         *File,
    int           Line
    );
StrmpInitializeLockLog(
    VOID
    );
VOID
PadEntry(
    char *EntryPtr
    );

VOID
DelayedNbtCloseFileHandles(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    );

NTSTATUS
CloseAddressesWithTransport(
    IN  tDEVICECONTEXT  *pDeviceContext
        );

PVOID
CTEAllocMemDebug(
    IN  ULONG   Size,
    IN  PVOID   pBuffer,
    IN  UCHAR   *File,
    IN  ULONG   Line
    );

VOID
AcquireSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN PKIRQL          pOldIrq,
    IN INT             LineNumber
    );

VOID
FreeSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN KIRQL           OldIrq,
    IN INT             LineNumber
    );

VOID
AcquireSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    );

VOID
FreeSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    );

VOID
GetDgramMdl(
    OUT PMDL  *ppMdl
    );

NTSTATUS
NbtDestroyDevice(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN BOOLEAN          fWait
    );


//---------------------------------------------------------------------
//
// FROM REGISTRY.C
//
NTSTATUS
NbtReadRegistry(
    OUT tDEVICES        **ppBindDevices,
    OUT tDEVICES        **ppExportDevices,
    OUT tADDRARRAY      **ppAddrArray
    );

VOID
NbtReadRegistryCleanup(         // release resources allocated by NbtReadRegistry
    IN tDEVICES        **ppBindDevices,
    IN tDEVICES        **ppExportDevices,
    IN tADDRARRAY      **ppAddrArray
    );

NTSTATUS
ReadNameServerAddresses (
    IN  HANDLE      NbtConfigHandle,
    IN  tDEVICES    *BindDevices,
    IN  ULONG       NumberDevices,
    OUT tADDRARRAY  **ppAddrArray
    );

NTSTATUS
GetIPFromRegistry(
    IN  PUNICODE_STRING         pucBindDevice,
    OUT tIPADDRESS              *pIpAddresses,
    OUT tIPADDRESS              *pSubnetMask,
    IN  ULONG                   MaxIpAddresses,
    OUT ULONG                   *pNumIpAddresses,
    IN  enum eNbtIPAddressType  IPAddressType
    );

NTSTATUS
ReadElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    );

NTSTATUS
NTReadIniString (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       Key,
    OUT PUCHAR      *ppString
    );

ULONG
NbtReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

NTSTATUS
NTGetLmHostPath(
    OUT PUCHAR *ppPath
    );

NTSTATUS
NbtParseMultiSzEntries(
    IN  PWSTR       StartBindValue,
    IN  PWSTR       EndBindValue,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,
    OUT ULONG       *pNumDevices
    );

//---------------------------------------------------------------------
//
// FROM tdihndlr.c
//
NTSTATUS
Normal(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
FillIrp(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
IndicateBuffer(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
PartialRcv(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
TdiReceiveHandler (
    IN  PVOID           ReceiveEventContext,
    IN  PVOID           ConnectionContext,
    IN  USHORT          ReceiveFlags,
    IN  ULONG           BytesIndicated,
    IN  ULONG           BytesAvailable,
    OUT PULONG          BytesTaken,
    IN  PVOID           Tsdu,
    OUT PIRP            *IoRequestPacket
    );

NTSTATUS
PassRcvToTransport(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnectEle,
    IN PVOID                pIoRequestPacket,
    IN PULONG               pRcvLength
    );

NTSTATUS
CompletionRcv(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NtBuildIrpForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    );

NTSTATUS
SetEventHandler (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PFILE_OBJECT         FileObject,
    IN ULONG                EventType,
    IN PVOID                EventHandler,
    IN PVOID                Context
    );

NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP         Irp
    );

NTSTATUS
TdiConnectHandler (
    IN PVOID                pConnectEventContext,
    IN int                  RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pConnectionContext,
    OUT PIRP                *ppAcceptIrp
    );

NTSTATUS
TdiDisconnectHandler (
    PVOID            EventContext,
    PVOID            ConnectionContext,
    ULONG            DisconnectDataLength,
    PVOID            DisconnectData,
    ULONG            DisconnectInformationLength,
    PVOID            DisconnectInformation,
    ULONG            DisconnectIndicators
    );
NTSTATUS
TdiRcvDatagramHandler(
    IN  PVOID                pDgramEventContext,
    IN  int                  SourceAddressLength,
    IN  PVOID                pSourceAddress,
    IN  int                  OptionsLength,
    IN  PVOID                pOptions,
    IN  ULONG                ReceiveDatagramFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN  PVOID                pTsdu,
    OUT PIRP                 *pIoRequestPacket
    );
NTSTATUS
TdiRcvNameSrvHandler(
    IN PVOID                 pDgramEventContext,
    IN int                   SourceAddressLength,
    IN PVOID                 pSourceAddress,
    IN int                   OptionsLength,
    IN PVOID                 pOptions,
    IN ULONG                 ReceiveDatagramFlags,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,
    OUT PIRP                 *pIoRequestPacket
    );
NTSTATUS
TdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    );

NTSTATUS
CompletionRcvDgram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
MakePartialMdl (
    IN tCONNECTELE      *pConnEle,
    IN PIRP             pIrp,
    IN ULONG            ToCopy
    );

NTSTATUS
OutOfRsrcKill(
    OUT tLOWERCONNECTION    *pLowerConn);

VOID
CopyToStartofIndicate (
    IN tLOWERCONNECTION       *pLowerConn,
    IN ULONG                  DataTaken
    );

//---------------------------------------------------------------------
//
// FROM tdicnct.c
//
NTSTATUS
CreateDeviceString(
    IN  PWSTR               AppendingString,
    IN OUT PUNICODE_STRING  pucDevice
    );


//---------------------------------------------------------------------
//
// FROM winsif.c
//
NTSTATUS
NTOpenWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tIPADDRESS      IpAddress
    );

NTSTATUS
NTCleanUpWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    );

NTSTATUS
NTCloseWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    );

NTSTATUS
RcvIrpFromWins (
    IN  PCTE_IRP        pIrp
    );

NTSTATUS
PassNamePduToWins (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes
    );

NTSTATUS
WinsSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  BOOLEAN         MustSend);

NTSTATUS
WinsRegisterName(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  tNAMEADDR      *pNameAddr,
    IN  PUCHAR         pScope,
    IN  enum eNSTYPE   eNsType
    );

NTSTATUS
WinsSetInformation(
    IN  tWINS_INFO      *pWins,
    IN  tWINS_SET_INFO  *pWinsSetInfo
    );

//---------------------------------------------------------------------
//
// FROM ntpnp.c
//
VOID
NbtNotifyTdiClients(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  enum eTDI_ACTION    Action
    );

#ifdef _NETBIOSLESS
tDEVICECONTEXT *
NbtCreateSmbDevice(
    );
#endif

NTSTATUS
NbtDeviceAdd(
    PUNICODE_STRING pucBindString
    );

NTSTATUS
NbtDeviceRemove(
    PUNICODE_STRING pucBindString
    );

VOID
TdiAddressArrival(
    IN  PTA_ADDRESS         Addr,
    IN  PUNICODE_STRING     pDeviceName,
    IN  PTDI_PNP_CONTEXT    Context
    );

VOID
TdiAddressDeletion(
    IN  PTA_ADDRESS         Addr,
    IN  PUNICODE_STRING     pDeviceName,
    IN  PTDI_PNP_CONTEXT    Context
    );

VOID
TdiBindHandler(
    IN  TDI_PNP_OPCODE      PnPOpcode,
    IN  PUNICODE_STRING     DeviceName,
    IN  PWSTR               MultiSZBindList
    );


NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     DeviceName,
    IN  PNET_PNP_EVENT      PnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    );

VOID
NbtPnPPowerComplete(
    IN PNET_PNP_EVENT  NetEvent,
    IN NTSTATUS        ProviderStatus
    );

NTSTATUS
CheckSetWakeupPattern(
    tDEVICECONTEXT  *pDeviceContext,
    PUCHAR          pName,
    BOOLEAN         RequestAdd
    );


NTSTATUS
NbtCreateNetBTDeviceObject(
    PDRIVER_OBJECT       DriverObject,
    tNBTCONFIG           *pConfig,
    PUNICODE_STRING      RegistryPath
    );

NTSTATUS
NbtNtPNPInit(
        VOID
    );

VOID
NbtFailedNtPNPInit(
        VOID
    );

NTSTATUS
NbtAddressAdd(
    IN  ULONG           IpAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PUNICODE_STRING pucBindString
    );

NTSTATUS
NbtAddNewInterface (
    IN  PIRP            pIrp,
    IN  PVOID           *pBuffer,
    IN  ULONG            Size
    );

VOID
NbtAddressDelete(
    ULONG   IpAddr
    );

tDEVICECONTEXT      *
NbtFindAndReferenceDevice(
    PUNICODE_STRING      pucBindName,
    BOOLEAN              fNameIsBindName
    );

#if FAST_DISP
NTSTATUS
NbtQueryIpHandler(
    IN  PFILE_OBJECT    FileObject,
    IN  ULONG           IOControlCode,
    OUT PVOID           *EntryPoint
    );
#endif

//---------------------------------------------------------------------
//
// FROM AutoDial.c
//
VOID
NbtAcdBind(
    );

VOID
NbtAcdUnbind(
    );

NTSTATUS
LookupDeviceInRegistry(
    IN PUNICODE_STRING pBindName,
    OUT tADDRARRAY* pAddrs,
    OUT PUNICODE_STRING pExportName);

void SetNodeType(void);

void NbtUpBootCounter(void);

void NbtDownBootCounter(void);

NTSTATUS
NbtSetSmbBindingInfo2(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  NETBT_SMB_BIND_REQUEST  *pSmbRequest
    );

#endif  // !VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\timer.h ===
//
//
//  timer.h
//
//  This file contains the typedefinitions for the timer code


#ifndef __TIMERNBT_H
#define __TIMERNBT_H

// to convert a millisecond time to 100ns time
//
#define MILLISEC_TO_100NS       10000
// the completion routine that the client must define
typedef
    VOID
        (*COMPLETIONROUTINE)(
                IN  PVOID,      // context
                IN  PVOID,      // context2
                IN  PVOID);     // timerqentry
typedef
    VOID
        (*COMPLETIONCLIENT)(
                IN  PVOID,
                IN  NTSTATUS);

// Timer Queue Entry - this entry looks after a timer event.  It tracks who
// should be called when the timeout occurs, the time in the future of the
// timout, and a context value.
typedef struct
{
    LIST_ENTRY          Linkage;
    ULONG               Verify;
    USHORT              Retries;    // number of times to restart the timer
    BOOLEAN             fIsWakeupTimer;
    UCHAR               RefCount;   // to tell if the timer is expiring or not

    ULONG               DeltaTime;
    PVOID               *pDeviceContext;
    COMPLETIONROUTINE   TimeoutRoutine;
    PVOID               Context;

    PVOID               Context2;
    PVOID               ClientContext;
    COMPLETIONCLIENT    ClientCompletion;
    PVOID               pCacheEntry;        // entry in Remote or local cache

    HANDLE              WakeupTimerHandle;
    CTETimer            VxdTimer ;

    USHORT              Flags;      // to tell the timing system to restart the timer again
}tTIMERQENTRY;

// Flag bits for tTIMERQENTRY
#define TIMER_RESTART       0x0001
// to differentiate the broadcast timeouts from the timouts to the Name Service
#define TIMER_MNODEBCAST    0x0002
#define TIMER_DOING_EXPIRY  0x0004
#define TIMER_NOT_STARTED   0x0008
#define TIMER_RETIMED       0x0010  // timeout has changed, restart timer without any processing

// The timer Q itself
typedef struct
{
    LIST_ENTRY  ActiveHead;
    NPAGED_LOOKASIDE_LIST   LookasideList;
    BOOLEAN     TimersInitialized;
} tTIMERQ;

//
// Function Prototype -  this function is only called locally to this file
//

//
//  TimerExpiry routine - Called by kernel upon timer expiration.  Note that
//      DeferredContext is the only argument used and must be named/used the
//      same between NT and WFW.
//
VOID
TimerExpiry(
#ifndef VXD
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
#else
    IN  CTEEvent * pCTEEvent,
    IN  PVOID      DeferredContext
#endif
    ) ;

//
//  ExpireTimer routine - Called to stop the current timer and call
//  the Timeout routine
//
VOID
ExpireTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    IN  CTELockHandle   *OldIrq1
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\nbtnt.h ===
//
//  NBTNT.H
//
//  This file contains common header definitions for NBT in the NT
//  environment
//
//

#ifndef _NBT_H
#define _NBT_H

#ifndef VXD
#include <ntosp.h>
#include <zwapi.h>
//#include <status.h>
//#include <ntstatus.h>
#include <tdikrnl.h>
#include <tdi.h>
#include <windef.h>
#include <stdio.h>
#include <nb30.h>

#else

#include <oscfgnbt.h>
#include <cxport.h>
#define  __int64 double
#include <windef.h>
#include <nb30.h>

//
//  These definitions work around NTisms found in various difficult to change
//  places.
//
typedef ULONG NTSTATUS ;
typedef PNCB  PIRP ;
typedef PVOID PDEVICE_OBJECT ;

#include <ctemacro.h>
#include <tdi.h>

//
//  These are needed because we include windef.h rather then
//  ntddk.h, which end up not being defined
//
#define STATUS_NETWORK_NAME_DELETED     ((NTSTATUS)0xC00000CAL)
#define STATUS_INVALID_BUFFER_SIZE      ((NTSTATUS)0xC0000206L)
#define STATUS_CONNECTION_DISCONNECTED  ((NTSTATUS)0xC000020CL)
#define STATUS_CANCELLED                ((NTSTATUS)0xC0000120L)
#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0xC0000001L)

#define STATUS_TOO_MANY_COMMANDS        ((NTSTATUS)0xC00000C1L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_SHARING_VIOLATION        ((NTSTATUS)0xC0000043L)
#define STATUS_DUPLICATE_NAME           ((NTSTATUS)0xC00000BDL)
#define STATUS_BAD_NETWORK_PATH         ((NTSTATUS)0xC00000BEL)
#define STATUS_REMOTE_NOT_LISTENING     ((NTSTATUS)0xC00000BCL)
#define STATUS_CONNECTION_REFUSED       ((NTSTATUS)0xC0000236L)
#define STATUS_INVALID_PARAMETER        ((NTSTATUS)0xC000000DL)
#define STATUS_UNEXPECTED_NETWORK_ERROR ((NTSTATUS)0xC00000C4L)
#define STATUS_NOT_SUPPORTED            ((NTSTATUS)0xC00000BBL)

#define STATUS_INVALID_HANDLE           ((NTSTATUS)0xC0000008L)
#define STATUS_INVALID_DEVICE_REQUEST   ((NTSTATUS)0xC0000010L)

#define STATUS_INVALID_PARAMETER_6      ((NTSTATUS)0xC00000F4L)

//
//  The following functions are used by NBT.  They are defined in the NT kernel
//  TDI stuff which we are trying to avoid.
//

typedef
NTSTATUS
(*PTDI_IND_CONNECT)(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext
    )
    ;

NTSTATUS
TdiDefaultConnectHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext
    );

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it. Note that
// this is a change from TDI V1, which indicated only when the remote caused
// a disconnection. Any non-directed disconnection will cause this indication.
//

typedef
NTSTATUS
(*PTDI_IND_DISCONNECT)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
TdiDefaultDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
// For NetBIOS-type providers, this indication is also delivered when a name
// in conflict or duplicate name occurs.
//

typedef
NTSTATUS
(*PTDI_IND_ERROR)(
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );

NTSTATUS
TdiDefaultErrorHandler (
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );

//
// TDI_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// TDI_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_DATAGRAM)(
    IN PVOID TdiEventContext,       // the event context
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_EXPEDITED)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvExpeditedHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PTDI_IND_SEND_POSSIBLE)(
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

NTSTATUS
TdiDefaultSendPossibleHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

#endif //VXD

#define FILE_DEVICE_NBT  0x32

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

__inline long
htonl(long x)
{
	return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L) |
                        (((x) << 24) & 0xFF000000L));
}
#endif
#define ntohs(x)        htons(x)
#define ntohl(x)        htonl(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\vxddebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions.


    FILE HISTORY:
        KeithMo     20-Sep-1993 Created.
        MohsinA,    20-Nov-96.  Robust, added dangling else fix.
*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#ifdef DBG_PRINT
#include <stdarg.h>
#endif  // DBG_PRINT


#ifdef DEBUG

#define DBG_MEMALLOC_VERIFY  0x0BEEFCAFE

typedef struct {
    LIST_ENTRY    Linkage;          // to keep linked list of allocated blocks
    DWORD         Verify;           // our signature
    DWORD         ReqSize;          // original size as requested by caller
    DWORD         Owner[4];         // stack trace 4 deep (of ret.addrs)
} DbgMemBlkHdr;

LIST_ENTRY  DbgMemList;
ULONG       DbgLeakCheck;

//
//  Debug output control flags.
//

#define VXD_DEBUG_INIT                 0x00000001L
#define VXD_DEBUG_SOCKET               0x00000002L
#define VXD_DEBUG_MISC                 0x00000004L
#define VXD_DEBUG_BIND                 0x00000008L
#define VXD_DEBUG_ACCEPT               0x00000010L
#define VXD_DEBUG_CONNECT              0x00000020L
#define VXD_DEBUG_LISTEN               0x00000040L
#define VXD_DEBUG_RECV                 0x00000080L
#define VXD_DEBUG_SEND                 0x00000100L
#define VXD_DEBUG_SOCKOPT              0x00000200L
#define VXD_DEBUG_CONFIG               0x00000400L
#define VXD_DEBUG_CONNECT_EVENT        0x00000800L
#define VXD_DEBUG_DISCONNECT_EVENT     0x00001000L
#define VXD_DEBUG_ERROR_EVENT          0x00002000L
#define VXD_DEBUG_RECV_EVENT           0x00004000L
#define VXD_DEBUG_RECV_DATAGRAM_EVENT  0x00008000L
#define VXD_DEBUG_RECV_EXPEDITED_EVENT 0x00010000L

// #define VXD_DEBUG_                     0x00020000L
// #define VXD_DEBUG_                     0x00040000L
// #define VXD_DEBUG_                     0x00080000L
// #define VXD_DEBUG_                     0x00100000L
// #define VXD_DEBUG_                     0x00200000L
// #define VXD_DEBUG_                     0x00400000L
// #define VXD_DEBUG_                     0x00800000L
// #define VXD_DEBUG_                     0x01000000L
// #define VXD_DEBUG_                     0x02000000L
// #define VXD_DEBUG_                     0x04000000L
// #define VXD_DEBUG_                     0x08000000L
// #define VXD_DEBUG_                     0x10000000L
// #define VXD_DEBUG_                     0x20000000L
// #define VXD_DEBUG_                     0x40000000L

#define VXD_DEBUG_OUTPUT_TO_DEBUGGER   0x80000000L


//
//  Assert & require.
//

void VxdAssert( void          * pAssertion,
                void          * pFileName,
                unsigned long   nLineNumber );

#define VXD_ASSERT(exp) \
     if( !(exp) ){ VxdAssert( #exp, __FILE__, __LINE__ ); }else{}

#define VXD_REQUIRE VXD_ASSERT


#define DEBUG_BREAK     _asm int 3

#else   // !DEBUG =========================================================

//
//  Null assert & require.
//
#define VXD_ASSERT(exp)  /* Nothing */
#define VXD_REQUIRE(exp) ((void)(exp))

#define DEBUG_BREAK       /* Nothing */

#endif  // DEBUG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\types.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Types.h

Abstract:


    This file contains the typedefs and constants for Nbt.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#ifndef _TYPES_H
#define _TYPES_H

#pragma warning( disable : 4103 )

#include "nbtnt.h"
#include "ctemacro.h"
#include "debug.h"
#include "timer.h"
#include <nbtioctl.h>

#ifndef VXD
#include <netevent.h>
#endif  // VXD

//
// The code enabled by the following change is blocked by
// a bug in the ObjectManager code
//
// #define HDL_FIX         1

//----------------------------------------------------------------------------

#ifndef VXD
//
// TDI Version information
//
#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0

typedef struct _NETBT_PNP_CONTEXT_
{
    TDI_PNP_CONTEXT TDIContext;
    PVOID           ContextData;
} NETBT_PNP_CONTEXT, *PNETBT_PNP_CONTEXT;
#endif  // VXD


#ifdef MULTIPLE_WINS
//
//  Define the maximum # of bad IP addresses to tolerate during connect attempts
//
#define MAX_FAILED_IP_ADDRESSES   10
#endif  // MULTIPLE_WINS

#define MAX_RECURSE_DEPTH   10

//
// a flag to tell the transport to reindicate remaining data
// currently not supported by the transport
//
#define TDI_RECEIVE_REINDICATE  0x00000200  // remaining TSDU should cause another indication to the client

//
// In debug builds, write flink and blink with invalid pointer values so that
// if an entry is removed twice from a list, we bugcheck right there, instead
// of being faced with a corrupted list some years later!
//
#if DBG
#undef RemoveEntryList
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_OrgEntry;\
    _EX_OrgEntry = (Entry);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_OrgEntry->Flink = (LIST_ENTRY *)__LINE__;\
    _EX_OrgEntry->Blink = (LIST_ENTRY *)__LINE__;\
    }
#endif

//
// Netbios name size restrictions
//
#define NETBIOS_NAME_SIZE       16
#define MAX_NBT_DGRAM_SIZE      512

//
// To distinguish NBNS server ipaddr from DNS server ipaddr in common routines
//
#define NBNS_MODE  1
#define DNS_MODE   2

// buffer size to start for registry reads
#define REGISTRY_BUFF_SIZE  512
//
// this is the amount of memory that nbt will allocate max for datagram
// sends, before it rejects datagram sends with insufficient resources, since
// nbt buffers datagram sends to allow them to complete quickly to the
// client. - 128k - it can be set via the registry using the Key
// MaxDgramBuffering
//
#define DEFAULT_DGRAM_BUFFERING  0x20000

//
// the hash bucket structure - number of buckets - these should be set by
// a value read from the registry (small/medium/large).  If the registry
// does not contain the values then these are used as defaults.
//
#define NUMBER_BUCKETS_LOCAL_HASH_TABLE    0x10
#define NUMBER_BUCKETS_REMOTE_HASH_TABLE   256
#define NUMBER_LOCAL_NAMES                 10
#define NUMBER_REMOTE_NAMES                10

#define MEDIUM_NUMBER_BUCKETS_LOCAL_HASH_TABLE    0x80
#define MEDIUM_NUMBER_BUCKETS_REMOTE_HASH_TABLE   256
#define MEDIUM_NUMBER_LOCAL_NAMES                 20
#define MEDIUM_NUMBER_REMOTE_NAMES                100

#define LARGE_NUMBER_BUCKETS_LOCAL_HASH_TABLE    255
#define LARGE_NUMBER_BUCKETS_REMOTE_HASH_TABLE   256
#define LARGE_NUMBER_LOCAL_NAMES                 0xFFFF
#define LARGE_NUMBER_REMOTE_NAMES                255

//
// max number of buffers of various types
//
#define NBT_INITIAL_NUM         2
#define NBT_NUM_DGRAM_TRACKERS  0xFFFF
#define MIN_NBT_NUM_INITIAL_CONNECTIONS     20
#define DEFAULT_NBT_NUM_INITIAL_CONNECTIONS 50
#ifndef VXD
#define NBT_NUM_SESSION_MDLS    0xFFFF
#else
#define NBT_NUM_SESSION_HDR     200
#define NBT_NUM_SEND_CONTEXT    200
#define NBT_NUM_RCV_CONTEXT     200
#endif  // !VXD

#define MEDIUM_NBT_NUM_DGRAM_TRACKERS  1000
#define MEDIUM_NBT_NUM_INITIAL_CONNECTIONS   100
#ifndef VXD
#define MEDIUM_NBT_NUM_SESSION_MDLS    1000
#else
#define MEDIUM_NBT_NUM_SESSION_HDR     1000
#define MEDIUM_NBT_NUM_SEND_CONTEXT    1000
#define MEDIUM_NBT_NUM_RCV_CONTEXT     1000
#endif  // !VXD

#define LARGE_NBT_NUM_DGRAM_TRACKERS  0xFFFF
#define LARGE_NBT_NUM_INITIAL_CONNECTIONS   500
#ifndef VXD
#define LARGE_NBT_NUM_SESSION_MDLS    0xFFFF
#else
#define LARGE_NBT_NUM_SESSION_HDR     0xFFFF
#define LARGE_NBT_NUM_SEND_CONTEXT    0xFFFF
#define LARGE_NBT_NUM_RCV_CONTEXT     0xFFFF
#endif  // !VXD

// ip loop back address - does not go out on wire
//

#define LOOP_BACK           0x7F000000 // in host order
#define INADDR_LOOPBACK     0x7f000001
#define NET_MASK    0xC0       // used to get network number from ip address

//
// Nbt must indicate at least 128 bytes to its client, so it needs to be
// able to buffer 128 bytes + the session header (4)
//
#define NBT_INDICATE_BUFFER_SIZE            132


#define IS_NEG_RESPONSE(OpcodeFlags)     (OpcodeFlags & FL_RCODE)
#define IS_POS_RESPONSE(OpcodeFlags)     (!(OpcodeFlags & FL_RCODE))

//
// where to locate or register a name - locally or on the network
//
enum eNbtLocation
{
    NBT_LOCAL,
    NBT_REMOTE,
    NBT_REMOTE_ALLOC_MEM
};

//
// Type of IP address to look for
//
enum eNbtIPAddressType
{
    NBT_IP_STATIC,
    NBT_IP_DHCP,
    NBT_IP_AUTOCONFIGURATION
};

//
// Type of Request to Resolve from LmhSvc Dll
//
enum eNbtLmhRequestType
{
    NBT_PING_IP_ADDRS,
    NBT_RESOLVE_WITH_DNS
};

#define STATIC_IPADDRESS_NAME           L"IPAddress"
#define STATIC_IPADDRESS_SUBNET         L"SubnetMask"

#define DHCP_IPADDRESS_NAME             L"DhcpIPAddress"
#define DHCP_IPADDRESS_SUBNET           L"DhcpSubnetMask"

#define DHCP_IPAUTOCONFIGURATION_NAME   L"IPAutoconfigurationAddress"
#define DHCP_IPAUTOCONFIGURATION_SUBNET L"IPAutoconfigurationMask"

#define SESSION_PORT                    L"SessionPort"
#define DATAGRAM_PORT                   L"DatagramPort"

//
// these are the names that NBT binds to, in TCP when it is opening address
// objects or creating connections.
//
#define NBT_TCP_BIND_NAME               L"\\Device\\Streams\\"
#define NBT_BIND                        L"Bind"
#define NBT_EXPORT                      L"Export"
#define NBT_PARAMETERS                  L"\\Parameters"
#define PWS_NAME_SERVER_LIST            L"NameServerList"
#define PWS_DHCP_NAME_SERVER_LIST       L"DhcpNameServerList"

#ifdef _NETBIOSLESS
#define PWS_NETBIOS_OPTIONS             L"NetbiosOptions"
#define PWS_DHCP_NETBIOS_OPTIONS        L"DhcpNetbiosOptions"
#endif  // _NETBIOSLESS
#define PWS_RAS_PROXY_FLAGS             L"RASFlags"
#define PWS_ENABLE_NAGLING              L"EnableNagling"

#define WC_WINS_DEVICE_BIND_NAME        L"\\Device\\NetBt_Wins_Bind"
#define WC_WINS_DEVICE_EXPORT_NAME      L"\\Device\\NetBt_Wins_Export"
#define WC_NETBT_PROVIDER_NAME          L"\\Device\\NetBT"
#define WC_NETBT_CLIENT_NAME            L"NetBt"

#define WC_SMB_DEVICE_BIND_NAME         L"\\Device\\Netbt_Smb_Bind"
#define WC_SMB_DEVICE_EXPORT_NAME       L"\\Device\\NetbiosSmb"    // Match what's in .INF file
#define WC_SMB_DEVICE_NAME              L"Smb"
#define WC_SMB_PARAMETERS_LOCATION      L"Parameters\\Smb"



//
// Special NetBIOS name suffixes
//
#define SPECIAL_GROUP_SUFFIX        0x1C                // for netlogon and the browser
#define SPECIAL_BROWSER_SUFFIX      0x1D                // for the browser
#define SPECIAL_MESSENGER_SUFFIX    0x03                // for the Messenger Service
#define SPECIAL_SERVER_SUFFIX       0x20                // for the Server
#define SPECIAL_WORKSTATION_SUFFIX  0x00                // for the Workstation


// these are bit mask values passed to freetracker in name.c to tell it what to do
// to free a tracker
//
#define FREE_HDR        0x0001
#define REMOVE_LIST     0x0002
#define RELINK_TRACKER  0x0004


#define NAME_RESOLVED_BY_IP         0x001
#define NAME_RESOLVED_BY_CLIENT     0x002
#define NAME_RESOLVED_BY_LMH_P      0x004
#define NAME_RESOLVED_BY_DNS        0x008
#define NAME_RESOLVED_BY_WINS       0x010
#define NAME_RESOLVED_BY_BCAST      0x020
#define NAME_RESOLVED_BY_LMH        0x040
#define NAME_RESOLVED_BY_DGRAM_IN   0x080
#define NAME_RESOLVED_BY_ADAP_STAT  0x100
#define NAME_ADD_INET_GROUP         0x200
#define NAME_ADD_IF_NOT_FOUND_ONLY  0x400

#define NAME_MULTIPLE_CACHES_ONLY   1
#define NAME_STRICT_CONNECT_ONLY    2

#define REMOTE_CACHE_INCREMENT      4

//
// Work Item structure for work items put on the Kernel Excutive worker threads
//
typedef struct _TRACKER tDGRAM_SEND_TRACKING;
typedef struct _DeviceContext tDEVICECONTEXT;
typedef struct
{
    LIST_ENTRY Linkage;

    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientContext;
    PVOID                   ClientCompletion;
    tDEVICECONTEXT          *pDeviceContext;
    PVOID                   WorkerRoutine;

    BOOL TimedOut;
    BOOL bSpecialAlloc;
    BOOL bQueued;
} NBT_WORK_ITEM_CONTEXT;


//
// Hash Table basic structure
//
typedef struct
{
    LONG                lNumBuckets;
    enum eNbtLocation   LocalRemote;    // type of data stored inhash table
    LIST_ENTRY          Bucket[1];  // array uTableSize long of hash buckets
} tHASHTABLE, *PHASHTABLE;



#define NBT_BROADCAST_NAME  "\x2a\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0"

enum eREF_NAME
{
    REF_NAME_LOCAL,
    REF_NAME_REMOTE,
    REF_NAME_SCOPE,
    REF_NAME_REGISTER,
    REF_NAME_RELEASE,
    REF_NAME_RELEASE_REFRESH,
    REF_NAME_PRELOADED,
    REF_NAME_LOG_EVENT,
    REF_NAME_FIND_NAME,
    REF_NAME_CONNECT,
    REF_NAME_SEND_DGRAM,
    REF_NAME_NODE_STATUS,
    REF_NAME_QUERY_ON_NET,
    REF_NAME_QUERY_RESPONSE,
    REF_NAME_DELETE_DEVICE,
    REF_NAME_AUTODIAL,
    REF_NAME_MAX
};

//
// the tNAMEADDR structure uses a bit mask to track which names are registered
// on which adapters.  To support up to 64 adapters on NT make this a ULONGLONG,
// On the VXD the largest Long is 32 bits (they don't support _int64), so the
// adapter limit is 32 for the VXD.
//
#ifndef VXD
#define CTEULONGLONG    ULONGLONG
#else
#define CTEULONGLONG    ULONG
#endif  // !VXD


typedef struct
{
    tIPADDRESS          IpAddress;          // Unique IP address
    tIPADDRESS          *pOrigIpAddrs;      // when address was cached
} tADDRESS_ENTRY;

typedef struct
{
    tIPADDRESS          IpAddress;  // Unique IP address
    ULONG               Interface;
    ULONG               Metric;
} tQUERY_ADDRS;


// the format of each element linked to the hash buckets
//
typedef struct _tNAMEADDR
{
    // Line # 1
    LIST_ENTRY          Linkage;    // used to link onto bucket chains
    ULONG               Verify;     // for debug to tell remote from local names
    ULONG               RefCount;   // if Greater than one, can't free memory

    // Line # 2
    tADDRESS_ENTRY      *pRemoteIpAddrs;    // remote addresses per interface
    tIPADDRESS          IpAddress;          // 4 byte IP address
    tIPADDRESS          *pLmhSvcGroupList;  // (NameTypeState == NAMETYPE_GROUP loaded from LmhSvc)
    tIPADDRESS          *pIpAddrsList;      // list of ipaddrs (internet grp names,multihomed dns hosts etc.)

    // Line # 4
    ULONG               TimeOutCount;  // Count to know when entry has timed out
    struct _TRACKER     *pTracker;  // contains tracker ptr during name resol. phase
    ULONG               NameTypeState; // group or unique name + state
    ULONG               Ttl;           // in milliseconds..ttl of name

    // Line # 5
    CTEULONGLONG        AdapterMask;   // bit mask of adapters name registered on (MH)
    CTEULONGLONG        RefreshMask;   // bit mask of adapters name refreshed

    // Line # 6
    CTEULONGLONG        ReleaseMask;   // bit mask of adapters name to be released
    CTEULONGLONG        ConflictMask;   // bit mask of adapters currently in conflict

    // Line # 7
    union
    {                                // A scope name does not have timers started against it!
        tTIMERQENTRY    *pTimer;    // ptr to active timer entry
        ULONG           ulScopeLength;
    };
    union
    {                                // for local names the scope is implied and is stored in NbtConfig
        struct _tNAMEADDR *pScope; // ptr to scope record in hash table (Remote names only)
        struct _Address   *pAddressEle;// or ptr to address element (Local names)
        struct
        {
            USHORT      MaxDomainAddrLength; // max # of ip addrs in Iplist for domain names from lmhosts
            USHORT      CurrentLength;       // current # of above
        };
    };
    USHORT              RemoteCacheLen;
    USHORT              NameAddFlags;
    BYTE                ProxyReqType;
    BOOLEAN             fPnode;         //indicates whether the node type is a Pnode
    BOOLEAN             fPreload;       // Needed temporarily when reading Domain name from LmHosts file

    UNICODE_STRING      FQDN;

    // Line # 8
    ULONG               NameFlags;

// #if DBG
    UCHAR               References[REF_NAME_MAX];
// #endif  // DBG

    // Line # 3
    CHAR                Name[NETBIOS_NAME_SIZE]; // Must be the last field
} tNAMEADDR;

#define NAME_REGISTERED_ON_SMBDEV   0x01

//
// these values can be checked with a bit check since they are mutually
// exclusive bits... uses the first nibble of the field
//
#define NAMETYPE_QUICK       0x0001 // set if name is Quick Unique or Quick Group
#define NAMETYPE_UNIQUE      0x0002
#define NAMETYPE_GROUP       0x0004
#define NAMETYPE_INET_GROUP  0x0008
#define NAMETYPE_SCOPE       0x1000
//
// values for NameTypeState.. the state of the name occupies the second nibble
// of the field
//
#define STATE_RESOLVED  0x0010  // name query completed
#define STATE_RELEASED  0x0020  // no longer active
#define STATE_CONFLICT  0x0040  // proxy name addition to the name table
#define STATE_RESOLVING 0x0080  // name is waiting for Query or Reg. to complete
#define NAME_TYPE_MASK  0x000F
#define NAME_STATE_MASK 0x00F0

#define REFRESH_FAILED  0x0100  // set if the name refresh response was received
#define PRELOADED       0x0800  // set if the entry is a preloaded entry - no timeout
#define REFRESH_MASK    0x0F00

#define LOCAL_NAME      0xDEAD0000
#define REMOTE_NAME     0xFACF0000

// the number of timeouts per refresh time.  The timer expires 8 times and
// refreshes every four (i.e. at twice the required refresh interval)
#define REFRESH_DIVISOR 0x0008

//
// two flags used in the NbtTdiOpenAddress procedure to decide which
// event handlers to setup
//
#define TCP_FLAG        0x00000001
#define SESSION_FLAG    0x00000002

//
// these defines allow the code to run as either a Bnode or a Pnode
// or a proxy
//
extern USHORT   RegistryNodeType;   // defined in Name.c
extern USHORT   NodeType;   // defined in Name.c
#define BNODE       0x0001
#define PNODE       0x0002
#define MNODE       0x0004
#define MSNODE      0x0008
#define NODE_MASK   0x000F
#define PROXY       0x0010
#define PROXY_REG   0x0020U  // Registration request
typedef enum {
    NO_PROXY,
    PROXY_WINS,
    PROXY_RAS
} tPROXY_TYPE;
#define PROXY_RAS_NONAMEQUERYFORWARDING     (0x1UL)

#define NAMEREQ_REGULAR             0
#define NAMEREQ_PROXY_QUERY         1       // Do negative name cache
#define NAMEREQ_PROXY_REGISTRATION  2       // Don't do negative name cache

#define DEFAULT_NODE_TYPE 0x1000


//
// Wide String defintions of values to read from the registry
//

//  NT wants Unicode, Vxd wants ANSI
#ifdef VXD
    #define __ANSI_IF_VXD(str)     str
#else
    #define __ANSI_IF_VXD(str)     L##str
#endif  // VXD
#define ANSI_IF_VXD( str ) __ANSI_IF_VXD( str )

#define WS_NUM_BCASTS                   ANSI_IF_VXD("BcastNameQueryCount")
#define WS_BCAST_TIMEOUT                ANSI_IF_VXD("BcastQueryTimeout")
#define WS_CACHE_TIMEOUT                ANSI_IF_VXD("CacheTimeout")
#define WS_INBOUND_DGRAM_NAME_CACHE_TIMEOUT ANSI_IF_VXD("InboundDgramNameCacheTimeout")
#define WS_MAX_NUM_NAME_CACHE           ANSI_IF_VXD("MaxNumNameCache")
#define WS_NODE_TYPE                    ANSI_IF_VXD("NodeType")
#define WS_NS_PORT_NUM                  ANSI_IF_VXD("NameServerPort")
#define WS_NAMESRV_RETRIES              ANSI_IF_VXD("NameSrvQueryCount")
#define WS_NAMESRV_TIMEOUT              ANSI_IF_VXD("NameSrvQueryTimeout")
#define WS_NODE_SIZE                    ANSI_IF_VXD("Size/Small/Medium/Large")
#define WS_KEEP_ALIVE                   ANSI_IF_VXD("SessionKeepAlive")
#define WS_ALLONES_BCAST                ANSI_IF_VXD("BroadcastAddress")
#define NBT_SCOPEID                     ANSI_IF_VXD("ScopeId")
#define WS_RANDOM_ADAPTER               ANSI_IF_VXD("RandomAdapter")
#define WS_SINGLE_RESPONSE              ANSI_IF_VXD("SingleResponse")
#define WS_INITIAL_REFRESH              ANSI_IF_VXD("InitialRefreshT.O.")
#define WS_ENABLE_DNS                   ANSI_IF_VXD("EnableDns")
#define WS_TRY_ALL_ADDRS                ANSI_IF_VXD("TryAllIpAddrs")
#define WS_ENABLE_LMHOSTS               ANSI_IF_VXD("EnableLmhosts")
#define WS_LMHOSTS_TIMEOUT              ANSI_IF_VXD("LmhostsTimeout")
#define WS_SMB_DISABLE_NETBIOS_NAME_CACHE_LOOKUP    ANSI_IF_VXD("SmbDisableNetbiosNameCacheLookup")
#define WS_MAX_DGRAM_BUFFER             ANSI_IF_VXD("MaxDgramBuffering")
#define WS_ENABLE_PROXY_REG_CHECK       ANSI_IF_VXD("EnableProxyRegCheck")
#define WS_WINS_DOWN_TIMEOUT            ANSI_IF_VXD("WinsDownTimeout")
#define WS_MAX_CONNECTION_BACKLOG       ANSI_IF_VXD("MaxConnBacklog")
#define WS_CONNECTION_BACKLOG_INCREMENT ANSI_IF_VXD("BacklogIncrement")
#define WS_REFRESH_OPCODE               ANSI_IF_VXD("RefreshOpCode")
#define WS_TRANSPORT_BIND_NAME          ANSI_IF_VXD("TransportBindName")
#define WS_MAX_PRELOADS                 ANSI_IF_VXD("MaxPreloadEntries")
#define WS_USE_DNS_ONLY                 ANSI_IF_VXD("UseDnsOnlyForNameResolutions")
#define WS_NO_NAME_RELEASE              ANSI_IF_VXD("NoNameReleaseOnDemand")
#ifdef MULTIPLE_WINS
#define WS_TRY_ALL_NAME_SERVERS         ANSI_IF_VXD("TryAllNameServers")
#endif  // MULTIPLE_WINS
#define WS_MINIMUM_REFRESH_SLEEP_TIME   ANSI_IF_VXD("MinimumRefreshSleepTime")
#define WS_CACHE_PER_ADAPTER_ENABLED    ANSI_IF_VXD("CachePerAdapterEnabled")
#define WS_CONNECT_ON_REQUESTED_IF_ONLY ANSI_IF_VXD("ConnectOnRequestedInterfaceOnly")
#define WS_SEND_DGRAM_ON_REQUESTED_IF_ONLY ANSI_IF_VXD("SendDgramOnRequestedInterfaceOnly")
#define WS_MULTIPLE_CACHE_FLAGS         ANSI_IF_VXD("MultipleCacheFlags")
#define WS_SMB_DEVICE_ENABLED           ANSI_IF_VXD("SMBDeviceEnabled")
#define WS_MIN_FREE_INCOMING_CONNECTIONS ANSI_IF_VXD("MinFreeLowerConnections")
#define WS_BREAK_ON_ASSERT              ANSI_IF_VXD("BreakOnAssert")
#define WS_PENDING_NAME_QUERIES_COUNT   ANSI_IF_VXD("PendingNameQueriesCount")

#ifdef VXD
#define VXD_MIN_NAMETABLE_SIZE            1
#define VXD_DEF_NAMETABLE_SIZE           17
#define VXD_MIN_SESSIONTABLE_SIZE         1
#define VXD_DEF_SESSIONTABLE_SIZE       255

#define VXD_LANABASE_NAME               ANSI_IF_VXD("LANABASE")
#define WS_DNS_PORT_NUM                 ANSI_IF_VXD("DnsServerPort")
#define WS_LMHOSTS_FILE                 ANSI_IF_VXD("LmHostFile")
#define WS_DO_DNS_DEVOLUTIONS           ANSI_IF_VXD("VNbtDoDNSDevolutions")
#define VXD_NAMETABLE_SIZE_NAME         ANSI_IF_VXD("NameTableSize")
#define VXD_SESSIONTABLE_SIZE_NAME      ANSI_IF_VXD("SessionTableSize")

#ifdef CHICAGO
#define VXD_ANY_LANA                    0xff
#define VXD_DEF_LANABASE                VXD_ANY_LANA
#else
#define VXD_DEF_LANABASE                0
#endif  // CHICAGO

#endif  // VXD

#ifdef PROXY_NODE
#define IS_NOT_PROXY                    0
#define WS_IS_IT_A_PROXY                ANSI_IF_VXD("EnableProxy")
#define NODE_TYPE_MASK                  0x60    // Mask for NodeType in NBFLAGS byte of Query response
#define PNODE_VAL_IN_PKT                0x20    // A bit pattern of 01 in the NodeType fld
                                                // of the Query response pkt indicates a P node
#endif  // PROXY_NODE
#define NBT_PROXY_DBG(x)  KdPrint(x)

// Various Default values if the above values cannot be read from the
// registry
//
#define TWO_MINUTES                     2 * 60 * 1000
#define ONE_HOUR                        1 * 60 * 60 * 1000  // millisecs

//
// Cache the sender's name for 15 seconds on DC and 2 seconds in other cases
//
#define DEFAULT_INBOUND_DGRAM_NAME_CACHE_TIMEOUT    2000    // 2 seconds in milliseconds
#define DEFAULT_DC_INBOUND_DGRAM_NAME_CACHE_TIMEOUT 15000   // 15 seconds in milliseconds
#define MIN_INBOUND_DGRAM_NAME_CACHE_TIMEOUT        2000    // 2 seconds

#define DEFAULT_CACHE_TIMEOUT           360000    // 6 minutes in milliseconds
#define MIN_CACHE_TIMEOUT               60000     // 1 minutes in milliseconds
#define DEFAULT_MINIMUM_REFRESH_SLEEP_TIME  6 * 3600 * 1000  // 6 hours
#define REMOTE_HASH_TIMEOUT     2500     // 2.5 second timer
#define ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT 30000   // 30 seconds

#define     MAX_INBOUND_STATE_TIMEOUT   30000   // 30   seconds
#define     MED_INBOUND_STATE_TIMEOUT   15000   // 15   seconds
#define     MIN_INBOUND_STATE_TIMEOUT    7500   //  7.5 seconds

//
// timeouts - the defaults if the registry cannot be read.
//  (time is milliseconds)
// The retry counts are the actual number of transmissions, not the number
// of retries i.e. 3 means the first transmission and 2 retries. Except
// for Bnode name registration where 3 registrations and 1 over write request
// are sent.(effectively 4 are sent).
//
#define DEFAULT_NUMBER_RETRIES      3
#define DEFAULT_RETRY_TIMEOUT       1500
#define MIN_RETRY_TIMEOUT           100

//#define MIN_RETRY_TIMEOUT           100

// the broadcasts values below related to broadcast name service activity
#define DEFAULT_NUMBER_BROADCASTS   3
#define DEFAULT_BCAST_TIMEOUT       750
#define MIN_BCAST_TIMEOUT           100

#define DEFAULT_NODE_SIZE           1       // BNODE
#define SMALL                       1
#define MEDIUM                      2
#define LARGE                       3

#define DEFAULT_KEEP_ALIVE          0xFFFFFFFF // disabled by default
#define MIN_KEEP_ALIVE              60*1000    // 60 seconds in milliseconds
//
// The default is to use the subnet broadcast address for broadcasts rather
// than use 0xffffffff(i.e. when BroadcastAddress is not defined in the
// registery. If the registery variable BroadcastAddress is set to
// something that cannot be read for some reason, then the broadcast address
// gets set to this value.
//
#define DEFAULT_BCAST_ADDR          0xFFFFFFFF

// a TTL value to use as a default (for refreshing names with WINS)
//
#define DEFAULT_TTL                         5*60*1000

//
// Default TTL used for checking whether we need to switch back to the primary. currently 1 hour.
//
#define DEFAULT_SWITCH_TTL                  ONE_HOUR

//
// we refresh every 16 minutes / 8 - so no more than once every two
// minutes until we reach WINS and get a new value
//
#define NBT_INITIAL_REFRESH_TTL             16*60*1000 // milliseconds
#define MAX_REFRESH_CHECK_INTERVAL          600000  // 10 minutes in msec

// don't allow the refresh mechanism to run any faster than once per 5 minutes
#define NBT_MINIMUM_TTL                     5*60*1000  // Milliseconds
#define NBT_MAXIMUM_TTL                     0xFFFFFFFF // larges ULONG (approx 50 days)

//
// the Mininimum and default timeouts to stop talking to WINS in the event
// that we fail to reach it once.(i.e. temporarily stop using it)
//
#define DEFAULT_WINS_DOWN_TIMEOUT   15000 // 15 seconds
#define MIN_WINS_DOWN_TIMEOUT       1000  // 1 second

//
// Default max connections that can be in backlog
//
#define DEFAULT_CONN_BACKLOG   1000
#define MIN_CONN_BACKLOG   2
#define MAX_CONNECTION_BACKLOG  40000   // we allow only upto 40000 outstanding connections (~4MB)

//
// Default max lower connection increment
//
#define DEFAULT_CONN_BACKLOG_INCREMENT   3
#define MIN_CONN_BACKLOG_INCREMENT   3
#define MAX_CONNECTION_BACKLOG_INCREMENT  20   // we allow only upto 20 new ones at a time

// the minimum time to wait for a session setup pdu to complete - used to
// start a timer in name.c
#define NBT_SESSION_RETRY_TIMEOUT   10000     // 10 sec in milliseconds
//
// the number of times to attempt a session setup if the return code is
// Called Name Present but insufficient resources (0x83) - or if the
// destination does not have the name at all - in this case the session
// is just setup one more time, not 3 more times
//
#define NBT_SESSION_SETUP_COUNT       3
//
// the following two lines allow proxy code to be compiled OUT if PROXY is not
// defined
//
#define IF_PROXY(Node)    if ((Node) & PROXY)
#define END_PROXY

#define IF_DEF_PROXY \
#ifdef PROXY_NODE
#define END_DEF_PROXY \
#endif  // PROXY_NODE

// Status code specific to NBT that is used in the RcvHndlrNotOs to indicate
// that not enough data has been received, and more must be obtained.
//
#define STATUS_NEED_MORE_DATA   0xC0000999L

#ifndef VXD

//
// Logging definitions
//

#define LOGSIZE  10000
#define LOGWIDTH 32

typedef char STRM_RESOURCE_LOG[LOGSIZE+1][LOGWIDTH];

typedef struct {
    STRM_RESOURCE_LOG  Log;
    CHAR               Unused[3*LOGWIDTH];   // for overruns
    int                Index;
} STRM_PROCESSOR_LOG, *PSTRM_PROCESSOR_LOG;

/*
 *  Definitions for the error logging facility
 */

/*
 *  Maximum amount of data (binary dump data plus insertion strings) that
 *  can be added to an error log entry.
 */
#define MAX_ERROR_LOG_DATA_SIZE     \
    ( (ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) + 4) & 0xFFFFFFFC )

#endif  // !VXD

#define NBT_ADDRESS_TYPE        01
#define NBT_CONNECTION_TYPE     02
#define NBT_CONTROL_TYPE        03
#define NBT_WINS_TYPE           04


//
// Maximum ip addresses that can be in an internet group - used as a sanity
// check to prevent allocating hugh amounts of memory
//
#define NBT_MAX_INTERNET_GROUP_ADDRS    1000

// define buffer types so we will know when we have allocated the maximum
// allowed number of buffers - this enum serves as an array index into the
// config data
//
enum eBUFFER_TYPES
{
    eNBT_DGRAM_TRACKER,
#ifndef VXD
    eNBT_FREE_SESSION_MDLS,
#else
    eNBT_SESSION_HDR,
    eNBT_SEND_CONTEXT,
    eNBT_RCV_CONTEXT,
#endif  // !VXD
    eNBT_NUMBER_BUFFER_TYPES    // this type must be last on the list
};

//
// enumerate the types of name service broadcasts... either name registration
// or name query
//
enum eNSTYPE
{
    eNAME_QUERY,
    eDNS_NAME_QUERY,
    eDIRECT_DNS_NAME_QUERY,
    eNAME_QUERY_RESPONSE,
    eNAME_REGISTRATION,
    eNAME_REGISTRATION_OVERWRITE,
    eNAME_REGISTRATION_RESPONSE,
    eNAME_RELEASE,
    eNAME_REFRESH
};


#define DIRECT_DNS_NAME_QUERY_BASE 0x8000


#define NBT_G_REFRESHING_NOW        0x1
#define NBT_G_REFRESH_SLEEPING      0x2

#define NBT_D_REFRESHING_NOW        0x1
#define NBT_D_REFRESH_WAKING_UP     0x2


//
// Defines for the Verify elements of the handles passed to clients so that
// we can determine if we recieved the correct handle back from the client
// i.e. the Verify element must equal the correct define given here
//
#define NBT_VERIFY_ADDRESS           0x72646441 // Addr
#define NBT_VERIFY_LOWERCONN         0x43776f4c // LowC
#define NBT_VERIFY_CONNECTION        0x316e6f43 // Con1
#define NBT_VERIFY_CONNECTION_DOWN   0x326e6f43 // Con2
#define NBT_VERIFY_CLIENT            0x316e6c43 // Cln1
#define NBT_VERIFY_CLIENT_DOWN       0x326e6c43 // Cln2
#define NBT_VERIFY_DEVCONTEXT        0x43766544 // DevC
#define NBT_VERIFY_DEVCONTEXT_DOWN   0x32766544 // Dev2
#define NBT_VERIFY_CONTROL           0x6c727443 // Ctrl
#define NBT_VERIFY_TRACKER           0x6b617254 // Trak
#define NBT_VERIFY_TRACKER_DOWN      0x32617254 // Tra2
#define NBT_VERIFY_BLOCKING_NCB      0x0042434e // NCB
#define NBT_VERIFY_TIMER_ACTIVE      0x316d6954 // Tim1
#define NBT_VERIFY_TIMER_DOWN        0x326d6954 // Tim2
#define NBT_VERIFY_WINS_ACTIVE       0x736e6957 // Wins
#define NBT_VERIFY_WINS_DOWN         0x326e6957 // Win2

//
// Session Header types from the RFC's
//
#define NBT_SESSION_MESSAGE           0x00
#define NBT_SESSION_REQUEST           0x81
#define NBT_POSITIVE_SESSION_RESPONSE 0x82
#define NBT_NEGATIVE_SESSION_RESPONSE 0x83
#define NBT_RETARGET_SESSION_RESPONSE 0x84
#define NBT_SESSION_KEEP_ALIVE        0x85
#define NBT_SESSION_FLAGS             0x00  // flag byte of Session hdr = 0 always
#define SESSION_NOT_LISTENING_ON_CALLED_NAME    0x80
#define SESSION_NOT_LISTENING_FOR_CALLING_NAME  0x81
#define SESSION_CALLED_NAME_NOT_PRESENT         0x82
#define SESSION_CALLED_NAME_PRESENT_NO_RESRC    0x83
#define SESSION_UNSPECIFIED_ERROR               0x8F

//
// Address Info structure used to return buffer in TDI_QUERY_ADDRESS_INFO
//
#include <packon.h>
typedef struct
{
    ULONG               ActivityCount;
    TA_NETBIOS_ADDRESS  NetbiosAddress;

} tADDRESS_INFO;
#include <packoff.h>
//
// Name Registration error codes per the RFC
//
#define REGISTRATION_NO_ERROR       0x0
#define REGISTRATION_FORMAT_ERR     0x1
#define REGISTRATION_SERVER_ERR     0x2
#define REGISTRATION_UNSUPP_ERR     0x4
#define REGISTRATION_REFUSED_ERR    0x5
#define REGISTRATION_ACTIVE_ERR     0x6
#define REGISTRATION_CONFLICT_ERR   0x7

#define NBT_NAMESERVER_UDP_PORT     137 // port used by the Name Server
#define NBT_DNSSERVER_UDP_PORT       53 // port used by the DNS server
#define NBT_NAMESERVICE_UDP_PORT    137
#define NBT_DATAGRAM_UDP_PORT       138
#define NBT_SESSION_TCP_PORT        139
#ifdef _NETBIOSLESS
#define NBT_SMB_SESSION_TCP_PORT    445 // port used by rdr and srv
#define NBT_SMB_DATAGRAM_UDP_PORT   445 // port used by browser
#endif  // _NETBIOSLESS

#define IP_ANY_ADDRESS                0 // means broadcast IP address to IP
#define WINS_SIGNATURE             0xFF // put into QdCount to tell signal name reg from this node

#define MAX_IP_ADDRS                 10 // Temporary for now!
#ifdef MULTIPLE_WINS
#define MAX_NUM_OTHER_NAME_SERVERS   10 // # of Backup Name Server entries to keep in cache
#endif  // MULTIPLE_WINS

//
// whether an address is unique or a group address... these agree with the
// values in TDI.H for TDI_ADDRESS_NETBIOS_TYPE_UNIQUE etc.. but are easier to
// type!
//
enum eNbtAddrType
{
    NBT_UNIQUE,
    NBT_GROUP,
    NBT_QUICK_UNIQUE,   // these two imply that the name is registered on the
    NBT_QUICK_GROUP     // net when it is claimed
};


//
// this type defines the session hdr used to put session information
// into each client pdu sent
//
#include <packon.h>
typedef union
{
    union
    {
        struct
        {
            UCHAR   Type;
            UCHAR   Flags;
            USHORT  Length;
        };
        ULONG   UlongLength;
    };
#ifndef _WIN64

    //
    // (fcf) This isn't used anywhere as far as I can tell, but I want to wait
    // until post-beta2 to be safe.
    //

    PSINGLE_LIST_ENTRY  Next;
#endif  // _WIN64
} tSESSIONHDR;

// Session response PDU
typedef struct
{
    UCHAR   Type;
    UCHAR   Flags;
    USHORT  Length;
    UCHAR   ErrorCode;

} tSESSIONERROR;

// Session Retarget response PDU
typedef struct
{
    UCHAR   Type;
    UCHAR   Flags;
    USHORT  Length;
    ULONG   IpAddress;
    USHORT  Port;

} tSESSIONRETARGET;

// the structure for the netbios name itself, which includes a length
// byte at the start of it
typedef struct
{
    UCHAR   NameLength;
    CHAR    NetBiosName[1];

} tNETBIOS_NAME;

// session request packet...this is the first part of it. It still needs the
// calling netbios name to be appended on the end, but we can't do that
// until we know how long the Called Name is.
typedef struct
{
    tSESSIONHDR     Hdr;
    tNETBIOS_NAME   CalledName;

} tSESSIONREQ;

// the type definition to queue empty session header buffers in a LIST
typedef union
{
    tSESSIONHDR Hdr;
    LIST_ENTRY  Linkage;
} tSESSIONFREE;

// this type definition describes the NetBios Datagram header format on the
// wire
typedef union
{
    struct
    {
        UCHAR           MsgType;
        UCHAR           Flags;
        USHORT          DgramId;
        ULONG           SrcIpAddr;
        USHORT          SrcPort;
        USHORT          DgramLength;
        USHORT          PckOffset;
        tNETBIOS_NAME   SrcName;
    };
    LIST_ENTRY  Linkage;

} tDGRAMHDR;

typedef struct
{
    UCHAR           MsgType;
    UCHAR           Flags;
    USHORT          DgramId;
    ULONG           SrcIpAddr;
    USHORT          SrcPort;
    UCHAR           ErrorCode;

} tDGRAMERROR;

// define the header size since just taking the sizeof(tDGRAMHDR) will be 1 byte
// too large and if for any reason this data structure changes later, things
// fail to work for unknown reasons....  This size includes the Hdr + the
// two half ascii src and dest names + the length byte in each name + the
//  It does
// not include the scope.  That must be added separately(times 2).
#define DGRAM_HDR_SIZE  80
#define MAX_SCOPE_LENGTH    255
#define MAX_LABEL_LENGTH    63

// Name Service header
typedef struct
{
    USHORT          TransactId;
    USHORT          OpCodeFlags;
    UCHAR           Zero1;
    UCHAR           QdCount;
    UCHAR           Zero2;
    UCHAR           AnCount;
    UCHAR           Zero3;
    UCHAR           NsCount;
    UCHAR           Zero4;
    UCHAR           ArCount;
    tNETBIOS_NAME   NameRR;

} tNAMEHDR;

//
// the offset from the end of the question name to the field
// in a name registration pdu ( includes 1 for the length byte of the name
// since ConvertToAscii does not count that value
//
#define QUERY_NBFLAGS_OFFSET  10
#define NBFLAGS_OFFSET        16
#define IPADDRESS_OFFSET      18
#define PTR_OFFSET            4     // offset to PTR in Name registration pdu
#define NO_PTR_OFFSET         10    // offset to NbFlags after name
#define PTR_SIGNATURE         0xC0  // ptrs to names in pdus start with C

//
// Minimum Pdu lengths that will be accepted from the wire
//
#define DNS_MINIMUM_QUERYRESPONSE   34

#define NBT_MINIMUM_QUERY           50
#define NBT_MINIMUM_QUERYRESPONSE   56
#define NBT_MINIMUM_WACK            58
#define NBT_MINIMUM_REGRESPONSE     62
#define NBT_MINIMUM_REGREQUEST      68

#define NBT_NODE_NAME_SIZE          18
#define NBT_MINIMUM_RR_LENGTH       22

// the structure of a DNS label is the count of the number of bytes followed
// by the label itself.  Each part of a dot delimited name is a label.
// Fred.ms.com is 3 labels.- Actually 4 labels where the last one is zero
// length - hence all names end in a NULL
typedef struct
{
    UCHAR       uSizeLabel; // top two bits are set to 1 when next 14 bits point to actual label in msg.
    CHAR        pLabel[1];  // variable length of label -> 63 bytes

}   tDNS_LABEL;
// top two bits set to signify a ptr to a name follows in the next 14 bits
#define PTR_TO_NAME     0xC0

// question section for the resource record modifiers
typedef struct
{
    ULONG      QuestionTypeClass;
} tQUESTIONMODS;

#define QUEST_NBINTERNET  0x00200001  // combined type/class
#define QUEST_DNSINTERNET 0x00010001  // combined type/class for dns query
#define QUEST_NETBIOS     0x0020      // General name service Resource Record
#define QUEST_STATUS      0x0021      // Node Status resource Record
#define QUEST_CLASS       0x0001      // internet class

// Resource Record format - in the Name service packets
// General format RrType = 0x20
typedef struct
{
    tQUESTIONMODS   Question;
    tDNS_LABEL      RrName;
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    USHORT          Flags;
    ULONG           IpAddress;

}   tGENERALRR;
// Resource Record format - in the Name service packets
// General format RrType = 0x20
typedef struct
{
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    USHORT          Flags;
    ULONG           IpAddress;

}   tQUERYRESP;

// same as tQUERYRESP, except no Flags field
// DNS servers return only 4 bytes of data (ipaddress): no flags.
typedef struct
{
    USHORT          RrType;
    USHORT          RrClass;
    ULONG           Ttl;
    USHORT          Length;
    ULONG           IpAddress;

}   tDNS_QUERYRESP;

#define  DNS_CNAME   5

//
// the format of the tail of the node status response message
//
typedef struct
{
    UCHAR       Name[NETBIOS_NAME_SIZE];
    UCHAR       Flags;
    UCHAR       Resrved;

} tNODENAME;

typedef struct
// the statistics portion of the node status message
{
    UCHAR       UnitId[6];
    UCHAR       Jumpers;
    UCHAR       TestResult;
    USHORT      VersionNumber;
    USHORT      StatisticsPeriod;
    USHORT      NumberCrcs;
    USHORT      NumberAlignmentErrors;
    USHORT      NumberCollisions;
    USHORT      NumberSendAborts;
    ULONG       NumberSends;
    ULONG       NumberReceives;
    USHORT      NumberTransmits;
    USHORT      NumberNoResrcConditions;
    USHORT      NumberFreeCommandBlks;
    USHORT      TotalCommandBlocks;
    USHORT      MaxTotalCommandBlocks;
    USHORT      NumberPendingSessions;
    USHORT      MaxNumberPendingSessions;
    USHORT      MaxTotalSessionsPossible;
    USHORT      SessionDataPacketSize;

} tSTATISTICS;

typedef struct
{
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    UCHAR           NumNames;
    tNODENAME        NodeName[1];     // there are NumNames of these

}   tNODESTATUS;

typedef struct
{
    USHORT  NbFlags;
    ULONG   IpAddr;
} tADDSTRUCT;
#define tADDSTRUCT_SIZE 6


// Flags Definitions
#define FL_GROUP    0x8000
#define FL_BNODE    0x0000      // note that this has no bits set!!
#define FL_PNODE    0x2000
#define FL_MNODE    0x4000

//Redirect type Address record - RrType = 0x01
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Ttl;
    USHORT  DataLength;
    ULONG   IpAddress;

}   tIPADDRRR;

//Redirect type - Name Server Resource Record RrType = 0x02
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Ttl;
    USHORT  DataLength;
    CHAR    Name[1];        // name starts here for N bytes - till null

}   tREDIRECTRR;

//Null type- WACK-  RrType = 0x000A
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Zeroes;
    USHORT  Null;

}   tWACKRR;

// definitions of the bits in the OpCode portion of the OpCodeFlag word
// These definitions work on a 16 bit word rather than the 5 bit opcode and 7
// bit flag
#define NM_FLAGS_MASK     0x0078
#define OP_RESPONSE       0x0080
#define OP_QUERY          0x0000
#define OP_REGISTRATION   0x0028
#define OP_REGISTER_MULTI 0x0078    // new multihomed registration(Byte) op code
#define OP_RELEASE        0x0030
#define OP_WACK           0x0038
#define OP_REFRESH        0x0040
#define OP_REFRESH_UB     0x0048    // UB uses 9 instead of 8 (Ref. RFC 1002)
#define REFRESH_OPCODE    0x8
#define UB_REFRESH_OPCODE 0x9
#define FL_RCODE          0x0F00
#define FL_NAME_ACTIVE    0x0600    // WINS is reporting another name active
#define FL_NAME_CONFLICT  0x0700    // another node is reporting name active
#define FL_AUTHORITY      0x0004
#define FL_TRUNCFLAG      0x0002
#define FL_RECURDESIRE    0x0001
#define FL_RECURAVAIL     0x8000
#define FL_BROADCAST      0x1000
#define FL_BROADCAST_BYTE 0x10
// used to determine if the source is a Bnode for Datagram distribution
#define SOURCE_NODE_MASK 0xFC

// defines for the node status message
#define GROUP_STATUS        0x80
#define UNIQUE_STATUS       0x00
#define NODE_NAME_PERM      0x02
#define NODE_NAME_ACTIVE    0x04
#define NODE_NAME_CONFLICT  0x08
#define NODE_NAME_RELEASED  0x10
#define STATUS_BNODE        0x00
#define STATUS_PNODE        0x20
#define STATUS_MNODE        0x40


// Resource record defines - rrtype and rr class
#define RR_NETBIOS      0x0020
#define RR_INTERNET     0x0001

// Name Query Response Codes
#define QUERY_NOERROR   00
#define FORMAT_ERROR    01
#define SERVER_FAILURE  02
#define NAME_ERROR      03
#define UNSUPP_REQ      04
#define REFUSED_ERROR   05
#define ACTIVE_ERROR    06  // name is already active on another node
#define CONFLICT_ERROR  07  // unique name is owned by more than one node


typedef struct
{
    tDGRAMHDR   DgramHdr;
    CHAR    SrcName[NETBIOS_NAME_SIZE];
    CHAR    DestName[NETBIOS_NAME_SIZE];

} tDGRAM_NORMAL;

typedef struct
{
    tDGRAMHDR   DgramHdr;
    UCHAR       ErrorCode;

} tDGRAM_ERROR;

typedef struct
{
    tDGRAMHDR   DgramHdr;
    CHAR        DestName[NETBIOS_NAME_SIZE];

} tDGRAM_QUERY;

#include <packoff.h>


// the buffer type passed to the TDI routines so that the datagram or session
// header can be included too.
typedef struct
{
    ULONG               HdrLength;
    PVOID               pDgramHdr;
    ULONG               Length;
    PVOID               pBuffer;
} tBUFFER;

//
// This typedef is used by DgramHandlrNotOs to keep track of which client
// is receiving a datagram and which client's need to also get the
// datagram
typedef struct
{
    struct _Address       *pAddress;
    ULONG                 ReceiveDatagramFlags;
    PVOID                 pRemoteAddress;
    ULONG                 RemoteAddressLength;
    struct _Client        *pClientEle;
    BOOLEAN               fUsingClientBuffer;
    BOOLEAN               fProxy; //used by PROXY code for getting the
                                  //entire datagram. See
                                  //CompletionRcvDgram in tdihndlrs.c

} tCLIENTLIST;


typedef struct
{
    ULONG           RefCount;
    HANDLE          hNameServer;        // from ZwCreateFile
    PDEVICE_OBJECT  pNameServerDeviceObject;    // from pObject->DeviceObject
    CTE_ADDR_HANDLE pNameServerFileObject;  // from ObReferenceObjectByHandle(hNameServer)

    HANDLE          hDgram;
    PDEVICE_OBJECT  pDgramDeviceObject;
    CTE_ADDR_HANDLE pDgramFileObject;

    NBT_WORK_ITEM_CONTEXT WorkItemCleanUp;
}tFILE_OBJECTS;


// Enumerate the different types of trackers (depending on where it
// is allocated)
enum eTRACKER_TYPE
{
    NBT_TRACKER_PROXY_DGRAM_DIST,
    NBT_TRACKER_NODE_STATUS_RESPONSE,
    NBT_TRACKER_CONNECT,
    NBT_TRACKER_DISCONNECT_LOWER,
    NBT_TRACKER_BUILD_SEND_DGRAM,
    NBT_TRACKER_SEND_NODE_STATUS,
    NBT_TRACKER_QUERY_FIND_NAME,
    NBT_TRACKER_QUERY_NET,
    NBT_TRACKER_CONTINUE_QUERY_NET,
    NBT_TRACKER_REGISTER_NAME,
    NBT_TRACKER_RELEASE_NAME,
    NBT_TRACKER_REFRESH_NAME,
    NBT_TRACKER_KEEP_ALIVE,
    NBT_TRACKER_SEND_NSBCAST,
    NBT_TRACKER_SEND_RESPONSE_DGRAM,
    NBT_TRACKER_SEND_RESPONSE_SESSION,
    NBT_TRACKER_SEND_DISCONNECT,
    NBT_TRACKER_RELEASE_REFRESH,
    NBT_TRACKER_ADAPTER_STATUS,
    NBT_TRACKER_SEND_WINS_DGRAM,
    NBT_TRACKER_NUM_TRACKER_TYPES
};

// #if DBG
extern ULONG   TrackTrackers[];
extern ULONG   TrackerHighWaterMark[];
// #endif   // DBG


// Active Datagram Send List - a set of linked blocks that represent transactions
// passed to the Transport TDI for execution... these blocks could be waiting
// for name resolution or for the send to complete

typedef struct _TRACKER
{
    // Line 1
    LIST_ENTRY              Linkage;
    ULONG                   Verify;
    // The type of address dictates the course of action, e.g., TDI_ADDRESS_NETBIOS_EX
    // address avoids NETBIOS name registration. This encodes the desired address type
    // associated with the connection or specified for the connection.
    ULONG                   RefCount;

    // Line 2
    PCTE_IRP                pClientIrp;     // client's IRP
    struct _DeviceContext   *pDeviceContext;
    PCHAR                   pDestName;      // ptr to destination ASCII name
    tNAMEADDR               *pNameAddr;     // ptr to name addres rec in hash tbl

    // Line 3
    tBUFFER                 SendBuffer;     // send buffer and header to send

    // Line 4
    struct _TRACKER         *pTrackerWorker;
    union
    {
        struct _Client      *pClientEle;    // client element block
        struct _Connect     *pConnEle;      // connection element block
        tNAMEADDR           *p1CNameAddr;   // DomainNames 1C pNameAddr - used sending datagrams
    };
    PVOID                   pNodeStatus;    // node status response buffer
    PTDI_CONNECTION_INFORMATION pSendInfo;

    // Line 5
    union
    {
        PVOID               pTimeout;       // used for the TCP connect timeout -from union below
        USHORT              TransactionId;  // name queries and registrations: response has same transactionid
        ULONG               RCount;         // refcount used for datagram dist.
    };
    union
    {
        ULONG               AllocatedLength;// used in Sending Dgrams to count mem allocated
        ULONG               RefConn;        // used for NbtConnect
    };
    ULONG                   DestPort;       // used by ReTarget to specify the dest port
    USHORT                  IpListIndex;    // index into IpList for Group sends
    USHORT                  SavedListIndex; //last index sent when timer was started


    // Line 6
    //
    // when two name queries go to the same name, this is the
    // completion routine to call for this tracker queued to the first
    // tracker.
    //
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        CompletionRoutine;
    COMPLETIONCLIENT        ClientCompletion;
    PVOID                   ClientContext;

    // Line 7
#ifdef MULTIPLE_WINS
    ULONG                   ResolutionContextFlags;
    tIPADDRESS              *pFailedIpAddresses;    // List of failed IP addresses
    ULONG                   LastFailedIpIndex;
    USHORT                  NSOthersIndex;
    USHORT                  NSOthersLeft;
#endif  // MULTIPLE_WINS

    // Line 8
    tIPADDRESS              RemoteIpAddress;
    ULONG                   RemoteNameLength;
    PUCHAR                  pRemoteName;
    ULONG                   AddressType;

    // Line 9
    ULONG                   NumAddrs;
    PULONG                  IpList;
    ULONG                   Flags;
    ULONG                   NodeStatusLen;      // pNodeStatus buffer length

    // Line 10
    LIST_ENTRY              TrackerList;

#ifdef VXD
    PUCHAR                  pchDomainName;
#endif  // VXD

    tIPADDRESS              *pGroupList;   // (NameTypeState = NAMETYPE_GROUP)

    //
    // bug #95241, bug #20697
    // pwRemoteName is pRemoteName in UNICODE format.
    // pwDestName   is pDestName in UNICODE format.
    // If TDI_ADDRESS_TYPE_NETBIOS_WCHAR_EX is used, pwRemoteName will be setup, otherwise it is NULL
    //
    PWCHAR                  UnicodeRemoteName;
    ULONG                   UnicodeRemoteNameLength;
    enum eNameBufferType UNALIGNED  *pNameBufferType;
    UNICODE_STRING          ResolvedRemoteName;
    PWCHAR                  UnicodeDestName;

    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pNetbiosUnicodeEX;
    UNICODE_STRING          ucRemoteName;   // copy of pNetbiosUnicodeEX->RemoteName field
                                            // pNetbiosUnicodeEX->RemoteName may be overwritten by other drivers
                                            // for safety, we need to make sure the buffer is untouched before
                                            // we update it. Make a private copy here.

    NBT_WORK_ITEM_CONTEXT WorkItemReconnect;

// #if DBG
    LIST_ENTRY              DebugLinkage;   // to keep track of used trackers
    enum eTrackerType       TrackerType;
// #endif  // DBG
} tDGRAM_SEND_TRACKING;

// this is the type of the procedure to call in the session receive handler
// as data arrives - a different procedure per state
typedef
    NTSTATUS
        (*tCURRENTSTATEPROC)(
                        PVOID                       ReceiveEventContext,
                        struct _LowerConnection     *pLowerConn,
                        USHORT                      RcvFlags,
                        ULONG                       BytesIndicated,
                        ULONG                       BytesAvailable,
                        PULONG                      pBytesTaken,
                        PVOID                       pTsdu,
                        PVOID                       *ppIrp);
#ifdef VXD
#define SetStateProc( pLower, StateProc )
#else
#define SetStateProc( pLower, StateProc )  ((pLower)->CurrentStateProc = (StateProc))
#endif  // VXD


// A Listen is attached to a client element attached address element when a
// client does a listen
typedef VOID    (*tRequestComplete)
                                (PVOID,
                      TDI_STATUS,
                      PVOID);

typedef struct
{
    LIST_ENTRY                  Linkage;
    PCTE_IRP                    pIrp;           // IRP ptr for NT only (may not be true)
    tRequestComplete            CompletionRoutine;
    PVOID                       pConnectEle;    // the connection that the Listen is active on
    PVOID                       Context;
    ULONG                       Flags;
    TDI_CONNECTION_INFORMATION  *pConnInfo;        // from a Listen
    TDI_CONNECTION_INFORMATION  *pReturnConnInfo;  // from a Listen

} tLISTENREQUESTS;

typedef struct
{
    LIST_ENTRY                  Linkage;
    PCTE_IRP                    pIrp;           // IRP ptr for NT only (may not be true)
    PVOID                       pRcvBuffer;
    ULONG                       RcvLength;
    PTDI_CONNECTION_INFORMATION ReceiveInfo;
    PTDI_CONNECTION_INFORMATION ReturnedInfo;

} tRCVELE;

//
// Values for the Flags element above
#define NBT_BROADCAST               0x0001
#define NBT_NAME_SERVER             0x0002
#define NBT_NAME_SERVER_BACKUP      0x0004
#ifdef MULTIPLE_WINS
#define NBT_NAME_SERVER_OTHERS      0x0008
#endif
#define NBT_NAME_SERVICE            0x0010 // two flags used by Tdiout to send dgrams
#define NBT_DATAGRAM_SERVICE        0x0020
#define TRACKER_CANCELLED           0x0040
#define NBT_DNS_SERVER              0x0080
#define NBT_DNS_SERVER_BACKUP       0x0100
#define WINS_NEG_RESPONSE           0x0200
#define REMOTE_ADAPTER_STAT_FLAG    0x1000
#define SESSION_SETUP_FLAG          0x2000
#define DGRAM_SEND_FLAG             0x4000
#define FIND_NAME_FLAG              0x8000
#define NO_DNS_RESOLUTION_FLAG     0x10000
#define NBT_USE_UNIQUE_ADDR        0x20000

#ifdef MULTIPLE_WINS
#define NAME_RESOLUTION_DONE        0x00FF    // Signal termination of Queries over wire
#endif  // MULTIPLE_WINS

//
// this flag indicates that a datagram send is still outstanding in the
// transport - it is set in the tracker flags field.
//
#define SEND_PENDING                0x0080


// Completion routine definition for calls to the Udp... routines.  This routine
// type is called by the tdiout.c completion routine (the Irp completion routine),
// so this is essentially the Nbt completion routine of the Irp.
typedef
    VOID
        (*NBT_COMPLETION)(
                IN  PVOID,      // context
                IN  NTSTATUS,   // status
                IN  ULONG);     // extra info


// Define datagram types
#define DIRECT_UNIQUE       0x10
#define DIRECT_GROUP        0x11
#define BROADCAST_DGRAM     0x12
#define ERROR_DGRAM         0x13
#define QUERY_REQUEST       0x14
#define POS_QUERY_RESPONSE  0x15
#define NEG_QUERY_RESPONSE  0x16

// define datagra flags byte values
#define FIRST_DGRAM 0x02
#define MORE_DGRAMS 0x01

// The type of Device we are bound to
enum eNbtDevice
{
    NBT_DEVICE_REGULAR,
#ifdef _NETBIOSLESS
    NBT_DEVICE_NETBIOSLESS,
#endif  // _NETBIOSLESS
    NBT_DEVICE_CLUSTER,
    NBT_DEVICE_WINS
};

#ifdef _NETBIOSLESS
#define IsDeviceNetbiosless( d ) (d->DeviceType == NBT_DEVICE_NETBIOSLESS)

// Flags for NetbiosOptions
#define NETBT_UNUSED 0
#define NETBT_MODE_NETBIOS_ENABLED 1
#define NETBT_MODE_NETBIOS_DISABLED 2
#endif  // _NETBIOSLESS

//
// The default disconnect timeout used in several places in name.c
//
#define DEFAULT_DISC_TIMEOUT    10  // seconds

//
// this is the value that the IpListIndex is set to when the last datagram
// has been sent.
//
#define LAST_DGRAM_DISTRIBUTION 0xFFFD
#define END_DGRAM_DISTRIBUTION  0xFFFE
// max 500 millisec timeout for ARP on dgram send before netbt sends the next
// datagram.
#define DGRAM_SEND_TIMEOUT      500

//
// These are other states for connections that are not explicitly used by
// NBT but are returned on the NbtQueryConnectionList call.
//
#define LISTENING   20;
#define UNBOUND     21;

// Lower Connection states that deal with receiving to the indicate buffer
#define NORMAL          0
#define INDICATE_BUFFER 1
#define FILL_IRP        2
#define PARTIAL_RCV     3

// Spin Lock Numbers.  Each structure is assigned a number so that locks are
// always acquired in the same order.  The CTESpinLock code checks the lock
// number before setting the spin lock and asserts if it is higher than
// the current one.  This prevents deadlocks.
#define JOINT_LOCK      0x0001
#define DEVICE_LOCK     0x0002
#define ADDRESS_LOCK    0x0004
#define CLIENT_LOCK     0x0008
#define CONNECT_LOCK    0x0010
#define LOWERCON_LOCK   0x0020
#define NBTCONFIG_LOCK  0x0040
#define WORKERQ_LOCK    0x0080

typedef struct
{
    DEFINE_LOCK_STRUCTURE( SpinLock )        // to lock access on an MP machine
#if DBG
    ULONG               LastLockLine;
    ULONG               LastReleaseLine;
    UCHAR               LockNumber;     // spin lock number for this struct
#endif  // DBG
} tNBT_LOCK_INFO;

// overall spin lock to coordinate access to timer entries and hash tables
// at the same time.  Always get the joint lock FIRST and then either the
// hash or timer lock.  Be sure not to get both hash and timer locks or
// dead lock could result
//
typedef struct
{
    tNBT_LOCK_INFO  LockInfo;
}tJOINTLOCK;

// these are two bits to indicated the state of a client element record
//
#define NBT_ACTIVE  1
#define NBT_DOWN    0

// This structure is used by the parse.c to hold on to an Irp from the
// lmhsvc.dll that is used for checking IP addr reachability or for doing
// DNS name queries.  It is also used for Handling LmHost queries.
//
typedef struct
{
    union
    {
        PCTE_IRP        QueryIrp;       // irp passed down from lmhsvc.dll
        tTIMERQENTRY    *pTimer;        // non null if the timer is running
    };
    LIST_ENTRY          ToResolve;      // linked list of names Q'd to resolve
    PVOID               Context;        // currently resolving name context block
    tIPADDR_BUFFER_DNS  *pIpAddrBuf;    // PlaceHolder for Mdl buffer location
    BOOLEAN             ResolvingNow;   // irp is in user mode doing a resolve
} tLMHSVC_REQUESTS;

#define DEFAULT_LMHOST_TIMEOUT      6000   // 6-12 to wait for lmhost or DNS query
#define MIN_LMHOST_TIMEOUT          1000    // 1  seconds min

//
// Lmhosts Domain Controller List - keeps a list of #DOM names that have
// been retrieved from the LMhosts file
//
typedef struct
{
    LIST_ENTRY  DomainList;

} tDOMAIN_LIST;
//
// The pIpList of a domain name starts with 6 ulongs of space
//
#define INITIAL_DOM_SIZE sizeof(tIPADDRESS)*6

#ifndef VXD
//
// This structure keeps track of the WINS recv Irp and any datagram
// queued to go up to WINS (name service datagrams)
//
typedef struct
{
    LIST_ENTRY      Linkage;
    ULONG           Verify;
    tIPADDRESS      IpAddress;

    LIST_ENTRY      RcvList;            // linked list of Datagrams Q'd to rcv
    LIST_ENTRY      SendList;           // Dgrams Q'd to be sent

    struct _DeviceContext  *pDeviceContext;    // the devicecontext used by wins for sends
    PCTE_IRP        RcvIrp;             // irp passed down from WINS for Rcv
    ULONG           RcvMemoryAllocated; // bytes buffered so far
    ULONG           RcvMemoryMax;       // max # of bytes to buffer on Rcv

    ULONG           SendMemoryAllocated;// bytes for buffering dgram sends
    ULONG           SendMemoryMax;      // max allowed for buffering dgram sends
    ULONG           WinsSignature;
} tWINS_INFO;

//
// Wins Rcv Buffer structure
//
typedef struct
{
    LIST_ENTRY      Linkage;
    ULONG           DgramLength;
    tREM_ADDRESS    Address;

} tWINSRCV_BUFFER;
#endif  // !VXD


// Connection Database...
// this tracks the connection to the transport and the address of the
// endpoint (Net Bios name) and a connection Context to return to the client
// on each Event (i.e. Receive event or Disconnect Event ).

// the possible states of the lower connection to the transport
enum eSTATE
{
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_RECONNECTING,       // waiting for the Worker thread to run NbtConnect again
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};

enum eREF_CONN
{
    REF_CONN_CREATE,
    REF_CONN_INBOUND,
    REF_CONN_SESSION,
    REF_CONN_CONNECT,
    REF_CONN_MULTIPLE_CONNECT,
    REF_CONN_CLEANUP_ADDR,
    REF_CONN_SESSION_TIMEOUT,
    REF_CONN_MAX
};

typedef struct _Connect
{
    // Line # 1
    LIST_ENTRY                Linkage;       // ptrs to next in chain
    ULONG                     Verify;        // set to a known value to verify block
    LONG                      RefCount;      // number of active requests on the connection

    // Line # 2
    struct _LowerConnection   *pLowerConnId; // connection ID to transport
    struct _DeviceContext     *pDeviceContext;
    struct _Client            *pClientEle;   // ptr to client record
    enum eSTATE               state;

    // Line # 3
    UCHAR RemoteName[NETBIOS_NAME_SIZE];

    // Line # 4
    PCTE_IRP                  pIrp;          // IRP ptr for a send
    PCTE_IRP                  pIrpClose;     // IRP for an NtClose
    PCTE_IRP                  pIrpDisc;      // IRP for Disconnects when connection is still pending
    PCTE_IRP                  pIrpRcv;       // IRP that client has passed down for a session Rcv

    // Line # 5
#ifndef VXD
    PMDL                      pNextMdl;      // the next MDL in the chain to use as a basis for a partial MDL
    PMDL                      pNewMdl;       // keep extra MDL if needed to handle multichunk rcvs
    ULONG                     CurrentRcvLen; // #of bytes to recv for Irp
    ULONG                     FreeBytesInMdl;// tracks how full current Mdl is in the FILLIRP state.
#else
    UCHAR RTO ;                              // NB Receive timeout (in 1/2 sec)
    UCHAR STO ;                              // NB Send timeout
    USHORT Flags ;
#endif  // !VXD

    // Line # 6
    ULONG                     BytesInXport;  // number of bytes left in the transport
    ULONG                     BytesRcvd;     // number of bytes recvd so far
    ULONG                     ReceiveIndicated; // count of number of rcv indicates not handled yet
    ULONG                     OffsetFromStart;// the amount of the Mdl/NCB that has been filled

    // Line # 7
    ULONG                     TotalPcktLen;  // length of session packet
    ULONG                     AddressType;   // type of address over which the connection was established
    CONNECTION_CONTEXT        ConnectContext;// ret to client on each event
    UCHAR                     SessionSetupCount; // number of tries in case destination is in b/w listens
    UCHAR                     DiscFlag;       // disconnect was an abort or normal release (NbtDisconnect)?
    // The DNS status of the remote name is recorded in this field. It is set to
    // FALSE on creation of a tCONNECTELE instance and changed to TRUE if the
    // DNS resolution for the Remote Name fails. This is used to throttle back
    // subsequent requests for the same DNS name.
    BOOLEAN RemoteNameDoesNotExistInDNS;
    BOOLEAN                   Orig;           // originating connection? (if conn in freelist to be deleted)

    // Line # 8
    LIST_ENTRY                RcvHead;       // List of Rcv Buffers

    // Line # 9
    PFILE_OBJECT              pClientFileObject;    // so that Rdr can get a backptr from the connection
    tNBT_LOCK_INFO            LockInfo;     // spin lock info for this struct

    BOOLEAN                   JunkMsgFlag;
    // The NetBt Connection logic manages a pool of lower connection blocks. These
    // entries are replenished with every associate call made from the client.
    // The entries are removed with a fresh invocation to NbtConnectCommon.
    // Since it is conceivable that multiple invocations to NbtConnectCommon can be
    // made this state needs to be recorded in the connect element.
    BOOLEAN                   LowerConnBlockRemoved;
#ifdef RASAUTODIAL
    // this field is TRUE if an automatic connection is in progress
    // for this connection.  we use this to prevent an infinite
    // number of automatic connection attempts to the same address.
    BOOLEAN                   fAutoConnecting;
    // this field is TRUE if this connection has already been
    // autoconnected.
    BOOLEAN                   fAutoConnected;
#endif  // RASAUTODIAL
    BOOLEAN                   ConnectionCleanedUp;

// #if DBG
    UCHAR                       References[REF_CONN_MAX];
// #endif  // DBG
} tCONNECTELE;


// Placeholder for TCP Send routine if Fast Send is possible
typedef
NTSTATUS
(*PTCPSEND_DISPATCH) (
   IN PIRP Irp,
   IN PIO_STACK_LOCATION irpsp
   );



//
// Enumerate all the different contexts under which the LowerConnection
// is referenced
//
enum eREF_LOWERCONN
{
    REF_LOWC_CREATE,
    REF_LOWC_ASSOC_CONNECTION,
    REF_LOWC_CONNECTED,
    REF_LOWC_WAITING_INBOUND,
    REF_LOWC_DISABLE_INBOUND,
    REF_LOWC_KEEP_ALIVE,
    REF_LOWC_QUERY_DEVICE_REL,
    REF_LOWC_QUERY_INFO,
    REF_LOWC_SET_TCP_INFO,
    REF_LOWC_RCV_HANDLER,
    REF_LOWC_OUT_OF_RSRC,
    REF_LOWC_SEND,
    REF_LOWC_MAX
};


// a list of connections to the transport.  For each connection opened
// to the transport, the connection context is set to the address of this
// block so that when info comes in on the conection, the pUpperConnection
// ptr can be used to find the client connection
typedef struct _LowerConnection
{
    // Line # 1
    LIST_ENTRY              Linkage;
    ULONG                   Verify;
    LONG                    RefCount;           // the number of active users of record

    // Line # 2
    struct _Connect         *pUpperConnection;  // ptr to upper conn. to client
    struct _DeviceContext   *pDeviceContext;    // so we can put connection back on its free list at the end
    enum eSTATE             State;
    USHORT                  StateRcv;           // the receive state = Normal/UseIndic/FillIrp/PartialRcv
    BOOLEAN                 bOriginator;        // TRUE if the connection originated on this side
    BOOLEAN                 OutOfRsrcFlag;      // Set when connection is queued onto the OutOfRsrc list to
                                                // indicate to DeleteLowerConn not to remove from any list.
    BOOLEAN bNoOutRsrcKill; // Set when connection is disconnected and haven't been queued onto the OutOfRsrc list

    // Line # 3
    PCTE_IRP                pIrp;               // Irp to complete after disconnect completes
    ULONG                   SrcIpAddr;
#ifndef VXD
    PMDL                    pIndicateMdl;       // This mdl holds up to 128 bytes as mandated by TDI
    PMDL                    pMdl;               // So that if we receive session PDU in several chunks,
#endif  // !VXD                                 // we can reset original Mdl

    // Line # 4
    // Contains Handle/Object of a TDI Connection for incoming connections
    CTE_ADDR_HANDLE         pFileObject;        // file object for the connection
    // Address object handles - used for outgoing connections only since
    // inbound connections are all bound to the same address object (port 139)
    //
    // The VXD uses only pAddrFileObject which contains the openned address
    // handle (used for compatibility with existing code).
    //
    CTE_ADDR_HANDLE         pAddrFileObject;    // file object for the address
#ifndef VXD
    HANDLE                  FileHandle;         // file handle for connection to transport
    HANDLE                  AddrFileHandle;     // file handle for the address

    // Line # 5
    // in the receive handler this procedure variable is used to point to the
    // procedure to call for the current state (Normal,FillIrp,IndicateBuff,RcvPartial)
    ULONGLONG               BytesRcvd;          // for query provider statistics
    ULONGLONG               BytesSent;

    // Line # 6
    tCURRENTSTATEPROC       CurrentStateProc;
    ULONG                   BytesInIndicate;    // the number of bytes in the indicate buffer
    ULONG                   TimeUnitsInLastState;
#else
    ULONG                   BytesRcvd;          // for query provider statistics
    ULONG                   BytesSent;
    tSESSIONHDR             Hdr ;   // VXD only has to worry about getting enough data for the session header
    LIST_ENTRY              PartialRcvList;     // When we go into partial rcv state, until NCB is submitted
    USHORT                  BytesInHdr;         //  Number of bytes in Hdr
    BOOLEAN                 fOnPartialRcvList;
#endif  // !VXD
    tNBT_LOCK_INFO          LockInfo;           // spin lock info for this struct
    // this flag is set true when executing the session Rcv Handler so we
    // can detect this state and not free ConnEle or LowerConn memory.
    BOOLEAN                 InRcvHandler;
    BOOLEAN                 SpecialAlloc;       // If this ws allocated to tackle TCP/IP SynAttack problem

    // Placeholder for TCP Send routine if Fast Send is possible
    PTCPSEND_DISPATCH       FastSend;

    //
    // Another ugly patch!!!  -- JRuan
    //
    BOOLEAN                 bDisconnectIrpPendingInTCP;

    NBT_WORK_ITEM_CONTEXT WorkItemCleanUpAndWipeOut;

// #if DBG
    UCHAR               References[REF_LOWC_MAX];
// #endif  // DBG
} tLOWERCONNECTION;


#define NBT_DISASSOCIATE_CONNECTION(_pConnEle, _pLowerConn)     \
        _pConnEle->pLowerConnId = NULL;                         \
        _pLowerConn->pUpperConnection = NULL;

#define SET_STATE_UPPER(_C, _S)         \
    _C->state = _S;

#define SET_STATE_LOWER(_L, _S)         \
    _L->State = _S;                     \
    _L->TimeUnitsInLastState = 0;

#define SET_STATERCV_LOWER(_L, _S, _P)  \
    _L->StateRcv = _S;                  \
    SetStateProc(_L, _P);               \
    _L->TimeUnitsInLastState = 0;


// the Client list is just a list of linked blocks where the address of the
// block is the HANDLE returned to the client - The client block is linked onto
// the chain of clients that have opened the address.
typedef struct _Client
{
    // Line # 1
    LIST_ENTRY         Linkage;       // double linked list to next client
    ULONG              Verify;        // set to a known value to verify block
    LONG               RefCount;

    // Line # 2
    PCTE_IRP           pIrp;          // IRP ptr for NT only... during name registration

    struct _DeviceContext *pDeviceContext; // the device context associated with this connection
    struct _Address    *pAddress;     // ptr to address object that this client is Q'd on
    ULONG              AddressType;   // Stashed value of the original value stored in the address element.

    // Line # 3
    UCHAR              EndpointName[NETBIOS_NAME_SIZE];

    // Line # 4
    LIST_ENTRY         ConnectHead;   // list of connections
    LIST_ENTRY         ConnectActive; // list of connections that are in use

    // Line # 5
    LIST_ENTRY         RcvDgramHead;  // List of dgram buffers to recv into
    LIST_ENTRY         ListenHead;    // List of Active Listens

    // Line # 6
    LIST_ENTRY         SndDgrams;     // a doubly linked list of Dgrams to send
#ifdef VXD
    LIST_ENTRY         RcvAnyHead ;   // List of RCV_CONTEXT for NCB Receive any
    BOOL               fDeregistered; // TRUE if name has been deleted and we're waiting for sessions to close
#endif  // VXD
    PTDI_IND_CONNECT   evConnect;     // Client Event to call
    PVOID              ConEvContext;  // EVENT Context to pass to client

    // Line # 7
    PTDI_IND_RECEIVE   evReceive;
    PVOID              RcvEvContext;
    PTDI_IND_DISCONNECT evDisconnect;
    PVOID              DiscEvContext;

    // Line # 8
    PTDI_IND_ERROR     evError;
    PVOID              ErrorEvContext;
    PTDI_IND_RECEIVE_DATAGRAM  evRcvDgram;
    PVOID              RcvDgramEvContext;

    // Line # 9
    PTDI_IND_RECEIVE_EXPEDITED evRcvExpedited;
    PVOID              RcvExpedEvContext;
    PTDI_IND_SEND_POSSIBLE evSendPossible;
    PVOID              SendPossEvContext;

    // Line # 10
    tNBT_LOCK_INFO     LockInfo;     // spin lock info for this struct
    BOOLEAN            ExtendedAddress;
    BOOLEAN            WaitingForRegistration;  // If several clients register the same name at the same time
} tCLIENTELE;                                   // It is reset in RegisterCompletion.


enum eREF_FSP
{
    REF_FSP_CONN,
    REF_FSP_NEWADDR,
    REF_FSP_WAKEUP_TIMER_EXPIRY,
    REF_FSP_STOP_WAKEUP_TIMER,
    REF_FSP_START_WAKEUP_TIMER,
    REF_FSP_SET_TCP_INFO,
    REF_FSP_ADD_INTERFACE,
    REF_FSP_DEVICE_ADD,
    REF_FSP_CREATE_SMB_DEVICE,
    REF_FSP_CREATE_DEVICE,
    REF_FSP_DELETE_DEVICE,
    REF_FSP_CLOSE_FILE_HANDLES,
    REF_FSP_CLOSE_ADDRESSES,
    REF_FSP_CLOSE_FILE,
    REF_FSP_PROCESS_IP_REQUEST,
    REF_FSP_CLOSE_CONNECTION,
    REF_FSP_CLOSE_ADDRESS,
    REF_FSP_MAX
};


//
// Enumerate all the different places the Address can be referenced to
// keep track of RefCounts
//
enum eREF_ADDRESS
{
    REF_ADDR_NEW_CLIENT,
    REF_ADDR_REGISTER_NAME,
    REF_ADDR_REG_COMPLETION,
    REF_ADDR_REFRESH,
    REF_ADDR_DGRAM,
    REF_ADDR_MULTICLIENTS,
    REF_ADDR_DEL_DEVICE,
    REF_ADDR_MAX
};

// The Address List is a set of blocks that contain the netbios names active
// on the node.  Each time a connection request comes in or a datagram is
// received, the destination name must be found in the address list.
// There is one of these for each Netbios name in the system, although there
// can be more than one client attached to each of these.  In addition,
// a client can open the same name for several different adapters. In this case
// the nbt code first finds the ptr to this address element, and then it walks
// the client list to find a client with a "deviceContext" (ip address) that
// matches the adapter that the pdu came in on.
typedef struct _Address
{
    // Line # 1
    LIST_ENTRY         Linkage;         // link to next item in list
    ULONG              Verify;          // set to a known value to verify block
    LONG               RefCount;

    // Line # 2
    LIST_ENTRY         ClientHead;      // list of client records Q'd against address
    tNAMEADDR          *pNameAddr;      // ptr to entry in hash table
    ULONG              AddressType;     // Type of address specified in opening the connection object
                                        // when names are added in NbtOpenAddress

    // Line # 3
    USHORT             NameType;        // Group or Unique NAMETYPE_UNIQUE or group
    BOOLEAN            MultiClients;    // signals Dgram Rcv handler that more than one client exists - set
    tNBT_LOCK_INFO     LockInfo;        // spin lock info for this struct

    NBT_WORK_ITEM_CONTEXT WorkItemClose;

#ifndef VXD
    SHARE_ACCESS       ShareAccess;     // Used for checking share access
    PSECURITY_DESCRIPTOR SecurityDescriptor; // used to hold ACLs on the address
#endif  // !VXD
} tADDRESSELE;


// this structure is used to store the addresses of the name servers
// for each adapter - it is used in Registry.c and Driver.c
//
typedef struct
{
    union
    {
        tIPADDRESS      AllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  NameServerAddress;
            tIPADDRESS  BackupServer;
            tIPADDRESS  Others[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };
    USHORT  NumOtherServers;
    USHORT  LastResponsive;
#ifdef _NETBIOSLESS
    BOOLEAN NetbiosEnabled;
#endif  // _NETBIOSLESS
    ULONG   RasProxyFlags;
    BOOLEAN EnableNagling;
}tADDRARRAY;

typedef struct
{
    UCHAR   Address[6];
}tMAC_ADDRESS;


typedef ULONG IPAddr;

// Placeholder for IP FastQuery routine to determine InterfaceContext + metric for dest addr
typedef
NTSTATUS
(*PIPFASTQUERY)(
    IN   IPAddr  Address,
    OUT  PULONG   pIndex,
    OUT  PULONG   pMetric
    );



//
// Enumerate all the different places the device can be referenced to
// keep track of RefCounts
//
enum eREF_DEVICE
{
    REF_DEV_DISPATCH,
    REF_DEV_WORKER,
    REF_DEV_TIMER,
    REF_DEV_LMH,
    REF_DEV_OUTBOUND,
    REF_DEV_DGRAM,
    REF_DEV_FIND_REF,
    REF_DEV_NAME_REL,
    REF_DEV_REREG,
    REF_DEV_GET_REF,
    REF_DEV_OUT_FROM_IP,
    REF_DEV_UDP_SEND,
    REF_DEV_WINS,
    REF_DEV_AUTODIAL,
    REF_DEV_CREATE,
    REF_DEV_SMB_BIND,
    REF_DEV_MAX
};


// this type is the device context which includes NBT specific data
// that is initialized when "DriverEntry" is called.
//

//
// The transport type is used to distinguish the additional transport types
// that can be supported, NETBT framing without NETBIOS name resolution/registration
// and NETBIOS over TCP. The transport type is stored as part of all the upper
// level data structures. This enables us to reuse NETBT code and expose multiple
// device objects at the top level. Currently these are not exposed. In preparation
// for exporting multiple transport device objects the DeviceContext has been
// reorganized.
// The elements that would be common to all the device objects have been gathered
// together in tCOMMONDEVICECONTEXT. This will include an enumerated type to
// distinguish between the various device objects in the future. Currently there is only
// one device context and the fields that belong to it are listed ...
//
// RegistrationHandle -- PNP power,
// enumerated type distinguishing the types.
//

typedef struct _DeviceContext
{
    // the I/O system's device object
    DEVICE_OBJECT   DeviceObject;
    ULONG           IsDestroyed;        // ulong since we use interlocked ops to manipulate it.
    enum eNbtDevice DeviceType;         // Whether it is a regular device or a "special" device

    // Line # 12 (0xc0)
    LIST_ENTRY      Linkage;            // For storage in the tNBTCONFIG structure
    ULONG           Verify;             // To verify that this is a device context record
    ULONG           RefCount;           // keep this device around until all names have been released

    // Line # 13 (0xd0)
    LIST_ENTRY      WaitingForInbound;  // list of pLowerConn's waiting for SessionSetup from remote
    LIST_ENTRY      UpConnectionInUse;  // connections that the clients have created

    // Line # 14 (0xe0)
    LIST_ENTRY      LowerConnection;    // Currently-used connections to the transport provider
    LIST_ENTRY      LowerConnFreeHead;  // Connected to transport but not currently to a client(upper) conn.
                                        // - ready to accept an incoming session

    // Line # 15 (0xf0)
    ULONG           NumWaitingForInbound;  // number of pLowerConn's waiting for SessionSetup from remote
    ULONG           NumQueuedForAlloc;
    ULONG           NumSpecialLowerConn;
    tCLIENTELE      *pPermClient;       // permanent name client record (in case we have to delete it later)

    // Line # 16 (0x100)
    UNICODE_STRING  BindName;           // name of the device to bind to - *TODO* remove from this struct.
    UNICODE_STRING  ExportName;         // name exported by this device

    // Line # 17 (0x110)
    tIPADDRESS      IpAddress;          // addresses that need to be opened with the transport
    tIPADDRESS      SubnetMask;
    tIPADDRESS      BroadcastAddress;
    tIPADDRESS      NetMask;            // mask for the network number

    // Line # 18 (0x120)
    union
    {
        tIPADDRESS      lAllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  lNameServerAddress; // the Ip Address of the Name Server
            tIPADDRESS  lBackupServer;
            tIPADDRESS  lOtherServers[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };

    // Line # 21 (0x150)
    USHORT          lNumOtherServers;
    USHORT          lLastResponsive;
    ULONG           NumAdditionalIpAddresses;
    CTEULONGLONG    AdapterMask;        // bit mask for adapters 1->64 (1-32 for VXD)

    // Line # 22 (0x160)
    HANDLE          DeviceRegistrationHandle;       // Handle returned from TdiRegisterDeviceObject.
    HANDLE          NetAddressRegistrationHandle;   // Handle returned from TdiRegisterNetAddress.
    ULONG           InstanceNumber;
    ULONG           WakeupPatternRefCount;

    // Line # 23 (0x170)
    UCHAR           WakeupPatternName[NETBIOS_NAME_SIZE];

    // Line # 24 (0x180)
    tFILE_OBJECTS   *pFileObjects;      // Pointer to FileObjects on the Transport
    HANDLE          hSession;
    PDEVICE_OBJECT  pSessionDeviceObject;
    CTE_ADDR_HANDLE pSessionFileObject;


    // Line # 25 (0x190)
    // these are handles to the transport control object, so we can do things
    // like query provider info... *TODO* this info may not need to be kept
    // around... just set it up once and then drop it?
    HANDLE          hControl;
    PDEVICE_OBJECT  pControlDeviceObject;
    PFILE_OBJECT    pControlFileObject;
    KEVENT          DeviceCleanedupEvent;

    // Line # 26 (0x1a0)
    //
    ULONG           AdapterNumber;      // index of adapter in DeviceContexts list (starts from 1)
    ULONG           IPInterfaceContext; // Context value for IP adapter
    PTCPSEND_DISPATCH   pFastSend;      // function ptr for doing a FastSend into TcpIp
    PIPFASTQUERY    pFastQuery;         // function ptr for doing a FastQuery for interface + metric info
    ULONG           WOLProperties;      // Whether this Device supports WOL or not!

    // Handles for open addresses to the transport provider
    // The VXD uses only the p*FileObject fields which contain TDI Addresses or connection IDs
    //
    NETBT_PNP_CONTEXT Context1;                   // This is to store the Device Name to pass as the context
    NETBT_PNP_CONTEXT Context2;                   // This is to store the PDOContext passed to us from TCPIP
    // this is a bit mask, a bit shifted to the bit location corresponding
    // to this adapter number
    tMAC_ADDRESS    MacAddress;

    tNBT_LOCK_INFO  LockInfo;           // spin lock info for this struct
    BOOLEAN         RefreshToBackup;    // flag to say switch to backup nameserver
    BOOLEAN         SwitchedToBackup;   // flag to say whether we are on original Primary or Backup
    BOOLEAN         WinsIsDown;         // per Devcontext flag to tell us not to contact WINS for 15 sec.
    UCHAR           DeviceRefreshState; // Keep track of whether this is a new refresh of not

    ULONG           IpInterfaceFlags;   // From IOCTL_TCP_QUERY_INFORMATION_EX (has P2P and P2MP flags)
    ULONG           AssignedIpAddress;  // addresses that need to be opened with the transport
    BOOLEAN         NetbiosEnabled;     // Flag indicating device is currently active
    ULONG           RasProxyFlags;      // Flags for RAS proxy
    USHORT          SessionPort;        // Session port to use
    USHORT          NameServerPort;     // Name server port to use
    USHORT          DatagramPort;       // Datagram port to use
    CHAR            MessageEndpoint[NETBIOS_NAME_SIZE];       // Endpoint to use for message only

    ULONG           NumFreeLowerConnections;
    ULONG           TotalLowerConnections;
    ULONG           NumServers;
    BOOLEAN         EnableNagling;
    tIPADDRESS      AdditionalIpAddresses[MAX_IP_ADDRS];
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    enum eTDI_ACTION    DelayedNotification;
    KEVENT              DelayedNotificationCompleteEvent;
#endif

    NBT_WORK_ITEM_CONTEXT WorkItemDeleteDevice;

// #if DBG
    ULONG           ReferenceContexts[REF_DEV_MAX];
// #endif  // DBG
} tDEVICECONTEXT;


#ifdef VXD

typedef void (*DCCallback)( PVOID pContext ) ;

typedef struct
{
    NBT_WORK_ITEM_CONTEXT  dc_WIC ;         // Must be first item in structure
    CTEEvent               dc_event ;
    DCCallback             dc_Callback ;
    struct _DeviceContext *pDeviceContext;
    LIST_ENTRY             Linkage;
} DELAYED_CALL_CONTEXT, *PDELAYED_CALL_CONTEXT ;

typedef struct
{
    LIST_ENTRY       Linkage;
    ULONG            Verify;
    NCB             *pNCB;
    CTEBlockStruc   *pWaitNCBBlock;
    BOOL             fNCBCompleted;
    BOOL             fBlocked;
} BLOCKING_NCB_CONTEXT, *PBLOCKING_NCB_CONTEXT;



typedef struct
{
    //
    // Book keeping.
    //
    LIST_ENTRY      Linkage;
    tTIMERQENTRY    *pTimer;    // ptr to active timer entry
    tDEVICECONTEXT  *pDeviceContext;
    //
    // Domain name for next query.
    //
    PUCHAR          pchDomainName;
    //
    // Flags to track progress.
    //
    USHORT          Flags;
    //
    // Transaction ID used in name query.
    //
    USHORT          TransactId;
    //
    // Client fields follow.
    