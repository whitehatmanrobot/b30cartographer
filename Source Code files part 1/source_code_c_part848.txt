leEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile )
{
    HRESULT hr;
    LPTSTR  lpszDst;
    LPTSTR  lpszFile;
    int     cchFile;
    LPTSTR  lpszPath;
    WCHAR   rgchUrlPath[MAX_PATH];
    DWORD   dwLen;

    dwLen = ARRAYSIZE(rgchUrlPath);

    hr = PathCreateFromUrlW(bstrURL, rgchUrlPath, &dwLen, 0);
    if (FAILED(hr))
        return E_FAIL;

    lpszPath = rgchUrlPath;

    if (lpstrSrcFile)
        StringCchCopy( lpstrSrcFile,  MAX_PATH, lpszPath);

    lpszFile = PathFindFileName( lpszPath );
    ASSERT(lpszFile != NULL);
    cchFile = ARRAYSIZE(rgchUrlPath) - (int)(lpszFile-rgchUrlPath);

    hr = THR(_Insert( bstrURL, lpszFile, cchFile, pphe )); 

    lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, lpszFile );
    ASSERT( lpszDst );

    RRETURN(hr);
}

HRESULT
CThicketArchive::_AddMiscEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, int cchDstFile )
{
    HRESULT hr;
    TCHAR   szT[MAX_PATH];
    LPTSTR  lpszPrefix;
    LPTSTR  lpszDst;

    lpszPrefix = bstrURL;

    if (GetTempFileName( m_lpstrFilesDir, lpszPrefix, 0,szT ))
    {
        lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, szT );
        ASSERT(lpszDst);

        LPTSTR pszFile = PathFindFileName(lpstrDstFile);
        hr = THR(_Insert( bstrURL, pszFile, cchDstFile - (int)(pszFile-lpstrDstFile), pphe ));
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistHttpURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    TCHAR   szSrc[MAX_PATH];

    hr = THR(_AddHttpEntry(  bstrURL, pphe, szDst, szSrc ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szSrc), m_lpstrFilesDir );

    if (!CopyFile(szSrc,szDst, FALSE))
        hr = HRESULT_FROM_WIN32(GetLastError());

Error:
    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistFileURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    TCHAR   szSrc[MAX_PATH];

    hr = THR(_AddFileEntry(  bstrURL, pphe, szDst, szSrc ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szSrc), m_lpstrFilesDir );

    if (!CopyFile(szSrc,szDst, FALSE))
        hr = HRESULT_FROM_WIN32(GetLastError());

Error:
    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistMiscURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    LPTSTR  lpszURL;

    lpszURL = bstrURL;

    hr = THR(_AddMiscEntry(  bstrURL, pphe, szDst, ARRAYSIZE(szDst) ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szDst), m_lpstrFilesDir );

    hr = URLDownloadToFile(NULL, lpszURL, szDst,0, NULL);

Error:
    RRETURN(hr);
}


HRESULT
CThicketArchive::_Insert(BSTR bstrI, LPTSTR lpszFile, int cchFile, CHashEntry **pphe )
{
    HRESULT hr = S_OK;
    BSTR    bstrThicket = NULL;
    TCHAR   buf[MAX_PATH];
    int     i = 0;

    CHashEntry *phe = &m_rgBins[Hash(bstrI)];
    
    ASSERT(pphe != NULL);

    *pphe = NULL;

    if (lstrlen(m_lpstrFilesDir) + lstrlen(lpszFile) + 1 < MAX_PATH)
        StringCchPrintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), m_lpstrFilesDir, lpszFile );
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Defend against bug 18160 - collision of file names in the thicket.
    if ( PathFileExists(buf) )
    {
        TCHAR *pszExt = PathFindExtension(lpszFile);
        int   i = 0;

        // chop the file name into name and extenstion
        if ( pszExt )
        {
            *pszExt = 0;
            pszExt++;
        }

        do
        {
            i++;

            if ( pszExt )
                StringCchPrintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s(%d).%s"), m_lpstrFilesDir, lpszFile, i, pszExt );
            else
                StringCchPrintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s(%d)"), m_lpstrFilesDir, lpszFile, i );

        } while ( PathFileExists(buf) && i < 1000 );


        // deviously rewrite the file name for the caller
        StringCchCopy(lpszFile, cchFile, PathFindFileName(buf));
    }
    else
        StringCchPrintf( buf, ARRAYSIZE(buf), TEXT("%s/%s"), m_lpstrFilesDirName, lpszFile );
    
    bstrThicket = SysAllocString(buf);
    if (bstrThicket == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (phe->m_bstrKey)
    {        
        CHashEntry *pheNew = new CHashEntry;
        
        if (pheNew==NULL)
            return E_OUTOFMEMORY;

        if (pheNew->SetKey(bstrI) && pheNew->SetValue(bstrThicket))
            *pphe = pheNew;
        else
        {
            delete pheNew;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pheNew->m_pheNext = phe->m_pheNext;
        phe->m_pheNext = pheNew;
        phe = pheNew;
    } 
    else if (phe->SetKey(bstrI) && phe->SetValue(bstrThicket))
        *pphe = phe;
    else
        hr = E_OUTOFMEMORY;
        
Cleanup:
    if (bstrThicket)
        SysFreeString(bstrThicket);

    return hr;
}


HRESULT 
CThicketArchive::_BackupOldDirectory()
{
    int n = 1;
    HRESULT hr = S_OK;
    TCHAR szFmt[MAX_PATH];

    // Do we need to do this under critical section?
    MLLoadString(IDS_THICKETTEMPFMT, szFmt, ARRAYSIZE(szFmt));

    do {
        if (m_lpstrSafeDir)
        {
            LocalFree( m_lpstrSafeDir );
            m_lpstrSafeDir = NULL;
        }

        if (n > 100)    // avoid infinite loop!
            break;

        DWORD cchSafeDir = lstrlen(m_lpstrFilesDir) + lstrlen(szFmt) + 1;
        m_lpstrSafeDir = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cchSafeDir );
        if (m_lpstrSafeDir!=NULL)
        {
            StringCchPrintf( m_lpstrSafeDir, cchSafeDir, szFmt, m_lpstrFilesDir, n++ );
        }
        else
            hr = E_OUTOFMEMORY;

    } while (SUCCEEDED(hr) && GetFileAttributes(m_lpstrSafeDir) != -1 && n < 1000);

    // rename the old version of the supporting files directory
    if (SUCCEEDED(hr) && !MoveFile(m_lpstrFilesDir, m_lpstrSafeDir))
    {
        LocalFree( m_lpstrSafeDir );
        m_lpstrSafeDir = NULL;

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

HRESULT
CThicketArchive::_RemoveOldDirectoryAndChildren( LPCWSTR pwzDir )
{
    HRESULT hr = S_OK;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WCHAR wzBuf[MAX_PATH];
    WIN32_FIND_DATAW fd;

    if (!pwzDir)
        goto Exit;

    if (RemoveDirectoryW(pwzDir))
        goto Exit;

    // FindNextFile returns 120, not implemented on OSR2, so we'll have to do all
    // this stuff multibyte

    StringCchCopy(wzBuf, ARRAYSIZE(wzBuf), pwzDir);
    StringCchCat(wzBuf,  ARRAYSIZE(wzBuf), FILENAME_SEPARATOR_STR_W L"*");

    if ((hf = FindFirstFileW(wzBuf, &fd)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    do {

        if ( (StrCmpW(fd.cFileName, L".") == 0) ||
             (StrCmpW(fd.cFileName, L"..") == 0))
            continue;

        StringCchPrintf(wzBuf, ARRAYSIZE(wzBuf), L"%s" FILENAME_SEPARATOR_STR_W L"%s", pwzDir, fd.cFileName);

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            SetFileAttributesW(wzBuf, 
                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL);

            if (FAILED((hr=_RemoveOldDirectoryAndChildren(wzBuf)))) {
                goto Exit;
            }

        } else {

            SetFileAttributesW(wzBuf, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFileW(wzBuf)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }


    } while (FindNextFileW(hf, &fd));


    if (GetLastError() != ERROR_NO_MORE_FILES) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (hf != INVALID_HANDLE_VALUE) {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    // here if all subdirs/children removed
    /// re-attempt to remove the main dir
    if (!RemoveDirectoryW(pwzDir)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:

    if (hf != INVALID_HANDLE_VALUE)
        FindClose(hf);

    RRETURN(hr);
}



/*
 *  CMHTMLArchive ##################################################
 */

CMHTMLArchive::CMHTMLArchive(CThicketProgress *ptp) :
    CWebArchive(ptp),
    m_hBodyAlt(NULL),
    m_pimm(NULL)
{
}


CMHTMLArchive::~CMHTMLArchive(void)
{  
    ReleaseInterface(m_pimm);
}


HRESULT
CMHTMLArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = S_OK;
  
    MimeOleSetCompatMode(MIMEOLE_COMPAT_MLANG2);
  
    if ( m_pimm == NULL )
    {
        hr = CWebArchive::Init( lpstrDoc, dwHashSize );
        if (SUCCEEDED(hr))
            hr = MimeOleCreateMessage(NULL, &m_pimm);
    }

    RRETURN(hr);
}


HRESULT
CMHTMLArchive::AddURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe));
    
    if (FAILED(hr))
    {       
        IStream     *pstm = NULL;
        CHAR        szUrl[INTERNET_MAX_URL_LENGTH];
        WCHAR       wzArchiveText[MAX_SAVING_STATUS_TEXT + 1];
        WCHAR       wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];
        LPSTR       lpszCID=0;
        DWORD       dwAttach = URL_ATTACH_SET_CNTTYPE; 

        SHUnicodeToAnsi(bstrURL, szUrl, ARRAYSIZE(szUrl));

        // hack: if it's an MHTML: url then we have to fixup to get the cid:
        if (StrCmpNIA(szUrl, "mhtml:", 6)==0)
        {
            LPSTR lpszBody;

            if (SUCCEEDED(MimeOleParseMhtmlUrl(szUrl, NULL, &lpszBody)))
            {
                StringCchCopyA(szUrl,  INTERNET_MAX_URL_LENGTH, lpszBody);
                CoTaskMemFree(lpszBody);
            }
        }

        MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzArchiveText,
                      ARRAYSIZE(wzArchiveText));

        StringCchPrintf(wzBuf, ARRAYSIZE(wzBuf), L"%ws: %ws", wzArchiveText, bstrURL);
        m_ptp->SetSaveText(wzBuf);

#ifndef WIN16  //RUN16_BLOCK - NOT YET AVAILABLE
        hr = URLOpenBlockingStreamW(NULL, bstrURL, &pstm, 0, NULL);
#else
        hr = MIME_E_URL_NOTFOUND;
#endif

        if (SUCCEEDED(hr))
        {
            HBODY hBody;

            hr = m_pimm->AttachURL(NULL, szUrl, dwAttach, pstm, &lpszCID, &hBody);

            if (SUCCEEDED(hr))
                hr = _Insert( bstrURL, bstrURL, pphe );
        }

        ReleaseInterface(pstm);
    }
    
    RRETURN(hr);
}

HRESULT
CMHTMLArchive::AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe)); // there's always a slim chance we're reusing a frame.
    
    if (FAILED(hr))
    {     
        // insert place-holder
        hr = _Insert(bstrURL, c_bstr_BLANK, pphe);  
    }
    
    return hr; // no RRETURN - may return S_FALSE
}



HRESULT
CMHTMLArchive::ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit* ppsi = NULL;
    PROPVARIANT             variant;
    FILETIME                filetime;
    WCHAR                   wzBuffer[MAX_BUFFER_LEN];
    WCHAR                   wzArchiveText[MAX_SAVING_STATUS_TEXT + 1];
    WCHAR                   wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];

    // Set the MIME subject header

    PropVariantClear(&variant);
    variant.vt = VT_LPWSTR;
    hr = pDoc->get_title(&variant.pwszVal);
    if (SUCCEEDED(hr))
    {
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0,
                                 &variant);
        SAFEFREEBSTR(variant.pwszVal);
    }

    // Set the MIME date header

    if (SUCCEEDED(hr))
    {
        hr = CoFileTimeNow(&filetime);
    }

    if (SUCCEEDED(hr))
    {
        PropVariantClear(&variant);
        variant.vt = VT_FILETIME;
        variant.filetime = filetime;
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_DATE), 0,
                                 &variant);
    }

    // Set the MIME from header

    if (SUCCEEDED(hr))
    {
        MLLoadStringW(IDS_MIME_SAVEAS_HEADER_FROM, wzBuffer,
                      ARRAYSIZE(wzBuffer));

        PropVariantClear(&variant);
        variant.vt = VT_LPWSTR;
        variant.pwszVal = wzBuffer;
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0,
                                 &variant);
    }
    
    hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**)&ppsi);
    if (SUCCEEDED(hr))
    {
        IStream *pstm = NULL;

        hr = MimeOleCreateVirtualStream( &pstm );
        if ( SUCCEEDED(hr) )
        {
            HBODY hBody;
            hr = ppsi->Save(pstm, FALSE);


            if (SUCCEEDED(hr))
            {
                BSTR    bstrDocURL = NULL;
                WCHAR  *pwzBookMark = NULL;
                
                pDoc->get_URL(&bstrDocURL);
                RemoveBookMark(bstrDocURL, &pwzBookMark);

                if (!StrCmpIW(bstrDocURL, URL_ABOUT_BLANK))
                {
                    // We got about:blank as the URL (because the doc has
                    // document.write's etc in it). We can't save this!
                    hr = E_FAIL;
                    goto Exit;
                }

                MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzArchiveText,
                              ARRAYSIZE(wzArchiveText));
        
                StringCchPrintf(wzBuf, ARRAYSIZE(wzBuf), L"%ws: %ws", wzArchiveText, bstrDocURL);
                m_ptp->SetSaveText(wzBuf);


                if (fFrameDoc)
                {
                    CHAR    szURL[INTERNET_MAX_URL_LENGTH];
                    LPSTR   lpszCID = NULL;
                    DWORD   dwAttach = URL_ATTACH_SET_CNTTYPE; 
        
                    szURL[0] = 0;

        
                    if (WideCharToMultiByte(CP_ACP, 0, bstrDocURL, -1, szURL, INTERNET_MAX_URL_LENGTH, NULL, NULL))
                    {

                        hr = m_pimm->AttachURL(NULL, szURL, dwAttach,
                                               pstm, &lpszCID, &hBody);

                        if (SUCCEEDED(hr) && cpDoc)
                        {
                            IMimeBody         *pBody = NULL;

                            hr = m_pimm->BindToObject(hBody, IID_IMimeBody,
                                                      (LPVOID *)&pBody);
                            if (SUCCEEDED(hr))
                            {
                                hr = SetCharset(cpDoc, CSET_APPLY_TAG_ALL, pBody);
                            }
                            pBody->Release();
                        }

                        if (SUCCEEDED(hr))
                        {
                            CHashEntry *phe;

                            LPWSTR  pwz = NULL;
                            int     iLen = 0;

                            // If it is ASP, it is actually HTML
            
                            iLen = lstrlenW(bstrDocURL);
            
                            if (iLen) {
                                pwz = StrRChrW(bstrDocURL, bstrDocURL + iLen, L'.');
                            }
            
            
                            if (pwz && !StrCmpIW(pwz, TEXT(".asp")))
                            {
                                PROPVARIANT             propvar;

                                PropVariantClear(&propvar);
                                propvar.vt = VT_LPSTR;
                                propvar.pszVal = "text/html";
                                hr = m_pimm->SetBodyProp(hBody,
                                                         PIDTOSTR(PID_HDR_CNTTYPE),
                                                         0, &propvar);
                            }

                            if ( m_hBodyAlt == NULL )
                                m_hBodyAlt = hBody;

                            // update the place-holder hash entry
                            hr = Find( bstrDocURL, &phe);
                            if (SUCCEEDED(hr))
                            {
                                ASSERT(phe != NULL);
                                phe->SetValue( bstrDocURL );
                            }
                        }
                    }
                    else
                         hr = HRESULT_FROM_WIN32(GetLastError());

                }
                else
                {
                    hr = m_pimm->SetTextBody( TXT_HTML, IET_INETCSET, m_hBodyAlt, pstm, &hBody);
                    // The main text was the last thing we were waiting for
                    if (SUCCEEDED(hr) && cpDoc)
                    {
                        IMimeBody         *pBody = NULL;

                        hr = m_pimm->BindToObject(hBody, IID_IMimeBody,
                                                  (LPVOID *)&pBody);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetCharset(cpDoc, CSET_APPLY_TAG_ALL, pBody);
                        }
                        pBody->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        IPersistFile *pipf = NULL;
                        // Initialzie PropVariant
                        PROPVARIANT rVariant;
                        rVariant.vt = VT_LPWSTR;
                        rVariant.pwszVal = (LPWSTR)bstrDocURL;
                        // Add a content location, so we can use it for security later.
                        hr = m_pimm->SetBodyProp( hBody, STR_HDR_CNTLOC, 0, &rVariant );
                        if (SUCCEEDED(hr))
                        {
                            hr = m_pimm->QueryInterface(IID_IPersistFile, (LPVOID *)&pipf);
                            if (SUCCEEDED(hr))
                            {
                                LPWSTR lpwszFile;
                                lpwszFile = m_lpstrDoc;
                                hr = pipf->Save(lpwszFile, FALSE);

                                SAFERELEASE(pipf);
                            }
                        }

                        ReleaseInterface(pstm);
                    }
                }

                if ( bstrDocURL )
                {
                    // Restore Bookmark
                    RestoreBookMark(pwzBookMark);
                    SysFreeString(bstrDocURL);
                }
            }

            ReleaseInterface(pstm);
        }
    }
   
    ReleaseInterface(ppsi);

Exit:
    
    RRETURN(hr);
}

HRESULT
CMHTMLArchive::ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc )
{
    HRESULT hr;
    BSTR    bstrDocURL = NULL;
    CHAR    szURL[INTERNET_MAX_URL_LENGTH];
    LPSTR   lpszCID = NULL;
    DWORD   dwAttach = URL_ATTACH_SET_CNTTYPE;
    HBODY   hBody;
    IStream *pstm = NULL;
    ULONG cbWrite, cbWritten;

    hr = MimeOleCreateVirtualStream( &pstm );
    if (FAILED(hr))
        return hr;

    cbWrite = lstrlenA(lpszSSText);
    pstm->Write(lpszSSText, cbWrite, &cbWritten);
    ASSERT(cbWritten==cbWrite);

    //if (dwFlags & MECD_CNTLOCATIONS)
    //    dwAttach |= URL_ATTACH_SET_CNTLOCATION;

    szURL[0] = 0;

    if (WideCharToMultiByte(CP_ACP, 0, bstrCSSUrl, -1, szURL, INTERNET_MAX_URL_LENGTH, NULL, NULL))
    {

        hr = m_pimm->AttachURL(NULL, szURL, dwAttach,
                                 pstm, &lpszCID, &hBody);

        if (SUCCEEDED(hr))
        {
            CHashEntry *phe;

            // update the place-holder hash entry
            hr = Find(bstrCSSUrl, &phe);

            ASSERT(SUCCEEDED(hr) && phe != NULL);

            phe->SetValue( bstrCSSUrl );
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    ReleaseInterface(pstm);

    return hr;
}

HRESULT CMHTMLArchive::SetCharset(UINT uiCharset, CSETAPPLYTYPE csat,
                                  IMimeBody *pBody)
{
    HRESULT                        hr = E_FAIL;
    HCHARSET                       hCharset;
    IMimeInternational            *pimi = NULL;
    
    hr = CoCreateInstance(CLSID_IMimeInternational,
                          NULL, CLSCTX_INPROC_SERVER,
                          IID_IMimeInternational, (LPVOID*)&pimi);
    if (SUCCEEDED(hr))
    {
        hr = pimi->GetCodePageCharset(uiCharset, CHARSET_WEB, &hCharset);
    }

    if (SUCCEEDED(hr))
    {
        hr = pBody->SetCharset(hCharset, csat);
    }
                            
    if (pimi)
    {
        pimi->Release();
    }

    return hr;
}

/*
*  CThicketProgress ##################################################
*/

CThicketProgress::CThicketProgress( HWND hDlg )
{
    TCHAR szFmt[MAX_PATH];
    int   cchPctFmt;

    m_hDlg = hDlg;
    m_hwndProg = GetDlgItem(hDlg, IDC_THICKETPROGRESS);

    MLLoadString(IDS_THICKETSAVINGFMT, szFmt, ARRAYSIZE(szFmt) );
    m_cchSavingFmt = lstrlen(szFmt);
    m_pszSavingFmt = new TCHAR[m_cchSavingFmt+1];
    if (m_pszSavingFmt != NULL)
    {
        StringCchCopy( m_pszSavingFmt, m_cchSavingFmt+1, szFmt);
    }

    MLLoadString(IDS_THICKETPCTFMT, szFmt, ARRAYSIZE(szFmt));
    cchPctFmt = lstrlen(szFmt);
    m_pszPctFmt = new TCHAR[cchPctFmt+1];
    if (m_pszPctFmt != NULL)
    {
        StringCchCopy(m_pszPctFmt, cchPctFmt+1, szFmt);
    }

    m_ulPct = 0;
}

CThicketProgress::~CThicketProgress(void)
{
    if (m_pszSavingFmt)
        delete[] m_pszSavingFmt;

    if (m_pszPctFmt)
        delete[] m_pszPctFmt;

}

void CThicketProgress::SetPercent( ULONG ulPct )
{
    TCHAR szBuf[MAX_PATH];

    szBuf[0] = TEXT('\0');

    if ( ulPct > 100 )
        ulPct = 100;

    if ( ulPct > m_ulPct ) // prevent retrograde motion.
    {
        m_ulPct = ulPct;
        if (m_pszPctFmt != NULL)
        {
            StringCchPrintf( szBuf, ARRAYSIZE(szBuf), m_pszPctFmt, m_ulPct );
        }
        SetDlgItemText(m_hDlg, IDC_THICKETPCT, szBuf);
        SendMessage(m_hwndProg, PBM_SETPOS, m_ulPct, 0);
    }
}

void CThicketProgress::SetSaving( LPCTSTR szFile, LPCTSTR szDst )
{
    TCHAR szPath[30];
    TCHAR szBuf[MAX_PATH*2];
    LPCTSTR psz;

    szBuf[0] = TEXT('\0');

    if (PathCompactPathEx( szPath, szDst, 30, 0 ))
    {
        psz = szPath;
    }
    else
    {
        psz = szDst;
    }

    if (m_pszSavingFmt != NULL)
    {
        StringCchPrintf( szBuf, ARRAYSIZE(szBuf), m_pszSavingFmt, szFile, psz );
    }

    SetDlgItemText(m_hDlg, IDC_THICKETSAVING, szBuf);
}

void CThicketProgress::SetSaveText(LPCTSTR szText)
{
    if (szText)
    {
        SetDlgItemText(m_hDlg, IDC_THICKETSAVING, szText);
    }
}

/*
*  CCollectionPackager ##################################################
*/

CCollectionPackager::~CCollectionPackager(void)
{
    if (m_pColl)
        m_pColl->Release();
}


HRESULT CCollectionPackager::_GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL)
{
    HRESULT         hr;
    VARIANT         rVar;
    
    ASSERT (pElem);
    
    rVar.vt = VT_BSTR;
    
    // Note that _GetTargetAttribute is a virtual method, so the derived class
    // specifies what attribute to fetch.
    
    hr = THR(pElem->getAttribute(_GetTargetAttribute(), VARIANT_FALSE, &rVar));
    if (SUCCEEDED(hr))
    {
        if (rVar.vt == VT_BSTR && rVar.bstrVal != NULL)
            *pbstrURL = rVar.bstrVal;
        else
            hr = S_FALSE;
    }
    
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CCollectionPackager::_PackageData(CWebArchive *pwa,
                                          IHTMLElementCollection *pColl,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT        hr = S_OK;
    ULONG          uElem,
                   cElems,
                   uRange = progHigh - progLow;
    IHTMLElement   *pElem;
    
    cElems = UlGetCollectionCount(pColl);
    
    // Iterate over the collection, packaging each element in turn.
    
    for (uElem=0; uElem<cElems && SUCCEEDED(hr) ; uElem++)
    {
        hr = THR(HrGetCollectionItem(pColl, uElem, IID_IHTMLElement, (LPVOID *)&pElem));
        if (SUCCEEDED(hr))
        {
            hr = _PackageElement(pwa, pElem ); // no THR - may return S_FALSE
            pElem->Release();
        }

        if (pfCancel && *pfCancel)
            hr = E_ABORT;

        if (ptp && uRange)
            ptp->SetPercent( progLow + (uRange * uElem) / cElems );
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT CCollectionPackager::_PackageElement(CWebArchive *pwa,
                                             IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BOOL           fBadLinks=FALSE;
    CHashEntry     *phe;
    
    hr = _GetElementURL(pElem, &bstrURL);
    if (hr == S_OK && bstrURL && bstrURL[0])
    {
        // PTH hr = HrAddImageToMessage(pMsgSrc, pMsgDst, pHash, bstrURL, &bstrURLThicket, m_fAddCntLoc);
        hr = pwa->AddURL( bstrURL, &phe );

        if (SUCCEEDED(hr))
        {
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
        }
        else
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), c_bstr_EMPTY));
    }

    if (bstrURL)
        SysFreeString(bstrURL);


    return hr; 
}


HRESULT CCollectionPackager::_InitSubCollection(IHTMLElementCollection *pAll,
                                                BSTR bstrTagName,
                                                IHTMLElementCollection **ppSub,
                                                ULONG *pcElems)
{
    IDispatch              *pDisp=NULL;
    VARIANT                 TagName;
    HRESULT                 hr = S_FALSE;

    ASSERT (ppSub);
    ASSERT(pAll);

    *ppSub = NULL;
    
    TagName.vt = VT_BSTR;
    TagName.bstrVal = bstrTagName;
    if (NULL == TagName.bstrVal)
        hr = E_INVALIDARG;
    else
    {
        hr = pAll->tags(TagName, &pDisp);
    }
    
    if (pDisp)
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,
            (void **)ppSub);
        pDisp->Release();
    }
    
    if (pcElems)
    {
        if (hr == S_OK)
            *pcElems = UlGetCollectionCount(*ppSub);
        else
            *pcElems = 0;
    }
    
    RRETURN(hr);
}

/*
*  CImagePackager ##################################################
*/


HRESULT CImagePackager::InitFromCollection(IHTMLElementCollection *pColl,
                                           ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_IMG, &m_pColl, pcElems);
}

BSTR CImagePackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CInputImgPackager ##################################################
*/

HRESULT CInputImgPackager::InitFromCollection(IHTMLElementCollection *pColl,
                                              ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_INPUT, &m_pColl, pcElems);
}

/*
*  CBGSoundsPackager ##################################################
*/

HRESULT CBGSoundsPackager::InitFromCollection(IHTMLElementCollection *pColl,
                                              ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_BGSOUND, &m_pColl, pcElems);
}

BSTR CBGSoundsPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CAnchorAdjustor ##################################################
*/


HRESULT CAnchorAdjustor::InitFromCollection(IHTMLElementCollection *pColl,
                                            ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_ANCHOR, &m_pColl, pcElems);
}

BSTR CAnchorAdjustor::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_HREF;
}

HRESULT CAnchorAdjustor::_PackageElement(CWebArchive *pwa,
                                         IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BSTR           bstrThicket = NULL;
    BOOL           fBadLinks=FALSE;
    CHashEntry     *phe;
    
    // leave intra-doc urls and <A name=> alone
    // seanf(2/11/98) : haven't seen a local # link come through here yet. 
    hr = _GetElementURL(pElem, &bstrURL);
    if (hr != S_OK || bstrURL == NULL || bstrURL[0] == '#' || bstrURL[0] == 0)
        goto error;
    
    // See if the target is something we have in the thicket, like an <A> in frame A
    // targetting the page saved for frame B.
    ASSERT(pwa);

    hr = pwa->Find(bstrURL, &phe);
    if (SUCCEEDED(hr))
        bstrThicket = phe->m_bstrValue;
    else
    {
        // not in the thicket, so make both URLs the same.
        bstrThicket = bstrURL;
        hr = S_OK;
    }

    if (hr == S_OK)
        hr = THR(HrSetMember(pElem, _GetTargetAttribute(), bstrThicket));
    
error:
    
    if (bstrURL)
        SysFreeString(bstrURL);

    // don't free bstrThicket, its either bstrURL, or belongs to the thicket hash table.
    
    return hr; 
}

/*
*  CAreaAdjustor ##################################################
*/


HRESULT CAreaAdjustor::InitFromCollection(IHTMLElementCollection *pColl,
                                            ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_AREA, &m_pColl, pcElems);
}

/*
*  CBaseNeutralizer ##################################################
*/

CBaseNeutralizer::~CBaseNeutralizer(void)
{
    if (m_bstrLocal)
        SysFreeString(m_bstrLocal);
 
    if (m_pTree)
        m_pTree->Release();
}

HRESULT CBaseNeutralizer::InitFromCollection(IHTMLElementCollection *pColl,
                                             ULONG *pcElems,
                                             IHTMLDocument2 *pDoc )
{
    if ( pDoc != NULL )
    {
        if ( m_pTree )
        {
            m_pTree->Release();
            m_pTree = NULL;
        }
        pDoc->QueryInterface(IID_IMarkupServices, (void**)&m_pTree);
    }

    return _InitSubCollection(pColl, (BSTR)c_bstr_BASE, &m_pColl, pcElems);
}


BSTR CBaseNeutralizer::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_HREF;
}

HRESULT CBaseNeutralizer::PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                      CThicketProgress *ptp,
                                      ULONG progLow, ULONG progHigh)
{
    HRESULT        hr = S_OK;
    ULONG          uElem,
                   cElems,
                   uRange = progHigh - progLow;
    IHTMLElement   *pElem;
    
    cElems = UlGetCollectionCount(m_pColl);
    
    // Iterate over the collection, packaging each element in turn.
    
    for (uElem=0; uElem<cElems && SUCCEEDED(hr) ; uElem++)
    {
        hr = THR(HrGetCollectionItem(m_pColl, 0, IID_IHTMLElement, (LPVOID *)&pElem));
        if (SUCCEEDED(hr))
        {
            hr = _PackageElement(pwa, pElem ); // no THR - may return S_FALSE
            pElem->Release();
        }

        if (pfCancel && *pfCancel)
            hr = E_ABORT;

        if (ptp && uRange)
            ptp->SetPercent( progLow + (uRange * uElem) / cElems );
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT CBaseNeutralizer::_PackageElement(CWebArchive *pwa,
                                          IHTMLElement *pElem)
{
    HRESULT        hr = S_FALSE;

    // NOTE: There's seems to be no retouching that will make this work.
    //         Tried setting BASE to ".", ".\", "". It has to be absolute,
    //         which would anchor the thicket to one location in the file
    //         system. The solution here is to use the base to fix the
    //         other rel URLs in the doc, then whack the base tags.
    if ( m_pTree )
    {
        //OLD NOTE: Tree Services can't remove a head element yet, so 
        //        wait to enable this pending Joe Beda/EricVas work.
        hr = m_pTree->RemoveElement( pElem );
    }

    return hr; // no RRETURN - may return S_FALSE
}

/*
*  CRelativeURLPackager ##################################################
*/


CRelativeURLPackager::~CRelativeURLPackager(void)
{
    if (m_pCollBase)
        m_pCollBase->Release();
    
    if (m_bstrDocURL)
        SysFreeString(m_bstrDocURL);
}


HRESULT CRelativeURLPackager::Init(IHTMLElementCollection *pColl,
                                   ULONG *pcElems,
                                   IHTMLDocument2 *pDoc)
{
    HRESULT hr = S_OK;
    
    // Hold on to the outer collection, we'll subsample it later.
    m_pColl = pColl;
    
    if (m_pColl)
    {
        m_pColl->AddRef();
        hr = _InitSubCollection( m_pColl, (BSTR)c_bstr_BASE, &m_pCollBase, &m_cBase );
    }
    
    if (SUCCEEDED(hr) && pDoc)
    {
        hr = pDoc->get_URL( &m_bstrDocURL );
    }
    
    RRETURN(hr);
}

HRESULT CRelativeURLPackager::_GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL)
{
    HRESULT             hr = S_FALSE;
    LONG                lElemPos;
    BSTR                bstr = NULL;
    
    
    ASSERT (pbstrURL);
    *pbstrURL = 0;
    
    hr = CCollectionPackager::_GetElementURL(pElem, &bstr);
    if (hr==S_OK)
    {
        if (bstr==NULL)
            hr = S_FALSE;
        else
        {
            hr = pElem->get_sourceIndex(&lElemPos);
            ASSERT(SUCCEEDED(hr));
            hr = HrGetCombinedURL(m_pCollBase, m_cBase, lElemPos, bstr, m_bstrDocURL, pbstrURL);
            SysFreeString(bstr);
        }
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

/*
*  CBackgroundPackager ##################################################
*/


HRESULT CBackgroundPackager::PackageData(CWebArchive *pwa,
                                         BOOL *pfCancel,
                                         CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    IHTMLElementCollection *pColl = NULL;
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_BODY, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TABLE, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel);
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TD, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TH, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
error:
    
    if (pColl)
        pColl->Release();
    
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CBackgroundPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_BACKGROUND;
}


/*
*  CDynSrcPackager ##################################################
*/


HRESULT CDynSrcPackager::PackageData(CWebArchive *pwa,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    IHTMLElementCollection *pColl = NULL;
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_IMG, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_INPUT, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    
error:
    
    if (pColl)
        pColl->Release();
    
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CDynSrcPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_DYNSRC;
}


/*
*  CScriptPackager ##################################################
*/


HRESULT CScriptPackager::Init(IHTMLElementCollection *pColl,
                              ULONG *pcElems,
                              IHTMLDocument2 *pDoc)
{
    HRESULT hr = CRelativeURLPackager::Init(pColl, NULL, pDoc);

    if (SUCCEEDED(hr))
        hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_SCRIPT, &m_pCollScripts, pcElems );

    return hr;
}


BSTR CScriptPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CFramesPackager ##################################################
*/

HRESULT CFramesPackager::Init(IHTMLElementCollection *pColl,
                              ULONG *pcElems,
                              IHTMLDocument2 *pDoc,
                              IHTMLDocument2 *pDocDesign,
                              CDocumentPackager *pdp)
{
    HRESULT hr = CRelativeURLPackager::Init(pColl, NULL, pDocDesign);

    if (SUCCEEDED(hr))
    {
        m_pdp = pdp;
        // Get the element collection for the frames.
        // Note: If documents have frames, they are either all
        // <FRAME>s _OR_ all <IFRAME>s.
        hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_FRAME, &m_pCollFrames, &m_cFrames);
        if (FAILED(hr) || m_cFrames == 0)
        {
            if (m_pCollFrames)
                m_pCollFrames->Release();
            hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_IFRAME, &m_pCollFrames, &m_cFrames);
        }

        if (pcElems)
            *pcElems = m_cFrames;

        // To traverse a framseset that spans multiple domains, we need to approach it
        // via the "unsecured" window object, which is only accessible via Invoke.
        if (SUCCEEDED(hr) && m_cFrames > 0)
        {
            DISPPARAMS dispparams;
            VARIANT VarResult;
            VariantInit(&VarResult);
            ZeroMemory(&dispparams, sizeof(dispparams));

            hr = pDoc->Invoke(DISPID_WINDOWOBJECT,
                              IID_NULL,
                              0,
                              DISPATCH_PROPERTYGET,
                              &dispparams,
                              &VarResult,
                              NULL,
                              NULL );

            if( SUCCEEDED(hr) )
            {
                // Code in iedisp.cpp's  GetDelegateOnIDispatch was really paranoid about this,
                // so we'll be similarly cautious.
                if( (VarResult.vt == VT_DISPATCH || VarResult.vt == VT_UNKNOWN)
                    && VarResult.pdispVal )
                {
                    IHTMLWindow2 *pwin2 = NULL;

                    hr = VarResult.pdispVal->QueryInterface( IID_IHTMLWindow2, (LPVOID*)&pwin2);
                    if (SUCCEEDED(hr))
                    {
                        hr = pwin2->get_frames(&m_pframes2);
                        pwin2->Release();
                    }
                } // if we really got an interface
                else
                    hr = E_FAIL;

                VariantClearLazy( &VarResult );
            } // if we can get the un-secured window object
        } // if we have frames
    } // if base initialization succeeded

    return hr;
}


HRESULT CFramesPackager::PackageData(CWebArchive *pwa,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    //ULONG   cColl = 0;
    
    if (m_cFrames == 0)
        return S_OK; // Trident will get confused if we return a non-S_OK success code
    
    m_iFrameCur = 0; // index of frame in window.frames and all.tags("FRAME");
    m_pfCancel = pfCancel;
    m_ptp = ptp;
    m_uLow = progLow;
    m_uHigh = progHigh; 
    
    m_uRangeDoc = (progHigh - progLow) / m_cFrames;
    hr = _PackageData( pwa, m_pCollFrames, pfCancel );
        
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CFramesPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

HRESULT CFramesPackager::_PackageElement(CWebArchive *pwa,
                                         IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BOOL           fBadLinks=FALSE;
    IHTMLDocument2 *pDocFrame = NULL;
    //IWebBrowser    *pwb = NULL;
    IDispatch      *pDisp = NULL;
    IHTMLWindow2   *pwin2 = NULL;
    VARIANT        varIndex;
    VARIANT        varFrame;
    WCHAR         *pwzBookMark = NULL;
    
    ASSERT(pElem);
    ASSERT(pwa);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_iFrameCur;
    hr = m_pframes2->item( &varIndex, &varFrame );
    if (FAILED(hr))
        goto error;
    // The variant should give us an IHTMLWindow2, but we'll treat it as a Disp anyway
    ASSERT(varFrame.vt & VT_DISPATCH);
    pDisp = varFrame.pdispVal;
    hr = pDisp->QueryInterface(IID_IHTMLWindow2, (LPVOID*)&pwin2 );
    if (FAILED(hr))
        goto error;

    hr = pwin2->get_document(&pDocFrame);

#ifdef OLD_THICKET

    hr = pElem->QueryInterface(IID_IWebBrowser, (void**)&pwb);
    if (FAILED(hr))
        goto error;
    
    hr = pwb->get_Document( &pDisp );
    if (FAILED(hr))
        goto error;
    else if ( pDisp == NULL )
    {
        hr = S_FALSE;
        goto error;
    }
    
    hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDocFrame);
    if (FAILED(hr))
        goto error;

#endif // OLD_THICKET

    if (SUCCEEDED(hr) && SUCCEEDED(pDocFrame->get_URL(&bstrURL)) && bstrURL && bstrURL[0])
    {
        TCHAR       szFrameDoc[MAX_PATH];
        CHashEntry  *phe;
        
        RemoveBookMark(bstrURL, &pwzBookMark);

        hr = pwa->AddFrameOrStyleEntry( bstrURL, &phe, szFrameDoc );
        if (hr==S_OK)
        {
            ULONG uLowDoc = m_uLow + m_iFrameCur * m_uRangeDoc;
            ULONG uHighDoc = uLowDoc + m_uRangeDoc;
            CWebArchive *pwaFrame = m_pdp->GetFrameDocArchive( pwa );
            
            if ( pwaFrame != NULL )
            {
                BSTR               bstrCharSetSrc = NULL;
                MIMECSETINFO       csetInfo;
                IMultiLanguage2   *pMultiLanguage = NULL;

                hr = pDocFrame->get_charset(&bstrCharSetSrc);
                if (FAILED(hr))
                    goto error;
            
                hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IMultiLanguage2, (void**)&pMultiLanguage);
                if (FAILED(hr))
                {
                    goto error;
                }
            
                hr = pMultiLanguage->GetCharsetInfo(bstrCharSetSrc, &csetInfo);
                pMultiLanguage->Release();

                if (FAILED(hr))
                {
                    goto error;
                }

                hr = m_pdp->_PackageDocument(pDocFrame, szFrameDoc, m_pfCancel, m_ptp, 
                                             uLowDoc, uHighDoc, csetInfo.uiInternetEncoding,
                                             pwaFrame, m_pdp, TRUE );
                if (SUCCEEDED(hr))
                    hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
                else
                    fBadLinks = TRUE;

                if ( pwaFrame != pwa ) // only delete if new one was made (thicket)
                    delete pwaFrame;
            }
            else
                hr = E_OUTOFMEMORY;
        } // if the location matched the element URL
        else if (hr==S_FALSE)
        {
            // This is a repeat - we don't need to do most of the work, but we
            // do need to record the element for remapping.
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
        }
    } // if we got the frame's doc's URL
    else // if ( hr == DISP_E_MEMBERNOTFOUND ) // frame is non-trident docobj
    {
        IHTMLLocation *ploc = NULL;

        // For a non-trident doc-obj, get the file, if possible, and put it in the thicket.

        hr = pwin2->get_location( &ploc );
        if (SUCCEEDED(hr) &&
            SUCCEEDED(hr = ploc->get_href( &bstrURL )))
        {
            if (bstrURL && bstrURL[0])
            {
                CHashEntry  *phe;
                // PTH hr = HrAddImageToMessage(pMsgSrc, pMsgDst, pHash, bstrURL, &bstrURLThicket, m_fAddCntLoc);
                hr = pwa->AddURL( bstrURL, &phe );
                if (!FAILED(hr))
                {
                    hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
                }
            }
            else
                hr = S_FALSE;
        }
        ReleaseInterface(ploc);
    }
    
error:
    //ReleaseInterface(pwb);
    ReleaseInterface(pwin2);
    ReleaseInterface(pDisp);
    ReleaseInterface(pDocFrame);

    if (bstrURL) {
        RestoreBookMark(pwzBookMark);
        SysFreeString(bstrURL); // bstrFrameURL);
    }
    
    m_iFrameCur++;

    return hr;
}

/*
*  CDocumentPackager ##################################################
*/

HRESULT CDocumentPackager::PackageDocument(IHTMLDocument2 *pDoc,
                                           LPCTSTR lpstrDoc,
                                           BOOL *pfCancel, CThicketProgress *ptp,
                                           ULONG progLow, ULONG progHigh,
                                           UINT cpDst,
                                           CWebArchive *pwa)
{
    HRESULT hr = S_OK;

    m_ptp = ptp;

    switch (m_iPackageStyle)
    {
    case PACKAGE_THICKET:
        {
            CThicketArchive thicket(ptp);

            hr = _PackageDocument( pDoc, lpstrDoc, pfCancel, ptp, progLow, progHigh, cpDst, &thicket, this, FALSE );
        }
        break;

    case PACKAGE_MHTML:
        {
            CMHTMLArchive *pmhtmla = (CMHTMLArchive *)pwa; // sleazy downcast
    
            if (pwa == NULL)
                pmhtmla = new CMHTMLArchive(ptp);

            if (pmhtmla != NULL)
            {
                hr = _PackageDocument( pDoc, lpstrDoc, pfCancel, ptp, progLow, progHigh, cpDst,
                                       pmhtmla, this, FALSE );

                // if pwa is NULL, then we created a CMHTMLArchive for
                // use in _PackageDocument which we now need to clean up
                if (pwa == NULL)
                    delete pmhtmla;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;

    case PACKAGE_HTML:
        // fall through - Trident will do the right thing by sniffing the 
        // extension.
    case PACKAGE_TEXT:
        {
            if (SUCCEEDED(hr))
            {
                IHTMLDocument2 *pDocDesign = NULL;
                IHTMLDocument2 *pDocSave = NULL;
                IPersistFile *ppf = NULL;

                if (cpDst == CP_ACP)
                {
                    // No encoding change, use the browse doc
                    pDocSave = pDoc;
                }
                else
                {
                    hr = _GetDesignDoc( pDoc, &pDocDesign, pfCancel, ptp, cpDst);

                    if (SUCCEEDED(hr))
                    {
                        pDocSave = pDocDesign;
                    }
                    else
                    {
                        return E_FAIL;
                    }
                }
                
                // Trident IPersistFile::Save looks at the extension to determine if it's
                // an HTML or text save.

                hr = pDocSave->QueryInterface(IID_IPersistFile, (void**)&ppf);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR lpwszFile;
                    lpwszFile = lpstrDoc;
                    BSTR bstrURL = NULL;
                    WCHAR wzSavingText[MAX_SAVING_STATUS_TEXT + 1];
                    WCHAR wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];

                    hr = pDocSave->get_URL(&bstrURL);

                    if (SUCCEEDED(hr))
                    {

                        MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzSavingText,
                                      ARRAYSIZE(wzSavingText));
                
                        StringCchPrintf(wzBuf, ARRAYSIZE(wzBuf),
                                   L"%ws: %ws", wzSavingText, bstrURL);
                        ptp->SetSaveText(wzBuf);
                    
                        if (bstrURL)
                        {
                            SysFreeString(bstrURL);
                        }
                    }

                    hr = ppf->Save( lpwszFile, FALSE );
                    ppf->SaveCompleted(lpwszFile);

                    ppf->Release();
                }

                if (cpDst != CP_ACP)
                {
                    pDocSave->Release();
                }

                // If we used the browse-time pDoc, we don't need to release
                // it because it is released by CThicketUI::ThicketUIThreadProc
            }
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return hr;
}

HRESULT CDocumentPackager::_PackageDocument(IHTMLDocument2 *pDoc,
                                            LPCTSTR lpstrDoc,
                                            BOOL *pfCancel, CThicketProgress *ptp,
                                            ULONG progLow, ULONG progHigh,
                                            UINT cpDst,
                                            CWebArchive *pwa,
                                            CDocumentPackager *pdpFrames,
                                            BOOL fFrameDoc)
{
    HRESULT                 hr = S_OK;
    ULONG                   cImages;
    ULONG                   cInputImgs;
    ULONG                   cBGSounds;
    ULONG                   cFrames;
    ULONG                   uRange = progHigh - progLow;
    ULONG                   uRangeThis;
    ULONG                   uLow, uHigh;
    IHTMLElementCollection  *pCollect = NULL;
    CImagePackager          imgPkgr;
    CInputImgPackager       inputimgPkgr;
    CBGSoundsPackager       bgsPkgr;
    CBackgroundPackager     bkgndPkgr;
    CBaseNeutralizer        baseNeut;
    CAnchorAdjustor         anchorAdj;
    CAreaAdjustor           areaAdj;
    CFramesPackager         framesPkgr;
    CSSPackager             stylesheetPkgr;
    CDynSrcPackager         dynsrcPkgr;
    CScriptPackager         scriptPkgr;
    IHTMLDocument2          *pDocDesign = NULL;
    BYTE                     abBuffer[MAX_BUFFER_LEN];
    DWORD                    dwType = 0;
    DWORD                    dwSize = 0;
    BOOL                     bDLImages = TRUE;
    HKEY                     hkey = 0;
    IOleCommandTarget       *pIOCT = NULL;

    if (pDoc==NULL)
        return E_INVALIDARG;

    hr = _GetDesignDoc( pDoc, &pDocDesign, pfCancel, ptp, cpDst );
    if (FAILED(hr))
        goto error;

    // HACK! If you have a unicode character in the filename, when we
    // call put_href on the CSS, trident tries to download this. The
    // invalid character is sent to the server, who sends badddddd
    // stuff, which the CSS parser doesn't understand. The result is
    // that trident falls on the floor. This tells trident not to download
    // the CSS hence avoiding the problem.

    hr = pDocDesign->QueryInterface(IID_IOleCommandTarget, (void **)&pIOCT);

    if (SUCCEEDED(hr) && pIOCT)
    {
        pIOCT->Exec(NULL, OLECMDID_DONTDOWNLOADCSS, OLECMDID_DONTDOWNLOADCSS,
                    NULL, NULL);
        pIOCT->Release();
    }

    hr = pDocDesign->get_all(&pCollect);
    if (FAILED(hr))
        RRETURN(hr);
    
    dwSize = MAX_BUFFER_LEN;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_MSIE_MAIN, 0, KEY_READ ,&hkey) == ERROR_SUCCESS)
    {
        if (SHQueryValueExA(hkey, REGVALUE_DOWNLOAD_IMAGES, 0, &dwType,
                            abBuffer, &dwSize) == NO_ERROR)
        {
            bDLImages = !StrCmpIA((char *)abBuffer, "yes");
        }

        RegCloseKey(hkey);
    }

    if (bDLImages)
    {
        // pack all the images into the message and remember the Thicket mappings
        hr = imgPkgr.InitFromCollection(pCollect, &cImages);
        if (FAILED(hr))
            goto error;

        hr = inputimgPkgr.InitFromCollection(pCollect, &cInputImgs);
        if (FAILED(hr))
            goto error;

    }

    hr = bgsPkgr.InitFromCollection(pCollect, &cBGSounds);
    if (FAILED(hr))
        goto error;
   
    hr = bkgndPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = dynsrcPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = stylesheetPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = framesPkgr.Init(pCollect, &cFrames, pDoc, pDocDesign, this);
    if (FAILED(hr))
        goto error;

    hr = scriptPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = pwa->Init(lpstrDoc, cImages + cInputImgs + cFrames);
    if (FAILED(hr))
        goto error;

    // herewith commences the hackery to drive the progess bar.
    // If we have frames we devide the progress range among all the docs involved.
    // We'll neglect style sheets and devote the range for the immediate
    // document to the image collection.
    uRangeThis = uRange / (cFrames + 1);

    uLow = progLow;
    uHigh = progLow + uRangeThis;
    
    if (bDLImages)
    {
        hr = imgPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
        if (FAILED(hr))
            goto error;

        hr = inputimgPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
        if (FAILED(hr))
            goto error;
    }

    hr = bgsPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
    if (FAILED(hr))
        goto error;
     
    hr = bkgndPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;

    hr = dynsrcPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
    
    hr = stylesheetPkgr.PackageStyleSheets(pDocDesign, pwa);
    if (FAILED(hr))
        goto error;
 
    uLow = progHigh - uRangeThis;
    uHigh = progHigh;

    hr = framesPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
    if (FAILED(hr))
        goto error;

    hr = scriptPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
                
    // we want to do this after frames s.t. the frame docs will be in the thicket
    // and we can correctly direct a targetted hyperlink from frame A to frame B
    // if the href is in the thicket vs. still out on the Web.
    hr = anchorAdj.InitFromCollection(pCollect);
    if (FAILED(hr))
        goto error;
    
    hr = anchorAdj.PackageData(pwa, pfCancel); // not that we need the thicket...
    if (FAILED(hr))
        goto error;  
    
    hr = areaAdj.InitFromCollection(pCollect);
    if (FAILED(hr))
        goto error;
    
    hr = areaAdj.PackageData(pwa, pfCancel); // not that we need the thicket...
    if (FAILED(hr))
        goto error;   

 
    // Now that we've got everybody remapped, short-circuit the base tags
    // and redirect to the current directory.
    hr = baseNeut.InitFromCollection(pCollect, NULL, pDocDesign );
    if (FAILED(hr))
        goto error;
    
    hr = baseNeut.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
        
    //if(dwFlags & MECD_HTML || dwFlags & MECD_PLAINTEXT)
    {
        hr = pwa->ArchiveDocumentText( pDocDesign, cpDst, fFrameDoc );
        if (FAILED(hr))
            goto error;
    }

    
error:
    
    if (pCollect)
        pCollect->Release();

    if (pDocDesign)
        pDocDesign->Release();

    if (pfCancel && *pfCancel)
        hr = E_ABORT;

    if (SUCCEEDED(hr))
        pwa->Commit();
    else
        pwa->Revert();
    
    return hr;
}

CWebArchive *CDocumentPackager::GetFrameDocArchive(CWebArchive *pwaSrc)
{
    CWebArchive *pwa = NULL;

    if (m_iPackageStyle == PACKAGE_THICKET)
        pwa = new CThicketArchive(m_ptp);
    else if (m_iPackageStyle == PACKAGE_MHTML)
        pwa = pwaSrc;
    else
        ASSERT(FALSE);

    return pwa;
}

HRESULT CDocumentPackager::_GetDesignDoc( IHTMLDocument2 *pDocSrc, IHTMLDocument2 **ppDocDesign,
                                          BOOL *pfCancel, CThicketProgress *ptp, UINT cpDst )
{
    HRESULT            hr;
    DWORD              dwFlags;
    BSTR               bstrURL = NULL;
    BSTR               bstrCharSetSrc = NULL;
    MIMECSETINFO       csetInfo;
    IMultiLanguage2   *pMultiLanguage = NULL;
    CUrlDownload      *pud = NULL;
    ULONG              cRef = 0;
    DWORD              dwUrlEncodingDisableUTF8;
    DWORD              dwSize = SIZEOF(dwUrlEncodingDisableUTF8);
    BOOL               fDefault = FALSE;

    hr = pDocSrc->get_charset(&bstrCharSetSrc);
    if (FAILED(hr))
        goto Cleanup;

    hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMultiLanguage2, (void**)&pMultiLanguage);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pMultiLanguage->GetCharsetInfo(bstrCharSetSrc, &csetInfo);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    
    if (FAILED(pDocSrc->get_URL( &bstrURL )))
        goto Cleanup;

    pud = new CUrlDownload( ptp, &hr, csetInfo.uiInternetEncoding );

    if (pud == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppDocDesign = NULL;

    // seanf(2/6/98): Review DLCTL_ flags.
    dwFlags = DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD |
              DLCTL_SILENT | DLCTL_OFFLINE;

    SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS,
        TEXT("UrlEncoding"), NULL, (LPBYTE) &dwUrlEncodingDisableUTF8, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));

    if (dwUrlEncodingDisableUTF8)
    {
        dwFlags |= DLCTL_URL_ENCODING_DISABLE_UTF8;
    }
    else
    {
        dwFlags |= DLCTL_URL_ENCODING_ENABLE_UTF8;
    }

    hr = pud->SetDLCTL(dwFlags);
    if (SUCCEEDED(hr))
        hr = pud->BeginDownloadURL2( bstrURL, BDU2_BROWSER, BDU2_NONE, NULL, 0xF0000000 );

    if (SUCCEEDED(hr))
    {
        MSG msg;

        hr = S_FALSE;

        while (hr==S_FALSE)
        {
            GetMessage(&msg, NULL, 0, 0);
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            if (*pfCancel)
            {
                pud->AbortDownload();
                hr = E_ABORT;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pud->GetDocument( ppDocDesign );

            // Set the document to the codepage the user has selected.
            // Don't bother if it's no specific page has been directed, as is the case
            // with frame documents and in cases where the user kept the default
            // code page selected in the Save As... dialog.
            if (SUCCEEDED(hr) && cpDst != CP_ACP)
            {
                MIMECPINFO  cpInfo;
                BSTR        bstrCharSet = NULL;
                LANGID      langid;

                langid = MLGetUILanguage();

                if ( SUCCEEDED(pMultiLanguage->GetCodePageInfo(cpDst, langid, &cpInfo)) &&
                     (bstrCharSet = SysAllocString(cpInfo.wszWebCharset)) != NULL )
                    hr = (*ppDocDesign)->put_charset(bstrCharSet);

                ASSERT(SUCCEEDED(hr));

                if (bstrCharSet)
                    SysFreeString(bstrCharSet);
            }
        }
    }

    pud->DoneDownloading();

    cRef = pud->Release();

    if (SUCCEEDED(hr))
    {
        IOleCommandTarget *pioct;

        hr = pDocSrc->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pioct);
        if (SUCCEEDED(hr))
        {
            VARIANTARG v;

            v.vt = VT_UNKNOWN;
            v.punkVal = *ppDocDesign;

            hr = pioct->Exec( &CGID_ShortCut, CMDID_SAVEASTHICKET, OLECMDEXECOPT_DODEFAULT, &v, NULL );

            pioct->Release();
        }
    }

Cleanup:

    SAFERELEASE(pMultiLanguage);

    if (bstrURL)
        SysFreeString(bstrURL);

    if (bstrCharSetSrc)
        SysFreeString(bstrCharSetSrc);

    if (FAILED(hr))
    {
        if (ppDocDesign != NULL)
        {
            ReleaseInterface((*ppDocDesign));
        }
    }

    return hr;
}

/*
*  CSSPackager ##################################################
*/

HRESULT CSSPackager::Init(IHTMLElementCollection *pColl,
                          ULONG *pcElems,
                          IHTMLDocument2 *pDoc)
{
    HRESULT hr = CRelativeURLPackager::Init( pColl, pcElems, pDoc );
            
    m_pDoc = pDoc;

    RRETURN(hr);
}


HRESULT CSSPackager::PackageStyleSheets(IHTMLDocument2 *pDoc2,
                                        CWebArchive *pwa)
{
    HRESULT hr = S_OK;
    IHTMLStyleSheetsCollection *pssc = NULL;
    
    ASSERT(pDoc2);
    ASSERT(pwa);
    
    // process the inline style sheets
    hr = pDoc2->get_styleSheets( &pssc );
    if (SUCCEEDED(hr))
    {
        hr = _PackageSSCollection(pssc, pwa);
        pssc->Release();
    }
    
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CSSPackager::_PackageSSCollection(IHTMLStyleSheetsCollection *pssc,
                                          CWebArchive *pwa)
{
    HRESULT hr;
    LONG cSS;
    
    hr = pssc->get_length( &cSS );
    if (SUCCEEDED(hr))
    {
        LONG iSS;
        
        for (iSS = 0; iSS < cSS && SUCCEEDED(hr); iSS++ )
        {
            VARIANT varIndex;
            VARIANT varSS;
            
            varIndex.vt = VT_I4;
            varIndex.lVal = iSS;
            varSS.vt = VT_EMPTY;
            hr = pssc->item( &varIndex, &varSS );
            if (SUCCEEDED(hr) && varSS.vt == VT_DISPATCH && varSS.pdispVal != NULL)
            {
                IHTMLStyleSheet *pss = NULL;
                if(SUCCEEDED(varSS.pdispVal->QueryInterface(IID_IHTMLStyleSheet, (void**)&pss)))
                {
                    hr = _PackageSS(pss, pwa); 
                    pss->Release();
                }
                varSS.pdispVal->Release();
            }
        }
    }
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CSSPackager::_PackageSS(IHTMLStyleSheet *pss,
                                CWebArchive *pwa)
{
    HRESULT     hr;
    BSTR        bstrRelURL = NULL;
    BSTR        bstrAbsURL = NULL;
    LONG        lElemPos;
    IHTMLElement *pElemOwner = NULL;
    IHTMLStyleSheetsCollection *pssc = NULL;
    BOOL        fStyleTag = FALSE;
    
    if (pss == NULL || pwa == NULL)
        return E_INVALIDARG;
    
    hr = pss->get_href(&bstrRelURL);
    if (FAILED(hr))
        goto error;
    fStyleTag = bstrRelURL == NULL || *bstrRelURL == 0;
    
    hr = pss->get_owningElement(&pElemOwner);
    if (FAILED(hr))
        goto error;
    
    hr = pElemOwner->get_sourceIndex(&lElemPos);
    if (FAILED(hr))
        goto error;
    
    hr = HrGetCombinedURL(m_pCollBase, m_cBase, lElemPos, bstrRelURL, m_bstrDocURL, &bstrAbsURL);
    if (FAILED(hr))
        goto error;
    
    // First we do the defualt processing, gathering the imports into _our_
    
    // process the inline style sheets
    hr = pss->get_imports( &pssc );
    if (SUCCEEDED(hr))
    {
        long cSS;
        
        hr = pssc->get_length( &cSS );
        if (SUCCEEDED(hr) && cSS > 0)
        {
            CSSPackager importPkgr;
            
            hr = importPkgr.Init(m_pCollBase, NULL, m_pDoc);
            
            hr = importPkgr._PackageSSCollection(pssc, pwa);
        }
        pssc->Release();
    }
    
    // oh, yeah, if we want to do background-image and list-style-image, we'd enumerate this ss's rule styles
    // here, find the ones with these attributes, and build a list of IHTML rule style, maybe using some sub-obj
    // like an image packager.
    
    if (SUCCEEDED(hr) && !fStyleTag)
    {
        BSTR    bstrSSText;
        
        // Now we grab our modified text and add it to the document.
        hr = pss->get_cssText(&bstrSSText);
        if (SUCCEEDED(hr) && bstrSSText != NULL)
        {
            LPSTR lpszSSText;
            
            // This text needs to be ANSI before we put it into the stream.
            hr = HrBSTRToLPSZ( bstrSSText, &lpszSSText );
            if (SUCCEEDED(hr))
            {
                // PTH hr = MimeOleCreateVirtualStream(&pstm);
                TCHAR       szStyleDoc[MAX_PATH];
                CHashEntry  *phe;

                hr = pwa->AddFrameOrStyleEntry( bstrAbsURL, &phe, szStyleDoc );
                
                if (hr==S_OK)
                {
                    hr = pwa->ArchiveCSSText( bstrAbsURL, lpszSSText, szStyleDoc );

                    if ( SUCCEEDED(hr) )
                        hr = pss->put_href(phe->m_bstrValue);
                }
                else if (hr==S_FALSE)
                {
                    // repeated style sheet, don't need to do all the work, but do need to note
                    // the ss for remapping
                    hr = pss->put_href( phe->m_bstrValue);
                }
                delete lpszSSText;
            }
            SysFreeString(bstrSSText);
        }
    }
    
error:
    if (pElemOwner)
        pElemOwner->Release();
    if (bstrRelURL)
        SysFreeString(bstrRelURL);
    if (bstrAbsURL)
        SysFreeString(bstrAbsURL);
    
    return hr; // no RRETURN - may return S_FALSE
}

//
// Functions ##############################################################
//

ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect)
{
    ULONG   ulCount=0;
    
    if (pCollect)
        pCollect->get_length((LONG *)&ulCount);
    
    return ulCount;
}


HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj)
{
    HRESULT     hr=E_FAIL;
    IDispatch   *pDisp=0;
    VARIANTARG  va1,
        va2;
    
    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
    va1.lVal = (LONG)uIndex;
    
    pCollect->item(va1, va2, &pDisp);
    if (pDisp)
    {
        hr = pDisp->QueryInterface(riid, ppvObj);
        pDisp->Release();
    }
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue)
{
    IHTMLElement    *pObj;
    HRESULT         hr;
    VARIANT         rVar;
    
    ASSERT(pUnk);

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj);
    if (SUCCEEDED(hr))
    {
        ASSERT (pObj);
        rVar.vt = VT_BSTR;
        rVar.bstrVal = bstrValue;
        hr = pObj->setAttribute(bstrMember, rVar, FALSE);
        pObj->Release();
    }
    return hr; // no RRETURN - may return S_FALSE
}


/*
* HrGetCombinedURL does some of the things that GetBackgroundImageUrl
* does, but in a more general way. It relies on the caller to have
* isolated the <BASE> collection and to supply the root document URL.
* While a trifle awkward, it is more efficient if the caller is going
* to combine many URLS.
*/

HRESULT HrGetCombinedURL( IHTMLElementCollection *pCollBase,
                         LONG cBase,
                         LONG lElemPos,
                         BSTR bstrRelURL,
                         BSTR bstrDocURL,
                         BSTR *pbstrBaseURL)
{
    HRESULT             hr = S_FALSE;
    IHTMLElement        *pElemBase;
    IHTMLBaseElement    *pBase;
    LONG                lBasePos=0,
        lBasePosSoFar=0;
    BSTR                bstr = NULL;
    LPWSTR              pszUrlW=0;
    WCHAR               szBaseW[INTERNET_MAX_URL_LENGTH];
    WCHAR               szUrlW[INTERNET_MAX_URL_LENGTH];
    DWORD               cch=INTERNET_MAX_URL_LENGTH;
    LONG                i;
    
    *pbstrBaseURL = 0;
    *szBaseW = 0;
    
    for (i=0; i<cBase; i++)
    {
        if (SUCCEEDED(HrGetCollectionItem(pCollBase, i, IID_IHTMLElement, (LPVOID *)&pElemBase)))
        {
            pElemBase->get_sourceIndex(&lBasePos);
            if (lBasePos < lElemPos &&
                lBasePos >= lBasePosSoFar)
            {
                if (SUCCEEDED(pElemBase->QueryInterface(IID_IHTMLBaseElement, (LPVOID *)&pBase)))
                {
                    bstr = NULL;
                    if (pBase->get_href(&bstr)==S_OK && bstr != NULL)
                    {
                        ASSERT (bstr);
                        if (*bstr)
                        {
                            StringCchCopy(szBaseW,  ARRAYSIZE(szBaseW), bstr);
                            lBasePosSoFar = lBasePos;
                        }
                        SysFreeString(bstr);
                    }
                    pBase->Release();
                }
            }
            pElemBase->Release();
        }
    }
    
    if (szBaseW[0] == 0 && bstrDocURL)
    {
        // We didn't find a <BASE> tag before our element, so fall back to using
        // the document's location as basis for the base
        StringCchCopy( szBaseW,  ARRAYSIZE(szBaseW), bstrDocURL );
    }
    
#ifndef WIN16  //RUN16_BLOCK - UrlCombineW is not available
    // if there's a <BASE> then do the combine
    if (*szBaseW && 
        SUCCEEDED(UrlCombineW(szBaseW, bstrRelURL, szUrlW, &cch, 0)))
        pszUrlW = szUrlW;
#endif //!WIN16
    
    // pszUrlW contains the combined <BODY> and <BASE> tag, return this.
    if (pszUrlW)
        *pbstrBaseURL = SysAllocString(pszUrlW);
    
    return (*pbstrBaseURL == NULL ? S_FALSE : S_OK);
}

HRESULT HrBSTRToLPSZ(BSTR bstr, LPSTR *lplpsz)
{
    ULONG     cch = 0;
    
    ASSERT (bstr && lplpsz);
    
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, -1, NULL, 0, NULL, NULL);

    if (!cch)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *lplpsz = new char[cch + 1];

    if (!*lplpsz)
    {
        return E_OUTOFMEMORY;
    }
    
    if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, *lplpsz, cch+1, NULL, NULL))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(GetLastError());
}

void RemoveBookMark(WCHAR *pwzURL, WCHAR **ppwzBookMark)
{
    if (pwzURL && ppwzBookMark)
    {
        *ppwzBookMark = pwzURL;

        while (**ppwzBookMark)
        {
            if (**ppwzBookMark == L'#')
            {
                **ppwzBookMark = L'\0';
                break;
            }

            (*ppwzBookMark)++;
        }
    }
}

void RestoreBookMark(WCHAR *pwzBookMark)
{
    if (pwzBookMark)
    {
        *pwzBookMark = L'#';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\privacyimport.hpp ===
//
//  declares privacy import headers.. defined in privacyimport.cpp
//

SHDOCAPI_(BOOL) LoadPrivacySettings( IN LPCWSTR szFilename);

#define REGSTR_VAL_PRIVLEASHLEGACY (L"LeashLegacyCookies")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\privacyimport.cpp ===
//  PrivacyImport.cpp  - handles parsing and import of privacy preferences
#include "priv.h"
#include "resource.h"
#include <mluisupp.h>

#include "SmallUtil.hpp"
#include "PrivacyImport.hpp"


#define MAX_TOKEN_SIZE 64
#define NUM_OF_ZONES (1 + IDS_PRIVACYXML6_COOKIEZONE_LAST - IDS_PRIVACYXML6_COOKIEZONE_FIRST)
#define NUM_OF_ACTIONS (1 + IDS_PRIVACYXML6_ACTION_LAST - IDS_PRIVACYXML6_ACTION_FIRST) 


//
//  DeleteCacheCookies was copy'n'pasted from Cachecpl.cpp
//
//     Any changes to either version should probably be transfered to both.
//

BOOL DeleteCacheCookies()
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY)
            DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
            
        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}


//*****************************************************************************************
//*****************************************************************************************
//
// CPrivacyXMLResourceStrings
//
//   just stores the Privacy format XML strings..

class CPrivacyXMLResourceStrings
{
    WCHAR m_szResourceString[IDS_PRIVACYXML6_LASTPRIVACYXML6
                             -IDS_PRIVACYXML6 + 1] [MAX_TOKEN_SIZE];
public:
    LPCWSTR GetResourceString( int iIndex) { return m_szResourceString[ iIndex - IDS_PRIVACYXML6];};


    BOOL Initialize()
    {
        for( int i = 0; 
             i < ARRAYSIZE(m_szResourceString);
             i++)
        {
            if( 0 == MLLoadStringW( IDS_PRIVACYXML6 + i, 
                                    m_szResourceString[i], MAX_TOKEN_SIZE))
                return FALSE;
        }
        return TRUE;
    }
};


//*****************************************************************************************
//*****************************************************************************************
//
//  CParseAccumulation is a class that stores the results of parsing an XML privacy
//preference file.  These results can then be sent to the system after parsing
//successfully completes.
//

class CParseAccumulation : public CPrivacyXMLResourceStrings
{
public:

    bool m_fFlushCookies;
    bool m_fFlushSiteList;
    bool m_fLeashCookies;

    struct SPerZonePartyPreferences
    {
        UINT m_uiNoPolicyDefault;
        UINT m_uiNoRuleDefault;
        bool m_fAlwaysAllowSession;
        CGrowingString m_cZonePreference;
    };

    struct SPerZonePreferences
    {
        UINT m_uiZoneID;
        bool m_fSetZone;
        SPerZonePartyPreferences m_party[2];  // first party = 0, third party = 1
    };

    SPerZonePreferences m_zonePref[NUM_OF_ZONES];

    CQueueSortOf m_queueSitesToAccept;
    CQueueSortOf m_queueSitesToReject;

    ~CParseAccumulation()
    {
        void* iterator;

        iterator = NULL;
        //  free up the names sites to be accepted
        while( NULL != (iterator = m_queueSitesToAccept.StepEnumerate( iterator)))
        {
            SysFreeString( (BSTR)m_queueSitesToAccept.Get( iterator));
        }

        iterator = NULL;
        //  free up the names of sites to be rejected
        while( NULL != (iterator = m_queueSitesToReject.StepEnumerate( iterator)))
        {
            SysFreeString( (BSTR)m_queueSitesToReject.Get( iterator));
        }
    }

    BOOL Initialize()
    {
        m_fFlushCookies = false;
        m_fFlushSiteList = false;
        m_fLeashCookies = true;

        for( int i = 0; i < ARRAYSIZE( m_zonePref); i++)
        {
            m_zonePref[i].m_uiZoneID = 0;
            m_zonePref[i].m_fSetZone = false;
            m_zonePref[i].m_party[0].m_uiNoPolicyDefault = 0;
            m_zonePref[i].m_party[0].m_uiNoRuleDefault = 0;
            m_zonePref[i].m_party[0].m_fAlwaysAllowSession = false;
            m_zonePref[i].m_party[1].m_uiNoPolicyDefault = 0;
            m_zonePref[i].m_party[1].m_uiNoRuleDefault = 0;
            m_zonePref[i].m_party[1].m_fAlwaysAllowSession = false;
        }

        return CPrivacyXMLResourceStrings::Initialize();
    }


    BOOL AddSiteRule( BSTR bstrDomain, DWORD uiAction)
    {
        if( uiAction == IDS_PRIVACYXML6_ACTION_ACCEPT)
            return m_queueSitesToAccept.InsertAtEnd( (void*)bstrDomain) ? TRUE : FALSE;
        else if( uiAction == IDS_PRIVACYXML6_ACTION_REJECT)
            return m_queueSitesToReject.InsertAtEnd( (void*)bstrDomain) ? TRUE : FALSE;
        else
            return FALSE;
    }


    long GetZoneFromResource( UINT uiZoneResource)
    {
        switch(uiZoneResource)
        {
        case IDS_PRIVACYXML6_COOKIEZONE_INTERNET:
            return URLZONE_INTERNET;
        case IDS_PRIVACYXML6_COOKIEZONE_INTRANET:
            return URLZONE_INTRANET;
        case IDS_PRIVACYXML6_COOKIEZONE_TRUSTED:
            return URLZONE_TRUSTED;
        default:
            return -1;
        }
    }

    BOOL DoAccumulation()
    {
        BOOL returnValue = FALSE;
        long i;
        void* iterator;

        if( m_fFlushSiteList)
            InternetClearAllPerSiteCookieDecisions();

    
        DWORD dwSetValue = m_fLeashCookies ? TRUE : FALSE;
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_PRIVLEASHLEGACY,
                   REG_DWORD, &dwSetValue, sizeof(DWORD));

        if( m_fFlushCookies)
            DeleteCacheCookies();

        //  Set compact policy response rules for each zone
        for( i = 0; i < ARRAYSIZE(m_zonePref); i++)
        {
            if( !m_zonePref[i].m_fSetZone)
                continue;
            
            if( ERROR_SUCCESS !=
                PrivacySetZonePreferenceW( 
                    GetZoneFromResource(m_zonePref[i].m_uiZoneID), 
                    PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_CUSTOM, 
                    m_zonePref[i].m_party[0].m_cZonePreference.m_pszString))
            {
                goto doneDoAccumulation;
            }

            if( ERROR_SUCCESS !=
                PrivacySetZonePreferenceW( 
                    GetZoneFromResource(m_zonePref[i].m_uiZoneID), 
                    PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_CUSTOM, 
                    m_zonePref[i].m_party[1].m_cZonePreference.m_pszString))
            {
                goto doneDoAccumulation;
            }
        }

        //  If any per-site rules were specified, we modify the persite list..
        if( NULL != m_queueSitesToAccept.StepEnumerate(NULL)
            || NULL != m_queueSitesToReject.StepEnumerate(NULL))
        {
            //  First we clear all existing per site rules..
            InternetClearAllPerSiteCookieDecisions();

            //  Then we add the Accept per-site exceptions
            iterator = NULL;
            while( NULL != (iterator = m_queueSitesToAccept.StepEnumerate( iterator)))
            {
                InternetSetPerSiteCookieDecision( (LPCWSTR)m_queueSitesToAccept.Get( iterator), COOKIE_STATE_ACCEPT);
            }

            //  and then the Reject per-site exceptions
            iterator = NULL;
            while( NULL != (iterator = m_queueSitesToReject.StepEnumerate( iterator)))
            {
                InternetSetPerSiteCookieDecision( (LPCWSTR)m_queueSitesToReject.Get( iterator), COOKIE_STATE_REJECT);
            }
        }

        returnValue = TRUE;
    doneDoAccumulation:
        return returnValue;
    }
};



int FindP3PPolicySymbolWrap( LPCWSTR szSymbol)
{
    char szSymBuffer[MAX_PATH];
    int length = lstrlen( szSymbol);

    if( length + 1 > ARRAYSIZE( szSymBuffer))
        return -1;
    
    szSymBuffer[0] = '\0';
    SHTCharToAnsi( szSymbol, szSymBuffer, ARRAYSIZE( szSymBuffer));

    return FindP3PPolicySymbol( szSymBuffer);
}



//*****************************************************************************
//*****************************************************************************
//
//  XML Parsing functions
//
//  These functions help parsing XML.
//


//  GetNextToken looks at the node you are at (*ppCurrentNode) and tests
//if it has a particular tag value.  If it does, *ppOutToken is set to
//be a pointer to the node, *ppCurrentNode is advanced to the next node,
//and *pfFoundToken is set to TRUE.  If the *ppCurrentNode doesn't have
//the target tag, the *pfFoundToken is FALSE, *ppCurrentNode is unchanged,
//and *ppOutToken is NULL.
//  If *ppCurrentNode is the last node, *ppCurrentNode would be advanced
//to NULL when finding the target token.
BOOL GetNextToken( IN OUT IXMLDOMNode ** ppCurrentNode, IN LPCWSTR szTargetToken, 
                   OUT BOOL * pfFoundToken, OUT IXMLDOMNode ** ppOutTokenNode)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    BSTR bstrNodeName = NULL;
    VARIANT var;
    VariantInit( &var);

    if( *ppCurrentNode == NULL)
    {
        *pfFoundToken = FALSE;
        *ppOutTokenNode = NULL;
        returnValue = TRUE;
        goto doneGetNextToken;
    }

    hr = (*ppCurrentNode)->get_nodeName( &bstrNodeName);
    if( FAILED(hr))
        goto doneGetNextToken;

    if( 0 != StrCmpW( szTargetToken, bstrNodeName))
    {
        *pfFoundToken = FALSE;
        *ppOutTokenNode = NULL;
        returnValue = TRUE;
    }
    else
    {
        IXMLDOMNode * pNode = NULL;
        hr = (*ppCurrentNode)->get_nextSibling( &pNode);
        if( FAILED(hr))
            goto doneGetNextToken;
    
        *ppOutTokenNode = *ppCurrentNode;
        if( hr == S_OK)
            *ppCurrentNode = pNode;
        else
            *ppCurrentNode = NULL;
        *pfFoundToken = TRUE;
        returnValue = TRUE;
    }

doneGetNextToken:
    
    if( bstrNodeName != NULL)
        SysFreeString( bstrNodeName);

    return returnValue;
}


//  GeAttributes retrieves the XML attributes for a node.  The attributes to
//be fetched are passed in in array aszName, of length iStringCount.  The results
//are returned as VT_BSTRs on success of VT_EMPTY on failure.  The total number
//of attributes for the node is also returned (*plAllAttributesCount).
BOOL GetAttributes( 
    IN IXMLDOMNode * pNode, IN LPCWSTR * aszName, IN long iStringCount,
    OUT VARIANT * aAttributeVariants, OUT long * plAllAttributesCount)
{
    BOOL returnValue = FALSE;

    HRESULT hr;
    BSTR bstrAttributeName = NULL;
    IXMLDOMNamedNodeMap * pAttributes = NULL;
    IXMLDOMNode * pTempNode = NULL;

    hr = pNode->get_attributes( &pAttributes);
    if( FAILED(hr))
        goto doneGetAttributes;

    if( plAllAttributesCount != NULL)
    {
        hr = pAttributes->get_length( plAllAttributesCount);
        if( FAILED(hr))
            goto doneGetAttributes;
    }
    
    for( int i = 0; i < iStringCount; i++)
    {
        if( pTempNode != NULL)
            pTempNode->Release();
        pTempNode = NULL;
        if( bstrAttributeName != NULL)
            SysFreeString( bstrAttributeName);
        bstrAttributeName = NULL;

        aAttributeVariants[i].vt = VT_EMPTY;
        aAttributeVariants[i].bstrVal = NULL;
        
        bstrAttributeName = SysAllocString( aszName[i]);
        if( bstrAttributeName == NULL)
            continue;

        //  test if the ith attribute was set
        hr = pAttributes->getNamedItem( bstrAttributeName, &pTempNode);
        if( FAILED(hr) || pTempNode == NULL)
            continue;

        //  get the value
        hr = pTempNode->get_nodeTypedValue( &aAttributeVariants[i]);

        //  convert the value to a BSTR.
        hr = VariantChangeType( &aAttributeVariants[i], &aAttributeVariants[i], NULL, VT_BSTR);

        if( FAILED(hr) || aAttributeVariants[i].bstrVal == NULL)
        {
            VariantClear( &aAttributeVariants[i]);
            aAttributeVariants[i].vt = VT_EMPTY;
            aAttributeVariants[i].bstrVal = NULL;
        }
    }

    returnValue = TRUE;
doneGetAttributes:
    if( bstrAttributeName != NULL)
        SysFreeString( bstrAttributeName);
    
    if( pAttributes != NULL)
        pAttributes->Release();

    if( pTempNode != NULL)
        pTempNode->Release();
    return returnValue;
}


//  The actions by GetActionByResource are formatted for
//PrivacySetZonePreference, like /token=n/ where n is the action.
LPCWSTR GetActionByResource( UINT uiActionResource)
{
    switch( uiActionResource)
    {
    case IDS_PRIVACYXML6_ACTION_ACCEPT:
        return L"=a/";
    case IDS_PRIVACYXML6_ACTION_PROMPT:
        return L"=p/";
    case IDS_PRIVACYXML6_ACTION_FIRSTPARTY:
        return L"=l/";
    case IDS_PRIVACYXML6_ACTION_SESSION:
        return L"=d/";
    case IDS_PRIVACYXML6_ACTION_REJECT:
        return L"=r/";
    default:
        ASSERT(0);
        return L"r/";
    }
}

LPCWSTR GetShortActionByResource( UINT uiActionResource)
{
    switch( uiActionResource)
    {
    case IDS_PRIVACYXML6_ACTION_ACCEPT:
        return L"=a";
    case IDS_PRIVACYXML6_ACTION_PROMPT:
        return L"=p";
    case IDS_PRIVACYXML6_ACTION_FIRSTPARTY:
        return L"=l";
    case IDS_PRIVACYXML6_ACTION_SESSION:
        return L"=d";
    case IDS_PRIVACYXML6_ACTION_REJECT:
        return L"=r";
    default:
        ASSERT(0);
        return L"r";
    }
}


//  GetChildrenByName takes an XML node and returns all the subnodes
//with a particular name.
BOOL GetChildrenByName( IN IXMLDOMNode * pNode, IN LPCWSTR szName, 
                        OUT IXMLDOMNodeList ** ppOutNodeList, OUT long * plCount)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    BSTR bstr = NULL;
    IXMLDOMNodeList * pSelectedNodes;

    if( NULL == (bstr = SysAllocString( szName)))
        goto doneGetChildrenByName;

    hr = pNode->selectNodes( bstr, &pSelectedNodes);

    if( FAILED(hr))
        goto doneGetChildrenByName;

    if( plCount != NULL)
    {
        hr = pSelectedNodes->get_length( plCount);
        if( FAILED(hr))
            goto doneGetChildrenByName;
    }

    returnValue = TRUE;
    *ppOutNodeList = pSelectedNodes;
    pSelectedNodes = NULL;

doneGetChildrenByName:
    if( bstr != NULL)
        SysFreeString( bstr);

    if( pSelectedNodes != NULL)
        pSelectedNodes->Release();

    return returnValue;
}


//*****************************************************************************
//*****************************************************************************
//
//  XML preference parsing functions
//
//    These functions are specific to the v6 XML format of privacy preferences
//
//    To make sense of these functions, their easiest to look at looking at
//the bottom function first, then moving up to the next function.


//  parses <if expr="rule" action="act">
//  where rule is like " token & ! token" and act is like "accept"
BOOL ParseIfRule( IN IXMLDOMNode* pIfNode,
                  CParseAccumulation::SPerZonePartyPreferences* pAccumParty,
                  CParseAccumulation& thisAccum)                  
{
    BOOL returnValue = FALSE;
    LONG lTemp;
    UINT uiTemp;

    VARIANT avarRule[2];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantInit( &avarRule[lTemp]);
    LPCWSTR aszRuleAttributes[2] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_EXPR), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION)};

    if( TRUE != GetAttributes( 
                  pIfNode, aszRuleAttributes, ARRAYSIZE(aszRuleAttributes),
                  avarRule, &lTemp)
        || lTemp != 2
        || avarRule[0].vt == VT_EMPTY
        || avarRule[1].vt == VT_EMPTY)
    {
        goto doneParseIfRule;
    }

    // determine the action
    UINT uiActionResource;
    uiActionResource = 0;
    for( uiTemp = IDS_PRIVACYXML6_ACTION_FIRST;
         uiTemp <= IDS_PRIVACYXML6_ACTION_LAST;
         uiTemp++)
    {
        if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(uiTemp)))
            uiActionResource = uiTemp;
    }
    if( uiActionResource == 0)
        goto doneParseIfRule;


    //  Write the beginning of the next rule " /"
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" /"))
        goto doneParseIfRule;

    //  Write the rule expression formatted for GetZoneFromResource
    LPWSTR pCursor, pEndCursor;
    pCursor = avarRule[0].bstrVal;
    bool fContinue, fNegated;
    fContinue = true;
    while( fContinue)
    {
        while( *pCursor == L' ')
            pCursor++;
        
        fNegated = false;
        while( *pCursor == L'!')
        {
            fNegated = !fNegated;
            pCursor++;
            while( *pCursor == L' ')
                pCursor++;
        }
        if( fNegated)
        {
            if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"!"))
                goto doneParseIfRule;
        }

        while( *pCursor == L' ')
            pCursor++;

        pEndCursor = pCursor;
        while( *pEndCursor != L'\0' && *pEndCursor != L',' && *pEndCursor != L' ')
        {
            pEndCursor++;
        }
        WCHAR szToken[10];
        if( pEndCursor == pCursor
            || pEndCursor - pCursor > ARRAYSIZE(szToken)-1)
        {
            goto doneParseIfRule;
        }
        StrCpyNW( szToken, pCursor, (int)(pEndCursor-pCursor+1));
        szToken[ pEndCursor-pCursor] = L'\0';
        if( -1 == FindP3PPolicySymbolWrap( szToken))
            goto doneParseIfRule;
        if( TRUE != pAccumParty->m_cZonePreference.AppendToString(szToken))
             goto doneParseIfRule;
        pCursor = pEndCursor;

        while( *pCursor == L' ')
            pCursor++;

        fContinue = false;
        if( *pCursor == L',')
        {
            if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"&"))
                goto doneParseIfRule;
            fContinue = true;
            pCursor++;
        }
    }

    while( *pCursor == L' ')
        pCursor++;

    if( *pCursor != L'\0')
        goto doneParseIfRule;

    //  Write the ending of the next rule "=action/"
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetActionByResource(
                                uiActionResource)))
    {
        goto doneParseIfRule;
    }

    returnValue = TRUE;
doneParseIfRule:

    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantClear( &avarRule[lTemp]);

    return returnValue;
}
                  

// parses  <firstParty ...> or <thirdParty ...> elements
BOOL ParsePartyBlock( IN IXMLDOMNode* pPartyNode,
                      CParseAccumulation::SPerZonePartyPreferences* pAccumParty,
                      CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    long lTemp;
    UINT uiTemp;
    HRESULT hr;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pRuleNode = NULL;
    VARIANT avarAttributes[3];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarAttributes); lTemp++)
        VariantInit( &avarAttributes[lTemp]);
    LPCWSTR aszAttributes[3] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_NOPOLICYDEFAULT), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_NORULESDEFAULT), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ALWAYSALLOWSESSION)};

    if( TRUE != GetAttributes( pPartyNode, aszAttributes, ARRAYSIZE(aszAttributes),
                               avarAttributes, &lTemp)
        || lTemp != 3
        || avarAttributes[0].vt == VT_EMPTY
        || avarAttributes[1].vt == VT_EMPTY
        || avarAttributes[2].vt == VT_EMPTY)
    {
        goto doneParsePartyBlock;
    }

    hr = pPartyNode->get_firstChild( &pCurrentNode);
    if( FAILED(hr))
        goto doneParsePartyBlock;

    //  Determine No Policy and No Rule Matched defaults
    pAccumParty->m_uiNoPolicyDefault = 0;
    pAccumParty->m_uiNoRuleDefault = 0;
    for( uiTemp = IDS_PRIVACYXML6_ACTION_FIRST;
         uiTemp <= IDS_PRIVACYXML6_ACTION_LAST;
         uiTemp++)
    {
        if( 0 == StrCmp( avarAttributes[0].bstrVal, thisAccum.GetResourceString(uiTemp)))
            pAccumParty->m_uiNoPolicyDefault = uiTemp;
        if( 0 == StrCmp( avarAttributes[1].bstrVal, thisAccum.GetResourceString(uiTemp)))
            pAccumParty->m_uiNoRuleDefault = uiTemp;
    }
    if( pAccumParty->m_uiNoPolicyDefault == 0 || pAccumParty->m_uiNoRuleDefault == 0)
        goto doneParsePartyBlock;

    //  Determine if we should always allow session cookies.
    if( 0 == StrCmp( avarAttributes[2].bstrVal, 
                     thisAccum.GetResourceString(IDS_PRIVACYXML6_YES)))
    {
        pAccumParty->m_fAlwaysAllowSession = true;
    }
    else if( 0 == StrCmp( avarAttributes[2].bstrVal, 
                          thisAccum.GetResourceString(IDS_PRIVACYXML6_NO)))

    {
        pAccumParty->m_fAlwaysAllowSession = false;
    }
    else
    {
        goto doneParsePartyBlock;
    }

    //  Write the response if there is no policy
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"IE6-P3PV1/settings: nopolicy"))
        goto doneParsePartyBlock;
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetShortActionByResource(
                                pAccumParty->m_uiNoPolicyDefault)))
    {
        goto doneParsePartyBlock;
    }

    //  If we allow all session cookies, write that rule.
    if( pAccumParty->m_fAlwaysAllowSession)
    {
        if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" session=a"))
            goto doneParsePartyBlock;
    }

    //  Write each of the rules in IF blocks
    while( pCurrentNode != NULL)
    {
        if( pRuleNode != NULL)
            pRuleNode->Release();
        pRuleNode = NULL;
        
        BOOL fFoundIfRule;
        if( TRUE != GetNextToken( 
                      &pCurrentNode, thisAccum.GetResourceString( IDS_PRIVACYXML6_IF),
                      &fFoundIfRule, &pRuleNode)
            || fFoundIfRule != TRUE)
        {
            goto doneParsePartyBlock;
        }

        if( TRUE != ParseIfRule( pRuleNode, pAccumParty, thisAccum))
            goto doneParsePartyBlock;
    }

    //  Write the command for the No Rule Matched rule..
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" /"))
        goto doneParsePartyBlock;
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetActionByResource(
                                pAccumParty->m_uiNoRuleDefault)))
    {
        goto doneParsePartyBlock;
    }

    returnValue = TRUE;
doneParsePartyBlock:
    if( pCurrentNode != NULL)
        pCurrentNode->Release();
    
    if( pRuleNode != NULL)
        pRuleNode->Release();
    
    for( lTemp = 0; lTemp < ARRAYSIZE( avarAttributes); lTemp++)
        VariantClear( &avarAttributes[lTemp]);

    return returnValue;
}


BOOL ParseP3pCookiePolicyBlock( IN IXMLDOMNode* pP3pPolicyNode, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    BOOL bl;
    long iTemp;
    
    VARIANT varZoneAttribute;
    VariantInit( &varZoneAttribute);
    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pFirstPartyNode = NULL;
    IXMLDOMNode * pThirdPartyNode = NULL;
    
    LPCWSTR aszAttributes[1] = { thisAccum.GetResourceString(IDS_PRIVACYXML6_COOKIEZONE_ZONE)};
    if( TRUE != GetAttributes( pP3pPolicyNode, 
                               aszAttributes, ARRAYSIZE( aszAttributes), 
                               &varZoneAttribute, &iTemp)
        || iTemp != 1
        || varZoneAttribute.vt == VT_EMPTY)
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    hr = pP3pPolicyNode->get_firstChild( &pCurrentNode);
    if( FAILED( hr))
        goto doneParseP3pCookiePolicyBlock;

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FIRSTPARTY),
                              &bl, &pFirstPartyNode)
        || bl != TRUE)
    {
        goto doneParseP3pCookiePolicyBlock;
    }
    
    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_THIRDPARTY),
                              &bl, &pThirdPartyNode)
        || bl != TRUE)
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    if( pCurrentNode != NULL)  //  to many elements ...
        goto doneParseP3pCookiePolicyBlock;


    long iCurrentZone;
    iCurrentZone = -1;
    for( iTemp = 0; iTemp < NUM_OF_ZONES; iTemp++)
    {
        if( 0 == StrCmp(varZoneAttribute.bstrVal, 
                        thisAccum.GetResourceString( iTemp + IDS_PRIVACYXML6_COOKIEZONE_FIRST)))
        {
            iCurrentZone = iTemp;
        }
    }

    if( iCurrentZone == -1)
        goto doneParseP3pCookiePolicyBlock;

    thisAccum.m_zonePref[iCurrentZone].m_uiZoneID = iCurrentZone + IDS_PRIVACYXML6_COOKIEZONE_FIRST;
    thisAccum.m_zonePref[iCurrentZone].m_fSetZone = true;

    if( TRUE != ParsePartyBlock( pFirstPartyNode, &(thisAccum.m_zonePref[iCurrentZone].m_party[0]),
                                 thisAccum))
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    if( TRUE != ParsePartyBlock( pThirdPartyNode, &(thisAccum.m_zonePref[iCurrentZone].m_party[1]),
                                 thisAccum))
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    returnValue = TRUE;

doneParseP3pCookiePolicyBlock:
    VariantClear( &varZoneAttribute);

    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pFirstPartyNode != NULL)
        pFirstPartyNode->Release();

    if( pThirdPartyNode != NULL)
        pThirdPartyNode->Release();

    return returnValue;
}


BOOL ParseMSIEPrivacyBlock( IXMLDOMNode* pMSIEPrivacyNode, CParseAccumulation& thisAccum)
{
    bool returnValue = NULL;
    HRESULT hr;
    BOOL bl;
    long iZoneIndex;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pAlwaysReplayLegacyNode = NULL;
    IXMLDOMNode * pFlushCookiesNode = NULL;
    IXMLDOMNode * pFlushSiteListNode = NULL;
    IXMLDOMNode * apZoneNode[NUM_OF_ZONES];  
    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE(apZoneNode); iZoneIndex++)
        apZoneNode[iZoneIndex] = NULL;

    //  The correctness of attributes for this node was verified in
    //LoadPrivacySettings()..  (formatVersion="6.0")

    hr = pMSIEPrivacyNode->get_firstChild( &pCurrentNode);
    if( FAILED( hr))
        goto doneParseMSIEPrivacyBlock;

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE( apZoneNode); iZoneIndex++)
    {
        if( TRUE != GetNextToken( &pCurrentNode, 
                       thisAccum.GetResourceString(IDS_PRIVACYXML6_COOKIEZONE),
                       &bl, &apZoneNode[iZoneIndex]))
        {
            goto doneParseMSIEPrivacyBlock;
        }
    }

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ALWAYSREPLAYLEGACY),
                              &bl, &pAlwaysReplayLegacyNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fLeashCookies = pAlwaysReplayLegacyNode == NULL;

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FLUSHCOOKIES),
                              &bl, &pFlushCookiesNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fFlushCookies = pFlushCookiesNode != NULL;
    
    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FLUSHSITELIST),
                              &bl, &pFlushSiteListNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fFlushSiteList = pFlushSiteListNode != NULL;

    if( pCurrentNode != NULL)
        goto doneParseMSIEPrivacyBlock;

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE( apZoneNode); iZoneIndex++)
    {
        if( apZoneNode[iZoneIndex] != NULL)
        {
            if( TRUE != ParseP3pCookiePolicyBlock( apZoneNode[iZoneIndex], thisAccum))
                goto doneParseMSIEPrivacyBlock;
        }
    }    

    returnValue = TRUE;

doneParseMSIEPrivacyBlock:
    
    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pAlwaysReplayLegacyNode != NULL)
        pAlwaysReplayLegacyNode->Release();

    if( pFlushCookiesNode != NULL)
        pFlushCookiesNode->Release();

    if( pFlushSiteListNode != NULL)
        pFlushSiteListNode->Release();

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE(apZoneNode); iZoneIndex++)
    {
        if( apZoneNode[iZoneIndex] != NULL)
            apZoneNode[iZoneIndex]->Release();
    }

    return returnValue;
}


BOOL ParsePerSiteRule( IXMLDOMNode* pPerSiteRule, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    LONG lTemp;

    VARIANT avarRule[2];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantInit( &avarRule[lTemp]);
    VARIANT varDomain;
    VariantInit( &varDomain);
    LPCWSTR aszRuleAttributes[2] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_DOMAIN), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION)};

    if( TRUE != GetAttributes( 
                  pPerSiteRule, aszRuleAttributes, ARRAYSIZE(aszRuleAttributes),
                  avarRule, &lTemp)
        || lTemp != 2
        || avarRule[0].vt == VT_EMPTY
        || avarRule[1].vt == VT_EMPTY)
    {
        goto doneParsePerSiteRule;
    }

    //  get the domain and make sure its legit
    varDomain.vt = avarRule[0].vt;
    varDomain.bstrVal = avarRule[0].bstrVal;
    avarRule[0].vt = VT_EMPTY;
    avarRule[0].bstrVal = NULL;

    if( TRUE != IsDomainLegalCookieDomain( varDomain.bstrVal, varDomain.bstrVal))
        goto doneParsePerSiteRule;

    //  get the action, ensuring its also legit
    UINT uiActionResource;
    if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION_ACCEPT)))
        uiActionResource = IDS_PRIVACYXML6_ACTION_ACCEPT;
    else if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION_REJECT)))
        uiActionResource = IDS_PRIVACYXML6_ACTION_REJECT;
    else
        goto doneParsePerSiteRule;

    //  store the rule in the accumulated result
    if( TRUE != thisAccum.AddSiteRule( varDomain.bstrVal, uiActionResource))
        goto doneParsePerSiteRule;

    varDomain.vt = VT_EMPTY;
    varDomain.bstrVal = NULL;
   
    returnValue = TRUE;

doneParsePerSiteRule:
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantClear( &avarRule[lTemp]);

    VariantClear( &varDomain);

    return returnValue;
}


BOOL ParseMSIEPerSiteBlock( IXMLDOMNode* pPerSiteRule, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pRuleNode = NULL;

    hr = pPerSiteRule->get_firstChild( &pCurrentNode);
    if( FAILED(hr))
        goto doneParsePerSiteBlock;

    while( pCurrentNode != NULL)
    {
        if( pRuleNode != NULL)
            pRuleNode->Release();
        pRuleNode = NULL;
        
        BOOL fFoundPerSiteRule;
        if( TRUE != GetNextToken( 
                      &pCurrentNode, thisAccum.GetResourceString( IDS_PRIVACYXML6_SITE),
                      &fFoundPerSiteRule, &pRuleNode)
            || fFoundPerSiteRule != TRUE)
        {
            goto doneParsePerSiteBlock;
        }

        if( TRUE != ParsePerSiteRule( pRuleNode, thisAccum))
            goto doneParsePerSiteBlock;
    }

    returnValue = TRUE;

doneParsePerSiteBlock:
    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pRuleNode != NULL)
        pRuleNode->Release();

    return returnValue;
}


BOOL OpenXMLFile( LPCWSTR szFilename, IXMLDOMNode ** ppOutputNode)
{
    BOOL returnValue = FALSE;

    HRESULT hr;
    VARIANT varFilename;
    VariantInit( &varFilename);
        
    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMElement * pXMLRoot = NULL;
    IXMLDOMNode * pRootNode = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
           IID_IXMLDOMDocument, (void**)&pXMLDoc);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    hr = pXMLDoc->put_async( VARIANT_FALSE);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    varFilename.vt = VT_BSTR;
    varFilename.bstrVal = SysAllocString( szFilename);
    if( varFilename.bstrVal == NULL)
        goto doneOpenXMLFile;
    VARIANT_BOOL varbool;
    hr = pXMLDoc->load( varFilename, &varbool);
    if( FAILED(hr) || varbool != VARIANT_TRUE)
        goto doneOpenXMLFile;

    hr = pXMLDoc->get_documentElement( &pXMLRoot);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    hr = pXMLRoot->QueryInterface( IID_IXMLDOMNode, (void **)&pRootNode);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    returnValue = TRUE;
    *ppOutputNode = pRootNode;
    pRootNode = NULL;
    
doneOpenXMLFile:   
    if( pXMLDoc != NULL)
        pXMLDoc->Release();

    if( pXMLRoot != NULL)
        pXMLRoot->Release();
  
    if( pRootNode != NULL)
        pRootNode->Release();

    VariantClear( &varFilename);

    return returnValue;
}


//
//  GetVersionedTag
//
//   Looks at all tags in pSource with the tag szTargetTag.  Returns
//the member with version fVersion.  Fails if zero or >1 such
//tags are found.
//

BOOL GetVersionedTag( IXMLDOMNode* pSource, LPCWSTR szTargetTag, LPCWSTR szVersionAttribute, float fVersion,
                      IXMLDOMNode** ppOutputNode)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    IXMLDOMNode * pNode = NULL;
    IXMLDOMNode * pResult = NULL;
    IXMLDOMNodeList * pRootNodeList = NULL;
    IXMLDOMNode * pVersionAttribute = NULL;
    VARIANT varVersion;
    VariantInit( &varVersion);

    //  Get the elements in pSource with tag szTargetTag
    long iListSize;
    if( TRUE != GetChildrenByName( pSource, szTargetTag,
                                   &pRootNodeList, &iListSize))
    {
        goto doneGetVersionedTag;
    }

    long iListIndex;
    for( iListIndex = 0; iListIndex < iListSize; iListIndex++)
    {
        if( pNode != NULL)
            pNode->Release();
        pNode = NULL;
        if( pVersionAttribute != NULL)
            pVersionAttribute->Release();
        pVersionAttribute = NULL;
        VariantClear( &varVersion);
        
        hr = pRootNodeList->get_item( iListIndex, &pNode);
        if( FAILED(hr))
            goto doneGetVersionedTag;

        long iTotalAttributeCount;
        LPCWSTR aszAttributes[1] = { szVersionAttribute};
        if( TRUE != GetAttributes( pNode, aszAttributes, ARRAYSIZE(aszAttributes), 
                                   &varVersion, &iTotalAttributeCount)
            || varVersion.vt == VT_EMPTY)
        {
            continue;
        }

        hr = VariantChangeType( &varVersion, &varVersion, NULL, VT_R4);
        if( FAILED(hr))
            goto doneGetVersionedTag;

        if( varVersion.fltVal != fVersion)
            continue;

        if( pResult == NULL)
        {
            pResult = pNode;
            pNode = NULL;
        }
        else
        {  // found multiple of right version.. syntax problem.
            goto doneGetVersionedTag;
        }
    }

    *ppOutputNode = pResult;
    pResult = NULL;
    returnValue = TRUE;

doneGetVersionedTag:
    if( pNode != NULL)
        pNode->Release();
    
    if( pResult != NULL)
        pResult->Release();

    if( pRootNodeList != NULL)
        pRootNodeList->Release();

    if( pVersionAttribute != NULL)
        pVersionAttribute->Release();

    VariantClear( &varVersion);
    
    return returnValue;
}
                      


BOOL LoadPrivacySettings(LPCWSTR szFilename, CParseAccumulation& thisAccum, 
                         IN OUT BOOL* pfParsePrivacyPreferences, IN OUT BOOL* pfParsePerSiteRules)
{
    BOOL returnValue = FALSE;

    IXMLDOMNode * pRootNode = NULL;
    IXMLDOMNode * pPrivacyPreferencesNode = NULL;
    IXMLDOMNode * pPerSiteSettingsNode = NULL;

    //  Load the XML file  
    if( TRUE != OpenXMLFile( szFilename, &pRootNode))
        goto doneLoadPrivacySettings;

    //  Get the node containing privacy settings
    if( TRUE != GetVersionedTag( pRootNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ROOTPRIVACY),
                  thisAccum.GetResourceString(IDS_PRIVACYXML6_VERSION), 6.0, &pPrivacyPreferencesNode))
    {
        goto doneLoadPrivacySettings;
    }

    //  Get the node containing per-site settings
    if( TRUE != GetVersionedTag( pRootNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ROOTPERSITE),
                  thisAccum.GetResourceString(IDS_PRIVACYXML6_VERSION), 6.0, &pPerSiteSettingsNode))
    {
        goto doneLoadPrivacySettings;
    }

    //  If we're supposed to import privacy preferences and we found some, parse privacy preferences.
    if( *pfParsePrivacyPreferences == TRUE && pPrivacyPreferencesNode != NULL)
    {
        if( TRUE != ParseMSIEPrivacyBlock( pPrivacyPreferencesNode, thisAccum))
        {
            goto doneLoadPrivacySettings;
        }
    }

    //  If we're supposed to import per-site rules and we found some, parse per-site rules.
    if( *pfParsePerSiteRules == TRUE && pPerSiteSettingsNode != NULL)
    {
        if( TRUE != ParseMSIEPerSiteBlock( pPerSiteSettingsNode, thisAccum))
        {
            goto doneLoadPrivacySettings;
        }
    }

    //  Indicate whether privacy preferences or per-site rules were parsed..
    *pfParsePrivacyPreferences = (*pfParsePrivacyPreferences == TRUE) && (pPrivacyPreferencesNode != NULL);
    *pfParsePerSiteRules = (*pfParsePerSiteRules == TRUE) && (pPerSiteSettingsNode != NULL);

    returnValue = TRUE;

doneLoadPrivacySettings:
    if( pRootNode != NULL)
        pRootNode->Release();

    if( pPrivacyPreferencesNode != NULL)
        pPrivacyPreferencesNode->Release();
    
    if( pPerSiteSettingsNode != NULL)
        pPerSiteSettingsNode->Release();
    
    return returnValue;
}


//  Top-level import function..  optionally imports privacy settings and per-site rules.
//The flag in tells if those items should be parsed, the flag out indicates if they were found.
//
//  Returns TRUE to indicate the import was successful, no syntax problems in the import
//file and the output flags are set.
//
//  Returns FALSE if there were any problems loading the file or writing the imported settings.
SHDOCAPI_(BOOL) ImportPrivacySettings( IN LPCWSTR szFilename,
                                       IN OUT BOOL* pfParsePrivacyPreferences,
                                       IN OUT BOOL* pfParsePerSiteRules)
{
    BOOL returnValue = FALSE;
    CParseAccumulation thisAccum;

    if( TRUE != thisAccum.Initialize())
        goto doneImportPrivacySettings;

    if( TRUE != LoadPrivacySettings( szFilename, thisAccum, 
                    pfParsePrivacyPreferences, pfParsePerSiteRules))
        goto doneImportPrivacySettings;

    returnValue = thisAccum.DoAccumulation();

doneImportPrivacySettings:
    return returnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

// For use with VC6
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data

// Sundown
#pragma warning(disable: 4800)  // conversion to bool

#define ASSERT_PRIV_H_INCLUDED


// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API
#define _BROWSEUI_      // Make functions exported from browseui as stdapi (as they are delay loaded)

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#ifndef STRICT
#define STRICT
#endif

//
// Channels are enabled for IE4 upgrades.
//
#define ENABLE_CHANNELS

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
#include <nt.h>

// WARNING!  NTDLL is manually delay-loaded! bcause it is crippled on Win95.
// We used to use automatic delay-loading, but people who didn't realize that
// Win95 doesn't have full support for NTDLL would accidentally call NTDLL
// functions and cause us to crash on Win95.
#undef NTSYSAPI
#define NTSYSAPI
#include <ntrtl.h>
#include <nturtl.h>
#undef NTSYSAPI
#define NTSYSAPI DECLSPEC_IMPORT

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
#define POST_IE5_BETA // turn on post-split iedev stuff
#include <w95wraps.h>
#include <windows.h>
#include <windowsx.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

// Smartly delay load OLEAUT32
HRESULT VariantClearLazy(VARIANTARG *pvarg);
#define VariantClear VariantClearLazy
WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
#define VariantCopy VariantCopyLazy

// Must do this before including <exdisp.h> or the build will break.
// See comments at declaration of FindWindowD much further below.
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD
#endif

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <hlink.h>
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#undef SubclassWindow
#if defined(__cplusplus) && !defined(DONT_USE_ATL)
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component

// AtlMisc.h needs some defines from AtlApp.h
#ifndef __ATLAPP_H__
#include "AtlApp.h"
#endif

// include CString, CSize, CRect, CPoint, CFindFile from WTL10
// see %_NTROOT%\public\sdk\inc\wtl10
#include "AtlMisc.h"

// Include LBSTR::CString
#include <locbstr.h>

#endif

#include <shellapi.h>

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#define SEN_FIRST       (0U-550U)       // ;Internal


#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <ieguidp.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>
#include <iethread.h>

#include <help.h>

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>
#include <regapix.h>    // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // FEATURE (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#define DLL_IS_ROOTABLE
#include <ccstock.h>
#include <ccstock2.h>
#include <port32.h>

#define STRSAFE_NO_CB_FUNCTIONS
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <browseui.h>

#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#    ifdef __cplusplus
#        define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#    else
#        define ATOMICRELEASE(p) IUnknown_AtomicRelease((LPVOID*)&p)
#    endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <htmlfilter.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include "util.h"
#include "iepriv.h"
#include "brutil.h"
#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
// IEUNIX - we do have them in MainWin
//
#ifndef MAINWIN
#ifdef  UNICODE

   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;

#endif /* UNICODE */
#endif /* !MAINWIN */

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


extern const ITEMIDLIST c_idlDesktop;
typedef const BYTE *LPCBYTE;

STDAPI MonikerFromURLPidl(LPCITEMIDLIST pidlURLItem, IMoniker** ppmk);
STDAPI MonikerFromURL(LPCWSTR wszPath, IMoniker** ppmk);
STDAPI MonikerFromString(LPCTSTR szPath, IMoniker** ppmk);

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

extern IShellFolder* g_psfInternet;
HRESULT InitPSFInternet(void);

//
// Debug helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

BOOL    IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix);

#endif // DEBUG

//
// we may not be part of the namespace on IE3/Win95
//
#define ILIsEqual(p1, p2)       IEILIsEqual(p1, p2, FALSE)


extern LPCITEMIDLIST c_pidlURLRoot;

//
// Trace/dump/break flags specific to shell32\.
//   (Standard flags defined in shellp.h)
//

// Break flags
#define BF_ONDUMPMENU       0x10000000      // Stop after dumping menus
#define BF_ONLOADED         0x00000010      // Stop when loaded

// Trace flags
#define TF_INTSHCUT         0x00000010      // Internet shortcuts
#define TF_REGCHECK         0x00000100      // Registry check stuff
#define TF_SHDLIFE          0x00000200
#define TF_SHDREF           0x00000400
#define TF_SHDPERF          0x00000800
#define TF_SHDAUTO          0x00001000
#define TF_MENUBAND         0x00002000      // Menu band messages
#define TF_SITEMAP          0x00004000      // Sitemap messages
#define TF_SHDTHREAD        0x00008000      // Thread management
#define TF_SHDCONTROL       0x00010000      // ActiveX Control
#define TF_SHDAPPHACK       0x00020000      // Hack for app-bug
#define TF_SHDBINDING       0x00040000      // Moniker binding
#define TF_SHDPROGRESS      0x00080000      // Download progress
#define TF_SHDNAVIGATE      0x00100000      // Navigation
#define TF_SHDUIACTIVATE    0x00200000      // UI-Activation/Deactivation
#define TF_OCCONTROL        0x00400000      // OC Hosting Window Control
#define TF_PIDLWRAP         0x00800000      // Pidl / Protocol wrapping
#define TF_AUTOCOMPLETE     0x01000000      // AutoCompletion
#define TF_COCREATE         0x02000000      // WinList/CoCreate(Browser only)
#define TF_URLNAMESPACE     0x04000000      // URL Name Space
#define TF_BAND             0x08000000      // Bands (ISF Band, etc)
#define TF_TRAVELLOG        0x10000000      // TravelLog and Navigation stack
#define TF_DDE              0x20000000      // PMDDE traces
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

//FEATURE: REMOVE
#define TF_OBJECTCACHE      TF_TRAVELLOG

// (Re-use TF_CUSTOM1 and TF_CUSTOM2 by defining a TF_ value in your
// local file to one of these values while you have the file checked
// out.)

// Dump flags
#define DF_SITEMAP          0x00000001      // Sitemap
#define DF_MEMLEAK          0x00000002      // Dump leaked memory at the end
#define DF_DEBUGQI          0x00000004      // Alloc stub object for each QI
#define DF_DEBUGQINOREF     0x00000008      // No AddRef/Release QI stub
#define DF_DEBUGMENU        0x00000010      // Dump menu handles
#define DF_URL              0x00000020      // Display URLs
#define DF_AUTOCOMPLETE     0x00000040      // AutoCompletion
#define DF_DELAYLOADDLL     0x00000080      // Delay-loaded DLL
#define DF_SHELLLIST        0x00000100      // CShellList contents
#define DF_INTSHCUT         0x00000200      // Internet shortcut structs
#define DF_URLPROP          0x00000400      // URL properties
#define DF_MSGHOOK          0x00000800      // Menu MessageFilter
#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter

// Prototype flags
#define PF_USERMENUS        0x00000001      // Use traditional USER menu bar
#define PF_NEWFAVMENU       0x00000002      // New favorites menu
#define PF_FORCESHDOC401    0x00000004      // force shdoc401 even on NT5
//efine PF_                 0x00000008      // Used by dochost.cpp
//efine PF_                 0x00000010      // Unused
//efine PF_                 0x00000020      // Used by urlhist.cpp
//efine PF_                 0x00000040      // Unused
//efine PF_                 0x00000100      // Unused
//efine PF_                 0x00000200      // Used by shembed.cpp
//efine PF_                 0x00000400      // Unused?
//efine PF_                 0x00000800      // Unused?

//
// global object array - used for class factory, auto registration, type libraries, oc information
//

#include "cfdefs.h"

#define OIF_ALLOWAGGREGATION  0x0001

//
// global variables
//
//
// Function prototypes
//

HRESULT SHRegisterTypeLib(void);
VOID SHCheckRegistry(void);

// htregmng.cpp
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

#define OleAlloc(cb)    CoTaskMemAlloc(cb)
#define OleFree(pv)     CoTaskMemFree(pv)

STDAPI_(IBindCtx *) BCW_Create(IBindCtx* pibc);

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH
#define MAX_NAME_STRING     INTERNET_MAX_PATH_LENGTH
#define MAX_BROWSER_WINDOW_TITLE   128

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

STDAPI _SetStdLocation(LPTSTR szPath, UINT id);

STDAPI CDocObjectHost_AddPages(LPARAM that, HWND hwnd, HINSTANCE hinst, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
STDAPI_(void) CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax);

extern BOOL DeleteUrlCacheEntryA(LPCSTR pszUrlName);

void LaunchPrivacySettings(HWND);

//
// a couple bogus pidls
//
#define PIDL_LOCALHISTORY ((LPCITEMIDLIST)-1)
#define PIDL_NOTHING      ((LPCITEMIDLIST)-2)


//
// Globals (per-process)
//
extern UINT g_tidParking;           // parking thread
extern HPALETTE g_hpalHalftone;
extern BOOL g_fBrowserOnlyProcess;  // initialized in IEWinMain()



//
//  In DEBUG, send all our class registrations through a wrapper that
//  checks that the class is on our unregister-at-unload list.
//
#ifdef DEBUG
#undef  SHRegisterClass
#undef    RegisterClass
#define SHRegisterClass       SHRegisterClassD
#define   RegisterClass         RegisterClassD

STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS* pwc);
STDAPI_(ATOM)   RegisterClassD(CONST WNDCLASS* pwc);
#ifdef UNICODE
#define RealSHRegisterClass   SHRegisterClassW
#define   RealRegisterClass     RegisterClassWrapW
#else
#define RealSHRegisterClass   SHRegisterClassA
#define   RealRegisterClass     RegisterClassA
#endif // UNICODE
#endif // DEBUG

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
//  IShellWindows has a method called FindWindow, so we have to define
//  the debug wrapper macros before including <exdisp.h>.  We should've
//  called it FindWindowSW.  In fact, there should be some law against
//  giving a method the same name as a Windows API.
//
#ifdef DEBUG
STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExWrapW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG

#define CALLWNDPROC WNDPROC

extern const GUID CGID_ShellBrowser;
extern const GUID CGID_PrivCITCommands;

// Map KERNEL32 unicode string functions to SHLWAPI
//#define lstrcmpW    StrCmpW
//#define lstrcmpiW   StrCmpIW
//#define lstrcpyW    StrCpyW
//#define lstrcpynW   StrCpyNW
//#define lstrcatW    StrCatW

//
// Prevent buffer overruns - don't use unsafe functions.
//

//lstrcpy
#undef  lstrcpyW
#define lstrcpyW       Do_not_use_lstrcpyW_use_StrCpyNW
#define lstrcpyA       Do_not_use_lstrcpyA_use_StrCpyNA

#ifdef lstrcpy
    #undef lstrcpy
#endif
#define lstrcpy        Do_not_use_lstrcpy_use_StrCpyN

//StrCpy
//#ifdef StrCpyW
//    #undef StrCpyW
//#endif
#define StrCpyW        Do_not_use_StrCpyW_use_StrCpyNW

#ifdef StrCpyA
    #undef StrCpyA
#endif
#define StrCpyA        Do_not_use_StrCpyA_use_StrCpyNA

#ifdef StrCpy
    #undef StrCpy
#endif
#define StrCpy         Do_not_use_StrCpy_use_StrCpyN


//ualstrcpyW
#ifdef ualstrcpyW
    #undef ualstrcpyW
#endif
#define ualstrcpyW     Do_not_use_ualstrcpyW_ualstrcpynW

//lstrcatW
#define lstrcatW       Do_not_use_lstrcatW_use_StrCatBuffW
#define lstrcatA       Do_not_use_lstrcatA_use_StrCatBuffA

#ifdef lstrcat
    #undef lstrcat
#endif
#define lstrcat        Do_not_use_lstrcat_use_StrCatBuff

//wsprintf
#define wsprintfW      Do_not_use_wsprintfW_use_wnsprintfW
#define wsprintfA      Do_not_use_wsprintfA_use_wnsprintfA

#ifdef wsprintf
    #undef wsprintf
#endif
#define wsprintf       Do_not_use_wsprintf_use_wnsprintf

//wvsprintf
#ifdef wvsprintfW
    #undef wvsprintfW
#endif
#define wvsprintfW     Do_not_use_wvsprintfW_use_wvnsprintfW

#define wvsprintfA     Do_not_use_wvsprintfA_use_wvnsprintfA

#ifdef wvsprintf
    #undef wvsprintf
#endif
#define wvsprintf      Do_not_use_wvsprintf_use_wvnsprintf


//
// Don't use the kernel string functions.  Use shlwapi equivalents.
//
#ifndef _WIN64
// lstrcmp
#undef  lstrcmpW
#define lstrcmpW       Do_not_use_lstrcmpW_use_StrCmpW
//#define lstrcmpA       Do_not_use_lstrcmpA_use_StrCmpA
#ifdef lstrcmp
    #undef lstrcmp
#endif
#define lstrcmp        Do_not_use_lstrcmp_use_StrCmp

// lstrcmpi
#undef lstrcmpiW
#define lstrcmpiW      Do_not_use_lstrcmpiW_use_StrCmpIW
//#define lstrcmpiA      Do_not_use_lstrcmpiA_use_StrCmpIA
#ifdef lstrcmpi
    #undef lstrcmpi
#endif
#define lstrcmpi       Do_not_use_lstrcmpi_use_StrCmpI

// lstrncmpi
#define lstrncmpiW     Do_not_use_lstrncmpiW_use_StrCmpNIW
//#define lstrncmpiA      Do_not_use_lstrncmpiA_use_StrCmpNIA
#ifdef lstrncmpi
    #undef lstrncmpi
#endif
#define lstrncmpi      Do_not_use_lstrncmpi_use_StrCmpNI


//lstrcpyn
#undef lstrcpynW
#define lstrcpynW      Do_not_use_lstrcpynW_use_StrCpyNW
//#define lstrcpynA      Do_not_use_lstrcpynA_use_StrCpyNA
#ifdef lstrcpyn
    #undef lstrcpyn
#endif
#define lstrcpyn       Do_not_use_lstrcpyn_use_StrCpyN
#endif

extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

extern BOOL g_fRunningOnNT;
extern BOOL g_bNT5Upgrade;
extern BOOL g_bRunOnNT5;
extern BOOL g_bRunOnMemphis;
extern BOOL g_fRunOnFE;
extern UINT g_uiACP;
//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

#ifdef WINDOWS_ME
//
// This is needed for BiDi localized win95 RTL stuff
//
extern BOOL g_bBiDiW95Loc;

#else // !WINDOWS_ME
#define g_bBiDiW95Loc FALSE
#endif // WINDOWS_ME

extern const TCHAR c_szHelpFile[];
extern const TCHAR c_szHtmlHelpFile[];
extern const TCHAR c_szURLPrefixesKey[];
extern const TCHAR c_szDefaultURLPrefixKey[];
extern const TCHAR c_szShellEmbedding[];
extern const TCHAR c_szViewClass[];

#define c_szNULL        TEXT("")

// status bar pane numbers actually used to create the controls - in left-to-right order
#define STATUS_PANES            6
#define STATUS_PANE_NAVIGATION  0
#define STATUS_PANE_PROGRESS    1
#define STATUS_PANE_OFFLINE     2
#define STATUS_PANE_PRINTER     2         // printer and offline share a spot
#define STATUS_PANE_PRIVACY     3
#define STATUS_PANE_SSL         4
#define STATUS_PANE_ZONE        5

#define ZONES_PANE_WIDTH        70

extern HICON g_hiconSSL;
extern HICON g_hiconFortezza;
extern HICON g_hiconOffline;
extern HICON g_hiconPrinter;
extern HICON g_hiconPrivacyImpact;

#define MAX_TOOLTIP_STRING 80

#define SID_SOmWindow IID_IHTMLWindow2
#define SID_SDropBlocker CLSID_SearchBand

#define MIN_BROWSER_DISPID              1
#define MAX_BROWSER_DISPID              1000

// We may want to put "Thunks between us and some of the shell private entries as
// some of them will take Ansi strings on Windows 95 and will take unicode strings
// on NT.
#include "runonnt.h"


// Function in IEDISP.CPP
HRESULT CreateBlankURL(BSTR *url, LPCTSTR pszErrorUrl, BSTR oldUrl);
SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData, DWORD cbData);

#include "idispids.h"

#ifdef __cplusplus
//
// C++ modules only
//
#include <shstr.h>
#include "shembed.h"


extern "C" const ITEMIDLIST s_idlNULL;

// helper routines for view state stuff

IStream *GetDesktopRegStream(DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreams);
//IStream *GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams);

// StreamHeader Signatures
#define STREAMHEADER_SIG_CADDRESSBAND        0xF432E001
#define STREAMHEADER_SIG_CADDRESSEDITBOX     0x24F92A92

#define CoCreateInstance IECreateInstance
HRESULT IECreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

#endif

extern HRESULT LoadHistoryShellFolder(IUnknown *punkSFHistory, IHistSFPrivate **pphsfHistory); // from urlhist.cpp
extern void CUrlHistory_CleanUp();

#define c_szHelpFile     TEXT("iexplore.hlp")



/////// mappings...
////// these functions moved from being private utilities to being exported (mostly from shlwapi)
///// and thus need a new name to avoid name collisions
#define IsRegisteredClient SHIsRegisteredClient
#define IE_ErrorMsgBox SHIEErrorMsgBox
#define SetDefaultDialogFont SHSetDefaultDialogFont
#define RemoveDefaultDialogFont SHRemoveDefaultDialogFont
#define IsGlobalOffline SHIsGlobalOffline
#define SetWindowBits SHSetWindowBits
#define IsSameObject SHIsSameObject
#define SetParentHwnd SHSetParentHwnd
#define IsEmptyStream SHIsEmptyStream
#define PropagateMessage SHPropagateMessage
#define MenuIndexFromID  SHMenuIndexFromID
#define Menu_RemoveAllSubMenus SHRemoveAllSubMenus
#define _EnableMenuItem SHEnableMenuItem
#define _CheckMenuItem SHCheckMenuItem
#define SimulateDrop SHSimulateDrop
#define GetMenuFromID  SHGetMenuFromID
#define GetCurColorRes SHGetCurColorRes
#define VerbExists  SHVerbExists
#define IsExpandableFolder SHIsExpandableFolder
#define WaitForSendMessageThread SHWaitForSendMessageThread
#define FillRectClr  SHFillRectClr
#define SearchMapInt SHSearchMapInt
#define IsChildOrSelf SHIsChildOrSelf
#define StripMneumonic SHStripMneumonic
#define MapNbspToSp SHMapNbspToSp
#define GetViewStream SHGetViewStream
#define HinstShdocvw() HINST_THISDLL

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#define QUAD_PART(a) ((a)##.QuadPart)

// Sundown macros
#define PtrDiff(x,y)        ((LPBYTE)(x)-(LPBYTE)(y))

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.##member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.##member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.##member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.##member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.##member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"

#include "shfusion.h"


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\privacyui.hpp ===
#ifndef _PRIVACYUI_HPP_
#define _PRIVACYUI_HPP_
// 
//  PrivacyUI.hpp
//
//  Privacy implementation classes and functions
//

// Forward Declarations
class CDocObjectHost;
class CDOHBindStatusCallback;

// Function to initiate privacy dialog.. implemented in privacyui.cpp
// Publicly exported through the .w files
HRESULT
DoPrivacyDlg(
    HWND                hwndParent,             // parent window
    LPOLESTR            pszUrl,                 // base URL
    IEnumPrivacyRecords *pPrivacyEnum,          // enum of all affected dependant URLs
    BOOL                fReportAllSites         // show all or just show sites with privacy impact
    );

// Used during binding to keep track of the privacy data coming in through
// urlmon notifications

class CPrivacyRecord
{
public:
    // Data Members
    TCHAR *       _pszUrl;
    TCHAR *       _pszPolicyRefUrl;
    TCHAR *       _pszP3PHeader;
    DWORD         _dwPrivacyFlags;    // contains the COOKIEACTION flags in the LOWORD and other 
                                      // PRIVACY flags (TopLevel, HasPolicy, Impacted) defined in mshtml.h
    CPrivacyRecord *    _pNextNode;         

    // Methods
    CPrivacyRecord() : _pszUrl(NULL), _pszPolicyRefUrl(NULL), _pszP3PHeader(NULL),
                       _dwPrivacyFlags(0), _pNextNode(NULL) {}
    ~CPrivacyRecord();

    HRESULT Init(LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, DWORD dwFlags);

    HRESULT SetNext( CPrivacyRecord *  pNextRec );
    CPrivacyRecord * GetNext() { return _pNextNode; }
};


class CPrivacyQueue
{
public:
    CPrivacyQueue() : _pHeadRec(NULL), _pTailRec(NULL), _ulSize(0) {}
    ~CPrivacyQueue();

    void Queue(CPrivacyRecord *pRecord);
    CPrivacyRecord * Dequeue();
    
    void Reset();

private:
    CPrivacyRecord  *     _pHeadRec;      // Beginning of the list
    CPrivacyRecord  *     _pTailRec;      // Last record in the list. Need to keep track of this to ease addition
    ULONG                 _ulSize;        // Number of records in the list
};

#endif

// value to determine whether to show one time discovery ui or not
#define REGSTR_VAL_PRIVDISCOVER     TEXT("PrivDiscUiShown")

// discovery dlg proc
BOOL DoPrivacyFirstTimeDialog( HWND hwndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\propstg.c ===
/*
 * propstg.c - Property storage ADT 
 */


#include "priv.h"
#include "propstg.h"

#ifndef UNIX
// SafeGetItemObject
//
// Since the GetItemObject member of IShellView was added late in the game
// during Win95 development we have found at least one example (rnaui.dll)
// of an application that built an IShellView with a NULL member for
// GetItemObject.  Fearing more applications that may have the same
// problem, this wrapper function was added to catch bad apps like rnaui.
// Thus, we check here for NULL before calling the member.
//
STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, LPVOID *ppv)
{
#ifdef __cplusplus
#error THIS_MUST_STAY_C
    // read the comment above
#endif
    if (!psv->lpVtbl->GetItemObject)
        return E_FAIL;

    return (HRESULT)(psv->lpVtbl->GetItemObject(psv, uItem, riid, ppv));
}
#endif


// This structure is a dictionary element. It maps a name to a propid.  

typedef struct
{
    PROPID  propid;
    WCHAR   wszName[MAX_PATH];
} DICTEL, * PDICTEL;


// This structure is a propvariant element.
typedef struct
{
    PROPVARIANT propvar;
    DWORD       dwFlags;        // PEF_*
} PROPEL, * PPROPEL;

// Flags for PROPEL structure
#define PEF_VALID           0x00000001
#define PEF_DIRTY           0x00000002

// This structure is the ADT for property storage

typedef struct
{
    DWORD   cbSize;
    DWORD   dwFlags;
    HDSA    hdsaProps;          // array of properties (indexed by propid) 
    HDPA    hdpaDict;           // dictionary of names mapped to propid 
    //  (each element is a DICTEL) 
    int     idsaLastValid;
} PROPSTG, * PPROPSTG;


// The first two entries in hdsaProps are reserved.  When we enumerate
// thru the list, we skip these entries.
#define PROPID_DICT     0
#define PROPID_CODEPAGE 1

#define IDSA_START      2
#define CDSA_RESERVED   2

BOOL IsValidHPROPSTG(HPROPSTG hstg)
{
    PPROPSTG pstg = (PPROPSTG)hstg;
    
    return (IS_VALID_WRITE_PTR(pstg, PROPSTG) &&
        SIZEOF(*pstg) == pstg->cbSize && 
        NULL != pstg->hdsaProps &&
        NULL != pstg->hdpaDict);
}

#ifdef DEBUG
BOOL IsValidPPROPSPEC(PROPSPEC * ppropspec)
{
    return (ppropspec &&
        PRSPEC_PROPID == ppropspec->ulKind ||
        (PRSPEC_LPWSTR == ppropspec->ulKind && 
        IS_VALID_STRING_PTRW(ppropspec->DUMMYUNION_MEMBER(lpwstr), -1)));
}
#endif

STDAPI PropStg_Create(OUT HPROPSTG * phstg, IN  DWORD dwFlags)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_WRITE_PTR(phstg, HPROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)LocalAlloc(LPTR, SIZEOF(*pstg));
        
        hres = STG_E_INSUFFICIENTMEMORY;       // assume error 
        
        if (pstg) 
        {
            pstg->cbSize = SIZEOF(*pstg);
            pstg->dwFlags = dwFlags;
            pstg->idsaLastValid = PROPID_CODEPAGE;
            
            pstg->hdsaProps = DSA_Create(SIZEOF(PROPEL), 8);
            pstg->hdpaDict = DPA_Create(8);
            
            if (pstg->hdsaProps && pstg->hdpaDict)
            {
                // The first two propids are reserved, so insert
                // placeholders.
                PROPEL propel;
                
                propel.propvar.vt = VT_EMPTY;
                propel.dwFlags = 0;
                
                DSA_SetItem(pstg->hdsaProps, PROPID_DICT, &propel);
                DSA_SetItem(pstg->hdsaProps, PROPID_CODEPAGE, &propel);
                
                hres = S_OK;
            }
            else
            {
                // Clean up because something failed 
                if (pstg->hdsaProps)
                {
                    DSA_Destroy(pstg->hdsaProps);
                    pstg->hdsaProps = NULL;
                }
                
                if (pstg->hdpaDict)
                {
                    DPA_Destroy(pstg->hdpaDict);
                    pstg->hdpaDict = NULL;
                }
                
                LocalFree(pstg);
                pstg = NULL;
            }
        }
        
        *phstg = (HPROPSTG)pstg;
        
        // Validate return values
        ASSERT((SUCCEEDED(hres) && 
            IS_VALID_WRITE_PTR(*phstg, PPROPSTG)) ||
            (FAILED(hres) && NULL == *phstg));
    }
    
    return hres;
}


STDAPI PropStg_Destroy(HPROPSTG hstg)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        
        if (pstg->hdsaProps)
        {
            int cdsa = DSA_GetItemCount(pstg->hdsaProps) - CDSA_RESERVED;
            
            // The first two elements are not cleared, because they
            // are just place-holders.
            
            if (0 < cdsa)
            {
                PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
                
                ASSERT(ppropel);
                
                while (0 < cdsa--)
                {
                    PropVariantClear(&ppropel->propvar);
                    ppropel++;
                }
            }
            
            DSA_Destroy(pstg->hdsaProps);
            pstg->hdsaProps = NULL;
        }
        
        if (pstg->hdpaDict)
        {
            int i, cel = DPA_GetPtrCount(pstg->hdpaDict);
            for (i = 0; i < cel; i++)
            {
                LocalFree(DPA_FastGetPtr(pstg->hdpaDict, i));
            }
            DPA_Destroy(pstg->hdpaDict);
            pstg->hdpaDict = NULL;
        }
        
        LocalFree(pstg);
        pstg = NULL;
        
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Compare names

Returns: standard -1, 0, 1
Cond:    --
*/
int CALLBACK PropStg_Compare(IN LPVOID pv1, IN LPVOID pv2, IN LPARAM lParam)
{
    LPCWSTR psz1 = pv1;
    LPCWSTR psz2 = pv2;
    
    // Case insensitive 
    return StrCmpIW(psz1, psz2);
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the property exists in this storage.
         If it does exist, the propid is returned.

Returns: TRUE 
         FALSE 

Cond:    --
*/
BOOL PropStg_PropertyExists(IN  PPROPSTG   pstg,
                            IN  const PROPSPEC * ppropspec,
                            OUT PROPID *   ppropid)
{
    BOOL bRet;
    PPROPEL ppropel;
    HDSA hdsaProps;
    
    ASSERT(pstg);
    ASSERT(ppropspec);
    ASSERT(ppropid);
    
    hdsaProps = pstg->hdsaProps;
    
    switch (ppropspec->ulKind)
    {
    case PRSPEC_PROPID:
        *ppropid = ppropspec->DUMMYUNION_MEMBER(propid);
        
        bRet = (*ppropid < (PROPID)DSA_GetItemCount(hdsaProps));
        if (bRet)
        {
            ppropel = DSA_GetItemPtr(hdsaProps, *ppropid);
            bRet = (ppropel && IsFlagSet(ppropel->dwFlags, PEF_VALID));
        }
        break;
        
    case PRSPEC_LPWSTR:
        // Key off whether the name exists 
        *ppropid = DPA_Search(pstg->hdpaDict, ppropspec->DUMMYUNION_MEMBER(lpwstr), 0, PropStg_Compare, 0, DPAS_SORTED);
        
#ifdef DEBUG
        // Sanity check that the property actually exists
        ppropel = DSA_GetItemPtr(hdsaProps, *ppropid);
        ASSERT(-1 == *ppropid ||
            (ppropel && IsFlagSet(ppropel->dwFlags, PEF_VALID)));
#endif
        
        bRet = (-1 != *ppropid);
        break;
        
    default:
        bRet = FALSE;
        break;
    }
    
    // Propid values 0 and 1 are reserved, as are values >= 0x80000000 
    if (bRet && (0 == *ppropid || 1 == *ppropid || 0x80000000 <= *ppropid))
        bRet = FALSE;
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Create a new propid and assign the given name to
         it.  

         The propid is an index into hdsaProps.

Returns: S_OK
         STG_E_INSUFFICIENTMEMORY

Cond:    --
*/
HRESULT PropStg_NewPropid(IN  PPROPSTG pstg,
                          IN  LPCWSTR  pwsz,
                          IN  PROPID   propidFirst,
                          OUT PROPID * ppropid)           OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPOINTER;        // assume error
    DICTEL * pdictel;
    PROPID propid = (PROPID)-1;
    HDPA hdpa;
    
    ASSERT(pstg);
    ASSERT(ppropid);
    
    if (EVAL(IS_VALID_STRING_PTRW(pwsz, -1)))
    {
        hres = STG_E_INSUFFICIENTMEMORY;            // assume error
        
        hdpa = pstg->hdpaDict;
        
        // The name shouldn't be in the list yet 
        ASSERT(-1 == DPA_Search(hdpa, (LPVOID)pwsz, 0, PropStg_Compare, 0, DPAS_SORTED));
        
        pdictel = LocalAlloc(LPTR, SIZEOF(*pdictel));
        if (pdictel)
        {
            // Determine the propid for this 
            PROPID propidNew = max(propidFirst, (PROPID)pstg->idsaLastValid + 1);
            
            pdictel->propid = propidNew;
            
            StrCpyNW(pdictel->wszName, pwsz, ARRAYSIZE(pdictel->wszName));
            
            if (-1 != DPA_AppendPtr(hdpa, pdictel))
            {
                // Sort it by name
                DPA_Sort(hdpa, PropStg_Compare, 0);
                hres = S_OK;
                propid = propidNew;
            }
        }
    }
    
    *ppropid = propid;
    
    return hres;
}

/*----------------------------------------------------------
Purpose: Read a set of properties given their propids.  If the propid 
         doesn't exist in this property storage, then set the
         value type to VT_EMPTY but return success; unless
         all the properties in rgpropspec don't exist, in which
         case also return S_FALSE.  

Returns: S_OK
         S_FALSE
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_ReadMultiple(IN HPROPSTG      hstg,
                            IN ULONG         cpspec,
                            IN const PROPSPEC * rgpropspec,
                            IN PROPVARIANT * rgpropvar)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropvar, PROPVARIANT, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        ULONG cpspecSav = cpspec;
        const PROPSPEC * ppropspec = rgpropspec;
        PROPVARIANT * ppropvar = rgpropvar;
        int idsa;
        BOOL bPropertyExists;
        ULONG cpspecIllegal = 0;
        
        hres = S_OK;        // assume success
        
        if (0 < cpspec)
        {
            // Read the list of property specs 
            while (0 < cpspec--)
            {
                bPropertyExists = PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa);
                
                // Does this property exist? 
                if ( !bPropertyExists )
                {
                    // No
                    ppropvar->vt = VT_ILLEGAL;
                    cpspecIllegal++;
                }
                else
                {
                    // Yes; is the element a valid property? 
                    PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, idsa);
                    
                    ASSERT(ppropel);
                    
                    if (IsFlagSet(ppropel->dwFlags, PEF_VALID))
                    {
                        // Yes; copy the variant value
                        hres = PropVariantCopy(ppropvar, &ppropel->propvar);
                    }
                    else
                    {
                        // No
                        ppropvar->vt = VT_ILLEGAL;
                        cpspecIllegal++;
                    }
                }
                
                ppropspec++;
                ppropvar++;
                
                //  Bail out of loop if something failed 
                if (FAILED(hres))
                    break;
            }
            
            // Are all the property specs illegal? 
            if (cpspecIllegal == cpspecSav)
            {
                hres = S_FALSE;     // yes
            }
            
            // Did anything fail above?
            if (FAILED(hres))
            {
                // Yes; clean up -- no properties will be retrieved 
                FreePropVariantArray(cpspecSav, rgpropvar);
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Add a set of property values given their propids.  
         If the propid doesn't exist in this property storage, 
         then add the propid as a legal ID and set the value. 

         On error, some properties may or may not have been 
         written.

         If pfn is non-NULL, this callback will get called
         to optionally "massage" the propvariant value or to
         validate it.  The rules for the callback are:

            1)  It can change the value directly if it is not
                allocated

            2)  If the value is allocated, the callback must 
                replace the pointer with a newly allocated 
                buffer that it allocates.  It must not try
                to free the value coming in, since it doesn't
                know how it was allocated.  It must also use
                CoTaskMemAlloc to allocate its buffer. 

            3)  If the callback returns an error, this function
                will stop writing properties and return that
                error.

            4)  If the callback returns S_FALSE, this function
                will not write that particular property and 
                continue on to the next property.  The function
                then returns S_FALSE once it is finished.

Returns: S_OK
         S_FALSE
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_WriteMultipleEx(IN HPROPSTG          hstg,
                               IN ULONG             cpspec,
                               IN const PROPSPEC *  rgpropspec,
                               IN const PROPVARIANT * rgpropvar,
                               IN PROPID            propidFirst,   OPTIONAL
                               IN PFNPROPVARMASSAGE pfn,           OPTIONAL
                               IN LPARAM            lParam)        OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropvar, PROPVARIANT, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        const PROPVARIANT * ppropvar = rgpropvar;
        int idsa;
        PROPEL propel;
        BOOL bPropertyExists;
        BOOL bSkippedProperty = FALSE;
        
        if (0 == cpspec)
        {
            hres = S_OK;
        }
        else
        {
            // Write the list of property specs 
            while (0 < cpspec--)
            {
                bPropertyExists = PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa);
                
                hres = S_OK;
                
                // If this is an illegal variant type and yet a valid 
                // property, then return an error.  Otherwise, ignore it
                // and move on.
                if (VT_ILLEGAL == ppropvar->vt)
                {
                    if (bPropertyExists)
                        hres = STG_E_INVALIDPARAMETER;
                    else
                        goto NextDude;
                }
                
                if (SUCCEEDED(hres))
                {
                    // Add the property.  If it doesn't exist, add it.
                    
                    // Is this a propid or a name? 
                    switch (ppropspec->ulKind)
                    {
                    case PRSPEC_PROPID:
                        idsa = ppropspec->DUMMYUNION_MEMBER(propid);
                        break;
                        
                    case PRSPEC_LPWSTR:
                        if ( !bPropertyExists )
                        {
                            hres = PropStg_NewPropid(pstg, ppropspec->DUMMYUNION_MEMBER(lpwstr), 
                                propidFirst, (LPDWORD)&idsa);
                        }
                        break;
                        
                    default:
                        hres = STG_E_INVALIDNAME;
                        break;
                    }
                    
                    if (SUCCEEDED(hres))
                    {
                        PROPVARIANT propvarT;
                        
                        ASSERT(S_OK == hres);   // we're assuming this on entry 
                        
                        // Save a copy of the original in case the
                        // callback changes it.
                        CopyMemory(&propvarT, ppropvar, SIZEOF(propvarT));
                        
                        // How did the callback like it? 
                        if (pfn)
                            hres = pfn(idsa, ppropvar, lParam);
                        
                        if (S_OK == hres)
                        {
                            // Fine; make a copy of the (possibly changed)
                            // propvariant value
                            hres = PropVariantCopy(&propel.propvar, ppropvar);
                            if (SUCCEEDED(hres))
                            {
                                propel.dwFlags = PEF_VALID | PEF_DIRTY;
                                
                                hres = (DSA_SetItem(pstg->hdsaProps, idsa, &propel) ? S_OK : STG_E_INSUFFICIENTMEMORY);
                                
                                if (SUCCEEDED(hres) && idsa > pstg->idsaLastValid)
                                {
                                    pstg->idsaLastValid = idsa;
                                }
                            }
                        }
                        else if (S_FALSE == hres)
                        {
                            bSkippedProperty = TRUE;
                        }
                        
                        // Restore the propvariant value to its original
                        // value. But first, did the callback allocate a
                        // new buffer? 
                        if (propvarT.DUMMYUNION_MEMBER(pszVal) != ppropvar->DUMMYUNION_MEMBER(pszVal))
                        {
                            // Yes; clear it (this function is safe for
                            // non-allocated values too).
                            PropVariantClear((PROPVARIANT *)ppropvar);
                        }
                        
                        // Restore
                        CopyMemory((PROPVARIANT *)ppropvar, &propvarT, SIZEOF(*ppropvar));
                        hres = S_OK;
                    }
                }
                
NextDude:
                ppropspec++;
                ppropvar++;
                
                //  Bail out of loop if something failed 
                if (FAILED(hres))
                    break;
            }
            
            if (bSkippedProperty)
                hres = S_FALSE;
            }
        }
        
        return hres;
    }
    

/*
Purpose: Add a set of property values given their propids.  
         If the propid doesn't exist in this property storage, 
         then add the propid as a legal ID and set the value. 

         On error, some properties may or may not have been 
         written.

Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

*/
STDAPI PropStg_WriteMultiple(IN HPROPSTG      hstg,
                             IN ULONG         cpspec,
                             IN const PROPSPEC * rgpropspec,
                             IN const PROPVARIANT * rgpropvar,
                             IN PROPID        propidFirst)      OPTIONAL
{
    return PropStg_WriteMultipleEx(hstg, cpspec, rgpropspec, rgpropvar,
        propidFirst, NULL, 0);
}

STDAPI PropStg_DeleteMultiple(IN HPROPSTG      hstg,
                              IN ULONG         cpspec,
                              IN const PROPSPEC * rgpropspec)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        HDSA hdsaProps = pstg->hdsaProps;
        PPROPEL ppropel;
        int idsa;
        int cdsa;
        
        hres = S_OK;
        
        if (0 < cpspec)
        {
            BOOL bDeletedLastValid = FALSE;
            
            // Delete the list of property specs
            while (0 < cpspec--)
            {
                if (PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa))
                {
                    // Delete the property.  Zero out the existing
                    // propel.  Don't call DSA_DeleteItem, otherwise
                    // we'll move the positions of any remaining
                    // properties following this one, thus changing their
                    // propids.
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(ppropel);
                    
                    PropVariantClear(&ppropel->propvar);
                    ppropel->dwFlags = 0;
                    
                    // Our idsaLastValid is messed up if we hit this
                    // assert
                    ASSERT(idsa <= pstg->idsaLastValid);
                    
                    if (idsa == pstg->idsaLastValid)
                        bDeletedLastValid = TRUE;
                    
                    // Delete the names associated with the property 
                    // FEATURE (scotth): implement this
                }
                
                ppropspec++;
            }
            
            // Did we delete the property that was marked as the terminating
            // valid property in the list? 
            if (bDeletedLastValid)
            {
                // Yes; go back and search for the new terminating index 
                ppropel = DSA_GetItemPtr(hdsaProps, pstg->idsaLastValid);
                cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
                ASSERT(ppropel);
                
                while (0 < cdsa--)
                {
                    if (IsFlagSet(ppropel->dwFlags, PEF_VALID))
                    {
                        pstg->idsaLastValid = cdsa - 1;
                        break;
                    }
                    ppropel--;
                }
                
                if (0 == cdsa)
                    pstg->idsaLastValid = PROPID_CODEPAGE;
            }
            
            // Since we didn't delete any items from hdsaProps (we freed 
            // the variant value and zeroed it out), this structure 
            // may have a bunch of unused elements at the end.  
            // Compact now if necessary.
            
            // Do we have a bunch of trailing, empty elements? 
            cdsa = DSA_GetItemCount(hdsaProps);
            
            if (cdsa > pstg->idsaLastValid + 1)
            {
                // Yes; compact.  Start from the end and go backwards
                // so DSA_DeleteItem doesn't have to move memory blocks.
                for (idsa = cdsa-1; idsa > pstg->idsaLastValid; idsa--)
                {
#ifdef DEBUG
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(IsFlagClear(ppropel->dwFlags, PEF_VALID));
#endif
                    DSA_DeleteItem(hdsaProps, idsa);
                }
            }
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Marks the specified properties dirty or undirty, depending
         on the value of bDirty.  
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_DirtyMultiple(IN HPROPSTG    hstg,
                             IN ULONG       cpspec,
                             IN const PROPSPEC * rgpropspec,
                             IN BOOL        bDirty)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        HDSA hdsaProps = pstg->hdsaProps;
        PPROPEL ppropel;
        int idsa;
        
        hres = S_OK;
        
        if (0 < cpspec)
        {
            // Mark the list of property specs
            while (0 < cpspec--)
            {
                // Does it exist?
                if (PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa))
                {
                    // Yes; mark it
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(ppropel);
                    
                    if (bDirty)
                    {
                        SetFlag(ppropel->dwFlags, PEF_DIRTY);
                    }
                    else
                    {
                        ClearFlag(ppropel->dwFlags, PEF_DIRTY);
                    }
                }
                
                ppropspec++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Marks or unmarks all the property values.
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_DirtyAll(IN HPROPSTG hstg,
                        IN BOOL     bDirty)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        
        hres = S_OK;
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                if (bDirty)
                    SetFlag(ppropel->dwFlags, PEF_DIRTY);
                else
                    ClearFlag(ppropel->dwFlags, PEF_DIRTY);
                ppropel++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Returns S_OK if at least one property value is dirty
         in the storage.  Otherwise, this function returns 
         S_FALSE.
         
Returns: S_OK if it is dirty
         S_FALSE if not
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_IsDirty(HPROPSTG hstg)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        
        hres = S_FALSE;
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                if (IsFlagSet(ppropel->dwFlags, PEF_DIRTY))
                {
                    hres = S_OK;
                    break;
                }
                ppropel++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Enumerates thru the list of properties.
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_Enum(IN HPROPSTG       hstg,
                    IN DWORD          dwFlags,      // One of PSTGEF_ 
                    IN PFNPROPSTGENUM pfnEnum,
                    IN LPARAM         lParam)       OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_CODE_PTR(pfnEnum, PFNPROPSTGENUM)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        DWORD dwFlagsPEF = 0;
        
        hres = S_OK;
        
        // Set the filter flags
        if (dwFlags & PSTGEF_DIRTY)
            SetFlag(dwFlagsPEF, PEF_DIRTY);
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            int idsa = IDSA_START;
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                // Does it pass thru filter? 
                if (IsFlagSet(ppropel->dwFlags, PEF_VALID) &&
                    (0 == dwFlagsPEF || (dwFlagsPEF & ppropel->dwFlags)))
                {
                    // Yes, call callback
                    HRESULT hresT = pfnEnum(idsa, &ppropel->propvar, lParam);
                    if (S_OK != hresT)
                    {
                        if (FAILED(hresT))
                            hres = hresT;
                        break;      // stop enumeration
                    }
                }
                ppropel++;
                idsa++;
            }
        }
    }
    
    return hres;
}


#ifdef DEBUG

HRESULT CALLBACK PropStg_DumpVar(IN PROPID        propid,
                                 IN PROPVARIANT * ppropvar,
                                 IN LPARAM        lParam)
{
    TCHAR sz[MAX_PATH];
    PPROPEL ppropel = (PPROPEL)ppropvar;        // we're cheating here
    
    if (IsFlagSet(ppropel->dwFlags, PEF_DIRTY))
        wnsprintf(sz, ARRAYSIZE(sz), TEXT("    *id:%#lx\t%s"), propid, Dbg_GetVTName(ppropvar->vt));
    else
        wnsprintf(sz, ARRAYSIZE(sz), TEXT("     id:%#lx\t%s"), propid, Dbg_GetVTName(ppropvar->vt));
    
    
    switch (ppropvar->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:
        TraceMsg(TF_ALWAYS, "     %s", sz);
        break;
        
    case VT_I2:
    case VT_I4:
        TraceMsg(TF_ALWAYS, "     %s\t%d", sz, ppropvar->DUMMYUNION_MEMBER(lVal));
        break;
        
    case VT_UI1:
        TraceMsg(TF_ALWAYS, "     %s\t%#02x '%c'", sz, ppropvar->DUMMYUNION_MEMBER(bVal), ppropvar->DUMMYUNION_MEMBER(bVal));
        break;
    case VT_UI2:
        TraceMsg(TF_ALWAYS, "     %s\t%#04x", sz, ppropvar->DUMMYUNION_MEMBER(uiVal));
        break;
    case VT_UI4:
        TraceMsg(TF_ALWAYS, "     %s\t%#08x", sz, ppropvar->DUMMYUNION_MEMBER(ulVal));
        break;
        
    case VT_LPSTR:
        TraceMsg(TF_ALWAYS, "     %s\t\"%S\"", sz, Dbg_SafeStrA(ppropvar->DUMMYUNION_MEMBER(pszVal)));
        break;
    case VT_LPWSTR:
        TraceMsg(TF_ALWAYS, "     %s\t\"%ls\"", sz, Dbg_SafeStrW(ppropvar->DUMMYUNION_MEMBER(pwszVal)));
        break;
        
    default:
#if defined(_WIN64)
        TraceMsg(TF_ALWAYS, "     %s\t0x%p", sz, (DWORD_PTR)ppropvar->DUMMYUNION_MEMBER(pszVal)); 
#else
        TraceMsg(TF_ALWAYS, "     s\t%#08lx", sz, (DWORD)ppropvar->DUMMYUNION_MEMBER(pszVal));
#endif
        
        break;
    }
    return S_OK;
}

STDAPI PropStg_Dump(IN HPROPSTG       hstg,
                    IN DWORD          dwFlags)      // One of PSTGDF_ 
{
    TraceMsg(TF_ALWAYS, "  Property storage 0x%08lx = {", hstg);
    
    PropStg_Enum(hstg, 0, PropStg_DumpVar, 0);
    
    TraceMsg(TF_ALWAYS, "  }");
    
    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\privacyui.cpp ===
//
//   privacyui.cpp  - Implements the UI for IE's privacy features
//
//   The privacy dialog is managed from this sourcefile.
//   The privacy view dialog is also managed from this sourcefile.

#include "priv.h"
#include "resource.h"
#include "privacyui.hpp"
#include <mluisupp.h>
#include "richedit.h"

#include "SmallUtil.hpp"


#define REGSTR_PRIVACYPS_PATHEDIT   TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REGSTR_PRIVACYPS_VALUEDIT   TEXT("PrivacyAddRemoveSites")  //  this key is duplicated in cpls\inetcpl\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHPANE   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUPANE   TEXT("Privacy Settings")  //  this key is duplicated in cpls\inetcpl\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHTAB    TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUTAB    TEXT("PrivacyTab")  //  this key is duplicated somewhere else


BOOL allowPerSiteModify()
{
    DWORD dwSize, dwRet, dwType, dwValue;
    dwSize = sizeof(dwValue);

    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHEDIT, 
                       REGSTR_PRIVACYPS_VALUEDIT, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHPANE, 
                       REGSTR_PRIVACYPS_VALUPANE, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHTAB, 
                       REGSTR_PRIVACYPS_VALUTAB, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }
    return TRUE;
}


struct SPerSiteData;
typedef SPerSiteData* PSPerSiteData;

class CPolicyHunt; 

struct SPrivacyDialogData;
typedef SPrivacyDialogData* PSPrivacyDialogData;


//+---------------------------------------------------------------------------
//
//  Function:   HyperlinkSubclass
//
//  Synopsis:   subclass for the makeshift hyperlink control
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK HyperlinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    WNDPROC     wndproc;
    static BOOL fMouseCaptured;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {

    case WM_SETCURSOR:

        if (!fMouseCaptured)
        {
            SetCapture(hwnd);
            fMouseCaptured = TRUE;
        }

        SetCursor(LoadHandCursor(0));
        return( TRUE );

    case WM_GETDLGCODE:
    {
        MSG* pmsg;
        LRESULT lRet = DLGC_STATIC;
        if (((pmsg = (MSG*)lParam)) && ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)))
        {
            switch(pmsg->wParam)
            {
            case VK_RETURN:
            case VK_SPACE:
                lRet |= DLGC_WANTALLKEYS;
                break;

            default:
                break;
            }
        }
        return lRet;
    }

    case WM_KEYDOWN:
        if ((wParam!=VK_SPACE)&&(wParam!=VK_RETURN))
        {
            break;
        }
    
    case WM_LBUTTONUP:
        SetFocus(hwnd);
        PostMessage( GetParent(hwnd), WM_APP, (WPARAM)GetDlgCtrlID( hwnd), (LPARAM)hwnd);
        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_SETFOCUS:

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadHandCursor(0));

            return( TRUE );
        }

        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        
        return( TRUE );

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_MOUSEMOVE:

        RECT                rect;
        int                 xPos, yPos;

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            fMouseCaptured = FALSE;
        }


    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}



//  Data structure associated with each site the privacy dialog may show
struct SPerSiteData : public IDispatch
{
    BSTR bstrUrl;
    BSTR bstrCookieDomain;
    BSTR bstrHeaderPolicyRef;
    BSTR bstrLinkTagPolicyRef;
    DWORD dwFlags;
    int iPrivacyImpactResource;
    CPolicyHunt* pPolicyHunt;

    SPerSiteData();
    ~SPerSiteData();

    BOOL ReadyForPolicyHunt();

    //  here is overhead for IDispatch:
    virtual ULONG __stdcall AddRef( void );
    virtual ULONG __stdcall Release( void );
    virtual HRESULT __stdcall
        QueryInterface( REFIID iid, void ** ppv);
    
    virtual HRESULT __stdcall
            GetTypeInfoCount( unsigned int FAR*  pctinfo);

    virtual HRESULT __stdcall
            GetTypeInfo( unsigned int  iTInfo,         
                         LCID  lcid,                   
                         ITypeInfo FAR* FAR*  ppTInfo);

    virtual HRESULT __stdcall
            GetIDsOfNames( REFIID  riid,                  
                           OLECHAR FAR* FAR*  rgszNames,  
                           unsigned int  cNames,          
                           LCID   lcid,                   
                           DISPID FAR*  rgDispId);

    virtual HRESULT __stdcall
            Invoke( DISPID  dispIdMember,      
                    REFIID  riid,              
                    LCID  lcid,                
                    WORD  wFlags,              
                    DISPPARAMS FAR*  pDispParams,  
                    VARIANT FAR*  pVarResult,  
                    EXCEPINFO FAR*  pExcepInfo,  
                    unsigned int FAR*  puArgErr);
};


enum enumPolicyHuntResult
{
    POLICYHUNT_INPROGRESS,
    POLICYHUNT_NOTFOUND,
    POLICYHUNT_FOUND,
    POLICYHUNT_ERROR,
    POLICYHUNT_FORMATERROR,
    POLICYHUNT_CANCELLED,
};

class CPolicyHunt : public CCancellableThread
{
public:
    CPolicyHunt();
    ~CPolicyHunt();
    BOOL Initialize( PSPerSiteData pSite);

    //BOOL Run();     defined in CCancelableThread
    //BOOL IsFinished();   defined in CCancelableThread
    //BOOL WaitForNotRunning( DWORD dwMilliseconds, PBOOL pfFinished);   defined in CCancelableThread
    BOOL GetResult( PDWORD pdwResult);  // special handling wraps CCancelableThread::GetResult
    LPCWSTR GetResultFilename();

private:
    virtual DWORD run();

    P3PSignal _p3pSignal;
    P3PResource _resourceSite;
    CHAR _szPolicy[MAX_URL_STRING];
    WCHAR _wszPolicy[MAX_URL_STRING];
    WCHAR _wszResultsFile[ MAX_PATH];
    HANDLE _hPolicyFile;

    PCHAR allocCharFromWChar( LPCWSTR pOriginal);

    static BSTR s_pwszPrivacyPolicyTransform;  
    //  the transform is loaded from a resource and does not need
    //to be deallocated..

public:
    LPCWSTR GetPolicyUrl() { return _wszPolicy;};

    static void FreePrivacyPolicyTransform()
    {
        if( s_pwszPrivacyPolicyTransform != NULL)
        {
            SysFreeString( s_pwszPrivacyPolicyTransform);
            s_pwszPrivacyPolicyTransform = NULL;
        }
    }
};

BSTR CPolicyHunt::s_pwszPrivacyPolicyTransform = NULL;


//
// data used by privacy dialog
//
struct SPrivacyDialogData
{
    // parameters set when initiating the privacy dialog..
    IEnumPrivacyRecords *pEnumPrivacyRecords;     // enumerator from Trident
    LPOLESTR    pszName;                          // site name
    BOOL        fReportAllSites;    // flag: Report all sites?  Otherwise, only report impacted
                                    //    and their parent sites.

    // parameters set within the privacy dialog code.
    
    //  listAllSites lists pointers to SPerSiteData for sites
    //return from IEnumPrivacyRecords::enum
    CQueueSortOf listAllSites;
    ULONG countRecordsEnumerated;                                    

    SPrivacyDialogData()
    {
        countRecordsEnumerated = 0;
    }
};


SPerSiteData::SPerSiteData()
{
    bstrUrl = NULL;
    bstrCookieDomain = NULL;
    bstrHeaderPolicyRef = NULL;
    bstrLinkTagPolicyRef = NULL;
    dwFlags = 0;
    iPrivacyImpactResource = 0;
    pPolicyHunt = NULL;
}


SPerSiteData::~SPerSiteData()
{
    if( bstrUrl != NULL)
        SysFreeString( bstrUrl);

    if( bstrCookieDomain != NULL)
        SysFreeString( bstrCookieDomain);

    if( bstrHeaderPolicyRef != NULL)
        SysFreeString( bstrHeaderPolicyRef);

    if( bstrLinkTagPolicyRef != NULL)
        SysFreeString( bstrLinkTagPolicyRef);

    if( pPolicyHunt != NULL)
        delete pPolicyHunt;
}


CPolicyHunt::CPolicyHunt()
{
    memset( &_p3pSignal, 0, sizeof(P3PSignal));
    memset( &_resourceSite, 0, sizeof(P3PResource));
    _szPolicy[0] = '\0';
    _wszPolicy[0] = L'\0';
    _wszResultsFile[0] = L'\0';
    _hPolicyFile = INVALID_HANDLE_VALUE;
}


CPolicyHunt::~CPolicyHunt()
{
    if( _hPolicyFile != INVALID_HANDLE_VALUE)
        CloseHandle( _hPolicyFile);

    if( _wszResultsFile[0] != L'\0')
    {
        DeleteFile( _wszResultsFile);
    }
    
    if( _p3pSignal.hEvent != NULL)
        CloseHandle( _p3pSignal.hEvent);

    if( _resourceSite.pszLocation != NULL)
        delete [] _resourceSite.pszLocation;
    if( _resourceSite.pszVerb != NULL)
        delete [] _resourceSite.pszVerb;
    if( _resourceSite.pszP3PHeaderRef != NULL)
        delete [] _resourceSite.pszP3PHeaderRef;
    if( _resourceSite.pszLinkTagRef != NULL)
        delete [] _resourceSite.pszLinkTagRef;
}


PCHAR CPolicyHunt::allocCharFromWChar( LPCWSTR pOriginal)
{
    PCHAR pResult;
    
    if( pOriginal == NULL)
        return NULL;
        
    int iSize = 1 + lstrlen( pOriginal);

    pResult = new CHAR[ iSize];

    if( pResult == NULL)
        return NULL;

    SHTCharToAnsi( pOriginal, pResult, iSize);

    return pResult;
}


BOOL CPolicyHunt::Initialize( PSPerSiteData pSite)
{
    if( TRUE != CCancellableThread::Initialize())
        return FALSE;
    
    _resourceSite.pszLocation = allocCharFromWChar( pSite->bstrUrl);
    _resourceSite.pszVerb = allocCharFromWChar( 
         (pSite->dwFlags & PRIVACY_URLHASPOSTDATA) ? L"POST" : L"GET");
    _resourceSite.pszP3PHeaderRef = allocCharFromWChar( pSite->bstrHeaderPolicyRef);
    _resourceSite.pszLinkTagRef = allocCharFromWChar( pSite->bstrLinkTagPolicyRef);
    _resourceSite.pContainer = NULL;

    return TRUE;
}


BOOL CPolicyHunt::GetResult( PDWORD pdwResult)
{
    if( IsFinished())
    {
        return CCancellableThread::GetResult( pdwResult);
    }

    *pdwResult = POLICYHUNT_INPROGRESS;
    return TRUE;
}


LPCWSTR CPolicyHunt::GetResultFilename()
{
    return _wszResultsFile;
}


//  used only in CPolicyHunt::run..
//  This the fetched transform need never be deallocated,
//and need only be allocated once.
BSTR LoadPrivacyPolicyTransform()
{
    BSTR returnValue = NULL;
    DWORD dwByteSizeOfResource;

    HRSRC hrsrc = FindResource( MLGetHinst(), 
                               TEXT("privacypolicytransform.xsl"), 
                               MAKEINTRESOURCE(RT_HTML));

    if( hrsrc == NULL)
        goto doneLoadPrivacyPolicyTransform;

    dwByteSizeOfResource = SizeofResource( MLGetHinst(), hrsrc);

    if( dwByteSizeOfResource == 0)
        goto doneLoadPrivacyPolicyTransform;

    HGLOBAL hGlobal = LoadResource( MLGetHinst(), hrsrc);  // Loaded resources do not need to be unloaded

    if( hGlobal == NULL)
        goto doneLoadPrivacyPolicyTransform;

    LPVOID pLockedResource = LockResource( hGlobal);  // Locked resources do not need to be unlocked

    if( pLockedResource == NULL)
        goto doneLoadPrivacyPolicyTransform;

    // Skip first WCHAR when allocating BSTR copy of the transform,
    // since unicode resource starts with an extra 0xFF 0xFE
    int cwCount = (dwByteSizeOfResource/sizeof(WCHAR)) - 1;
    returnValue = SysAllocStringLen( 1+(LPCWSTR)pLockedResource, cwCount);

doneLoadPrivacyPolicyTransform:
   
    return returnValue;
}


DWORD CPolicyHunt::run()
{
    DWORD retVal = POLICYHUNT_ERROR;
    int iTemp;
    DWORD dw;
    
    if( IsFinished())
        goto doneCPolicyHuntRun;

    //  MapResourceToPolicy phase

    //  ...  need an event..
    _p3pSignal.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL);
    if( _p3pSignal.hEvent == NULL)
        goto doneCPolicyHuntRun;

    //  ...   now call MapResourceToPolicy
    iTemp = MapResourceToPolicy(&(_resourceSite), 
                                _szPolicy, 
                                ARRAYSIZE(_szPolicy), 
                                &(_p3pSignal));
    if( iTemp != P3P_InProgress)
        goto doneCPolicyHuntRun;

    //  ...   now wait for MapResourceToPolicy to finish
    do
    {
        if( IsCancelled())
        {
            retVal = POLICYHUNT_CANCELLED;
            goto doneCPolicyHuntRun;
        }
    } while ( WAIT_TIMEOUT == (dw = WaitForSingleObject( _p3pSignal.hEvent, 100)));
    if( WAIT_OBJECT_0 != dw)
        goto doneCPolicyHuntRun;

    FreeP3PObject( _p3pSignal.hRequest);
    _p3pSignal.hRequest = NULL;
 
    //  ...   check if MapResourceToPolicy found anything..
    if( _szPolicy[0] == '\0')
    {
        retVal = POLICYHUNT_NOTFOUND;
        goto doneCPolicyHuntRun;
    }

    //  prepare a WCHAR copy of the policy
    SHAnsiToUnicode( _szPolicy, _wszPolicy, ARRAYSIZE( _wszPolicy));

    //  Now we need to prepare a temp file for our result.
    //  ...   get the path for the result file
    WCHAR szPathBuffer[ MAX_PATH];
    dw = GetTempPath( ARRAYSIZE( szPathBuffer), szPathBuffer);
    if( dw == 0 || dw+1 > MAX_PATH)
        goto doneCPolicyHuntRun;

    //  ...   get a .tmp filename for the result file
    dw = GetTempFileName( szPathBuffer, L"IE", 0, _wszResultsFile);
    if( dw == 0)
        goto doneCPolicyHuntRun;
    DeleteFile( _wszResultsFile);

    //  ...   make the .tmp filename a .htm filename
    dw = lstrlen( _wszResultsFile);
    while( dw > 0 && _wszResultsFile[dw] != L'.')
    {
           dw--;
    }
    StrCpyNW( _wszResultsFile + dw, L".htm", ARRAYSIZE(L".htm"));
    
    //  ...   open the file
    _hPolicyFile = CreateFile( _wszResultsFile, 
                               GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                               CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( _hPolicyFile == INVALID_HANDLE_VALUE)
        goto doneCPolicyHuntRun;

    if( s_pwszPrivacyPolicyTransform == NULL)
        s_pwszPrivacyPolicyTransform = LoadPrivacyPolicyTransform();

    if( s_pwszPrivacyPolicyTransform == NULL)
        goto doneCPolicyHuntRun;

    ResetEvent( _p3pSignal.hEvent);

    iTemp = GetP3PPolicy( _szPolicy, _hPolicyFile,
                          s_pwszPrivacyPolicyTransform, &_p3pSignal);
    if( iTemp != P3P_InProgress)
        goto doneCPolicyHuntRun;

    //  ...   now wait for GetP3PPolicy to finish
    do
    {
        if( IsCancelled())
        {
            retVal = POLICYHUNT_CANCELLED;
            goto doneCPolicyHuntRun;
        }
    } while ( WAIT_TIMEOUT == (dw = WaitForSingleObject( _p3pSignal.hEvent, 100)));
    if( WAIT_OBJECT_0 != dw)
        goto doneCPolicyHuntRun;

    int iGetP3PPolicyResult;
    iGetP3PPolicyResult = GetP3PRequestStatus( _p3pSignal.hRequest);

    switch( iGetP3PPolicyResult)
    {
    case P3P_Done:
        retVal = POLICYHUNT_FOUND;
        break;
    case P3P_NoPolicy:
    case P3P_NotFound:
        retVal = POLICYHUNT_NOTFOUND;
        break;
    case P3P_Failed:
        retVal = POLICYHUNT_ERROR;
        break;
    case P3P_FormatErr:
        retVal = POLICYHUNT_FORMATERROR;
        break;
    case P3P_Cancelled:
        retVal = POLICYHUNT_CANCELLED;
        break;
    default:
        retVal = POLICYHUNT_ERROR;
        break;
    }

doneCPolicyHuntRun:
    if( _hPolicyFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle( _hPolicyFile);
        _hPolicyFile = INVALID_HANDLE_VALUE;
    }

    if( _p3pSignal.hRequest != NULL)
    {
        FreeP3PObject( _p3pSignal.hRequest);
        _p3pSignal.hRequest = NULL;
    }

    if( _p3pSignal.hEvent != NULL)
    {
        CloseHandle( _p3pSignal.hEvent);
        _p3pSignal.hEvent = NULL;
    }

    memset( &_p3pSignal, 0, sizeof(P3PSignal));
        
    return retVal;
}


//  be warned: a NULL BSTR is equivalent to a "" BSTR..
//  This function returns the cookie domain from an http:// or https:// style Url.
BSTR GetCookieDomainFromUrl( LPCWSTR bstrFullUrl)
{
    BSTR returnValue = NULL;

    if( bstrFullUrl == NULL)
        goto doneGetMinimizedCookieDomain;

    WCHAR wszUrl[MAX_URL_STRING], *pMinimizedDomain;
    wszUrl[0] = L'\0';
    StrCpyNW( wszUrl, bstrFullUrl, lstrlen( bstrFullUrl)+1);
    
    if( wszUrl[0] == '\0')
        goto doneGetMinimizedCookieDomain;
    
    WCHAR *pBeginUrl = wszUrl;     // pBeginUrl will be 'http://full.domain.com/path/path...'
    while( *pBeginUrl != L'\0' && *pBeginUrl != L'/')
        pBeginUrl++;
    if( *pBeginUrl == L'/')
        pBeginUrl++;
    while( *pBeginUrl != L'\0' && *pBeginUrl != L'/')
        pBeginUrl++;
    if( *pBeginUrl == L'/')
        pBeginUrl++;               // now pBeginUrl is 'full.domain.com/path/path'..
    WCHAR *pEndUrl = pBeginUrl;    // pEndUrl will find the '/path/path..' and clip it from pBeginUrl
    while( *pEndUrl != L'\0' && *pEndUrl != L'/')
        pEndUrl++;
    *pEndUrl = L'\0';
    pMinimizedDomain = pEndUrl;   
    //  pBeginUrl is now like 'full.domain.com'
    //  pMinimizedDomain will reduce pBeginUrl to a domain minimized to still allow cookies..

    do
    {
        pMinimizedDomain--;
        while( pBeginUrl < pMinimizedDomain
               && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while( !IsDomainLegalCookieDomain( pMinimizedDomain, pBeginUrl)
             && pBeginUrl < pMinimizedDomain);

    returnValue = SysAllocString( pMinimizedDomain);

doneGetMinimizedCookieDomain:
    return returnValue;
}


void PrivacyDlgDeallocSiteList( PSPrivacyDialogData pData)
{
    void* iterator = NULL;
    while( NULL != (iterator = pData->listAllSites.StepEnumerate(iterator)))
    {
        PSPerSiteData pCurrent = 
            (PSPerSiteData)(pData->listAllSites.Get( iterator));
        delete pCurrent;
    }

    CPolicyHunt::FreePrivacyPolicyTransform();
}


BOOL PrivacyDialogExtendSiteList( PSPrivacyDialogData pData)
{
    BOOL returnValue = FALSE;

    BSTR bstrUrl = NULL, bstrPolicyRef = NULL;
    DWORD dwFlags;
    ULONG ulPrivacyRecordsTotal;

    if( FAILED(pData->pEnumPrivacyRecords->GetSize( &ulPrivacyRecordsTotal)))
        ulPrivacyRecordsTotal = 0;

    DWORD dwTemp;

    //  Enumerate the sites in IEnumPrivacyRecords::enum
    PSPerSiteData pCurrentSite = NULL, pCurrentSiteInList = NULL;
    while( pData->countRecordsEnumerated < ulPrivacyRecordsTotal
           && SUCCEEDED( dwTemp = pData->pEnumPrivacyRecords->
                                            Next(&bstrUrl, &bstrPolicyRef, 
                                            NULL, &dwFlags)))
    {
        pData->countRecordsEnumerated++;
        pCurrentSite = NULL;
        pCurrentSiteInList = NULL;
        void* iterator = NULL;

        if(NULL == bstrUrl || 0 == *bstrUrl)
        {
            //  every time we pass a blank token,
            //we begin processing a higher navigation level.
            SysFreeString( bstrUrl);
            bstrUrl = NULL;
            continue;
        }

        if( 0 != StrNCmpI( bstrUrl, L"http", ARRAYSIZE(L"http")-1))
        {
            // we ignore non http stuff... like ftp, local files..
            continue;
        }

        //  Test if the current site is already in the list.
        iterator = NULL;
        while( pCurrentSiteInList == NULL 
               && NULL != 
                  (iterator = pData->listAllSites.StepEnumerate(iterator)))
        {
            PSPerSiteData pCurrent = 
                (PSPerSiteData)(pData->listAllSites.Get( iterator));
            if( 0 == StrCmp( bstrUrl, pCurrent->bstrUrl))
                pCurrentSiteInList = pCurrent;
        }

        //  If the site is not in the list, add it.
        //  If the site isn't in the list, add the information given by enum.
        if( pCurrentSiteInList == NULL)
        {
            pCurrentSite = new SPerSiteData();

            if( pCurrentSite == NULL)
                goto donePrivacyDialogExtendSiteList;

            pCurrentSite->bstrUrl = bstrUrl;
            bstrUrl = NULL;
            pCurrentSite->dwFlags = dwFlags;
            //  Now find the minimized cookie domain..
            pCurrentSite->bstrCookieDomain = 
                GetCookieDomainFromUrl( pCurrentSite->bstrUrl);
            
            if( pData->listAllSites.InsertAtEnd( pCurrentSite))
                pCurrentSiteInList = pCurrentSite;
            else
                goto donePrivacyDialogExtendSiteList;
        }
        else  // else we have a duplicate list item
        {
            pCurrentSite = pCurrentSiteInList;
            //  pCurrentSite->bstrUrl is correct
            //  pCurrentSite->bstrCookieDomain is correct
            pCurrentSite->dwFlags |= dwFlags;
        }

        if( bstrPolicyRef != NULL && dwFlags & PRIVACY_URLHASPOLICYREFHEADER)
        {  //  We have the policy ref from the header..
            SysFreeString( pCurrentSite->bstrHeaderPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrHeaderPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }
        else if ( bstrPolicyRef != NULL && dwFlags & PRIVACY_URLHASPOLICYREFLINK)
        {  //  We have the policy ref from the link tag..
            SysFreeString( pCurrentSite->bstrLinkTagPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrLinkTagPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }
        else if( bstrPolicyRef != NULL)
        {  //  We have a policy ref with an unknown source..  bug in IEnumPrivacyRecords
            ASSERT(0);  
            SysFreeString( pCurrentSite->bstrHeaderPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrHeaderPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }


        //  now to determine the privacy impact of the site..
        //     precedence:  IDS_PRIVACY_BLOCKED > IDS_PRIVACY_RESTRICTED > IDS_PRIVACY_ACCEPTED > nothing
        if( dwFlags & (COOKIEACTION_ACCEPT | COOKIEACTION_LEASH))
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_ACCEPTED);
        }

        if( dwFlags & COOKIEACTION_DOWNGRADE)
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_RESTRICTED);
        }

        if( dwFlags & (COOKIEACTION_REJECT | COOKIEACTION_SUPPRESS))
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_BLOCKED);
        }

        SysFreeString( bstrUrl);
        bstrUrl = NULL;
        SysFreeString( bstrPolicyRef);
        bstrPolicyRef = NULL;
    }

    returnValue = TRUE;
  
donePrivacyDialogExtendSiteList:
    if( bstrUrl != NULL)
        SysFreeString( bstrUrl);

    if( bstrPolicyRef != NULL)
        SysFreeString( bstrUrl);

    if( pCurrentSite != NULL && pCurrentSiteInList == NULL)
        delete pCurrentSite;

    return returnValue;
}


BOOL PrivacyDlgBuildSiteList( PSPrivacyDialogData pData)
{
    PrivacyDlgDeallocSiteList( pData);

    return PrivacyDialogExtendSiteList( pData);
}


BOOL InitializePrivacyDlg(HWND hDlg, PSPrivacyDialogData pData)
{
    WCHAR       szBuffer[256];
    HWND        hwndListView = GetDlgItem(hDlg, IDC_SITE_LIST);
    RECT rc;
 
    //  Set the privacy status caption text
    BOOL fImpacted;
    if( SUCCEEDED(pData->pEnumPrivacyRecords->GetPrivacyImpacted(&fImpacted)) && fImpacted)
    {
        MLLoadStringW( IDS_PRIVACY_STATUSIMPACTED, szBuffer, ARRAYSIZE( szBuffer));
    }
    else
    {
        MLLoadStringW( IDS_PRIVACY_STATUSNOIMPACT, szBuffer, ARRAYSIZE( szBuffer));
    }
    SendMessage( GetDlgItem( hDlg, IDC_PRIVACY_STATUSTEXT), WM_SETTEXT,
                 0, (LPARAM)szBuffer);

    //Initialize the list view..
    // ..Empty the list in list view.
    ListView_DeleteAllItems (hwndListView);

    // ..Initialize the columns in the list view.
    LV_COLUMN   lvColumn;        
    lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = szBuffer;

    lvColumn.cx = 300;
    if( 0 != GetClientRect( hwndListView, &rc))
        lvColumn.cx = rc.right - rc.left - 150 - GetSystemMetrics( SM_CXVSCROLL);
    //  15 is an arbitrary number to prevent the horizontal scrollbar from appearing
    MLLoadStringW(IDS_PRIVACY_COLUMN1, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hwndListView, 1, &lvColumn);

    lvColumn.cx = 150;
    MLLoadStringW(IDS_PRIVACY_COLUMN2, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hwndListView, 2, &lvColumn);

    //  Initialize the view all/restricted combo box
    HWND hwndComboBox = GetDlgItem( hDlg, IDC_PRIVACY_VIEWCOMBO);

    ComboBox_ResetContent( hwndComboBox);
    int iComboPosition;

    MLLoadStringW(IDS_PRIVACY_VIEWIMPACTED, szBuffer, ARRAYSIZE(szBuffer));
    iComboPosition = ComboBox_AddString(hwndComboBox, szBuffer);
    ComboBox_SetItemData(hwndComboBox, iComboPosition, 0);
    MLLoadStringW(IDS_PRIVACY_VIEWALL, szBuffer, ARRAYSIZE(szBuffer));
    iComboPosition = ComboBox_AddString(hwndComboBox, szBuffer);
    ComboBox_SetItemData(hwndComboBox, iComboPosition, 1);

    ComboBox_SetCurSel( hwndComboBox, pData->fReportAllSites);

    GetDlgItemText( hDlg, IDC_PRIVACY_HELP, szBuffer, ARRAYSIZE( szBuffer));
    MLLoadStringW(IDS_PRIVACY_LEARNMOREABOUTPRIVACY, szBuffer, ARRAYSIZE(szBuffer));
    RenderStringToEditControlW(hDlg,
                               szBuffer,
                               (WNDPROC)HyperlinkSubclass,
                               IDC_PRIVACY_HELP);

    return TRUE;
}


//  add items to the privacy dialog's listview..
BOOL PopulatePrivacyDlgListView(HWND hDlg, PSPrivacyDialogData pData, bool fMaintainSelectedItem)
{
    HWND hwndListView = GetDlgItem( hDlg, IDC_SITE_LIST);
    void* iterator = NULL;
    int iCurrentPosition = 0;
    int iSelectedItem = ListView_GetSelectionMark( hwndListView);
    PSPerSiteData pSelectedItem = NULL;

    if( fMaintainSelectedItem  && iSelectedItem != -1)
    {
        LVITEM lvi;
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSelectedItem;
        if( FALSE != ListView_GetItem( hwndListView, &lvi)
           && lvi.lParam != (LPARAM)NULL)
        {
            pSelectedItem = (PSPerSiteData)lvi.lParam;
        }
    }

    // Empty the list in list view.
    ListView_DeleteAllItems (hwndListView);

    iSelectedItem = -1;  

    while( NULL != (iterator = pData->listAllSites.StepEnumerate(iterator)))
    {
        PSPerSiteData pCurrent = 
            (PSPerSiteData)(pData->listAllSites.Get(iterator));

        BOOL fAddItem = pData->fReportAllSites
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_SUPPRESSED
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_RESTRICTED
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_BLOCKED;

        if( fAddItem == TRUE)
        {
            LVITEM  lvitem;
            lvitem.mask = LVIF_TEXT | LVIF_PARAM;
            lvitem.pszText = pCurrent->bstrUrl;
            lvitem.iItem = iCurrentPosition++;
            lvitem.iSubItem = 0;
            lvitem.lParam = (LPARAM)pCurrent;
            ListView_InsertItem(hwndListView, &lvitem);

            if( pCurrent->iPrivacyImpactResource != 0)
            {
                WCHAR   wszTemp[128];

                // set cookie string
                lvitem.iSubItem = 1;
                lvitem.mask = LVIF_TEXT;
                lvitem.pszText = wszTemp;
                if( MLLoadString(pCurrent->iPrivacyImpactResource,
                                 wszTemp, ARRAYSIZE(wszTemp)))
                {
                    SendMessage(hwndListView, LVM_SETITEMTEXT, 
                                (WPARAM)lvitem.iItem, (LPARAM)&lvitem);
                }
            }

            //  We either keep the last item selected as selected,
            //or select the last top-level item.
            if( fMaintainSelectedItem)
            {
                if( pSelectedItem == pCurrent)
                    iSelectedItem = lvitem.iItem;
            }
        }
    }

//    if( fMaintainSelectedItem && iSelectedItem != -1)
//    {
//        ListView_SetItemState( hwndListView, iSelectedItem, LVIS_SELECTED, LVIS_SELECTED);
//        ListView_SetSelectionMark( hwndListView, iSelectedItem);
//        ListView_EnsureVisible( hwndListView, iSelectedItem, FALSE);
//    }

    PostMessage( hDlg, WM_APP, IDC_SITE_LIST, 0);  // notifies the dialog that a listview item has been selected

    return TRUE;
}


typedef BOOL (*PFNPRIVACYSETTINGS)(HWND);

void LaunchPrivacySettings(HWND hwndParent)
{
    HMODULE             hmodInetcpl;
    PFNPRIVACYSETTINGS  pfnPriv;

    hmodInetcpl = LoadLibrary(TEXT("inetcpl.cpl"));
    if(hmodInetcpl)
    {
        pfnPriv = (PFNPRIVACYSETTINGS)GetProcAddress(hmodInetcpl, "LaunchPrivacyDialog");
        if(pfnPriv)
        {
            pfnPriv(hwndParent);
        }

        FreeLibrary(hmodInetcpl);
    }
}


BOOL PrivacyPolicyHtmlDlg( HWND hDlg, HWND hwndListView, int iItemIndex)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    DWORD dw;
    PSPerSiteData pListViewData;
    WCHAR* pwchHtmlDialogInput = NULL;
    IMoniker * pmk = NULL;
    VARIANT  varArg, varOut;
    VariantInit( &varArg);
    VariantInit( &varOut);

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItemIndex;
    if( FALSE == ListView_GetItem( hwndListView, &lvi)
       || lvi.lParam == (LPARAM)NULL)
        goto donePrivacyPolicyHtmlDlg;
    pListViewData = (PSPerSiteData)lvi.lParam;

    WCHAR szResURL[MAX_URL_STRING];

    //  fetch the HTML for the dialog box..
    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("privacypolicy.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;
    
    hr = CreateURLMoniker(NULL, szResURL, &pmk);
    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;

    varArg.vt = VT_DISPATCH;
    varArg.pdispVal = (IDispatch*)pListViewData;

    //  Show the dialog..
    hr = ShowHTMLDialog( hDlg, pmk, &varArg, L"help:no; resizable:1", &varOut);

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;
        
    hr = VariantChangeType( &varOut, &varOut, NULL, VT_I4);

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;

    if( allowPerSiteModify())
    {
        switch( varOut.lVal)
        {
        default:
            hr = TRUE;
            break;
        case 1:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_UNKNOWN);
            break;
        case 2:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_ACCEPT);
            break;
        case 3:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_REJECT);
            break;
        }
    }
    
    if( hr != TRUE)
        goto donePrivacyPolicyHtmlDlg;

    returnValue = TRUE;

donePrivacyPolicyHtmlDlg:

    if( pListViewData->pPolicyHunt != NULL)
    {
        // no-op if already finished
        pListViewData->pPolicyHunt->NotifyCancel();  
        pListViewData->pPolicyHunt->WaitForNotRunning( INFINITE);
    }
    
    if( pListViewData->pPolicyHunt != NULL 
        && pListViewData->pPolicyHunt->GetResult( &dw) == TRUE
        && dw != POLICYHUNT_FOUND)
    {
        delete pListViewData->pPolicyHunt;
        pListViewData->pPolicyHunt = NULL;
    }

    if( pwchHtmlDialogInput != NULL)
        delete[] pwchHtmlDialogInput;
    
    if( pmk != NULL)
        ATOMICRELEASE( pmk);

    VariantClear( &varArg);
    VariantClear( &varOut);

    return returnValue;
}


BOOL PrivacyDlgContextMenuHandler( HWND hDlg, HWND hwndListView, 
                                   int iSelectedListItem, int x, int y)
{
    //user has initiated opening the context menu..
    //  if the user right-clicked a non-list item, we do nothing
    if( iSelectedListItem == -1
        || !allowPerSiteModify())
        return TRUE;

    SPerSiteData *psSiteData = NULL;
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelectedListItem;
    if( FALSE == ListView_GetItem( hwndListView, &lvi)
       || lvi.lParam == (LPARAM)NULL)
        return FALSE;
    psSiteData = (PSPerSiteData)(lvi.lParam);
    
    HMENU hmenu0 = LoadMenu( MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_CNTXTMN_PERSITE_ADD_REM));
    HMENU hmenu1 = GetSubMenu( hmenu0, 0);
    if( hmenu0 == NULL || hmenu1 == NULL)
    {
        DestroyMenu(hmenu0);
        return FALSE;
    }

    //  Check the appropriate option..
    unsigned long ulResult;
    MENUITEMINFO menuiteminfo;
    menuiteminfo.cbSize = sizeof(menuiteminfo);
    menuiteminfo.fMask = MIIM_STATE;
    menuiteminfo.fState = MFS_CHECKED;
    if( InternetGetPerSiteCookieDecision( psSiteData->bstrCookieDomain, &ulResult) == TRUE)
    {
        switch( ulResult)
        {
        case COOKIE_STATE_ACCEPT:
            SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_ACCEPT, FALSE, &menuiteminfo);
            break;
        case COOKIE_STATE_REJECT:
            SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_REJECT, FALSE, &menuiteminfo);
            break;
        }
    }
    else
    {
        SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_DEFAULT, FALSE, &menuiteminfo);
    }

    //  the target location of the context window depends on whether or not the user
    //right-clicked the mouse or used the context menu button..
    if( x == -1 && y == -1)
    {  //  context menu was opened through keyboard, not mouse..
        RECT rectListRect;
        RECT rectSelectionRect;
        if(  0 != GetWindowRect( hwndListView, &rectListRect)
            && TRUE == ListView_GetItemRect( hwndListView, iSelectedListItem, 
                                             &rectSelectionRect, LVIR_LABEL))
        {
            x = rectListRect.left + (rectSelectionRect.left + rectSelectionRect.right) / 2;
            y = rectListRect.top + (rectSelectionRect.top + rectSelectionRect.bottom) / 2;
        }
    }

    //  now we know enough to open the conext menu.
    BOOL userSelection = TrackPopupMenu( hmenu1, TPM_RETURNCMD, x, y, 0, hDlg, NULL);
    DestroyMenu( hmenu1);
    DestroyMenu( hmenu0);

    switch( userSelection)
    {
        case 0:
            //  User cancelled context menu, do nothing.
            break;
        case IDM_PRIVACY_PAR_ACCEPT:
            //  User chose to add site to per-site exclusion list.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_ACCEPT);
            break;
        case IDM_PRIVACY_PAR_REJECT:
            //  User chose to add site per-site inclusion list.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_REJECT);
            break;
        case IDM_PRIVACY_PAR_DEFAULT:
            //  User chose to have site use default behavior.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_UNKNOWN);
            break;
    }

   return TRUE;
}


INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PSPrivacyDialogData pData = (PSPrivacyDialogData)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam);
            pData = (PSPrivacyDialogData)lParam;
            InitializePrivacyDlg( hDlg, pData);
            PrivacyDlgBuildSiteList( pData);
            PopulatePrivacyDlgListView(hDlg, pData, false);

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            
            PostMessage( hDlg, WM_NEXTDLGCTL, 
                         (WPARAM)GetDlgItem( hDlg, IDC_SITE_LIST), 
                         MAKELPARAM( TRUE, 0));
            SetTimer( hDlg, NULL, 500, NULL);
            return TRUE;

        case WM_DESTROY:
            PrivacyDlgDeallocSiteList( pData);

            break;

        case WM_TIMER:
            {
                ULONG oldCount = pData->countRecordsEnumerated;
                if( pData != NULL
                    && TRUE == PrivacyDialogExtendSiteList( pData)
                    && oldCount < pData->countRecordsEnumerated)
                {
                    PopulatePrivacyDlgListView( hDlg, pData, true);
                }
            }
            
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    switch( GetDlgCtrlID(GetFocus()))
                    {
                        case IDC_SITE_LIST:
                        {
                            PostMessage( hDlg, WM_COMMAND, 
                                         (WPARAM)IDC_PRIVACY_SHOWPOLICY,
                                         (LPARAM)GetDlgItem(hDlg, IDC_PRIVACY_SHOWPOLICY));
                            return 0;  // return 0 to indicate message was handled
                        }
                        case IDC_PRIVACY_HELP:
                        {
                            PostMessage( hDlg, WM_APP, (WPARAM)IDC_PRIVACY_HELP, (LPARAM)GetDlgItem(hDlg, IDC_PRIVACY_HELP));
                            return 0;
                        }
                        case IDC_PRIVACY_VIEWCOMBO:
                        {
                            PostMessage( hDlg, WM_NEXTDLGCTL, 
                                         (WPARAM)GetDlgItem( hDlg, IDC_SITE_LIST), 
                                         MAKELPARAM( TRUE, 0)); 
                            return 0;
                        }
                    }
                    //  fall through if IDOK was actually due to hitting IDOK with defaulting on an enter..
                 case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
                    return 0;
                case IDC_SETTINGS:
                    LaunchPrivacySettings(hDlg);
                    return 0;
                case IDC_PRIVACY_VIEWCOMBO:
                    if( CBN_SELCHANGE == HIWORD(wParam))
                    {
                        HWND hwndComboBox = (HWND)lParam;

                        int iIndex = ComboBox_GetCurSel(hwndComboBox);
                        
                        if( iIndex != CB_ERR)
                        {
                            pData->fReportAllSites = (iIndex == 1) ? TRUE : FALSE;
                                                    
                            PopulatePrivacyDlgListView(hDlg, pData, true);
                        }
                        return 0;
                    }
                    break;
                case IDC_PRIVACY_SHOWPOLICY:
                    {
                        //  Catching the default return and seeing if the site list is
                        //selected was the only way to detect a return on the listview.
                        HWND hwndSiteList = GetDlgItem( hDlg, IDC_SITE_LIST);
                        int iSelectedItem = ListView_GetSelectionMark( hwndSiteList);
                        if( iSelectedItem != -1)
                        {
                            PrivacyPolicyHtmlDlg( hDlg, hwndSiteList, iSelectedItem);
                        }
                        return 0;
                    }
            }
            break;

        case WM_APP:
            if( LOWORD(wParam) == IDC_PRIVACY_HELP)
            {
                SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), 
                    HH_DISPLAY_TOPIC, (DWORD_PTR) L"sec_cook.htm", ML_CROSSCODEPAGE);
            }
            else if ( LOWORD( wParam) == IDC_SITE_LIST)
            {
                //   We post an WM_APP to the dialog everytime the selected list view item
                //is changed..  By handling the change in a posted message, we insure the
                //list view's selected item is updated.

                //  Whenever the selected privacy report list item is changed, we have to enable/disable
                //the show site policy button.

                int iSelectedItem = ListView_GetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST));

                EnableWindow( GetDlgItem( hDlg, IDC_PRIVACY_SHOWPOLICY), (-1 != iSelectedItem));

            }
            
            return 0;

        case WM_CONTEXTMENU:
            //  If the user hits the context menu button on the list view, we handle it here,
            //because its the only place to check for that keypress.
            //  If the user clicks the right mouse button for the context menu, we handle it in
            //WM__NOTIFY::NM_RCLICK, because the NM_RCLICK gives the correct seleceted item.
            if( GET_X_LPARAM(lParam) == -1
                && (HWND)wParam == GetDlgItem( hDlg, IDC_SITE_LIST))
            {
                int iSelectedItem = ListView_GetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST));
                PrivacyDlgContextMenuHandler( hDlg, (HWND)wParam, 
                                              iSelectedItem,
                                              GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            }
            break;
        case WM_NOTIFY:
            if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                && NM_DBLCLK == ((LPNMHDR)lParam)->code
                && ((LPNMITEMACTIVATE)lParam)->iItem != -1)
            {
                PrivacyPolicyHtmlDlg( hDlg, ((LPNMHDR)lParam)->hwndFrom, 
                                      ((LPNMITEMACTIVATE)lParam)->iItem);
            }
            else if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                     && NM_RCLICK == ((LPNMHDR)lParam)->code)
            {
                int iRightClickedItem = ((LPNMITEMACTIVATE)lParam)->iItem;
                if( iRightClickedItem != -1)
                {
                    POINT pointClick = ((LPNMITEMACTIVATE)lParam)->ptAction;
                    RECT rc;
                    if( 0 != GetWindowRect( GetDlgItem( hDlg, IDC_SITE_LIST), &rc))
                    {
                        pointClick.x += rc.left;
                        pointClick.y += rc.top;
                    }
                    else
                    {  
                        //  Strange error case.. but its alright since we can place the context menu
                        //as if the context-menu button was clicked, instead of the mouse
                        pointClick.x = -1;
                        pointClick.y = -1;
                    }
                    PrivacyDlgContextMenuHandler( hDlg, GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                  iRightClickedItem,
                                                  pointClick.x, pointClick.y);
                }
            }
            else if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                     && LVN_ITEMCHANGED == ((LPNMHDR)lParam)->code)
            {
                if( ((LPNMLISTVIEW)lParam)->uChanged & LVIF_STATE)
                {
                    //  For some unknown reason the selection mark does not move with
                    //the selected item..  We have to update it.
                    if( ((LPNMLISTVIEW)lParam)->uNewState & LVIS_SELECTED)
                    {
                         ListView_SetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                    ((LPNMLISTVIEW)lParam)->iItem);
                    }
                    else
                    {
                         ListView_SetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                    -1);
                    }

                    //  Now that the selection mark is in sync, the UI can update
                    //related items
                    PostMessage( hDlg, WM_APP, IDC_SITE_LIST, 0);
                }
            }
            break;
    }
    return FALSE;
}


//
// Exported entry point to show privacy dialog
//
SHDOCAPI
DoPrivacyDlg(
    HWND                hwndParent,             // parent window
    LPOLESTR            pszUrl,                 // base URL
    IEnumPrivacyRecords *pPrivacyEnum,          // enum of all affected dependant URLs
    BOOL                fReportAllSites         // show all or just show bad
    )
{
    HINSTANCE hRichEditDll;
    
    SPrivacyDialogData p;     // data to send to dialogbox

    if(NULL == pszUrl || NULL == pPrivacyEnum)
    {
        return E_INVALIDARG;
    }

    // We need to load richedit
    hRichEditDll = LoadLibrary(TEXT("RICHED20.DLL"));
    if (!hRichEditDll)
    {
        ASSERT(FALSE); //can't load richedit, complain to akabir
        return E_UNEXPECTED;
    }

    p.pszName = pszUrl;
    p.pEnumPrivacyRecords = pPrivacyEnum;
    p.fReportAllSites = fReportAllSites;

    SHFusionDialogBoxParam(MLGetHinst(),
        MAKEINTRESOURCE(IDD_PRIVACY_DIALOG),
        hwndParent,
        PrivacyDlgProc,
        (LPARAM)&p);

    FreeLibrary( hRichEditDll);

    return S_OK;
}


#define DISPID_URL 10
#define DISPID_COOKIEURL 11
#define DISPID_ARD 12
#define DISPID_ARD_FIXED 13
#define DISPID_POLICYHUNT_DONE 14
#define DISPID_POLICYHUNT_VIEW 15
#define DISPID_CREATEABSOLUTEURL 16

struct SPropertyTable
{
    WCHAR* pName;
    DISPID dispid;
} const g_SPerSiteDataDisptable[] =
{
    L"url",       DISPID_URL,
    L"cookieUrl", DISPID_COOKIEURL,
    L"acceptRejectOrDefault", DISPID_ARD,
    L"fixedAcceptRejectOrDefault", DISPID_ARD_FIXED,
    L"flagPolicyHuntDone", DISPID_POLICYHUNT_DONE,
    L"urlPolicyHuntView", DISPID_POLICYHUNT_VIEW,
    L"CreateAbsoluteUrl", DISPID_CREATEABSOLUTEURL
};

const DWORD g_cSPerSiteDataDisptableSize = ARRAYSIZE( g_SPerSiteDataDisptable);

ULONG SPerSiteData::AddRef( void )
{
    return 1;
}

ULONG SPerSiteData::Release( void )
{
    return 1;
}

HRESULT SPerSiteData::QueryInterface( REFIID iid, void ** ppv)
{
    if( ppv == NULL) return E_POINTER;

    if (IsEqualIID(iid, IID_IUnknown) 
        || IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (void *)this;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}
    
HRESULT SPerSiteData::GetTypeInfoCount( unsigned int FAR*  pctinfo)
{
    if( pctinfo == NULL)
        return E_POINTER;

    *pctinfo = 0;
    return S_OK;
}

HRESULT SPerSiteData::GetTypeInfo( unsigned int  iTInfo,         
                                   LCID  lcid,                   
                                   ITypeInfo FAR* FAR*  ppTInfo)
{
    return E_NOTIMPL;
}

HRESULT SPerSiteData::GetIDsOfNames( REFIID  riid,                  
                                     OLECHAR FAR* FAR*  rgszNames,  
                                     unsigned int  cNames,          
                                     LCID   lcid,                   
                                     DISPID FAR*  rgDispId)
{
    if( !IsEqualIID(riid, IID_NULL) )
        return E_INVALIDARG;

    if( cNames != 1)
        return E_INVALIDARG; // none of the objects we ID have arguments..

    int i;

    for( i = 0; i < g_cSPerSiteDataDisptableSize; i++)
    {
        if( 0 == StrCmp( rgszNames[0], g_SPerSiteDataDisptable[i].pName))
        {
            rgDispId[0] = g_SPerSiteDataDisptable[i].dispid;
            return S_OK;
        }
    }

    rgDispId[0] = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}


HRESULT SPerSiteData::Invoke( DISPID  dispIdMember,      
                              REFIID  riid,              
                              LCID  lcid,                
                              WORD  wFlags,              
                              DISPPARAMS FAR*  pDispParams,  
                              VARIANT FAR*  pVarResult,  
                              EXCEPINFO FAR*  pExcepInfo,  
                              unsigned int FAR*  puArgErr)
{
    HRESULT hr;
    DWORD dw;
    
    if( !IsEqualIID(riid, IID_NULL) )
        return E_INVALIDARG;

    if( pDispParams == NULL 
        || pDispParams->cNamedArgs != 0)
        return DISP_E_BADPARAMCOUNT;
        
    switch( dispIdMember)
    {
    case DISPID_CREATEABSOLUTEURL:
        if( pDispParams->cArgs != 1)
            return DISP_E_BADPARAMCOUNT;
        if( pVarResult == NULL)
            return S_OK;
        break;
    case DISPID_COOKIEURL:
    case DISPID_URL:
    case DISPID_ARD:
    case DISPID_ARD_FIXED:
    case DISPID_POLICYHUNT_DONE:
    case DISPID_POLICYHUNT_VIEW:
        if( pDispParams->cArgs != 0)
            return DISP_E_BADPARAMCOUNT;
        if( !(wFlags & DISPATCH_PROPERTYGET))
            return DISP_E_MEMBERNOTFOUND;
        if( pVarResult == NULL)
            return S_OK;
        break;
    default:
        return DISP_E_MEMBERNOTFOUND;
    }

    pVarResult->vt = VT_BSTR;

    switch( dispIdMember)
    {
    case DISPID_COOKIEURL:
        pVarResult->bstrVal = SysAllocString(bstrCookieDomain);
        return S_OK;
    case DISPID_URL:
        {
            BSTR bstrResult = SysAllocString( bstrUrl);

            if( bstrResult == NULL)
                return ERROR_OUTOFMEMORY;

            //  Cut of query info from end of URL..
            PWCHAR pCursor = bstrResult;
            while( pCursor[0] != L'\0' && pCursor[0] != L'?')
                pCursor++;
            pCursor[0] = L'\0';
                
            pVarResult->bstrVal = bstrResult;
            return S_OK;
        }
    case DISPID_ARD:
        {
            unsigned long ulResult;
            if( InternetGetPerSiteCookieDecision( 
                    bstrCookieDomain, &ulResult)
                == TRUE)
            {
                switch( ulResult)
                {
                case COOKIE_STATE_ACCEPT:
                    pVarResult->bstrVal = SysAllocString( L"a");
                    break;
                case COOKIE_STATE_REJECT:
                    pVarResult->bstrVal = SysAllocString( L"r");
                    break;
                default:
                    pVarResult->bstrVal = SysAllocString( L"d");
                    break;
                }
            }
            else
            {
                pVarResult->bstrVal = SysAllocString( L"d");
            }           
            return S_OK;
        }
    case DISPID_ARD_FIXED:
        {
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = !allowPerSiteModify();
            return S_OK;
        }
    case DISPID_POLICYHUNT_DONE:
        {
            //  try to start the policy hunt..
            if( pPolicyHunt == NULL)
            {
                CPolicyHunt* pNewHunt = new CPolicyHunt();

                if( !pNewHunt
                    || TRUE != pNewHunt->Initialize( this)
                    || TRUE != pNewHunt->Run())
                {
                    goto doneTryToStartPolicyHunt;
                }

                pPolicyHunt = pNewHunt;
                pNewHunt = NULL;
            doneTryToStartPolicyHunt:
                if( pNewHunt != NULL)
                    delete pNewHunt;
            }
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = pPolicyHunt != NULL
                                  && pPolicyHunt->IsFinished();

            return S_OK;
        }
    case DISPID_POLICYHUNT_VIEW:
        {
            pVarResult->vt = VT_BSTR;
            LPWSTR szResultHtm = L"policyerror.htm";

            if( pPolicyHunt == NULL
                || FALSE == pPolicyHunt->IsFinished())
            {
                szResultHtm = L"policylooking.htm";
            }
            else if( TRUE == pPolicyHunt->GetResult( &dw))
            {
                switch( dw)
                {
                case POLICYHUNT_FOUND:
                    pVarResult->bstrVal = SysAllocString( pPolicyHunt->GetResultFilename());
                    return pVarResult->bstrVal ? S_OK : E_UNEXPECTED;
                case POLICYHUNT_NOTFOUND:
                    szResultHtm = L"policynone.htm";
                    break;
                case POLICYHUNT_INPROGRESS:
                    szResultHtm = L"policylooking.htm";
                    break;
                case POLICYHUNT_FORMATERROR:
                    szResultHtm = L"policysyntaxerror.htm";
                    break;
                case POLICYHUNT_ERROR:
                case POLICYHUNT_CANCELLED:
                    szResultHtm = L"policyerror.htm";
                    break;
                }
            }
            else
            {
                szResultHtm = L"policyerror.htm";
            }
            
            WCHAR   szResURL[MAX_URL_STRING];
               
            hr = MLBuildResURLWrap(L"shdoclc.dll",
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               szResultHtm,
                               szResURL,
                               ARRAYSIZE(szResURL),
                               L"shdocvw.dll");

            if( FAILED(hr))
                return E_UNEXPECTED;

            pVarResult->bstrVal = SysAllocString( szResURL);
            return S_OK;
        }
    case DISPID_CREATEABSOLUTEURL:
        {
            WCHAR szBuffer[ MAX_URL_STRING];
            DWORD dwBufferSize = ARRAYSIZE( szBuffer);
            pVarResult->bstrVal = NULL;
            
            if( pDispParams == NULL)
            {
                return E_UNEXPECTED;
            }

            if( pDispParams->rgvarg[0].vt != VT_BSTR
                || pDispParams->rgvarg[0].bstrVal == NULL)
            {
                //  when pVarResult->bstrVal == NULL and we return S_OK,
                //    we are returning an empty string.
                return S_OK;
            }

            HRESULT hr = UrlCombine( pPolicyHunt->GetPolicyUrl(),
                                     pDispParams->rgvarg[0].bstrVal,
                                     szBuffer, &dwBufferSize,
                                     URL_ESCAPE_UNSAFE );

            if( hr != S_OK)
                return E_UNEXPECTED;

            pVarResult->bstrVal = SysAllocString( szBuffer);
            if( pVarResult->bstrVal == NULL)
                return E_UNEXPECTED;
            else
                return S_OK;
                                     
        }
    }
    return S_OK;
}

//
// Privacy record implementation
//
HRESULT CPrivacyRecord::Init( LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, 
                              DWORD dwFlags)
{
    unsigned long     len = 0;
    TCHAR           * pUrl = NULL;

    if (!ppszUrl || !*ppszUrl || !**ppszUrl || !ppszP3PHeader || !ppszPolicyRef )
        return E_POINTER;

    _pszUrl = *ppszUrl;    
    _pszP3PHeader = *ppszP3PHeader;
    _pszPolicyRefUrl = *ppszPolicyRef;

    // The record will own the memory from now for these
    *ppszUrl = NULL;
    *ppszP3PHeader = NULL;
    *ppszPolicyRef = NULL;

    _dwPrivacyFlags = dwFlags;

    return S_OK;
}

CPrivacyRecord::~CPrivacyRecord()
{
    delete [] _pszUrl;
    delete [] _pszPolicyRefUrl;
    delete [] _pszP3PHeader;
}

HRESULT CPrivacyRecord::SetNext( CPrivacyRecord *  pNextRec )
{
    if (!pNextRec)
        return E_POINTER;

    _pNextNode = pNextRec;
    return S_OK;
}

//
// Privacy queue implementation
//
CPrivacyQueue::~CPrivacyQueue()
{
    Reset();
}

void CPrivacyQueue::Reset()
{
    while (_pHeadRec)
    {
        delete Dequeue();
    }
}

void CPrivacyQueue::Queue(CPrivacyRecord *pRecord)
{
    ASSERT(pRecord);

    if (!_ulSize)
    {   
        _pHeadRec = _pTailRec = pRecord;
    }
    else
    {
        ASSERT(_pTailRec);
        _pTailRec->SetNext(pRecord);
        _pTailRec = pRecord;
    }
    _ulSize++;
}

CPrivacyRecord* CPrivacyQueue::Dequeue()
{
    CPrivacyRecord *headRec = NULL;

    if (_ulSize)
    {
        ASSERT(_pHeadRec);
        headRec = _pHeadRec;
        _pHeadRec = headRec->GetNext();
        --_ulSize;
    }

    return headRec;
}

////////////////////////////////////////////////////////////////////////////////////
//
// One time privacy discovery dialog proc
//
////////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK PrivacyDiscoveryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fDontShowNextTime = FALSE;
    WCHAR       szBuffer[256];

    switch (message)
    {
        case WM_INITDIALOG:
            {
                CheckDlgButton( hDlg, IDC_PRIV_DISCOVER_DONTSHOW, BST_CHECKED);
                MLLoadStringW(IDS_PRIVACY_LEARNMOREABOUTCOOKIES, szBuffer, ARRAYSIZE(szBuffer));
                RenderStringToEditControlW(hDlg,
                                           szBuffer,
                                           (WNDPROC)HyperlinkSubclass,
                                           IDC_PRIVACY_HELP);

                if( IsOS(OS_WHISTLERORGREATER))
                {
                    HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                    if( hIcon != NULL)
                        SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                    // icons loaded with LoadIcon never need to be released
                }
            
                return TRUE;
            }
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if(IsDlgButtonChecked(hDlg, IDC_PRIV_DISCOVER_DONTSHOW))
                        fDontShowNextTime = TRUE;
                    else
                        fDontShowNextTime = FALSE;

                    // fall through
                case IDCANCEL:

                    EndDialog(hDlg, fDontShowNextTime);
                    return 0;
                case IDC_SETTINGS:
                    LaunchPrivacySettings(hDlg);
                    return 0;
            }
            break;
        case WM_APP:
            switch( LOWORD( wParam))
            {
                case IDC_PRIVACY_HELP:
                    SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), 
                        HH_DISPLAY_TOPIC, (DWORD_PTR) L"sec_cook.htm", ML_CROSSCODEPAGE);
   
            }
    }

    return FALSE;
}


//  returns boolean indicating if dialog should be shown again.
BOOL DoPrivacyFirstTimeDialog( HWND hwndParent)
{
    HINSTANCE hRichEditDll;
    BOOL returnValue;

    // We need to load richedit
    hRichEditDll = LoadLibrary(TEXT("RICHED20.DLL"));
    if (!hRichEditDll)
    {
        ASSERT(FALSE); //can't load richedit, complain to akabir
        return TRUE;
    }

    returnValue = (BOOL)SHFusionDialogBoxParam(MLGetHinst(),
                                               MAKEINTRESOURCE(IDD_PRIV_DISCOVER),
                                               hwndParent,
                                               PrivacyDiscoveryDlgProc,
                                               NULL);

    FreeLibrary( hRichEditDll);

    return returnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\ratings.cpp ===
#include "priv.h"

#ifdef FEATURE_PICS

#include "asyncrat.h"
#include <ratings.h>
#include "dochost.h"
#include <mshtmdid.h>


/* There is a PicsQuery structure in the following global array for each
 * outstanding query.  It records the address of the PicsData structure in
 * the corresponding w3doc, the window handle corresponding to the Mwin,
 * and a serial number.  This way, RatingObtainQueryCallback can tell if
 * the page the query corresponds to still exists, before posting a message;
 * and PicsDataMessageLoop can tell if the doc still exists when the message
 * finally gets delivered.
 *
 * The array is dynamically allocated and is protected by the main HTML
 * critical section.
 */


HDSA g_haQueries = NULL;
DWORD g_dwPicsSerial = 1L;
const UINT c_cQueryAllocSize = 8;		/* should be plenty by default */
UINT g_crefQueries = 0;


/* AddPicsQuery - add an outstanding PICS query to the list, given a window
 * handle to send a completion message to.  Returns the serial number of the
 * query for later reference.
 */
DWORD _AddPicsQuery(HWND hwnd)
{
    ENTERCRITICAL;
    
    DWORD dwRet = 0;
    
    if (g_haQueries == NULL) {
        g_haQueries = DSA_Create(sizeof(PicsQuery), c_cQueryAllocSize);
    }
    
    if (g_haQueries != NULL) {
        PicsQuery q;
        
        q.dwSerial = ::g_dwPicsSerial++;
        q.hwnd = hwnd;
        q.lpvRatingDetails = NULL;
        
        if (DSA_InsertItem(g_haQueries, DA_LAST, &q) >= 0)
            dwRet = q.dwSerial;
    }
    
    LEAVECRITICAL;
    
    return dwRet;
}


/* RemovePicsQuery - remove an outstanding query based on its serial number.
*/
void _RemovePicsQuery(DWORD dwSerial)
{
    ENTERCRITICAL;
    
    if (g_haQueries != NULL) {
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        PicsQuery *pq = NULL;
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            if (pq->lpvRatingDetails != NULL)
                ::RatingFreeDetails(pq->lpvRatingDetails);
            DSA_DeleteItem(g_haQueries, i);
        }
    }
    
    LEAVECRITICAL;
}


/* GetPicsQuery - get a copy of an outstanding PICS query record, given its
 * serial number.  Returns TRUE if found.
 */
BOOL _GetPicsQuery(DWORD dwSerial, PicsQuery *pOut)
{
    ENTERCRITICAL;
    
    PicsQuery *pq = NULL;
    
    if (g_haQueries != NULL) {
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            *pOut = *pq;
            pq->lpvRatingDetails = NULL;	/* caller's copy owns this now */
        }
    }
    
    LEAVECRITICAL;
    
    return pq != NULL;
}


/* _RefPicsQueries - add a reference to the async query array */
void _RefPicsQueries(void)
{
    ENTERCRITICAL;

    ++g_crefQueries;

    LEAVECRITICAL;
}


/* _ReleasePicsQueries - cleanup all memory associated with outstanding queries
 */
void _ReleasePicsQueries(void)
{
    ENTERCRITICAL;
    
    if (!--g_crefQueries) {
        if (g_haQueries != NULL) {
            UINT cQueries = DSA_GetItemCount(g_haQueries);
            for (UINT i=0; i<cQueries; i++) {
                PicsQuery *pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
                if (pq != NULL && pq->lpvRatingDetails != NULL) {
                    RatingFreeDetails(pq->lpvRatingDetails);
                }
            }
            DSA_Destroy(g_haQueries);
            g_haQueries = NULL;
            // leave g_dwPicsSerial as it is, just in case we start up again
        }
    }
    
    LEAVECRITICAL;
}


/* PostPicsMessage - formats up a custom window message to signal that a
 * query is complete.  Format is WM_PICS_STATUS(hresult,dwSerial).  Other
 * information (the rating details blob obtained from RatingCheckUserAccess)
 * is stored in the query record for safekeeping.
 *
 * Returns TRUE if a message was posted successfully to the right window.
 */
BOOL _PostPicsMessage(DWORD dwSerial, HRESULT hr, LPVOID lpvRatingDetails)
{
    BOOL fRet = FALSE;
    
    ENTERCRITICAL;
    
    if (g_haQueries != NULL) {
        PicsQuery *pq = NULL;
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            pq->lpvRatingDetails = lpvRatingDetails;
            fRet = PostMessage(pq->hwnd, WM_PICS_ASYNCCOMPLETE, (WPARAM)hr,
                (LPARAM)dwSerial);
            if (!fRet) {	/* oops, couldn't post message, don't keep copy of details */
                pq->lpvRatingDetails = NULL;
            }
        }
    }
    
    LEAVECRITICAL;
    
    return fRet;
}


/* Class CPicsRootDownload manages the download of the root document of a
 * site, to get ratings from it.
 */

CPicsRootDownload::CPicsRootDownload(IOleCommandTarget *pctParent, BOOL fFrameIsOffline, BOOL fFrameIsSilent)
{
    m_cRef = 1;
    m_pctParent = pctParent; m_pctParent->AddRef();
    m_pole = NULL;
    m_pctObject = NULL;
    m_pBinding = NULL;
    m_fFrameIsOffline = fFrameIsOffline ? TRUE : FALSE;
    m_fFrameIsSilent = fFrameIsSilent ? TRUE : FALSE;
}


CPicsRootDownload::~CPicsRootDownload()
{
    ATOMICRELEASE(m_pctParent);

    CleanUp();

    ATOMICRELEASE(m_pBinding);

    ATOMICRELEASE(m_pBindCtx);
}


HRESULT CPicsRootDownload::StartDownload(IMoniker *pmk)
{
    IUnknown *punk = NULL;
    HRESULT hr;

    hr = CreateBindCtx(0, &m_pBindCtx);
    if (FAILED(hr))
        goto LErrExit;

    /*
    hr = m_pBindCtx->RegisterObjectParam(BROWSER_OPTIONS_OBJECT_NAME,
                    (IBrowseControl *)this);
    if (FAILED(hr))
        goto LErrExit;
    */

    //
    //  Associate the client site as an object parameter to this
    // bind context so that Trident can pick it up while processing
    // IPersistMoniker::Load().
    //
    m_pBindCtx->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite,
                                    SAFECAST(this, IOleClientSite*));

    hr = RegisterBindStatusCallback(m_pBindCtx,
            (IBindStatusCallback *)this,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    hr = pmk->BindToObject(m_pBindCtx, NULL, IID_IUnknown, (LPVOID*)&punk);

    if (SUCCEEDED(hr) || hr==E_PENDING)
    {
        hr = S_OK;

        //
        // If moniker happen to return the object synchronously, emulate
        // OnDataAvailable callback and OnStopBinding.
        //
        if (punk)
        {
            OnObjectAvailable(IID_IUnknown, punk);
            OnStopBinding(hr, NULL);
            punk->Release();
        }
    }
    else
    {
        /* OnStopBinding can be called by URLMON within the BindToObject
         * call in some cases.  So, don't call it ourselves if it's
         * already been called (we can tell by looking whether our
         * bind context still exists).
         */
        if (m_pBindCtx != NULL) {
            OnStopBinding(hr, NULL);
        }
    }

LErrExit:
    if (FAILED(hr) && (m_pBindCtx != NULL)) {
        m_pBindCtx->Release();
        m_pBindCtx = NULL;
    }

    return hr;
}


/* _NotifyEndOfDocument is used in all the error cases to make sure the caller
 * gets a notification of some sort.  The case where this function does not
 * send a notification is if we have a valid OLE object -- in that case, we're
 * assuming that we have it because we know it supports PICS, therefore we're
 * expecting it to send such a notification to the parent itself.
 */
void CPicsRootDownload::_NotifyEndOfDocument(void)
{
    if (m_pole == NULL) {
        if (m_pctParent != NULL) {
            m_pctParent->Exec(&CGID_ShellDocView, SHDVID_NOMOREPICSLABELS, 0, NULL, NULL);
        }
    }
}


HRESULT CPicsRootDownload::_Abort()
{
    if (m_pBinding)
    {
        return m_pBinding->Abort();
    }
    return S_FALSE;
}


void CPicsRootDownload::CleanUp()
{
    _Abort();

    if (m_pctObject != NULL) {
        VARIANTARG v;
        v.vt = VT_UNKNOWN;
        v.punkVal = NULL;
        m_pctObject->Exec(&CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        m_pctObject->Exec(NULL, OLECMDID_STOP, NULL, NULL, NULL);
        ATOMICRELEASE(m_pctObject);
    }

    LPOLECLIENTSITE pcs;
    if (m_pole && SUCCEEDED(m_pole->GetClientSite(&pcs)) && pcs) 
    {
        if (pcs == SAFECAST(this, LPOLECLIENTSITE)) 
        {
            m_pole->SetClientSite(NULL);
        }
        pcs->Release();
    }

    ATOMICRELEASE(m_pole);
}


// IUnknown members
STDMETHODIMP CPicsRootDownload::QueryInterface(REFIID riid, void **punk)
{
    *punk = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IsPicsBrowser))
        *punk = (IUnknown *)(IBindStatusCallback *)this;
    else if (IsEqualIID(riid, IID_IBindStatusCallback))
        *punk = (IBindStatusCallback *)this;
    else if (IsEqualIID(riid, IID_IOleClientSite))
        *punk = (IOleClientSite *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *punk = (IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *punk = (IDispatch *)this;

    if (*punk != NULL) {
        ((IUnknown *)(*punk))->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CPicsRootDownload::AddRef(void)
{
    ++m_cRef;
    TraceMsg(TF_SHDREF, "CPicsRootDownload(%x)::AddRef called, new m_cRef=%d", this, m_cRef);
    return m_cRef;
}


STDMETHODIMP_(ULONG) CPicsRootDownload::Release(void)
{
    UINT crefNew = --m_cRef;

    TraceMsg(TF_SHDREF, "CPicsRootDownload(%x)::Release called, new m_cRef=%d", this, m_cRef);

    if (!crefNew)
        delete this;

    return crefNew;
}

// IBindStatusCallback methods
STDMETHODIMP CPicsRootDownload::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pbinding;

    if (m_pBinding != NULL)
        m_pBinding->AddRef();

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPicsRootDownload::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                           ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
    /* If the root document's data type is not HTML, don't try to get any
     * ratings out of it, just abort.
     */
    if (ulStatusCode == BINDSTATUS_CLASSIDAVAILABLE) {
        BOOL fContinueDownload = FALSE;

        CLSID clsid;
        // CLSIDFromString is prototyped wrong, non const first param
        HRESULT hresT = CLSIDFromString((WCHAR *)pwzStatusText, &clsid);
        if (SUCCEEDED(hresT)) {
            LPWSTR pwzProgID = NULL;
            hresT = ProgIDFromCLSID(clsid, &pwzProgID);
            if (SUCCEEDED(hresT)) {
                if (StrCmp(pwzProgID, L"htmlfile") == 0)
                {
                    fContinueDownload = TRUE;
                }
                OleFree(pwzProgID);
            }
        }

        if (!fContinueDownload) {
            _Abort();
        }
    }

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
    /* Some of the cleanup we do in here (RevokeObjectParam is suspect?) could
     * remove our last reference, causing the Releases at the end to fault.
     * Guard against this with an AddRef/Release.  Dochost does this too.
     *
     * WARNING - if URLMON is calling back through this object, shouldn't he
     * have a reference to us?  If so, where is it?
     */
    AddRef();

    /* Notify the caller that we've got to the end of the document */
    _NotifyEndOfDocument();
    m_pBindCtx->RevokeObjectParam(WSZGUID_OPID_DocObjClientSite);
    ::RevokeBindStatusCallback(m_pBindCtx, (IBindStatusCallback *)this);
    ATOMICRELEASE(m_pBinding);
    ATOMICRELEASE(m_pBindCtx);

    /* Undo above AddRef(). */
    Release();

    return S_OK;
}

void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *pgrfBindf);

STDMETHODIMP CPicsRootDownload::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    if ( !pgrfBINDF || !pbindInfo || !pbindInfo->cbSize )
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE;
    *pgrfBINDF |= BINDF_GETNEWESTVERSION;

    if(m_fFrameIsSilent)
    {
        *pgrfBINDF |= BINDF_NO_UI;  
    }
    else
    {
        *pgrfBINDF &= ~BINDF_NO_UI;
    }

    SetBindfFlagsBasedOnAmbient(BOOLIFY(m_fFrameIsOffline), pgrfBINDF);
    
    // clear BINDINFO except cbSize
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    pbindInfo->dwBindVerb = BINDVERB_GET;

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                                FORMATETC *pfmtetc,
                                                STGMEDIUM* pstgmed)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    if (SUCCEEDED(punk->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pctObject))) {
        VARIANTARG v;
        v.vt = VT_UNKNOWN;
        v.punkVal = (IOleCommandTarget *)m_pctParent;
        HRESULT hresT = m_pctObject->Exec(&CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        if (hresT == S_OK) {
            hresT = punk->QueryInterface(IID_IOleObject, (LPVOID *)&m_pole);
            if (FAILED(hresT))
                m_pole = NULL;
        }
    }

    if (m_pole == NULL) {
        ATOMICRELEASE(m_pctObject);
        _Abort();
    }

    return S_OK;
}


// IOleClientSite
STDMETHODIMP CPicsRootDownload::SaveObject(void)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::GetMoniker(DWORD, DWORD, IMoniker **)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::GetContainer(IOleContainer **)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::ShowObject(void)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}


// IServiceProvider (must be QI'able from IOleClientSite)
STDMETHODIMP CPicsRootDownload::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_STopLevelBrowser)) {
        if (IsEqualIID(riid, IID_IsPicsBrowser))
            return QueryInterface(riid, ppvObj);
        return E_NOINTERFACE;
    }

    return E_FAIL;
}


// IDispatch
HRESULT CPicsRootDownload::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    if (!pVarResult)
        return E_INVALIDARG;

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            // We support IDispatch so that Trident can ask us to control the
            // download.  By specifying all the following flags, and by NOT
            // specifying DLCTL_DLIMAGES, DLCTL_VIDEOS, or DLCTL_BGSOUNDS,
            // we ensure we only download the HTML doc itself, and not a lot
            // of associated things that aren't going to help us find a META
            // tag.

            pVarResult->vt = VT_I4;
            pVarResult->lVal = DLCTL_SILENT | DLCTL_NO_SCRIPTS | 
                               DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS |
                               DLCTL_NO_DLACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD |
                               DLCTL_NO_CLIENTPULL;
            break;
        default:
            return DISP_E_MEMBERNOTFOUND;
        }
        return S_OK;
    }

    return DISP_E_MEMBERNOTFOUND;
}


#endif  /* FEATURE_PICS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\reload.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       reload.cpp ( based on WebCheck's downld.cxx )
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------

#include "priv.h"

//#include "headers.hxx"
#include "reload.h"

#include <exdisp.h>
#include <exdispid.h>
#include <htiface.h>
#include <mshtmdid.h>
#include <mshtmcid.h>
#include <mshtmhst.h>
#include <optary.h>                 // needed for IHtmlLoadOptions
#include <wininet.h>
#include <winineti.h>
#include <shlguid.h>
#include <shlobj.h>
#include "intshcut.h"               // IUniformResourceLocator

#undef DEFINE_STRING_CONSTANTS
#pragma warning( disable : 4207 ) 
#include "htmlstr.h"
#pragma warning( default : 4207 )

// Disable perf warning for typecasts to the native bool type
// Useful for NT64 where pointers cannot be cast to "BOOL"
#pragma warning( disable : 4800 )

//MtDefine(CUrlDownload, Utilities, "CUrlDownload")

#define TF_THISMODULE   TF_DOWNLD

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);


CLIPFORMAT g_cfHTML=CF_NULL;

// User-Agent strings
const WCHAR c_szUserAgent95[] = L"Mozilla/4.0 (compatible; MSIE 4.01; MSIECrawler; Windows 95)";
const WCHAR c_szUserAgentNT[] = L"Mozilla/4.0 (compatible; MSIE 4.01; MSIECrawler; Windows NT)";

// Refresh header for http-equiv (client-pull)
const WCHAR c_wszRefresh[] = L"Refresh";

const int  MAX_CLIENT_PULL_NUM = 4;     // max # redirections
const int  MAX_CLIENT_PULL_TIMEOUT = 6; // max timeout we'll follow

// Function also present in shdocvw\basesb.cpp and in mshtml
BOOL DLParseRefreshContent(LPWSTR pwzContent, UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

const WCHAR c_wszHeadVerb[] = L"HEAD";

const WCHAR c_szUserAgentPrefix[] = L"User-Agent: ";
const WCHAR c_szAcceptLanguagePrefix[] = L"Accept-Language: ";

#define WM_URLDL_CLEAN      (WM_USER + 0x1010)
#define WM_URLDL_ONDLCOMPLETE (WM_USER + 0x1012)
#define WM_URLDL_CLIENTPULL (WM_USER+0x1013)

#define PROP_CODEPAGE       3

const PROPSPEC c_rgPropRead[] = {
    { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION},
    { PRSPEC_PROPID, PID_INTSITE_FLAGS},
    { PRSPEC_PROPID, PID_INTSITE_TRACKING},
    { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
};

//---------------------------------------------------------------
// CUrlDownload class
CUrlDownload::CUrlDownload( CThicketProgress* ptp, HRESULT *phr, UINT cpDL )
{
    // Maintain global count of objects
    //DllAddRef();

    m_ptp = ptp;
    m_phr = phr;
    m_cpDL = cpDL;
    m_dwProgMax = 0;

    m_cRef = 1;
    
    m_pDocument = NULL;
    m_dwConnectionCookie = 0;
    m_pwszURL = NULL;
    m_pScript = NULL;
    m_fAdviseOn = FALSE;
    m_pCP = NULL;
    m_pDocument = NULL;
    m_pPersistMk = NULL;
    m_pOleCmdTarget = NULL;
    m_pwszClientPullURL = NULL;
    m_fWaitingForReadyState = FALSE;
    m_fFormSubmitted = FALSE;
    m_fBrowserValid = FALSE;
    m_hwndMe = NULL;

    // find the HTML clipboard format
    if (!g_cfHTML)
    {
        g_cfHTML = RegisterClipboardFormat(CFSTR_MIME_HTML);
    }

    // find out if we need to set the "RESYNCHRONIZE" flag
    INTERNET_CACHE_CONFIG_INFOA CacheConfigInfo;
    DWORD dwBufSize = sizeof(CacheConfigInfo);

    if (GetUrlCacheConfigInfoA(&CacheConfigInfo, &dwBufSize, CACHE_CONFIG_SYNC_MODE_FC))
    {
        if ((WININET_SYNC_MODE_ONCE_PER_SESSION == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_NEVER == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_AUTOMATIC == CacheConfigInfo.dwSyncMode))
        {
            m_fSetResync = FALSE;
        }
        else
        {
            m_fSetResync = TRUE;
        }
    }
    else
        ASSERT(FALSE);

    m_lBindFlags = DLCTL_SILENT | DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD | 
        DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    // register our window class if necessary
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = UrlDownloadWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hinst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH)NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = URLDL_WNDCLASS;

    SHRegisterClass(&wc);

}

CUrlDownload::~CUrlDownload()
{
    // Maintain global count of objects
    //DllRelease();

    CleanUp();
}

void CUrlDownload::CleanUpBrowser()
{
    SAFERELEASE(m_pScript);

    if (m_fAdviseOn)
    {
        UnAdviseMe();
    }
    SAFERELEASE(m_pCP);
    SAFERELEASE(m_pDocument);
    SAFERELEASE(m_pPersistMk);
    SAFERELEASE(m_pOleCmdTarget);
    SAFELOCALFREE(m_pwszClientPullURL);
}

void CUrlDownload::CleanUp()
{
    CleanUpBrowser();
    SAFELOCALFREE(m_pwszURL);

    if (m_hwndMe)
    {
        SetWindowLongPtr(m_hwndMe, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndMe);
        m_hwndMe = NULL;
    }
}

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CUrlDownload *pThis = (CUrlDownload *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis)
    {
        ASSERT(FALSE);
    }
#endif

    switch (Msg)
    {
    case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_URLDL_CLIENTPULL :
    case WM_URLDL_ONDLCOMPLETE :
        if (pThis)
            pThis->HandleMessage(hWnd, Msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hWnd, Msg, wParam, lParam);
    }
    return 0;
}

HRESULT CUrlDownload::CreateMyWindow()
{
    // Create our callback window
    if (NULL == m_hwndMe)
    {
//      TraceMsg(TF_THISMODULE, "Creating MeWnd, this=0x%08x", (DWORD)this);
        m_hwndMe = CreateWindow(URLDL_WNDCLASS, TEXT("CUrlDownloadWnd"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hinst, (LPVOID)this);

        if (NULL == m_hwndMe)
        {
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT CUrlDownload::BeginDownloadURL2(
    LPCWSTR     pwszURL,        // URL
    BDUMethod   iMethod,        // download method
    BDUOptions  iOptions,       // download options
    LPTSTR      pszLocalFile,   // Local file to download to instead of cache
    DWORD       dwMaxSize       // Max size in bytes; will abort if exceeded
)
{
    HRESULT hr = S_OK;

    // Param validation
    ASSERT(pwszURL);
    ASSERT(!(iOptions & BDU2_NEEDSTREAM));
    ASSERT(!pszLocalFile);

    if (pszLocalFile)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CreateMyWindow();

        // Clean up some old stuff
        SAFERELEASE(m_pScript);

        m_fBrowserValid = FALSE;

        m_iMethod = iMethod;
        m_iOptions = iOptions;

        m_dwMaxSize = dwMaxSize;

        SAFELOCALFREE(m_pwszClientPullURL);
        m_iNumClientPull = 0;

        // Save URL
        SAFELOCALFREE(m_pwszURL);
        m_pwszURL = StrDupW(pwszURL);

        // Determine how to download this URL
        hr = BeginDownloadWithBrowser(pwszURL);
    }

    if (FAILED(hr))
    {
        OnDownloadComplete(BDU2_ERROR_GENERAL);
    }

    return (hr);
}

//
// Looks up the Url in the url history object and if its not CP_ACP
// inserts an IHTMLLoadOptions object that contains the codepage
// into the bind context
//


HRESULT InsertCodepageIntoBindCtx(UINT codepage, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    if (pbc == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (codepage != CP_ACP)
        {
            DWORD dwcp = codepage;
            //
            // We got a codepage that wasn't the ansi one create an
            // HTMLLoadOptions object and set the code page in it.
            //
            IHtmlLoadOptions *phlo = NULL;
            hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, 
                CLSCTX_INPROC_SERVER, IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hr) && phlo)
            {
                hr = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &dwcp,
                    sizeof(dwcp));

                if (SUCCEEDED(hr))
                {
                    //
                    // Insert the option into the bindctx
                    //
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                }
                phlo->Release();
            }
        }
    }
    return hr; // no return  - may return S_FALSE
}

HRESULT CUrlDownload::BeginDownloadWithBrowser(LPCWSTR pwszURL)
{
    HRESULT hr;

    // Get browser and hook up sink
    // (no-op if we're already set up)
    hr = GetBrowser();

    if (SUCCEEDED(hr))
    {
        // browse to the required URL
        LPMONIKER           pURLMoniker = NULL;
        IBindCtx           *pbc = NULL;

        // create a URL moniker from the canonicalized path
        hr=CreateURLMoniker(NULL, pwszURL, &pURLMoniker);

        // create an empty bind context so that Urlmon will call Trident's
        //  QueryService on the proper thread so that Trident can delegate
        //  it to use properly.
        hr=CreateBindCtx(0, &pbc);

        if (SUCCEEDED(hr))
        {
            //
            // Looks up the Url in the url history object and if its not CP_ACP
            // inserts an IHTMLLoadOptions object that contains the codepage
            // into the bind context. This is done so that TRIDENT is seeded
            // with the correct codepage.
            //
            InsertCodepageIntoBindCtx(m_cpDL, pbc);

            hr = m_pPersistMk->Load(FALSE, pURLMoniker, pbc, 0);
            if (SUCCEEDED(hr)) m_fWaitingForReadyState = TRUE;
        }

        // clean up junk
        if (pURLMoniker)
            pURLMoniker->Release();

        if (pbc)
            pbc->Release();

        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
        }
        else
        {
            CleanUpBrowser();
        }
    }

    return (hr);
}

HRESULT CUrlDownload::OnDownloadComplete(int iError)
{
    PostMessage(m_hwndMe, WM_URLDL_ONDLCOMPLETE, (WPARAM)iError, 0);
    return S_OK;
}

BOOL CUrlDownload::HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_URLDL_CLIENTPULL :
        {
            HRESULT hr = S_OK;

            // Ask our parent if we should do this
            if (m_pwszClientPullURL)
            {
                if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
                    hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                // Download this new url. Don't give "downloadcomplete" for first one
                // Save member vars since they get reset in BDU2
                int iNumClientPull = m_iNumClientPull;
                LPWSTR pszNewURL = m_pwszClientPullURL;

                m_pwszClientPullURL = NULL;
                hr = BeginDownloadURL2(pszNewURL, m_iMethod, m_iOptions, NULL, m_dwMaxSize);
                SAFELOCALFREE(pszNewURL);
                if (SUCCEEDED(hr))
                {
                    m_iNumClientPull = iNumClientPull + 1;
                }
            }
        }
        break;

    case WM_URLDL_ONDLCOMPLETE :
        ASSERT(m_phr);
        *m_phr = S_OK;
        return TRUE;

    default:
        break;

    }
    return TRUE;
}

HRESULT CUrlDownload::AbortDownload(int iErrorCode /* =-1 */)
{
    HRESULT hr=S_FALSE;
    BOOL    fAborted=FALSE;

    if (m_fBrowserValid)
    {
        ASSERT(m_pOleCmdTarget);
        if (m_pOleCmdTarget)
        {
            m_pOleCmdTarget->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
        }

        SAFELOCALFREE(m_pwszClientPullURL);

        fAborted=TRUE;
        m_fBrowserValid = FALSE;
    }

    return hr; // no return  - may return S_FALSE
}

// Loads browser, creates sink and hooks it up to DIID_DWebBrowserEvents
HRESULT CUrlDownload::GetBrowser()
{
    HRESULT hr = S_OK;

    if (m_fAdviseOn)
        return (hr);

    if (NULL == m_pDocument)
    {
        ASSERT(!m_pPersistMk);
        ASSERT(!m_pCP);

        hr = CoCreateInstance(CLSID_HTMLDocument, NULL,
                    CLSCTX_INPROC, IID_IHTMLDocument2, (void **)&m_pDocument);

        if (SUCCEEDED(hr)) // setting design mode faults Trident && SUCCEEDED(hr = m_pDocument->put_designMode( (BSTR)c_bstr_ON )))
        {
            IOleObject *pOleObj;

            hr = m_pDocument->QueryInterface(IID_IOleObject, (void **)&pOleObj);
            if (SUCCEEDED(hr))
            {
                pOleObj->SetClientSite((IOleClientSite *)this);
                pOleObj->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IPersistMoniker, (void**)&m_pPersistMk);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IOleCommandTarget, (void**)&m_pOleCmdTarget);
        }

        ASSERT(SUCCEEDED(hr));
    }

    // At this point we have m_pDocument and m_pPersistMk

    // Find our connection point if necessary
    if (NULL == m_pCP && SUCCEEDED(hr))
    {
        IConnectionPointContainer *pCPCont=NULL;
        hr = m_pDocument->QueryInterface(IID_IConnectionPointContainer,
                (void **)&pCPCont);

        if (SUCCEEDED(hr))
        {
            hr = pCPCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP);
            pCPCont->Release();
            pCPCont = NULL;
        }
    }

    // And hook it up to us
    if (SUCCEEDED(hr))
    {
        // create sink
        IPropertyNotifySink *pSink = (IPropertyNotifySink *)this;

        hr = m_pCP->Advise(pSink, &m_dwConnectionCookie);
        if (SUCCEEDED(hr))
        {
            m_fAdviseOn = TRUE;
        }
    }

    return (hr);
}

void CUrlDownload::UnAdviseMe()
{
    if (m_fAdviseOn)
    {
        m_pCP->Unadvise(m_dwConnectionCookie);
        m_fAdviseOn = FALSE;
    }
}

void CUrlDownload::DoneDownloading()
{
    // Don't send any more messages to the parent

    AbortDownload();

    CleanUp();
}

// Returns TRUE if this appears to be an HTML URL
HRESULT CUrlDownload::GetDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr;

    if (!m_fBrowserValid)
    {
        *ppDoc = NULL;
        return (E_FAIL);
    }

    *ppDoc = m_pDocument;
    if (m_pDocument)
    {
        m_pDocument->AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return (hr);
}

    


//
// IUnknown of CUrlDownload
//
STDMETHODIMP CUrlDownload::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv=NULL;

    // Validate requested interface
    if (IID_IOleClientSite == riid)
        *ppv=(IOleClientSite *)this;
    else if (IID_IPropertyNotifySink == riid)
        *ppv=(IPropertyNotifySink *)this;
    else if (IID_IOleCommandTarget == riid)
        *ppv=(IOleCommandTarget *)this;
    else if (IID_IDispatch == riid)
        *ppv=(IDispatch *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_IAuthenticate == riid)
        *ppv = (IAuthenticate *)this;
    else if (IID_IInternetSecurityManager == riid)
        *ppv = (IInternetSecurityManager *)this;
    else if ((IID_IUnknown == riid) ||
             (IID_IHlinkFrame == riid))
        *ppv = (IHlinkFrame *)this;
    else
    {
        // DBGIID("CUrlDownload::QueryInterface() failing", riid);
    }

    // Addref through the interface
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CUrlDownload::AddRef(void)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload addref to %d", m_cRef+1);
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUrlDownload::Release(void)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload release - %d", m_cRef-1);
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CUrlDownload::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::Invoke(DISPID dispidMember, 
                                  REFIID riid, 
                                  LCID lcid, 
                                  WORD wFlags,
                                  DISPPARAMS *pdispparams, 
                                  VARIANT *pvarResult,
                                  EXCEPINFO *pexcepinfo, 
                                  UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(V_VT(pvarResult)== VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            //TraceMsg(TF_THISMODULE, "Returning DLCONTROL ambient property 0x%08x", m_lBindFlags);
            pvarResult->vt = VT_I4;
            pvarResult->lVal = m_lBindFlags;
            break;

        case DISPID_AMBIENT_USERAGENT:
            CHAR    szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
            DWORD   dwSize;

            dwSize = MAX_PATH;
            szUserAgent[0] = '\0';

            pvarResult->vt = VT_BSTR;

            if ( ObtainUserAgentString( 0, szUserAgent, &dwSize ) == S_OK )
            {
                UINT cch = lstrlenA( szUserAgent );

                // Allocates size + 1
                pvarResult->bstrVal = SysAllocStringLen( 0, cch );
                if( pvarResult->bstrVal )
                {
                    if( !MultiByteToWideChar( CP_ACP, 0, szUserAgent, -1, pvarResult->bstrVal, cch + 1 ) )
                    {
                        SysFreeString( pvarResult->bstrVal );
                        pvarResult->bstrVal = 0;
                    }
                }
            }
            break;

        case DISPID_AMBIENT_USERMODE:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = VARIANT_FALSE; // put it in design mode
            break;

        default:
            return DISP_E_MEMBERNOTFOUND;
        }
        return S_OK;
    }

    return DISP_E_MEMBERNOTFOUND;
}

// IPropertyNotifySink

STDMETHODIMP CUrlDownload::OnChanged(DISPID dispID)
{
    if ((DISPID_READYSTATE == dispID) ||
        (DISPID_UNKNOWN == dispID))
    {
        // Find out if we're done
        if (m_fWaitingForReadyState)
        {
            VARIANT     varState;
            DISPPARAMS  dp;

            VariantInit(&varState);

            if (SUCCEEDED(m_pDocument->Invoke(DISPID_READYSTATE, 
                                              IID_NULL, 
                                              GetUserDefaultLCID(), 
                                              DISPATCH_PROPERTYGET, 
                                              &dp, 
                                              &varState, NULL, NULL)) &&
                V_VT(&varState)==VT_I4 && 
                V_I4(&varState)== READYSTATE_COMPLETE)
            {
                m_fWaitingForReadyState = FALSE;
                // Successful download. See if a client-pull is waiting.
                if (m_pwszClientPullURL)
                    PostMessage(m_hwndMe, WM_URLDL_CLIENTPULL, 0, 0);
                else
                    OnDownloadComplete(BDU2_ERROR_NONE);
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

// IOleCommandTarget
STDMETHODIMP CUrlDownload::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CUrlDownload::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {
        case OLECMDID_SETPROGRESSPOS:
        {
            hres = S_OK;
            VARIANT     varBytes;
            
            if (m_pOleCmdTarget)
            {
                varBytes.vt=VT_EMPTY;
                m_pOleCmdTarget->Exec(&CGID_MSHTML, IDM_GETBYTESDOWNLOADED, 0, NULL, &varBytes);

                if (varBytes.vt == VT_I4)
                {
                    DWORD dwBytes = (DWORD) varBytes.lVal;

                    //TraceMsg(TF_THISMODULE, "%d bytes on page so far (mshtml)", dwBytes);

                    ProgressBytes(dwBytes);

                    // for this mutant version, we also want to keep mom and dad up to date.
                    LONG lPos;

                    // we use 0..50 so that the progress meter won't max out
                    // when only the download phase is finished and we still have
                    // packaging work to do.
                    if (pvarargIn && m_dwProgMax)
                        lPos = (pvarargIn->lVal * 25) / m_dwProgMax;
                    else
                        lPos = 0;

                    if (m_ptp)
                        m_ptp->SetPercent( lPos );
                    hres = S_OK;
                }
            }
        }
            break;

        case OLECMDID_SETPROGRESSMAX:
        {
            if (pvarargIn && pvarargIn->vt == VT_I4)
                m_dwProgMax = pvarargIn->lVal;
            hres = S_OK;
        }
            break;

        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull)
        //
        case OLECMDID_HTTPEQUIV_DONE:
            hres = S_OK;
            break;

        case OLECMDID_HTTPEQUIV:
            {
                LPWSTR  pwszEquivString = pvarargIn? pvarargIn->bstrVal : NULL;
                BOOL    fHasHeader = (bool) pwszEquivString;

                if (pvarargIn && pvarargIn->vt != VT_BSTR)
                    return OLECMDERR_E_NOTSUPPORTED;

                if (!fHasHeader || StrCmpNIW(c_wszRefresh, pwszEquivString, lstrlenW(c_wszRefresh)) == 0)
                {
                    // Hit.  Now do the right thing for this header
                    // We pass both the header and a pointer to the first char after
                    // ':', which is usually the delimiter handlers will look for.

                    LPWSTR pwszColon = fHasHeader ? StrChrW(pwszEquivString, ':') : NULL;
      
                    // Enforce the : at the end of the header
                    if (fHasHeader && !pwszColon)
                    {
                        return OLECMDERR_E_NOTSUPPORTED;
                    }
             
                    hres = HandleRefresh(pwszEquivString, pwszColon ? pwszColon+1:NULL,
                                         (nCmdID == OLECMDID_HTTPEQUIV_DONE));
                }
            }

            // if we return OLECMDERR_E_NOTSUPPORTED, we don't handle
            // client pull
            break;
        }
    }

    return hres;
}

// The basic operation was lifted from shdocvw\basesb.cpp
HRESULT CUrlDownload::HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone)
{
    unsigned int uiTimeout = 0;
    WCHAR        awch[INTERNET_MAX_URL_LENGTH];

    if (fDone)
    {
        return S_OK;    // fDone means we don't process this
    }

    // NSCompat: we only honor the first successfully parsed Refresh
    if (m_pwszClientPullURL)
        return S_OK;

    if (!pwszContent ||
        !DLParseRefreshContent(pwszContent, &uiTimeout, awch, INTERNET_MAX_URL_LENGTH))
    {
        return OLECMDERR_E_NOTSUPPORTED;   // cannot handle refresh w/o timeout
    }
    
    if (!awch[0])
    {
        return S_OK;
    }

    if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
    {
        return S_OK;
    }

    //TraceMsg(TF_THISMODULE, "CUrlDownload client pull (refresh=%d) url=%ws", uiTimeout, awch);
    if (uiTimeout > MAX_CLIENT_PULL_TIMEOUT)
    {
        return S_OK;
    }

    m_pwszClientPullURL = StrDupW(awch);

    // If we can't copy the URL, don't set the timer or else we'll
    // keep reloading the same page.

    if (m_pwszClientPullURL == NULL)
        return OLECMDERR_E_NOTSUPPORTED;

    return S_OK;
}



HRESULT CUrlDownload::SetDLCTL(long lFlags)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload: SetDLCTL %04x", lFlags);
    m_lBindFlags = lFlags | DLCTL_SILENT;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    return S_OK;
}

#define INET_E_AGENT_BIND_IN_PROGRESS 0x800C0FFF

HRESULT CUrlDownload::ProgressBytes(DWORD dwBytes)
{
    if (m_dwMaxSize > 0 && dwBytes > m_dwMaxSize)
    {
        //TraceMsg(TF_THISMODULE, "CUrlDownload MaxSize exceeded aborting. %d of %d bytes", dwBytes, m_dwMaxSize);

        AbortDownload(BDU2_ERROR_MAXSIZE);
        return E_ABORT;
    }

    return S_OK;
}

//---------------------------------------------------------------
// IServiceProvider
STDMETHODIMP CUrlDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if ((SID_SHlinkFrame == guidService && IID_IHlinkFrame == riid) ||
        (IID_IAuthenticate == guidService && IID_IAuthenticate == riid) ||
        (SID_SInternetSecurityManager == guidService && IID_IInternetSecurityManager == riid))
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    hr = E_NOTIMPL;

    //TraceMsg(TF_THISMODULE, "CUrlDownload::Authenticate returning hr=%08x", hr);

    return (hr);
}

//---------------------------------------------------------------
// IHlinkFrame
STDMETHODIMP CUrlDownload::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    // We should only get a call through IHlinkFrame->Navigate()
    // when the webcrawler has submitted a form for authentication.
    // Bail out if that's not the case.
    if (!m_fFormSubmitted)
    {
        return E_NOTIMPL;
    }

    // Our timer has already been started. If this fails, OnDownloadComplete will get
    //  called when we time out.

    // We don't support a wide variety of parameters.
    ASSERT(grfHLNF == 0);
    ASSERT(pbc);
    ASSERT(pibsc);
    ASSERT(pihlNavigate);

    // Get the moniker from IHlink
    HRESULT hr;
    IMoniker *pmk = NULL;
    hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmk, NULL);
    if (SUCCEEDED(hr))
    {
        // Load the URL with the post data.
        // REARCHITECT: What if we get redirected to something other than HTML? (beta 2)
        hr = m_pPersistMk->Load(FALSE, pmk, pbc, 0);
        SAFERELEASE(pmk);
        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            // Need to wait again.
            m_fWaitingForReadyState = TRUE;
        }
    }
    return (hr);
}
STDMETHODIMP CUrlDownload::OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
// IInternetSecurityManager interface
// Used to override security to allow form submits, for form auth sites
HRESULT CUrlDownload::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    if ((dwAction == URLACTION_HTML_SUBMIT_FORMS_TO) ||
        (dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM))
    {
        return S_OK;
    }
    
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//
// IOleClientSite
//
STDMETHODIMP CUrlDownload:: SaveObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: ShowObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}



// ParseRefreshContent was lifted in its entirety from shdocvw\basesb.cpp
BOOL DLParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ [ws]* ; [ws]* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS, PRC_SEMI, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPWSTR pwz = pwzContent;
    LPWSTR pwzUrl = NULL;
    UINT   cchUrl = 0;
    WCHAR  wch,  wchDel = 0;

    *pwzUrlBuf = 0;

    do
    {
        wch = *pwz;

        switch (uiState)
        {
            case PRC_START:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                {
                    uiState = PRC_DIG;
                    uiDelay = wch - TEXT('0');
                }
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_DIG:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                    uiDelay = uiDelay * 10 + wch - TEXT('0');
                else if (ISSPACE(wch))
                    uiState = PRC_DIG_WS;
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_WS:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI:
                if (    (wch == TEXT('u') || wch == TEXT('U'))
                    &&  (pwz[1] == TEXT('r') || pwz[1] == TEXT('R'))
                    &&  (pwz[2] == TEXT('l') || pwz[2] == TEXT('L')))
                {
                    uiState = PRC_SEMI_URL;
                    pwz += 2;
                }
                else if (!ISSPACE(wch) && wch != TEXT(';'))
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (wch == TEXT('='))
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pwzUrlBuf = 0;
                }
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pwzUrl = pwzUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (wch == TEXT('\'')|| wch == TEXT('\"'))
                        wchDel = wch;
                    else
                    {
                        wchDel = 0;
                        *pwzUrl++ = wch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !wch
                    ||  ( wchDel && wch == wchDel)
                    ||  (!wchDel && wch == L';'))
                {
                    *pwzUrl = 0;
                    uiState = wch == TEXT(';') ? PRC_SEMI : PRC_DIG_WS;
                }
                else if (cchUrl > 1)
                {
                    *pwzUrl++ = wch;
                    cchUrl--;
                }
                break;
        }

        ++pwz;

    } while (wch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
} // ParseRefreshContent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\propstg.h ===
/*
 * propstg.h - Property storage ADT
 */

#ifndef _PROPSTG_H_
#define _PROPSTG_H_

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(HPROPSTG);

HRESULT
WINAPI
PropStg_Create(
    OUT HPROPSTG * phstg,
    IN  DWORD      dwFlags);        // PSTGF_*

// Flags for PropStg_Create
#define PSTGF_DEFAULT       0x00000000

HRESULT
WINAPI
PropStg_Destroy(
    IN HPROPSTG hstg);

HRESULT
WINAPI
PropStg_ReadMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN PROPVARIANT * rgpropvar);

HRESULT
WINAPI
PropStg_WriteMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN const PROPVARIANT * rgpropvar,
    IN PROPID        propidFirst);     OPTIONAL


typedef HRESULT (CALLBACK *PFNPROPVARMASSAGE)(PROPID propid, const PROPVARIANT * ppropvar, LPARAM lParam);

HRESULT
WINAPI
PropStg_WriteMultipleEx(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN const PROPVARIANT * rgpropvar,
    IN PROPID        propidFirst,      OPTIONAL
    IN PFNPROPVARMASSAGE pfn,          OPTIONAL
    IN LPARAM        lParam);          OPTIONAL

HRESULT
WINAPI
PropStg_DeleteMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec);


HRESULT
WINAPI
PropStg_DirtyMultiple(
    IN HPROPSTG    hstg,
    IN ULONG       cpspec,
    IN const PROPSPEC * rgpropspec,
    IN BOOL        bDirty);

HRESULT
WINAPI
PropStg_DirtyAll(
    IN HPROPSTG    hstg,
    IN BOOL        bDirty);

HRESULT
WINAPI
PropStg_IsDirty(
    IN HPROPSTG hstg);


typedef HRESULT (CALLBACK *PFNPROPSTGENUM)(PROPID propid, PROPVARIANT * ppropvar, LPARAM lParam);

HRESULT
WINAPI
PropStg_Enum(
    IN HPROPSTG       hstg,
    IN DWORD          dwFlags,      // One of PSTGEF_ 
    IN PFNPROPSTGENUM pfnEnum,
    IN LPARAM         lParam);      OPTIONAL

// Filter flags for PropStg_Enum
#define PSTGEF_DEFAULT      0x00000000
#define PSTGEF_DIRTY        0x00000001

#ifdef DEBUG
HRESULT
WINAPI
PropStg_Dump(
    IN HPROPSTG       hstg,
    IN DWORD          dwFlags);     // One of PSTGDF_ 
#endif


#ifdef DEBUG

BOOL
IsValidPPROPSPEC(
    PROPSPEC * ppropspec);

BOOL
IsValidHPROPSTG(
    HPROPSTG hstg);

#endif


#ifdef __cplusplus
};
#endif

#endif  // _PROPSTG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\reload.h ===
#ifndef _DOWNLD_HXX_
#define _DOWNLD_HXX_

#include <mshtmdid.h>
#include <mshtml.h>
#include <hlink.h>
#include "packager.h"

#ifndef GUIDSTR_MAX
// GUIDSTR_MAX is 39 and includes the terminating zero.
// == Copied from OLE source code =================================
// format for string form of GUID is (leading identifier ????)
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
// ================================================================
#endif

// Trace and debug flags
#define TF_WEBCHECKCORE 0x00001000
//#define TF_SCHEDULER    0x00002000
#define TF_WEBCRAWL     0x00004000
//#define TF_FAVORITES    0x00008000
#define TF_CDFAGENT     0x00010000
#define TF_STRINGLIST   0x00020000
#define TF_URLDOWNLOAD  0x00040000
#define TF_DOWNLD       0x00080000
#define TF_DIALMON      0x00100000
#define TF_MAILAGENT    0x00200000
#define TF_TRAYAGENT    0x00400000
#define TF_SUBSFOLDER   0x00800000
#define TF_MEMORY       0x01000000
#define TF_UPDATEAGENT  0x02000000
#define TF_POSTAGENT    0x04000000
#define TF_DELAGENT     0x08000000
#define TF_TRACKCACHE   0x10000000
#define TF_SYNCMGR      0x20000000
#define TF_THROTTLER    0x40000000

#define PSM_QUERYSIBLINGS_WPARAM_RESCHEDULE 0XF000

#undef DBG
#define DBG(sz)             TraceMsg(TF_THISMODULE, sz)
#define DBG2(sz1, sz2)      TraceMsg(TF_THISMODULE, sz1, sz2)
#define DBG_WARN(sz)        TraceMsg(TF_WARNING, sz)
#define DBG_WARN2(sz1, sz2) TraceMsg(TF_WARNING, sz1, sz2)

#ifdef DEBUG
#define DBGASSERT(expr,sz)  do { if (!(expr)) TraceMsg(TF_WARNING, (sz)); } while (0)
#define DBGIID(sz,iid)      DumpIID(sz,iid)
#else
#define DBGASSERT(expr,sz)  ((void)0)
#define DBGIID(sz,iid)      ((void)0)
#endif

// shorthand
#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#endif
#ifndef SAFEFREEBSTR
#define SAFEFREEBSTR(p) if ((p) != NULL) { SysFreeString(p); (p) = NULL; } else
#endif
#ifndef SAFEFREEOLESTR
#define SAFEFREEOLESTR(p) if ((p) != NULL) { CoTaskMemFree(p); (p) = NULL; } else
#endif
#ifndef SAFELOCALFREE
#define SAFELOCALFREE(p) if ((p) != NULL) { LocalFree(p); (p) = NULL; } else
#endif
#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; } else
#endif

#define URLDL_WNDCLASS  TEXT("TridentThicketUrlDlClass")

#define ACCEPT_LANG_MAX     256

// Options for BeginDownloadURL2
typedef enum {
    BDU2_BROWSER    // always download into the browser
} BDUMethod;

typedef DWORD BDUOptions;

// BDUOptions
#define BDU2_NONE               0
#define BDU2_NEEDSTREAM         1   // keep an istream around from bdu2_urlmon download

// OnDownloadComplete error codes
#define BDU2_ERROR_NONE         0
#define BDU2_ERROR_GENERAL      1
#define BDU2_ERROR_ABORT        2
#define BDU2_ERROR_MAXSIZE      3
#define BDU2_ERROR_TIMEOUT      4


// CUrlDowload hosts one browser and can handle one download at a time.
//
// Use of class CUrlDownload:
//
// 1) Create and AddRef it
// 1.5) call put_Flags() to set the bind status callback IBrowseControl::Flags
// 2) Call BeginDownloadURL2 to start a download
// 3) Call BeginDownloadURL2 to start another download, reusing browser
// 4) Call DoneDownloading() when finished
// 5) Release()

// DoneDownloading() must be called before Release() or the CUrlDownload instance may
//  continue to receive notifications from the browser and attempt to pass them to
//  the parent. It unhooks itself as soon as OnProgress(-1) is received. But be safe.


// See webcrawl.h and webcrawl.cpp for example
class CUrlDownload :  public IOleClientSite         // e_notimpl
                    , public IPropertyNotifySink    // for readystate change notifications
                    , public IOleCommandTarget      // for client pull callbacks
                    , public IDispatch              // for ambient properties
                    , public IServiceProvider       // for IAuthenticate and IHlinkFrame
                    , public IAuthenticate          // for Basic and NTLM authentication
                    , public IHlinkFrame            // for catching the post of a form
                    , public IInternetSecurityManager // for allowing the post of a form
{
    

public:
    CUrlDownload( CThicketProgress *ptp, HRESULT *phr, UINT cpDL );
    ~CUrlDownload();

    void SetFormSubmitted(BOOL fFormSubmitted) { m_fFormSubmitted = fFormSubmitted; }
    BOOL GetFormSubmitted(void) { return m_fFormSubmitted; }

    // An E_ return code from this function may be ignored if desired. The
    //  client's OnDownloadComplete will be called with fAborted==TRUE after this
    //  function returns with an error value.
    HRESULT BeginDownloadURL2(LPCWSTR, BDUMethod, BDUOptions, LPTSTR, DWORD);

    HRESULT SetDLCTL(long lFlags);  // DLCTL flags used for browser control

    HRESULT AbortDownload(int iErrorCode=-1);   // S_OK, S_FALSE, E_FAIL

    void    ReleaseScript() { SAFERELEASE(m_pScript); } // Releases internal reference

    HRESULT GetDocument(IHTMLDocument2 **ppDoc);

    void    DoneDownloading();  // Call before releasing. Will destroy browser and windows.

    // URL manipulation functions
static HRESULT StripAnchor(LPWSTR lpURL);

    // Should only be called from CUrlDownloadMsgProc
    BOOL HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //      IDispatch (ambient properties)
    STDMETHODIMP         GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP         GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP         GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgdispid);
    STDMETHODIMP         Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IOleClientSite
    STDMETHODIMP        SaveObject(void);
    STDMETHODIMP        GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHODIMP        GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP        ShowObject(void);
    STDMETHODIMP        OnShowWindow(BOOL fShow);
    STDMETHODIMP        RequestNewObjectLayout(void);

    // IPropertyNotifySink
    STDMETHODIMP        OnChanged(DISPID dispID);
    STDMETHODIMP        OnRequestEdit(DISPID dispID);

    // IOleCommandTarget
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // IServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    // IAuthenticate
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    
    // IHlinkFrame
    STDMETHODIMP        SetBrowseContext(IHlinkBrowseContext *pihlbc);
    STDMETHODIMP        GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    STDMETHODIMP        Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    STDMETHODIMP        OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    STDMETHODIMP        UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IInternetSecurityManager
    STDMETHODIMP        SetSecuritySite(IInternetSecurityMgrSite *pSite);
    STDMETHODIMP        GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    STDMETHODIMP        MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    STDMETHODIMP        GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    STDMETHODIMP        ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP        QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    STDMETHODIMP        SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    STDMETHODIMP        GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);



protected:
    // main object stuff
    ULONG               m_cRef;
    HWND                m_hwndMe;
    CThicketProgress*   m_ptp;
    UINT                m_cpDL;
    HRESULT             *m_phr;
    DWORD               m_dwProgMax;

    // GetBrowser/CleanUpBrowser (browser download data)
    IPersistMoniker     *m_pPersistMk;
    IHTMLDocument2      *m_pDocument;
    IOleCommandTarget   *m_pOleCmdTarget;
    BOOL                m_fWaitingForReadyState;
    BOOL                m_fFormSubmitted;
    IConnectionPoint    *m_pCP;         // connection point for DIID_DWebBrowserEvents
    BOOL                m_fAdviseOn;    // our sink is hooked up? (ConnectionCookie valid)
    DWORD               m_dwConnectionCookie;
    BOOL                m_fBrowserValid;    // Browser pointing to 'current' URL?


    // General download data
    BDUMethod           m_iMethod;
    BDUOptions          m_iOptions;
    LPWSTR              m_pwszURL;      // gives us the current url after redirections
    BOOL                m_fSetResync;   // need RESYNCHRONIZE?
    DWORD               m_dwMaxSize;    // in bytes

    // IBrowseControl
    long                m_lBindFlags;

    // allow caching GetScript calls
    IHTMLWindow2        *m_pScript;

    // Client pull
    LPWSTR              m_pwszClientPullURL;
    int                 m_iNumClientPull;

    // other internal stuff
    HRESULT     CreateMyWindow();
    HRESULT     GetBrowser();   // Get browser and set us on connection point
    void        UnAdviseMe();   // Unhook our advise sink

    void        CleanUpBrowser();
    void        CleanUp();      // Clean up, including releasing browser

    HRESULT     BeginDownloadWithBrowser(LPCWSTR);

    HRESULT     HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone);

    HRESULT     OnDownloadComplete(int iError);     // cancel timeout, send OnDownloadComplete

    HRESULT     ProgressBytes(DWORD dwBytes);       // Will abort if too many
};



#endif // _DWNLOAD_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\runonnt.h ===
// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#define PathCleanupSpec         _AorW_PathCleanupSpec
#define SHCLSIDFromString       _AorW_SHCLSIDFromString
#define SHILCreateFromPath      _AorW_SHILCreateFromPath
#define SHSimpleIDListFromPath  _AorW_SHSimpleIDListFromPath
#define StrToOleStr             _AorW_StrToOleStr
#define GetFileNameFromBrowse   _AorW_GetFileNameFromBrowse
#define OpenRegStream           _AorW_OpenRegStream
#define PathProcessCommand      _AorW_PathProcessCommand
#define PathYetAnotherMakeUniqueName    _AorW_PathYetAnotherMakeUniqueName
#define Shell_GetCachedImageIndex _AorW_Shell_GetCachedImageIndex
#define SHRunControlPanel       _AorW_SHRunControlPanel
#define PickIconDlg             _AorW_PickIconDlg
#define SHCreateDirectory       _AorW_SHCreateDirectory

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef ILCreateFromPath
#undef ILCreateFromPath
#endif
#define ILCreateFromPath        _AorW_ILCreateFromPath

#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

// Define the prototypes for each of these forwarders...

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
extern int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd);
extern LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath);
extern int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
extern LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags);
extern HRESULT _AorW_SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid);
extern BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);
extern HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
extern LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath);
extern BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle);
extern IStream * _AorW_OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode);

extern BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszShort,
                                         LPCTSTR pszFileSpec);

extern int  _AorW_PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cchIconPath, int * piIconIndex);
extern int  _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);

#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\security.h ===
/**************************************************************\
    FILE: security.h

    DESCRIPTION:
        This file will contain helper functions and objects that
    help deal with security.  This mainly means Zones Security, but
    can include other types.
\**************************************************************/

#ifndef _SECURITY_H
#define _SECURITY_H

#include "priv.h"
#include "util.h"

#endif // _SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

STDAPI  CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CWebBrowserOC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinks_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinksOld_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMediaBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // mediaband.cpp
STDAPI  CAddressBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // address.cpp
STDAPI  CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   // aeditbox.cpp
STDAPI  CBandProxy_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);     // bandprxy.cpp
STDAPI  CBrandBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CTargetMenu_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CSHItemOC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellHlinkFrame_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CUrlHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CURLSearchHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CStartMenuBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBrowserBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CSearchBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCommBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CStubBSC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellDataSource_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CFavBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CHistBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#ifdef ENABLE_CHANNELS
STDAPI  CChannelBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#endif  // ENABLE_CHANNELS
STDAPI  CExplorerBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLIShellFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMulti_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIntShcut_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CCmdFileIcon_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CSharedTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CStartMenuTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDesktopTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CBaseBrowser2_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);

STDAPI  CShellFolderView_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CWinListShellProc_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CActiveDesktop_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CMenuSite_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  COfflinePagesCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocFileInfoTip_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocHostUIHandler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CToolbarExtBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CToolbarExtExec_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMruLongList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMruPidlList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
#ifdef _HSFOLDER
STDAPI  CacheFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  HistFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
#endif

STDAPI CBaseBrowser_Validate(HWND hwnd, LPVOID* ppsb);
STDAPI CShellBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CSDWindows_CreateInstance(IShellWindows **ppunk);

STDAPI CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern char g_szLibName[]; // shocx.c
extern LCID g_lcidLocale; // shocx.c

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\runonnt.c ===
#include "priv.h"
#include <strsafe.h>
// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#include <mluisupp.h>

//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

// First undefine everything that we are intercepting as to not forward back to us...
#undef ILCreateFromPath
#undef PathCleanupSpec
#undef PathProcessCommand
#undef SHCLSIDFromString
#undef SHGetSpecialFolderPath
#undef SHILCreateFromPath
#undef SHSimpleIDListFromPath
#undef ShellMessageBox
#undef GetFileNameFromBrowse
#undef OpenRegStream
#undef PathYetAnotherMakeUniqueName
#undef Shell_GetCachedImageIndex
#undef SHRunControlPanel
#undef PickIconDlg
#undef SHCreateDirectory

#define TF_THUNK    0

#define THUNKMSG(psz)   TraceMsg(TF_THUNK, "shdv THUNK::%s", psz)


// FEATURE:: need to properly handle not having ILGetdisplaynameex...
typedef BOOL (*PFNILGETDISPLAYNAMEEX)(LPSHELLFOLDER psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);

#ifndef ANSI_SHELL32_ON_UNIX
#define UseUnicodeShell32() (g_fRunningOnNT)
#else
#define UseUnicodeShell32() (FALSE)
#endif


//=================================================================================
// Now the thunks...

int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd)
{
    CHAR szPath[MAX_PATH];
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszOrig_cmdline, szPath, ARRAYSIZE(szPath));
        pszOrig_cmdline = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }
    return SHRunControlPanel(pszOrig_cmdline, errwnd);
}

int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    CHAR szPath[MAX_PATH];
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszIconPath, szPath, ARRAYSIZE(szPath));
        pszIconPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }
    return Shell_GetCachedImageIndex(pszIconPath, iIconIndex, uIconFlags);
}

// Explicit prototype because only the A/W prototypes exist in the headers
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPath(LPCTSTR pszPath);

LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("ILCreateFromPath"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return ILCreateFromPath(pszPath);
}

int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec)
{
    THUNKMSG(TEXT("PathCleanupSpec"));
    if (!UseUnicodeShell32())
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir) {
            UnicodeToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        } else {
            pszDir2 = NULL;
        }

        UnicodeToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));

        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        AnsiToUnicode(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
        return PathCleanupSpec(pszDir, pszSpec);
}

LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags)
{
    LONG    lReturnValue;

    THUNKMSG(TEXT("PathProcessCommand"));
    if (!UseUnicodeShell32())
    {
        CHAR szSrc[MAX_PATH];
        CHAR szDest[MAX_PATH];

        UnicodeToAnsi(lpSrc, szSrc, ARRAYSIZE(szSrc));
        lReturnValue = PathProcessCommand((LPTSTR)szSrc, (LPTSTR)szDest, iDestMax, dwFlags);
        AnsiToUnicode(szDest, lpDest, iDestMax);
    }
    else
        lReturnValue = PathProcessCommand(lpSrc, lpDest, iDestMax, dwFlags);

    return(lReturnValue);
}

HRESULT _AorW_SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("SHCLSIDFromString"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(lpsz, szPath, ARRAYSIZE(szPath));
        lpsz = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return SHCLSIDFromString(lpsz, lpclsid);
}

#ifndef UNIX
// Explicit prototype because only the A/W prototypes exist in the headers
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);
#else
#ifdef UNICODE
#define SHGetSpecialFolderPath SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath SHGetSpecialFolderPathA
#endif
#endif

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    THUNKMSG(TEXT("SHGetSpecialFolderPath"));
    if (!UseUnicodeShell32())
    {
        CHAR szPath[MAX_PATH];
        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)szPath, nFolder, fCreate);
        if (fRet)
            AnsiToUnicode(szPath, pszPath, MAX_PATH);
        return fRet;
    }
    else
        return SHGetSpecialFolderPath(hwndOwner, pszPath, nFolder, fCreate);
}

HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHILCreateFromPath"));

    if (pszPath)
    {
        //
        //  Shell32 will blindly copy pszPath into a MAX_PATH buffer.  This
        //  results in a exploitable buffer overrun.  Do not pass more than
        //  MAX_PATH characters.
        //
        if (!UseUnicodeShell32())
        {
            UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
        else if (lstrlenW(pszPath) >= MAX_PATH)
        {
            *ppidl = NULL;
            return E_FAIL;
        }
    }

    return SHILCreateFromPath(pszPath, ppidl, rgfInOut);
}

LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("SHSimpleIDListFromPath"));
    if (!UseUnicodeShell32() && pszPath)
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return SHSimpleIDListFromPath(pszPath);
}


#define TEMP_SMALL_BUF_SZ  256
BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR pszFilePath, UINT cchFilePath,
        LPCTSTR pszWorkingDir, LPCTSTR pszDefExt, LPCTSTR pszFilters, LPCTSTR pszTitle)
{
    CHAR    szPath[MAX_PATH];
    CHAR    szDir[MAX_PATH];
    CHAR    szExt[TEMP_SMALL_BUF_SZ];
    CHAR    szFilters[TEMP_SMALL_BUF_SZ*2];
    CHAR    szTitle[TEMP_SMALL_BUF_SZ];
    LPTSTR  pszPath = pszFilePath;
    BOOL    bResult;
    THUNKMSG(TEXT("GetFileNameFromBrowse"));

    // thunk strings to ansi 
    if (!UseUnicodeShell32()) 
    {
        // always move szFilePath stuff to wszPath buffer. Should never be a resourceid.
        UnicodeToAnsi((LPCTSTR)pszFilePath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPTSTR)szPath;
        if (!IS_INTRESOURCE(pszWorkingDir)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCTSTR)szDir;
        }
        if (!IS_INTRESOURCE(pszDefExt)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCTSTR)szExt;
        }
        if (!IS_INTRESOURCE(pszFilters)) //not a resource
        {
            int l=1;
            while (*(pszFilters+l) != 0 || *(pszFilters+l-1) != 0)
                l++;
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, l+1, szFilters,
                                ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCTSTR)szFilters;
        }
        if (!IS_INTRESOURCE(pszTitle)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCTSTR)szTitle;
        }
    }

    bResult = GetFileNameFromBrowse(hwnd, pszPath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle);

    if (!UseUnicodeShell32())
    {
        AnsiToUnicode(szPath, pszFilePath, cchFilePath);
    }

    return (bResult);
}

IStream * _AorW_OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode)
{
    CHAR szSubkey[MAX_PATH];      // large enough to hold most any name...
    CHAR szValue[MAX_PATH];       // dito.
    if (!UseUnicodeShell32())
    {

        UnicodeToAnsi(pszSubkey, szSubkey, ARRAYSIZE(szSubkey));
        pszSubkey = (LPCTSTR)szSubkey;
        if (pszValue)
        {
            UnicodeToAnsi(pszValue, szValue, ARRAYSIZE(szValue));
            pszValue = (LPCTSTR)szValue;
        }
    }

    return OpenRegStream(hkey, pszSubkey, pszValue, grfMode);

}


BOOL
_AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                  LPCTSTR pszPath,
                                  LPCTSTR pszShort,
                                  LPCTSTR pszFileSpec)
{
    CHAR szUniqueName[MAX_PATH];
    CHAR szPath[MAX_PATH];
    CHAR szShort[32];
    CHAR szFileSpec[MAX_PATH];
    BOOL fRet;
    THUNKMSG(TEXT("PathYetAnotherMakeUniqueName"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            UnicodeToAnsi(pszShort, szShort, ARRAYSIZE(szShort));
            pszShort = (LPCTSTR)szShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            UnicodeToAnsi(pszFileSpec, szFileSpec, ARRAYSIZE(szFileSpec));
            pszFileSpec = (LPCTSTR)szFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)szUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            AnsiToUnicode(szUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
    else
        return PathYetAnotherMakeUniqueName(pszUniqueName, pszPath, pszShort, pszFileSpec);
}

int _AorW_PickIconDlg(
    IN     HWND  hwnd, 
    IN OUT LPTSTR pszIconPath, 
    IN     UINT  cchIconPath, 
    IN OUT int * piIconIndex)
{
    int  nRet;

    if (UseUnicodeShell32())
    {
        nRet = PickIconDlg(hwnd, pszIconPath, cchIconPath, piIconIndex);
    }
    else
    {
        CHAR szPath[MAX_PATH];
        UINT cch = ARRAYSIZE(szPath);

        UnicodeToAnsi(pszIconPath, szPath, cch);
        nRet = PickIconDlg(hwnd, (LPTSTR)szPath, cch, piIconIndex);
        AnsiToUnicode(szPath, pszIconPath, cchIconPath);
    }

    return nRet;
}

STDAPI_(int) _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    if (UseUnicodeShell32())
    {
        WCHAR wsz[MAX_PATH];

        SHTCharToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        return SHCreateDirectory(hwnd, (LPCTSTR)wsz);
    }
    else
    {
        CHAR  sz[MAX_PATH];

        SHTCharToAnsi(pszPath, sz, ARRAYSIZE(sz));
        return SHCreateDirectory(hwnd, (LPCTSTR)sz);
    }
}

#endif  // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\sftupmb.cpp ===
#include "priv.h"
#include "resource.h"

#include <strsafe.h>

#include <mluisupp.h>

struct SUParams {
    LPSOFTDISTINFO  psdi;
    BITBOOL         bRemind : 1;
    BITBOOL         bDetails : 1;
    LONG            cyNoDetails;
    LONG            cxDlg;
    LONG            cyDlg;
};

INT_PTR CALLBACK SoftwareUpdateDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                     LPCWSTR szDistUnit,
                                     DWORD dwFlags,
                                     LPSOFTDISTINFO psdi )
{
    HRESULT hr;
    int iRet = IDIGNORE;
    SOFTDISTINFO    sdi;
    SUParams suparams;
    DWORD dwAdStateNew = SOFTDIST_ADSTATE_NONE;

    if ( psdi == NULL )
    {
        // use a local 
        sdi.cbSize = sizeof(SOFTDISTINFO);
        sdi.dwReserved = 0;
        psdi = &sdi;
    }

    suparams.psdi = psdi;
    suparams.bRemind = TRUE;
    suparams.bDetails = FALSE;

    hr = GetSoftwareUpdateInfo( szDistUnit, psdi );
 
    // we need an HREF to work properly. The title and abstract are negotiable.
    if ( SUCCEEDED(hr) && psdi->szHREF != NULL )
    {
        // see if this is an update the user already knows about.
        // If it is, then skip the dialog.
        if (  (psdi->dwUpdateVersionMS >= psdi->dwInstalledVersionMS ||
                (psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
                 psdi->dwUpdateVersionLS >= psdi->dwInstalledVersionLS))    && 
              (psdi->dwUpdateVersionMS >= psdi->dwAdvertisedVersionMS ||
                (psdi->dwUpdateVersionMS == psdi->dwAdvertisedVersionMS &&
                 psdi->dwUpdateVersionLS >= psdi->dwAdvertisedVersionLS)) )
        { 
            DWORD idDlg;

            if ( hr == S_OK ) // new version
            {
                // we have a pending update, either on the net, or downloaded
                if ( psdi->dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE )
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_DOWNLOADED;
                    // Show same dialog for downloaded/available states
                    // because users get confused. See IE5 RAID entry 14488
                    idDlg = IDD_SUAVAILABLE;
                }
                else
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_AVAILABLE;
                    idDlg = IDD_SUAVAILABLE;
                }
            }
            else if ( psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
                      psdi->dwUpdateVersionLS == psdi->dwInstalledVersionLS )
            {
                // if installed version matches advertised, then we autoinstalled already
                dwAdStateNew = SOFTDIST_ADSTATE_INSTALLED;
                idDlg = IDD_SUINSTALLED;
            }
            else
            {
                idDlg = 0;
            }

            // only show the dialog if we've haven't been in this ad state before for
            // this update version
            if ( dwAdStateNew > psdi->dwAdState && idDlg != 0)
            {
                // Sundown: coercion is OK since SoftwareUpdateDlgProc returns true/false
                iRet = (int) DialogBoxParam(MLGetHinst(),
                                            MAKEINTRESOURCE(idDlg),
                                            hWnd,
                                            SoftwareUpdateDlgProc,
                                            (LPARAM)&suparams);
            }
        } // if update is a newer version than advertised

        // If the user doesn't want a reminder and didn't cancel, mark the DU.

        if ( !suparams.bRemind && (iRet == IDNO || iRet == IDYES) )
        {
            SetSoftwareUpdateAdvertisementState( szDistUnit,
                                                dwAdStateNew,
                                                psdi->dwUpdateVersionMS,
                                                psdi->dwUpdateVersionLS );
        } // if we're finished with this ad state for this version
    } // if we got the update info
    else 
        iRet = IDABORT;

    if ( FAILED(hr) || psdi == &sdi )
    {
        if ( psdi->szTitle != NULL )
        {
            CoTaskMemFree( psdi->szTitle );
            psdi->szTitle = NULL;
        }
        if ( psdi->szAbstract != NULL )
        {
            CoTaskMemFree( psdi->szAbstract );
            psdi->szAbstract = NULL;
        };
        if ( psdi->szHREF != NULL )
        {
            CoTaskMemFree( psdi->szHREF );
            psdi->szHREF = NULL;
        }
    }

    return iRet;
}

INT_PTR CALLBACK SoftwareUpdateDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL        fRet = 0;
    SUParams    *psuparam = (SUParams*)GetWindowLongPtr(hDlg, DWLP_USER);;
    HRESULT     hr = S_OK;
    HWND hwndDetails;

    switch (msg)
    {
    case WM_INITDIALOG:
        int         cchDetails;
        TCHAR       *pszTitle;
        TCHAR       *pszAbstract;
        TCHAR       *pszDetails;
        TCHAR       szFmt[MAX_PATH];

        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        psuparam = (SUParams*)lParam;

        if (SHRestricted( REST_NOFORGETSOFTWAREUPDATE))
            EnableWindow(GetDlgItem(hDlg, IDC_REMIND), FALSE);

        // Prepare the details from the SOFTDISTINFO
        MLLoadString(IDS_SUDETAILSFMT, szFmt, ARRAYSIZE(szFmt) );
        cchDetails = lstrlen( szFmt );
        if ( psuparam->psdi->szTitle != NULL )
        {
            pszTitle = psuparam->psdi->szTitle;
        }
        else
        {
            pszTitle = NULL;
        }
        if ( psuparam->psdi->szAbstract != NULL )
        {
            pszAbstract = psuparam->psdi->szAbstract;
        }
        else
        {
            pszAbstract = NULL;
        }
        pszDetails = new TCHAR[cchDetails];
        if ( pszDetails != NULL )
        {
            StringCchPrintf( pszDetails, cchDetails, szFmt, ((pszTitle!=NULL)?pszTitle:TEXT("")),
                                         ((pszAbstract!=NULL)?pszAbstract:TEXT("")) );
            // set the details text
            SetDlgItemText( hDlg, IDC_DETAILSTEXT, pszDetails );
            // initialize the reminder check box
            CheckDlgButton( hDlg, IDC_REMIND, ((psuparam->bRemind)?BST_CHECKED:BST_UNCHECKED) );
            // Hide or show the details
            RECT rectDlg;
            RECT rectDetails;

            GetWindowRect( hDlg, &rectDlg );
            psuparam->cyDlg = rectDlg.bottom - rectDlg.top;
            psuparam->cxDlg = rectDlg.right - rectDlg.left;
            hwndDetails = GetDlgItem( hDlg, IDC_DETAILSTEXT );
            GetWindowRect( hwndDetails, &rectDetails );
            psuparam->cyNoDetails = rectDetails.top - rectDlg.top;
            SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE );
            SetWindowPos( hDlg, NULL,
                          0,0,psuparam->cxDlg,psuparam->cyNoDetails,
                          SWP_NOMOVE | SWP_NOZORDER );
        }
        else
            EndDialog( hDlg, IDABORT );


        if ( pszDetails != NULL )
            delete pszDetails;

        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDYES:
            EndDialog(hDlg, IDYES );
            fRet = TRUE;
            break;
        case IDNO:
            EndDialog(hDlg, IDNO );
            fRet = TRUE;
            break;
        case IDC_REMIND:
            psuparam->bRemind = IsDlgButtonChecked( hDlg, IDC_REMIND ) == BST_CHECKED;
            fRet = TRUE;
            break;
        case IDC_DETAILS:
            {
                TCHAR   szDetails[40];

                // toggle the details
                hwndDetails = GetDlgItem( hDlg, IDC_DETAILSTEXT );
                psuparam->bDetails = !psuparam->bDetails;

                if ( psuparam->bDetails )
                {
                    // show the details
                    // switch button to close text
                    MLLoadString(IDS_SUDETAILSCLOSE, szDetails, ARRAYSIZE(szDetails) );
                    SetDlgItemText( hDlg, IDC_DETAILS, szDetails );
                    SetWindowPos( hDlg, NULL,
                                  0,0,psuparam->cxDlg, psuparam->cyDlg,
                                  SWP_NOMOVE | SWP_NOZORDER );
                    SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE );
                }
                else
                {
                    MLLoadString(IDS_SUDETAILSOPEN, szDetails, ARRAYSIZE(szDetails) );
                    SetDlgItemText( hDlg, IDC_DETAILS, szDetails );
                    SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE );
                    SetWindowPos( hDlg, NULL,
                                  0,0,psuparam->cxDlg,psuparam->cyNoDetails,
                                  SWP_NOMOVE | SWP_NOZORDER );
                }
            }
            fRet = TRUE;
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, IDNO);
        fRet = TRUE;
        break;

    case WM_DESTROY:
        fRet = TRUE;
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\resource.h ===
/***************************************************************************/
/* WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! */
/***************************************************************************/
/* As part of the shdocvw/browseui split, parts of this file are moving to */
/* shell32 (#ifdef POSTPOSTSPLIT).  Make sure you make your delta to the   */
/* shell32 version if you don't want your changes to be lost!              */
/***************************************************************************/

// Resource IDs for SHDOCVW
//
// Cursor IDs

//  #define IDC_OFFLINE_HAND        103  This has been moved to shlobj.w so
// that ISVs can access it from outside
// Hence you will find it in shlobj.h

// REARCHITECT:CHEE
// these are duplicated with explorer.exe
//
// (no they aren't -raymondc)
//
#define IDS_CHANNEL_UNAVAILABLE 832
#define IDS_BETAEXPIRED         835
#define IDS_FAV_UNABLETOCREATE  833

#define IDS_OPEN                840
#define IDS_SYNCHRONIZE         841
#define IDS_MAKE_OFFLINE        842
#define IDS_VALUE_UNKNOWN       844

#define IDS_DESKTOP             901

// global ids
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define IDC_GROUPBOX                    300

#define IDC_KBSTART                     305

//
// END REARCHITECT:CHEE
//
//
// Icons in other modules

#define IDI_URL_WEBDOC                  102     // in url.dll
#define IDI_URL_SPLAT                   106     // in url.dll


// Icon IDs (the order of these IDs should be preserved
//  across releases)
//
//
// *** READ THIS BEFORE MODIFYING ICONS ***
// ***
// *** The order of icons is important, as sometimes they
// *** are referenced by INDEX instead of by ID.  This
// *** means that technically, to maintain backward compat
// *** all icons, onced shipped, must stay there and stay
// *** in the same order.  Specifically, icon IDI_CHANNELSAPP (118)
// *** must be at index 18 as ie4 channels.scf references id.
// ***
// *** IE5 already ripped out a bunch of icons, and I'm putting
// *** back just enough to fix this bug.
// ***
//
// #define IDI_HOMEPAGE                 100 // Index:   0   // defined in inc\shdocvw.h
#define IDI_101                         101 //          1
#define IDI_RUNDLG                      102 //          2
#define IDI_SSL                         103 //          3
#define IDI_104                         104 //          4
//#define IDI_OFFLINE                   105 //          5   // defined in inc\shdocvw.h
#define IDI_106                         106 // ICO_CHANNELS in ie4
#define IDI_107                         107 // ICO_FAVORITES in ie4
#define IDI_108                         108 // ICO_SEARCH in ie4
#define IDI_109                         109 // ICO_HISTORY in ie4
#define IDI_STATE_FIRST                 110
//#define IDI_STATE_NORMAL              110 //          10  // defined in inc\shdocvw.h
#define IDI_STATE_FINDINGRESOURCE       111 //          11
#define IDI_STATE_SENDINGREQUEST        112 //          12
#define IDI_STATE_DOWNLOADINGDATA       113 //          13
#define IDI_STATE_LAST                  113
#define IDI_115                         115 // IDI_SUBSCRIPTION in ie4
#define IDI_PRINTER                     116 //          16
#define IDI_117                         117 // IDI_BACK_NONE in ie4
#define IDI_CHANNELSAPP                 118 //          18
#define IDI_154                         154 // IDI_SYSFILE in ie4
#define IDI_FRAME                       190 // IE4 shipped at 101
#define IDI_FAVORITE                    191 // IE4 shipped at 104
#define IDI_200                         200 // ICO_SHOWALL in ie4
#define IDI_201                         201 // ICO_HIDEHIDDEN in ie4
#define IDI_202                         202 // ICO_HIDESYSTEM in ie4
#define IDI_203                         203 // ICO_MULTWIN in ie4
//#define ICO_TREEUP                    204 //              // defined in inc\shdocvw.h
//#define ICO_GLEAM                     205 //              // defined in inc\shdocvw.h
#ifndef POSTPOSTSPLIT
#define IDI_NEW_FOLDER                  206
#endif
#define IDI_207                         207 // IDI_FOLDER in ie4
#define IDI_208                         208 // IDI_FOLDERVIEW in ie4
#define IDI_209                         209 // IDI_HTTFILE in ie4
#define IDI_LOCK                        0x31E0
#define IDI_UNLOCK                      0x31E1
#define IDI_USAGE_ICON                  0x31E2
#define IDI_SUGENERIC                   0x3330
#define IDI_REMOTEFLD                   20780
#define IDI_HISTORYDELETE               20782
#define IDI_HISTWEEK                    20783
#define IDI_HISTOPEN                    20784
#define IDI_HISTFOLDER                  20785
#define IDI_HISTURL                     20786
// ***
// *** IE4 shipped all the above icons, so if you want
// *** to add new ones, you should must add them
// *** after id 20786
// ***

#define IDI_FORTEZZA                    20788
#define IDI_STATE_SCRIPTERROR           20789
#define IDI_PRIVACY                     20790
#define IDI_PRIVACY_IMPACT              20793
#define IDI_PRIVACY_WARN                20794
#define IDI_PRIVACY_QUESTION            20795
#define IDI_PRIVACY_BLANK               20796
#define IDI_PRIVACY_XP                  20797

// other stuff
#define HSFBASE                         20480   //  0x5000
#ifdef _HSFOLDER
#define POPUP_CACHECONTEXT_URL          20680
#define POPUP_CONTEXT_URL_VERBSONLY     20681
#define POPUP_HISTORYCONTEXT_URL        20682
#define MENU_HISTORY                    20683
#define MENU_CACHE                      20684


#define IDS_BYTES                       (HSFBASE+515)
#define IDS_ORDERKB                     (HSFBASE+520)
#define IDS_ORDERMB                     (HSFBASE+521)
#define IDS_ORDERGB                     (HSFBASE+522)
#define IDS_ORDERTB                     (HSFBASE+523)

#define IDS_HOSTNAME_COL                (HSFBASE+345)
#define IDS_TIMEPERIOD_COL              (HSFBASE+346)
#define IDS_NAME_COL                    (HSFBASE+347)
#define IDS_ORIGINAL_COL                (HSFBASE+348)
#define IDS_STATUS_COL                  (HSFBASE+349)
#define IDS_SIZE_COL                    (HSFBASE+350)
#define IDS_TYPE_COL                    (HSFBASE+351)
#define IDS_MODIFIED_COL                (HSFBASE+352)
#define IDS_EXPIRES_COL                 (HSFBASE+353)
#define IDS_ACCESSED_COL                (HSFBASE+354)
#define IDS_LASTSYNCED_COL              (HSFBASE+355)
#define IDS_HSFNONE                     (HSFBASE+356)

#define IDS_CACHETYPE                   (HSFBASE+357)

#define IDS_LASTVISITED_COL             (HSFBASE+358)
#define IDS_NUMVISITS_COL               (HSFBASE+359)
#define IDS_WHATSNEW_COL                (HSFBASE+360)
#define IDS_DESCRIPTION_COL             (HSFBASE+361)
#define IDS_AUTHOR_COL                  (HSFBASE+362)
#define IDS_TITLE_COL                   (HSFBASE+363)
#define IDS_LASTUPDATED_COL             (HSFBASE+364)
#define IDS_SHORTNAME_COL               (HSFBASE+365)
#define IDS_NOTNETHOST                  (HSFBASE+366)
#define IDS_TODAY                       (HSFBASE+367)
#define IDS_FROMTO                      (HSFBASE+368)
#define IDS_WEEKOF                      (HSFBASE+369)
#define IDS_SITETOOLTIP                 (HSFBASE+370)
#define IDS_DAYTOOLTIP                  (HSFBASE+371)
#define IDS_WEEKTOOLTIP                 (HSFBASE+372)
#define IDS_MISCTOOLTIP                 (HSFBASE+373)
#define IDS_TODAYTOOLTIP                (HSFBASE+374)
#define IDS_WEEKSAGO                    (HSFBASE+375)
#define IDS_LASTWEEK                    (HSFBASE+376)
#define IDS_FILE_TYPE                   (HSFBASE+377)
#define IDS_HISTHOST_FMT                (HSFBASE+378)

#define IDM_SORTBYTITLE                 10
#define IDM_SORTBYADDRESS               11
#define IDM_SORTBYVISITED               12
#define IDM_SORTBYUPDATED               13

#define IDM_SORTBYNAME                  20
#define IDM_SORTBYADDRESS2              21
#define IDM_SORTBYSIZE                  22
#define IDM_SORTBYEXPIRES2              23
#define IDM_SORTBYMODIFIED              24
#define IDM_SORTBYACCESSED              25
#define IDM_SORTBYCHECKED               26

#define IDM_MOREINFO                    30

#define IDS_MH_FIRST                    (HSFBASE+400)
#define IDS_MH_TITLE                    IDS_MH_FIRST+IDM_SORTBYTITLE
#define IDS_MH_ADDRESS                  IDS_MH_FIRST+IDM_SORTBYADDRESS
#define IDS_MH_VISITED                  IDS_MH_FIRST+IDM_SORTBYVISITED
#define IDS_MH_UPDATED                  IDS_MH_FIRST+IDM_SORTBYUPDATED
#define IDS_MH_NAME                     IDS_MH_FIRST+IDM_SORTBYNAME
#define IDS_MH_ADDRESS2                 IDS_MH_FIRST+IDM_SORTBYADDRESS2
#define IDS_MH_SIZE                     IDS_MH_FIRST+IDM_SORTBYSIZE
#define IDS_MH_EXPIRES2                 IDS_MH_FIRST+IDM_SORTBYEXPIRES2
#define IDS_MH_MODIFIED                 IDS_MH_FIRST+IDM_SORTBYMODIFIED
#define IDS_MH_ACCESSED                 IDS_MH_FIRST+IDM_SORTBYACCESSED
#define IDS_MH_CHECKED                  IDS_MH_FIRST+IDM_SORTBYCHECKED


#define  RSVIDM_FIRST                   1
#define  RSVIDM_OPEN                    RSVIDM_FIRST+0
#define  RSVIDM_COPY                    RSVIDM_FIRST+1
#define  RSVIDM_DELCACHE                RSVIDM_FIRST+2
#define  RSVIDM_PROPERTIES              RSVIDM_FIRST+3
#define  RSVIDM_NEWFOLDER               RSVIDM_FIRST+4
#define  RSVIDM_ADDTOFAVORITES          RSVIDM_FIRST+5
#define  RSVIDM_OPEN_NEWWINDOW          RSVIDM_FIRST+6
#define  RSVIDM_EXPAND                  RSVIDM_FIRST+7
#define  RSVIDM_COLLAPSE                RSVIDM_FIRST+8
#define  RSVIDM_LAST                    RSVIDM_COLLAPSE /* Adjust me if you add new RSVIDM_s. */

#define IDS_SB_FIRST                    (HSFBASE+380)
#define IDS_SB_OPEN                     IDS_SB_FIRST+RSVIDM_OPEN
#define IDS_SB_COPY                     IDS_SB_FIRST+RSVIDM_COPY
#define IDS_SB_DELETE                   IDS_SB_FIRST+RSVIDM_DELCACHE
#define IDS_SB_PROPERTIES               IDS_SB_FIRST+RSVIDM_PROPERTIES

#define IDS_WARN_DELETE_HISTORYITEM     (HSFBASE+500)
#define IDS_WARN_DELETE_MULTIHISTORY    (HSFBASE+501)
#define IDS_WARN_DELETE_CACHE           (HSFBASE+502)

#define DLG_CACHEITEMPROP               21080
#define IDD_ITEMICON                    21081
#define IDD_FILETYPE_TXT                21084
#define IDD_FILETYPE                    21085
#define IDD_FILESIZE                    21087
#define IDD_LINE_2                      21088
#define IDD_EXPIRES                     21092
#define IDD_LASTMODIFIED                21094
#define IDD_LASTACCESSED                21096
#define IDD_TITLE                       21097

#define DLG_HISTITEMPROP                21180

#define IDD_INTERNET_ADDRESS            21280
#define IDD_LAST_VISITED                21281
#define IDD_LAST_UPDATED                21282
#define IDD_HSFURL                      21283
#define IDD_LAST_ACCESSED               21284
#define IDD_LAST_MODIFIED               21285
#define IDD_CACHE_NAME                  21286
#define IDD_NUMHITS                     21287

#define DLG_HISTCACHE_WARNING           21380
#define IDD_TEXT4                       21382

#endif

#ifndef POSTPOSTSPLIT
#define IDD_ADDTOFAVORITES_TEMPLATE     21400

#define IDC_SUBSCRIBE_CUSTOMIZE         1004

#define IDC_FAVORITE_NAME               1005
#define IDC_FAVORITE_CREATEIN           1006
#define IDC_FAVORITE_NEWFOLDER          1007
#define IDC_FAVORITE_ICON               1008

#define IDC_CHANNEL_NAME                1009
#define IDC_CHANNEL_URL                 1010
#define IDC_FOLDERLISTSTATIC            1011
#define IDC_NAMESTATIC                  1012

#endif
    //control id's for next 3 are important -- they're the id's
    //of the same object (non-placeholder) in dialog created
    //by SHBrowseForFolder.  REVIEW!
#define IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER 0x3741
#define IDOK_PLACEHOLDER                0001
#define IDCANCEL_PLACEHOLDER            0002


#define IDM_CLOSE               FCIDM_LAST + 0x0011

#define HELP_ITEM_COUNT         10

#define IDS_HELP_FIRST          0x4000
#define IDS_HELP_OF(id)         ((id - DVIDM_FIRST)+IDS_HELP_FIRST)
#define IDS_HELP_OPEN           IDS_HELP_OF(DVIDM_OPEN           )
#define IDS_HELP_SAVE           IDS_HELP_OF(DVIDM_SAVE           )
#define IDS_HELP_SAVEASFILE     IDS_HELP_OF(DVIDM_SAVEASFILE     )
#define IDS_HELP_PAGESETUP      IDS_HELP_OF(DVIDM_PAGESETUP      )
#define IDS_HELP_PRINT          IDS_HELP_OF(DVIDM_PRINT          )
#define IDS_HELP_SEND           IDS_HELP_OF(DVIDM_SEND           )
#define IDS_HELP_SENDPAGE       IDS_HELP_OF(DVIDM_SENDPAGE       )
#define IDS_HELP_SENDSHORTCUT   IDS_HELP_OF(DVIDM_SENDSHORTCUT   )
#define IDS_HELP_SENDTODESKTOP  IDS_HELP_OF(DVIDM_DESKTOPSHORTCUT)
#define IDS_HELP_IMPORTEXPORT   IDS_HELP_OF(DVIDM_IMPORTEXPORT   )
#define IDS_HELP_ADDSITE        IDS_HELP_OF(DVIDM_ADDSITE        )
#define IDS_HELP_TRUSTEDSITES   IDS_HELP_OF(DVIDM_TRUSTEDSITES   )
#define IDS_HELP_INTRANETSITES  IDS_HELP_OF(DVIDM_INTRANETSITES  )
#define IDS_HELP_PROPERTIES     IDS_HELP_OF(DVIDM_PROPERTIES     )
#define IDS_HELP_CUT            IDS_HELP_OF(DVIDM_CUT            )
#define IDS_HELP_COPY           IDS_HELP_OF(DVIDM_COPY           )
#define IDS_HELP_PASTE          IDS_HELP_OF(DVIDM_PASTE          )
#define IDS_HELP_STOPDOWNLOAD   IDS_HELP_OF(DVIDM_STOPDOWNLOAD   )
#define IDS_HELP_REFRESH        IDS_HELP_OF(DVIDM_REFRESH        )
#define IDS_HELP_GOHOME         IDS_HELP_OF(DVIDM_GOHOME         )
#define IDS_HELP_GOSEARCH       IDS_HELP_OF(DVIDM_GOSEARCH       )
#define IDS_HELP_NEWWINDOW      IDS_HELP_OF(DVIDM_NEWWINDOW      )
#define IDS_HELP_PRINTPREVIEW   IDS_HELP_OF(DVIDM_PRINTPREVIEW   )
#define IDS_HELP_PRINTFRAME     IDS_HELP_OF(DVIDM_PRINTFRAME     )
#define IDS_HELP_NEWMESSAGE     IDS_HELP_OF(DVIDM_NEWMESSAGE     )
#define IDS_HELP_DHFAVORITES    IDS_HELP_OF(DVIDM_DHFAVORITES    )
#define IDS_HELP_HELPABOUT      IDS_HELP_OF(DVIDM_HELPABOUT      )
#define IDS_HELP_HELPSEARCH     IDS_HELP_OF(DVIDM_HELPSEARCH     )
#define IDS_HELP_HELPTUTORIAL   IDS_HELP_OF(DVIDM_HELPTUTORIAL   )
#define IDS_HELP_HELPMSWEB      IDS_HELP_OF(DVIDM_HELPMSWEB      )

#define IDS_HELP_NEW            IDS_HELP_OF(DVIDM_NEW            )
#define IDS_HELP_NEWPOST        IDS_HELP_OF(DVIDM_NEWPOST        )
#define IDS_HELP_NEWAPPOINTMENT IDS_HELP_OF(DVIDM_NEWAPPOINTMENT )
#define IDS_HELP_NEWMEETING     IDS_HELP_OF(DVIDM_NEWMEETING     )
#define IDS_HELP_NEWCONTACT     IDS_HELP_OF(DVIDM_NEWCONTACT     )
#define IDS_HELP_NEWTASK        IDS_HELP_OF(DVIDM_NEWTASK        )
#define IDS_HELP_NEWTASKREQUEST IDS_HELP_OF(DVIDM_NEWTASKREQUEST )
#define IDS_HELP_NEWJOURNAL     IDS_HELP_OF(DVIDM_NEWJOURNAL     )
#define IDS_HELP_NEWNOTE        IDS_HELP_OF(DVIDM_NEWNOTE        )
#define IDS_HELP_CALL           IDS_HELP_OF(DVIDM_CALL           )

#define FCIDM_HELPNETSCAPEUSERS (DVIDM_HELPMSWEB+11)
#define FCIDM_HELPONLINESUPPORT (DVIDM_HELPMSWEB+4)
#define FCIDM_HELPSENDFEEDBACK  (DVIDM_HELPMSWEB+5)
#define FCIDM_PRODUCTUPDATES    (DVIDM_HELPMSWEB+2)

#define IDS_HELP_HELPNETSCAPEUSERS  IDS_HELP_OF(FCIDM_HELPNETSCAPEUSERS)
#define IDS_HELP_HELPONLINESUPPORT  IDS_HELP_OF(FCIDM_HELPONLINESUPPORT)
#define IDS_HELP_HELPSENDFEEDBACK   IDS_HELP_OF(FCIDM_HELPSENDFEEDBACK)
#define IDS_HELP_PRODUCTUPDATES     IDS_HELP_OF(FCIDM_PRODUCTUPDATES)
#define IDS_HELP_ADDTOFAVORITES     IDS_HELP_OF(FCIDM_ADDTOFAVORITES)
#define IDS_HELP_ORGANIZEFAVORITES  IDS_HELP_OF(FCIDM_ORGANIZEFAVORITES)



#define IDS_MAYSAVEDOCUMENT     0x201
#define IDS_CANTACCESSDOCUMENT  0x202


#define IDS_SSL40               0x205
#define IDS_SSL128              0x206
#define IDS_SSL_FORTEZZA        0x207
#define IDS_SSL56               0x208

// END
//

// We pull this resource from browseui.  Don't change this ID unless
// you change browseui to match!!!  [Similar note in browseui]
#define IDB_IEBRAND             0x130


#define DELTA_HOT 1                     // HOT icons are def icons +1

#define IDB_CLASSIC_IETOOLBAR           0x145
#define IDB_CLASSIC_IETOOLBARHOT        0x146   // IDB_IETOOLBAR + DELTA_HOT
#define IDB_CLASSIC_IETOOLBAR16         0x147
#define IDB_CLASSIC_IETOOLBARHOT16      0x148   // IDB_IETOOLBAR16 + DELTA_HOT
#define IDB_CLASSIC_IETOOLBARHICOLOR    0x149
#define IDB_CLASSIC_IETOOLBARHOTHICOLOR 0x14A   // IDB_IETOOLBARHICOLOR + DELTA_HOT


#define IDS_BROWSER_TB_LABELS   0x14F   // string table for cut copy paste encoding

// For splash screen
#define IDB_SPLASH_IEXPLORER    0x150
#define IDB_SPLASH_IEXPLORER_HI 0x151
#define IDS_SPLASH_FONT         0x152
#define IDS_SPLASH_STR1         0x153
#define IDS_SPLASH_STR2         0x154
#define IDS_SPLASH_SIZE         0x155
#define IDS_SPLASH_Y1           0x156
#define IDS_SPLASH_Y2           0x157


// constants for download dialogs
#define IDB_DOWNLOAD            0x215

#define IDB_HISTORYANDFAVBANDSDEF  0x216
#define IDB_HISTORYANDFAVBANDSHOT  0x217

// ReBar stuff
#define IDS_SUBSTR_PRD           0x22C
#define IDS_SUBSTR_PVER          0x22D

#define IDS_BAND_MESSAGE         0x232

// OC stuff
//
#define IDS_VERB_EDIT           0x240

// Progress bar text
#define IDS_BINDSTATUS          0x260
#define IDS_BINDSTATUS_FIN      0x261 // (IDS_BINDSTATUS+BINDSTATUS_FINDINGRESOURCE)
#define IDS_BINDSTATUS_CON      0x262 // (IDS_BINDSTATUS+BINDSTATUS_CONNECTING)
#define IDS_BINDSTATUS_RED      0x263 // (IDS_BINDSTATUS+BINDSTATUS_REDIRECTING)
#define IDS_BINDSTATUS_BEG      0x264 // (IDS_BINDSTATUS+BINDSTATUS_BEGINDOWNLOADDATA)
#define IDS_BINDSTATUS_DOW      0x265 // (IDS_BINDSTATUS+BINDSTATUS_DOWNLOADINGDATA  )
#define IDS_BINDSTATUS_END      0x266 // (IDS_BINDSTATUS+BINDSTATUS_ENDDOWNLOADDATA  )
#define IDS_BINDSTATUS_BEGC     0x267 // (IDS_BINDSTATUS+BINDSTATUS_BEGINDOWNLOADCOMPONENTS)
#define IDS_BINDSTATUS_INSC     0x268 // (IDS_BINDSTATUS+BINDSTATUS_INSTALLINGCOMPONENTS        )
#define IDS_BINDSTATUS_ENDC     0x269 // (IDS_BINDSTATUS+BINDSTATUS_ENDDOWNLOADCOMPONENTS)
#define IDS_BINDSTATUS_USEC     0x26a // (IDS_BINDSTATUS+BINDSTATUS_USINGCACHEDCOPY)
#define IDS_BINDSTATUS_SEND     0x26b // (IDS_BINDSTATUS+BINDSTATUS_SENDINGREQUEST )
#define IDS_BINDSTATUS_PROXYDETECTING 0x26c 



// Registration Strings
//


#define IDS_REG_HTTPNAME        0x350
#define IDS_REG_HTTPSNAME       0x351
#define IDS_REG_FTPNAME         0x352
#define IDS_REG_GOPHERNAME      0x353
#define IDS_REG_TELNETNAME      0x354
#define IDS_REG_RLOGINNAME      0x355
#define IDS_REG_TN3270NAME      0x356
#define IDS_REG_MAILTONAME      0x357
#define IDS_REG_NEWSNAME        0x358
#define IDS_REG_FILENAME        0x359
#define IDS_REG_INTSHNAME       0x35a
#define IDS_REG_THEINTERNET     0x35b
#define IDS_REG_URLEXECHOOK     0x35c
#define IDS_REG_OPEN            0x35d
#define IDS_REG_OPENSAME        0x35e
#define IDS_REG_SCFTYPENAME     0x35f
#define IDS_RELATEDSITESMENUTEXT    0x360   // 864
#define IDS_RELATEDSITESSTATUSBAR   0x361   // 865
#define IDS_RELATEDSITESBUTTONTEXT  0x362   // 866
#define IDS_TIPOFTHEDAYTEXT         0x363   // 867
#define IDS_TIPOFTHEDAYSTATUSBAR    0x364   // 868

#define IDS_INTERNETEXPLORER        0x370   // 880
#define IDS_INTERNETEXPLORER_TIP    0x371   // 881

////  3d0- 420 reserved for quick links

#define IDS_TYPELIB             0x4f0
#define IDS_SHELLEXPLORER       0x4f1
//                              0x4f2

#define IDS_CATDESKBAND         0x502

#define IDS_CATINFOBAND         0x504

#define IDS_CATCOMMBAND         0x509

#define IDS_ERRMSG_FIRST        0x1000
#define IDS_ERRMSG_LAST         0x1fff

// OC Bitmaps
//
#define IDB_FOLDER              0x101 // used in selfreg.inf
#define IDB_FOLDERVIEW          0x104 // used in selfreg.inf

// Dialog Boxes
#define DLG_DOWNLOADPROGRESS    0x1100
#define IDD_ANIMATE             0x1101
#define IDD_NAME                0x1102
#define IDD_OPENIT              0x1103
#define IDD_PROBAR              0x1104
#define IDD_TIMEEST             0x1105
#define IDD_SAVEAS              0x1106
#define IDD_DOWNLOADICON        0x1107
#define IDD_NOFILESIZE          0x1109
#define IDD_TRANSFERRATE        0x1110
#define IDD_DIR                 0x1112
#define IDD_DISMISS             0x1113
#define IDD_DNLDCOMPLETEICON    0x1114
#define IDD_DNLDCOMPLETETEXT    0x1115
#define IDD_DNLDESTTIME         0x1116
#define IDD_DNLDTIME            0x1117
#define IDD_BROWSEDIR           0x1118
#define IDD_OPENFILE            0x1119

#define DLG_SAFEOPEN            0x1140
#define IDC_SAFEOPEN_ICON       0x1141
#define IDC_SAFEOPEN_FILENAME   0x1142
#define IDC_SAFEOPEN_AUTOOPEN   0x1143
#define IDC_SAFEOPEN_AUTOSAVE   0x1144
#define IDC_SAFEOPEN_ALWAYS     0x1145
#define IDC_SAFEOPEN_FILETYPE   0x1146
#define IDC_SAFEOPEN_FILEFROM   0x1147
#define IDC_SAFEOPEN_WARNICON   0x1148
#define IDC_SAFEOPEN_WARNTEXT   0x1149

#define IDD_ASSOC               0x1160
#define IDC_ASSOC_CHECK         0x1161
#define IDC_ASSOC_IE40          0x1163

#define IDD_PRINTOPTIONS        0x1165

#define DLG_RUN                 0x1170
#define IDD_ICON                0x1171
#define IDD_PROMPT              0x1172
#define IDD_COMMAND             0x1173
#define IDD_RUNDLGOPENPROMPT    0x1174
#define IDD_BROWSE              0x1175
#define IDC_ASWEBFOLDER         0x1176

#define DLG_NEWFOLDER           0x1180
#define IDD_SUBSCRIBE           0x1185

// UNIX only
#define DLG_RUNMOTIF            0x1187


// Resources for Internet Shortcut dialogs

#define IDD_INTSHCUT_PROP               1048
#undef IDC_ICON         // The one defined in winuser is obsolete
#define IDC_ICON                        1002
#define IDC_NAME                        1003
#define IDC_URL_TEXT                    1004
#define IDC_URL                         1005
#define IDC_HOTKEY_TEXT                 1006
#define IDC_START_IN_TEXT               1007
#define IDC_START_IN                    1008
#define IDC_SHOW_CMD                    1009
#define IDC_CHANGE_ICON                 1010
#define IDC_HOTKEY                      1011

#define IDC_WHATSNEW                    1011
#define IDC_RATING                      1012
#define IDC_AUTHOR                      1013
#define IDC_LAST_VISITED                1014
#define IDC_LAST_MODIFIED               1015
#define IDC_VISITCOUNT                  1016
#define IDC_DESC                        1017

#define IDC_VISITS_TEXT                 1018
#define IDC_VISITS                      1019
#define IDC_MAKE_OFFLINE                1020
#define IDC_SUMMARY                     1021
#define IDC_LAST_SYNC_TEXT              1022
#define IDC_LAST_SYNC                   1023
#define IDC_DOWNLOAD_SIZE_TEXT          1024
#define IDC_DOWNLOAD_SIZE               1025
#define IDC_DOWNLOAD_RESULT_TEXT        1026
#define IDC_DOWNLOAD_RESULT             1027
#define IDC_FAVORITE_DESC               1028
#define IDC_FREESPACE_TEXT              1029

#define IDS_ALLFILES                    1200
#define IDS_BROWSEFILTER                1201
#define IDS_DOWNLOADFAILED              1202
#define IDS_TRANSFERRATE                1203
#define IDS_DOWNLOADTOCACHE             1204
#define IDS_UNTITLE_SHORTCUT            1205
#define IDS_SECURITYALERT               1206
#define IDS_DOWNLOADDISALLOWED          1207
// unused - recycle me                  1208
#define IDS_URL_SEARCH_KEY              1210
#define IDS_SEARCH_URL                  1211
#define IDS_SEARCH_SUBSTITUTIONS        1212
#define IDS_SHURL_ERR_PARSE_NOTALLOWED  1213
#define IDS_SEARCH_INTRANETURL          1214

// UNIX only
#define IDS_SHURL_ERR_NOASSOC           1215
#define IDS_DOWNLOAD_BADCACHE           1216


#define IDS_SETHOME_TITLE               1220
#define IDS_SETHOME_TEXT                1221

// Warning strings must be sequential.
#define IDS_ADDTOFAV_WARNING            1230
#define IDS_ADDTOLINKS_WARNING          1231
#define IDS_MAKEHOME_WARNING            1232
#define IDS_DROP_WARNING                1233

#define IDS_CONFIRM_RESET_SAFEMODE      1526

// Internet shortcut-related IDs
#define IDS_SHORT_NEW_INTSHCUT              0x2730
#define IDS_NEW_INTSHCUT                    0x2731
#define IDS_INVALID_URL_SYNTAX              0x2732
#define IDS_UNREGISTERED_PROTOCOL           0x2733
#define IDS_SHORTCUT_ERROR_TITLE            0x2734
#define IDS_IS_EXEC_FAILED                  0x2735
#define IDS_IS_EXEC_OUT_OF_MEMORY           0x2736
#define IDS_IS_EXEC_UNREGISTERED_PROTOCOL   0x2737
#define IDS_IS_EXEC_INVALID_SYNTAX          0x2738
#define IDS_IS_LOADFROMFILE_FAILED          0x2739
#define IDS_INTERNET_SHORTCUT               0x273E
#define IDS_URL_DESC_FORMAT                 0x273F
#define IDS_FAV_LASTVISIT                   0x2740
#define IDS_FAV_LASTMOD                     0x2741
#define IDS_FAV_WHATSNEW                    0x2742
#define IDS_IS_APPLY_FAILED                 0x2744
#define IDS_FAV_STRING                      0x2745

#define IDS_AUTHOR                          0x2746
#define IDS_SUBJECT                         0x2747
#define IDS_COMMENTS                        0x2748
#define IDS_DOCTITLE                        0x2749

#define IDS_MENUOPEN                        0x2800
#define IDS_MENUOPENHOMEPAGE                0x2801

// Open Web Folder Dialogs
#define IDS_ERRORINTERNAL                   0x2940

// Internet shortcut menu help
#define IDS_MH_ISFIRST                      0x2750
#define IDS_MH_OPEN                         (IDS_MH_ISFIRST + 0)
#define IDS_MH_SYNCHRONIZE                  (IDS_MH_ISFIRST + 1)
#define IDS_MH_MAKE_OFFLINE                 (IDS_MH_ISFIRST + 2)

// AVI
#define IDA_DOWNLOAD            0x100




//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

// REARCHITECT: these are duplicated in browseui

// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0120)

#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_DELETE            (FCIDM_BROWSER_FILE+0x0003)
#define FCIDM_RENAME            (FCIDM_BROWSER_FILE+0x0004)
#define FCIDM_PROPERTIES        (FCIDM_BROWSER_FILE+0x0005)

#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut

#define FCIDM_FAVS_FIRST        (FCIDM_BROWSER_EXPLORE  +0x0052)
#define FCIDM_ORGANIZEFAVORITES (FCIDM_FAVS_FIRST       +0x0000)
#define FCIDM_ADDTOFAVORITES    (FCIDM_FAVS_FIRST       +0x0001)
#define FCIDM_FAVS_MORE         (FCIDM_FAVS_FIRST       +0x0002)
#define FCIDM_FAVORITEFIRST     (FCIDM_FAVS_FIRST       +0x0003)
#define FCIDM_UPDATESUBSCRIPTIONS (FCIDM_FAVS_FIRST       +0x0004)
#define FCIDM_SORTBY            (FCIDM_FAVS_FIRST       +0x0005)
#define FCIDM_SORTBYNAME        (FCIDM_FAVS_FIRST       +0x0006)
#define FCIDM_SORTBYVISIT       (FCIDM_FAVS_FIRST       +0x0007)
#define FCIDM_SORTBYDATE        (FCIDM_FAVS_FIRST       +0x0008)
#define FCIDM_FAVAUTOARRANGE    (FCIDM_FAVS_FIRST       +0x0009)
#define FCIDM_SUBSCRIPTIONS     (FCIDM_FAVS_FIRST       +0x000A)
#define FCIDM_SUBSCRIBE         (FCIDM_FAVS_FIRST       +0x000B)

#define FCIDM_FAVORITELAST      (FCIDM_FAVORITEFIRST    +0x0050)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVS_FIRST)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)
#define FCIDM_FAVS_LAST         (FCIDM_FAVORITELAST)


//---------------------------------------------------------------------------
#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST + 0x0200)
#define FCIDM_VIEWTOOLBAR       (FCIDM_BROWSER_VIEW + 0x0001)
#define FCIDM_VIEWSTATUSBAR     (FCIDM_BROWSER_VIEW + 0x0002)
#define FCIDM_VIEWOPTIONS       (FCIDM_BROWSER_VIEW + 0x0003)
#define FCIDM_VIEWTOOLS         (FCIDM_BROWSER_VIEW + 0x0004)
#define FCIDM_VIEWADDRESS       (FCIDM_BROWSER_VIEW + 0x0005)
#define FCIDM_VIEWLINKS         (FCIDM_BROWSER_VIEW + 0x0006)
#define FCIDM_VIEWTEXTLABELS    (FCIDM_BROWSER_VIEW + 0x0007)
#define FCIDM_VIEWTBCUST        (FCIDM_BROWSER_VIEW + 0x0008)
#define FCIDM_VIEWAUTOHIDE      (FCIDM_BROWSER_VIEW + 0x0009)
#define FCIDM_VIEWMENU          (FCIDM_BROWSER_VIEW + 0x000A)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_REFRESH           (FCIDM_BROWSER_VIEW + 0x0020) // ie4 shell32: must be A220 (cannot change)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)
// 1d - FCIDM_VIEWTOOLBARCUSTOMIZE
#define FCIDM_ENCODING          (FCIDM_BROWSER_VIEW + 0x001e)
// (FCIDM_BROWSER_VIEW + 0x0030) through
// (FCIDM_BROWSER_VIEW + 0x003f) is taken

// Define string ids that go into resource file
#define IDS_CHANNEL             0x503

#define IDS_SUBS_UNKNOWN        711
#ifndef POSTPOSTSPLIT
#define IDS_NEED_CHANNEL_PASSWORD     716
#endif


// REARCHITECT: these are duplciated in browseui
#define IDS_TITLE       723
#define IDS_ERROR_GOTO  724
// END

#define IDS_NONE        725
#define IDS_NAME        726     // Used for NAME member function for fram programmability

#define IDS_INVALIDURL   727    // Generic error message in OnStopBinding
#define IDS_CANTDOWNLOAD 728
#define IDS_TARGETFILE   730    // String for target file of downloading
#define IDS_DOWNLOADCOMPLETE 731 // Download completed

#define IDS_CREATE_SHORTCUT_MSG 734
#define IDS_UNDEFINEDERR 735
#define IDS_SAVING       736
#define IDS_OPENING      737

#define IDS_ESTIMATE    738     // Estimated time string for progress (B/sec)
// 739 below
#define IDS_SAVED       740
#define IDS_BYTESCOPIED 741     // Progress text when ulMax is 0 (unknown)
#define IDS_DEF_UPDATE  742
#define IDS_DEF_CHANNELGUIDE 743
#define IDS_DOCUMENT    744
#define IDS_ERR_OLESVR  745     // CoCreateInstance failed.
#define IDS_ERR_LOAD    746     // IPersistFile::Load failed.

#ifndef POSTPOSTSPLIT
#define IDS_FAVORITES          749
#define IDS_FAVORITEBROWSE     748

#define IDS_FAVS_SUBSCRIBE_TEXT 718
#define IDS_FAVS_SUBSCRIBE      719
#define IDS_FAVS_ADVANCED      753
#define IDS_FAVS_ADDTOFAVORITES 757
#define IDS_FAVS_FILEEXISTS     794
#define IDS_FAVS_INVALIDFN      795
#define IDS_FAVS_ADVANCED_EXPAND   812
#define IDS_FAVS_ADVANCED_COLLAPSE 813
#define IDS_FAVS_FNTOOLONG      810


#define IDS_EXCEPTIONMSGSH 739
#define IDS_EXCEPTIONMSG        754
#define IDS_EXCEPTIONNOMEMORY   755
#endif

#define IDS_CANTSHELLEX         756     // Shell Execute on the URL failed

#define IDS_TITLEBYTES          760   // Download title with % loaded
#define IDS_TITLEPERCENT        761     // Download title with bytes copied
#define IDS_HELPTUTORIAL        762

#define IDS_HELPMSWEB           763
// Don't use 763=779 because they are used by HELPMSWEB strings

// Don't use 780=790 because they wil be used by different URLs used in the product

#define IDS_DEFDLGTITLE         790

#define IDS_EXCHANGE            791 // Exchange mail client display name

#define IDS_CANTFINDURL         793 // Autosearching prompt on failed navigation

#ifndef POSTPOSTSPLIT
#define IDS_CHANNELS_FILEEXISTS 796
#endif
#define IDS_BYTESTIME           797
#define IDS_CANTFINDSEARCH      799
#define IDS_CLOSE               800
#define IDS_EXTDOCUMENT         811

#define IDS_OPENFROMINTERNET    920
#define IDS_SAVEFILETODISK      921
#define IDS_SAFEOPENPROMPT      922
#define IDS_HELPIESEC           923

// Coolbar String IDs - starting from 950

////////////////// WARNING!!!  /////////////////
///  IDS_QLURL1 MUST be 1000, IDS_QLTEXT1 MUST BE 1010
// inetcpl depends on it ..  -Chee
// also, inetcpl hard codes that there are 5 quicklinks!
#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

//////////////////////// END WARNING! //////////////////////


#define IDS_FOLDEROPTIONS       1030
#define IDS_INTERNETOPTIONS     1031


#define IDS_CONFIRM_RESETFLAG           1060

// Accelerator ID

#define ACCEL_DOCVIEW             0x101
#define ACCEL_DOCVIEW_NOFILEMENU  0x102
#define ACCEL_FAVBAR              0x103

#define MID_FOCUS               0x102

#define MENU_SCRDEBUG                   0x103


//#ifdef DEBUG
#define ALPHA_WARNING_IS_DUMB
//#endif

#ifndef ALPHA_WARNING_IS_DUMB
#define IDS_ALPHAWARNING        0x2000
#endif



// Title for properties dialog
#define IDS_INTERNETSECURITY    0x2003
// ID for running uninstall stubs
#define IDS_UNINSTALL         0x3010

#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

// OPSProfile strings (0x3100 to 0x31BF)
#define IDR_TRACK                       0x3101

#define IDS_OPS_REQUEST                 0x3100
#define IDS_PROFILE_ASSISTANT           0x3101
#define IDS_OPS_CONFIRM                 0x3102
#define IDS_OPS_BLANK                   0x3103
#define IDS_OPS_NO_INFORMATION          0x3104

#define IDS_DEFAULT_FNAME               0x3140

#define IDS_OPS_COMMONNAME              0x3150
#define IDS_OPS_GIVENNAME               0x3151
#define IDS_OPS_LASTNAME                0x3152
#define IDS_OPS_MIDDLENAME              0x3153
#define IDS_OPS_GENDER                  0x3154
#define IDS_OPS_CELLULAR                0x3155
#define IDS_OPS_EMAIL                   0x3156
#define IDS_OPS_URL                     0x3157

#define IDS_OPS_COMPANY                 0x3158
#define IDS_OPS_DEPARTMENT              0x3159
#define IDS_OPS_JOBTITLE                0x315a
#define IDS_OPS_PAGER                   0x315b

#define IDS_OPS_HOME_ADDRESS            0x315c
#define IDS_OPS_HOME_CITY               0x315d
#define IDS_OPS_HOME_ZIPCODE            0x315e
#define IDS_OPS_HOME_STATE              0x315f
#define IDS_OPS_HOME_COUNTRY            0x3160
#define IDS_OPS_HOME_PHONE              0x3161
#define IDS_OPS_HOME_FAX                0x3162

#define IDS_OPS_BUSINESS_ADDRESS        0x3163
#define IDS_OPS_BUSINESS_CITY           0x3164
#define IDS_OPS_BUSINESS_ZIPCODE        0x3165
#define IDS_OPS_BUSINESS_STATE          0x3166
#define IDS_OPS_BUSINESS_COUNTRY        0x3167

#define IDS_OPS_BUSINESS_PHONE          0x3168
#define IDS_OPS_BUSINESS_FAX            0x3169
#define IDS_OPS_BUSINESS_URL            0x316a

#define IDS_OPS_OFFICE                  0x316b

#define IDS_NAVIGATEBACKTO              0x3170
#define IDS_NAVIGATEFORWARDTO           0x3171

// Usage strings. These have to be contiguous
#define IDS_OPS_USAGEUNK                0x31A0
#define IDS_OPS_USAGE0                  0x31A1
#define IDS_OPS_USAGE1                  0x31A2
#define IDS_OPS_USAGE2                  0x31A3
#define IDS_OPS_USAGE3                  0x31A4
#define IDS_OPS_USAGE4                  0x31A5
#define IDS_OPS_USAGE5                  0x31A6
#define IDS_OPS_USAGE6                  0x31A7
#define IDS_OPS_USAGE7                  0x31A8
#define IDS_OPS_USAGE8                  0x31A9
#define IDS_OPS_USAGE9                  0x31AA
#define IDS_OPS_USAGE10                 0x31AB
#define IDS_OPS_USAGE11                 0x31AC
#define IDS_OPS_USAGE12                 0x31AD
#define IDS_OPS_USAGEMAX                0x31AD

// Dialogs and controls.
#define IDD_OPS_CONSENT                 0x3200
#define IDD_OPS_UPDATE                  0x3201

#define IDC_OPS_LIST                    0x3210
#define IDC_VIEW_CERT                   0x3211
#define IDC_USAGE_STRING                0x3212
#define IDC_SITE_IDENTITY               0x3213
#define IDC_SECURITY_ICON               0x3214
#define IDC_USAGE_ICON                  0x3215
#define IDC_SECURE_CONNECTION           0x3216
#define IDC_UNSECURE_CONNECTION         0x3217
#define IDC_OPS_URL                     0x3218
#define IDC_EDIT_PROFILE                0x3219
#define IDC_KEEP_SETTINGS               0x321A
#define IDC_OPS_INFO_REQUESTED          0x321B
#define IDC_OPS_PRIVACY                 0x321C

// AutoSuggest dialogs and controls
#define IDD_AUTOSUGGEST_SAVEPASSWORD    0x3220
#define IDD_AUTOSUGGEST_CHANGEPASSWORD  0x3221
#define IDD_AUTOSUGGEST_DELETEPASSWORD  0x3222
#define IDD_AUTOSUGGEST_ASK_USER        0x3223
#define IDC_AUTOSUGGEST_NEVER           0x3225
#define IDC_AUTOSUGGEST_ICON            0x3226
#define IDA_AUTOSUGGEST                 0x3227
//#define IDI_AUTOSUGGEST                 0x3228
#define IDC_AUTOSUGGEST_HELP            0x324F

// Software Update Advertisment Dialogs
#define IDD_SUAVAILABLE                 0x3300
#define IDD_SUDOWNLOADED               0x3301
#define IDD_SUINSTALLED                0x3302

//ids for DLG_SUAVAIL, DLG_SUDOWNLOAD, DLG_SUINSTALL
#define IDC_ICONHOLD                    0x3310
#define IDC_REMIND                      0x3311
#define IDC_DETAILS                     0x3312
#define IDC_DETAILSTEXT                 0x3313

#define IDS_SUDETAILSFMT                0x3320
#define IDS_SUDETAILSOPEN               0x3321
#define IDS_SUDETAILSCLOSE              0x3322

#define IDS_HISTVIEW_FIRST              0x3331
#define IDS_HISTVIEW_DEFAULT            0x3331
#define IDS_HISTVIEW_SITE               0x3332
#define IDS_HISTVIEW_FREQUENCY          0x3333
#define IDS_HISTVIEW_TODAY              0x3334
#define IDS_HISTVIEW_LAST               0x3335

#define IDS_DONE_WITH_SCRIPT_ERRORS     0x3336
#define IDS_SCRIPT_ERROR_ON_PAGE        0x3337

/* ID for install stub progress dialog (template in \shell\inc\inststub.rc) */
#define IDD_InstallStubProgress         0x3340


// IDs for thicket save
#define IDD_SAVETHICKET                 0x3350
#define IDC_THICKETPROGRESS             0x3351
#define IDC_THICKETSAVING               0x3352
#define IDC_THICKETPCT                  0x3353

#define IDS_THICKETDIRFMT               0x3354
#define IDS_THICKETTEMPFMT              0x3355
#define IDS_THICKET_SAVE                0x3356
#define IDS_NOTHICKET_SAVE              0x3357
#define IDS_UNTITLED                    0x3358

#define IDD_ADDTOSAVE_DIALOG            0x3359
#define IDC_SAVE_CHARSET                0x335A

#define IDS_THICKETERRTITLE             0x335B
#define IDS_THICKETERRMEM               0x335C
#define IDS_THICKETERRMISC              0x335D
#define IDS_THICKETERRACC               0x335E
#define IDS_THICKETERRFULL              0x335F
#define IDS_THICKETABORT                0x3360
#define IDS_THICKETSAVINGFMT            0x3361
#define IDS_THICKETPCTFMT               0x3362
#define IDS_THICKETERRFNF               0x3363
#define IDS_NOMHTML_SAVE                0x3364

#define IDD_ADDTOSAVE_NT5_DIALOG        0x3365

#define IDD_IMPEXP                      0x3380
#define IDC_IMPORT                      0x3381
#define IDC_EXPORT                      0x3382
#define IDC_FAVORITES                   0x3383
#define IDC_BROWSEFORFAVORITES          0x3384

#define IDS_IMPORTCONVERTERROR          0x3385
#define IDS_NOTVALIDBOOKMARKS           0x3386
#define IDS_COULDNTOPENBOOKMARKS        0x3387
#define IDS_IMPORTFAILURE_FAV           0x3388
#define IDS_IMPORTSUCCESS_FAV           0x3389
#define IDS_EXPORTFAILURE_FAV           0x338A
#define IDS_EXPORTSUCCESS_FAV           0x338B
#define IDS_IMPORTFAILURE_COOK          0x338C
#define IDS_IMPORTSUCCESS_COOK          0x338D
#define IDS_EXPORTFAILURE_COOK          0x338E
#define IDS_EXPORTSUCCESS_COOK          0x338F
#define IDS_EXPORTDIALOGTITLE           0x3390
#define IDS_IMPORTDIALOGTITLE           0x3391
#define IDS_INVALIDURLFILE              0x3392
#define IDS_CONFIRM_IMPTTL_FAV          0x3393
#define IDS_CONFIRM_EXPTTL_FAV          0x3394
#define IDS_CONFIRM_IMPTTL_COOK         0x3395
#define IDS_CONFIRM_EXPTTL_COOK         0x3396
#define IDS_CONFIRM_IMPORT              0x3397
#define IDS_CONFIRM_EXPORT              0x3398
#define IDS_IMPORT_DISABLED             0x3399
#define IDS_EXPORT_DISABLED             0x339A
#define IDS_IMPORTEXPORTTITLE           0x339B

// Save-as warning dialog
#define DLG_SAVEAS_WARNING              0x3400
#define IDC_SAVEAS_WARNING_STATIC       0x3401
#define IDC_SAVEAS_WARNING_CB           0x3402
#define IDI_SAVEAS_WARNING              0x3403

// HTML dialog resources
#define RT_FILE                         2110

// Print dialog
#define IDC_LINKED                          8140
#define IDC_PREVIEW                         8141
#define IDC_SHORTCUTS                       8142
#define IDC_SCALING                         8143

// Page setup

#define IDC_HEADERFOOTER                    8145
#define IDC_STATICHEADER                    8146
#define IDC_EDITHEADER                      8147
#define IDC_STATICFOOTER                    8148
#define IDC_EDITFOOTER                      8149

#define IDR_PRINT_PREVIEW               8416
#define IDR_PRINT_PREVIEWONEDOC         8417
#define IDR_PRINT_PREVIEWALLDOCS        8418
#define IDR_PRINT_PREVIEWDISABLED       8422

#define IDS_PRINTTOFILE_TITLE           8419
#define IDS_PRINTTOFILE_OK              8420
#define IDS_PRINTTOFILE_SPEC            8421

///////////////////////////////////////////////////////
// Favorites, nsc, and explorer bars
#define IDS_FAVS_BAR_LABELS     3000
#define IDS_HIST_BAR_LABELS     3001
#define IDI_PINNED              3002
#define IDS_SEARCH_MENUOPT      3003
#define IDS_BAND_FAVORITES      3004
#define IDS_BAND_HISTORY        3005
#define IDS_BAND_CHANNELS       3006

#define IDS_RESTRICTED          3007
#define IDS_BAND_EXPLORER       3008
// (see histBand.cpp for more info...)
#define FCIDM_HISTBAND_FIRST      (FCIDM_BROWSERFIRST   + 0x0180)
#define FCIDM_HISTBAND_VIEW       (FCIDM_HISTBAND_FIRST + 0x0000)
#define FCIDM_HISTBAND_SEARCH     (FCIDM_HISTBAND_FIRST + 0x0001)

#define IDC_EDITHISTSEARCH       3205
#define IDD_HISTSRCH_ANIMATION   3206
#define IDA_HISTSEARCHAVI        3207
#define IDB_HISTSRCH_GO          3208
#define IDC_HISTSRCH_STATIC      3209
#define IDC_HISTCUSTOMLINE       3210

#define DLG_HISTSEARCH2          3211

#define POPUP_CONTEXT_NSC        3400

///////////////////////////////////////////////////////

// Flavors of refresh
#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

// placeholder for context menu extensions
#define IDM_MENUEXT_PLACEHOLDER          6047
#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range
#define IDR_BROWSE_CONTEXT_MENU     24641  //0x6041  // bad id - not in core range


#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#define IDM_DEBUG_METERS            6014
#define IDM_DEBUG_DUMPDISPLAYTREE   6015
#define IDM_DEBUG_DUMPFORMATCACHES  6016
#define IDM_DEBUG_DUMPLAYOUTRECTS   6017


#ifdef UNIX
//EULA related entries
#define IDD_EULA                        0x4000
#define IDC_WIZARD                      0x4001
#define IDC_EULA_TEXT                   0x4002
#define IDC_ACCEPT                      0x4003
#define IDC_DONT_ACCEPT                 0x4004
#define IDC_MORE                        0x4005
#define IDC_BIGFONT                     0x4006
#define IDD_ALPHAWRNDLG                 0x4007
#define IDC_NOFUTUREDISPLAY             0x4008
#define IDC_ALIAS_NAME                  0x4009

#define IDS_NEWS_SCRIPT_ERROR           0x4010
#define IDS_NEWS_SCRIPT_ERROR_TITLE     0x4011

#define IDI_MONOFRAME                   0x4020

#define IDS_NS_BOOKMARKS_DIR               137
#endif


#define IDS_IMPFAVORITES                0x4201
#define IDS_IMPFAVORITESDESC            0x4202
#define IDS_EXPFAVORITES                0x4203
#define IDS_EXPFAVORITESDESC            0x4204
#define IDS_IMPCOOKIES                  0x4205
#define IDS_IMPCOOKIESDESC              0x4206
#define IDS_EXPCOOKIES                  0x4207
#define IDS_EXPCOOKIESDESC              0x4208
#define IDS_IMPEXPTRANSFERTYPE_TITLE    0x4209
#define IDS_IMPEXPTRANSFERTYPE_SUBTITLE 0x420A
#define IDS_IMPEXPIMPFAVSRC_TITLE       0x420B
#define IDS_IMPEXPIMPFAVSRC_SUBTITLE    0x420C
#define IDS_IMPEXPIMPFAVDES_TITLE       0x420D
#define IDS_IMPEXPIMPFAVDES_SUBTITLE    0x420E
#define IDS_IMPEXPEXPFAVSRC_TITLE       0x420F
#define IDS_IMPEXPEXPFAVSRC_SUBTITLE    0x4210
#define IDS_IMPEXPEXPFAVDES_TITLE       0x4211
#define IDS_IMPEXPEXPFAVDES_SUBTITLE    0x4212
#define IDS_IMPEXPIMPCKSRC_TITLE        0x4213
#define IDS_IMPEXPIMPCKSRC_SUBTITLE     0x4214
#define IDS_IMPEXPEXPCKDES_TITLE        0x4215
#define IDS_IMPEXPEXPCKDES_SUBTITLE     0x4216
#define IDS_IMPEXP_FILEEXISTS           0x4217
#define IDS_IMPEXP_FILENOTFOUND         0x4218
#define IDS_IMPEXP_COMPLETE_IMPCK       0x4219
#define IDS_IMPEXP_COMPLETE_EXPCK       0x421A
#define IDS_IMPEXP_COMPLETE_IMPFV       0x421B
#define IDS_IMPEXP_COMPLETE_EXPFV       0x421C
#define IDS_IMPEXP_CAPTION              0x421D
#define IDS_NS3_VERSION_CAPTION         0x421E
#define IDS_NS4_FRIENDLY_PROFILE_NAME   0x421F
#define IDS_FB_FRIENDLY_PROFILE_NAME    0x4220
#define IDS_IMPEXP_CHOSEBOOKMARKFILE    0x4221
#define IDS_IMPEXP_CHOSECOOKIEFILE      0x4222
#define IDS_IMPEXP_BOOKMARKFILTER       0x4223
#define IDS_IMPEXP_COOKIEFILTER         0x4224

#define IDS_NETSCAPE_COOKIE_FILE        0x4225
#define IDS_NETSCAPE_BOOKMARK_FILE      0x4226
#define IDS_NETSCAPE_USERS_DIR          0x4227

#define IDC_IMPEXPACTIONDESCSTATIC      0x4261
#define IDC_IMPEXPBROWSE                0x4262
#define IDC_IMPEXPFAVTREE               0x4263

#define IDD_IMPEXPWELCOME               0x4264
#define IDD_IMPEXPTRANSFERTYPE          0x4265
#define IDD_IMPEXPIMPFAVSRC             0x4266
#define IDD_IMPEXPIMPFAVDES             0x4267
#define IDD_IMPEXPEXPFAVSRC             0x4268
#define IDD_IMPEXPEXPFAVDES             0x4269
#define IDD_IMPEXPIMPCKSRC              0x4270
#define IDD_IMPEXPEXPCKDES              0x4271
#define IDD_IMPEXPCOMPLETE              0x4272
#define IDC_IMPEXPACTIONLISTBOX         0x4273
#define IDC_IMPEXPEXTERNALCOMBO         0x4274
#define IDC_IMPEXPMANUAL                0x4275
#define IDC_IMPEXPRADIOAPP              0x4276
#define IDC_IMPEXPRADIOFILE             0x4287
#define IDC_IMPEXPTITLETEXT             0x4288
#define IDC_IMPEXPCOMPLETECONFIRM       0x4289

#define IDB_IMPEXPWATERMARK             0x428A
#define IDB_IMPEXPHEADER                0x428B

#define IDS_MIME_SAVEAS_HEADER_FROM     0x4300
#define IDS_SAVING_STATUS_TEXT          0x4301

#define IDS_CACHECLN_DISPLAY            0x5020
#define IDS_CACHECLN_DESCRIPTION        0x5021
#define IDS_CACHECLN_BTNTEXT            0x5022
#define IDS_CACHEOFF_DISPLAY            0x5023
#define IDS_CACHEOFF_DESCRIPTION        0x5024
#define IDS_CACHEOFF_BTNTEXT            0x5025

#define IDS_ON_DESKTOP                  0x6000
#define IDS_FIND_TITLE                  0x6001

#define IDS_RESET_WEB_SETTINGS_TITLE    0x6002
#define IDS_RESET_WEB_SETTINGS_SUCCESS  0x6003
#define IDS_RESET_WEB_SETTINGS_FAILURE  0x6004
#define IDD_RESET_WEB_SETTINGS          0x6005
#define IDC_RESET_WEB_SETTINGS_HOMEPAGE 0x6006

#define IDS_ERR_NAV_FAILED              0x6007
#define IDS_ERR_NAV_FAILED_TITLE        0x6008
#define IDS_HYPERTEXT_STYLE             0x6009

//
// my pics hoverbar as well as auto image resize feature
//

// buttons and tooltip strings:
#define IDM_MYPICS_SAVE                 4000
#define IDS_MYPICS_SAVE                 4000
#define IDM_MYPICS_PRINT                4001
#define IDS_MYPICS_PRINT                4001
#define IDM_MYPICS_EMAIL                4002
#define IDS_MYPICS_EMAIL                4002
#define IDM_MYPICS_MYPICS               4003
#define IDS_MYPICS_MYPICS               4003

#define IDM_AIR_BUTTON                  4019
#define IDS_AIR_EXPAND                  4018
#define IDS_AIR_SHRINK                  4017

// identifiers:
#define ID_MPTOOLBAR                    4020
#define ID_MPREBAR                      4021

#define ID_AIR_BUTTON                   4028
#define ID_AIR_REBAR                    4029

// bitmaps:
#define IDB_MYPICS_TOOLBAR              4030
#define IDB_MYPICS_TOOLBARG             4031
#define IDB_MYPICS_TOOLBARW             4032
#define IDB_MYPICS_TOOLBARGW            4033

#define IDB_AIR_EXPAND                  4038
#define IDB_AIR_SHRINK                  4039

// context menu thingie:
#define IDR_MYPICS_CONTEXT_MENU         4040
#define IDM_DISABLE_MYPICS              4041
#define IDM_HELP_MYPICS                 4042

// dialogue box popup disable thingie:
#define DLG_DISABLE_MYPICS              4050
#define IDC_MP_TEXT1                    4051
#define IDC_MP_TEXT2                    4052
#define IDC_MP_ALWAYS                   4053
#define IDC_MP_THISSESSION              4054
#define IDC_MP_CANCEL                   4055

// the timer
#define IDT_MP_TIMER                    4060
#define IDT_AIR_TIMER                   4061

// privacy dialog and status bar icons/tooltips
#define IDD_PRIVACY_DIALOG              4070
#define IDC_SITE_LIST                   4071
#define IDC_VIEW_POLICY                 4072
#define IDS_PRIVACY_COLUMN1             4073
#define IDS_PRIVACY_COLUMN2             4074
#define IDS_PRIVACY_TOOLTIP             4075
//  ordering of IDS_PRIVACY_/NOCOOKIE/ACCEPTED/RESTRICTED/BLOCKED must be maintained ..
#define IDS_PRIVACY_NOCOOKIE            4076
#define IDS_PRIVACY_ACCEPTED            4077
#define IDS_PRIVACY_SUPPRESSED          4078
#define IDS_PRIVACY_RESTRICTED          4079
#define IDS_PRIVACY_BLOCKED             4080
#define IDS_PRIVACY_VIEWIMPACTED        4081
#define IDS_PRIVACY_VIEWALL             4082
#define IDS_PRIVACY_LEARNMOREABOUTPRIVACY 4083
#define IDS_PRIVACY_LEARNMOREABOUTCOOKIES 4084
#define IDS_PRIVACY_STATUSIMPACTED      4085
#define IDS_PRIVACY_STATUSNOIMPACT      4086

#define IDC_SETTINGS                    4087
#define IDC_PRIVACY_VIEWCOMBO           4090
#define IDD_PRIVACY_CNTXTMN_PERSITE_ADD_REM     4091
#define IDM_PRIVACY_PAR_ACCEPT          4092
#define IDM_PRIVACY_PAR_REJECT          4093
#define IDM_PRIVACY_PAR_DEFAULT         4094
#define IDD_PRIV_DISCOVER               4095
#define IDB_PRIV_IMPACT                 4096
#define IDC_PRIV_DISCOVER_DONTSHOW      4097
#define IDC_PRIVACY_HELP                4098
#define IDC_PRIVACY_STATUSTEXT          4100
#define IDC_PRIVACY_SHOWPOLICY          4101
#define IDC_PRIVACY_ICON                4102

// media bar
#define IDD_MEDIA_MIME                  4120
#define IDC_MEDIA_MIME_CHKBOX           4121
#define IDS_MEDIABAR_NOWMP7         0x7000
#define IDS_MEDIABAR_NOWMP7TITLE    0x7001
#define IDS_MEDIABAR_NEEDWMP7       0x7002
#define IDC_MEDIABAR_EXTRA           0x7000

//  Since all the PrivacyXML strings are loaded in a string table,
//the resources must fill contiguously identifiers in the range
//IDS_PRIVACYXML6 to IDS_PRIVACYXML6_LASTPRIVACYXML6.
#define IDS_PRIVACYXML6                          0x6500
#define IDS_PRIVACYXML6_ROOTPRIVACY              (IDS_PRIVACYXML6 + 0)
#define IDS_PRIVACYXML6_VERSION                  (IDS_PRIVACYXML6 + 1)
#define IDS_PRIVACYXML6_COOKIEZONE               (IDS_PRIVACYXML6 + 2)
#define IDS_PRIVACYXML6_COOKIEZONE_ZONE          (IDS_PRIVACYXML6 + 3)
//  The four cookie zones must be contiguous in the resources..
#define IDS_PRIVACYXML6_COOKIEZONE_INTERNET      (IDS_PRIVACYXML6 + 4)
#define IDS_PRIVACYXML6_COOKIEZONE_INTRANET      (IDS_PRIVACYXML6 + 5)
#define IDS_PRIVACYXML6_COOKIEZONE_TRUSTED       (IDS_PRIVACYXML6 + 6)
#define IDS_PRIVACYXML6_COOKIEZONE_FIRST         IDS_PRIVACYXML6_COOKIEZONE_INTERNET
#define IDS_PRIVACYXML6_COOKIEZONE_LAST          IDS_PRIVACYXML6_COOKIEZONE_TRUSTED
//  end of four cookie zookes..
#define IDS_PRIVACYXML6_ACTION                   (IDS_PRIVACYXML6 + 7)
#define IDS_PRIVACYXML6_FIRSTPARTY               (IDS_PRIVACYXML6 + 8)
#define IDS_PRIVACYXML6_THIRDPARTY               (IDS_PRIVACYXML6 + 9)
#define IDS_PRIVACYXML6_NOPOLICYDEFAULT          (IDS_PRIVACYXML6 + 10)
#define IDS_PRIVACYXML6_NORULESDEFAULT           (IDS_PRIVACYXML6 + 11)
//  The five action attribute values must be contiguous in the resources..
#define IDS_PRIVACYXML6_ACTION_ACCEPT            (IDS_PRIVACYXML6 + 12)
#define IDS_PRIVACYXML6_ACTION_PROMPT            (IDS_PRIVACYXML6 + 13)
#define IDS_PRIVACYXML6_ACTION_FIRSTPARTY        (IDS_PRIVACYXML6 + 14)
#define IDS_PRIVACYXML6_ACTION_SESSION           (IDS_PRIVACYXML6 + 15)
#define IDS_PRIVACYXML6_ACTION_REJECT            (IDS_PRIVACYXML6 + 16)
#define IDS_PRIVACYXML6_ACTION_FIRST             IDS_PRIVACYXML6_ACTION_ACCEPT
#define IDS_PRIVACYXML6_ACTION_LAST              IDS_PRIVACYXML6_ACTION_REJECT
//  end of five attribute values
#define IDS_PRIVACYXML6_ALWAYSALLOWSESSION       (IDS_PRIVACYXML6 + 17)
#define IDS_PRIVACYXML6_YES                      (IDS_PRIVACYXML6 + 18)
#define IDS_PRIVACYXML6_NO                       (IDS_PRIVACYXML6 + 19)
#define IDS_PRIVACYXML6_IF                       (IDS_PRIVACYXML6 + 20)
#define IDS_PRIVACYXML6_EXPR                     (IDS_PRIVACYXML6 + 21)
#define IDS_PRIVACYXML6_ALWAYSREPLAYLEGACY       (IDS_PRIVACYXML6 + 22)
#define IDS_PRIVACYXML6_FLUSHCOOKIES             (IDS_PRIVACYXML6 + 23)
#define IDS_PRIVACYXML6_FLUSHSITELIST            (IDS_PRIVACYXML6 + 24)
#define IDS_PRIVACYXML6_ROOTPERSITE              (IDS_PRIVACYXML6 + 25)
#define IDS_PRIVACYXML6_SITE                     (IDS_PRIVACYXML6 + 26)
#define IDS_PRIVACYXML6_DOMAIN                   (IDS_PRIVACYXML6 + 27)
#define IDS_PRIVACYXML6_ROOT                     (IDS_PRIVACYXML6 + 28)
#define IDS_PRIVACYXML6_LASTPRIVACYXML6          (IDS_PRIVACYXML6 + 28)

#define IDC_MEDIA_MOREINFO             0x8001

#define IDD_IEHARDEN1                   4200
#define IDC_IEHARDEN_TEXT               4201
#define IDC_IEHARDEN_DONT_SHOW          4202
#define IDC_IEHARDEN_HELP               4203

#define IDS_IEHARDEN_TEXT_IE            4210
#define IDS_IEHARDEN_TEXT_OC            4211
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\sccls.cpp ===
#define  DONT_USE_ATL
#include "priv.h"
#include "sccls.h"
#include "atl.h"
#include <ntverp.h>

#include <ieguidp.h>                // for CLSID_CDocObjectFolder
#include "ishcut.h"
#include "reload.h"                 // for URLDL_WNDCLASS
#include "inetnot.h"                // CWinInetNotify_szWindowClass
#include <activscp.h>               // IID_IActiveScriptStats
#define MLUI_INIT
#include <mluisupp.h>

#define DECL_CRTFREE
#include <crtfree.h>
#include "shfusion.h"

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli);

PfnDliHook __pfnDliFailureHook;
PfnDliHook __pfnDliNotifyHook = DelayloadNotifyHook;      // notify hook is needed so that we can unload wininet.dll


LONG                g_cRefThisDll = 0;      // per-instance
CRITICAL_SECTION    g_csDll = {0};          // per-instance
HINSTANCE           g_hinst = NULL;

EXTERN_C HANDLE g_hMutexHistory = NULL;

BOOL g_fRunningOnNT = FALSE;
BOOL g_bNT5Upgrade = FALSE;
BOOL g_bRunOnNT5 = FALSE;
BOOL g_bRunOnMemphis = FALSE;
BOOL g_fRunOnFE = FALSE;
UINT g_uiACP = CP_ACP;
DWORD g_dwStopWatchMode = 0;        // Shell perf automation
BOOL g_bMirroredOS = FALSE;         // Is Mirroring enabled
BOOL g_bBiDiW95Loc = FALSE;         // needed for BiDi localized win95 RTL stuff
HMODULE g_hmodWininet = NULL;       // have we loaded wininet because of a delayload thunk??

EXTERN_C HANDLE g_hSemBrowserCount;

HPALETTE g_hpalHalftone = NULL;

EXTERN_C const GUID CLSID_MsgBand;

STDAPI CMsgBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_CDocObjectFolder,        CDocObjectFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS(&CLSID_CBaseBrowser,    CBaseBrowser2_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CURLFolder,              CInternetFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_Internet,                CInternetFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CacheFolder,             CacheFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CacheFolder2,            CacheFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_HistFolder,              HistFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_ALL(&CLSID_WebBrowser,          CWebBrowserOC_CreateInstance,
         &IID_IWebBrowser2, &DIID_DWebBrowserEvents2, VERSION_2,
        OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CUrlHistory,             CUrlHistory_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CURLSearchHook,          CURLSearchHook_CreateInstance,
        COCREATEONLY), 

    CF_TABLE_ENTRY_ALL(&CLSID_WebBrowser_V1,           CWebBrowserOC_CreateInstance,
         &IID_IWebBrowser, &DIID_DWebBrowserEvents, VERSION_1,
        OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CStubBindStatusCallback, CStubBSC_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellUIHelper,           CShellUIHelper_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_InternetShortcut,        CIntShcut_CreateInstance,
        COCREATEONLY),

#ifdef ENABLE_CHANNELS
    CF_TABLE_ENTRY_ALL(&CLSID_ChannelOC,                ChannelOC_CreateInstance,
        NULL,NULL,0,
        OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,
        OIF_ALLOWAGGREGATION),
#endif  // ENABLE_CHANNELS

#ifndef NO_SPLASHSCREEN 
   CF_TABLE_ENTRY(&CLSID_IESplashScreen,            CIESplashScreen_CreateInstance,
        COCREATEONLY),
#endif
        
   CF_TABLE_ENTRY(&CLSID_WinListShellProc,          CWinListShellProc_CreateInstance,
        COCREATEONLY),

   CF_TABLE_ENTRY(&CLSID_CDFCopyHook,               CCDFCopyHook_CreateInstance,
        COCREATEONLY),

   CF_TABLE_ENTRY(&CLSID_InternetCacheCleaner,      CInternetCacheCleaner_CreateInstance,
        COCREATEONLY),
   
    CF_TABLE_ENTRY(&CLSID_OfflinePagesCacheCleaner, COfflinePagesCacheCleaner_CreateInstance,
        COCREATEONLY),        

   CF_TABLE_ENTRY(&CLSID_TaskbarList,               TaskbarList_CreateInstance,
        COCREATEONLY),
        
   CF_TABLE_ENTRY(&CLSID_DocHostUIHandler,          CDocHostUIHandler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ToolbarExtBand,           CToolbarExtBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ToolbarExtExec,           CToolbarExtExec_CreateInstance,
        COCREATEONLY),
        
    CF_TABLE_ENTRY(&CLSID_NSCTree,                  CNscTree_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_FavBand,                 CFavBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ExplorerBand,             CExplorerBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_HistBand,                  CHistBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MruLongList,                CMruLongList_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MruPidlList,                CMruPidlList_CreateInstance,
        COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo. 

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn, 
                         DWORD dwClassFactFlagsIn)
{ 
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        ASSERT(FAILED(hr) ? *ppv == NULL : TRUE);
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

BOOL IsProxyRegisteredProperly(LPCTSTR pszInterface, LPCTSTR pszClsid)
{
    // Default to failure
    BOOL fRet = FALSE;
    TCHAR szInterface[128];
    if (SUCCEEDED(StringCchPrintf(szInterface, ARRAYSIZE(szInterface), TEXT("Interface\\%s\\ProxyStubClsid32"), pszInterface)))
    {
        TCHAR szValue[40];
        DWORD cbValue = sizeof(szValue);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szInterface, NULL, NULL, szValue, &cbValue))
        {
            fRet = (0 == StrCmpI(szValue, pszClsid));
        }
    }

    return fRet;
}

// published, so invariant

#define ACTXPROXYSTUB           TEXT("{B8DA6310-E19B-11D0-933C-00A0C90DCAA9}")
#define FOLDERMARSHALPROXYSTUB  TEXT("{bf50b68e-29b8-4386-ae9c-9734d5117cd5}")  // CLSID_FolderMarshalStub
#define ISHELLFOLDER            TEXT("{000214E6-0000-0000-C000-000000000046}")  // IID_IShellFolder
#define ISHELLFOLDER2           TEXT("{93F2F68C-1D1B-11D3-A30E-00C04F79ABD1}")  // IID_IShellFolder2
#define IOLECOMMANDTARGET       TEXT("{b722bccb-4e68-101b-a2bc-00aa00404770}")  // IID_IOleCommandTarget
#define IHLINKTARGET            TEXT("{79eac9c4-baf9-11ce-8c82-00aa004ba90b}")  // IID_IHlinkTarget

void SHShouldRegisterActxprxy(void)
{
    // IOleCommandTarget / IHlinkTarget Proxy/Stub CLSID key missing?
    if (!IsProxyRegisteredProperly(IOLECOMMANDTARGET, ACTXPROXYSTUB) ||
        !IsProxyRegisteredProperly(IHLINKTARGET, ACTXPROXYSTUB))
    {
        HINSTANCE hinst = LoadLibrary(TEXT("ACTXPRXY.DLL"));
        if (hinst)
        {
            typedef HRESULT (WINAPI * REGSERVERPROC)(void);
            REGSERVERPROC pfn = (REGSERVERPROC) GetProcAddress(hinst, "DllRegisterServer");
            if (pfn)
                pfn();
            FreeLibrary(hinst);
        }
    }

    // test for IShellFolder marshaler not being set to our app compat stub
    if (!IsProxyRegisteredProperly(ISHELLFOLDER, FOLDERMARSHALPROXYSTUB) ||
        !IsProxyRegisteredProperly(ISHELLFOLDER2, FOLDERMARSHALPROXYSTUB))
    {
        SHSetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\") ISHELLFOLDER TEXT("\\ProxyStubClsid32"), 
            TEXT(""), REG_SZ, FOLDERMARSHALPROXYSTUB, sizeof(FOLDERMARSHALPROXYSTUB));

        SHSetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\") ISHELLFOLDER2 TEXT("\\ProxyStubClsid32"), 
            TEXT(""), REG_SZ, FOLDERMARSHALPROXYSTUB, sizeof(FOLDERMARSHALPROXYSTUB));
    }
}

void SHCheckRegistry(void)
{
    // VBE has a bug where they destroy the interface registration information of any control
    // hosted in a VBE user form.  Check the registry here.  Only do this once.
    // 17-Nov-97 [alanau/terrylu] Added a check for the IOleCommandTarget Proxy/Stub handler
    //
    static BOOL fNeedToCheckRegistry = TRUE;

    if (fNeedToCheckRegistry)
    {
        fNeedToCheckRegistry = FALSE;

        // This is published, so is invariant
        TCHAR szValue[39];
        DWORD cbValue = sizeof(szValue);
        LONG rc = SHGetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\{EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B}\\Typelib"), 
            NULL, NULL, szValue, &cbValue); 
            
        if (rc == ERROR_SUCCESS)
        {
            // Compare the retrieved value with our typelib id.
            //
            if (StrCmpI(szValue, TEXT("{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}")) != 0)
            {
                // If different, we need to explicitly register our typelib
                //
                SHRegisterTypeLib();
            }
        }
         
        SHShouldRegisterActxprxy();
     }
}

STDAPI CInstClassFactory_Create(REFCLSID rclsid, REFIID riid, void *ppv);

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    SHCheckRegistry();  // patch up broken registry

    *ppv = NULL;
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if ((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
                break;
            }
        }

        if (FAILED(hr))
        {
            // Try the ATL class factory
            hr = AtlGetClassObject(rclsid, riid, ppv);
            if (FAILED(hr))
            {
                // not found, see if it's an 'instance' (code + initialization)
                hr = CInstClassFactory_Create(rclsid, riid, ppv);
            }
        }
    }
    else if ((riid == IID_IPSFactoryBuffer) && 
             (rclsid == CLSID_FolderMarshalStub) &&
             !(SHGetAppCompatFlags(ACF_APPISOFFICE) & ACF_APPISOFFICE))
    {
        // IID_IActiveScriptStats == CLSID_ActiveXProxy
        // B8DA6310-E19B-11d0-933C-00A0C90DCAA9
        hr = CoGetClassObject(IID_IActiveScriptStats, CLSCTX_INPROC_SERVER, NULL, riid, ppv);
    }
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (0 != g_cRefThisDll || 0 != AtlGetLockCount())
        return S_FALSE;

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}

// DllGetVersion - New for IE 4.0
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

#ifdef DEBUG
EXTERN_C
DWORD g_TlsMem = 0xffffffff;
#endif

void InitNFCtl()
{
    INITCOMMONCONTROLSEX icc;

    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icc);
}

//
// we use shlwapi as our delayload error handler.
// NOTE: this only works if we are statically linked to shlwapi!
//
void SetupDelayloadErrorHandler()
{
    HMODULE hmod = GetModuleHandleA("shlwapi.dll");
    ASSERTMSG(hmod != NULL, "SHDOCVW must be statically linked to shlwapi.dll for delayload failure handling to work!");
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(hmod, "DelayLoadFailureHook");
}

//
// we use this function to see if we have loaded wininet.dll due to a delayload thunk so that we 
// can free it at dll detach and therefore it will cleanup all of its crud
//
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli)
{
    if (iReason == dliNoteEndProcessing)
    {
        if (pdli        &&
            pdli->szDll &&
            (StrCmpIA("wininet.dll", pdli->szDll) == 0))
        {
            // wininet was loaded!!
            g_hmodWininet = pdli->hmodCur;
        }
    }

    return NULL;
}

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
const LPCTSTR c_rgszClasses[] = {
    c_szViewClass,                          // dochost.cpp
    URLDL_WNDCLASS,                         // reload.cpp
    c_szShellEmbedding,                     // embed.cpp
    TEXT("CIESplashScreen"),                // splash.cpp
    CWinInetNotify_szWindowClass,           // inetnot.cpp
    OCHOST_CLASS,                           // occtrl.cpp
    TEXT("AutoImageResizeHost"),            // airesize.cpp
    TEXT("MyPicturesHost")                  // mypics.cpp
};

//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))

// IEUNIX - This function  should be moved to some file used to create 
// shdocvw.dll. While compiling for DLLs mainsoft will #define DllMain
// to the appropriate function being called in generated *_init.c
#if defined(MAINWIN)
STDAPI_(BOOL) DllMain_Internal(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
#else
STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hDll);

        SetupDelayloadErrorHandler();

        AtlInit(hDll);
        DisableThreadLibraryCalls(hDll);    // perf

        g_hinst = hDll;
        InitializeCriticalSection(&g_csDll);

        MLLoadResources(g_hinst, TEXT("shdoclc.dll"));

        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();

#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        if (IsFlagSet(g_dwBreakFlags, BF_ONLOADED))
        {
            TraceMsg(TF_ALWAYS, "SHDOCVW.DLL has just loaded");
            DEBUG_BREAK;
        }
#endif

        g_fRunningOnNT = IsOS(OS_NT);
        if (g_fRunningOnNT)
            g_bRunOnNT5 = IsOS(OS_WIN2000ORGREATER);
        else
            g_bRunOnMemphis = IsOS(OS_WIN98ORGREATER);

        g_fRunOnFE = GetSystemMetrics(SM_DBCSENABLED);
        g_uiACP = GetACP();

        //
        // Check if the mirroring APIs exist on the current
        // platform.
        //
        g_bMirroredOS = IS_MIRRORING_ENABLED();

#ifdef WINDOWS_ME
        //
        // Check to see if running on BiDi localized Win95
        //
        g_bBiDiW95Loc = IsBiDiLocalizedWin95(FALSE);
#endif // WINDOWS_ME
        

        InitNFCtl();

        // See if perfmode is enabled
        g_dwStopWatchMode = StopWatchMode();

        // Cache a palette handle for use throughout shdocvw
        g_hpalHalftone = SHCreateShellPalette(NULL);

        SHCheckRegistry();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MLFreeResources(g_hinst);

        if (g_hMutexHistory) 
        {
            CloseHandle(g_hMutexHistory);
            g_hMutexHistory = NULL;
        }

        if (g_hSemBrowserCount)
            CloseHandle(g_hSemBrowserCount);

        if (g_hpalHalftone)
            DeletePalette(g_hpalHalftone);
        if (g_hiconSSL)
            DestroyIcon(g_hiconSSL);
        if (g_hiconOffline)
            DestroyIcon(g_hiconOffline);
        if (g_hiconPrinter)
            DestroyIcon(g_hiconPrinter);

        if (fProcessUnload == NULL)
        {
            // DLL being unloaded, FreeLibrary() (vs process shutdown)
            // at process shutdown time we can't make call outs since 
            // we don't know if those DLLs will still be loaded!

            AtlTerm();

            CUrlHistory_CleanUp();

            if (g_psfInternet)
            {
                // Atomic Release for a C pgm.
                //
                IShellFolder *psfInternet = g_psfInternet;
                g_psfInternet = NULL;
                psfInternet->Release();
            }

            UnregisterWindowClasses();

            if (g_fRunningOnNT && g_hmodWininet)
            {
                // we need to free wininet if it was loaded because of a delayload thunk. 
                //
                // (a) we can only safely do this on NT since on win9x calling FreeLibrary during
                //     process detach can cause a crash (depending on what msvcrt you are using).
                //
                // (b) we only really need to free this module from winlogon.exe's process context 
                //     because when we apply group policy in winlogon, MUST finally free wininet 
                //     so that it will clean up all of its reg key and file handles.
                FreeLibrary(g_hmodWininet);
            }
        }

        SHFusionUninitialize();

        DeleteCriticalSection(&g_csDll);
    }
    return TRUE;
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT(g_cRefThisDll != 0);      // don't underflow
    InterlockedDecrement(&g_cRefThisDll);
}


STDAPI_(UINT) WhichPlatformFORWARD()
{
    return WhichPlatform();
}


// IEUNIX
// CoCreateInstance is #defined as IECreateInstance #ifdef __cplusplus, 
// so I #undef it  here to prevent the recursive call. 
// On Windows it works, because this file is C file.

#ifdef CoCreateInstance
#undef CoCreateInstance
#endif

HRESULT IECreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, void **ppv)
{
#ifndef NO_MARSHALLING
    if (dwClsContext == CLSCTX_INPROC_SERVER) 
    {
#else
    if (dwClsContext & CLSCTX_INPROC_SERVER) 
    {
#endif
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            // Note that we do pointer comparison (instead of IsEuqalGUID)
            if (&rclsid == pcls->pclsid)
            {
                // const -> non-const expclit casting (this is OK)
                IClassFactory* pcf = GET_ICLASSFACTORY(pcls);
                return pcf->CreateInstance(pUnkOuter, riid, ppv);
            }
        }
    }
    // Use SHCoCreateInstanceAC to go through the app compat layer
    return SHCoCreateInstanceAC(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

#ifdef DEBUG

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (StrCmpI(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealSHRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

STDAPI_(ATOM) RegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (StrCmpI(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shdocvw.inc ===
#
# Common makefile include for this project
#
!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

C_DEFINES       = $(C_DEFINES) \
                  -DIN_SHDOCVW \
                  -DFEATURE_FRAMES \
                  -DMSOCT2=1 \
                  -DBETA1_DIALMON_HACK \
                  -DFEATURE_URLHIST \
                  -DFEATURE_PICS \
                  -DPAGER \
                  -D_HSFOLDER \
                  -DFAVORITESTOSHDOCVW \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \
                  -DWINDOWS_ME

# Defines for deskmover
C_DEFINES       = $(C_DEFINES) \
                  -D_NTSDK -D_USRDLL -D_WINNT

!if "$(TEST_AMBIENTS)" == "1"
C_DEFINES       = $(C_DEFINES) -DTEST_AMBIENTS
!endif

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Bring in the ATL headers
USE_STATIC_ATL = 1

# Bring in the WTL headers
USE_WTL=1
WTL_VER=10

USE_MSVCRT      = 1

# be careful here-- shdocvw has to run downlevel. Don't add anything to
# the delayload line that you absolutely depend on having downlevel!
DELAYLOAD       = shell32.dll;browseui.dll;oleaut32.dll;wininet.dll;urlmon.dll;\
                  msrating.dll;mshtml.dll;mlang.dll;inetcomm.dll;ole32.dll;\
                  advpack.dll

!if !$(386)
DELAYLOAD       = $(DELAYLOAD);\
                  winmm.dll;\
                  version.dll
!endif

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shdocfl.cpp ===
#include "priv.h"
#include "sccls.h"
#include "dochost.h"
#include "resource.h"
#include "stdenum.h"
#include <idhidden.h>
#include "shdocfl.h"

#include <mluisupp.h>

HRESULT CDocObjectView_Create(IShellView** ppv, IShellFolder* psf, LPCITEMIDLIST pidl);


#define DM_STARTUP          0
#define DM_CDOFPDN          0       // CDocObjectFolder::ParseDisplayName

class CDocObjectFolder :    public IShellFolder2, 
                            public IPersistFolder2,
                            public IBrowserFrameOptions
{
public:
    CDocObjectFolder(LPCITEMIDLIST pidlRoot = NULL);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);

    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST * ppidlOut);
    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID pGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails){ return E_NOTIMPL; };
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IPersistFolder
    STDMETHODIMP GetClassID(LPCLSID pClassID);
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);
    
    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);

protected:

    ~CDocObjectFolder();

    LONG            _cRef;
    LPITEMIDLIST    _pidlRoot;
};

//========================================================================
// CDocObjectFolder members
//========================================================================

CDocObjectFolder::CDocObjectFolder(LPCITEMIDLIST pidlRoot)
        : _cRef(1), _pidlRoot(NULL)
{
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectFolder %x", this);

    DllAddRef();

    if (pidlRoot)
        _pidlRoot = ILClone(pidlRoot);
}

CDocObjectFolder::~CDocObjectFolder()
{
    TraceMsg(TF_SHDLIFE, "dtor CDocObjectFolder %x", this);

    if (_pidlRoot)
        ILFree(_pidlRoot);

    DllRelease();
}

HRESULT CDocObjectFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDocObjectFolder, IShellFolder, IShellFolder2),
        QITABENT(CDocObjectFolder, IShellFolder2),
        QITABENTMULTI(CDocObjectFolder, IPersistFolder, IPersistFolder2),
        QITABENT(CDocObjectFolder, IPersistFolder2), 
        QITABENT(CDocObjectFolder, IBrowserFrameOptions), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDocObjectFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDocObjectFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDocObjectFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppidl = NULL;
    return E_UNEXPECTED;
}
HRESULT CDocObjectFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvOut = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvObj = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        hres = CDocObjectView_Create((IShellView**)ppvOut, this, _pidlRoot);
    }
    else
    {
        hres = E_NOINTERFACE;
        *ppvOut = NULL;
    }
    return hres;
}

HRESULT CDocObjectFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvOut = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    //  we should never have any children.
    ASSERT(cidl == 0);
    if (cidl != 0)
        return E_UNEXPECTED;
        
    if (*rgfInOut)
    {
        //  they want to know about the document itself
        ASSERT(_pidlRoot);
        return SHGetAttributesOf(_pidlRoot, rgfInOut);
    }

    return S_OK;
}

HRESULT CDocObjectFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    *pGuid = SRCID_SWebSearch;
    return S_OK;
}

HRESULT CDocObjectFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

HRESULT CDocObjectFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_CDocObjectFolder;
    return S_OK;
}

HRESULT CDocObjectFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (_pidlRoot) 
    {
        ILFree(_pidlRoot);
        _pidlRoot = NULL;
    }

    if (pidl)
        _pidlRoot = ILClone(pidl);

    return S_OK;
}

HRESULT CDocObjectFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return SHILClone(_pidlRoot, ppidl);
}

// IBrowserFrameOptions
#define BASE_OPTIONS \
                            (BFO_BROWSER_PERSIST_SETTINGS | BFO_RENAME_FOLDER_OPTIONS_TOINTERNET | \
                            BFO_PREFER_IEPROCESS | BFO_ENABLE_HYPERLINK_TRACKING | \
                            BFO_USE_IE_LOGOBANDING | BFO_ADD_IE_TOCAPTIONBAR | BFO_GO_HOME_PAGE | \
                            BFO_USE_IE_TOOLBAR | BFO_NO_PARENT_FOLDER_SUPPORT | BFO_NO_REOPEN_NEXT_RESTART | \
                            BFO_SHOW_NAVIGATION_CANCELLED)


// IBrowserFrameOptions
HRESULT CDocObjectFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // We are hosting a DocObj?
    BOOL fIsFileURL = FALSE;

    // Is this under the Internet Name Space? Yes for
    // HTTP and FTP owned by the IE name space.  MSIEFTP
    // pidls are passed straight to that folder.
    // This function will return FALSE for non-IE stuff
    // but we will then want to check if it's a file system
    // thing that wants to act like a web page because it's
    // MIME TYPE or other association is associated with the web.
    if (!IsURLChild(_pidlRoot, TRUE))
    {               
        // Since IsURLChild() returned FALSE, this must be in the file system.
        // This case will happen with:
        // C:\foo.htm
        // http://www.yahoo.com/
        // http://bryanst/resume.doc
        // http://bryanst/notes.txt
        // <Start Page>  [I couldn't find a case that hit CInternetFolder]
        // C:\foo.doc (use the addressbar to repro)
        fIsFileURL = TRUE;
    }

    *pdwOptions = dwMask & BASE_OPTIONS;
    if (!fIsFileURL)
    {
        // Add the Offline Support when we aren't in the file system.
        *pdwOptions |= dwMask & (BFO_USE_IE_OFFLINE_SUPPORT | BFO_USE_DIALUP_REF);
    }
        
    return S_OK;
}


STDAPI CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CDocObjectFolder *psf = new CDocObjectFolder;
    if (psf)
    {
        *ppunk = SAFECAST(psf, IShellFolder *);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


class CInternetFolder : CDocObjectFolder
{
public:
    CInternetFolder(LPCITEMIDLIST pidlRoot = NULL) ;

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IPersistFolder
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);

protected:
    ~CInternetFolder();

    HRESULT _CreateProtocolHandler(LPCSTR pszProtocol, IBindCtx * pbc, IShellFolder **ppsf);
    HRESULT _CreateProtocolHandlerFromPidl(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsf);
    HRESULT _GetAttributesOfProtocol(LPCSTR pszProtocol, LPCITEMIDLIST *apidl, UINT cpidl, ULONG *rgfInOut);
    HRESULT _FaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IUnknown * punkSite);
    HRESULT _ConditionallyFaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IBindCtx * pbc);
    HRESULT _AssocCreate(LPCITEMIDLIST pidl, REFIID riid, void * *ppv);
    HRESULT _GetScheme(LPCITEMIDLIST pidl, LPWSTR pszOut, DWORD cchOut);
    HRESULT _GetUIObjectFromShortcut(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut);
    HRESULT _GetTitle(LPCWSTR pszUrl, STRRET *pstr);
    HRESULT _InitHistoryStg(IUrlHistoryStg **pphist);

    IUrlHistoryStg *_phist;
};


CInternetFolder::CInternetFolder(LPCITEMIDLIST pidlRoot)
    : CDocObjectFolder(pidlRoot)
{
    TraceMsg(TF_URLNAMESPACE, "[%X] ctor CInternetFolder", this);
    ASSERT(NULL == _phist);
}

CInternetFolder::~CInternetFolder()
{
    ATOMICRELEASE(_phist);
    TraceMsg(TF_URLNAMESPACE, "[%X] dtor CInternetFolder", this);
}

HRESULT CInternetFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CInternetFolder, IShellFolder, IShellFolder2),
        QITABENT(CInternetFolder, IShellFolder2),
        QITABENTMULTI(CDocObjectFolder, IPersistFolder, IPersistFolder2),
        QITABENT(CDocObjectFolder, IPersistFolder2), 
        QITABENT(CInternetFolder, IBrowserFrameOptions), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CInternetFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInternetFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


typedef struct tagURLID 
{
    ITEMIDLIST idl;     //  cb and SHID
    BYTE bType;         //  URLID
    UINT uiCP;          //  Code Page
    WCHAR achUrl[1];       //  variable size string
} URLID;

#define SHID_INTERNET           0x60
#define SHID_INTERNET_SITE      0x61    // IE name space item

#define URLID_URLBASEA          0x00
/////// URLID_LOCATION          0x01  //  LEGACY IE3/4 used for Frag IDs
/////// URLID_FTPFOLDER         0x02  //  LEGACY used by a pre-release FTP Folder dll
#define URLID_PROTOCOL          0x03  //  this is actually a delegated protocol
#define URLID_URLBASEW          0x80  //  
//      URLIDF_UNICODE          0x80  //  URLID_ is actually of UNICODE type

#ifdef UNICODE 
#define URLID_URLBASE           URLID_URLBASEW
#else
#define URLID_URLBASE           URLID_URLBASEA
#endif

typedef const UNALIGNED URLID *PCURLID;
typedef UNALIGNED URLID *PURLID;

#define PDID_SIG MAKEWORD(SHID_INTERNET_SITE, URLID_PROTOCOL)

inline PCDELEGATEITEMID _IsValidDelegateID(LPCITEMIDLIST pidl)
{
    PCDELEGATEITEMID pdi = (PCDELEGATEITEMID)pidl;
    ASSERT(pdi);

    if ((pdi->cbSize >= (SIZEOF(PDELEGATEITEMID)-1))
    && (pdi->wOuter == PDID_SIG))
        return pdi;

    return NULL;
}
    
LPCSTR _PidlToDelegateProtocol(LPCITEMIDLIST pidl)
{
    PCDELEGATEITEMID pdi = _IsValidDelegateID(pidl);
    if (pdi)
        return (LPCSTR)&(pdi->rgb[pdi->cbInner]);

    return NULL;
}

inline PCURLID _IsValidUrlID(LPCITEMIDLIST pidl)
{
    PCURLID purlid = (PCURLID)pidl;
    ASSERT(purlid);

//  98/12/22 #263932 vtan: ANSI and Unicode URLs are both valid. Use function
//  _ExtractURL to extract the URL from the PIDL as a Unicode string.

    if (purlid->idl.mkid.cb >= SIZEOF(URLID)
    && (purlid->idl.mkid.abID[0] == SHID_INTERNET_SITE)
    && (purlid->bType == URLID_URLBASEA || purlid->bType == URLID_URLBASEW || _IsValidDelegateID(pidl)))
        return purlid;

    return NULL;
}

//  98/12/22 #263932 vtan: IE4 stores the PIDL in a stream as an ANSI
//  string. IE5 stores the PIDL in a stream as a Unicode string. This
//  functions reads the string (ANSI or Unicode) and converts it to
//  an internal Unicode string which is what will be written to the stream.

void _ExtractURL (PCURLID pURLID, LPWSTR wszURL, int iCharCount)
{
    if (pURLID->bType == URLID_URLBASEA)
    {
        char aszURL[MAX_URL_STRING];

        ualstrcpynA(aszURL, reinterpret_cast<const char*>(pURLID->achUrl), sizeof(aszURL));
        SHAnsiToUnicode(aszURL, wszURL, iCharCount);
    }
    else if (pURLID->bType == URLID_URLBASEW)
    {
        ualstrcpynW(wszURL, pURLID->achUrl, iCharCount);
    }
}

//  99/01/04 vtan: Added the following to help compare URLIDs which
//  can be AA/UU/AU/UA and perform the correct comparison.

int _CompareURL (PCURLID pURLID1, PCURLID pURLID2)
{
    int iResult;
    
    if ((pURLID1->bType == URLID_URLBASEA) && (pURLID2->bType == URLID_URLBASEA))
    {
        iResult = ualstrcmpA(reinterpret_cast<const char*>(pURLID1->achUrl), reinterpret_cast<const char*>(pURLID2->achUrl));
    }
    else if ((pURLID1->bType == URLID_URLBASEW) && (pURLID2->bType == URLID_URLBASEW))
    {
        iResult = ualstrcmpW(pURLID1->achUrl, pURLID2->achUrl);
    }
    else
    {
        PCURLID pCompareURLID;
        WCHAR wszURL[MAX_URL_STRING];
        
        //  AU/UA comparison. To be efficient only convert the ANSI URLID
        //  to Unicode and perform the comparison in Unicode.
        
        if (pURLID1->bType == URLID_URLBASEA)
        {
            pCompareURLID = pURLID2;
            _ExtractURL(pURLID1, wszURL, SIZECHARS(wszURL));
        }
        else
        {
            pCompareURLID = pURLID1;
            _ExtractURL(pURLID2, wszURL, SIZECHARS(wszURL));
        }
        iResult = ualstrcmpW(pCompareURLID->achUrl, wszURL);
    }
    return iResult;
}

IShellFolder* g_psfInternet = NULL;

STDAPI CDelegateMalloc_Create(void *pv, UINT cbSize, WORD wOuter, IMalloc **ppmalloc);
//
// this might modify pszName if it's not a fully qualified url!
BOOL _ValidateURL(LPTSTR pszName, DWORD dwFlags)
{
    //
    // WARNING: In order to allow URL extensions, we assume all strings
    //  which contains ":" in it is a valid string.
    // Assumptions are:
    //
    // (1) CDesktop::ParseDisplayName parse file system strings first.
    // (2) URL moniker will return an error correctly if URL is not valid.
    // (3) someone else (the desktop folder) handles shell: URLs
    //     they should not be used directly by the browser 
    //
    HRESULT hr = IURLQualify(pszName, dwFlags, pszName, NULL, NULL);
    DWORD nScheme = GetUrlScheme(pszName);
    return SUCCEEDED(hr) && (-1 != nScheme) && (URL_SCHEME_SHELL != nScheme);
}

LPITEMIDLIST IEILAppendFragment(LPITEMIDLIST pidl, LPCWSTR pszFragment)
{
    // WARNING: See IE5 bug #'s 86951 and 36497 for more details.
    //         In a nutshell, we're rolling back the change for 36497 because
    //         the change caused many more problems with customers than
    //         the behavior we had in IE4.
    // 
    //         Because we're not ensuring that
    //         the fragment is prefixed with a '#', there may be
    //         cases where the URL in the address bar looks wrong,
    //         as well as cases where a hyperlink to a different doc
    //         or HTML page may fail if it contains a fragment.
    return ILAppendHiddenStringW(pidl, IDLHID_URLFRAGMENT, pszFragment);
}

// browser only uglyness... we need to construct a desktop relative "regitem" pidl for
// the internet since browser only shell does not support psf->ParseDisplayName("::{guid}", &pidl)
// this uses the same layout as REGITEMs so we have PIDL compatibility with integrated mode
// this ensures that a shortcut to the IE icon made in browser only mode works in integrated

#ifndef NOPRAGMAS
#pragma pack(1)
#endif
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bReserved;  // This is to get DWORD alignment
    CLSID   clsid;
} IDITEM;               // IDREGITEM

typedef struct
{
    IDITEM idri;
    USHORT cbNext;
} IDLITEM;              // IDLREGITEM
#ifndef NOPRAGMAS
#pragma pack()
#endif

// stolen from shell32\shitemid.h

#define SHID_ROOT_REGITEM       0x1f    // MyDocuments, Internet, etc

const IDLITEM c_idlInetRoot = 
{ 
    {SIZEOF(IDITEM), SHID_ROOT_REGITEM, 0, 
    { 0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D },/* CLSID_Internet */ }, 0,
};

LPCITEMIDLIST c_pidlURLRoot = (LPCITEMIDLIST)&c_idlInetRoot;

// it must be an absolute pidl with a root regitem id at the front
// if we're a rooted explorer, this is always false
// this means we're definitely in nashville, so we shouldn't have a split
// world

PCURLID _FindUrlChild(LPCITEMIDLIST pidl, BOOL fIncludeHome = FALSE)
{
    if ((pidl == NULL) ||
        (pidl->mkid.cb != sizeof(IDITEM)) ||
        (pidl->mkid.abID[0] != SHID_ROOT_REGITEM))
    {
        return NULL;
    }

    //
    // the clsid in the pidl must be our internet folder's
    //
    if (!IsEqualGUID(((IDITEM*)pidl)->clsid, CLSID_Internet))
    {
        ASSERT(!IsEqualGUID(((IDITEM*)pidl)->clsid, CLSID_CURLFolder));
        return NULL;
    }

    //  go to the child...
    pidl = _ILNext(pidl);
    
    //
    // if it is a pidl to the internet root then it is the IE3 Home Page
    //
    
    if (fIncludeHome && ILIsEmpty(pidl))
        return (PCURLID)pidl;

    //
    // otherwise it is our child if it is a site object
    //
    return _IsValidUrlID(pidl);
}

STDAPI_(BOOL) IsURLChild(LPCITEMIDLIST pidl, BOOL fIncludeHome)
{
    return (NULL != _FindUrlChild(pidl, fIncludeHome));
}


BOOL IEILGetFragment(LPCITEMIDLIST pidl, LPWSTR pszFragment, DWORD cchFragment)
{
    return ILGetHiddenStringW(pidl, IDLHID_URLFRAGMENT, pszFragment, cchFragment);
}

UINT IEILGetCP(LPCITEMIDLIST pidl)
{
    PCURLID purlid = _FindUrlChild((pidl));
    if (purlid)
    {
        if (!_IsValidDelegateID((LPCITEMIDLIST)purlid))
            return purlid->uiCP;
    }
    return CP_ACP;
}

LPITEMIDLIST _UrlIdCreate(UINT uiCP, LPCTSTR pszUrl)
{
    //
    //  the URLID has a variable sized string
    //  member.  but we put the arbitrary limit
    //  of MAX_URL_STRING because that is what
    //  we use everywhere else.  we could just remove the
    //  limit however.
    //
    USHORT cb = (USHORT)SIZEOF(URLID) - (USHORT)CbFromCch(1);
    USHORT cchUrl = lstrlen(pszUrl) + 1;
    cchUrl = (USHORT)min(cchUrl, MAX_URL_STRING);
    cb += CbFromCch(cchUrl);

    PURLID purlid = (PURLID)IEILCreate(cb + SIZEOF(USHORT));

    if (purlid)
    {
        //  everything is actually aligned right now...
        purlid->idl.mkid.cb = cb;
        purlid->idl.mkid.abID[0] = SHID_INTERNET_SITE;
        purlid->bType = URLID_URLBASE;
        purlid->uiCP = uiCP;
        ualstrcpyn(purlid->achUrl, pszUrl, cchUrl);
    }

    return (LPITEMIDLIST) purlid;
}
        
LPITEMIDLIST UrlToPidl(UINT uiCP, LPCTSTR pszUrl)
{
    LPITEMIDLIST pidlRet;
    LPCTSTR pszAttachedFrag = UrlGetLocation(pszUrl);
    TCHAR szURLBuf[MAX_URL_STRING];

    //  deal with URL's that still include the location (as in ParseDisplayName)
    if (pszAttachedFrag) 
    {
        INT cch = (INT) min((pszAttachedFrag-pszUrl+1), ARRAYSIZE(szURLBuf));
        StrCpyN(szURLBuf, pszUrl, cch);
        pszUrl = szURLBuf;
    }

    ASSERT(pszUrl);
    
    pidlRet = _UrlIdCreate(uiCP, pszUrl);

    if (pidlRet && pszAttachedFrag && *pszAttachedFrag)
        pidlRet = IEILAppendFragment(pidlRet, pszAttachedFrag);

    return pidlRet;
}

typedef struct
{
    LPCSTR pszProtocol;
    const CLSID * pCLSID;
} FAULTIN_URLHANDERS;

// TODO: If there are other URL Handlers, add them here.
const FAULTIN_URLHANDERS c_FaultInUrlHandlers[] =
{
    {"ftp", &CLSID_FTPShellExtension}
};

HRESULT CInternetFolder::_FaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IUnknown * punkSite)
{
    HRESULT hr = S_OK;
    if (pszProtocol)
    {
        for (int nIndex = 0; nIndex < ARRAYSIZE(c_FaultInUrlHandlers); nIndex++)
        {
            if (!StrCmpIA(pszProtocol, c_FaultInUrlHandlers[nIndex].pszProtocol))
            {
                // Only fault in the feature if we are navigating to an FTP directory.
                if ((0 == nIndex) && !UrlIs(pszUrl, URLIS_DIRECTORY))
                {
                    // It's not an ftp directory, so skip it.
                    continue;
                }

                // FTP has a URL Shell Extension handler that is optionally
                // installed.  Fault it in now if it's needed.
                uCLSSPEC ucs;
                QUERYCONTEXT qc = { 0 };
                HWND hwnd = NULL;

                ucs.tyspec = TYSPEC_CLSID;
                ucs.tagged_union.clsid = *c_FaultInUrlHandlers[nIndex].pCLSID;

                IUnknown_GetWindow(punkSite, &hwnd);
                if (EVAL(hwnd))
                {
                    // Make it modal while the dialog is being displayed.
                    IUnknown_EnableModless(punkSite, FALSE);
                    FaultInIEFeature(hwnd, &ucs, &qc, 0);
                    IUnknown_EnableModless(punkSite, TRUE);
                }
                break;    // pidl can only have 1 procotol, so we don't need to check the other protocol.
            }
        }
    }

    return hr;    // We don't care if it didn't make it.
}


HRESULT CInternetFolder::_ConditionallyFaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    // Faulting in the feature will probably require UI, so we need to assure that the caller
    // will allow this.
    if (pbc)
    {
        IUnknown * punkSite = NULL;

        pbc->GetObjectParam(STR_DISPLAY_UI_DURING_BINDING, &punkSite);
        if (punkSite)
        {
            hr = _FaultInUrlHandler(pszProtocol, pszUrl, punkSite);
            punkSite->Release();
        }
    }

    ASSERT(SUCCEEDED(hr));
    return S_OK;    // We don't care if it didn't make it.
}


// returns:
//      success S_OK
//      failure FAILED(hres)

HRESULT CInternetFolder::_CreateProtocolHandler(LPCSTR pszProtocol, IBindCtx * pbc, IShellFolder **ppsf)
{
    HRESULT hres;
    CHAR szCLSID[GUIDSTR_MAX];
    DWORD cbSize = SIZEOF(szCLSID);

    *ppsf = NULL;

    if (pszProtocol && 
        SHGetValueA(HKEY_CLASSES_ROOT, pszProtocol, "ShellFolder", NULL, &szCLSID, &cbSize) == ERROR_SUCCESS)
    {
        CLSID clsid;
        IShellFolder *psf;

        GUIDFromStringA(szCLSID, &clsid);
        if (!SHSkipJunction(pbc, &clsid))
        {
            hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hres))
            {
                // IPersistFolder is optional
                IPersistFolder *ppf;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                {
                    ppf->Initialize(_pidlRoot);
                    ppf->Release();
                }

                IDelegateFolder *pdf;
                hres = psf->QueryInterface(IID_PPV_ARG(IDelegateFolder, &pdf));
                if (SUCCEEDED(hres))
                {
                    // REVIEW: we could cache the malloc on a per protocol basis
                    // to avoid creating these over and over
                    IMalloc *pmalloc;
                    hres = CDelegateMalloc_Create((void*)pszProtocol, (lstrlenA(pszProtocol) + 1), PDID_SIG, &pmalloc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pdf->SetItemAlloc(pmalloc);
                        pmalloc->Release();
                    }
                    pdf->Release();
                }

                if (SUCCEEDED(hres))
                {
                    hres = S_OK;    // force all success codes to S_OK 
                    *ppsf = psf;
                }
                else
                    psf->Release();
            }
        }
        else
            hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else
        hres = E_FAIL;

    return hres;
}

// returns:
//      S_FALSE if it is not a delegate protocol PIDL
//      hres of the bind opteration to the delegate protocol handler

HRESULT CInternetFolder::_CreateProtocolHandlerFromPidl(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsf)
{
    LPCSTR pszProtocol = _PidlToDelegateProtocol(pidl);
    if (pszProtocol)
    {
        HRESULT hres = _CreateProtocolHandler(pszProtocol, pbc, ppsf);
        ASSERT(hres != S_FALSE);    // enforce the return value comment
        return hres;
    }

    *ppsf = NULL;
    return S_FALSE;     // not a protocal PIDL
}

BOOL _GetUrlProtocol(LPCTSTR pszUrl, LPSTR pszProtocol, DWORD cchProtocol)
{
    TCHAR sz[MAX_PATH];
    DWORD cch = SIZECHARS(sz);
    if (SUCCEEDED(UrlGetPart(pszUrl, sz, &cch, URL_PART_SCHEME, 0)))
    {
        SHTCharToAnsi(sz, pszProtocol, cchProtocol);
        return TRUE;
    }

    return FALSE;
}

UINT CodePageFromBindCtx(LPBC pbc)
{
    UINT uiCP = CP_ACP;
    IDwnCodePage *pDwnCP;
    if (pbc && SUCCEEDED(pbc->QueryInterface(IID_PPV_ARG(IDwnCodePage, &pDwnCP))))
    {
        uiCP = pDwnCP->GetCodePage();
        pDwnCP->Release();
    }
    return uiCP;
}

#define STR_PARSE_INTERNET_DONT_ESCAPE_SPACES   L"Parse Internet Dont Escape Spaces"

HRESULT CInternetFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    HRESULT hres = E_FAIL;

    TCHAR szName[MAX_URL_STRING];
    StrCpyN(szName, pwszDisplayName, ARRAYSIZE(szName));
    if (!PathIsFilePath(szName))
    {
        if (_ValidateURL(szName, 0) || ShouldShellExecURL(szName))
        {
            CHAR szProtocol[MAX_PATH];
            DWORD cchName = ARRAYSIZE(szName);
            IShellFolder *psfHandler;
            BOOL fProtocolExists;

            //  fShellExecParse is set when we detect we are being called for
            //  ShellExecute purposes.  We don't want to auto-bind to the 
            //  shell protocol handler for things like ftp: in this case
            //  because we need to invoke the default ftp handler for ShellExecute.
            BOOL fShellExecParse;

            // if we're down here, then the szName was really a url so try to encode it.
            // turn spaces to %20, unless we are being called from shellexec
            // in which case we allow spaces in the URL
            if (!BindCtx_ContainsObject(pbc, STR_PARSE_INTERNET_DONT_ESCAPE_SPACES))
            {
                UrlEscape(szName, szName, &cchName, URL_ESCAPE_SPACES_ONLY);
                fShellExecParse = FALSE;
            }
            else
            {
                //  Make sure the default registered protocol handler gets invoked for
                //  ShellExecute.
                fShellExecParse = TRUE;
            }

            fProtocolExists = _GetUrlProtocol(szName, szProtocol, ARRAYSIZE(szProtocol));
            _ConditionallyFaultInUrlHandler(szProtocol, szName, pbc);

           if (!fShellExecParse && 
                fProtocolExists &&
                _CreateProtocolHandler(szProtocol, pbc, &psfHandler) == S_OK)
            {
                TraceMsg(TF_PIDLWRAP, "Asking \"%s\" handler to parse %s (%08X) into a pidl", szProtocol, szName, szName);
                hres = psfHandler->ParseDisplayName(hwnd, pbc,
                                                    pwszDisplayName, pchEaten,
                                                    ppidl, pdwAttributes);
                TraceMsg(TF_PIDLWRAP, "the result is %08X, the pidl is %08X", hres, *ppidl);
                psfHandler->Release();
                TraceMsg(TF_URLNAMESPACE, "CODF::PDN(%s) called psfHandler and returning %x",
                         szName, hres);
            }
            else
            {
                *ppidl = UrlToPidl(CodePageFromBindCtx(pbc), szName);
                if (*ppidl)
                {
                    if (pdwAttributes)
                        hres = _GetAttributesOfProtocol(NULL, (LPCITEMIDLIST *)ppidl, 1, pdwAttributes);
                    else
                        hres = S_OK;
                }
                else 
                    hres = E_OUTOFMEMORY;

                TraceMsg(TF_URLNAMESPACE, "CODF::PDN(%s) called UrlToPidl and returning %x", szName, hres);
            }
        } 
        else 
        {
            TraceMsg(DM_CDOFPDN, "CDOF::PDN(%s) returning E_FAIL because of (%s) is FALSE", szName, TEXT("(_ValidateURL(szName) || ShouldShellExecURL( szName ))"));
        }
    } 

    return hres;
}

class CInternetFolderDummyEnum : public IEnumIDList
{
public:
    CInternetFolderDummyEnum();
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumIDList methods ***
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    STDMETHODIMP Reset(void){return E_NOTIMPL;}
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum){return E_NOTIMPL;}

protected:
    ~CInternetFolderDummyEnum() {;}
    
    long _cRef;
};

CInternetFolderDummyEnum::CInternetFolderDummyEnum() : _cRef(1)
{
}

HRESULT CInternetFolderDummyEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CInternetFolderDummyEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CInternetFolderDummyEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInternetFolderDummyEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CInternetFolderDummyEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    pceltFetched = 0;
    return S_FALSE;
}

HRESULT CInternetFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    CInternetFolderDummyEnum *pdummy = new CInternetFolderDummyEnum();

    if (pdummy)
    {
        *ppenumIDList = (IEnumIDList *)pdummy;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInternetFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut)
{
    IShellFolder *psfHandler = NULL;
    BOOL fUseDefault = TRUE;
    *ppvOut = NULL;

    if (!_IsValidUrlID(pidl))
        return E_INVALIDARG;
        
    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, pbc, &psfHandler);
    if (hres == S_OK)
    {
        // NOTE: We allow Shell Extensions to take over URL handling on a per
        //     URL basis.  We entered the _CreateProtocolHandlerFromPidl()
        //     block of code above because
        //     a shell extension is registered to take over handling  this
        //     URL.  The above call to IShellFolder::BindToObject() just failed,
        //     so we need to fall back and handle it in the traditional way.
        //     This can be used by Shell Extensions, like the Ftp ShellExt, to
        //     let the browser (us) handle URLs that are either inaccessible because of
        //     the proxy or allow the browser to handle it so the traditional code
        //     will: 1) download the item(s), 2) sniff the data for the type, 3)
        //     use the suggested MIME type from the server or in the web page, 4)
        //     check the file for type extension mappings, 5)
        //     check any downloaded file for security certificates, and 6) display
        //     Open/Save dialogs.
            
        hres = psfHandler->BindToObject(pidl, pbc, riid, ppvOut);

        //  the handler will return ERROR_CANCELLED if it wants default behavior
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hres)
            fUseDefault = FALSE;
    }

    if (fUseDefault)
    {
        STRRET strRet;

        if (psfHandler)
        {
            //  we had a delegated folder that failed, need a normal pidl
            hres = psfHandler->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &strRet);
        }
        else
            hres = GetDisplayNameOf(pidl, SHGDN_FORPARSING, &strRet);

        TCHAR szUrl[MAX_URL_STRING];
        if (SUCCEEDED(hres) &&
            SUCCEEDED(hres = StrRetToBuf(&strRet, pidl, szUrl, ARRAYSIZE(szUrl))))
        {
            if (IsEqualIID(IID_IMoniker, riid))
            {
                hres = MonikerFromURL(szUrl, (IMoniker **)ppvOut);
            }
            else // DEFAULT
            {
                //  create a ShellFolder for the caller
                hres = E_OUTOFMEMORY;
                LPITEMIDLIST pidlT = NULL;

                //  if we are using a handler but it returned cancelled,
                //  then we need to recreate the pidl for ourselves to use
                //  otherwise we just use the one that was passed in, 
                //  which we assume was the one we created.
                if (psfHandler)
                {
                    pidlT = UrlToPidl(CP_ACP, szUrl);
                    pidl = pidlT;
                }

                if (pidl)
                {
                    LPITEMIDLIST pidlFull = ILCombine(_pidlRoot, pidl);

                    if (pidlFull)
                    {
                        CDocObjectFolder *psf = new CDocObjectFolder(pidlFull);
                        if (psf)
                        {
                            hres = psf->QueryInterface(riid, ppvOut);
                            psf->Release();
                        }
                        
                        ILFree(pidlFull);
                    }

                    ILFree(pidlT);
                }
            }
        }
    }

    
    if (psfHandler)
        psfHandler->Release();
        
    return hres;
}

HRESULT CInternetFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
{
    IShellFolder *psfHandler;

    *ppvObj = NULL;

    if (!_IsValidUrlID(pidl))
        return E_INVALIDARG;

    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, pbc, &psfHandler);
    if (hres != S_FALSE)
    {
        if (SUCCEEDED(hres))
        {
            hres = psfHandler->BindToStorage(pidl, pbc, riid, ppvObj);
            psfHandler->Release();
        }
        return hres;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

int CALLBACK CompareDelegateProtocols(void *pv1, void *pv2, LPARAM lParam)
{
    LPCSTR psz1 = _PidlToDelegateProtocol((LPCITEMIDLIST)pv1);
    LPCSTR psz2 = _PidlToDelegateProtocol((LPCITEMIDLIST)pv2);

    if (psz1 && psz2)
    {
        int iRet = StrCmpA(psz1, psz2);
        if (0 == iRet && lParam)
            *((LPCSTR *)lParam) = psz1;
    }
    else if (psz1)
    {
        return 1;
    }
    else if (psz2)
    {
        return -1;
    }
    return 0;
}


HRESULT CInternetFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;

    ASSERT(!ILIsEmpty(pidl1) && !ILIsEmpty(pidl2));

    // Check for protocol pidls.
    LPCSTR psz = NULL;
    iRet = CompareDelegateProtocols((void *)pidl1, (void *)pidl2, (LPARAM)&psz);
    if (iRet)
        return ResultFromShort(iRet);

    if (psz)
    {
        IShellFolder *psfHandler;
        if (_CreateProtocolHandler(psz, NULL, &psfHandler) == S_OK)
        {
            iRet = psfHandler->CompareIDs(lParam, pidl1, pidl2);
            psfHandler->Release();
            return ResultFromShort(iRet);
        }
        
    }

    //  we only have one layer of children
    ASSERT(ILIsEmpty(_ILNext(pidl1)));
    ASSERT(ILIsEmpty(_ILNext(pidl2)));

    PCURLID purlid1 = _IsValidUrlID(pidl1);

    if (purlid1)
    {
        PCURLID purlid2 = _IsValidUrlID(pidl2);

        if (purlid2)
        {
            iRet = _CompareURL(purlid1, purlid2);
        }
        else
        {
            iRet = -1;
        }
    }
    else
    {
        iRet = 1;
    }

    return ResultFromShort(iRet);
}


HRESULT CInternetFolder::_GetAttributesOfProtocol(LPCSTR pszProtocol,
                                                   LPCITEMIDLIST *apidl,
                                                   UINT cpidl, ULONG *rgfInOut)
{
    HRESULT hres;

    ASSERT(cpidl);
    
    if (pszProtocol)
    {
        //
        // We have a protocol.  Find the protocol handler
        // and pass it the bundle of pidls.
        //
        IShellFolder *psfHandler;
        hres = _CreateProtocolHandler(pszProtocol, NULL, &psfHandler);
        if (hres == S_OK)
        {
            hres = psfHandler->GetAttributesOf(cpidl, apidl, rgfInOut);
            psfHandler->Release();
        }
    }
    else if (_IsValidUrlID(apidl[0]))
    {
        ULONG uOut = SFGAO_CANLINK | SFGAO_BROWSABLE | SFGAO_STREAM;
        *rgfInOut &= uOut;
        hres = S_OK;
        
    }
    else
        hres = E_INVALIDARG;

    return hres;
}


HRESULT CInternetFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    if (*rgfInOut)
    {
        //
        // Internet folder case.
        //
        LPCSTR pszProtocol;

        if (cidl == 0)
        {
            //
            // They are asking about the Internet Folder itself.
            //
            *rgfInOut &= SFGAO_FOLDER | SFGAO_CANLINK | SFGAO_STREAM;
        }
        else if (cidl == 1)
        {
            //
            // Often we are asked about only one child,
            // so we optimize that case.
            //
            pszProtocol = _PidlToDelegateProtocol(apidl[0]);

            _GetAttributesOfProtocol(pszProtocol, apidl, cidl, rgfInOut);
        }
        else
        {
            //
            // They are asking about multiple internet children.
            // These children may have different protocols,
            // so we have to find the GetAttributesOf handler for
            // each group of protocols in the list.
            //
            LPCITEMIDLIST pidlBase;
            UINT i, cpidlGroup;

            // Create a list of pidls sorted by protocol.
            HDPA hdpa = DPA_Create(100);
            if (!hdpa)
                return E_OUTOFMEMORY;

            for (i = 0; i < cidl; i++)
            {
                DPA_AppendPtr(hdpa, (void *)apidl[i]);
            }
            DPA_Sort(hdpa, CompareDelegateProtocols, NULL);

            //
            // Call GetAttributesOf on each protocol group.
            // A group
            //   starts at pidlBase
            //   contains cpidlGroup pidls
            //   has a protocol of pszProtocol
            //
            pidlBase = (LPCITEMIDLIST)DPA_FastGetPtr(hdpa, 0);
            pszProtocol = NULL;
            cpidlGroup = 0;
            for (i = 0; *rgfInOut && (i < cidl); i++)
            {
                LPCITEMIDLIST pidlNew = (LPCITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                LPCSTR pszProtocolNew = _PidlToDelegateProtocol(pidlNew);
                if (pszProtocolNew)
                {
                    // See if we have a new protocol.
                    if (!pszProtocol || StrCmpA(pszProtocol, pszProtocolNew))
                    {
                        // We have a new protocol, time to process
                        // the last batch pidls.
                        _GetAttributesOfProtocol(pszProtocol, &pidlBase, cpidlGroup, rgfInOut);

                        pidlBase = pidlNew;
                        pszProtocol = pszProtocolNew;
                        cpidlGroup = 0;
                    }
                }
                cpidlGroup++;
            }
            if (*rgfInOut)
            {
                ASSERT(cpidlGroup);
                _GetAttributesOfProtocol(pszProtocol, &pidlBase, cpidlGroup, rgfInOut);
            }

            DPA_Destroy(hdpa);
            hdpa = NULL;
        }
    }

    return S_OK;
}

BOOL GetCommonProtocol(LPCITEMIDLIST *apidl, UINT cpidl, LPCSTR *ppszProtocol)
{
    UINT ipidl;
    LPCSTR pszProtocol;
    LPCSTR pszProtocolNext;

    *ppszProtocol = NULL;

    if (cpidl == 0)
    {
        return TRUE;    // No pidls - no protocols, but they do all match!
    }

    //
    // Grab the protocol of the first pidl, and use it to compare
    // against the rest of the pidls.
    //
    pszProtocol = _PidlToDelegateProtocol(apidl[0]);

    for (ipidl=1; ipidl<cpidl; ipidl++)
    {

        pszProtocolNext = _PidlToDelegateProtocol(apidl[ipidl]);

        //
        // Check if the protocols are different.
        //
        if ((pszProtocol != pszProtocolNext) &&
            ((pszProtocol == NULL) ||
             (pszProtocolNext == NULL) ||
             (StrCmpA(pszProtocol, pszProtocolNext) != 0)))
        {
            return FALSE;
        }
    }

    *ppszProtocol = pszProtocol;
    return TRUE;
}

HRESULT _CombineHidden(LPCITEMIDLIST pidl, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName)
{
    HRESULT hres = S_OK;
    // 
    //  need to correctly append the fragment and query to the base
    //  if pszName is a DOSPATH, it will be converted to a
    //  file: URL so that it can accomadate the location
    //
    WCHAR sz[MAX_URL_STRING];
    DWORD cch = cchName;

    if (ILGetHiddenStringW(pidl, IDLHID_URLQUERY, sz, SIZECHARS(sz)))
        hres = UrlCombineW(pszName, sz, pszName, &cch, 0);
    
    if (!(dwIEFlags & IEGDN_NOFRAGMENT) && IEILGetFragment(pidl, sz, SIZECHARS(sz)))
    {
        hres = UrlCombineW(pszName, sz, pszName, &cchName, 0);
    }

    //  else 
    //      BUBBUG - should we return just the fragment in some case?
    return hres;
}

HRESULT CInternetFolder::_GetUIObjectFromShortcut(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut)
{
    HRESULT hres = E_NOINTERFACE;
    STRRET str;
    TCHAR sz[MAX_URL_STRING];

    if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)) 
    && SUCCEEDED(StrRetToBuf(&str, pidl, sz, ARRAYSIZE(sz)))
    && SUCCEEDED(_CombineHidden(pidl, 0, sz, ARRAYSIZE(sz))))
    {
        IUniformResourceLocator *purl;
        hres = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUniformResourceLocator, &purl));
        if (SUCCEEDED(hres))
        {
            hres = purl->SetURL(sz, 0);
            
            if (SUCCEEDED(hres))
            {
                IShellLink * psl;
                if (SUCCEEDED(purl->QueryInterface(IID_PPV_ARG(IShellLink, &psl))))
                {
                    if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_INFOLDER, &str)) &&
                        SUCCEEDED(StrRetToBuf(&str, pidl, sz, ARRAYSIZE(sz))))
                    {
                        PathRenameExtension(sz, TEXT(".url"));
                        psl->SetDescription(sz);
                    }
                    psl->Release();
                }
                
                hres = purl->QueryInterface(riid, ppvOut);
            }
            purl->Release();
        }
    }       

    return hres;
}

HRESULT CInternetFolder::_GetScheme(LPCITEMIDLIST pidl, LPWSTR pszOut, DWORD cchOut)
{
    STRRET str;
    LPCSTR pszProtocol = _PidlToDelegateProtocol(pidl);

    if (pszProtocol)
    {
        SHAnsiToUnicode(pszProtocol, pszOut, cchOut);
        return S_OK;
    }
    else if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
    {
        WCHAR sz[MAX_URL_STRING];
        if (SUCCEEDED(StrRetToBufW(&str, pidl, sz, ARRAYSIZE(sz))))
        {
            return UrlGetPartW(sz, pszOut, &cchOut, URL_PART_SCHEME, 0);
        }
    }
    return E_FAIL;
}
    
HRESULT CInternetFolder::_AssocCreate(LPCITEMIDLIST pidl, REFIID riid, void * *ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        WCHAR szScheme[MAX_PATH];
        _GetScheme(pidl, szScheme, SIZECHARS(szScheme));

        hr = pqa->Init(0, szScheme, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pqa->QueryInterface(riid, ppv);

        pqa->Release();
    }

    return hr;
}

HRESULT CInternetFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut)
{
    HRESULT hres = E_NOINTERFACE;
    LPCSTR pszProtocol;
    
    *ppvOut = NULL;

    if (apidl[0] && GetCommonProtocol(apidl, cidl, &pszProtocol) && pszProtocol)
    {
        IShellFolder *psfHandler;
        hres = _CreateProtocolHandlerFromPidl(apidl[0], NULL, &psfHandler);
        if (hres != S_FALSE)
        {
            if (SUCCEEDED(hres))
            {
                hres = psfHandler->GetUIObjectOf(hwnd, 1, apidl, riid, prgfInOut, ppvOut);
                psfHandler->Release();
            }
            return hres;
        }
    }
    else if (IsEqualIID(riid, IID_IExtractIconA) 
         || IsEqualIID(riid, IID_IExtractIconW) 
         || IsEqualIID(riid, IID_IContextMenu)
         || IsEqualIID(riid, IID_IQueryInfo)
         || IsEqualIID(riid, IID_IDataObject))
    {
        //  WARNING - we only support this for one at a time.
        if (cidl == 1)
        {
            hres = _GetUIObjectFromShortcut(apidl[0], riid, ppvOut);
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        //  WARNING - we only support this for one at a time.
        if (cidl == 1)
        {
            hres = _AssocCreate(apidl[0], riid, ppvOut);
        }
    }
        


    return hres;
}

HRESULT CInternetFolder::_InitHistoryStg(IUrlHistoryStg **pphist)
{
    HRESULT hr;
    if (!_phist)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUrlHistoryStg, &_phist));
    }
    
    if (_phist)
    {
        *pphist = _phist;
        _phist->AddRef();
        return S_OK;
    }

    return hr;
}

HRESULT CInternetFolder::_GetTitle(LPCWSTR pszUrl, STRRET *pstr)
{
    ASSERT(pszUrl);

    IUrlHistoryStg *phist;

    HRESULT hr = _InitHistoryStg(&phist);

    if (SUCCEEDED(hr))
    {
        ASSERT(phist);
        STATURL stat = {0};
        hr = phist->QueryUrl(pszUrl, STATURL_QUERYFLAG_NOURL, &stat);

        if (SUCCEEDED(hr) && stat.pwcsTitle)
        {
            hr = StringToStrRet(stat.pwcsTitle, pstr); 
            CoTaskMemFree(stat.pwcsTitle);
        }
        else
            hr = E_FAIL;

        phist->Release();
    }

    return hr;
}

HRESULT CInternetFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    IShellFolder *psfHandler;
    HRESULT hr = _CreateProtocolHandlerFromPidl(pidl, NULL, &psfHandler);
    if (hr != S_FALSE)
    {
        if (SUCCEEDED(hr))
        {
            hr = psfHandler->GetDisplayNameOf(pidl, uFlags, pstr);
            psfHandler->Release();
        }
        return hr;
    }

    // FEATURE ZEKEL - should i handle more SHGDN flags here?? - Zekel - 24-NOV-98
    PCURLID purlid = _IsValidUrlID(pidl);
    if (purlid)
    {
        WCHAR sz[MAX_URL_STRING];

        _ExtractURL(purlid, sz, SIZECHARS(sz));

        if (SHGDN_NORMAL != uFlags)
            hr = StringToStrRet(sz, pstr); 
        else
        {
            hr = _GetTitle(sz, pstr);

            //  fallback to the URL if necessary
            if (FAILED(hr))
                hr = StringToStrRet(sz, pstr); 
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CInternetFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut)
{
    IShellFolder *psfHandler;
    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, NULL, &psfHandler);
    if (hres != S_FALSE)
    {
        if (SUCCEEDED(hres))
        {
            hres = psfHandler->SetNameOf(hwnd, pidl, pszName, uFlags, ppidlOut);
            psfHandler->Release();
        }
        return hres;
    }

    return E_FAIL;
}


HRESULT CInternetFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_Internet;
    return S_OK;
}


// IBrowserFrameOptions
HRESULT CInternetFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // The only case I know of that we hit this code is when you select "Internet Explorer" in the
    // Folder Browser Band.
    HRESULT hr = E_INVALIDARG;

    if (pdwOptions)
    {
        // CInternetFolder should only be used for the "Internet Explorer" pidl that
        // points to the Start Page, so find the start page and substitute it during
        // navigation.
        *pdwOptions |= dwMask & (BFO_SUBSTITUE_INTERNET_START_PAGE | BASE_OPTIONS);
        hr = S_OK;
    }

    return hr;
}



#ifdef DEBUG
extern void remove_from_memlist(void *pv);
#endif

STDAPI CInternetFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CInternetFolder *psf = new CInternetFolder;
    if (psf)
    {
        //
        // HACK:
        //
        //   SHELL32 caches c_sfInetRoot in a static DATA section
        //  and never release it. It caches an instance of CInternetFolder
        //  and never release it. Therefore, we are removing this object
        //  from the to-be-memleak-detected list to avoid a false alarm
        //  assuming that we don't realy leak this object.
        //   Please don't copy it to another place unless you are really
        //  sure that it's OK not to detect leaks in that scenario.
        //  (SatoNa)
        //
        HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        psf->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}
    

STDAPI MonikerFromURL(LPCWSTR wszPath, IMoniker** ppmk)
{
    HRESULT hres = CreateURLMoniker(NULL, wszPath, ppmk);
    if (FAILED(hres)) 
    {
        IBindCtx* pbc;
        hres = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hres)) 
        {
            // Fall back to a system (file) moniker
            ULONG cchEaten = 0;
            hres = MkParseDisplayName(pbc, wszPath, &cchEaten, ppmk);
            pbc->Release();
        }
    }

    return hres;
}

STDAPI MonikerFromString(LPCTSTR szPath, IMoniker** ppmk)
{
    return MonikerFromURL(szPath, ppmk);
}

HRESULT InitPSFInternet()
{
    if (g_psfInternet)
        return S_OK;

    IShellFolder *psfTemp;
    HRESULT hres = CoCreateInstance(CLSID_CURLFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolder, &psfTemp));
    if (SUCCEEDED(hres)) 
    {
        IPersistFolder* ppsf;
        hres = psfTemp->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppsf));
        if (SUCCEEDED(hres)) 
        {
            hres = ppsf->Initialize(c_pidlURLRoot);
            if (SUCCEEDED(hres))
            {
                if (SHInterlockedCompareExchange((void **)&g_psfInternet, psfTemp, 0) == 0)
                    psfTemp->AddRef();  // global now holds ref
            }
            ppsf->Release();
        }
        psfTemp->Release();
    }
    return hres;
}

HRESULT _GetInternetRoot(IShellFolder **ppsfRoot)
{
    HRESULT hr = InitPSFInternet();
    *ppsfRoot = NULL;

    if (SUCCEEDED(hr))
    {
        g_psfInternet->AddRef();
        *ppsfRoot = g_psfInternet;
    }
    return hr;
}

HRESULT _GetRoot(LPCITEMIDLIST pidl, BOOL fIsUrl, IShellFolder **ppsfRoot)
{
    HRESULT hr;
    *ppsfRoot = NULL;
    
    if (fIsUrl)
    {
        ASSERT(IsURLChild(pidl, TRUE));
        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using the Internet", pidl);
        hr = _GetInternetRoot(ppsfRoot);
    }
    else
    {
        ASSERT(ILIsRooted(pidl));
        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using Rooted", pidl);

        CLSID clsid;

        ILRootedGetClsid(pidl, &clsid);

        if (IsEqualGUID(clsid, CLSID_ShellDesktop))
        {
            hr = SHBindToObject(NULL, IID_IShellFolder, ILRootedFindIDList(pidl), (void **)ppsfRoot);
        }
        else
        {
            IShellFolder *psf;
            hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlRoot = ILRootedFindIDList(pidl);
                if (!pidlRoot)
                    pidlRoot = &s_idlNULL;

                IPersistFolder* ppf;
                hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
                if (SUCCEEDED(hr))
                {
                    hr = ppf->Initialize(pidlRoot);
                    ppf->Release();
                }

                //  hand over the reference
                *ppsfRoot = psf;
            }
        }
    }

    return hr;
}


STDAPI_(BOOL) IEILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fIgnoreHidden)
{
    UINT cb = ILGetSize(pidl1);

    if (cb != ILGetSize(pidl2) || 0 != memcmp(pidl1, pidl2, cb))
    {
        //  THEY are binarily different
        BOOL fRet = FALSE;
        BOOL fWebOnly = FALSE;

        if (IsURLChild(pidl1, TRUE) || IsURLChild(pidl2, TRUE))
            fWebOnly = TRUE;
       
        if ((IsURLChild(pidl1, FALSE) && IsURLChild(pidl2, FALSE))
        || (ILIsRooted(pidl1) && ILIsEqualRoot(pidl1, pidl2)))
        {
            IShellFolder *psf;
            if (SUCCEEDED(_GetRoot(pidl1, fWebOnly, &psf)))
            {
                if (0 == psf->CompareIDs(0, _ILNext(pidl1), _ILNext(pidl2)))
                    fRet = TRUE;

                psf->Release();
            }
        }
        
        if (!fRet && !fWebOnly)
        {
#undef ILIsEqual
            fRet = ILIsEqual(pidl1, pidl2);
        }
        
        if (fRet && !fIgnoreHidden)
        {
            fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_URLFRAGMENT));

            if (fRet)
                fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_URLQUERY));

            if (fRet)
                fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_NAVIGATEMARKER));
        }
        return fRet;
    }
    
    return TRUE;
}

// pszName must be MAX_URL_STRING
STDAPI IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags)
{
    return IEGetNameAndFlagsEx(pidl, uFlags, 0, pszName, MAX_URL_STRING, NULL);
}

HRESULT _GetInternetFolderName(LPWSTR pszName, DWORD cchName)
{
    LPCTSTR pszKey;
    DWORD cbSize = CbFromCch(cchName);

    if (4 > GetUIVersion())
        pszKey = TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}");
    else
        pszKey = TEXT("CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}"); 

    if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszKey, NULL, NULL, pszName, &cbSize)
    && *pszName)
        return S_OK;

    if (MLLoadString(IDS_REG_THEINTERNET, pszName, cchName)
    && *pszName)
        return S_OK;

    return E_UNEXPECTED;
}

STDAPI IEGetNameAndFlagsEx(LPCITEMIDLIST pidl, UINT uSHFlags, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs)
{
    HRESULT hres = E_FAIL;

    if (pszName)
    {
        *pszName = 0;
    }

    //  for support of NON-integrated builds, and 
    //  to expedite handling of URLs while browsing
    if (IsURLChild(pidl, FALSE)) 
    {
        hres = InitPSFInternet();
        if (SUCCEEDED(hres))
        {
            if (pszName)
            {
                STRRET str;
                hres = g_psfInternet->GetDisplayNameOf(_ILNext(pidl), uSHFlags, &str);
                if (SUCCEEDED(hres))
                {
                    StrRetToBufW(&str, pidl, pszName, cchName);
                }
            }

            if (prgfInOutAttrs)
                hres = IEGetAttributesOf(pidl, prgfInOutAttrs);
            
        }
    } 
    else if (GetUIVersion() <= 4 && IsURLChild(pidl, TRUE))
    {
        //
        //  we need to support requests for the Internet SFs
        //  Friendly name.  on NT5 we will always have something
        //  even when the SF is hidden.  but on older versions
        //  of the shell, it was possible to delete the folder
        //  by just removing the icon from the desktop
        //

        if (pszName)
            hres = _GetInternetFolderName(pszName, cchName);

        if (prgfInOutAttrs)
            hres = IEGetAttributesOf(pidl, prgfInOutAttrs);
    }
    else if (ILIsRooted(pidl))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlChild;
        
        hres = IEBindToParentFolder(pidl, &psf, &pidlChild);
        if (SUCCEEDED(hres))
        {
            if (pszName)
            {
                STRRET str;
                hres = IShellFolder_GetDisplayNameOf(psf, pidlChild, uSHFlags, &str, 0);
                if (SUCCEEDED(hres))
                {
                    hres = StrRetToBufW(&str, pidlChild, pszName, cchName);
                }
            }

            if (prgfInOutAttrs)
                hres = psf->GetAttributesOf(ILIsEmpty(pidlChild) ? 0 : 1, &pidlChild, prgfInOutAttrs);

            psf->Release();
        }
    } 
    else
        hres = SHGetNameAndFlags(pidl, uSHFlags, pszName, cchName, prgfInOutAttrs);

    if (SUCCEEDED(hres) && pszName && (uSHFlags & SHGDN_FORPARSING))
    {
        hres = _CombineHidden(pidl, dwIEFlags, pszName, cchName);
    }

    TraceMsg(TF_URLNAMESPACE, "IEGDN(%s) returning %x", pszName, hres);
    return hres;
}

STDAPI IEGetNameAndFlags(LPCITEMIDLIST pidl, UINT uFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs)
{
    return IEGetNameAndFlagsEx(pidl, uFlags, 0, pszName, cchName, prgfInOutAttrs);
}


BOOL _ClassIsBrowsable(LPCTSTR pszClass)
{
    BOOL fRet = FALSE;
    HKEY hk;
    
    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_CLASS, pszClass, NULL, &hk)))
    {
        fRet = (NOERROR == RegQueryValueEx(hk, TEXT("DocObject"), NULL, NULL, NULL, NULL)
             || NOERROR == RegQueryValueEx(hk, TEXT("BrowseInPlace"), NULL, NULL, NULL, NULL));

        RegCloseKey(hk);
    }

    return fRet;
}

BOOL _MimeIsBrowsable(LPCTSTR pszExt)
{
    BOOL fRet = FALSE;
    TCHAR sz[MAX_PATH];
    DWORD dwSize = ARRAYSIZE(sz);         

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExt, NULL, sz, &dwSize)))
    {
        TCHAR szKey[MAX_PATH];
        dwSize = SIZEOF(sz);

        // Get the CLSID for the handler of this content type.
         wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("MIME\\Database\\Content Type\\%s"), sz);

        // reuse sz for the clsid
        if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, szKey, TEXT("CLSID"), NULL, (void *) sz, &dwSize))
        {
            fRet = _ClassIsBrowsable(sz);
        }
    }
    return fRet;
}
                    
BOOL _StorageIsBrowsable(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
    //
    // If the file is STILL not browsable, try to open it as a structured storage
    // and check its CLSID.
    //
    IStorage *pStg = NULL;

    if (StgOpenStorage(pszPath, NULL, STGM_SHARE_EXCLUSIVE, NULL, 0, &pStg ) == S_OK && pStg)
    {
        STATSTG  statstg;
        if (pStg->Stat( &statstg, STATFLAG_NONAME ) == S_OK)
        {
            TCHAR szClsid[GUIDSTR_MAX];
            SHStringFromGUIDW(statstg.clsid, szClsid, SIZECHARS(szClsid));
            
            fRet = _ClassIsBrowsable(szClsid);
        }
        
        pStg->Release();
    }

    return fRet;
}

BOOL _IEIsBrowsable(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    BOOL fRet = FALSE;
    
    if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)))
    {
        // Don't change the order of the following OR'd conditions because
        // we want the HTML test to go first.  Also, the NT5 shell will
        // do the ClassIsBrowsable check for us, so we should avoid repeating
        // that check.

        if (PathIsHTMLFile(szPath)
        || _ClassIsBrowsable(szPath)
        || _MimeIsBrowsable(PathFindExtension(szPath))
        || _StorageIsBrowsable(szPath))
            fRet = TRUE;
    }
    
    return fRet;
}


HRESULT _IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs, BOOL fAllowExtraChecks)
{
    HRESULT hres = E_FAIL;
    DWORD dwAttribs = *pdwAttribs;
    BOOL fExtraCheckForBrowsable = FALSE;

    //
    // REARCHITECT - Check if we need to execute an additional logic - ZekeL - 7-JAN-99
    // to see if it's browsable or not. this is necessary on shell32s from NT4/win95/IE4 
    // both NT4/win95 have no notion of SFGAO_BROWSABLE, and even though
    // IE4 does, it doesnt handle it correctly for UNICODE file names.
    // We are just as thorough (more) in our private check, so just defer to it.  
    //
    // 78777: Even if we are on NT5, IE can browse things that Shell thinks is not 
    // browsable, for example, .htm files when Netscape is the default browser.  
    // So we should do the extra check on every platform.

    if (fAllowExtraChecks && (dwAttribs & SFGAO_BROWSABLE)) 
    {
        dwAttribs |= SFGAO_FILESYSTEM | SFGAO_FOLDER;
        fExtraCheckForBrowsable = TRUE;
    }

    IShellFolder* psfParent;
    LPCITEMIDLIST pidlChild;
    
    if (ILIsEmpty(pidl))
    {
        hres = SHGetDesktopFolder(&psfParent);
        pidlChild = pidl;
    }
    else if (ILIsRooted(pidl) && ILIsEmpty(_ILNext(pidl)))
    {
        //  
        //  when getting the attributes of the root itself, we
        //  decide its better to just limit the attribs to 
        //  some easily supported subset.  we used to always
        //  fail, but that is a little extreme.
        //
        //  we could also try to get the attributes from HKCR\CLSID\{clsid}\shellfolder\attributes
        //
        *pdwAttribs &= (SFGAO_FOLDER);
        return S_OK;
    }
    else 
    {
        if (GetUIVersion() < 4 && IsURLChild(pidl, TRUE))
        {
            IShellFolder *psfRoot;
            //
            //  if we are Browser Only, and this is the
            //  internet folder itself that we are interested
            //  in, then we need to bind to it by hand
            //  and query it with cidl = 0
            //
            hres = _GetInternetRoot(&psfRoot);

            if (SUCCEEDED(hres))
            {
                hres = SHBindToFolderIDListParent(psfRoot, _ILNext(pidl), IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
                psfRoot->Release();
            }
        }
        else if (ILIsRooted(pidl))
            hres = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
        else
            hres = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    }

    if (SUCCEEDED(hres))
    {
        ASSERT(psfParent);
        hres = psfParent->GetAttributesOf(ILIsEmpty(pidlChild) ? 0 : 1, &pidlChild, &dwAttribs);

        if (FAILED(hres))
            TraceMsg(TF_WARNING, "IEGetAttribs psfParent->GetAttr failed %x", hres);

        psfParent->Release();
    }   
    else
        TraceMsg(TF_WARNING, "IEGetAttribs BindTOParent failed %x", hres);

    //
    //  This is the extra logic we need to execute if this is a browser
    // only mode to get the right "browsable" attribute flag to DocObjects.
    //
    if (fExtraCheckForBrowsable && !(dwAttribs & SFGAO_BROWSABLE))
    {
        if ((dwAttribs & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) 
        {
            if (_IEIsBrowsable(pidl))
                dwAttribs |= SFGAO_BROWSABLE;
        }
    }

    *pdwAttribs &= dwAttribs;
    return hres;
}

HRESULT IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs)
{
    return _IEGetAttributesOf(pidl, pdwAttribs, TRUE);
}

// BRYANST: 7/22/97  -  NT Bug #188099
// shell32.dll in IE4 SI and only in that version had a bug if pbc was passed
// to IShellFolder::BindToObject() (fstreex.c!FSBindToFSFolder), it would fail
// to bind to Shell Extensions that extended file system folders, such as:
// the history folder, the occache, etc.  We work around this by passing a NULL pbc
// if the destination is an IE4 shell32.dll and it will go thru FSBindToFSFolder().
BOOL ShouldWorkAroundBCBug(LPCITEMIDLIST pidl)
{
    BOOL fWillBCCauseBug = FALSE;

    if (4 == GetUIVersion())
    {
        LPITEMIDLIST pidlCopy = ILClone(pidl);
        LPITEMIDLIST pidlIterate = pidlCopy;

        // Skip the first two ItemIDs. (#1 could be My Computer)
        if (!ILIsEmpty(pidlIterate))
        {
            IShellFolder * psf;

            // (#2 could be CFSFolder::BindToObject())
            pidlIterate = _ILNext(pidlIterate);
            if (!ILIsEmpty(pidlIterate))
            {
                pidlIterate = _ILNext(pidlIterate);
                // Remove everything else so we bind directly to CFSFolder::BindToObject()
                pidlIterate->mkid.cb = 0;

                if (SUCCEEDED(IEBindToObject(pidlCopy, &psf)))
                {
                    IPersist * pp;

                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersist, &pp))))
                    {
                        CLSID clsid;

                        if (SUCCEEDED(pp->GetClassID(&clsid)) && 
                            IsEqualCLSID(clsid, CLSID_ShellFSFolder))
                        {
                            fWillBCCauseBug = TRUE;
                        }

                        pp->Release();
                    }
                    psf->Release();
                }
            }

        }

        ILFree(pidlCopy);
    }

    return fWillBCCauseBug;
}

typedef enum
{
    SHOULDBIND_DOCOBJ,
    SHOULDBIND_DESKTOP,
    SHOULDBIND_NONE,
} SHOULDBIND;

//
//  _ShouldDocObjBind() 
//  returns 
//      SHOULDBIND_DOCOBJ   -  Should just use DocObjectFolder directly
//      SHOULDBIND_DESKTOP  -  bind through the desktop
//      SHOULDBIND_NONE     -  FAIL the bind...
//
SHOULDBIND _ShouldDocObjBind(DWORD dwAttribs, BOOL fStrictBind)
{
    if (fStrictBind)
    {
        if ((dwAttribs & (SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM)) == (SFGAO_BROWSABLE | SFGAO_FILESYSTEM))
            return SHOULDBIND_DOCOBJ;
        else
            return SHOULDBIND_DESKTOP;
    }
    else
    {
        if (dwAttribs & (SFGAO_FOLDER | SFGAO_BROWSABLE))
            return SHOULDBIND_DESKTOP;

        // manually bind using our CDocObjectFolder for
        // files which are not DocObject. Without this code, file:
        // to non-Docobject files (such as multi-media files)
        // won't do anything.
        //
        // is is needed for non integraded browser mode 
        //
        if (dwAttribs & SFGAO_FILESYSTEM) 
            return SHOULDBIND_DOCOBJ;
        else
            return SHOULDBIND_NONE;
    }
}

STDAPI _IEBindToObjectInternal(BOOL fStrictBind, LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, void **ppvOut)
{
    IShellFolder *psfTemp;
    HRESULT hr;

    *ppvOut = NULL;

    // Special case:  If we have the pidl for the "Desktop" then just use the Desktop folder itself
    if (ILIsEmpty(pidl))
    {
        hr = SHGetDesktopFolder(&psfTemp);
        if (SUCCEEDED(hr))
        {
            hr = psfTemp->QueryInterface(riid, ppvOut);
            psfTemp->Release();
        }
    } 
    else 
    {
        BOOL fIsUrlChild = IsURLChild(pidl, TRUE);

        if (fIsUrlChild || ILIsRooted(pidl))
        {
            hr = _GetRoot(pidl, fIsUrlChild, &psfTemp);
            if (SUCCEEDED(hr))
            {
                pidl = _ILNext(pidl);
                
                if (!ILIsEmpty(pidl))
                    hr = psfTemp->BindToObject(pidl, pbc, riid, ppvOut);
                else
                    hr = psfTemp->QueryInterface(riid, ppvOut);

                psfTemp->Release();
            }
        }
        else
        {
            // non integrated browser mode will succeed on 
            // BindToObject(IID_IShellFolder) even for things that should 
            // fail (files). to avoid the down stream problems caused by this we
            // filter out things that are not "browseable" up front, 
            //
            // NOTE: this does not work on simple PIDLs

            DWORD dwAttribs = SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM;

            hr = _IEGetAttributesOf(pidl, &dwAttribs, fStrictBind);
            
            if (SUCCEEDED(hr)) 
            {
                switch (_ShouldDocObjBind(dwAttribs, fStrictBind))
                {
                case SHOULDBIND_DOCOBJ:
                    {
                        //
                        // shortcircuit and bind using our CDocObjectFolder for
                        // files which are BROWSABLE. Without this code, file:
                        // to non-Docobject files (such as multi-media files)
                        // won't do anything.
                        //
                        // is is needed for non integraded browser mode 
                        //
                        CDocObjectFolder *pdof = new CDocObjectFolder();

                        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using DocObjectFolder", pidl);
                        if (pdof)
                        {
                            hr = pdof->Initialize(pidl);
                            if (SUCCEEDED(hr)) 
                                hr = pdof->QueryInterface(riid, ppvOut);
                            pdof->Release();
                        }
                        else
                            hr = E_OUTOFMEMORY;    
                    }
                    break;

                case SHOULDBIND_DESKTOP:
                    {
                        //
                        // This is the normal case. We just bind down through the desktop...
                        //
                        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using Desktop", pidl);

                        hr = SHGetDesktopFolder(&psfTemp);
                        if (SUCCEEDED(hr))
                        {
                            // BRYANST: 7/22/97  -  NT Bug #188099
                            // shell32.dll in IE4 SI and only in that version had a bug if pbc was passed
                            // to IShellFolder::BindToObject() (fstreex.c!FSBindToFSFolder), it would fail
                            // to bind to Shell Extensions that extended file system folders, such as:
                            // the history folder, the occache, etc.  We work around this by passing a NULL pbc
                            // if the destination is an IE4 shell32.dll and it will go thru FSBindToFSFolder().
                            if (pbc && ShouldWorkAroundBCBug(pidl))
                            {
                                pbc = NULL;
                            }

                            hr = psfTemp->BindToObject(pidl, pbc, riid, ppvOut);
                            psfTemp->Release();
                        }
                    } 
                    break;

                default:
                    hr = E_FAIL;
                }
            } 
        }
    }

    if (SUCCEEDED(hr) && !*ppvOut)
    {
        // Some NSEs have bugs where they will fail to fill in the
        // out pointer but return SUCCEEDED(hr).  WS_FTP is one example
        // in NT #413950.
        TraceMsg(TF_URLNAMESPACE, "IEBTO() BUG!!! An NSE succeeded but returned a NULL interface pointer.");
        hr = E_FAIL;
    }
    
    TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) returning %x", pidl, hr);

    return hr;
}

STDAPI IEBindToObjectEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppvOut)
{
    return _IEBindToObjectInternal(TRUE, pidl, pbc, riid, ppvOut);
}

STDAPI IEBindToObject(LPCITEMIDLIST pidl, IShellFolder **ppsfOut)
{
    return _IEBindToObjectInternal(TRUE, pidl, NULL, IID_PPV_ARG(IShellFolder, ppsfOut));
}

//  CLASSIC BIND here
HRESULT IEBindToObjectForNavigate(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut)
{
    return _IEBindToObjectInternal(FALSE, pidl, pbc, IID_PPV_ARG(IShellFolder, ppsfOut));
}


//
// CDwnCodePage: Dummy supports IBindCtx interface object only for casting
//               It holds codepage info to pass via LPBC parameter
//
class CDwnCodePage : public IBindCtx
                   , public IDwnCodePage
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindCtx methods
    STDMETHODIMP RegisterObjectBound(IUnknown *punk) { return (_pbc ? _pbc->RegisterObjectBound(punk) : E_NOTIMPL); };
    STDMETHODIMP RevokeObjectBound(IUnknown *punk) { return (_pbc ? _pbc->RevokeObjectBound(punk) : E_NOTIMPL); };
    STDMETHODIMP ReleaseBoundObjects(void) { return (_pbc ? _pbc->ReleaseBoundObjects() : E_NOTIMPL); };
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts) { return (_pbc ? _pbc->SetBindOptions(pbindopts) : E_NOTIMPL); };
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts) { return (_pbc ? _pbc->GetBindOptions(pbindopts) : E_NOTIMPL); };
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot) { *pprot = NULL; return (_pbc ? _pbc->GetRunningObjectTable(pprot) : E_NOTIMPL); };
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk) { return (_pbc ? _pbc->RegisterObjectParam(pszKey, punk) : E_NOTIMPL); };
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk) { *ppunk = NULL; return (_pbc ? _pbc->GetObjectParam(pszKey, ppunk) : E_NOTIMPL); };
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum) { *ppenum = NULL; return (_pbc ? _pbc->EnumObjectParam(ppenum) : E_NOTIMPL); };
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey) { return (_pbc ? _pbc->RevokeObjectParam(pszKey) : E_NOTIMPL); };

    STDMETHODIMP RemoteSetBindOptions(BIND_OPTS2 *pbindopts) { return E_NOTIMPL; };
    STDMETHODIMP RemoteGetBindOptions(BIND_OPTS2 *pbindopts) { return E_NOTIMPL; };

    // IDwnCodePage methods
    STDMETHODIMP_(UINT) GetCodePage(void) { return _uiCodePage; };
    STDMETHODIMP SetCodePage(UINT uiCodePage) { _uiCodePage = uiCodePage; return S_OK; };

    // Constructor
    CDwnCodePage(IBindCtx * pbc, UINT uiCodePage) : _cRef(1) { _uiCodePage = uiCodePage; _pbc = NULL; IUnknown_Set((IUnknown **)&_pbc, (IUnknown *)pbc); };
    ~CDwnCodePage() { ATOMICRELEASE(_pbc); };

private:
    int     _cRef;
    UINT    _uiCodePage;
    IBindCtx * _pbc;
};

STDAPI CDwnCodePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDwnCodePage, IBindCtx),
        QITABENT(CDwnCodePage, IDwnCodePage), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CDwnCodePage::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CDwnCodePage::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;
}

// IEParseDisplayName() will do all of the below functionality in IECreateFromPathCPWithBC()
// plus the following two things:
// 1.  It will call ParseURLFromOutsideSource(), so this is more friendly to
//     strings from outside sources.
// 2.  If the URL has a fragment, this function will pass out a PIDL with the last
//     ID being the location.
HRESULT IECreateFromPathCPWithBCW(UINT uiCP, LPCWSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut)
{
    TraceMsg(TF_URLNAMESPACE, "IECFP(%s) called", pszPath);

    HRESULT hr = S_OK;
    WCHAR szPath[MAX_URL_STRING];
    WCHAR szBuf[MAX_PATH];
    DWORD cchBuf = ARRAYSIZE(szBuf);
    CDwnCodePage DwnCodePage(pbc, uiCP);
    DWORD len;

    // Initialize for failure case
    *ppidlOut = NULL;

    // if we are passed a NULL path, then there is no way we can convert it to a pidl.
    // in some cases the reason we are passed a NULL path is because the IShellFolder
    // provider was unable to generate a parseable display name (MSN Classic 1.3 is
    // a very good example, they return E_NOTIMPL).
    if ( ((len = lstrlen( pszPath )) == 0)  || len >= MAX_URL_STRING )
    {
        return E_FAIL;
    }

    // Is this a "file:" URL?
    if (IsFileUrlW(pszPath) && SUCCEEDED(hr = PathCreateFromUrl(pszPath, szBuf, &cchBuf, 0)))
        pszPath = szBuf;

    BOOL fIsFilePath = PathIsFilePath(pszPath);

#ifdef FEATURE_IE_USE_DESKTOP_PARSING
    //
    //  in order to take advantage of whatever enhancements the desktop
    //  makes to parsing (eg, WebFolders and shell: URLs), then we allow
    //  the desktop first go at it.  it will loop back into the internet
    //  shell folder if all the special cases fail.
    //      maybe use a reg setting to control???
    //
    //
    if (fIsFilePath || GetUIVersion() >= 5)
#else // !FEATURE_IE_USE_DESKTOP_PARSING
    //
    //  right now we just use the desktop if its a file path or
    //  it is a shell: URL on NT5
    //
    if (fIsFilePath || (GetUIVersion() >= 5 && URL_SCHEME_SHELL == GetUrlSchemeW(pszPath)))
#endif // FEATURE_IE_USE_DESKTOP_PARSING
    {
        ASSERT(SUCCEEDED(hr));
        
        // Resolve any dot-dot path reference and remove trailing backslash
        if (fIsFilePath)
        {
            PathCanonicalize(szPath, pszPath);
            pszPath = szPath;

            // This call will cause a network hit: one connection attempt to \\server\IPC$
            // and then a series of FindFirst's - one for each directory.
            if (StrChr(pszPath, L'*') || StrChr(pszPath, L'?'))
            {
                hr = E_FAIL;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(pszPath, ppidlOut, NULL);               
            TraceMsg(DM_CDOFPDN, "IECreateFromPath psDesktop->PDN(%s) returned %x", pszPath, hr);
        }
    }
    else
    {
        //
        // Need to put in buffer since ParseDisplayName doesn't take a 'const' string.
         StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));
        pszPath = szPath;

        // Avoid the network and disk hits above for non-file urls.
        // This code path is taken on http: folks so a nice optimization. We will then drop
        // down below where we check the internet namespace.
        IShellFolder *psfRoot;
        hr = _GetInternetRoot(&psfRoot);
        if (SUCCEEDED(hr))
        {
            TraceMsg(TF_URLNAMESPACE, "IECFP(%s) calling g_psfInternet->PDN %x", pszPath, hr);
            LPITEMIDLIST pidlRel;

            hr = psfRoot->ParseDisplayName(NULL, (IBindCtx*)&DwnCodePage, szPath, NULL, &pidlRel, NULL);
            TraceMsg(DM_CDOFPDN, "IECreateFromPath called psfInternet->PDN(%s) %x", pszPath, hr);
            if (SUCCEEDED(hr))
            {
                *ppidlOut = ILCombine(c_pidlURLRoot, pidlRel);
                if (!*ppidlOut)
                    hr = E_OUTOFMEMORY;
                ILFree(pidlRel);
            }
            
            psfRoot->Release();
        }

    }

    // NOTE: NT5 beta 3 and before had a call to SHSimpleIDListFromPath().
    //       This is very bad because it will parse any garbage and prevent
    //       the caller from finding invalid strings.  I(BryanSt) needed
    //       this fixed for IEParseDisplayNameWithBCW() would fail on invalid
    //       address bar strings ("Search Get Rich Quick").
    TraceMsg(TF_URLNAMESPACE, "IECFP(%s) returning %x (hr=%x)",
             pszPath, *ppidlOut, hr);

    return hr;
}

HRESULT IECreateFromPathCPWithBCA(UINT uiCP, LPCSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut)
{
    WCHAR szPath[MAX_URL_STRING];

    ASSERT(lstrlenA(pszPath) < ARRAYSIZE(szPath));
    SHAnsiToUnicodeCP(uiCP, pszPath, szPath, ARRAYSIZE(szPath));

    return IECreateFromPathCPWithBCW(uiCP, szPath, pbc, ppidlOut);
}


HRESULT IEParseDisplayName(UINT uiCP, LPCTSTR pszPath, LPITEMIDLIST * ppidlOut)
{
    return IEParseDisplayNameWithBCW(uiCP, pszPath, NULL, ppidlOut);
}


// This function will do two things that IECreateFromPathCPWithBC() will not do:
// 1.  It will add the "Query" section of the URL into the pidl.
// 2.  If the URL has a fragment, this function will pass out a PIDL with the last
//     ID being the location.
// NOTE: If the caller needs the string to be "cleaned up" because the user manually
//       entered the URL, the caller needs to call ParseURLFromOutsideSource() before
//       calling this function.  That function should only be called on strings entered
//       by the user because of the perf hit and it could incorrectly format valid
//       parsible display names.  For example, ParseURLFromOutsideSource() will
//       convert the string "My Computer" into a search URL for yahoo.com
//       (http://www.yahoo.com/search.asp?p=My+p=Computer) when some callers
//       want that string parsed by an IShellFolder in the desktop.
HRESULT IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut)
{
    TCHAR szPath[MAX_URL_STRING];
    LPCWSTR pwszFileLocation = NULL;
    WCHAR szQuery[MAX_URL_STRING];
    HRESULT hres;

    szQuery[0] = TEXT('\0');
#ifdef DEBUG
    if (IsFlagSet(g_dwDumpFlags, DF_URL)) 
    {
        TraceMsg(DM_TRACE, "IEParseDisplayName got %s", szPath);
    }
#endif

    //  We want to remove QUERY and FRAGMENT sections of
    //  FILE URLs because they need to be added in "Hidden" pidls.
    //  Also, URLs need to be escaped all the time except for paths
    //  to facility parsing and because we already removed all other
    //  parts of the URL (Query and Fragment).
    if (IsFileUrlW(pwszPath)) 
    {
        DWORD cchQuery = SIZECHARS(szQuery) - 1;
        
        pwszFileLocation = UrlGetLocationW(pwszPath);        

        if (SUCCEEDED(UrlGetPart(pwszPath, szQuery+1, &cchQuery, URL_PART_QUERY, 0)) && cchQuery)
            szQuery[0] = TEXT('?');

        DWORD cchPath = ARRAYSIZE(szPath);
        if (FAILED(PathCreateFromUrl(pwszPath, szPath, &cchPath, 0))) 
        {
            // Failed to parse it back. Use the original.
            StrCpyN(szPath, pwszPath, ARRAYSIZE(szPath));
        }
    }        
    else 
    {
        // If we failed, just try to use the original
        StrCpyN(szPath, pwszPath, ARRAYSIZE(szPath));
    }

#ifdef DEBUG
    if (IsFlagSet(g_dwDumpFlags, DF_URL)) 
        TraceMsg(DM_TRACE, "IEParseDisplayName calling IECreateFromPath %s", szPath);
#endif

    hres = IECreateFromPathCPWithBC(uiCP, szPath, pbc, ppidlOut);
    if (SUCCEEDED(hres) && pwszFileLocation)
    {
        ASSERT(*ppidlOut);
        *ppidlOut = IEILAppendFragment(*ppidlOut, pwszFileLocation);
        hres = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hres) && szQuery[0] == TEXT('?'))
    {
        *ppidlOut = ILAppendHiddenString(*ppidlOut, IDLHID_URLQUERY, szQuery);
        hres = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shembed.cpp ===
#include "priv.h"
#include "sccls.h"

#include <mluisupp.h>

#define IPSMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s called", psz)
#define IPSMSG2(psz, hres)      TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s %x", psz, hres)
#define IPSMSG3(pszName, psz)   TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s:%s called", pszName,psz)
#define IOOMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called", psz)
#define IOOMSGX(psz, hres)      TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s returning %x", psz, hres)
#define IOOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called with (%d)", psz, i)
#define IOOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called with (%d, %d)", psz, i, j)
#define IVOMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s called", psz)
#define IVOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s called with (%d)", psz, i)
#define IVOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s with (%d, %d)", psz, i, j)
#define CCDMSG(psz, punk)       TraceMsg(TF_SHDCONTROL, "she TR-CSV::%s called punk=%x", psz, punk)
#define IDTMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called", psz)
#define IDTMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called with %d", psz, i)
#define IDTMSG3(psz, x)         TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s %x", psz, x)
#define IDTMSG4(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called with %x,%x", psz, i, j)
#define IIPMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOIPO::%s called", psz)
#define IIAMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOIPAO::%s called", psz)
#define IEVMSG(psz, i, j, ps)   TraceMsg(TF_SHDCONTROL, "she TR-IEV::%s called celt=%d, _iCur=%d, %x", psz, i, j, ps)

const TCHAR c_szShellEmbedding[] = TEXT("Shell Embedding");

//
// A special lindex value to be passed to ::Draw member indicating
// that it is an internal call from ::GetData
//
#define LINDEX_INTERNAL 12345

// REVIEW: We may want to use the functions in UTIL.C -- they look more efficient...
//
//=========================================================================
// Helper functions
//=========================================================================

#define HIM_PER_IN 2540

int g_iXppli = 0;
int g_iYppli = 0;

void GetLogPixels()
{
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        g_iXppli = GetDeviceCaps(hdc, LOGPIXELSX);
        g_iYppli = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }
}

// Scalar conversion of MM_HIMETRIC to MM_TEXT
void MetricToPixels(SIZEL* psize)
{
    ASSERT(g_iXppli);

    psize->cx = MulDiv(psize->cx, g_iXppli, HIM_PER_IN);
    psize->cy = MulDiv(psize->cy, g_iYppli, HIM_PER_IN);
}

// Scalar conversion of MM_TEXT to MM_HIMETRIC
void PixelsToMetric(SIZEL* psize)
{
    ASSERT(g_iYppli);

    psize->cx = MulDiv(psize->cx, HIM_PER_IN, g_iXppli);
    psize->cy = MulDiv(psize->cy, HIM_PER_IN, g_iYppli);
}


//=========================================================================
// CShellEmbedding implementaiton
//=========================================================================
HRESULT CShellEmbedding::v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellEmbedding, IPersist),
        QITABENT(CShellEmbedding, IOleObject),
        QITABENT(CShellEmbedding, IViewObject2),
        QITABENTMULTI(CShellEmbedding, IViewObject, IViewObject2),
        QITABENT(CShellEmbedding, IDataObject),
        QITABENT(CShellEmbedding, IOleInPlaceObject),
        QITABENTMULTI(CShellEmbedding, IOleWindow, IOleInPlaceObject),
        QITABENT(CShellEmbedding, IOleInPlaceActiveObject),
        QITABENT(CShellEmbedding, IInternetSecurityMgrSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

CShellEmbedding::CShellEmbedding(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs)
    : _pverbs(pverbs)
    , _nActivate(OC_DEACTIVE)
    , CAggregatedUnknown(punkOuter)
{
    TraceMsg(TF_SHDCONTROL, "ctor CShellEmbedding %x", this);

    DllAddRef();
    _RegisterWindowClass();
    _pObjectInfo = poi;
    _size.cx = 50;
    _size.cy = 20;

    // make sure some globals are set
    GetLogPixels();

    // let our logical size match our physical size
    _sizeHIM = _size;
    PixelsToMetric(&_sizeHIM);
}

CShellEmbedding::~CShellEmbedding()
{
    ASSERT(_hwnd==NULL);
    // IE v 4.1 bug 44541.  In an Office 97 user form, we were seeing this destructor get entered
    // with a non-null hwnd, which would cause a fault the next time the hwnd received a message.
    // 
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    ASSERT(_hwndChild==NULL);
    ASSERT(_pcli==NULL);
    ASSERT(_pipsite==NULL);
    ASSERT(_pipframe==NULL);
    ASSERT(_pipui==NULL);

    //
    // WARNING: Don't call any of virtual functions of this object
    //  itself for clean-up purpose. The Vtable is alreadly adjusted
    //  and we won't be able to perform any full clean up. Do it
    //  right before you delete in CShellEmbedding::CSVInner::Release.
    //
    TraceMsg(TF_SHDCONTROL, "dtor CShellEmbedding %x", this);

    // Warning: if the client site has not been released do not release the advise
    // object as some applications like VC5 will fault on this...
    if (_padv) {
        _padv->OnClose();
        if (!_pcli)
            ATOMICRELEASE(_padv);
    }

    if (!_pcli)
    {
        ATOMICRELEASE(_pdah);
        ATOMICRELEASE(_poah);
    }
    ATOMICRELEASE(_pstg);
    ATOMICRELEASE(_pcliHold);


    DllRelease();
}

// **************** IPersist ****************
HRESULT CShellEmbedding::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSIDOFOBJECT(this);

    return S_OK;
}

BOOL CShellEmbedding::_ShouldDraw(LONG lindex)
{
    // Don't draw if the window is visible.
    return ! (_pipsite && lindex!=LINDEX_INTERNAL);
}

// **************** IViewObject ****************
HRESULT CShellEmbedding::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    IVOMSG3(TEXT("Draw called"), lprcBounds->top, lprcBounds->bottom);

    // WARNING: this looks wrong to me -- I think we should always respond
    // to a Draw request, as the hdcDraw may not be the screen!
    //
    // Don't draw if the window is visible.
    if (!_ShouldDraw(lindex)) {
        return S_OK;
    }

    if (_hwnd) {
        int iDC = SaveDC(hdcDraw);
          RECTL rcBounds = *lprcBounds;
          ::LPtoDP(hdcDraw, (LPPOINT)&rcBounds, 2);
          IVOMSG3(TEXT("Draw DP=="), rcBounds.top, rcBounds.bottom);
          TraceMsg(TF_SHDCONTROL, "she Draw cx=%d cy=%d", rcBounds.right-rcBounds.left, rcBounds.bottom-rcBounds.top);

          SetMapMode(hdcDraw, MM_TEXT);         // make it 1:1
          SetMapMode(hdcDraw, MM_ANISOTROPIC);  // inherit call from MM_TEXT
          POINT pt;
          SetViewportOrgEx(hdcDraw, rcBounds.left, rcBounds.top, &pt);

          // APPCOMPAT: WordPad does a GetExtent to get the size and passes that in as lprcBounds
          // *without* doing a SetExtent, so when we resize larger (due to a BROWSE verb) _hwnd
          // is still the old size. So we IntersectClipRect to _hwnd but WordPad draws the border
          // to rcBounds. Ugly.

           RECT rc;
           GetClientRect(_hwnd, &rc);
           IntersectClipRect(hdcDraw, 0, 0, rc.right, rc.bottom);
           SendMessage(_hwnd, WM_PRINT, (WPARAM)hdcDraw,
                       PRF_NONCLIENT|PRF_CLIENT|PRF_CHILDREN|PRF_ERASEBKGND);

         SetViewportOrgEx(hdcDraw, pt.x, pt.y, NULL);
        RestoreDC(hdcDraw, iDC);
        return S_OK;
    }

    return OLE_E_BLANK;
}

HRESULT CShellEmbedding::GetColorSet(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    IVOMSG(TEXT("GetColorSet"));
    return S_FALSE;     // Indicating that the object doesn't care
}

HRESULT CShellEmbedding::Freeze(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DWORD *pdwFreeze)
{
    IVOMSG(TEXT("Freeze"));
    *pdwFreeze = 0;
    return S_OK;
}

HRESULT CShellEmbedding::Unfreeze(DWORD dwFreeze)
{
    IVOMSG(TEXT("Unfreeze"));
    return S_OK;
}

HRESULT CShellEmbedding::SetAdvise(
    DWORD aspects,
    DWORD advf,
    IAdviseSink *pAdvSink)
{
    IVOMSG2(TEXT("SetAdvise"), pAdvSink);

    if (advf & ~(ADVF_ONLYONCE | ADVF_PRIMEFIRST))
        return E_INVALIDARG;

    if (pAdvSink != _padv)
    {
        ATOMICRELEASE(_padv);

        if (pAdvSink)
        {
            _padv = pAdvSink;
            _padv->AddRef();
        }
    }

    _asp  = aspects;
    _advf = advf;

    if (advf & ADVF_PRIMEFIRST)
        _SendAdvise(OBJECTCODE_VIEWCHANGED);

    return S_OK;
}

HRESULT CShellEmbedding::GetAdvise(
    DWORD *pAspects,
    DWORD *pAdvf,
    IAdviseSink **ppAdvSink)
{
    IVOMSG(TEXT("GetAdvise"));
    if (pAspects) {
        *pAspects = _asp;
    }

    if (pAdvf) {
        *pAdvf = _advf;
    }

    if (ppAdvSink) {
        *ppAdvSink = _padv;
        if (_padv) {
            _padv->AddRef();
        }
    }

    return S_OK;
}

// **************** IViewObject2 ****************
HRESULT CShellEmbedding::GetExtent(
    DWORD dwDrawAspect,
    LONG lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL lpsizel)
{
    TraceMsg(TF_SHDCONTROL, "she GetExtent cx=%d cy=%d", _size.cx, _size.cy);
    lpsizel->cx = _size.cx;
    lpsizel->cy = _size.cy;
    PixelsToMetric(lpsizel);
    return S_OK;
}

//
// **************** IOleObject ****************
//

void CShellEmbedding::_OnSetClientSite()
{
    if (_pcli)
    {
        IOleInPlaceSite* pipsite;
        if (SUCCEEDED(_pcli->QueryInterface(IID_IOleInPlaceSite, (LPVOID*)&pipsite)))
        {
            _CreateWindowOrSetParent(pipsite);
            pipsite->Release();
        }
    }
    else if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
}

HRESULT CShellEmbedding::SetClientSite(IOleClientSite *pClientSite)
{
    IOOMSG2(TEXT("SetClientSite"), pClientSite);

    // If I have a client site on hold, get rid of it.
    //
    ATOMICRELEASE(_pcliHold);

    if (_pcli == pClientSite)
    {
        // mshtml is hitting their initialization code twice
        // no need for us to do anything here.
    }
    else
    {
        ATOMICRELEASE(_pcli);
        ATOMICRELEASE(_pipsite);
        ATOMICRELEASE(_pipframe);
        ATOMICRELEASE(_pipui);
    
        _pcli = pClientSite;
    
        if (_pcli)
            _pcli->AddRef();

        _OnSetClientSite();
    }

    return S_OK;
}


//
//  This function create _hwnd (the parent of this embedding) if it not
// created yet. Otherwise, it simply SetParent appropriately.
//
// NOTE: When this object is embedded in PowerPoint 95, the first
//  CreateWindowEx fails  when this function if called from SetClientSite
//  for some unknown reason.
//   It, however, succeeds when it is called from DoVerb. We should find
//  it out.
//
HRESULT CShellEmbedding::_CreateWindowOrSetParent(IOleWindow* pwin)
{
    HWND hwndParent = NULL;
    HRESULT hres = S_OK;

    //
    // NOTES: Unlike IE3.0, we don't fail even if pwin->GetWindow fails.
    //  It allows Trident to SetClientSite (and Navigate) before they
    //  are In-place Activated. In that case (hwndParent==NULL), we
    //  create a top-level window hidden and use it for navigation.
    //  When we are being InPlaceActivated, we hit this function again
    //  and set the parent (and window styles) correctly. Notice that
    //  we need to set WS_POPUP to avoid the Window Manager automatically
    //  add other random styles for verlapped window. 
    //
    pwin->GetWindow(&hwndParent);
#ifdef DEBUG
    // Pretend that GetWindow failed here.
    if (_hwnd==NULL && (g_dwPrototype & 0x00000200))
    {
        TraceMsg(DM_TRACE, "CSE::_CreateWindowOrSetParent pretend unsuccessful GetWindow");
        hwndParent = NULL;
    }
#endif

    _fOpen = TRUE;
    
    if (_hwnd) 
    {
        SetParentHwnd(_hwnd, hwndParent);

    } 
    else 
    {
        _hwnd = SHNoFusionCreateWindowEx(
            WS_EX_WINDOWEDGE,
            c_szShellEmbedding, NULL,
            (hwndParent ?
                (WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP)
                : (WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP)),
            0, 0, _rcPos.right - _rcPos.left, _rcPos.bottom - _rcPos.top,
            hwndParent,
            (HMENU)0,
            HINST_THISDLL,
            (LPVOID)SAFECAST(this, CImpWndProc*));

        if (!_hwnd) 
        {
            hres = E_FAIL;
            TraceMsg(TF_SHDCONTROL, "sdv TR-IOO::_CreateWindowOrSetParent CreateWindowEx failed (%d)", GetLastError());
        }
    }

    return hres;
}
HRESULT CShellEmbedding::GetClientSite(IOleClientSite **ppClientSite)
{
    IOOMSG(TEXT("GetClientSite"));
    *ppClientSite = _pcli;

    if (_pcli) {
        _pcli->AddRef();
    }

    return S_OK;
}

HRESULT CShellEmbedding::SetHostNames(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj)
{
    IOOMSG(TEXT("SetHostNames"));
    // We are not interested in host name
    return S_OK;
}


// A container application calls IOleObject::Close when it wants
// to move the object from a running to a loaded state. Following
// such a call, the object still appears in its container but is
// not open for editing. Calling IOleObject::Close on an object
// that is loaded but not running has no effect.
//
HRESULT CShellEmbedding::Close(DWORD dwSaveOption)
{
    IOOMSG2(TEXT("Close"), dwSaveOption);
    // Change the state of object back to TEXT("loaded") state.

    BOOL fSave = FALSE;
    if (_fDirty &&
        ((OLECLOSE_SAVEIFDIRTY==dwSaveOption)
         || (dwSaveOption==OLECLOSE_PROMPTSAVE))) {
        fSave = TRUE;
    }

    if (fSave) {
        _SendAdvise(OBJECTCODE_SAVEOBJECT);
        _SendAdvise(OBJECTCODE_SAVED);
    }

    _SendAdvise(OBJECTCODE_CLOSED);
    _fOpen = FALSE;

    // "loaded but not running" is confusing wording... If you look
    // at the OLEIVERB_HIDE comment in _OnActivateChange, it mentions
    // that OLEIVERB_HIDE puts it in the state "just after loading"
    // and puts us in OC_DEACTIVE state. Let's do that here as well.
    //
    // it just came to my awareness that OCs UIDeactivate,
    //         not IPDeactivate...
    _DoActivateChange(NULL, OC_DEACTIVE, FALSE);

    // It seems like some containers (Trident frame set) don't
    // do a SetClientSite(NULL) on us, so do it here. Old code here
    // did a DestroyWindow(_hwnd), which SetClientSite(NULL) will do.
    // NOTE: VB does call SetClientSite, but they do it after Close.

    // If we already have one on hold, release it.
    //
    ATOMICRELEASE(_pcliHold);

    // Hold onto our client site.  We may need it if we're DoVerbed, as Office tends to do.
    //

    IOleClientSite  *pOleClientSite = _pcli;
    if (pOleClientSite)
    {
        pOleClientSite->AddRef();
    }

    SetClientSite(NULL);

    _pcliHold = pOleClientSite;

    return S_OK;
}

HRESULT CShellEmbedding::SetMoniker(
    DWORD dwWhichMoniker,
    IMoniker *pmk)
{
    IOOMSG(TEXT("SetMoniker"));
    // We are not interested in moniker.
    return S_OK;
}

HRESULT CShellEmbedding::GetMoniker(
    DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    IOOMSG(TEXT("GetMoniker"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::InitFromData(
    IDataObject *pDataObject,
    BOOL fCreation,
    DWORD dwReserved)
{
    IOOMSG(TEXT("InitFromData"));
    // LATER: We may want to implement this later.
    return E_FAIL;
}

HRESULT CShellEmbedding::GetClipboardData(
    DWORD dwReserved,
    IDataObject **ppDataObject)
{
    IOOMSG(TEXT("GetClipboardData"));
    return E_FAIL;
}

HRESULT CShellEmbedding::DoVerb(
    LONG iVerb,
    LPMSG lpmsg,
    IOleClientSite *pActiveSite,
    LONG lindex,
    HWND hwndParent,
    LPCRECT lprcPosRect)
{
    IOOMSG2(TEXT("DoVerb"), iVerb);
    HRESULT hres = S_OK;

    // If I don't have a client site, but I have one on "hold", I need to set it up again.
    //
    if (_pcli == NULL
        && _pcliHold)
    {
        IOleClientSite *pOleClientSite = _pcliHold;
        _pcliHold = NULL;
        SetClientSite(pOleClientSite);
        pOleClientSite->Release();
    }

    switch(iVerb)
    {
    case OLEIVERB_HIDE:
        hres = _DoActivateChange(NULL, OC_DEACTIVE, FALSE);
        break;

    case OLEIVERB_OPEN:
        hres = E_FAIL;
        break;

    case OLEIVERB_PRIMARY:
    case OLEIVERB_SHOW:
        if (_pipsite) {
            return S_OK;
        }
        // Fall through
    case OLEIVERB_UIACTIVATE:
        hres = _DoActivateChange(pActiveSite, OC_UIACTIVE, TRUE); //TRUE => We want to force UIACTIVE even if we are already active.
        break;

    case OLEIVERB_INPLACEACTIVATE:
        hres = _DoActivateChange(pActiveSite, OC_INPLACEACTIVE, FALSE);
        break;

    default:
        hres = E_FAIL; // OLEOBJ_S_INVALDVERB;
        break;
    }

    IOOMSGX(TEXT("DoVerb"), hres);
    return hres;
}

//
// fForce == TRUE indicates that we need to call _OnActivateChange even if we
// are already in OC_UIACITVE state.
//
HRESULT CShellEmbedding::_DoActivateChange(IOleClientSite* pActiveSite, UINT uState, BOOL fForce)
{
    if (uState == _nActivate)
    {
        // in general, we have nothing to do if we're already in
        // the correct state. HOWEVER, OLEIVERB_UIACTIVATE is supposed
        // to set focus if we (or our children?) don't currently have it.
        // Fall into _OnActivateChange so CWebBrowserOC can tell the
        // base browser to go uiactive.
        //
        if ((uState != OC_UIACTIVE) || !fForce)
            return S_OK;
    }

    #define STATETOSTRING(n) (n==OC_DEACTIVE ? TEXT("OC_DEACTIVE") : (n==OC_INPLACEACTIVE ? TEXT("OC_INPLACEACTIVE") : (n== OC_UIACTIVE ? TEXT("OC_UIACTIVE") : TEXT("ERROR"))))
    TraceMsg(TF_SHDCONTROL, "she _DoActivateChange from %s to %s", STATETOSTRING(_nActivate), STATETOSTRING(uState));

    return _OnActivateChange(pActiveSite, uState);
}

HRESULT CShellEmbedding::_OnActivateChange(IOleClientSite* pActiveSite, UINT uState)
{
    if (uState != _nActivate)
    {
        // mark us in our new state immediately. this avoids recursion death with bad containers (ipstool)
        UINT uOldState = _nActivate;
        _nActivate = uState;
    
        if (uOldState == OC_DEACTIVE) // going from deactive to IP or UI active
        {
            if (pActiveSite==NULL)
            {
                _nActivate = uOldState;
                return E_INVALIDARG;
            }
    
            ASSERT(!_pipsite); // always true, so why check below?
            if (!_pipsite)
            {
                HRESULT hres = pActiveSite->QueryInterface(IID_IOleInPlaceSite, (LPVOID*)&_pipsite);
        
                if (FAILED(hres))
                {
                    _nActivate = uOldState;
                    return hres;
                }
                
                hres = _pipsite->CanInPlaceActivate();
                if (hres != S_OK) {
                    ATOMICRELEASE(_pipsite);
                    TraceMsg(TF_SHDCONTROL, "she - CanInPlaceActivate returned %x", hres);
                    _nActivate = uOldState;
                    return E_FAIL;
                }
        
                _OnInPlaceActivate(); // do it
            }
        }
        else if (uOldState == OC_UIACTIVE) // going from UIActive to IPActive or deactive
        {
            _OnUIDeactivate();
        }
    
        if (uState == OC_UIACTIVE) // going to UIActive
        {
            _OnUIActivate();
        }
        else if (uState == OC_DEACTIVE) // going to Deactive
        {
            // We fail creation (OLEIVERB_PRIMARY, OLEIVERB_SHOW,
            // OLEIVERB_UIACTIVATE, or OLEIVERB_INPLACEACTIVATE) if we don't
            // get a pipsite, so we should never hit this case.
            ASSERT(_pipsite);
            // OLEIVERB_HIDE should ... return it to the visual state just after
            // initial creation or reloading, before OLEIVERB_SHOW or OLEIVERB_OPEN
            // is sent. Which is what _InPlaceDeactivate does. What's the point of this?
            // htmlobj calls OLEIVERB_HIDE and then ::InPlaceDeactivate
            _OnInPlaceDeactivate();
        }
    }

    return S_OK;
}

// move from de-active to in-place-active
void CShellEmbedding::_OnInPlaceActivate()
{
    //
    // Set the appropriate parent window.
    //
    _CreateWindowOrSetParent(_pipsite);

    _pipsite->OnInPlaceActivate();
    ASSERT(_pipframe == NULL);
    ASSERT(_pipui == NULL);
    _finfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    _pipsite->GetWindowContext(&_pipframe, &_pipui,
                               &_rcPos, &_rcClip, &_finfo);

    TraceMsg(TF_SHDCONTROL, "she::_OnInPlaceActivate x=%d y=%d cx=%d cy=%d (_cx=%d _cy=%d)", _rcPos.left, _rcPos.top, _rcPos.right-_rcPos.left, _rcPos.bottom-_rcPos.top, _size.cx, _size.cy);
    SetWindowPos(_hwnd, 0,
                 _rcPos.left, _rcPos.top,
                 _rcPos.right-_rcPos.left,
                 _rcPos.bottom-_rcPos.top,
                 SWP_SHOWWINDOW | SWP_NOZORDER);

    _SendAdvise(OBJECTCODE_SHOWOBJECT); // just like OLE 2nd ed (p.1074)
}

// Move from in-place-active to de-active
void CShellEmbedding::_OnInPlaceDeactivate(void)
{
    if (_hwnd) {
        ShowWindow(_hwnd, SW_HIDE);

        // re-parent our _hwnd... when we're not active we can't rely on
        // what our parent window is doing. The container can even destroy it!
        //
        // FEATURE: the standard thing to do here is DESTROY our HWND and
        // recreate it if/when we are reactivated. This may break our hosted
        // IShellView and draw code. Investigate this.
        //

        // APPCOMPAT: this has been taken out by CDturner, MikeSH assures me we don't need it, and 
        // this is causing our app to lose activation and regain it which causes the 
        // palette to flash on 256 colour machines...y
        // SetParentHwnd(_hwnd, NULL);
    }

    if (_pipsite) {
        _pipsite->OnInPlaceDeactivate();
        ATOMICRELEASE(_pipsite);
    }

    ATOMICRELEASE(_pipframe);
    ATOMICRELEASE(_pipui);

    //
    // We need to tell the container to update the cached metafile, if any.
    //
    _SendAdvise(OBJECTCODE_DATACHANGED);

}

// move from in-place-active to ui-active
void CShellEmbedding::_OnUIActivate(void)
{
    if (_pipsite) {
        _pipsite->OnUIActivate();
    }

    //
    // HACK: When we are in Excel, _pipui->SetActiveObject sets the focus
    //  to us (for some unknown reason -- trying to be nice?). Since _hwnd
    //  simply forward the focus to the _hwndChild, setting focus to _hwnd
    //  twice causes this:
    //
    //   1. SetFocus(_hwnd)             by us (if we call SetFocus(_hwnd))
    //   2. SetFocus(_hwndChild)        in _hwnd's wndproc
    //   3. SetFocus(_hwnd)             by Excel
    //   4. SetFocus(_hwndChild)        in _hwnd's wndproc
    //
    //   If _hwndChild is a control, it notifies to the parent that it
    //  lost the focus. Then, we think "oh, we lost the focus. We should
    //  deactivate this object". To avoid it, we don't call SetFocus before
    //  we call _pipui->SetActiveObject and do some tricky thing below.
    //
    // SetFocus(_hwnd);

    //
    // RDuke suggest us to change the second parameter to NULL (instead of
    // "FOO" in IE3, but we don't know the side effect of it. I'm changing
    // it to "item" for IE4. (SatoNa)
    //
    if (_pipframe) {
        _pipframe->SetActiveObject(SAFECAST(this, IOleInPlaceActiveObject*), L"item");
    }

    if (_pipui) {
        _pipui->SetActiveObject(SAFECAST(this, IOleInPlaceActiveObject*), L"item");
    }

    //
    // We don't have any menu, so tell the container to use its own menu.
    //
    if (_pipframe) {
        _pipframe->SetMenu(NULL, NULL, _hwnd);
    }

    // Find-out if one of our child window has the input focus.
    for (HWND hwndFocus = GetFocus();
         hwndFocus && hwndFocus!=_hwnd;
         hwndFocus = GetParent(hwndFocus))
    {}

    // If not, set it.
    if (hwndFocus==NULL) {
         SetFocus(_hwnd);
    }

    // If this UIActivate came from below (i.e., our hosted DocObject), then we need to inform
    // our container.  We do this by calling IOleControlSite::OnFocus.  VB5 and Visual FoxPro
    // (at least) rely on this call being made for proper focus handling.
    //
    IUnknown_OnFocusOCS(_pcli, TRUE);
}

void CShellEmbedding::_OnUIDeactivate(void)
{
    //
    // We don't have any shared menu or tools to clean up.
    //

    if (_pipframe) {
        _pipframe->SetActiveObject(NULL, NULL);
    }

    if (_pipui) {
        _pipui->SetActiveObject(NULL, NULL);
    }

    if (_pipsite) {
        _pipsite->OnUIDeactivate(FALSE);
    }
    // If this UIDeactivate came from below (i.e., our hosted DocObject), then we need to inform
    // our container.  We do this by calling IOleControlSite::OnFocus.  VB5 and Visual FoxPro
    // (at least) rely on this call being made for proper focus handling.
    //
    IUnknown_OnFocusOCS(_pcli, FALSE);
}



HRESULT CShellEmbedding::EnumVerbs(
    IEnumOLEVERB **ppEnumOleVerb)
{
    IOOMSG(TEXT("EnumVerbs"));
    *ppEnumOleVerb = new CSVVerb(_pverbs);
    return *ppEnumOleVerb ? S_OK : E_OUTOFMEMORY;
}

HRESULT CShellEmbedding::Update( void)
{
    IOOMSG(TEXT("Update"));
    // Always up-to-date

    return S_OK;
}

HRESULT CShellEmbedding::IsUpToDate( void)
{
    IOOMSG(TEXT("IsUpToDate"));
    // Always up-to-date
    return S_OK;
}

HRESULT CShellEmbedding::GetUserClassID(CLSID *pClsid)
{
    IOOMSG(TEXT("GetUserClassID"));
    return GetClassID(pClsid);
}

HRESULT CShellEmbedding::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return OleRegGetUserType(CLSIDOFOBJECT(this), dwFormOfType, pszUserType);
}

HRESULT CShellEmbedding::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    // SetExtent sets the LOGICAL size of an object. SetObjectRects determins
    // the size of the object on the screen. If we cared about zooming, we'd
    // keep track of this and do some sort of scaling. But we don't.
    // We still need to remember this value so we return it on GetExtent.
    //
    _sizeHIM = *psizel;

    // HOWEVER, IE3 shipped a SetExtent that changed the physical size of the
    // object. For compat (AOL uses SetExtent to change the size), if we're the
    // old WebBrowser, continue to resize.
    //
    if (_pObjectInfo->pclsid == &CLSID_WebBrowser_V1)
    {
        RECT rc;
        HDC   hdc;
        int   mmOld;
        POINT pt;

        // Make sure a container doesn't do anything strange like
        // make us negative size
        //
        // APPCOMPAT: this breaks Trident because it sizes us negative
        // and we fail that sizing and they get confused...
        //
        //ASSERT(psizel->cx >= 0 && psizel->cy <= 0);
        //if (psizel->cx < 0 || psizel->cy > 0)
        //    return E_FAIL;
    
        // We only support DVASPECT_CONTENT
        if (dwDrawAspect != DVASPECT_CONTENT)
            return E_NOTIMPL;
    
        // Map this to a SetObjectRects call -- that way superclasses
        // only have to watch one function for size changes
        //

        int nScaleFactorX = 1, nScaleFactorY = 1;

        pt.x = psizel->cx;
        pt.y = psizel->cy;

        hdc = GetDC(NULL);

        if (hdc)
        {
            mmOld = SetMapMode(hdc, MM_HIMETRIC);

            if (!g_fRunningOnNT)  // if running on Win95
            {
                // Win95 doesn't like coordinates over 32K

                // SHRT_MIN and SHRT_MAX defined in $NT/public/sdk/inc/crt/limits.h

                while (pt.x > SHRT_MAX || pt.x < SHRT_MIN)
                {
                    pt.x >>= 1;
                    nScaleFactorX <<= 1;
                }
                while (pt.y > SHRT_MAX || pt.y < SHRT_MIN)
                {
                    pt.y >>= 1;
                    nScaleFactorY <<= 1;
                }
            }

            LPtoDP(hdc, &pt, 1);

            if (!g_fRunningOnNT)
            {
                pt.x *= nScaleFactorX;
                pt.y *= nScaleFactorY;
            }

            pt.y = -pt.y;
            SetMapMode(hdc, mmOld);
            ReleaseDC(NULL, hdc);
        }
    
        rc.left = _rcPos.left;
        rc.right = rc.left + pt.x;
        rc.top = _rcPos.top;
        rc.bottom = rc.top + pt.y;
    
        // Assume that using SetExtent adjusts both the pos and clip rects
        return SetObjectRects(&rc, NULL);
    }
    else
    {
        return S_OK;
    }
}

HRESULT CShellEmbedding::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    *psizel = _sizeHIM;
    return S_OK;
}

HRESULT CShellEmbedding::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    IOOMSG2(TEXT("Advise"), pAdvSink);
    HRESULT hr = E_INVALIDARG;

    if (!pdwConnection)
        return hr;

    *pdwConnection = NULL;              // set out params to NULL

    if (!_poah)
        hr = ::CreateOleAdviseHolder(&_poah);
    else
        hr = NOERROR;

    if( SUCCEEDED(hr) )
        hr = _poah->Advise(pAdvSink, pdwConnection);

    return(hr);
}

HRESULT CShellEmbedding::Unadvise(DWORD dwConnection)
{
    IOOMSG(TEXT("Unadvise"));
    HRESULT     hr;

    if (!_poah)
        return(OLE_E_NOCONNECTION);

    hr = _poah->Unadvise(dwConnection);

    return(hr);
}

HRESULT CShellEmbedding::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    IOOMSG(TEXT("EnumAdvise"));
    HRESULT     hr;

    if (!ppenumAdvise)
        return(E_INVALIDARG);

    if (!_poah)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = _poah->EnumAdvise(ppenumAdvise);
    }

    return(hr);
}

HRESULT CShellEmbedding::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    IOOMSG(TEXT("GetMiscStatus"));

    *pdwStatus = OLEMISCFLAGSOFCONTROL(this);

    return S_OK;
}

HRESULT CShellEmbedding::SetColorScheme(LOGPALETTE *pLogpal)
{
    IOOMSG(TEXT("GetColorScheme"));
    return S_OK;
}

//
//  Helper function to create an HDC from an OLE DVTARGETDEVICE structure.
//  Very useful for metafile drawing, where the Metafile DC will be the 
//  actual "draw to" dc, and the TargetDC, if present, will describe the ultimate output device.
//
HDC CShellEmbedding::_OleStdCreateDC(DVTARGETDEVICE *ptd)
{
    HDC        hdc = NULL;
    LPDEVNAMES lpDevNames = NULL;
    LPDEVMODEA lpDevMode = NULL;
    LPSTR      lpszDriverName = NULL;
    LPSTR      lpszDeviceName = NULL;
    LPSTR      lpszPortName = NULL;

    if (ptd)
    {
        lpDevNames = (LPDEVNAMES) ptd;
        if (ptd->tdExtDevmodeOffset)
        {
            lpDevMode = (LPDEVMODEA) ( (LPSTR) ptd + ptd->tdExtDevmodeOffset);
        }

        lpszDriverName = (LPSTR) lpDevNames + ptd->tdDriverNameOffset;
        lpszDeviceName = (LPSTR) lpDevNames + ptd->tdDeviceNameOffset;
        lpszPortName   = (LPSTR) lpDevNames + ptd->tdPortNameOffset;

        hdc = CreateDCA(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);
    }
    return hdc;
}

// *** IDataObject ***
//
// WARNING:
//   It is well-known fact that Word and Excel (in Office95) does not call
//  IViewObject::Draw to draw embedding. Instead, they GetData(CF_METAFILEPICT).
//  If we don't offer it, Word will fail to embed it and Excel will draw
//  white rectangle when our object is deactivated. To be embedded correctly
//  on those apps, we must support CF_METAFILEPICT. (SatoNa)
//
HRESULT CShellEmbedding::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    IDTMSG4(TEXT("GetData"), pformatetcIn->cfFormat, pformatetcIn->tymed);
    HRESULT hres = DV_E_FORMATETC;
    HDC hdcTargetDevice = NULL;
    HENHMETAFILE hemf = NULL;

    // If a Target device is specified in the FORMATETC structure, create a DC for it.
    // This gets passed to CreateEnhMetaFile and IViewObject::Draw.
    //
    if (pformatetcIn->ptd) 
    {
        hdcTargetDevice = _OleStdCreateDC(pformatetcIn->ptd);
        if (!hdcTargetDevice)
        {
            return E_FAIL;
        }
    }

    // Enhanced metafiles need special processing.
    //
    if (pformatetcIn->cfFormat == CF_ENHMETAFILE
        && (pformatetcIn->tymed & TYMED_ENHMF))
    {
        if (_hwnd)
        {
            RECTL rectBounds = { 0, 0, _sizeHIM.cx, _sizeHIM.cy };

            //
            // Call the "A" version since we're not passing in strings and
            // this needs to work on W95.
            HDC hdc = CreateEnhMetaFileA(hdcTargetDevice, NULL, (RECT*)&rectBounds, NULL);
            IDTMSG3(TEXT("_EnhMetafileFromWindow CreateEnhMetaFile returned"), hdc);
            if (hdc)
            {
                SetMapMode(hdc, MM_HIMETRIC);
                rectBounds.bottom = -rectBounds.bottom;

                Draw(DVASPECT_CONTENT, LINDEX_INTERNAL, NULL, pformatetcIn->ptd,
                     hdcTargetDevice, hdc, &rectBounds, NULL, NULL, 0);

                hemf = CloseEnhMetaFile(hdc);
                IDTMSG3(TEXT("_EnhMetafileFromWindow CloseEnhMetaFile returned"), hemf);
            }
        }

        pmedium->hEnhMetaFile = hemf;
        if (pmedium->hEnhMetaFile) 
        {
            pmedium->tymed = TYMED_ENHMF;
            pmedium->pUnkForRelease = NULL;
            hres = S_OK;
        } 
        else 
        {
            hres = E_FAIL;
        }
    }

    // Create a standard metafile
    //
    else if (pformatetcIn->cfFormat == CF_METAFILEPICT
        && (pformatetcIn->tymed & TYMED_MFPICT))
    {
        hres = E_OUTOFMEMORY;
        HGLOBAL hmem = GlobalAlloc(GPTR, sizeof(METAFILEPICT));
        if (hmem)
        {
            LPMETAFILEPICT pmf = (LPMETAFILEPICT) hmem;
            RECTL rectBounds = { 0, 0, _sizeHIM.cx, _sizeHIM.cy };

            HDC hdc = CreateMetaFile(NULL);
            if (hdc)
            {
                SetMapMode(hdc, MM_HIMETRIC);
                rectBounds.bottom = -rectBounds.bottom;

                SetWindowOrgEx(hdc, 0, 0, NULL);
                SetWindowExtEx(hdc, _sizeHIM.cx, _sizeHIM.cy, NULL);

                Draw(DVASPECT_CONTENT, LINDEX_INTERNAL, NULL, 
                    pformatetcIn->ptd, hdcTargetDevice,
                    hdc, &rectBounds, &rectBounds, NULL, 0);

                pmf->hMF = CloseMetaFile(hdc);

                if (pmf->hMF)
                {
                    pmf->mm = MM_ANISOTROPIC;
                    pmf->xExt = _sizeHIM.cx;
                    pmf->yExt = _sizeHIM.cy;
                    TraceMsg(TF_SHDCONTROL, "sdv TR ::GetData (%d,%d)-(%d,%d)",
                             _size.cx, _size.cy, _sizeHIM.cx, _sizeHIM.cy);

                    pmedium->tymed = TYMED_MFPICT;
                    pmedium->hMetaFilePict = hmem;
                    pmedium->pUnkForRelease = NULL;
                    hres = S_OK;
                }
            }

            if (FAILED(hres))
            {
                GlobalFree(hmem);
                hmem = NULL;
            }
        }
    }

    if (hdcTargetDevice)
        DeleteDC(hdcTargetDevice);

    return hres;
}

HRESULT CShellEmbedding::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    IDTMSG2(TEXT("GetDataHere"), pformatetc->cfFormat);
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::QueryGetData(FORMATETC *pformatetc)
{
    IDTMSG2(TEXT("QueryGetData"), pformatetc->cfFormat);
    HRESULT hres = S_FALSE;
    if (pformatetc->cfFormat == CF_ENHMETAFILE
        && (pformatetc->tymed & TYMED_ENHMF))
    {
        hres = S_OK;
    }
    else if (pformatetc->cfFormat == CF_METAFILEPICT
        && (pformatetc->tymed & TYMED_MFPICT))
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT CShellEmbedding::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
    IDTMSG2(TEXT("GetCanonicalFormatEtc"), pformatetcIn->cfFormat);
    *pformatetcOut = *pformatetcIn;
    return DATA_S_SAMEFORMATETC;
}

HRESULT CShellEmbedding::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    IDTMSG(TEXT("SetData"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    IDTMSG(TEXT("EnumFormatEtc"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    IDTMSG(TEXT("DAdvise"));
    HRESULT hr = E_INVALIDARG;

    if (!pdwConnection)
        return hr;

    *pdwConnection = NULL;              // set out params to NULL

    if (!_pdah)
        hr = ::CreateDataAdviseHolder(&_pdah);
    else
        hr = NOERROR;

    if( SUCCEEDED(hr) )
        hr = _pdah->Advise(this, pformatetc, advf, pAdvSink, pdwConnection);

    return(hr);
}

HRESULT CShellEmbedding::DUnadvise(DWORD dwConnection)
{
    IDTMSG(TEXT("DUnadvise"));
    HRESULT     hr;

    if (!_pdah)
        return(OLE_E_NOCONNECTION);

    hr = _pdah->Unadvise(dwConnection);

    return(hr);
}

HRESULT CShellEmbedding::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    IDTMSG(TEXT("EnumDAdvise"));
    HRESULT     hr;

    if (!ppenumAdvise)
        return(E_INVALIDARG);

    if (!_pdah)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = _pdah->EnumAdvise(ppenumAdvise);
    }

    return(hr);
}

// *** IOleWindow ***
HRESULT CShellEmbedding::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT CShellEmbedding::ContextSensitiveHelp(BOOL fEnterMode)
{
    return S_OK;
}


// *** IOleInPlaceObject ***
HRESULT CShellEmbedding::InPlaceDeactivate(void)
{
    IIPMSG(TEXT("InPlaceDeactivate"));
    return _DoActivateChange(NULL, OC_DEACTIVE, FALSE);
}

HRESULT CShellEmbedding::UIDeactivate(void)
{
    IIPMSG(TEXT("UIDeactivate"));
    return _DoActivateChange(NULL, OC_INPLACEACTIVE, FALSE);
}

HRESULT CShellEmbedding::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    RECT  rcVisible;

    _rcPos = *lprcPosRect;

    if (lprcClipRect)
    {
        _rcClip = *lprcClipRect;
    }
    else
    {
        _rcClip = _rcPos;
    }

    IntersectRect(&rcVisible, &_rcPos, &_rcClip);    
    if (EqualRect(&rcVisible, &_rcPos))
    {
        if (_fUsingWindowRgn)
        {
            SetWindowRgn(_hwnd, NULL, TRUE);
            _fUsingWindowRgn = FALSE;
        }
    }
    else 
    {
        _fUsingWindowRgn = TRUE;
        OffsetRect(&rcVisible, -_rcPos.left, -_rcPos.top);
        SetWindowRgn(_hwnd,
                CreateRectRgnIndirect(&rcVisible),
                TRUE);
    }

    // We should consider this equivalent to a SetExtent as well...
    // But only for valid sizes (html viewer gives us invalid
    // sizes during it's reformat routine). Note: we still need
    // the SetWindowPos because we may move off the window.
    int cx = _rcPos.right - _rcPos.left;
    int cy = _rcPos.bottom - _rcPos.top;
    TraceMsg(TF_SHDCONTROL, "she SetObjectRects to x=%d y=%d cx=%d cy=%d (from cx=%d cy=%d)", _rcPos.left, _rcPos.top, cx, cy, _size.cx, _size.cy);
    if (cx >= 0 && cy >= 0)
    {
        _size.cx = cx;
        _size.cy = cy;
    }

    if (_hwnd)
    {
        SetWindowPos(_hwnd, NULL,
                     _rcPos.left, _rcPos.top,
                     _size.cx,
                     _size.cy,
                     SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return S_OK;
}

HRESULT CShellEmbedding::ReactivateAndUndo(void)
{
    IIPMSG(TEXT("ReactivateAndUndo"));
    return INPLACE_E_NOTUNDOABLE;
}

// *** IOleInPlaceActiveObject ***
HRESULT CShellEmbedding::TranslateAccelerator(LPMSG lpmsg)
{
    extern BOOL IsVK_TABCycler(MSG * pMsg);
    HRESULT hr = S_FALSE;

    // IIAMSG(TEXT("TranslateAccelerator"));
    // We have no accelerators (other than TAB, which we must pass up
    // to IOCS::TA to move on to the next control if any)

    if (IsVK_TABCycler(lpmsg)) {
        // NOTE: grfMods?
        hr = IUnknown_TranslateAcceleratorOCS(_pcli, lpmsg, /*grfMods*/ 0);
    }

    return hr;
}

HRESULT CShellEmbedding::OnFrameWindowActivate(BOOL fActivate)
{
    IIAMSG(TEXT("OnFrameWindowActivate"));

    if (fActivate)
    {
        // our frame has been activated and we are the active object
        // make sure we have focus
        SetFocus(_hwnd);
    }

    return S_OK;
}

HRESULT CShellEmbedding::OnDocWindowActivate(BOOL fActivate)
{
    IIAMSG(TEXT("OnDocWindowActivate"));
    // We don't care
    return S_OK;
}

HRESULT CShellEmbedding::ResizeBorder(LPCRECT prcBorder,
                    IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow)
{
    IIAMSG(TEXT("ResizeBorder"));
    // We have no toolbars.
    return S_OK;
}

HRESULT CShellEmbedding::EnableModeless(BOOL fEnable)
{
    IIAMSG(TEXT("EnableModeless"));
    // We have no dialogs.
    return S_OK;
}

void CShellEmbedding::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};
    wc.style         = CS_DBLCLKS;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(CShellEmbedding*) * 2;
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szShellEmbedding;

    SHRegisterClass(&wc);
}


LRESULT CShellEmbedding::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_NCCREATE:
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & RTL_MIRRORED_WINDOW)
        {
             SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ RTL_MIRRORED_WINDOW);
        }
        goto DoDefault;

    case WM_SETFOCUS:
        if (_hwndChild)
            SetFocus(_hwndChild);
        // If this SETFOCUS came from TABbing onto the control, VB5 expects us to call its
        // IOleControlSite::OnFocus.  Then it will UIActivate us.
        //
        IUnknown_OnFocusOCS(_pcli, TRUE);
        break;

    case WM_KILLFOCUS:
        // If this KILLFOCUS came from TABbing off the control, VB5 expects us to call its
        // IOleControlSite::OnFocus.  Then it will UIDeactivate us.
        //
        IUnknown_OnFocusOCS(_pcli, FALSE);
        break;

    case WM_WINDOWPOSCHANGED:
        if (_hwndChild)
        {
            LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;

            if (!(lpwp->flags & SWP_NOSIZE))
            {
                SetWindowPos(_hwndChild, NULL,
                    0, 0, lpwp->cx, lpwp->cy,
                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|
                    (lpwp->flags&(SWP_NOREDRAW|SWP_NOCOPYBITS)));
            }
        }
        goto DoDefault;

#ifdef DEBUG
    // FEATURE: we'll never get this with ShellExplorer OC, but if we did,
    // we'd need to call _DoActivateChange(OC_UIACTIVE, FALSE);
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        TraceMsg(TF_SHDCONTROL, "she ::v_WndProc(WM_xBUTTONDOWN) - we need to UIActivate");
        goto DoDefault;
#endif

    default:
DoDefault:
        return DefWindowProc(_hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

void CShellEmbedding::_ViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _asp;

    if (dwAspect && _padv)
    {
        IAdviseSink *padv = _padv;
        IUnknown *punkRelease;

        if (_advf & ADVF_ONLYONCE)
        {
            _padv = NULL;
            punkRelease = padv;
        }
        else
            punkRelease = NULL;

        padv->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CShellEmbedding::_SendAdvise(UINT uCode)
{
    DWORD       dwAspect=DVASPECT_CONTENT | DVASPECT_THUMBNAIL;

    switch (uCode)
    {
    case OBJECTCODE_SAVED:
        if (NULL!=_poah)
            _poah->SendOnSave();
        break;

    case OBJECTCODE_CLOSED:
        if (NULL!=_poah)
            _poah->SendOnClose();
        break;

    case OBJECTCODE_RENAMED:
        //Call IOleAdviseHolder::SendOnRename (later)
        break;

    case OBJECTCODE_SAVEOBJECT:
        if (_fDirty && NULL!=_pcli)
            _pcli->SaveObject();

        _fDirty=FALSE;
        break;

    case OBJECTCODE_DATACHANGED:
        // _fDirty=TRUE;

        //No flags are necessary here.
        if (NULL!=_pdah)
            _pdah->SendOnDataChange(this, 0, 0);
        //
        // fall through
        //
    case OBJECTCODE_VIEWCHANGED:
        _ViewChange(dwAspect, -1);
        break;

    case OBJECTCODE_SHOWOBJECT:
        if (NULL!=_pcli)
            _pcli->ShowObject();
        break;
    }
}

HRESULT CSVVerb::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IEnumOLEVERB) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IEnumOLEVERB*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    _cRef++;
    return S_OK;
}

ULONG CSVVerb::AddRef()
{
    return ++_cRef;
}

ULONG CSVVerb::Release()
{
    if (--_cRef > 0) {
        return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CSVVerb::Next(
    /* [in] */ ULONG celt,
    /* [out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hres = S_FALSE;
    ULONG celtFetched = 0;


    // We need to enumerate the predefined verbs we support,
    // or some containers will never call them. This list
    // of verbs comes from our ::DoVerb function
    //
    static const OLEVERB rgVerbs[5] =
    {
        {OLEIVERB_PRIMARY, NULL, 0, 0},
        {OLEIVERB_INPLACEACTIVATE, NULL, 0, 0},
        {OLEIVERB_UIACTIVATE, NULL, 0, 0},
        {OLEIVERB_SHOW, NULL, 0, 0},
        {OLEIVERB_HIDE, NULL, 0, 0}
    };
    if (_iCur < ARRAYSIZE(rgVerbs))
    {
        IEVMSG(TEXT("Next"), celt, _iCur, TEXT("OLEIVERB_..."));

        *rgelt = rgVerbs[_iCur++];
        hres = S_OK;
    }
    else if (_pverbs)
    {
        int iCur = _iCur - ARRAYSIZE(rgVerbs);

        IEVMSG(TEXT("Next"), celt, _iCur, _pverbs[iCur].lpszVerbName);

        //
        // FEATURE: Should we do while(celt--)?
        //
        if (_pverbs[iCur].lpszVerbName)
        {
            *rgelt = _pverbs[_iCur++];
            WCHAR* pwszVerb = (WCHAR *)CoTaskMemAlloc(128 * sizeof(WCHAR));
            if (pwszVerb)
            {
                MLLoadStringW(PtrToUint(_pverbs[iCur].lpszVerbName), pwszVerb, 128);
                rgelt->lpszVerbName = pwszVerb;
                celtFetched++;
                hres = S_OK;
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    if (pceltFetched) {
        *pceltFetched = celtFetched;
    }
    return hres;
}

HRESULT CSVVerb::Skip(ULONG celt)
{
    return S_OK;
}

HRESULT CSVVerb::Reset( void)
{
    _iCur = 0;
    return S_OK;
}

HRESULT CSVVerb::Clone(IEnumOLEVERB **ppenum)
{
    *ppenum = new CSVVerb(_pverbs);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shdocfl.h ===
//
//  shdocfl.h 
//  
//  helper functions that are useful outside of shdocfl.cpp
//  but are definitely tied to the implementation of the namespace
//
//  WARNING - this should not be abused  - ZekeL - 24-NOV-98
//      by exposing the internal structure of the pidls
//


STDAPI_(LPITEMIDLIST) IEILAppendFragment(LPITEMIDLIST pidl, LPCWSTR pszFragment);
STDAPI_(BOOL) IEILGetFragment(LPCITEMIDLIST pidl, LPWSTR pszFragment, DWORD cchFragment);
STDAPI_(UINT) IEILGetCP(LPCITEMIDLIST pidl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shell32.cpp ===
// Wrappers for APIs that have moved elsewhere

#include "priv.h"
#include "shlwapip.h"

//------------------------------------------------------------------------
//
// APIs from SHDOCVW that are now forwarded to SHLWAPI
//
//
//  Note that we cannot use DLL forwarders because there is a bug
//  in Win95 where the loader screws up forwarders for bound DLLs.

STDAPI_(DWORD) StopWatchModeFORWARD(VOID)
{
    return StopWatchMode();
}

STDAPI_(DWORD) StopWatchFlushFORWARD(VOID)
{
    return StopWatchFlush();
}

STDAPI SHRunIndirectRegClientCommandForward(HWND hwnd, LPCWSTR pszClient)
{
    return SHRunIndirectRegClientCommand(hwnd, pszClient);
}

#ifdef ux10
/*IEUNIX : In the hp-ux linker, there is no option of specifying an internal name and an external name.  */
#define StopWatch StopWatch
#define StopWatchFORWARD StopWatch
#endif 

STDAPI_(DWORD) StopWatchFORWARD(DWORD dwId, LPCSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount)
{
    return StopWatchA(dwId, (LPCSTR)pszDesc, dwType, dwFlags, dwCount);
}

//------------------------------------------------------------------------
//
// APIs from SHDOCVW that are now forwarded to SHELL32/SHDOC41

//
//  This variable name is a misnomer.  It's really
//
//  g_hinstShell32OrShdoc401DependingOnWhatWeDetected;
//
//  I can live with the misnomer; saves typing.  Think of it as
//  "the INSTANCE of SHDOC401 or whatever DLL is masquerading as
//  SHDOC401".
//
//

extern "C" { HINSTANCE g_hinstSHDOC401 = NULL; }

//
//  GetShdoc401
//
//  Detect whether we should be using Shell32 or Shdoc401 to handle
//  active desktop stuff.  The rule is
//
//  If PF_FORCESHDOC401 is set, then use shdoc401. (DEBUG only)
//  If shell32 version >= 5, then use shell32.
//  Else use shdoc401.
//
//  Warning:  THIS FUNCTION CANNOT BE CALLED DURING PROCESS_ATTACH
//  because it calls LoadLibrary.

HINSTANCE GetShdoc401()
{
    DWORD dwMajorVersion;
    HINSTANCE hinst;
    HINSTANCE hinstSh32 = GetModuleHandle(TEXT("SHELL32.DLL"));
    ASSERT(hinstSh32);

#ifdef DEBUG
    if (g_dwPrototype & PF_FORCESHDOC401) {
        hinstSh32 = NULL; // force SHDOC401 to be loaded
    }
#endif

    if (hinstSh32) {
        DLLVERSIONINFO dllinfo;
        DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstSh32, "DllGetVersion");

        dllinfo.cbSize = sizeof(DLLVERSIONINFO);
        if (pfnGetVersion && SUCCEEDED(pfnGetVersion(&dllinfo))) {
            dwMajorVersion = dllinfo.dwMajorVersion;
        } else {
            dwMajorVersion = 0;
        }
    } else {
        dwMajorVersion = 0;
    }

    if (dwMajorVersion >= 5) {
        hinst = hinstSh32;
    } else {
        hinst = LoadLibrary(TEXT("SHDOC401.DLL"));

        if (NULL == hinst)
        {
            // If this fails we're screwed
            TraceMsg(TF_ERROR, "Failed to load SHDOC401.DLL.");
        }
    }
    g_hinstSHDOC401 = hinst;

    return hinst;
}

//
//  GetShdoc401ProcAddress
//
//  Get a procedure from SHDOC401 or whoever is masquerading as same.
//
//  Warning:  THIS FUNCTION CANNOT BE CALLED DURING PROCESS_ATTACH
//  because it calls LoadLibrary.

FARPROC GetShdoc401ProcAddress(FARPROC *ppfn, UINT ord)
{
    if (*ppfn) {
        return *ppfn;
    } else {
        HINSTANCE hinst = g_hinstSHDOC401;

        //
        //  No race condition here.  If two threads both call GetShdoc401,
        //  all that happens is that we load SHDOC401 into memory and then
        //  bump his refcount up to 2 instead of leaving it at 1.  Big deal.
        //
        if (hinst == NULL) {
            hinst = GetShdoc401();
        }

        if (hinst) {
            return *ppfn = GetProcAddress(hinst, (LPCSTR)LongToHandle(ord));
        } else {
            return NULL;
        }
    }
}

//
//  Delay-load-like macros.
//

#define DELAY_LOAD_SHDOC401(_type, _err, _fn, _ord, _arg, _nargs)   \
    STDAPI_(_type) _fn _arg                                         \
    {                                                               \
        static FARPROC s_pfn##_fn = NULL;                           \
        FARPROC pfn = GetShdoc401ProcAddress(&s_pfn##_fn, _ord);    \
        if (pfn) {                                                  \
            typedef _type (__stdcall *PFN##_fn) _arg;               \
            return ((PFN##_fn)pfn) _nargs;                          \
        } else {                                                    \
            return _err;                                            \
        }                                                           \
    }                                                               \

#define DELAY_LOAD_SHDOC401_VOID(_fn, _ord, _arg, _nargs)           \
    STDAPI_(void) _fn _arg                                          \
    {                                                               \
        static FARPROC s_pfn##_fn = NULL;                           \
        FARPROC pfn = GetShdoc401ProcAddress(&s_pfn##_fn, _ord);    \
        if (pfn) {                                                  \
            typedef void (__stdcall *PFN##_fn) _arg;                \
            ((PFN##_fn)pfn) _nargs;                                 \
        }                                                           \
    }                                                               \

// IE4 Shell Integrated Explorer called ShellDDEInit in shdocvw to
// set up DDE. Forward this call to SHELL32/SHDOC401 appropriately.

DELAY_LOAD_SHDOC401_VOID(ShellDDEInit, 188,
                         (BOOL fInit),
                         (fInit));

DELAY_LOAD_SHDOC401(HANDLE, NULL,
                    SHCreateDesktop, 200,
                    (IDeskTray* pdtray),
                    (pdtray));

DELAY_LOAD_SHDOC401(BOOL, FALSE,
                    SHDesktopMessageLoop, 201,
                    (HANDLE hDesktop),
                    (hDesktop));

// This may not have been used in IE4
DELAY_LOAD_SHDOC401(BOOL, FALSE,
                    DDEHandleViewFolderNotify, 202,
                    (IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER lpnm),
                    (psb, hwnd, lpnm));

DELAY_LOAD_SHDOC401(LPNMVIEWFOLDER, NULL,
                    DDECreatePostNotify, 82,
                   (LPNMVIEWFOLDER pnm), 
                   (pnm));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shdocvw.cpp ===
#include "priv.h"
#include "hlframe.h"
#include "dochost.h"
#include "bindcb.h"
#include "iface.h"
#include "resource.h"
#include "idhidden.h"
#include "shdocfl.h"

const ITEMIDLIST s_idNull = { {0} };
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);
LPWSTR URLFindExtensionW(LPCWSTR pszURL, int * piLen);

#define DM_CACHETRACE   0
#define DM_ZONECROSSING 0

#define NAVMSG3(psz, x, y)          TraceMsg(0, "NAV::%s %x %x", psz, x, y)
#define PAINTMSG(psz,x)             TraceMsg(0, "TraceMsgPAINT::%s %x", psz, x)
#define JMPMSG(psz, psz2)           TraceMsg(0, "TraceMsgCDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)             TraceMsg(0, "TraceMsgCDOV::%s %x", psz, x)
#define DOFMSG(psz)                 TraceMsg(0, "TraceMsgDOF::%s", psz)
#define DOFMSG2(psz, x)             TraceMsg(0, "TraceMsgDOF::%s %x", psz, x)
#define URLMSG(psz)                 TraceMsg(0, "TraceMsgDOF::%s", psz)
#define URLMSG2(psz, x)             TraceMsg(0, "TraceMsgDOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)          TraceMsg(0, "TraceMsgDOF::%s %x %x", psz, x, y)
#define BSCMSG(psz, i, j)           TraceMsg(0, "TraceMsgBSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)       TraceMsg(0, "TraceMsgBSC::%s %x %x %x", psz, i, j, k)
#define BSCMSG4(psz, i, j, k, l)    TraceMsg(0, "TraceMsgBSC::%s %x %x %x %x", psz, i, j, k, l)
#define BSCMSGS(psz, sz)            TraceMsg(0, "TraceMsgBSC::%s %s", psz, sz)
#define OIPSMSG(psz)                TraceMsg(0, "TraceMsgOIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)        TraceMsg(0, "TraceMsgOIPS::%s %s,%x", psz, sz,p)
#define VIEWMSG(psz)                TraceMsg(0, "CDOV::%s", psz)
#define VIEWMSG2(psz,xx)            TraceMsg(0, "CDOV::%s %x", psz,xx)
#define CACHEMSG(psz, d)            TraceMsg(0, "CDocObjectCtx::%s %d", psz, d)
#define OPENMSG(psz)                TraceMsg(0, "OPENING %s", psz)
#define OPENMSG2(psz, x)            TraceMsg(0, "OPENING %s %x", psz, x)
#define HFRMMSG(psz)                TraceMsg(0, "HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)         TraceMsg(0, "HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)           TraceMsg(0, "MNK::%s (%s)", psz, psz2)
#define CHAINMSG(psz, x)            TraceMsg(0, "CHAIN::%s %x", psz, x)
#define SHVMSG(psz, x, y)           TraceMsg(0, "SHV::%s %x %x", psz, x, y)
#define HOMEMSG(psz, psz2, x)       TraceMsg(0, "HOME::%s %s %x", psz, psz2, x)
#define SAVEMSG(psz, x)             TraceMsg(0, "SAVE::%s %x", psz, x)
#define PERFMSG(psz, x)             TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)

// this saves the view information for this shell view class
typedef struct {
    UINT cbSize;

    BOOL fCoolbar:1;
    BOOL fToolbar:1;
    BOOL fStatusbar:1;

} IEVIEWINFO;



class CDocObjectView :
    /* Group 1 */    public IShellView2, public IDropTarget
                   , public IViewObject, public IAdviseSink
                   , public IOleCommandTarget
                   , public IDocViewSite
                   , public IPrivateOleObject
                   , public IPersistFolder
                   , public IServiceProvider
{
protected:
    CDocObjectHost* _pdoh;
    IDocHostObject* _pdho;

    UINT _cRef;
    IShellFolder *_psf;
    IShellBrowser* _psb;
    IOleCommandTarget* _pctShellBrowser;
    FOLDERSETTINGS _fs;
    LPITEMIDLIST _pidl;
    LPTSTR _pszLocation;
    UINT _uiCP;

    IShellView * _psvPrev;

    // Advisory connection
    IAdviseSink *_padvise;
    DWORD _advise_aspect;
    DWORD _advise_advf;

    BOOL _fInHistory : 1;
    BOOL _fSaveViewState : 1;
    BOOL _fIsGet : 1;
    BOOL _fCanCache : 1;
    BOOL _fCanCacheFetched : 1;
    BOOL _fPrevViewIsDocView : 1;
    BOOL _fSelfDragging : 1;       // DocObject is the drag source

    SYSTEMTIME _stLastRefresh;
    HWND    _hwndParent;

    UINT _uState;
    // DragContext
    DWORD _dwDragEffect;

    ~CDocObjectView();

    void    _RestoreViewSettings();
    void    _SaveViewState();
    void    _GetViewSettings(IEVIEWINFO* pievi);
    int     _ShowControl(UINT idControl, int idCmd);
    void _CreateDocObjHost(IShellView * psvPrev);
    void _CompleteDocHostPassing(IShellView *psvPrev, HRESULT hres);
    BOOL _CanUseCache();
    void _SetLastRefreshTime() { GetSystemTime(&_stLastRefresh); };


    void _ConnectHostSink();
    void _DisconnectHostSink();

public:
    CDocObjectView(LPCITEMIDLIST pidl, IShellFolder *psf);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IShellView methods ***
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP EnableModelessSV(BOOL fEnable);
    STDMETHODIMP UIActivate(UINT uState);
    STDMETHODIMP Refresh();

    STDMETHODIMP CreateViewWindow(IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd);
    STDMETHODIMP DestroyViewWindow();
    STDMETHODIMP GetCurrentInfo(LPFOLDERSETTINGS lpfs);
    STDMETHODIMP AddPropertySheetPages(DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam);
    STDMETHODIMP SaveViewState();
    STDMETHODIMP SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags);
    STDMETHODIMP GetItemObject(UINT uItem, REFIID riid, void **ppv);

    STDMETHODIMP GetView(SHELLVIEWID* pvid, ULONG uView) ;
    STDMETHODIMP CreateViewWindow2(LPSV2CVW2_PARAMS lpParams) ;
    STDMETHODIMP HandleRename(LPCITEMIDLIST pidl) ;
    STDMETHODIMP SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt) {
        return E_NOTIMPL;
    }


    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);


    // IDropTarget
    STDMETHODIMP DragEnter(
    IDataObject *pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    STDMETHODIMP DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    STDMETHODIMP DragLeave(void);

    STDMETHODIMP Drop(
    IDataObject *pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    // IDocViewSite
    STDMETHODIMP OnSetTitle(VARIANTARG *pvTitle);

    // IPrivateOleObject
    STDMETHODIMP SetExtent( DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHODIMP GetExtent( DWORD dwDrawAspect, SIZEL *psizel);

    // IPersist methods
    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFolder methods
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IServiceProvider methods
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);
};

//--------------------------------------------------------------------------
// Detecting a memory leak
//--------------------------------------------------------------------------

CDocObjectView::~CDocObjectView()
{
    // just in case
    DestroyViewWindow();

    if (_pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    ATOMICRELEASE(_psf);

    if (_pszLocation)
    {
        LocalFree(_pszLocation);
        _pszLocation = NULL;
    }

    ATOMICRELEASE(_padvise);

    ATOMICRELEASE(_psvPrev);

    TraceMsg(TF_SHDLIFE, "dtor CDocObjectView(%x) being destructed", this);
}

CDocObjectView::CDocObjectView(LPCITEMIDLIST pidl, IShellFolder* psf) :
    _psf(psf),
    _cRef(1)
{
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectView(%x) being constructed", this);

    _dwDragEffect = DROPEFFECT_NONE;
    if (pidl)
    {
        _pidl = ILClone(pidl);

        if (_pidl)
        {
#ifndef UNIX
            WCHAR wszPath[MAX_URL_STRING];
#else
            WCHAR wszPath[MAX_URL_STRING] = TEXT("");
#endif
            if(IEILGetFragment(_pidl, wszPath, SIZECHARS(wszPath)))
            {
                _pszLocation = StrDup(wszPath);
            }

            _uiCP = IEILGetCP(_pidl);
        }
    }

    ASSERT(psf);
    if (_psf) {
        _psf->AddRef();
    }
}

HRESULT CDocObjectView_Create(IShellView** ppvOut, IShellFolder * psf, LPCITEMIDLIST pidl)
{
    *ppvOut = new CDocObjectView(pidl, psf);
    return (*ppvOut) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CDocObjectView::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;
    if (_pdoh)
        return _pdoh->GetWindow(lphwnd);
    return S_OK;
}

HRESULT CDocObjectView::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   // As specified in Kraig's document (optional)
}



// IShellView::TranslateAccelerator
//  From Browser -> DocView -> DocObject
HRESULT CDocObjectView::TranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hres = S_FALSE;
    if (_pdoh)
        hres = _pdoh->_xao.TranslateAccelerator(lpmsg);

    if (hres == S_FALSE && lpmsg->message == WM_KEYDOWN) {
        HWND hwndFocus = GetFocus();
        HWND hwndView = NULL;

        if(_pdoh) //WARNING ZEKEL i found this NULL
            _pdoh->GetWindow(&hwndView);

        if (hwndView && IsChildOrSelf(hwndView, hwndFocus) == S_OK) {

            switch (lpmsg->wParam) {

            case VK_BACK:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                hres = NOERROR;
                break;

            }
        }
    }

    return hres;
}

// IShellView::EnableModelessSV
//  From Browser -> DocView -> DocObject
HRESULT CDocObjectView::EnableModelessSV(BOOL fEnable)
{
    HRESULT hres = S_OK;
    // We have no modeless window to be enabled/disabled
    TraceMsg(0, "sdv TR - ::EnableModelessSV(%d) called", fEnable);
    if (_pdoh) {
        hres = _pdoh->_xao.EnableModeless(fEnable);
        TraceMsg(0, "sdv TR - _piact->EnableModeless returned %x", hres);
    }
    return hres;
}


HRESULT CDocObjectView::UIActivate(UINT uState)
{
    HRESULT hres = E_FAIL;

    if (_pdoh)
    {
        hres = _pdoh->UIActivate(uState, _fPrevViewIsDocView);
    }

    _uState = uState;
    return hres;
}

HRESULT CDocObjectView::Refresh()
{
    if (_pdoh)
    {
        VARIANT v = {0};
        v.vt = VT_I4;
        v.lVal = OLECMDIDF_REFRESH_NO_CACHE;
        // send this to exec so that it will update last refresh time.
        // all refresh to dochost should go through our own exec
        return Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, &v, NULL);
    }

    return S_OK;
}


// Return:
//   S_OK: It is a folder shortcut and ppidlTarget is filled out if provided.
//   S_FALSE: It is not a folder shortcut and ppidlTarget is filled with NULL if provided.
//   FAILED: An error occured trying to detect.
//
// Don't use this function if there is a better way.  Look into using
// IBrowserFrameOptions. -BryanSt
HRESULT IsFolderShortcutPidl(IN LPCITEMIDLIST pidl)
{
    IShellFolder * psf = NULL;
    HRESULT hr = IEBindToObject(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        IShellLinkA * psl;

        hr = psf->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            psl->Release();
        }
        else
            hr = S_FALSE;   // It's not a folder shortcut.

        psf->Release();
    }

    return hr;
}


// WARNING: This function explicitely creates URLMON monikers
//   because that's what the caller needs.  Some NSEs will
//   support IShellFolder::BindToObject(IMoniker)
//   but this function doesn't use that logic intentionally.
//
STDAPI _URLMONMonikerFromPidl(LPCITEMIDLIST pidl, IMoniker** ppmk, BOOL* pfFileProtocol)
{
    TCHAR szPath[MAX_URL_STRING];
    HRESULT hres = E_UNEXPECTED;

    *ppmk = NULL;
    *pfFileProtocol = FALSE;
    MNKMSG(TEXT("_URLMONMonikerFromPidl"), TEXT("called"));

    AssertMsg((S_OK != IsFolderShortcutPidl(pidl)), TEXT("We shouldn't get Folder Shortcuts here because we don't deref them to get the target. And we should never need to."));

    // Is this a child of the "Internet Explorer" name space?
    if (!IsURLChild(pidl, TRUE))
    {
        // No, so we want to get the display name to use to
        // create the moniker.  We will try to turn it into
        // an URL if it isn't already an URL.

        // NOTE: We don't try IEBindToObject(pidl, IID_IMoniker)
        //       because the caller requires that this
        //       IMoniker come from URLMON.
        HRESULT hrTemp = SHGetPathFromIDList(pidl, szPath);

        AssertMsg(SUCCEEDED(hrTemp), TEXT("_URLMONMonikerFromPidl() failed SHGetPathFromIDList() which is really bad because we probably won't be able to create a moniker from it.  We will try to create a URLMON moniker below."));
        if (SUCCEEDED(hrTemp))
        {
            //  this should never be a fully qualified URL
            DWORD cchPath = ARRAYSIZE(szPath);

            ASSERT(URL_SCHEME_INVALID == GetUrlScheme(szPath));
            if(SUCCEEDED(hres = UrlCreateFromPath(szPath, szPath, &cchPath, 0)))
            {
                MNKMSG(TEXT("_URLMONMonikerFromPidl Creating File Moniker"), szPath);
            }

            *pfFileProtocol = TRUE;
        }

    }
    else
    {
        // Yes so we are guaranteed this is from the "Internet Explorer"
        // name space so remove Fragment hidden itemID.
        // We do this because we navigate to the fragment later,
        // after the page is downloaded.  This is also needed
        // for delegates of the IE name space. (FTP is one example of
        // a delegate).
        ASSERT(pidl);
        ASSERT(!ILIsEmpty(_ILNext(pidl)));  // Make sure it's not the start page URL.

        LPITEMIDLIST pidlClone = ILClone(pidl);
        if (pidlClone)
        {
            //  we dont want to pass the fragment into URLMON
            //  so we pull it off before calling into GDN.
            //  Note that pidlClone needs to be the pidlTarget
            //  of folder shortcuts or the dislpay name will
            //  be the file system path of the folder shortcut
            //  if at the top level.
            ILRemoveHiddenID(pidlClone, IDLHID_URLFRAGMENT);
            IEGetDisplayName(pidlClone, szPath, SHGDN_FORPARSING);
            hres = S_OK;
            ILFree(pidlClone);
        }
    }

    if (SUCCEEDED(hres))
    {
        if (szPath[0])
        {
            hres = MonikerFromString(szPath, ppmk);
        }
        else
        {
            ASSERT(FALSE);
            hres = E_UNEXPECTED;
        }
    }

    return hres;
}

HRESULT CDocObjectView::HandleRename(LPCITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::CreateViewWindow(IShellView  *psvPrev,
                LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                RECT * prcView, HWND  *phWnd)
{
    SV2CVW2_PARAMS cParams;

    cParams.cbSize   = SIZEOF(SV2CVW2_PARAMS);
    cParams.psvPrev  = psvPrev;
    cParams.pfs      = lpfs;
    cParams.psbOwner = psb;
    cParams.prcView  = prcView;
    cParams.pvid     = NULL;

    HRESULT hres = CreateViewWindow2(&cParams);

    *phWnd = cParams.hwndView;
    IOleWindow *pOleWindow;

    // need top level frame available for D&D
    HRESULT hr = IUnknown_QueryService(_psb, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
    if(SUCCEEDED(hr))
    {
        ASSERT(pOleWindow);
        pOleWindow->GetWindow(&_hwndParent);
        pOleWindow->Release();
    }
    return(hres);
}

void CDocObjectView::_CompleteDocHostPassing(IShellView * psvPrev, HRESULT hresBinding)
{
    BOOL fPassedSV = FALSE;

    // If there was a previous shell view, see if it was our class.
    //
    if (psvPrev)
    {
        CDocObjectView * pdovPrev;

        HRESULT hres = psvPrev->QueryInterface(CLSID_CDocObjectView, (void **)&pdovPrev);
        if (SUCCEEDED(hres))
        {
            // Previous shell view is also an instance of CDocObjectView,
            // Remember that for optimization later. 
            //
            _fPrevViewIsDocView = TRUE;

            // it was, and we have the same doc host as they do.
            // we've succeeded in taking over, so null them out if we
            // succeeeded in our bind.  null ourselves out if we failed
            //
            if (pdovPrev->_pdoh == _pdoh) 
            {
                if (SUCCEEDED(hresBinding))
                {
                    pdovPrev->_DisconnectHostSink();    // just in case
                    _ConnectHostSink();                 // just in case

                    ATOMICRELEASET(pdovPrev->_pdoh, CDocObjectHost);
                }
                else
                {
                    _DisconnectHostSink();              // unhook
                    pdovPrev->_ConnectHostSink();       // kick other guy

                    ATOMICRELEASET(_pdoh, CDocObjectHost);
                }

                fPassedSV = TRUE;
            }

            pdovPrev->Release();
        }
    }

    if (!fPassedSV)
    {
        if (FAILED(hresBinding))
        {
            DestroyViewWindow();
        }
    }
}

BOOL CDocObjectView::_CanUseCache()
{
    // NOTE:  this function is more like _DontHaveToHitTheNet()
    //  the name is legacy from the objectcache.
    if (!_fCanCacheFetched)
    {
        _fCanCache = TRUE;
        _fCanCacheFetched = TRUE;
        _fIsGet = TRUE;

        IServiceProvider *psp;
        _psb->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp));
        if (psp)
        {
            IBindStatusCallback *pbsc;
            if (SUCCEEDED(GetTopLevelBindStatusCallback(psp, &pbsc)))
            {
                BINDINFO binfo;
                ZeroMemory(&binfo, sizeof(BINDINFO));
                binfo.cbSize = sizeof(BINDINFO);

                DWORD grfBINDF = BINDF_ASYNCHRONOUS;

                HRESULT hr = pbsc->GetBindInfo(&grfBINDF, &binfo);
                if (SUCCEEDED(hr))
                {
                    if (grfBINDF & (BINDF_GETNEWESTVERSION | BINDF_RESYNCHRONIZE))
                    {
                        _fCanCache = FALSE;
                    }

                    _fIsGet = (binfo.dwBindVerb == BINDVERB_GET);
                    ReleaseBindInfo(&binfo);
                }

                pbsc->Release();
            }
            // I believe that failing to get the Bindstatuscallback should
            //  not happen since we no longer use the object cache.
            //  and if it does, then we no that we didnt have to repost
            //  or something similar
            psp->Release();
        }
    }

    return _fCanCache;
}


void CDocObjectView::_ConnectHostSink()
{
    if (_pdoh)
    {
        IAdviseSink *pSink;

        if (FAILED(_pdoh->GetAdvise(NULL, NULL, &pSink)))
            pSink = NULL;

        if (pSink != (IAdviseSink *)this)
            _pdoh->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);

        if (pSink)
            pSink->Release();
    }
}

void CDocObjectView::_DisconnectHostSink()
{
    IAdviseSink *pSink;

    // paranoia: only blow away the advise sink if it is still us
    if (_pdoh && SUCCEEDED(_pdoh->GetAdvise(NULL, NULL, &pSink)) && pSink)
    {
        if (pSink == (IAdviseSink *)this)
            _pdoh->SetAdvise(0, 0, NULL);

        pSink->Release();
    }

    OnViewChange(DVASPECT_CONTENT, -1);
}

//
//  This function either (1) Create a new CDocObjectHost or (2) reuse it from
// the previous view. If also returns the DisplayName of previous moniker.
//
void CDocObjectView::_CreateDocObjHost(IShellView * psvPrev)
{
    BOOL fWindowOpen = FALSE;

    // if there was a previous shell view, see if it was our class.
    if (psvPrev)
    {
        CDocObjectView * pdovPrev = NULL;

        HRESULT hres = psvPrev->QueryInterface(CLSID_CDocObjectView, (void **)&pdovPrev);

        if (SUCCEEDED(hres))
        {
            CDocObjectHost * pPrevDOH = pdovPrev->_pdoh;

            ASSERT(_psb);
            ASSERT(_psb == pdovPrev->_psb);

            // find out if we should be saving the view state when we close
            // if the one we're coming from says yes, then we'll take over that
            // job instead of them.
            //
            _fSaveViewState = pdovPrev->_fSaveViewState;
            pdovPrev->_fSaveViewState = FALSE;

            //
            //  if this is a local anchor navigation,
            //  we treat it substantially differently.
            //  we can reuse the DOH and the OLE Object that
            //  it holds.       - zekel - 31-JUL-97
            //
            //  WARNING:  we should not reuse these objects for any other
            //  reason than a local anchor (fragment) navigation.
            //  we used to be a lot more lenient about reusing the DOH
            //  but i think this was mostly because of the old object cache.
            //
            //  we check for equal pidls so that we know we are on
            //  the same URL.  we require that _pszLocation be set.
            //  this is for Netscape compat.  this means that anytime
            //  we get a navigate to ourself it will refresh completely
            //  if there was no fragment.  we also check to make sure that
            //  the binding does not require us to hit the net for
            //  this request.
            //
            //  08-11-1999 (scotrobe): We now reuse the DOH if the
            //  hosted document has indicated that it knows how to
            //  navigate on its own.
            //

            if (_pidl && pdovPrev->_pidl && pPrevDOH &&
                (pPrevDOH->_fDocCanNavigate
                 || (   _pszLocation && IEILIsEqual(_pidl, pdovPrev->_pidl, TRUE)
                     && _CanUseCache())))
            {
                IBrowserService *pbs;

                if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
                {
                    DWORD dwFlags = 0;

                    // If the document doesn't know how to navigate, then this may
                    // mean that this navigation  was delegated from the document. 
                    // In that case, if we have gotten this far, that means that 
                    // _pszLocation is set. If it is and this is a delegated navigation
                    // (i.e., the navigation wasn't due to a link in a non-html document)
                    // we must create a new document.
                    //
                    if (!pPrevDOH->_fDocCanNavigate)
                    {
                        pbs->GetFlags(&dwFlags);
                    }

                    if (!(dwFlags & BSF_DELEGATEDNAVIGATION))
                    {
                        //
                        //  if SetHistoryObject() fails, then that means there is already
                        //  an object there for us to use.  this means that we should
                        //  not treat this as a local anchor navigation.  and
                        //  we shouldnt reuse the DOH even though the pidl is identical
                        //
                        //  TRUE is passed to SetHistoryObject even if this is not a
                        //  local anchor. In the case that this is not a local anchor,
                        //  the document (Trident) handles the navigation. Therefore,
                        //  the document will take care of updating the travel log and
                        //  the fIsLocalAnchor flag is ignored.
                        //
                        if (SUCCEEDED(pbs->SetHistoryObject(pPrevDOH->_pole,
                                                !pPrevDOH->_fDocCanNavigate ? TRUE : FALSE)))
                        {
                            TraceMsg(TF_TRAVELLOG, "CDOV::CreateDocObjHost reusing current DOH on local anchor navigate");
                            //
                            //  we cant update in ActivateNow because at that point
                            //  we have already switched the dochost over to the new
                            //  (reused) view.  so we need to update the entry now
                            //
                            //  The fact that the hosted document can navigate on its own,
                            //  implies that it will take care of updating the travel log.
                            //
                            if (!pPrevDOH->_fDocCanNavigate)
                            {
                                ITravelLog * ptl;

                                pbs->GetTravelLog(&ptl);
                                if (ptl)
                                {
                                    ptl->UpdateEntry(pbs, TRUE);
                                    ptl->Release();
                                }
                            }

                            pdovPrev->_DisconnectHostSink();    // we will connect below

                            // same target!  pass the docobj host
                            _pdoh = pPrevDOH;
                            _pdoh->AddRef();

                            if (_pdoh->_fDocCanNavigate)
                            {
                                _pdoh->OnInitialUpdate();
                            }

                            if ((_pdoh->_dwAppHack & BROWSERFLAG_SUPPORTTOP) && !_pszLocation)
                            {
                                // if there's no location for us to go to, and
                                // we're traversing in the same document,
                                // assume top.
                                //
                                _pszLocation = StrDup(TEXT("#top"));
                                _uiCP = CP_ACP;
                            }
                        }

                        pbs->Release();
                    }
                }
            }

            // In the case where we are opening a non-html mime type 
            // in a new window, we need to pass the _fWindowOpen
            // flag from the previous docobject host to the new
            // docobject host. This is needed so that if we are opening
            // a file outside of IE in a new window, we'll know to close
            // the newly created IE afterwards.
            // The problem is that there isn't really a good place to 
            // clear this flag since it has to remain set from one 
            // instance of the docobject host to the next. This causes
            // us to get into the situation where we'll close the browser
            // window if we click on a link to a file that opens outside
            // of IE after opening a new window for an html file.
            // The bottom line is that we only need to pass this flag to
            // the new docobject host if we opening an non-html mime type
            // in a new window.
            //
            if (!_pdoh && pPrevDOH && pPrevDOH->_fDelegatedNavigation)
            {
                fWindowOpen = pPrevDOH->_fWindowOpen;
            }

            //
            // FEATURE: We should take care of _pibscNC as well
            // to 'chain' the IBindStatusCallback.
            //
            pdovPrev->Release();
        }
    }


    // if we didn't pass the docobj host, create a new one and
    // pass the doc context
    if (!_pdoh)
    {
        ASSERT(_psb);

        _pdoh = new CDocObjectHost(fWindowOpen);

        // Reset host navigation flag in the browser
        //
        IUnknown_Exec(_psb,
                      &CGID_DocHostCmdPriv,
                      DOCHOST_DOCCANNAVIGATE,
                      0, NULL, NULL);
    }

    if (_pdoh)
    {
        _ConnectHostSink();
    }
}

extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

HRESULT CDocObjectView::CreateViewWindow2(LPSV2CVW2_PARAMS lpParams)
{
    HRESULT hres            = S_OK;
    IShellView * psvPrev    = lpParams->psvPrev;
    LPCFOLDERSETTINGS lpfs  = lpParams->pfs;
    IShellBrowser * psb     = lpParams->psbOwner;
    RECT * prcView          = lpParams->prcView;
    HWND UNALIGNED * phWnd  = &lpParams->hwndView;

    if (_pdoh || !_pidl)
    {
        *phWnd = NULL;
        ASSERT(0);
        return E_UNEXPECTED;
    }

    _fs = *lpfs;

    ASSERT(_psb==NULL);

    _psb = psb;
    psb->AddRef();

    ASSERT(_pctShellBrowser==NULL);

    _psb->QueryInterface(IID_IOleCommandTarget, (void **)&_pctShellBrowser);

    //if somebody that is not a ShellBrowser  (like the FileOpenBrowser)
    // tries to use us, we want to block them.  we will fault later on
    // if we dont have the right stuff.
    if (!_pctShellBrowser)
        return E_UNEXPECTED;

    // prime the cache bit.  this needs to be done while we're *the* guy navigating.
    // otherwise, if we ask later when there's a different pending navigation,
    // we'll get his info
    _CanUseCache();
    _SetLastRefreshTime();

    //  Either create a new CDocObjectHost or reuse it from the previous view
    // and set it in _pdoh.
    _CreateDocObjHost(psvPrev);

    if (!_pdoh || !_pdoh->InitHostWindow(this, psb, prcView))
    {
        ATOMICRELEASE(_psb);
        _pctShellBrowser->Release();
        _pctShellBrowser = NULL;
        return E_OUTOFMEMORY;
    }

    _pdoh->GetWindow(phWnd);

    ASSERT(NULL == _pdho);

    _pdoh->QueryInterface(IID_IDocHostObject, (void **)&_pdho);

    IMoniker* pmk = NULL;
    BOOL fFileProtocol;
    hres = ::_URLMONMonikerFromPidl(_pidl, &pmk, &fFileProtocol);

    if (SUCCEEDED(hres) && EVAL(pmk))
    {
        hres = _pdoh->SetTarget(pmk, _uiCP, _pszLocation, _pidl, psvPrev, fFileProtocol);
        _psvPrev = psvPrev;

        if (_psvPrev)
            _psvPrev->AddRef();

#ifdef NON_NATIVE_FRAMES
        _CompleteDocHostPassing(psvPrev, hres);
#endif

        pmk->Release();
    }

    return hres;
}

void CDocObjectView::_GetViewSettings(IEVIEWINFO* pievi)
{
    DWORD dwType, dwSize;

    // REVIEW:  Currently, we have on setting for all docobj class views
    //  (everything hosted by shdocvw).  we may want to subclassify them by clsid
    // of the docobj or maybe special case mshtml...

    dwSize = sizeof(IEVIEWINFO);
    if (SHGetValueGoodBoot(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("ViewSettings"), &dwType, (PBYTE)pievi, &dwSize) == ERROR_SUCCESS)
    {
        if (pievi->cbSize != sizeof(IEVIEWINFO))
        {
            goto DefaultInfo;
        }

    }
    else
    {
DefaultInfo:

        // can't count on 0 init because registry could have read stuff, but
        // of the wrong size (corruption)

        pievi->fToolbar = FALSE;
        pievi->fCoolbar = TRUE;
        pievi->fStatusbar = TRUE;
    }
}

void CDocObjectView::_SaveViewState()
{
    IEVIEWINFO ievi;
    int id;

    // First ask up if it is ok for us to save view state.  If we get the return value of
    //  S_FALSE bail as we were told no.
    if (_pctShellBrowser &&
            (_pctShellBrowser->Exec(&CGID_Explorer, SBCMDID_MAYSAVEVIEWSTATE, 0, NULL, NULL) == S_FALSE))
        return;

    // first load to preserve things we're not going to set
    _GetViewSettings(&ievi);

    ievi.cbSize = sizeof(ievi);

    id = _ShowControl(FCW_STATUS, SBSC_QUERY);
    // bail if it's not supported
    if (id == -1)
        return;
    ievi.fStatusbar = (id == SBSC_SHOW);

    id = _ShowControl(FCW_TOOLBAR, SBSC_QUERY);
    if (id != -1) {
        // this is allowed to fail if toolbar isn't supported (ie30 case)
        ievi.fToolbar = (id == SBSC_SHOW);
    }

    id = _ShowControl(FCW_INTERNETBAR, SBSC_QUERY);
    if (id != -1) {
        // this is allowed to fail if coolbar isn't supported
        ievi.fCoolbar = (id == SBSC_SHOW);
    }

    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                    TEXT("ViewSettings"), REG_BINARY, (const BYTE *)&ievi, sizeof(ievi));
}

int CDocObjectView::_ShowControl(UINT idControl, int idCmd)
{
    VARIANTARG var;

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = MAKELONG(idControl, idCmd);

    if (_pctShellBrowser  &&
        SUCCEEDED(_pctShellBrowser->Exec(&CGID_Explorer, SBCMDID_SHOWCONTROL, OLECMDEXECOPT_DODEFAULT,
                                    &var, &var)))
        return var.lVal;


    return -1;
}




HRESULT CDocObjectView::DestroyViewWindow()
{
    ATOMICRELEASE(_pdho);

    if (_pdoh)
    {
        BOOL fDestroyHost = TRUE;

        if (_psb && _pdoh->_pwb)
        {
            DWORD dwFlags;

            _pdoh->_pwb->GetFlags(&dwFlags);

            if (dwFlags & BSF_HTMLNAVCANCELED)
            {
                IShellView * psvCur;

                HRESULT hr = _psb->QueryActiveShellView(&psvCur);
                if (S_OK == hr)
                {
                    CDocObjectView * pdovCur;

                    hr = psvCur->QueryInterface(CLSID_CDocObjectView, (void**)&pdovCur);
                    if (S_OK == hr)
                    {
                        ASSERT(this != pdovCur);

                        if (_pdoh == pdovCur->_pdoh)
                        {
                            fDestroyHost = FALSE;
                        }

                        pdovCur->Release();
                    }

                    psvCur->Release();
                }
            }
        }

        if (fDestroyHost)
        {
            TraceMsg(DM_WARNING, "CDocObjectView::DestroyViewWindow(): Destroying Host Window");

            _DisconnectHostSink();

            if (_fSaveViewState)
                _SaveViewState();

            _pdoh->DestroyHostWindow();
        }

        ATOMICRELEASET(_pdoh, CDocObjectHost);
    }

    ATOMICRELEASE(_pctShellBrowser);

    // Note that we should release _psb at the very end.
    ATOMICRELEASE(_psb);

    return S_OK;
}

HRESULT CDocObjectView::GetCurrentInfo(LPFOLDERSETTINGS lpfs)
{
    *lpfs = _fs;
    return S_OK;
}

HRESULT CDocObjectView::AddPropertySheetPages(DWORD dwReserved,
        LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    if (_pdoh)
        return _pdoh->AddPages(lpfn, lParam);

    return E_FAIL;
}

HRESULT CDocObjectView::SaveViewState()
{
    // No viewsate to be saved
    return S_OK;
}

HRESULT CDocObjectView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
    // No item
    return E_FAIL;
}

//
// IShellView::GetItemObject
//
//   For this IShellView object, the only valid uItem is SVGIO_BACKGROUND,
//  which allows the browser to access an interface pointer to the
//  currently active document object.
//
// Notes:
//   The browser should be aware that IShellView::CreateViewWindow might be
//  asynchronous. This method will fail with E_FAIL if the document is not
//  instanciated yet.
//
HRESULT CDocObjectView::GetItemObject(UINT uItem, REFIID riid, void **ppv)
{
    HRESULT hres = E_INVALIDARG;
    *ppv = NULL;    // assumes error
    switch(uItem)
    {
    case SVGIO_BACKGROUND:
        if (_pdoh)
        {
            if (_pdoh->_pole)
            {
                hres = _pdoh->_pole->QueryInterface(riid, ppv);
                break;
            }
            else if (_pdoh->_punkPending)
            {
                hres = _pdoh->_punkPending->QueryInterface(riid, ppv);
                break;
            }
        }

    // fall through on the else's
    default:
        hres = E_FAIL;
        break;
    }
    return hres;
}

HRESULT CDocObjectView::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _fSelfDragging = FALSE;

    //
    // Check if this is a self-dragging or not.
    //
    if (_pdoh && _pdoh->_pmsot) {
        VARIANT var = { 0 };
        HRESULT hresT = _pdoh->_pmsot->Exec(
                    &CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &var);
        if (SUCCEEDED(hresT) && var.vt==VT_I4 && var.lVal) {
            _fSelfDragging = TRUE;
        }
        VariantClearLazy(&var);
    }

    ASSERT(pdtobj);
    _DragEnter(_hwndParent, ptl, pdtobj);
    _dwDragEffect = CommonDragEnter(pdtobj, grfKeyState, ptl);

    return DragOver(grfKeyState, ptl, pdwEffect);
}

HRESULT CDocObjectView::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect &= _dwDragEffect;
    _DragMove(_hwndParent, ptl);
    if (_fSelfDragging && _pdoh && _pdoh->_hwnd) {
        RECT rc;
        GetClientRect(_pdoh->_hwnd, &rc);
        POINT ptMap =  { ptl.x, ptl.y };
        MapWindowPoints(HWND_DESKTOP, _pdoh->_hwnd, &ptMap, 1);
        if (PtInRect(&rc, ptMap)) {
            *pdwEffect = DROPEFFECT_NONE;
        }
    }

    return S_OK;
}

HRESULT CDocObjectView::DragLeave(void)
{
    DAD_DragLeave();
    return S_OK;
}

HRESULT CDocObjectView::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHPidlFromDataObject(pdtobj, &pidlTarget, NULL, 0);
    if (SUCCEEDED(hr)) {
        ASSERT(pidlTarget);
        if((!ILIsWeb(pidlTarget) && _pdoh && SHIsRestricted2W(_pdoh->_hwnd, REST_NOFILEURL, NULL, 0)) ||
            (_pdoh && !IEIsLinkSafe(_pdoh->_hwnd, pidlTarget, ILS_NAVIGATE)))
        {
            ILFree(pidlTarget);
            hr = E_ACCESSDENIED;
        }
        else
        {
            DWORD flags = GetKeyState(VK_CONTROL) < 0 ?
            (SBSP_NEWBROWSER | SBSP_ABSOLUTE) :
            (SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
            hr = _psb->BrowseObject(pidlTarget, flags);
            HFRMMSG2(TEXT("::Drop _psb->BrowseObject returned"), hr, 0);
            ILFree(pidlTarget);
        }
    }
    if (SUCCEEDED(hr))
    {
        *pdwEffect &= _dwDragEffect;
    }

    DAD_DragLeave();
    return hr;
}


ULONG CDocObjectView::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CDocObjectView(%x)::AddRef called new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CDocObjectView::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CDocObjectView(%x)::Release called new _cRef=%d", this, _cRef);

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDocObjectView::GetView(SHELLVIEWID* pvid, ULONG uView)
{
    return E_NOTIMPL;
}


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz) ++_cRef
#endif

HRESULT CDocObjectView::QueryInterface(REFIID riid, void ** ppvObj)
{
    HRESULT hres;

    static const QITAB qit[] = {
        QITABENT(CDocObjectView, IShellView2),
        QITABENTMULTI(CDocObjectView, IShellView, IShellView2),
        QITABENTMULTI(CDocObjectView, IOleWindow, IShellView2),
        QITABENT(CDocObjectView, IDropTarget),
        QITABENT(CDocObjectView, IViewObject),
        QITABENT(CDocObjectView, IAdviseSink),
        QITABENT(CDocObjectView, IOleCommandTarget),
        QITABENT(CDocObjectView, IDocViewSite),
        QITABENT(CDocObjectView, IPrivateOleObject ),
        QITABENT(CDocObjectView, IPersistFolder),
        QITABENTMULTI(CDocObjectView, IPersist, IPersistFolder),
        QITABENT(CDocObjectView, IServiceProvider),
        { 0 },
    };

    hres = QISearch(this, qit, riid, ppvObj);

    if (S_OK != hres)
    {
        if (IsEqualIID(riid, CLSID_CDocObjectView))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_CDocObjectView"));
            return S_OK;
        }
    }

    return hres;
}



/// ***** IViewObject ******

HRESULT CDocObjectView::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    if (_pdoh)
    {
        return _pdoh->GetColorSet(dwAspect, lindex, pvAspect, ptd,
            hicTargetDev, ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return S_FALSE;
}

HRESULT CDocObjectView::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::SetAdvise(DWORD dwAspect, DWORD advf,
    IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            OnViewChange(dwAspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDocObjectView::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

HRESULT CDocObjectView::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
    const RECTL *lprcBounds, const RECTL *lprcWBounds,
    BOOL (*pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    if (_pdoh) {
        return _pdoh->Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev,
            hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    }

    return OLE_E_BLANK;
}

// IAdviseSink
void CDocObjectView::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CDocObjectView::OnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CDocObjectView::OnRename(IMoniker *)
{
}

void CDocObjectView::OnSave()
{
}

void CDocObjectView::OnClose()
{
    //
    // the doc object host went away so tell anybody above what happened
    //
    OnViewChange(_advise_aspect, -1);
}


HRESULT CDocObjectView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (_pdho && _pdoh)
        hres = _pdho->QueryStatusDown(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return hres;
}

HRESULT CDocObjectView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (!pguidCmdGroup)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _SetLastRefreshTime();
            break;

        default:
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SHDVID_UPDATEDOCHOSTSTATE:
            if (_pdoh)
            {
                DOCHOSTUPDATEDATA * pdhud;

                ASSERT(pvarargIn && pvarargIn->vt == VT_PTR);
                pdhud = (DOCHOSTUPDATEDATA *) V_BYREF(pvarargIn);
                return _pdoh->_UpdateState(pdhud->_pidl, pdhud->_fIsErrorUrl);
            }
            return S_OK;

        case SHDVID_COMPLETEDOCHOSTPASSING:
            _CompleteDocHostPassing(_psvPrev, S_OK);
            ATOMICRELEASE(_psvPrev);

            return S_OK;

        case SHDVID_NAVSTART:
            if (_pdoh)
            {
                _pdoh->_Init();
            }
            
            return S_OK;

        default:
            break;
        }
    }

    // only forward on if we aren't 'stolen'.
    // FEATURE ie4: clean this up to steal _pdho along w/ _pdoh.
    if (_pdho && _pdoh)
        hres = _pdho->ExecDown(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    // REVIEW: if _pdoh->ExecDown fails && pguidCmdGroup==NULL && nCmdID is
    //            OLECMDID_STOP or OLECMDID_REFRESH, then we are lying
    //            by returning a failure error code.

    return hres;
}

HRESULT CDocObjectView::OnSetTitle(VARIANTARG *pvTitle)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::SetExtent( DWORD dwDrawAspect, SIZEL *psizel)
{
    if ( _pdoh && _pdoh->GetOleObject() )
    {
        return _pdoh->GetOleObject()->SetExtent( dwDrawAspect, psizel );
    }

    return E_NOTIMPL;
}

HRESULT CDocObjectView::GetExtent( DWORD dwDrawAspect, SIZEL *psizel)
{
    if ( _pdoh && _pdoh->GetOleObject() )
    {
        return _pdoh->GetOleObject()->GetExtent( dwDrawAspect, psizel );
    }

    return E_NOTIMPL;
}

HRESULT CDocObjectView::GetClassID(CLSID *pclsid)
{
    if (pclsid)
    {
        *pclsid = CLSID_CDocObjectView;
        return S_OK;
    }
    return E_INVALIDARG;
}

HRESULT CDocObjectView::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hres = E_OUTOFMEMORY;

    LPITEMIDLIST pidlClone = ILClone(pidl);
    if (pidlClone)
    {
        IShellFolder* psf;
        if (SUCCEEDED(IEBindToObject(_pidl, &psf)))
        {
            ILFree(_pidl);
            ATOMICRELEASE(_psf);

            _pidl = pidlClone;
            _psf = psf;

            hres = S_OK;
        }
        else
        {
            ILFree(pidlClone);
        }
    }

    return hres;
}

HRESULT CDocObjectView::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if( _pdoh && IsEqualGUID(guidService, IID_IElementNamespaceTable) )
    {
        return _pdoh->QueryService( guidService, riid, ppvObj);
    }
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shembed.h ===
#ifndef __SHEMBED_H__
#define __SHEMBED_H__

#include "caggunk.h"
#include "cwndproc.h"

//=========================================================================
// CShellEmbedding class definition
//
// NOTE: I'm killing the embeddingness of this class since we
// never shipped a control marked for embedding. If we need it
// back we can easily inherit from CImpIPersistStorage instead
// of IPersist. If you do this, make sure dvoc.cpp explicitly
// returns failure for QI for IPersistStorage or Trident won't
// host it.
//
//=========================================================================
class CShellEmbedding
    : public IPersist
    , public IOleObject               // Embedding MUST
    , public IViewObject2             // Embedding MUST
    , public IDataObject              // for Word/Excel
    , public IOleInPlaceObject        // In-Place MUST
    , public IOleInPlaceActiveObject  // In-Place MUST
    , public IInternetSecurityMgrSite
    , public CAggregatedUnknown
    , protected CImpWndProc
{
public:
    // *** IUnknown ***
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CAggregatedUnknown::QueryInterface(riid, ppvObj); }
    virtual ULONG __stdcall AddRef(void)
        { return CAggregatedUnknown::AddRef(); }
    virtual ULONG __stdcall Release(void)
        { return CAggregatedUnknown::Release(); }

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IViewObject ***
    virtual STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    virtual STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    virtual STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    virtual STDMETHODIMP Unfreeze(DWORD);
    virtual STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    virtual STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // *** IViewObject2 ***
    virtual STDMETHODIMP GetExtent(DWORD, LONG, DVTARGETDEVICE *, LPSIZEL);

    // *** IOleObject ***
    virtual HRESULT __stdcall SetClientSite(IOleClientSite *pClientSite);
    virtual HRESULT __stdcall GetClientSite(IOleClientSite **ppClientSite);
    virtual HRESULT __stdcall SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    virtual HRESULT __stdcall Close(DWORD dwSaveOption);
    virtual HRESULT __stdcall SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk);
    virtual HRESULT __stdcall GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    virtual HRESULT __stdcall InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved);
    virtual HRESULT __stdcall GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject);
    virtual HRESULT __stdcall DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    virtual HRESULT __stdcall EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual HRESULT __stdcall Update(void);
    virtual HRESULT __stdcall IsUpToDate(void);
    virtual HRESULT __stdcall GetUserClassID(CLSID *pClsid);
    virtual HRESULT __stdcall GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType);
    virtual HRESULT __stdcall SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT __stdcall GetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT __stdcall Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall Unadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT __stdcall GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual HRESULT __stdcall SetColorScheme(LOGPALETTE *pLogpal);

    // *** IDataObject ***
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    // *** IOleWindow ***
    virtual HRESULT __stdcall GetWindow(HWND * lphwnd);
    virtual HRESULT __stdcall ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceObject ***
    virtual HRESULT __stdcall InPlaceDeactivate(void);
    virtual HRESULT __stdcall UIDeactivate(void);
    virtual HRESULT __stdcall SetObjectRects(LPCRECT lprcPosRect,
        LPCRECT lprcClipRect);
    virtual HRESULT __stdcall ReactivateAndUndo(void);

    // *** IOleInPlaceActiveObject ***
    virtual HRESULT __stdcall TranslateAccelerator(LPMSG lpmsg);
    virtual HRESULT __stdcall OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT __stdcall OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT __stdcall ResizeBorder(LPCRECT prcBorder,
        IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow);
    virtual HRESULT __stdcall EnableModeless(BOOL fEnable);

protected:
    CShellEmbedding(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs=NULL);
    virtual ~CShellEmbedding();
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

    virtual void _OnSetClientSite(void);    // called when we actually get a client site

    // Activation related -- this is the normal order these funcs get called
    HRESULT _DoActivateChange(IOleClientSite* pActiveSite, UINT uState, BOOL fForce); // figures out what to do
    virtual HRESULT _OnActivateChange(IOleClientSite* pActiveSite, UINT uState);// calls below
    virtual void _OnInPlaceActivate(void);      // called when we actually go in-place-active
    virtual void _OnUIActivate(void);           // called when we actually go ui-active
    virtual void _OnUIDeactivate(void);         // called when we actually go ui-deactive
    virtual void _OnInPlaceDeactivate(void);    // called when we actually deactivate

    // Window related
    virtual LRESULT v_WndProc(HWND, UINT, WPARAM, LPARAM);
    void _RegisterWindowClass(void);

    // Helper functions for subclasses
    HRESULT _CreateWindowOrSetParent(IOleWindow* pwin);
    HDC _OleStdCreateDC(DVTARGETDEVICE *ptd);

    void _ViewChange(DWORD dwAspect, LONG lindex);
    void _SendAdvise(UINT uCode);

    BOOL _ShouldDraw(LONG lindex);

    IOleClientSite*     _pcli;
    IOleClientSite*     _pcliHold;  // Save a pointer to our client site if we're DoVerbed after Close
    IAdviseSink*        _padv;
    DWORD               _advf;      // ADVF_ flags (p.166 OLE spec)
    DWORD               _asp;       // DVASPECT
    IStorage*           _pstg;
    SIZE                _size;
    SIZEL               _sizeHIM;       // HIMETRIC SetExtent size -- we pretty much ignore this.
    LPCOBJECTINFO       _pObjectInfo;   // pointer into global object array

    // WARNING: Load's OLE
    IOleAdviseHolder*   _poah;
    IDataAdviseHolder*  _pdah;

    // In-Place object specific
    RECT                _rcPos;
    RECT                _rcClip;
    IOleInPlaceSite*    _pipsite;
    IOleInPlaceFrame*   _pipframe;
    IOleInPlaceUIWindow* _pipui;
    OLEINPLACEFRAMEINFO _finfo;
    HWND                _hwndChild;
    const OLEVERB*      _pverbs;
    BOOL                _fDirty:1;
    BOOL                _fOpen:1;
    BOOL                _fUsingWindowRgn:1;
    UINT                _nActivate;
};

// Activation defines
#define OC_DEACTIVE         0
#define OC_INPLACEACTIVE    1
#define OC_UIACTIVE         2

//
//Copied from polyline.h in Inside OLE 2nd edition
//
//Code for CShellEmbedding::_SendAdvise
//......Code.....................Method called in CShellEmbedding::_SendAdvise
#define OBJECTCODE_SAVED       0 //IOleAdviseHolder::SendOnSave
#define OBJECTCODE_CLOSED      1 //IOleAdviseHolder::SendOnClose
#define OBJECTCODE_RENAMED     2 //IOleAdviseHolder::SendOnRename
#define OBJECTCODE_SAVEOBJECT  3 //IOleClientSite::SaveObject
#define OBJECTCODE_DATACHANGED 4 //IDataAdviseHolder::SendOnDataChange
#define OBJECTCODE_SHOWWINDOW  5 //IOleClientSite::OnShowWindow(TRUE)
#define OBJECTCODE_HIDEWINDOW  6 //IOleClientSite::OnShowWindow(FALSE)
#define OBJECTCODE_SHOWOBJECT  7 //IOleClientSite::ShowObject
#define OBJECTCODE_VIEWCHANGED 8 //IAdviseSink::OnViewChange

// A helper function in shembed.c
void PixelsToMetric(SIZEL* psize);
void MetricToPixels(SIZEL* psize);

//=========================================================================
// CSVVerb class definition
//=========================================================================
class CSVVerb : public IEnumOLEVERB
{
public:
    // *** IUnknown ***
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual ULONG __stdcall AddRef(void) ;
    virtual ULONG __stdcall Release(void);

    // *** IEnumOLEVERB ***
    virtual /* [local] */ HRESULT __stdcall Next(
        /* [in] */ ULONG celt,
        /* [out] */ LPOLEVERB rgelt,
        /* [out] */ ULONG *pceltFetched);

    virtual HRESULT __stdcall Skip(
        /* [in] */ ULONG celt);

    virtual HRESULT __stdcall Reset( void);

    virtual HRESULT __stdcall Clone(
        /* [out] */ IEnumOLEVERB **ppenum);

    CSVVerb(const OLEVERB* pverbs) : _cRef(1), _iCur(0), _pverbs(pverbs) {}

protected:
    UINT _cRef;
    UINT _iCur;
    const OLEVERB* _pverbs;
};


#endif // __SHEMBED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shocx.cpp ===
// builds an ocx out of the embedding in shembed.c

#include "priv.h"
#include "sccls.h"
#include "olectl.h"
#include "stdenum.h"
#include "shocx.h"
#include "resource.h"

LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

#define SUPERCLASS CShellEmbedding

CShellOcx::CShellOcx(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs, const OLEVERB* pdesignverbs) :
                        CShellEmbedding(punkOuter, poi, pverbs),
                        _pDesignVerbs(pdesignverbs),
                        CImpIDispatch(LIBID_SHDocVw, 1, 1, *(poi->piid))
{
    // CShellEmbedding class handles the DllAddRef / DllRelease

    m_cpEvents.SetOwner(_GetInner(), poi->piidEvents);
    m_cpPropNotify.SetOwner(_GetInner(), &IID_IPropertyNotifySink);

    _nDesignMode = MODE_UNKNOWN;
}

CShellOcx::~CShellOcx()
{
    // Should have been released when cllient site was set to NULL.... Don't release
    // it here as this will cause some applications like VC5 to fault...
    ASSERT(_pDispAmbient==NULL);

    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();
}

//
// We have a different set of verbs in design mode
//
HRESULT CShellOcx::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    TraceMsg(TF_SHDCONTROL, "sho: EnumVerbs");

    if (_IsDesignMode())
    {
        *ppEnumOleVerb = new CSVVerb(_pDesignVerbs);
        if (*ppEnumOleVerb)
            return S_OK;
    }

    return SUPERCLASS::EnumVerbs(ppEnumOleVerb);
}


//
// For the interfaces we support here
//
HRESULT CShellOcx::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellOcx, IDispatch),
        QITABENT(CShellOcx, IOleControl),
        QITABENT(CShellOcx, IConnectionPointContainer),
        QITABENT(CShellOcx, IPersistStreamInit),
        QITABENTMULTI(CShellOcx, IPersistStream, IPersistStreamInit),
        QITABENT(CShellOcx, IPersistPropertyBag),
        QITABENT(CShellOcx, IProvideClassInfo2),
        QITABENTMULTI(CShellOcx, IProvideClassInfo, IProvideClassInfo2),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);
    return hr;
}

//
// On a SetClientSite, we need to discard everything created from _pcli
// because shembed frees _pcli
//
HRESULT CShellOcx::SetClientSite(IOleClientSite *pClientSite)
{
    if (_pDispAmbient)
    {
        _pDispAmbient->Release();
        _pDispAmbient = NULL;
    }

    return SUPERCLASS::SetClientSite(pClientSite);
}


HRESULT CShellOcx::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    if (_IsDesignMode())
    {
        HBRUSH hbrOld = (HBRUSH)SelectObject(hdcDraw, (HBRUSH)GetStockObject(WHITE_BRUSH));
        HPEN hpenOld = (HPEN)SelectObject(hdcDraw, (HPEN)GetStockObject(BLACK_PEN));
        Rectangle(hdcDraw, lprcBounds->left, lprcBounds->top, lprcBounds->right, lprcBounds->bottom);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->top, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->top);
        SelectObject(hdcDraw, hbrOld);
        SelectObject(hdcDraw, hpenOld);
        return S_OK;
    }

    return SUPERCLASS::Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                            lprcBounds, lprcWBounds, pfnContinue, dwContinue);
}


// IPersistStream

HRESULT CShellOcx::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    // REVIEW: this is overly large, I believe E_NOTIMPL is a valid
    // return from this and it tells the container that we don't know how big we are.

    ULARGE_INTEGER cbMax = { 1028 * 8, 0 }; // isn't this overly large?
    *pcbSize = cbMax;
    return S_OK;
}

// IOleControl
STDMETHODIMP CShellOcx::GetControlInfo(LPCONTROLINFO pCI)
{
    return E_NOTIMPL; // for mnemonics
}
STDMETHODIMP CShellOcx::OnMnemonic(LPMSG pMsg)
{
    return E_NOTIMPL; // for mnemonics
}
STDMETHODIMP CShellOcx::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_AMBIENT_USERMODE:           // design mode  vs  run mode
    case DISPID_UNKNOWN:
        _nDesignMode = MODE_UNKNOWN;
        break;
    }

    return S_OK;
}

STDMETHODIMP CShellOcx::FreezeEvents(BOOL bFreeze)
{
    _fEventsFrozen = bFreeze;
    return S_OK;
}

HRESULT CShellOcx::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    // This is gross, for some reason from VBScript in a page can not get "Document" through so try "Doc" and map
    HRESULT hres = CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (FAILED(hres) && (cNames == 1) && rgszNames)
    {
        OLECHAR const *c_pwszDocument = L"Document";

        if (StrCmpIW(*rgszNames, L"Doc") == 0)
            hres = CImpIDispatch::GetIDsOfNames(riid, (OLECHAR**)&c_pwszDocument, cNames, lcid, rgdispid);
    }
    return hres;
}


// ConnectionPointContainer
CConnectionPoint* CShellOcx::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint* pccp;

    if (IsEqualIID(iid, EVENTIIDOFCONTROL(this)) ||
        (fdisp && IsEqualIID(iid, IID_IDispatch)))
    {
        pccp = &m_cpEvents;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CShellOcx::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 2,
            m_cpEvents.CastToIConnectionPoint(),
            m_cpPropNotify.CastToIConnectionPoint());
}

// IProvideClassInfo2
STDMETHODIMP CShellOcx::GetClassInfo(LPTYPEINFO * ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocale),
            LIBID_SHDocVw, 1, 1, CLSIDOFOBJECT(this), &_pClassTypeInfo);

    if (_pClassTypeInfo) 
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    ppTI = NULL;
    return E_FAIL;
}

// IProvideClassInfo2

STDMETHODIMP CShellOcx::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (pGUID == NULL)
        return E_POINTER;
    
    if ( (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
        && _pObjectInfo->piidEvents)
    {
        *pGUID = EVENTIIDOFCONTROL(this);
        return S_OK;
    }
    *pGUID = GUID_NULL;
    return E_FAIL;
}
 
// returns TRUE iff MODE_DESIGN

BOOL CShellOcx::_IsDesignMode(void)
{
    if (_nDesignMode == MODE_UNKNOWN)
    {
        VARIANT_BOOL fBool;

        if (_GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &fBool))
        {
            _nDesignMode = fBool ? MODE_FALSE : MODE_TRUE;
        }
        else
            _nDesignMode = MODE_FALSE;
    }
    return _nDesignMode == MODE_TRUE;
}

// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY = 0,
    0,                      // VT_NULL = 1,
    sizeof(short),          // VT_I2 = 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4 = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH = 9,
    sizeof(SCODE),          // VT_ERROR = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL = 11,
    sizeof(VARIANT),        // VT_VARIANT = 12,
    sizeof(IUnknown *),     // VT_UNKNOWN = 13,
};


// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL CShellOcx::_GetAmbientProperty(DISPID dispid, VARTYPE vt, void *pData)
{
    // IE30's WebBrowser OC never requested ambient properties.
    // IE40's does and we're finding that apps implemented some of
    // the properties we care about incorrectly. Assume old classid
    // means this is an old app and fail. The code that calls this
    // is smart enough to deal with failure.
    //
    if (_pObjectInfo->pclsid == &CLSID_WebBrowser_V1)
        return FALSE;

    HRESULT hr = E_FAIL;

    if (!_pDispAmbient && _pcli)
        _pcli->QueryInterface(IID_PPV_ARG(IDispatch, &_pDispAmbient));

    if (_pDispAmbient)
    {
        DISPPARAMS dispparams = {0};
        VARIANT v;
        VariantInit(&v);
        hr = _pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams, &v, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            VARIANT vDest;
            VariantInit(&vDest);
            // we've got the variant, so now go an coerce it to the type
            // that the user wants.
            //
            hr = VariantChangeType(&vDest, &v, 0, vt);
            if (SUCCEEDED(hr))
            {
                // copy the data to where the user wants it
                //
                if (vt < ARRAYSIZE(g_rgcbDataTypeSize))
                {
                    CopyMemory(pData, &vDest.lVal, g_rgcbDataTypeSize[vt]);
                }
                else
                {
                    hr = E_FAIL;
                }
                VariantClear(&vDest);
            }
            VariantClear(&v);
        }
    }
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shocx.h ===
#ifndef __SHOCX_H__
#define __SHOCX_H__

#include "cnctnpt.h"
#include "dspsprt.h"
#include "expdsprt.h"

//
// shocx.h
//

#define _INTERFACEOFOBJECT      1
#define _CLSIDOFOBJECT          2

class CShellOcx: public CShellEmbedding,        // IOleObject, IOleInPlacceObject, IOleInPlaceActiveObject,
                                                // IViewObject2, IPersistStorage
                 public IPersistStreamInit,
                 public IPersistPropertyBag,
                 public IOleControl,            // OnAmbientPropertyChange
                 public IDispatch,
                 public IProvideClassInfo2,
                 protected CImpIConnectionPointContainer,
                 protected CImpIDispatch
{
public:
    // *** IUnknown *** (we multiply inherit from IUnknown, disambiguate here)
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
        { return CShellEmbedding::QueryInterface(riid, ppvObj); }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CShellEmbedding::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CShellEmbedding::Release(); }

    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) {return CShellEmbedding::GetClassID(pClassID);} // IPersistStorage implementation
    virtual STDMETHODIMP IsDirty(void) {return _fDirty ? S_OK : S_FALSE;}
    virtual STDMETHODIMP Load(IStream *pStm) PURE;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) PURE;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void) PURE;

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pBag, IErrorLog *pErrorLog) PURE;
    virtual STDMETHODIMP Save(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties) PURE;

    // *** IOleControl ***
    virtual STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
    virtual STDMETHODIMP OnMnemonic(LPMSG pMsg);
    virtual STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
    virtual STDMETHODIMP FreezeEvents(BOOL bFreeze);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** CImpIConnectionPointContainer ***
    virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);

    // *** IProvideClassInfo2 ***
    virtual STDMETHODIMP GetClassInfo(LPTYPEINFO * ppTI);
    virtual STDMETHODIMP GetGUID(DWORD dwGuidKind, GUID *pGUID);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.OnChanged(dispid);
    }

    /*
    ** CShellEmbedding stuff
    */

    // *** IOleObject ***
    virtual STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // *** IViewObject ***
    virtual STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);

    /*
    ** CShellOcx specific stuff
    */

    CShellOcx(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs=NULL, const OLEVERB* pdesignverbs=NULL);
    ~CShellOcx();

protected:

    // from CShellEmbedding
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);

    ITypeInfo *_pClassTypeInfo; // ITypeInfo of class

    const OLEVERB* _pDesignVerbs;   // verb list for design mode -- run mode is in CShellEmbedding

    // Ambient Properties we care about
    IDispatch* _pDispAmbient;
    BOOL _GetAmbientProperty(DISPID dispid, VARTYPE vt, void *pData);
    int  _nDesignMode;          // MODE_UNKNOWN, MODE_TRUE, MODE_FALSE
    BOOL _IsDesignMode(void);   // TRUE means we have a design-mode container

    BOOL _fEventsFrozen:1;


    CConnectionPoint m_cpEvents;
    CConnectionPoint m_cpPropNotify;
} ;

// _nDesignMode,etc flags
#define MODE_UNKNOWN -1      // mode has not yet been determined
#define MODE_TRUE    1
#define MODE_FALSE   0

// CConnectionPoint types:
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

#endif // __SHOCX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shuioc.cpp ===
//
// Shell UI Control Class (CShellUIHelper)
//
// Sample code : shell\docs\shuiod.htm
//
// This is the source code of the ShellUI control class. You can put an instance
// of ShellUI control on any HTML pages then
// 
// The key thing is it always bring up some UI and never alter the system
// silently (without the User's interaction). By doing this, we can expose
// shell features as much as we want without worrying about the security
// problem (which automation interface has).
// 
// This control also allow us to provide many configuration type UI (such as
// "Customize your IE page") as well as rich web-view on some folders
// (especially control panel ;-) without paying the cost of data-binding. 
// 
#include "priv.h"
#include "sccls.h"
#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif
#include "favorite.h"
#include "caggunk.h"
#include "resource.h"
#include "channel.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "iforms.h"
#include "dspsprt.h"
#include "impexp.h" // needed for RunImportExportWizard()
#include "iforms.h"
//#include "cobjsafe.h" // CObjectSafety
#include "shvocx.h" // WrapSpecialUrl()

#include <mluisupp.h>

#define REG_DESKCOMP_SCHEME                 TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme")
#define REG_VAL_SCHEME_DISPLAY              TEXT("Display")
#define REG_VAL_GENERAL_WALLPAPER           TEXT("Wallpaper")
#define REG_VAL_GENERAL_TILEWALLPAPER       TEXT("TileWallpaper")
#define REG_DESKCOMP_GENERAL                TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sGeneral")

STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo);

// move it to shdocvw.h
UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags);

#define DM_SHUIOC   DM_TRACE

LONG GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz);

HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

EXTERN_C const SA_BSTRGUID s_sstrSearch;
EXTERN_C const SA_BSTRGUID s_sstrFailureUrl;


class CShellUIHelper :
        public CAggregatedUnknown,
        public IObjectWithSite,
        public IObjectSafety,
        public IShellUIHelper,  // dual, IDispatch
        public IDispatchEx,
        protected CImpIDispatch
{
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, 
        DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, 
        DWORD dwEnabledOptions);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                               LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
                        DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                        EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // IDispatchEx
    STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                          VARIANT *pvarRes, EXCEPINFO *pei, 
                          IServiceProvider *pspCaller);
    STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex);           
    STDMETHODIMP DeleteMemberByDispID(DISPID id);           
    STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);           
    STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
    STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);

    // IShellUIHelper
    STDMETHODIMP Execute();
    STDMETHODIMP ResetSafeMode();
    STDMETHODIMP ResetFirstBootMode();
    STDMETHODIMP RefreshOfflineDesktop();
    STDMETHODIMP AddFavorite(BSTR strURL, VARIANT *Title);
    STDMETHODIMP AddChannel(BSTR bstrURL);
    STDMETHODIMP AddDesktopComponent(BSTR strURL, BSTR strType, 
                        VARIANT *Left, VARIANT *Top, 
                        VARIANT *Width, VARIANT *Height);
    STDMETHODIMP IsSubscribed(BSTR bstrURL, VARIANT_BOOL* pBool);
    STDMETHODIMP NavigateAndFind(BSTR URL, BSTR strQuery, VARIANT* varTargetFrame);
    STDMETHODIMP ImportExportFavorites(VARIANT_BOOL fImport, BSTR strImpExpPath);
    STDMETHODIMP AutoCompleteSaveForm(VARIANT *Form);
    STDMETHODIMP AutoScan(BSTR strSearch, BSTR strFailureUrl, VARIANT* pvarTargetFrame);
    STDMETHODIMP AutoCompleteAttach(VARIANT *Form);
    STDMETHODIMP ShowBrowserUI(BSTR bstrName, VARIANT *pvarIn, VARIANT *pvarOut);

    HRESULT v_InternalQueryInterface(REFIID riid, void ** ppvObj);

    CShellUIHelper(IUnknown* punkAgg);
    ~CShellUIHelper();

    inline IDispatch *GetExternalDispatch()
    {
        return _pExternalDispEx ? _pExternalDispEx : _pExternalDisp;
    }

    void SetExternalDispatch(IDispatch *pExternalDisp)
    {
        ATOMICRELEASE(_pExternalDisp);
        ATOMICRELEASE(_pExternalDispEx);

        //  If we were passed an IDispatch to delegate to then we need to
        //  see if it can do IDispatchEx so we can support it as well,
        //  otherwise we just fall back to good ole IDispatch.
        if (pExternalDisp)
        {
            if (FAILED(pExternalDisp->QueryInterface(IID_IDispatchEx, 
                                      (void **)&_pExternalDispEx)))
            {
                _pExternalDisp = pExternalDisp;
                _pExternalDisp->AddRef();
            }
        }
    }

    STDMETHODIMP ShowChannel(IChannelMgrPriv *pChMgrPriv, LPWSTR pwszURL, HWND hwnd);
    HWND _GetOwnerWindow();
    HRESULT _ConnectToTopLevelConnectionPoint(BOOL fConnect, IUnknown* punk);
    STDMETHODIMP _DoFindOnPage(IDispatch* pdisp);

    friend HRESULT CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                                 IUnknown *pSite, IDispatch *pExternalDisp);

    DWORD               _dwSafety;
    // Cached pointers, hwnd
    IUnknown*           _punkSite;  // site pointer
    IDispatchEx*        _pExternalDispEx;
    IDispatch*          _pExternalDisp;
    DWORD               _dwcpCookie;
    BOOL                _fWaitingToFindText;
    BSTR                _bstrQuery;
    VOID *              _pvIntelliForms;
};

STDAPI CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CShellUIHelper* psuo = new CShellUIHelper(punkOuter);
    if (psuo)
    {
        *ppunk = psuo->_GetInner();
        hres = S_OK;
    }
    return hres;
}

HRESULT CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                      IUnknown *pSite, IDispatch *pExternalDisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CShellUIHelper* psuo = new CShellUIHelper(NULL);
    
    if (psuo)
    {
        hres = psuo->QueryInterface(riid, (void **)ppunk);
        psuo->Release();

        if (SUCCEEDED(hres))
        {
            psuo->SetSite(pSite);
            psuo->SetExternalDispatch(pExternalDisp);
        }
    }

    return hres;
}

CShellUIHelper::CShellUIHelper(IUnknown* punkAgg) :
    CAggregatedUnknown(punkAgg),
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IShellUIHelper)
{
    DllAddRef();
    _fWaitingToFindText = FALSE;
    _bstrQuery = NULL;
}

CShellUIHelper::~CShellUIHelper()
{

    ReleaseIntelliForms(_pvIntelliForms);

    if (_punkSite)
        SetSite(NULL);  // In case the parent did not clean it up.
    if (_bstrQuery)
        SysFreeString(_bstrQuery);
    ATOMICRELEASE(_pExternalDisp);
    ATOMICRELEASE(_pExternalDispEx);

    DllRelease();
}

HRESULT CShellUIHelper::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IShellUIHelper))
    {
        *ppvObj = SAFECAST(this, IShellUIHelper *);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite *);
    }
    else if (IsEqualIID(riid, IID_IObjectSafety))
    {
        *ppvObj = SAFECAST(this, IObjectSafety *);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppvObj = SAFECAST(this, IDispatchEx *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HWND CShellUIHelper::_GetOwnerWindow()
{
    HWND hwnd;
    HRESULT hres;

    // this deals with NULL _punkSite and zeros hwnd on failure
    IUnknown_GetWindow(_punkSite, &hwnd);

    if (!hwnd)
    {
        //
        //  We get to this point if we are instantiated like this
        //  in jscript:
        //      foo = new ActiveXObject("Shell.UIControl");
        //  or vbscript:
        //      set foo = CreateObject("Shell.UIControl");
        //
        if (_punkSite)
        {
            IServiceProvider *pSP = NULL;
            IOleWindow *pOleWindow = NULL;
            hres = _punkSite->QueryInterface(IID_IServiceProvider, (void **)&pSP);

            if (SUCCEEDED(hres))
            {
                ASSERT(pSP);

                hres = pSP->QueryService(SID_SContainerDispatch, IID_IOleWindow, 
                                         (void **)&pOleWindow);
                if (SUCCEEDED(hres))
                {
                    pOleWindow->GetWindow(&hwnd);
                    pOleWindow->Release();
                }
                pSP->Release();
            }
        }
        else
        {
            //  It's either this or the functions we call should take NULL for HWNDs.
            hwnd = GetDesktopWindow();
        }
    }

    return hwnd;
}

HRESULT CShellUIHelper::_ConnectToTopLevelConnectionPoint(BOOL fConnect, IUnknown* punk)
{
    HRESULT hr = E_INVALIDARG;
    IConnectionPointContainer* pcpContainer;
    IServiceProvider*          psp;
    IServiceProvider*          psp2;

    ASSERT(punk);
    if (punk)
    {
        hr = punk->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp));

        if (SUCCEEDED(hr))
        {
            hr = psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void**) &psp2);

            if (SUCCEEDED(hr))
            {
                hr = psp2->QueryService(SID_SWebBrowserApp, IID_IConnectionPointContainer, (void **)&pcpContainer);

                if (SUCCEEDED(hr))
                {
                    //to avoid ambiguous reference
                    IDispatch* pdispThis;
                    this->QueryInterface(IID_IDispatch, (void **)&pdispThis);
                    ASSERT(pdispThis);
                
                    hr = ConnectToConnectionPoint(pdispThis, DIID_DWebBrowserEvents2, fConnect,
                                                  pcpContainer, &_dwcpCookie, NULL);
                    pcpContainer->Release();
                    pdispThis->Release();
                }
                psp2->Release();
            }
            psp->Release();
        }
    }
    
    return hr;
}

HRESULT CShellUIHelper::SetSite(IUnknown *punkSite)
{
    if (!_punkSite)
    {
        _ConnectToTopLevelConnectionPoint(TRUE, punkSite);
    } 
    else
    {
        ASSERT(punkSite == NULL);   //if we've already got _punkSite, we'd better be releasing the site

        _ConnectToTopLevelConnectionPoint(FALSE, _punkSite);
        ATOMICRELEASE(_punkSite);
    }
    
    _punkSite = punkSite;

    if (_punkSite)
        _punkSite->AddRef();

    return S_OK;
}

HRESULT CShellUIHelper::GetSite(REFIID riid, void **ppvSite)
{
    TraceMsg(DM_SHUIOC, "SHUO::GetSite called");

    if (_punkSite) 
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}

STDMETHODIMP CShellUIHelper::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, 
                                             DWORD *pdwEnabledOptions)
{
    HRESULT hr = S_OK;

    if (!pdwSupportedOptions || !pdwEnabledOptions)
        return E_POINTER;

    if (IID_IDispatch == riid)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = _dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


STDMETHODIMP CShellUIHelper::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, 
                                             DWORD dwEnabledOptions)
{
    HRESULT hr = S_OK;
    
    if (IID_IDispatch == riid)
        _dwSafety = dwOptionSetMask & dwEnabledOptions;
    else
        hr = E_NOINTERFACE;

    return hr;
}


struct SHUI_STRMAP 
{
    LPCTSTR psz;
    int id;
};

int _MapStringToId(LPCTSTR pszStr, const SHUI_STRMAP* const psmap, int cel, int idDefault)
{
    if (pszStr)
    {
        for (int i=0; i<cel ; i++) 
        {
            if (StrCmpI(psmap[i].psz, pszStr) == 0) 
            {
                return psmap[i].id;
            }
        }
    }
    return idDefault;
}


LPCTSTR OptionalVariantToStr(VARIANT *pvar, LPTSTR pszBuf, UINT cchBuf)
{
    if (pvar->vt == VT_BSTR && pvar->bstrVal)
    {
        SHUnicodeToTChar(pvar->bstrVal, pszBuf, cchBuf);
        return pszBuf;
    }
    *pszBuf = 0;
    return NULL;
}

int OptionalVariantToInt(VARIANT *pvar, int iDefault)
{
    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(VariantChangeType(&v, pvar, 0, VT_I4)))
    {
        iDefault = v.lVal;
        // VariantClear(&v);   // not needed, VT_I4 has no allocs
    }
    return iDefault;
}

BOOL OptionalVariantToBool(VARIANT *pvar, BOOL fDefault)
{
    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(VariantChangeType(&v, pvar, 0, VT_BOOL)))
    {
        fDefault = v.boolVal;
    }
    return fDefault;
}

//------------------------------------------------------------------------
STDMETHODIMP CShellUIHelper::AddFavorite(/* [in] */ BSTR strURL, /* [in][optional] */ VARIANT *Title)
{
    HRESULT hres = S_OK;
    LPITEMIDLIST pidl;
    BSTR bstrTemp = NULL;

    if (IsSpecialUrl(strURL))
    {
        bstrTemp = SysAllocString(strURL);
        if (bstrTemp)
        {
            hres = WrapSpecialUrl(&bstrTemp);
            if (SUCCEEDED(hres))
                strURL = bstrTemp;
        }
        else
            hres = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hres))
        hres = IECreateFromPath(strURL, &pidl);
    if (SUCCEEDED(hres)) 
    {
        TCHAR szTitle[MAX_PATH];
        hres = ::AddToFavorites(_GetOwnerWindow(), pidl, OptionalVariantToStr(Title, szTitle, ARRAYSIZE(szTitle)), TRUE, NULL, NULL);
        ILFree(pidl);
    }
    if (bstrTemp)
        SysFreeString(bstrTemp);
    return hres;
}


//------------------------------------------------------------------------

STDMETHODIMP CShellUIHelper::ShowChannel(IChannelMgrPriv *pChMgrPriv, LPWSTR pwszURL, HWND hwnd)
{
    HRESULT hres = E_FAIL;
    IServiceProvider *pSP1 = NULL,
                     *pSP2 = NULL;
    IWebBrowser2 *pWebBrowser2 = NULL;

    if (_punkSite)
    {
        hres = _punkSite->QueryInterface(IID_IServiceProvider, (void **)&pSP1);
        if (SUCCEEDED(hres))
        {
            ASSERT(pSP1);
            hres = pSP1->QueryService(SID_STopLevelBrowser,
                                      IID_IServiceProvider,
                                      (void**)&pSP2);
            if (SUCCEEDED(hres))
            {
                ASSERT(pSP2);
                hres = pSP2->QueryService(SID_SWebBrowserApp,
                                          IID_IWebBrowser2,
                                          (void**)&pWebBrowser2);
                ASSERT((SUCCEEDED(hres) && pWebBrowser2) || FAILED(hres));
                pSP2->Release();
            }
            pSP1->Release();
        }
    }

    if (FAILED(hres))
    {
        hres = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
    }

    if (SUCCEEDED(hres))
    {
        ASSERT(pWebBrowser2);
        hres = pChMgrPriv->ShowChannel(pWebBrowser2, pwszURL, hwnd);
        pWebBrowser2->Release();
    }
    
    return hres;
}

STDMETHODIMP CShellUIHelper::AddChannel(BSTR bstrURL)
{
    HRESULT hres;
    IChannelMgrPriv *pChMgrPriv;

    TCHAR szURL[MAX_URL_STRING];
    HWND hwnd;

    if (!bstrURL)
    {
        return E_INVALIDARG;
    }
    
    hwnd = _GetOwnerWindow();

    //
    //  As long as the underlying functions choke on NULL HWNDs then we may as well
    //  bail early.
    //
    if (hwnd)
    {
        if (!SHIsRestricted2W(hwnd, REST_NoChannelUI, NULL, 0) && !SHIsRestricted2W(hwnd, REST_NoAddingChannels, NULL, 0))
        {
            StrCpyNW(szURL, bstrURL, ARRAYSIZE(szURL));

            hres = JITCoCreateInstance(CLSID_ChannelMgr, 
                                    NULL,
                                    CLSCTX_INPROC_SERVER, 
                                    IID_IChannelMgrPriv, 
                                    (void **)&pChMgrPriv,
                                    hwnd,
                                    FIEF_FLAG_FORCE_JITUI);

            if (S_OK == hres)
            {
                ASSERT(pChMgrPriv);
            
                hres = pChMgrPriv->AddAndSubscribe(hwnd, bstrURL, NULL);
                if (hres == S_OK)
                {
                    hres = ShowChannel(pChMgrPriv, bstrURL, hwnd);
                }
                else if (FAILED(hres))
                {
                    IE_ErrorMsgBox(NULL, hwnd, hres, NULL, szURL, IDS_CHANNEL_UNAVAILABLE, MB_OK| MB_ICONSTOP);
                    hres = S_FALSE;
                }
                pChMgrPriv->Release();
            }
            else if (SUCCEEDED(hres))
            {
                hres = S_FALSE; // FAIL silently for now - throw dialog for indicating that reboot required if needed
            } else
            {
                IE_ErrorMsgBox(NULL, hwnd, hres, NULL, szURL, IDS_FAV_UNABLETOCREATE, MB_OK| MB_ICONSTOP);
                hres = S_FALSE;
            }
        }
        else
        {
            hres = S_FALSE;  // Failure code results in a script error.
        }
    }
    else    //  !hwnd
    {
        hres = E_FAIL;
    }
    return hres;
}


// A lot like GetHTMLDoc2, but only cares about window.external
STDMETHODIMP GetTopLevelBrowser(IUnknown *punk, IWebBrowser2 **ppwb2)
{
    return IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, ppwb2));
}


STDMETHODIMP ZoneCheck(IUnknown *punkSite, BSTR bstrReqUrl)
{
    HRESULT hr = E_ACCESSDENIED;

    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    //  1)  Get an IHTMLDocument2 pointer
    //  2)  Get URL from doc
    //  3)  Create security manager
    //  4)  Check if doc URL zone is local, if so everything's S_OK
    //  5)  Otherwise, get and compare doc URL SID to requested URL SID

    IHTMLDocument2 *pHtmlDoc;
    if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
    {
        ASSERT(pHtmlDoc);
        BSTR bstrDocUrl;
        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
        {
            ASSERT(bstrDocUrl);
            IInternetSecurityManager *pSecMgr;

            HRESULT hrTmp = IUnknown_QueryService(punkSite, SID_SInternetSecurityManager, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
            if (FAILED(hrTmp))
            {
                hrTmp = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
            }
            if (SUCCEEDED(hrTmp))
            {
                ASSERT(pSecMgr);
                DWORD dwZoneID = URLZONE_UNTRUSTED;
                if (SUCCEEDED(pSecMgr->MapUrlToZone(bstrDocUrl, &dwZoneID, 0)))
                {
                    if (dwZoneID == URLZONE_LOCAL_MACHINE)
                        hr = S_OK;
                }
                if (hr != S_OK && bstrReqUrl)
                {
                    BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
                    DWORD cbReqSid = ARRAYSIZE(reqSid);
                    DWORD cbDocSid = ARRAYSIZE(docSid);

                    if (   SUCCEEDED(pSecMgr->GetSecurityId(bstrReqUrl, reqSid, &cbReqSid, 0))
                        && SUCCEEDED(pSecMgr->GetSecurityId(bstrDocUrl, docSid, &cbDocSid, 0))
                        && (cbReqSid == cbDocSid)
                        && (memcmp(reqSid, docSid, cbReqSid) == 0))
                    {

                        hr = S_OK;
                    }
                }
                pSecMgr->Release();
            }
            SysFreeString(bstrDocUrl);
        }
        pHtmlDoc->Release();
    }
    else
    {
        //  If we don't have an IHTMLDocument2 we aren't running in a browser that supports
        //  our OM.  We shouldn't block in this case since we could potentially
        //  get here from other hosts (VB, WHS, etc.).
        hr = S_FALSE;
    }

    return hr;
}

// This function checks to see if a navigation is happening from either internet
// or restricted url to LOCAL_MACHINE.
BOOL CanNavigateToUrlWithLocalMachineCheck(IUnknown *punkSite, BSTR pchurltarget)
{
    BOOL    bCanNavigate = FALSE;

    // Get the DochostUI flags for the site.
    IDocHostUIHandler *pIDocHostUI;
    if (SUCCEEDED(punkSite->QueryInterface(IID_PPV_ARG(IDocHostUIHandler, &pIDocHostUI))))
    {
        DOCHOSTUIINFO   dhInfo;
        if (SUCCEEDED(pIDocHostUI->GetHostInfo(&dhInfo)))
        {
            if (!(dhInfo.dwFlags & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
                bCanNavigate = TRUE;
        }
        pIDocHostUI->Release();
    }

    // If the DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK is set or if we failed to
    // get the flags, do a check to see if the zone is elevated to local machine.
    if (!bCanNavigate)
    {
        // Get the site's url.
        IHTMLDocument2 *pHtmlDoc;
        if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR pchurlsource;
            if (SUCCEEDED(pHtmlDoc->get_URL(&pchurlsource)))
            {
                IInternetSecurityManager *pSecMgr;
                if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SInternetSecurityManager,
                                                    IID_PPV_ARG(IInternetSecurityManager, &pSecMgr))) ||
                    SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                            IID_PPV_ARG(IInternetSecurityManager, &pSecMgr))))
                {
                    DWORD   dwZoneIDSource  = URLZONE_UNTRUSTED;
                    DWORD   dwZoneIDTarget  = URLZONE_LOCAL_MACHINE;
                    DWORD   dwFlags         = PUAF_DEFAULT;

                    // Get zone of the source url.
                    if (!pchurlsource || IsSpecialUrl(pchurlsource))
                    {
                        // Treat special Urls as restricted.
                        dwZoneIDSource = URLZONE_UNTRUSTED;
                    }
                    else if (!SUCCEEDED(pSecMgr->MapUrlToZone(pchurlsource, &dwZoneIDSource, 0)))
                    {
                        // If MapUrlToZone fails, treat the url as restricted.
                        dwZoneIDSource = URLZONE_UNTRUSTED;
                    }

                    // Get zone of the target url
                    if (!SUCCEEDED(pSecMgr->MapUrlToZone(pchurltarget, &dwZoneIDTarget, 0)))
                    {
                        // If MapUrlToZone fails, treat the url as MyComputer.  This is safe.
                        dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
                    }

                    // Check if there is a zone elevation.
                    if ((dwZoneIDSource != URLZONE_INTERNET &&
                        dwZoneIDSource != URLZONE_UNTRUSTED) ||
                        dwZoneIDTarget != URLZONE_LOCAL_MACHINE)
                    {
                        // There is no zone elevation.
                        bCanNavigate = TRUE;
                    }
                    pSecMgr->Release();
                }
                SysFreeString(pchurlsource);
            }
            pHtmlDoc->Release();
        }
    }
    return bCanNavigate;
}

STDMETHODIMP CShellUIHelper::IsSubscribed(BSTR bstrURL, VARIANT_BOOL* pBool)
{
    HRESULT hr;

    if (!bstrURL || !pBool)
    {
        return E_INVALIDARG;
    }

    hr = ZoneCheck(_punkSite, bstrURL);

    if (SUCCEEDED(hr))
    {
        ISubscriptionMgr *pSubscriptionMgr;

        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(ISubscriptionMgr, &pSubscriptionMgr));
        if (SUCCEEDED(hr))
        {
            ASSERT(pSubscriptionMgr);

            BOOL tmpBool;
            
            hr = pSubscriptionMgr->IsSubscribed(bstrURL, &tmpBool);
            *pBool = tmpBool ? VARIANT_TRUE : VARIANT_FALSE;
            
            pSubscriptionMgr->Release();
        }
    }

    return hr;
}

/****************************************************************************
 *
 *  AddDesktopComponentA - Adds a component to the desktop
 *
 *  ENTRY:
 *      hwnd - the parent for all UI
 *      pszUrlA - the URL of the component
 *      iCompType - one of COMP_TYPE_*
 *      iLeft, iTop, iWidth, iHeight - dimensions of the component
 *      dwFlags - additional flags
 *
 *  RETURNS:
 *      TRUE on success
 *      
 ****************************************************************************/
BOOL AddDesktopComponentW(HWND hwnd, LPCWSTR pszUrl, int iCompType,
                                    int iLeft, int iTop, int iWidth, int iHeight,
                                    DWORD dwFlags)
{
    COMPONENT Comp;
    BOOL    fRet = FALSE;
    HRESULT hres;

    Comp.dwSize = sizeof(Comp);

    //
    // Build the pcomp structure.
    //
    Comp.dwID = -1;
    Comp.iComponentType = iCompType;
    Comp.fChecked = TRUE;
    Comp.fDirty = FALSE;
    Comp.fNoScroll = FALSE;
    Comp.dwSize = SIZEOF(Comp);
    Comp.cpPos.dwSize = SIZEOF(COMPPOS);
    Comp.cpPos.iLeft = iLeft;
    Comp.cpPos.iTop = iTop;
    Comp.cpPos.dwWidth = iWidth;
    Comp.cpPos.dwHeight = iHeight;
    Comp.cpPos.izIndex = COMPONENT_TOP;
    Comp.cpPos.fCanResize = TRUE;
    Comp.cpPos.fCanResizeX = TRUE;
    Comp.cpPos.fCanResizeY = TRUE;
    Comp.cpPos.iPreferredLeftPercent = 0;
    Comp.cpPos.iPreferredTopPercent = 0;
    StrCpyNW(Comp.wszSource, pszUrl, ARRAYSIZE(Comp.wszSource));
    StrCpyNW(Comp.wszSubscribedURL, pszUrl, ARRAYSIZE(Comp.wszSubscribedURL));
    StrCpyNW(Comp.wszFriendlyName, pszUrl, ARRAYSIZE(Comp.wszFriendlyName));
    Comp.dwCurItemState = IS_NORMAL;

    IActiveDesktop * piad;

    //
    // Add it to the system.
    //
    hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &piad));
    if (SUCCEEDED(hres))
    {
        dwFlags |= DTI_ADDUI_POSITIONITEM;
        piad->AddDesktopItemWithUI(hwnd, &Comp, dwFlags);
        piad->Release();
        fRet = TRUE;
    } 

    return fRet;
}

//------------------------------------------------------------------------

STDMETHODIMP CShellUIHelper::AddDesktopComponent(BSTR strURL, BSTR strType, 
            /* [optional, in] */ VARIANT *Left,
            /* [optional, in] */ VARIANT *Top,
            /* [optional, in] */ VARIANT *Width,
            /* [optional, in] */ VARIANT *Height)
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    HRESULT hres;
    int iType;

    if (StrCmpIW(strType, L"image")==0) 
    {
        iType = COMP_TYPE_PICTURE;
    } 
    else if (StrCmpIW(strType, L"website")==0) 
    {
        iType = COMP_TYPE_WEBSITE;
    }
    else
    {
        iType = 0;
    }

    if (iType) 
    {
        AddDesktopComponentW(_GetOwnerWindow(), strURL, iType,
                             OptionalVariantToInt(Left, -1),
                             OptionalVariantToInt(Top, -1),
                             OptionalVariantToInt(Width, -1),
                             OptionalVariantToInt(Height, -1),
                             DTI_ADDUI_DISPSUBWIZARD);
        hres = S_OK;
    }
    else 
    {
        hres = E_INVALIDARG;
    }
    return hres;
#else // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

return E_INVALIDARG;

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
}
void RemoveDefaultWallpaper();
STDMETHODIMP CShellUIHelper::ResetFirstBootMode()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    if (MLShellMessageBox(
                        _GetOwnerWindow(),
                        MAKEINTRESOURCE(IDS_CONFIRM_RESETFLAG),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_YESNO | MB_ICONQUESTION) == IDYES)
    {
        RemoveDefaultWallpaper();
        return S_OK;
    }

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_FALSE;
}

// Little helper function used to change the safemode state
void SetSafeMode(DWORD dwFlags)
{
    IActiveDesktopP * piadp;

    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktopP, &piadp));
    if (SUCCEEDED(hres))
    {
        piadp->SetSafeMode(dwFlags);
        piadp->Release();
    }
}

STDMETHODIMP CShellUIHelper::ResetSafeMode()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    if ((ZoneCheck(_punkSite, NULL) == S_OK) || (MLShellMessageBox(
                       _GetOwnerWindow(),
                       MAKEINTRESOURCE(IDS_CONFIRM_RESET_SAFEMODE),
                       MAKEINTRESOURCE(IDS_TITLE),
                       MB_YESNO | MB_ICONQUESTION) == IDYES))
    {
        SetSafeMode(SSM_CLEAR | SSM_REFRESH);
        return S_OK;
    }

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_FALSE;
}

STDMETHODIMP CShellUIHelper::RefreshOfflineDesktop()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    IADesktopP2 * piad;

    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADesktopP2, &piad));
    if (SUCCEEDED(hres))
    {
        piad->UpdateAllDesktopSubscriptions();
        piad->Release();
    }
#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_OK;
}

STDMETHODIMP CShellUIHelper::GetTypeInfoCount(UINT * pctinfo)
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CShellUIHelper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CShellUIHelper::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, 
                                      UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    HRESULT hr = E_FAIL;

    //  First let our host get a crack at this method
    IDispatch *pDisp = GetExternalDispatch();

    if (pDisp)
    {
        hr = pDisp->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        if (SUCCEEDED(hr))
        {
            if (rgdispid[0] > 0)
            {
                //  Offset there dispid
                rgdispid[0] += DISPID_SHELLUIHELPERLAST;
            }
        }
    }

    if (FAILED(hr))
    {
        //  Our host didn't support it so we'll see if it's one of ours.
        hr = CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }

    return hr;
}

HRESULT CShellUIHelper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS *pdispparams, VARIANT * pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    
    if ((dispidMember > 0) && (dispidMember <= DISPID_SHELLUIHELPERLAST))
    {
        hr = CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, 
                                   pvarResult, pexcepinfo, puArgErr);
    }
    else if (_fWaitingToFindText && (dispidMember == DISPID_DOCUMENTCOMPLETE))
    {
        ASSERT(pdispparams->rgvarg[1].vt == VT_DISPATCH);

        _fWaitingToFindText = FALSE;
        hr = _DoFindOnPage(pdispparams->rgvarg[1].pdispVal);
    }
    else
    {
        IDispatch *pDisp = GetExternalDispatch();
        if (pDisp)
        {
            if (dispidMember > 0)
            {
                //  Fixup the offset we added in GetIDsOfNames
                dispidMember -= DISPID_SHELLUIHELPERLAST;
            }
            hr = pDisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, 
                                        pvarResult, pexcepinfo, puArgErr);
        }
    }

    return hr;                                   
}

STDMETHODIMP CShellUIHelper::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = E_FAIL;
    LCID lcid = GetSystemDefaultLCID();

    //  First let our host get a crack at this method via IDispatchEx or IDispatch
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetDispID(bstrName, grfdex, pid);
    }
    else if (_pExternalDisp)
    {
        hr = _pExternalDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, lcid, pid);
    }

    if (SUCCEEDED(hr))
    {
        if (*pid > 0)
        {
            *pid += DISPID_SHELLUIHELPERLAST;
        }
    }
    else
    {
        //  Our host didn't support it so we'll see if it's one of ours.
        hr = CImpIDispatch::GetIDsOfNames(IID_NULL, &bstrName, 1, lcid, pid);
    }

    return hr;
}

STDMETHODIMP CShellUIHelper::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                                 VARIANT *pvarRes, EXCEPINFO *pei, 
                                 IServiceProvider *pspCaller)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    UINT ArgErr;    //  inetsdk says this isn't used here

    //  First see if it's ours
    if ((id > 0) && (id <= DISPID_SHELLUIHELPERLAST))
    {
        hr = CImpIDispatch::Invoke(id, IID_NULL, lcid, wFlags, pdp, 
                                   pvarRes, pei, &ArgErr);
    }
    else
    {
        if (id > 0)
        {
            id -= DISPID_SHELLUIHELPERLAST;
        }
        //  otherwise try external IDispatchEx 
        if (_pExternalDispEx)
        {
            hr = _pExternalDispEx->InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
        }
        //  finally try the external IDispatch
        else if (_pExternalDisp)
        {
            hr = _pExternalDisp->Invoke(id, IID_NULL, lcid, wFlags, pdp, 
                                        pvarRes, pei, &ArgErr);
        }
    }
    
    return hr;
}

STDMETHODIMP CShellUIHelper::DeleteMemberByName(BSTR bstr, DWORD grfdex)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->DeleteMemberByName(bstr, grfdex);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::DeleteMemberByDispID(DISPID id)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->DeleteMemberByDispID(id);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetMemberProperties(id, grfdexFetch, pgrfdex);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetMemberName(id, pbstrName);
    }

    return hr;
}

STDMETHODIMP CShellUIHelper::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetNextDispID(grfdex, id, pid);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetNameSpaceParent(ppunk);
    }

    return hr;
}

int GetIntFromReg(HKEY    hKey,
                  LPCTSTR lpszSubkey,
                  LPCTSTR lpszNameValue,
                  int     iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = SIZEOF(szValue);
    int iRetValue = iDefault;
    DWORD dwType;

    if ((SHGetValue(hKey, lpszSubkey, lpszNameValue, &dwType,(LPBYTE)szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToInt(szValue);
        }
    }

    return iRetValue;
}

void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme)
{
    TCHAR szSubkey[MAX_PATH];
    DWORD dwDataLength = sizeof(szSubkey) - 2 * sizeof(TCHAR);
    DWORD dwType;

    StrCpyN(szSubkey, TEXT("\\"), ARRAYSIZE(szSubkey));
    if (lpszScheme)
        StrCatBuff(szSubkey, lpszScheme, ARRAYSIZE(szSubkey));
    else
        SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY, &dwType,
            (LPBYTE)(szSubkey) + sizeof(TCHAR), &dwDataLength);
    if (szSubkey[1])
        StrCatBuff(szSubkey, TEXT("\\"), ARRAYSIZE(szSubkey));

    wnsprintf(lpszResult, cchResult, lpszKey, szSubkey);
}

#define c_szWallpaper  REG_VAL_GENERAL_WALLPAPER
void RemoveDefaultWallpaper()
{
    // Read the Wallpaper from the Old location.
    TCHAR   szOldWallpaper[MAX_PATH];
    DWORD dwType;
    DWORD dwSize = SIZEOF(szOldWallpaper);
    if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, c_szWallpaper, &dwType, szOldWallpaper, &dwSize) != ERROR_SUCCESS)
        szOldWallpaper[0] = TEXT('\0');

    // Read the wallpaper style
    DWORD dwWallpaperStyle = GetIntFromReg(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, REG_VAL_GENERAL_TILEWALLPAPER, WPSTYLE_TILE);

    TCHAR szDeskcomp[MAX_PATH];
    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);

    // Set the old wallpaper into the new location.
    SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
        c_szWallpaper, REG_SZ, (LPBYTE)szOldWallpaper, SIZEOF(szOldWallpaper));


//  98/08/14 vtan: This used to write out a REG_DWORD. It should've
//  written out a REG_SZ.

    TCHAR   szWallpaperStyle[2];

    (TCHAR*)StrCpyN(szWallpaperStyle, TEXT("0"), ARRAYSIZE(szWallpaperStyle));
    szWallpaperStyle[0] += static_cast<TCHAR>(dwWallpaperStyle & WPSTYLE_MAX);

    // Set the old wallpaper style into the new location.
    SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
        REG_VAL_GENERAL_TILEWALLPAPER, REG_SZ, (LPBYTE)szWallpaperStyle, SIZEOF(szWallpaperStyle));

//  98/08/14 vtan #196226: Moved the create instance of IActiveDesktop
//  to here from entry of the function. When the instance is created the
//  registry information is cached in the member variable data. The
//  registry information for the wallpaper is then changed behind the
//  object instance and ApplyChanges() is called on STALE information.
//  By deferring the object instantiation to after the registry changes
//  the changes are applied correctly.

    IActiveDesktop * piad;
    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &piad));
    if (SUCCEEDED(hres))
    {
        piad->ApplyChanges(AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH);
        piad->Release();
    }
}


HRESULT GetTargetFrame(IUnknown* _punkSite, BSTR bstrFrame, IWebBrowser2** ppunkTargetFrame)
{
    IWebBrowser2 * pwb2;
    HRESULT        hr = GetTopLevelBrowser(_punkSite, &pwb2);

    *ppunkTargetFrame = NULL;

    if (SUCCEEDED(hr))
    {
        ITargetFrame2 * pOurTargetFrame;
        IUnknown      * punkTargetFrame = NULL;

        // See if there is an existing frame with the specified target name
        hr = TargetQueryService(pwb2, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
        
        if (SUCCEEDED(hr))
        {
            hr = pOurTargetFrame->FindFrame(bstrFrame, FINDFRAME_JUSTTESTEXISTENCE, &punkTargetFrame);
            if (SUCCEEDED(hr) && punkTargetFrame) // SUCCEEDED with NULL punkTargetFrame implies bstrFrame is "_blank" (since we specified FINDFRAME_JUSTTESTEXISTENCE)
            {
                // yes, we found a frame with that name.  QI for the automation
                // interface on that frame.
                hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowser2, ppunkTargetFrame));
                punkTargetFrame->Release();
            }
            pOurTargetFrame->Release();
        }
        pwb2->Release();
    }
    return hr;
}

// NavigateAndFind
// 1. navigate the specified target frame to the specified url
// 2. set _fWaitingToFindText so that on DocumentComplete, 
//    mimic the find dialog and select/highlight the specified text
STDMETHODIMP CShellUIHelper::NavigateAndFind(BSTR URL, BSTR strQuery, VARIANT* varTargetFrame)
{
    HRESULT        hr;
    IWebBrowser2 * pwb2         = NULL;
    BSTR           bstrFrameSrc = NULL;

    if (_bstrQuery)
        SysFreeString(_bstrQuery);
    _bstrQuery = SysAllocString(strQuery);
     
    hr = IsSpecialUrl(URL) ? E_FAIL: S_OK;
        
    // Security:  Don't allow javascript on one web page
    //            to automatically execute in the zone
    //            of the target frame URL.
    if (SUCCEEDED(hr) && varTargetFrame && (varTargetFrame->vt == VT_BSTR) && varTargetFrame->bstrVal)
    {
        hr = GetTargetFrame(_punkSite, varTargetFrame->bstrVal, &pwb2); // GetTargetFrame can return NULL pwb2 on S_OK (when bstrVal is "_blank")
        if (SUCCEEDED(hr) && pwb2)
        {
            hr = pwb2->get_LocationURL(&bstrFrameSrc);
            
            if (SUCCEEDED(hr))
            {
                IHTMLDocument2 *pHtmlDoc;
                if (SUCCEEDED(GetHTMLDoc2(_punkSite, &pHtmlDoc)))
                {
                    BSTR bstrDocUrl;
                    if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
                    {
                        hr = AccessAllowed(_punkSite, bstrDocUrl, bstrFrameSrc) ? S_OK : E_ACCESSDENIED;

                        if(!IsSpecialUrl(URL) && hr == E_ACCESSDENIED)
                        {
                            // For non-script navigates check policy
                            DWORD dwPolicy = 0;
                            DWORD dwContext = 0;
                            if( SUCCEEDED(ZoneCheckUrlEx(bstrDocUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, 
                                    sizeof(dwContext), URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL)) && 
                                    GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW) 
                            {
                                hr = S_OK;
                            }
                        }
                        SysFreeString(bstrDocUrl);
                    }
                    pHtmlDoc->Release();
                }
                SysFreeString(bstrFrameSrc);
            }
            pwb2->Release();
            pwb2 = NULL;
        }
    }

    // Don't allow access to MyComputer zone from non-MyComputer zone.
    if (SUCCEEDED(hr) && !CanNavigateToUrlWithLocalMachineCheck(_punkSite, URL))
        hr = E_ACCESSDENIED;

    if (SUCCEEDED(hr))
        hr = GetTopLevelBrowser(_punkSite, &pwb2);

    if (SUCCEEDED(hr))
    {
        _fWaitingToFindText = TRUE;
        pwb2->Navigate(URL, PVAREMPTY, varTargetFrame, PVAREMPTY, PVAREMPTY);
        pwb2->Release();
    }

    //script runtime error protection
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}


// AutoScan
//
// Takes the search string and tries to navigate to www.%s.com, www.%s.org etc.  If all of
// these fail then we navigate to pvarTargetFrame.
//
STDMETHODIMP CShellUIHelper::AutoScan
(
    BSTR strSearch,             // String to autoscan
    BSTR strFailureUrl,         // url to display is search fails
    VARIANT* pvarTargetFrame    // [optional] target frame
)
{
    HRESULT hr = E_FAIL;
    IWebBrowser2* pwb2;

    // Don't bother autoscanning if there are extended characters in the search string
    if (!HasExtendedChar(strSearch))
    {
        //first, check to see if the url is trying to spoof /1 security
        hr = IsSpecialUrl(strFailureUrl) ? E_FAIL : S_OK;

        if (SUCCEEDED(hr))
        {
            LPWSTR pszTarget = (pvarTargetFrame && pvarTargetFrame->vt == VT_BSTR && pvarTargetFrame->bstrVal) ?
                                    pvarTargetFrame->bstrVal : L"_main";

            hr = GetTargetFrame(_punkSite, pszTarget, &pwb2); // GetTargetFrame can return NULL pwb2 on S_OK (when bstrVal is "_blank")
            if (!pwb2)
                hr = E_FAIL;
            if (SUCCEEDED(hr))
            {
                BSTR bstrFrameSrc = NULL;               
                
                hr = pwb2->get_LocationURL(&bstrFrameSrc);
                
                if (SUCCEEDED(hr))
                {
                    IHTMLDocument2 *pHtmlDoc;
                    if (SUCCEEDED(GetHTMLDoc2(_punkSite, &pHtmlDoc)))
                    {
                        BSTR bstrDocUrl;
                        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
                        {
                            hr = AccessAllowed(_punkSite, bstrDocUrl, bstrFrameSrc) ? S_OK : E_ACCESSDENIED;
                            SysFreeString(bstrDocUrl);
                        }
                        pHtmlDoc->Release();
                    }
                    SysFreeString(bstrFrameSrc);
                }

                // Don't allow access to MyComputer zone from non-MyComputer zone.
                if (SUCCEEDED(hr) && !CanNavigateToUrlWithLocalMachineCheck(_punkSite, strFailureUrl))
                    hr = E_ACCESSDENIED;

                if (SUCCEEDED(hr))
                {
                    // We don't want to navigate to strSearch.  Start searching using the 
                    // first autoscan substitution.
                    WCHAR szFormat[MAX_PATH];
                    WCHAR szUrl[MAX_URL_STRING];
                    if (GetSearchFormatString(1, szFormat, sizeof(szFormat)) != ERROR_SUCCESS)
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        wnsprintf(szUrl, ARRAYSIZE(szUrl), szFormat, strSearch);
                        BSTRBLOB bstrBlob;
                        bstrBlob.cbSize = lstrlenW(szUrl) * sizeof(WCHAR);
                        bstrBlob.pData = (BYTE*)szUrl;
                        BSTR bstrUrl = (BSTR)bstrBlob.pData;
                        
                        // Save the original search string for autoscanning.  Normally
                        // this come from the addressbar, but in our case we store it as
                        // a property
                        VARIANT v;
                        VariantInit (&v);
                        
                        v.vt = VT_BSTR;
                        v.bstrVal = strSearch;
                        pwb2->PutProperty((BSTR)s_sstrSearch.wsz, v);
                        
                        // Save the error page in case the scan fails
                        v.vt = VT_BSTR;
                        v.bstrVal = strFailureUrl;
                        pwb2->PutProperty((BSTR)s_sstrFailureUrl.wsz, v);
                        
                        // Navigate with autosearch enabled
                        VARIANT vFlags;
                        vFlags.vt = VT_I4;
                        vFlags.lVal = navAllowAutosearch;
                        
                        pwb2->Navigate(bstrUrl, &vFlags, pvarTargetFrame, PVAREMPTY, PVAREMPTY);
                    }
                }
                pwb2->Release();
            }
        }
    }

    //script runtime error protection
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

typedef HRESULT (*PFNSHOWBROWSERUI)(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut);

typedef void (*PFNOPENLANGUAGEDIALOG)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

HRESULT ShowLanguageDialog(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hInstInetcpl = LoadLibrary(TEXT("inetcpl.cpl"));

    if (hInstInetcpl)
    {
        
        PFNOPENLANGUAGEDIALOG pfnOpenLanguageDialog = 
            (PFNOPENLANGUAGEDIALOG)GetProcAddress( hInstInetcpl, "OpenLanguageDialog" );

        if (pfnOpenLanguageDialog)
        {
            pfnOpenLanguageDialog(hwnd, NULL, NULL, SW_SHOW);
            hr = S_OK;
        }

        FreeLibrary(hInstInetcpl);
    }

    return hr;
}

HRESULT ShowOrganizeFavorites(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    return DoOrganizeFavDlgW(hwnd, NULL) ? S_OK : E_FAIL;
}

HRESULT ShowPrivacySettings(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    LaunchPrivacySettings(hwnd);

    return S_OK;
}

HRESULT ShowProgramAccessAndDefaults(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr;

    const WCHAR c_szControlExe[] = L"control.exe";
    WCHAR szControlPath[MAX_PATH];

    UINT nLen = GetSystemDirectory(szControlPath, ARRAYSIZE(szControlPath));

    //  This accounts for needing a backslash after the sysdir
    if ((nLen + ARRAYSIZE(c_szControlExe)) < ARRAYSIZE(szControlPath))
    {
        PathAppend(szControlPath, c_szControlExe);

        HINSTANCE hInst = ShellExecute(NULL, NULL, szControlPath, L"appwiz.cpl,,3", NULL, SW_SHOWNORMAL);

        if (hInst > (HINSTANCE)HINSTANCE_ERROR)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(PtrToInt(hInst));
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

struct BROWSERUI_MAP
{
    LPWSTR pwszName;
    PFNSHOWBROWSERUI pfnShowBrowserUI;
};

const BROWSERUI_MAP s_browserUIMap[] =
{
    { L"LanguageDialog",            ShowLanguageDialog              },
    { L"OrganizeFavorites",         ShowOrganizeFavorites           },
    { L"PrivacySettings",           ShowPrivacySettings             },
    { L"ProgramAccessAndDefaults",  ShowProgramAccessAndDefaults    }
};

STDMETHODIMP CShellUIHelper::ShowBrowserUI(BSTR bstrName, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr = E_FAIL;

    for (int i = 0; i < ARRAYSIZE(s_browserUIMap); i++)
    {
        if (pvarOut)
        {
            VariantInit(pvarOut);
        }
        
        if (0 == StrCmpIW(s_browserUIMap[i].pwszName, bstrName))
        {
            hr = s_browserUIMap[i].pfnShowBrowserUI(_punkSite, _GetOwnerWindow(), pvarIn, pvarOut);
        }
    }

    return S_OK == hr ? S_OK : S_FALSE;
}


// the find dialog does the following:
// 
// rng = document.body.createTextRange();
// if (rng.findText("Find this text"))
//     rng.select();
STDMETHODIMP CShellUIHelper::_DoFindOnPage(IDispatch* pdisp)
{
    HRESULT           hr;
    IWebBrowser2*     pwb2;
    IDispatch*        pdispDocument;
    IHTMLDocument2*   pDocument;
    IHTMLElement*     pBody;
    IHTMLBodyElement* pBodyElement;
    IHTMLTxtRange*    pRange;

    ASSERT(pdisp);
    if (!pdisp)
        return E_FAIL;

    hr = pdisp->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pwb2));

    if (SUCCEEDED(hr))
    {
        hr = pwb2->get_Document(&pdispDocument);

        if (SUCCEEDED(hr) && (NULL != pdispDocument))
        {
            hr = pdispDocument->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDocument));
            
            if (SUCCEEDED(hr))
            {
                hr = pDocument->get_body(&pBody);
                
                if (SUCCEEDED(hr) && (NULL != pBody))
                {
                    hr = pBody->QueryInterface(IID_PPV_ARG(IHTMLBodyElement, &pBodyElement));

                    if (SUCCEEDED(hr))
                    {
                        hr = pBodyElement->createTextRange(&pRange);

                        if (SUCCEEDED(hr) && (NULL != pRange))
                        {
                            VARIANT_BOOL vbfFoundText;
                            
                            hr = pRange->findText(_bstrQuery, 1000000, 0, &vbfFoundText);

                            if (SUCCEEDED(hr) && (vbfFoundText == VARIANT_TRUE))
                            {
                                hr = pRange->select();
                            }
                            
                            pRange->Release();
                        }
                        pBodyElement->Release();
                    }
                    pBody->Release();
                }
                pDocument->Release();
            }
            pdispDocument->Release();
        }
        pwb2->Release();
    }
    return hr;
}

//
// Launch the favorites import/export wizard
//
STDMETHODIMP CShellUIHelper::ImportExportFavorites(VARIANT_BOOL fImport, BSTR strImpExpPath) 
{
    //don't allow to import/export to folders other than Favorites from OM
    DoImportOrExport(fImport==VARIANT_TRUE, NULL, (LPCWSTR)strImpExpPath, TRUE);
    return S_OK;
}

//
// Save the form data via intelliforms
//
STDMETHODIMP CShellUIHelper::AutoCompleteSaveForm(VARIANT *Form)
{
    HRESULT hrRet = S_FALSE;

    IHTMLDocument2 *pDoc2=NULL;

    GetHTMLDoc2(_punkSite, &pDoc2);
    
    if (pDoc2)
    {
        hrRet = IntelliFormsSaveForm(pDoc2, Form);
        pDoc2->Release();
    }

    return hrRet;
}

//
// Attach intelliforms to this document
//
STDMETHODIMP CShellUIHelper::AutoCompleteAttach(VARIANT *Reserved)
{
    HRESULT hr=E_FAIL;

    if (_pvIntelliForms == NULL)
    {
        IHTMLDocument2 *pDoc2=NULL;

        GetHTMLDoc2(_punkSite, &pDoc2);

        if (pDoc2)
        {
            hr = S_OK;
            AttachIntelliForms(NULL, _GetOwnerWindow(), pDoc2, &_pvIntelliForms);
            pDoc2->Release();
        }
    }

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shvocx.h ===
#ifndef __SHVOCX_H__
#define __SHVOCX_H__

#include "shocx.h"
#include "basesb.h"
#include "sfview.h"
#include "util.h" // for BSTR functions
#include "cobjsafe.h"
#include "ipstg.h"
#include "fldset.h"

class CWebBrowserOC;

#define CS_BACK 0x0001
#define CS_FORE 0x0002

#define AUTOSIZE_OFF            0x00000000L
#define AUTOSIZE_ON             0x00000001L

#define AUTOSIZE_PERCENTWIDTH   0x00000002L
#define AUTOSIZE_FULLSIZE       0x00000004L

#define VB_CLASSNAME_LENGTH 20            

//
// NOTES:
//
//  A CWebBrowserSB object is ALWAYS paired with CWebBrowserOC, and bahaves
// as a "ShellExplorer" OC together. CWebBrowserOC exports OLE control
// interfaces and an OLE automation interface (IWebBrowser) to the
// container. CWebBrowserSB exports IShellBrowser interface and a few other
// interfaces to the containee (IShellView object and DocObject).
//
//  It's important to know that those objects have pointers (not interface
// pointers but explicit object pointers) to each other. In order to avoid
// a circular reference, we don't AddRef to the pointer to CWebBrowserOC
// (_psvo).
//
class CWebBrowserSB : public CBASEBROWSER
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() { return CBASEBROWSER::AddRef(); };
    STDMETHODIMP_(ULONG) Release() { return CBASEBROWSER::Release(); };

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP EnableModelessSB(BOOL fEnable);
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);

    // IBrowserService
    STDMETHODIMP GetParentSite(struct IOleInPlaceSite** ppipsite);
    STDMETHODIMP GetOleObject(struct IOleObject** ppobjv);
    STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    STDMETHODIMP ReleaseShellView();
    STDMETHODIMP ActivatePendingView();
    STDMETHODIMP SetTopBrowser();
    STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { /* we modify base directly */ return S_OK; };
    STDMETHODIMP _SwitchActivationNow();

    // IShellBrowser
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    HRESULT QueryServiceItsOwn(REFGUID guidService, REFIID riid, void **ppvObj)
        { return CBASEBROWSER::QueryService(guidService, riid, ppvObj); }

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CWebBrowserSB(IUnknown* pauto, CWebBrowserOC* psvo);

    void ReleaseShellExplorer(void) { _psvo = NULL; } // NOTE: Note that we haven't AddRef'ed it.
    
    IShellView* GetShellView() { return _bbd._psv;};

    // Load/Save to be called by CWebBrowserOC's IPS::Save
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm /*, BOOL fClearDirty */);

protected:

    ~CWebBrowserSB();

    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _ViewChange(DWORD dwAspect, LONG lindex);

    //ViewStateStream related
    STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // se DIRECTION_ flags below
    HRESULT _EnableModeless(BOOL fEnable, BOOL fDirection);
    HRESULT _TranslateAccelerator(LPMSG lpmsg, WORD wID, BOOL fDirection);
    HRESULT _IncludeByPidl(struct IShellView *psv, LPCITEMIDLIST pidl);
    HRESULT _IncludeByName(struct IShellView *psv, LPCTSTR pszInclude, LPCTSTR pszExclude);
    HRESULT _QueryServiceParent(REFGUID guidService, REFIID riid, void **ppvObj);

    BOOL    _IsDesktopOC(void);

    virtual BOOL    _HeyMoe_IsWiseGuy(void);


    friend CWebBrowserOC;
    CWebBrowserOC* _psvo;

    long _cbScriptNesting;
};


#define DIRECTION_FORWARD_TO_CHILD  FALSE
#define DIRECTION_FORWARD_TO_PARENT TRUE

class CWebBrowserOC : public CShellOcx
                    , public IWebBrowser2      // wrapped _pauto
                    , public CImpIExpDispSupport   // wrapped _pauto
                    , public IExpDispSupportOC
                    , public IPersistString
                    , public IOleCommandTarget
                    , public CObjectSafety
                    , public ITargetEmbedding
                    , public CImpIPersistStorage
                    , public IPersistHistory
{
public:
    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) { return CShellOcx::QueryInterface(riid, ppvObj); }
    STDMETHOD_(ULONG, AddRef)() { return CShellOcx::AddRef(); }
    STDMETHOD_(ULONG, Release)() { return CShellOcx::Release(); }

    // IDispatch (we multiply inherit from IDispatch, disambiguate here)
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return CShellOcx::GetTypeInfoCount(pctinfo); }
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CShellOcx::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CShellOcx::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgdispid); }
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IPersistXXX disambiguate here
    STDMETHODIMP IsDirty(void) {return CShellOcx::IsDirty();}

    // IOleCommandTarget
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHOD(Exec)(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IObjectSafety
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

    // IWebBrowser
    STDMETHOD(GoBack)();
    STDMETHOD(GoForward)();
    STDMETHOD(GoHome)();
    STDMETHOD(GoSearch)();
    STDMETHOD(Navigate)(BSTR URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers);
    STDMETHOD(Refresh)();
    STDMETHOD(Refresh2)(VARIANT *Level);
    STDMETHOD(Stop)();
    STDMETHOD(get_Application)(IDispatch **ppDisp);
    STDMETHOD(get_Parent)(IDispatch **ppDisp);
    STDMETHOD(get_Container)(IDispatch **ppDisp);
    STDMETHOD(get_Document)(IDispatch **ppDisp);
    STDMETHOD(get_TopLevelContainer)(VARIANT_BOOL *pBool);
    STDMETHOD(get_Type)(BSTR * pbstrType);
    STDMETHOD(get_Left)(long * pl);
    STDMETHOD(put_Left)(long Left);
    STDMETHOD(get_Top)(long * pl);
    STDMETHOD(put_Top)(long Top);
    STDMETHOD(get_Width)(long * pl);
    STDMETHOD(put_Width)(long Width);
    STDMETHOD(get_Height)(long * pl);
    STDMETHOD(put_Height)(long Height);
    STDMETHOD(get_LocationName)(BSTR * pbstrLocationName);
    STDMETHOD(get_LocationURL)(BSTR * pbstrLocationURL);
    STDMETHOD(get_Busy)(VARIANT_BOOL * pBool);

    /* IWebBrowserApp methods */
    STDMETHOD(Quit)(THIS);
    STDMETHOD(ClientToWindow)(THIS_ int FAR* pcx, int FAR* pcy);
    STDMETHOD(PutProperty)(THIS_ BSTR szProperty, VARIANT vtValue);
    STDMETHOD(GetProperty)(THIS_ BSTR szProperty, VARIANT FAR* pvtValue);
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName);
    STDMETHOD(get_HWND)(THIS_ LONG_PTR* pHWND);
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pbstrFullName);
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pbstrPath);
    STDMETHOD(get_FullScreen)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_FullScreen)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusBar)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_StatusBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusText)(THIS_ BSTR FAR* pbstr);
    STDMETHOD(put_StatusText)(THIS_ BSTR bstr);
    STDMETHOD(get_ToolBar)(THIS_ int FAR* pBool);
    STDMETHOD(put_ToolBar)(THIS_ int Value);
    STDMETHOD(get_MenuBar)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_MenuBar)(THIS_ VARIANT_BOOL Value);

    // IWebBrowser2 methods
    STDMETHOD(Navigate2)(THIS_ VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(ShowBrowserBar)(THIS_ VARIANT FAR* pvaClsid, VARIANT FAR* pvaShow, VARIANT FAR* pvaSize);
    STDMETHOD(QueryStatusWB)(THIS_ OLECMDID cmdID, OLECMDF FAR* pcmdf);
    STDMETHOD(ExecWB)(THIS_ OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT FAR* pvaIn, VARIANT FAR* pvaOut);
    STDMETHOD(get_ReadyState)(THIS_ READYSTATE FAR* plReadyState);
    STDMETHOD(get_Offline)(THIS_ VARIANT_BOOL FAR* pbOffline);
    STDMETHOD(put_Offline)(THIS_ VARIANT_BOOL bOffline);
    STDMETHOD(get_Silent)(THIS_ VARIANT_BOOL FAR* pbSilent);
    STDMETHOD(put_Silent)(THIS_ VARIANT_BOOL bSilent);
    STDMETHOD(get_RegisterAsBrowser)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsBrowser)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_RegisterAsDropTarget)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsDropTarget)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_TheaterMode)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_TheaterMode)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_AddressBar)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_AddressBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Resizable)(THIS_ VARIANT_BOOL FAR* Value) { return E_NOTIMPL; }
    STDMETHOD(put_Resizable)(THIS_ VARIANT_BOOL Value);

    // *** CImpIExpDispSupport override ***
    STDMETHODIMP OnTranslateAccelerator(MSG *pMsg,DWORD grfModifiers);
    STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    // *** IExpDispSupportOC ***
    STDMETHODIMP OnOnControlInfoChanged();
    STDMETHODIMP GetDoVerbMSG(MSG *pMsg);


    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID) { return CShellOcx::GetClassID(pClassID); }

    // IPersistString
    STDMETHOD(Initialize)(LPCWSTR pwszInit);

    // ITargetEmbedding
    STDMETHOD(GetTargetFrame)(ITargetFrame **ppTargetFrame);

    // IPersistStreamInit
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(InitNew)(void);

    // IPersistPropertyBag
    STDMETHOD(Load)(IPropertyBag *pBag, IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IOleObject
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP DoVerb(
        LONG iVerb,
        LPMSG lpmsg,
        IOleClientSite *pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);

    // IViewObject2
    STDMETHODIMP Draw(
        DWORD dwDrawAspect,
        LONG lindex,
        void *pvAspect,
        DVTARGETDEVICE *ptd,
        HDC hdcTargetDev,
        HDC hdcDraw,
        LPCRECTL lprcBounds,
        LPCRECTL lprcWBounds,
        BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
        ULONG_PTR dwContinue);

    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);

    virtual HRESULT STDMETHODCALLTYPE SetExtent( DWORD dwDrawAspect,
            SIZEL *psizel);
            
    // IOleControl
    STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
    STDMETHODIMP OnMnemonic(LPMSG pMsg);
    STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
    STDMETHODIMP FreezeEvents(BOOL bFreeze);

    // IOleInPlaceActiveObject
    virtual HRESULT __stdcall OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP EnableModeless(BOOL fEnable);

    // *** CShellOcx's CImpIConnectionPointContainer override ***
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);

    // *** IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);
    STDMETHODIMP SetPositionCookie(DWORD dwPositionCookie);
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie);

    // random public functions
    friend HRESULT CWebBrowserOC_SavePersistData(IStream *pstm, SIZE* psizeObj,
        FOLDERSETTINGS* pfs, IShellLinkA* plink, SHELLVIEWID* pvid,
        BOOL fOffline = FALSE, BOOL fSilent = FALSE,
        BOOL fRegisterAsBrowser = FALSE, BOOL fRegisterAsDropTarget = TRUE,
        BOOL fEmulateOldStream = FALSE, DWORD * pdwExtra = NULL);


protected:
    CWebBrowserOC(IUnknown* punkOuter, LPCOBJECTINFO poi);
    ~CWebBrowserOC();
    BOOL _InitializeOC(IUnknown* punkOuter);
    IUnknown* _GetInner() { return CShellOcx::_GetInner(); }
    friend HRESULT CWebBrowserOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    // Override private virtual function
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    virtual void _OnSetClientSite(void);
    virtual HRESULT _OnActivateChange(IOleClientSite* pActiveSite, UINT uState);
    virtual void _OnInPlaceActivate(void);
    virtual void _OnInPlaceDeactivate(void);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);

    // Private non-virtual
    LRESULT _OnPaintPrint(HDC hdcPrint);
    LRESULT _OnCreate(LPCREATESTRUCT lpcs);
    HRESULT _BrowseObject(LPCITEMIDLIST pidlBrowseTo);
    void    _InitDefault(void);
    void    _OnSetShellView(IShellView*);
    void    _OnReleaseShellView(void);
    BOOL    _GetViewInfo(SHELLVIEWID* pvid);
    void    _RegisterWindow();
    void    _UnregisterWindow();
    HRESULT _SetDownloadState(HRESULT hresRet, DWORD nCmdexecopt, VARIANTARG *pvarargIn);
    void    _OnLoaded(BOOL fUpdateBrowserReadyState);
    HMODULE _GetBrowseUI();
    BOOL    _HeyMoe_IsWiseGuy(void) {return _fHostedInImagineer;}
    void    _OnSetSecureLockIcon(int lock);
    BOOL    AccessAllowedToNamedFrame(VARIANT *varTargetFrameName);

    static LRESULT CALLBACK s_DVWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    IUnknown*       _pauto; // we aggregate this and pass it to the shellbrowser
    IWebBrowser2*   _pautoWB2;
    IExpDispSupport*_pautoEDS;

    BOOL            _fInit:1;               // TRUE iff we are initialized
    BOOL            _fEmulateOldStream:1;   // TRUE iff we emulate ie30 stream format
    BOOL            _fNavigateOnSetClientSite:1; // set when Loaded before SetClientSite
    BOOL            _fShouldRegisterAsBrowser:1; // TRUE iff OC should be registered in windows list
    BOOL            _fDidRegisterAsBrowser:1;    // TRUE iff registered in windows list
    BOOL            _fTopLevel:1;           // TRUE iff we're the topmost CBaseBrowser around
    BOOL            _fVisible:1;            // BETA1: bindable props of the OC that we can't
    BOOL            _fNoMenuBar:1;          //        call IEDisp's version of the props.
    BOOL            _fNoToolBar:1;          //        for beta2 we should let us call
    BOOL            _fNoStatusBar:1;        //        iedisp's version to get the events
    BOOL            _fFullScreen:1;         //        to fire and persistence correct.
    BOOL            _fTheaterMode:1;
    BOOL            _fNoAddressBar:1;
    BOOL            _fHostedInVB5:1;        // Our immediate container is the VB5 forms engine.
    BOOL            _fHostedInImagineer:1;  // 
    BOOL            _fIncrementedSessionCount:1;  // We incremented session count and need to decrement it
    BOOL            _fInsideInvokeCall;     // Currently processing an invoke call

    MSG             *_pmsgDoVerb;        // valid only when _fDoVerbMSGValid
    
    long            _cbCookie;              // our cookie for registering in windows list
    SIZE            _szIdeal;       // ideal size of view, based on _size.cx
    SIZE            _szNotify;      // last size we notified conainer

    FOLDERSETTINGS  _fs;            // FolderViewMode and FolderFlags

    // cached draw aspect incase we are not READSTATE_INTERACTIVE when we get SetExtent
    DWORD           _dwDrawAspect;
    
    friend CWebBrowserSB;
    CWebBrowserSB*      _psb;
    ITargetFramePriv*   _pTargetFramePriv;  // QueryService(IID_ITARGETFRAME2)

    IShellLinkA*        _plinkA;        // used in save/load code only

    IOleCommandTarget*  _pctContainer;  // container

    HGLOBAL             _hmemSB;        // Initializing stream

    CConnectionPoint    m_cpWB1Events;  // CShellOcx holds the WB2 event source
    LPMESSAGEFILTER     _lpMF;          // Pointer to message filter for cross-thread containers (e.g., AOL)

    HMODULE             _hBrowseUI;     // Handle for use in design mode brand drawing

    DWORD               _cPendingFreezeEvents;
};

#define IS_INITIALIZED if(!_fInit){TraceMsg(TF_WARNING,"shvocx: BOGUS CONTAINER calling when we haven't been initialized"); _InitDefault();}

#endif // __SHVOCX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\shvocx.cpp ===
#include "priv.h"

#include "sccls.h"
#include "comcat.h"
#include <hliface.h>
#include "shlguid.h"
#include "shvocx.h"
#include "winlist.h"
#include <mshtml.h>
#include "stdenum.h"
#include "iface.h"
#include "resource.h"
#include "msiehost.h"

#include <mluisupp.h>

#define SUPERCLASS CShellOcx

#define MIN_HEIGHT 80   // minimum height of a ShellFolderViewOC
#define MIN_WIDTH  80   // minimum width of a ShellFolderViewOC.
#define DEF_WIDTH  300  // default width when we cannot get sizing information
#define DEF_HEIGHT 150  // default height when we cannot get sizing information

#define IPSMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IPS::%s called", (psz))
#define IPSMSG2(psz, hres)      TraceMsg(TF_SHDCONTROL, "shv IPS::%s %x", (psz), hres)
#define IPSMSG3(psz, hres, x, y) TraceMsg(TF_SHDCONTROL,"shv IPS::%s %x %d (%d)", (psz), hres, x, y)
#define IOOMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IOO::%s called", (psz))
#define IOOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "shv IOO::%s called with (%d)", (psz), i)
#define IOOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "shv IOO::%s called with (%d, %d)", (psz), i, j)
#define IVOMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IVO::%s called", (psz))
#define IVOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "shv IVO::%s called with (%d)", (psz), i)
#define IVOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "shv IVO::%s called with (%d, %d)", (psz), i, j)
#define PROPMSG(psz)            TraceMsg(TF_SHDCONTROL, "shv %s", (psz))
#define PROPMSG2(psz, pstr)     TraceMsg(TF_SHDCONTROL, "shv %s with [%s]", (psz), pstr)
#define PROPMSG3(psz, hex)      TraceMsg(TF_SHDCONTROL, "shv %s with 0x%x", (psz), hex)
#define PRIVMSG(psz)            TraceMsg(TF_SHDCONTROL, "shv %s", (psz))
#define CVOCBMSG(psz)           TraceMsg(TF_SHDCONTROL, "shv CWebBrowserSB::%s", (psz))
#define IOIPAMSG(psz)           TraceMsg(TF_SHDCONTROL, "shv IOIPA::%s", (psz));

#define ABS(i)  (((i) < 0) ? -(i) : (i))

#define BOOL_TO_VARIANTBOOL(b) ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#define VARIANTBOOL_TO_BOOL(vb) ((vb == VARIANT_FALSE) ? FALSE : TRUE)

// sizing messages are annoying, but occasionally useful:
#define DM_FORSEARCHBAND    0

static const OLEVERB c_averbsSV[] = {
        { 0, (LPWSTR)MAKEINTRESOURCE(IDS_VERB_EDIT), 0, OLEVERBATTRIB_ONCONTAINERMENU },
        { 0, NULL, 0, 0 }
    };
static const OLEVERB c_averbsDesignSV[] = {
        { 0, NULL, 0, 0 }
    };

#define HMODULE_NOTLOADED   ((HMODULE)-1)

HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

/*
 * CMsgFilter - implementation of IMessageFilter
 *
 * Used to reject RPC-reentrant calls while inside AOL
 *
 */
class CMsgFilter : public IMessageFilter {
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
    {
        // This interface doesn't get QI'ed.
        ASSERT(FALSE);
        return E_NOINTERFACE;
    };
    virtual ULONG __stdcall AddRef(void)    {   return ++_cRef; };
    virtual ULONG __stdcall Release(void)   {   ASSERT(_cRef > 0);
                                                _cRef--;
                                                if (_cRef > 0)
                                                    return _cRef;

                                                delete this;
                                                return 0;
                                            };

    // *** IMessageFilter specific methods ***
    virtual DWORD __stdcall HandleInComingCall(
        IN DWORD dwCallType,
        IN HTASK htaskCaller,
        IN DWORD dwTickCount,
        IN LPINTERFACEINFO lpInterfaceInfo)
    {
#ifdef DEBUG
        WCHAR   wszIID[39];

        StringFromGUID2( lpInterfaceInfo->iid, wszIID, ARRAYSIZE(wszIID) );

        TraceMsg(TF_SHDCONTROL, "shvMF HandleIncomingCall: calltype=%lx, pUnk=%lx, IID=%ws, wMethod=%hu",
                dwCallType,
                lpInterfaceInfo->pUnk,
                wszIID,
                lpInterfaceInfo->wMethod);
#endif

        //
        //  The following statement guards against RPC-reentrancy by checking if
        //  the calltype is TOPLEVEL_CALLPENDING, which means that a call has arrived with a new
        //  logical threadid and that the object is currently waiting for a reply from a previous
        //  outgoing call.  It's this type of call that has proven troublesome in the past with AOL.
        //
        //  2-Dec-97: AOL QFE: We need to allow resizing requests to pass through the message filter.
        //            These appear as IOleObject::SetExtent.  Check the IID for IOleObject, and the 
        //            wMethod for 17 (SetExtent is the 17th method in the vtable, Zero-based).
        //
        const int SetExtent = 17;

        if ( ( dwCallType == CALLTYPE_TOPLEVEL_CALLPENDING )
            && !(IsEqualIID(lpInterfaceInfo->iid, IID_IOleObject) && lpInterfaceInfo->wMethod == SetExtent) )
        {
#ifdef DEBUG
            TraceMsg(TF_SHDCONTROL, "shvMF rejected call: calltype=%lx, pUnk=%lx, IID=%ws, wMethod=%hu",
                dwCallType,
                lpInterfaceInfo->pUnk,
                wszIID,
                lpInterfaceInfo->wMethod);
#endif
            return SERVERCALL_RETRYLATER;
        }

        if (_lpMFOld)
        {
           HRESULT hr = _lpMFOld->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
           TraceMsg(TF_SHDCONTROL, "shvMF HIC Previous MF returned %x", hr);
           return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF HIC returning SERVERCALL_ISHANDLED.");
            return SERVERCALL_ISHANDLED;
        }
    };

    virtual DWORD __stdcall RetryRejectedCall(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwRejectType)
    {
        TraceMsg(TF_SHDCONTROL, "shv MF RetryRejectedCall htaskCallee=%x, dwTickCount=%x, dwRejectType=%x",
            htaskCallee,
            dwTickCount,
            dwRejectType);

        if (_lpMFOld)
        {
            HRESULT hr = _lpMFOld->RetryRejectedCall(htaskCallee, dwTickCount, dwRejectType);
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returned %x", hr);
            return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returning 0xffffffff");
            return 0xffffffff;
        }
    };

    virtual DWORD __stdcall MessagePending(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwPendingType)
    {
        TraceMsg(TF_SHDCONTROL, "shv MF MessagePending htaskCallee=%x, dwTickCount=%x, dwPendingType=%x",
            htaskCallee,
            dwTickCount,
            dwPendingType);

        if (_lpMFOld)
        {
            HRESULT hr = _lpMFOld->MessagePending(htaskCallee, dwTickCount, dwPendingType);
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returned %x", hr);
            return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF MP returning PENDINGMSG_WAITDEFPROCESS");
            return PENDINGMSG_WAITDEFPROCESS;
        }
    };

    CMsgFilter() : _cRef(1)
    {
        ASSERT(_lpMFOld == NULL);
    };

    BOOL Initialize()
    {
        BOOL bResult = CoRegisterMessageFilter((LPMESSAGEFILTER)this, &_lpMFOld) != S_FALSE;
        TraceMsg(TF_SHDCONTROL, "shv Previous message filter is %lx", _lpMFOld);
        return bResult;
    };

    void UnInitialize()
    {
        TraceMsg(TF_SHDCONTROL, "shv MF Uninitializing, previous message filter = %x", _lpMFOld);
        CoRegisterMessageFilter(_lpMFOld, NULL);

        // we shouldn't ever get called again, but after 30 minutes
        // of automation driving we once hit a function call above
        // and we dereferenced this old pointer and page faulted.

        ATOMICRELEASE(_lpMFOld);
    };

protected:
    int _cRef;
    LPMESSAGEFILTER _lpMFOld;
};


CWebBrowserOC::CWebBrowserOC(IUnknown* punkOuter, LPCOBJECTINFO poi) :
    SUPERCLASS(punkOuter, poi, c_averbsSV, c_averbsDesignSV)
{
    TraceMsg(TF_SHDLIFE, "ctor CWebBrowserOC %x", this);

    // flag special so we only try to load browseui once
    _hBrowseUI = HMODULE_NOTLOADED;    
}

BOOL CWebBrowserOC::_InitializeOC(IUnknown *punkOuter)
{
    // we used a zero-init memory allocator, so everything else is NULL.
    // check to be sure:
    ASSERT(!_fInit);

    // By default, we're visible.  Everything else can default to FALSE.
    //
    _fVisible = 1;

    // CShellOcx holds the default event source which is DIID_DWebBrowserEvents2
    m_cpWB1Events.SetOwner(_GetInner(), &DIID_DWebBrowserEvents);

    // some stuff we want to set up now. we're a WebBrowser, so create the
    // IShellBrowser now. We need an aggregated automation object before
    // we do that.
    CIEFrameAuto_CreateInstance(SAFECAST(this, IOleControl*), &_pauto);
    if (_pauto)
    {
        // Cache some interfaces of CIEFrameAuto.
        //
        // Since we aggregate CIEFrameAuto, this will increase our refcount.
        // We cannot release this interface and expect it to work, so we
        // call release on ourself to remove the refcount cycle.
        //
        // Since we ourselves may be aggregated and we always want to get
        // CIEFrameAuto's interface and not our aggregator's, we delay
        // setting up punkOuter until below.
        //
        _pauto->QueryInterface(IID_PPV_ARG(IWebBrowser2, &_pautoWB2));
        ASSERT(_pautoWB2);
        Release();

        _pauto->QueryInterface(IID_PPV_ARG(IExpDispSupport, &_pautoEDS));
        ASSERT(_pautoEDS);
        Release();
    }

    // Now set up our aggregator's punkOuter
    if (punkOuter)
    {
        CAggregatedUnknown::_SetOuter(punkOuter);
    }

    // postpone initialization of stuff that may be persisted
    // until InitNew is called.

    // Were we successful? (we don't have to free this
    // here on failure, cuz we'll free them on delete)
    return (NULL!=_pauto);
}

CWebBrowserOC::~CWebBrowserOC()
{
    TraceMsg(TF_SHDLIFE, "dtor CWebBrowserOC %x", this);

    ASSERT(!_fDidRegisterAsBrowser);
    _UnregisterWindow();    // Last Chance - should have been done in InplaceDeactivate

    if (_psb) {
        ATOMICRELEASET(_psb, CWebBrowserSB);
    }

    ATOMICRELEASE(_plinkA);

    // We need to release these cached interface pointers.
    //
    // Since we cached them before setting up our outer-aggregation,
    // we need to un-outer-aggregate ourself first.
    //
    // Since we aggregate CIEFrameAuto (where these come from) we need
    // to AddRef ourself before releasing. Fortunately, this is done for us
    // by CAggregatedUnknown::Release (it bumps _cRef to 1000).
    //
    CAggregatedUnknown::_SetOuter(CAggregatedUnknown::_GetInner());
    ATOMICRELEASE(_pautoWB2);
    ATOMICRELEASE(_pautoEDS);

    ATOMICRELEASE(_pauto);

    if (_hmemSB) {
        GlobalFree(_hmemSB);
        _hmemSB = NULL;
    }

    if (_hBrowseUI != 0 && _hBrowseUI != HMODULE_NOTLOADED)
        FreeLibrary(_hBrowseUI);
}



IStream *CWebBrowserSB::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName)
{
    TCHAR szName[MAX_PATH];
    SHUnicodeToTChar(pwszName, szName, ARRAYSIZE(szName));
    return GetViewStream(pidl, grfMode, szName, REGSTR_PATH_EXPLORER TEXT("\\OCXStreamMRU"), TEXT("OCXStreams"));
}

void CWebBrowserOC::_InitDefault()
{
    if (_fInit)
    {
        IPSMSG(TEXT("_InitDefault already initialized"));
        return;
    }
    _fInit = TRUE;

    // Different versions of the control get different defaults.
    if (_pObjectInfo->lVersion == VERSION_1)
    {
        // AOL 3.0 compatibility: register as a browser window on InPlaceActivate
        _fShouldRegisterAsBrowser = TRUE;
    }
    else
    {
        // we use a zero-init memory allocator, so everything else is NULL.
        ASSERT(FALSE == _fShouldRegisterAsBrowser);
    }

    _size.cx = DEF_WIDTH;
    _size.cy = DEF_HEIGHT;
    _sizeHIM = _size;
    PixelsToMetric(&_sizeHIM);

    _fs.ViewMode = FVM_ICON;
    _fs.fFlags = FWF_AUTOARRANGE | FWF_NOCLIENTEDGE;
    
}

void CWebBrowserOC::_RegisterWindow()
{
    if (!_fDidRegisterAsBrowser && _pipsite && _fShouldRegisterAsBrowser)
    {
        ITargetFrame2 *ptgf;
        HRESULT hr;
    
        if (SUCCEEDED(QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            IUnknown *pUnkParent;

            hr = ptgf->GetParentFrame(&pUnkParent);
            if (SUCCEEDED(hr) && pUnkParent != NULL)
            {
                pUnkParent->Release();
            }
            else
            {
                IShellWindows* psw = WinList_GetShellWindows(TRUE);
                if (psw)
                {
                    IDispatch* pid;

                    if (SUCCEEDED(ptgf->QueryInterface(IID_PPV_ARG(IDispatch, &pid))))
                    {
                        psw->Register(pid, PtrToLong(_hwnd), SWC_3RDPARTY, &_cbCookie);
                        _fDidRegisterAsBrowser = 1;
                        pid->Release();
                    }
                    psw->Release();
                }
            }
            ptgf->Release();
        }
    }
}

void CWebBrowserOC::_UnregisterWindow()
{
    if (_fDidRegisterAsBrowser)
    {
        IShellWindows* psw = NULL;

        psw = WinList_GetShellWindows(TRUE);
        if (psw)
        {
            psw->Revoke(_cbCookie);
            _fDidRegisterAsBrowser = 0;
            psw->Release();
        }
    }
}

HRESULT CWebBrowserOC::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    IS_INITIALIZED;

    HRESULT hres;

    IVOMSG3(TEXT("Draw called"), lprcBounds->top, lprcBounds->bottom);
    IViewObject *pvo;
    if (_psb && _psb->GetShellView() &&
        SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IViewObject, &pvo)))) 
    {
        hres = pvo->Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                              lprcBounds, lprcWBounds, pfnContinue, dwContinue);
        pvo->Release();
        if (SUCCEEDED(hres))
            return hres;
    }
    
    // If we don't have a shell view, or if it couldn't draw, then we draw ourselves.
    // (if we're in design mode).
    //
    if (_IsDesignMode())
    {
        FillRect(hdcDraw, (RECT*) lprcBounds, (HBRUSH)GetStockObject(BLACK_BRUSH));

        SIZE     size = { ABS( lprcBounds->right - lprcBounds->left ), 
                          ABS( lprcBounds->bottom - lprcBounds->top ) };

        HBITMAP  hImage;
        HDC      hdcTmp = CreateCompatibleDC( hdcDraw );
        HMODULE  hBrowseUI;

        hBrowseUI = _GetBrowseUI();
        if ( hBrowseUI )      
            hImage = LoadBitmap( hBrowseUI, MAKEINTRESOURCE( IDB_IEBRAND ));
        else 
            hImage = NULL;

        // hdcDraw may be a metafile, in which case the CreateCompatibleDC call will fail.
        // 
        if ( !hdcTmp )
        {
            hdcTmp = CreateCompatibleDC( hdcTargetDev );  // Okay if hdcTargetDev == NULL
        }

        if (hdcTmp)
        {
            if ( hImage )
            {
                BITMAP bm;
                POINT  ptOriginDest;  // origin of destination
                SIZE   sizeDest;
                POINT  ptOriginSrc = { 0, 0 };
                SIZE   sizeSrc;

                GetObject( hImage, sizeof( bm ), &bm );
            
                HGDIOBJ hPrev = SelectObject( hdcTmp, hImage );

                // Yes, this looks wrong, but it's right.  We only want the first frame
                // of the brand bitmap, and the frames are stacked vertically.
                //
                sizeSrc.cx = sizeSrc.cy = bm.bmWidth;
            
                // This code centers the bitmap while preserving its aspect ratio.
                //            
                if ( size.cx > size.cy )
                {
                    // if destination is wider than tall,
                    //
                    ptOriginDest.x = lprcBounds->left + size.cx/2 - size.cy/2;
                    ptOriginDest.y = lprcBounds->top;
                    sizeDest.cx = size.cy;
                    sizeDest.cy = lprcBounds->bottom - lprcBounds->top >= 0 ? size.cy : -size.cy;
                }
                else
                {
                    // else destination is taller than wide
                    //
                    ptOriginDest.x = lprcBounds->left;
                    ptOriginDest.y = lprcBounds->bottom - lprcBounds->top >= 0
                        ? ( lprcBounds->top + size.cy/2 - size.cx/2 )
                        : -( lprcBounds->top + size.cy/2 - size.cx/2 );
                    sizeDest.cx = size.cx;
                    sizeDest.cy = lprcBounds->bottom - lprcBounds->top >= 0 ? size.cx : -size.cx;
                }

                StretchBlt( hdcDraw,
                            ptOriginDest.x, ptOriginDest.y,
                            sizeDest.cx, sizeDest.cy,
                            hdcTmp, 
                            ptOriginSrc.x, ptOriginSrc.y,
                            sizeSrc.cx, sizeSrc.cy,
                            SRCCOPY );

                SelectObject( hdcTmp, hPrev );
                DeleteObject( hImage );
            }

            DeleteDC( hdcTmp );
        }

        return S_OK;
    }
    
    return SUPERCLASS::Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                              lprcBounds, lprcWBounds, pfnContinue, dwContinue);
}

HRESULT CWebBrowserOC::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    IViewObject *pvo;

    if (_psb && _psb->GetShellView() &&
        SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IViewObject, &pvo))))
    {
        HRESULT hres = pvo->GetColorSet(dwAspect, lindex, pvAspect, ptd,
            hicTargetDev, ppColorSet);

        pvo->Release();

        if (SUCCEEDED(hres))
            return hres;
    }

    return SUPERCLASS::GetColorSet(dwAspect, lindex, pvAspect, ptd,
        hicTargetDev, ppColorSet);
}

 HRESULT CWebBrowserOC::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT hr = SUPERCLASS::SetExtent(dwDrawAspect, psizel);
    if ( FAILED( hr ))
    {
        return hr;
    }

    //
    // If oc < inplace then forward SetExtent through to docobject.
    // If docobject is already inplace active, SetExtent is meaningless.
    //
    
    if (_nActivate < OC_INPLACEACTIVE)
    {        
        IPrivateOleObject * pPrivOle = NULL;
        if ( _psb && _psb->GetShellView() && 
             SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IPrivateOleObject, &pPrivOle))))
        {
            // we have an ole object, delegate downwards...
            hr = pPrivOle->SetExtent( dwDrawAspect, psizel );
            pPrivOle->Release();
        }

        _dwDrawAspect = dwDrawAspect;
        // the size is already cached in _sizeHIM in our base class by the SUPERCLASS::SetExtent()
    }
    
    return hr;
}



// Called after the client site has been set so we can process
// stuff in the correct order
//
void CWebBrowserOC::_OnSetClientSite()
{
    // Until we have a client site we can't determine toplevelness.
    //
    if (_pcli)
    {
        BOOL fFoundBrowserService = FALSE;
        IBrowserService *pbsTop;

        if (SUCCEEDED(IUnknown_QueryService(_pcli, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbsTop))))
        {
            fFoundBrowserService = TRUE;
            pbsTop->Release();
        }

        // if nobody above us supports IBrowserService, we must be toplevel.
        if (!fFoundBrowserService)
            _fTopLevel = TRUE;


        // If we haven't created CWebBrowserSB, do so now.
        // We do this before our superclass OnSetClientSite
        // because shembed will create the window which
        // requires _psb's existence.
        //
        // NOTE: We do this here instead of _Initialize because
        // CBaseBrowser will QI us for interfaces during this call.
        // If we're in the middle of our CreateInstance function
        // and we've been aggregated, we pass the QI to _punkAgg
        // who faults because we haven't returned from CoCreateInstance.
        //
        // NOTE: We now destroy our window on SetClientSite(NULL)
        // which frees ths _psb, so we should create this every time.
        //
        if (!_psb)
        {
            // Give _psb our inner unknown so we never get interfaces
            // from whoever may aggregate us. _GetInner gives us
            // first crack at QueryInterface so we get the correct
            // IWebBrowser implementation.
            //
            _psb = new CWebBrowserSB(CAggregatedUnknown::_GetInner(), this);
    
            // if we don't get _psb we're totally hosed...
            //
            if (_psb)
            {
                _psb->_fldBase._fld._fs = _fs;
                // tell _psb if it's top-level or not
                //
                if (_fTopLevel)
                {
                    _psb->SetTopBrowser();
                }

                // CBaseBrowser assumes SVUIA_ACTIVATE_FOCUS, tell it what we really are
                //
                ASSERT(OC_DEACTIVE == _nActivate); // we shouldn't be activated yet
                _psb->_UIActivateView(SVUIA_DEACTIVATE);
            }
            else
            {
                TraceMsg(TF_WARNING, "Couldn't create _psb.  We are hosed!");
                // don't let the window get created by our superclass,
                // as we can't do anything anyway...
                //
                return;
            }
        }
    }
    else
    {
        // Tell our aggregatee that their cached window is invalid
        //
        IEFrameAuto * piefa;
        if (EVAL(SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa)))))
        {
            piefa->SetOwnerHwnd(NULL);
            piefa->Release();
        }

        if (_lpMF) 
        {
            IMessageFilter* lpMF = _lpMF;
            _lpMF = NULL;
            ((CMsgFilter *)lpMF)->UnInitialize();
            EVAL(lpMF->Release() == 0);
        }

        // Decrement the browser session count
        //
        if (_fIncrementedSessionCount)
        {
            SetQueryNetSessionCount(SESSION_DECREMENT);
            _fIncrementedSessionCount = FALSE;  // In case this instance is reused.
        }
    }

    SUPERCLASS::_OnSetClientSite();
    
    if (_pcli)
    {
        VARIANT_BOOL fAmbient = VARIANT_FALSE;
        HWND         hwndParent = NULL;
        // We init the local properties using ambients if available
        // If this fails, fAmbient will be left at VARIANT_FALSE which is what we need for the next 
        // statement.
        //
        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
        {
            put_Offline(fAmbient);
        } 
                       
        // If top-level and not offline, increment the browser session count.
        //
        if (_fTopLevel && !fAmbient)
        {
            SetQueryNetSessionCount(SESSION_INCREMENT_NODEFAULTBROWSERCHECK);
            _fIncrementedSessionCount = TRUE;
        }

        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
        {
            put_Silent(fAmbient);
        }

        // After the parent window has been set, check to see if it is on the same thread as us.
        // If not, we have a cross-thread container and we need a message filter.
        //
        if ( _fTopLevel    // If we're top level
            && _hwnd       //  and we have an hwnd (we should)
            && (hwndParent = GetParent( _hwnd ) )  // and we have a parent window
                           //  and the parent window is on a different thread
            && GetWindowThreadProcessId( _hwnd, NULL ) != GetWindowThreadProcessId( hwndParent, NULL ))
        {
            if (!_lpMF)
            {
                /*
                 * Create a message filter here to reject RPC-reentrant calls.
                 */
                _lpMF = new CMsgFilter();

                if (_lpMF && !(((CMsgFilter *)_lpMF)->Initialize()))
                {
                    ATOMICRELEASE(_lpMF);
                }
                TraceMsg(TF_SHDCONTROL, "shv Registering message filter (%lx) for RPC-reentrancy", _lpMF);
            }
        }


        // if we have a pending navigation from IPS::Load, do it now.
        //
        if (_fNavigateOnSetClientSite && _plinkA && _psb)
        {
            //
            // We hit this code if this OC is IPersistStream::Loaded before
            // the client site is set.
            //
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_plinkA->GetIDList(&pidl)) && pidl)
            {
                _BrowseObject(pidl);
                ILFree(pidl);
            }

            _fNavigateOnSetClientSite = FALSE;
        }
    }
    
}

STDAPI CWebBrowserOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres;

    hres = E_OUTOFMEMORY;
    CWebBrowserOC* psvo = new CWebBrowserOC(NULL, poi);
    if (psvo)
    {
        if (!psvo->_InitializeOC(punkOuter))
        {
            psvo->Release();
        }
        else
        {
            *ppunk = psvo->_GetInner();
            hres = S_OK;
        }
    }
    return hres;
}


LRESULT CWebBrowserOC::_OnPaintPrint(HDC hdcPrint)
{
    PAINTSTRUCT ps;
    HDC hdc = hdcPrint ? hdcPrint : BeginPaint(_hwnd, &ps);
    RECT rc;
    GetClientRect(_hwnd, &rc);
    DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST|BF_RECT|BF_SOFT);
    DrawText(hdc, hdcPrint ? TEXT("Print") : TEXT("Paint"),
            -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    if (!hdcPrint) 
    {
        EndPaint(_hwnd, &ps);
    }
    return 0;
}

HRESULT CWebBrowserOC::_BrowseObject(LPCITEMIDLIST pidlBrowseTo)
{
    if (_psb)
        return _psb->BrowseObject(pidlBrowseTo, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);

    // if no _psb at this point, container did not
    // honor OLEMISC_SETCLIENTSITEFIRST bit, so silently
    // fail instead of trying to make this work
    ASSERT(FALSE);
    return E_FAIL;
}

LRESULT CWebBrowserOC::_OnCreate(LPCREATESTRUCT lpcs)
{
    LRESULT lres;

    if (_psb)
    {
        ASSERT(_hwnd);
        _psb->_SetWindow(_hwnd);

        lres = _psb->OnCreate(NULL);
    }
    else
    {
        lres = (LRESULT)-1;
    }

    //
    //  If IPersistStream::Load has stored away a block of stream for
    // toolbars, this is the time to use it.
    //
    if (_hmemSB) 
    {
        GlobalFree(_hmemSB);
        _hmemSB = NULL;
    }

    return lres;
}

//
//  This is a virtual function defined in CShellEmbedding class, which
// is called when all but WM_NCCREATE and WM_NCDESTROY messages are
// dispatched to the our "Shell Embedding" window. It's important
// to remember that we pass this window handle to the constructor of
// CWebBrowserSB (which calls the constructor of CBaseBrowser).
// That's why we forward all messages to _psb->WndProcBS. (SatoNa)
//
LRESULT CWebBrowserOC::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0L;

    if (WM_CREATE == uMsg)
    {
        // We need first crack at this message before
        // forwarding it along to _psb (which we do
        // in this _OnCreate call)
        return _OnCreate((LPCREATESTRUCT)lParam);
    }

    // only let _psb look at it if the message is not reserved for us
    if (!IsInRange(uMsg, CWM_RESERVEDFORWEBBROWSER_FIRST, CWM_RESERVEDFORWEBBROWSER_LAST))
    {
        BOOL fDontForward = FALSE;
        
        // destroy bottom up for these 
        switch (uMsg) 
        {
        case WM_DESTROY:
        case WM_CLOSE:
            SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
            fDontForward = TRUE;
            break;
        }

        //
        // This AssertMsg will help debugging IE v4.1 bug 12931.
        //
        //  Comment out assert now that we don't create _psb at constructor time.  (?)
        //AssertMsg((BOOL)_psb, "WBOC::v_WndProc _psb==NULL! uMsg=%x", uMsg);

        if (_psb)
        {
            lres = _psb->WndProcBS(hwnd, uMsg, wParam, lParam);

            //  Due to aggregation of IEFrameAuto, _psb is holding references
            //  to us, so we need to break the cycle.
            //  _psb may have been freed above.  Double check it.
            //
            if (uMsg == WM_DESTROY && _psb)
            {
                _psb->ReleaseShellView();
                _psb->ReleaseShellExplorer();
                ATOMICRELEASET(_psb, CWebBrowserSB);
            }
        }
        if (uMsg >= WM_USER || fDontForward)
        {
            return lres;
        }
    }

    switch(uMsg)
    {
        /* these are handled by CBaseBrowser only */
    case WM_NOTIFY:
        return lres;

    case WM_SETCURSOR:
        if (lres) {
            return lres;
        }
        goto DoDefault;

DoDefault:
    default:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

HRESULT CWebBrowserOC::Close(DWORD dwSaveOption)
{
    if (_psb)
    {
        _psb->_CancelPendingNavigation();
    }

    if (_pauto)
    {
        IWebBrowserPriv * pWBPriv;

        HRESULT hr = _pauto->QueryInterface(IID_PPV_ARG(IWebBrowserPriv, &pWBPriv));
        if (SUCCEEDED(hr))
        {
            pWBPriv->OnClose();
            pWBPriv->Release();
        }
    }

    return SUPERCLASS::Close(dwSaveOption);
}

HRESULT CWebBrowserOC::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    IOOMSG(TEXT("SetHostNames"));

    // We are not interested in host name
    // ...well ... maybe a little.  this turns out to be the best place to
    // do an apphack for VC 5.0.  VC 5.0 has a bug where it calls Release()
    // one too many times.  the only good way to detect being hosted in the
    // offending container is to check the szContainerApp in SetHostNames!
    // ...chrisfra 8/14/97, bug 30428
    // NOTE: Mike Colee of VC verified their bug and will put a Raid bug in
    // their database including how to signal that a new version works by
    // changing szContainerApp string.
    if (_fTopLevel && szContainerApp && !StrCmpW(szContainerApp, L"DevIV Package"))
    {
        AddRef();
    }
    return SUPERCLASS::SetHostNames(szContainerApp, szContainerObj);
}

HRESULT CWebBrowserOC::DoVerb(
    LONG iVerb,
    LPMSG lpmsg,
    IOleClientSite *pActiveSite,
    LONG lindex,
    HWND hwndParent,
    LPCRECT lprcPosRect)
{
    IS_INITIALIZED;

    _pmsgDoVerb = lpmsg;

    HRESULT hr = SUPERCLASS::DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);

    _pmsgDoVerb = NULL;

    return hr;
}

// *** IPersistStreamInit ***

// in order to have upgrade and downgrade compatibility in stream formats
// we can't have any size assumptions in this code. Extra data streamed
// after our PersistSVOCX structure must be referenced by a dwOffX offset
// so the downgrade case knows where to start reading from.
//
// since we always write out a stream that's downward compatible, we don't
// need to folow the "source compatible" rule of: reading an old stream
// with an old CLSID WebBrowser implies that when we save, we need to
// save using the old stream format.
//
typedef struct _PersistSVOCX
{
    struct _tagIE30 {
        DWORD cbSize;
        SIZE sizeObject;            // IE3 saves as PIXELS, IE4 saves as HIMETRIC
        FOLDERSETTINGS fs;
        long lAutoSize;             // IE3, no longer used
        DWORD fColorsSet;           // IE3, no longer used
        COLORREF clrBack;           // IE3, no longer used
        COLORREF clrFore;           // IE3, no longer used
        DWORD dwOffPersistLink;
        long lAutoSizePercentage;   // IE3, no longer used
    } ie30;
    struct _tagIE40 {
        DWORD   dwExtra;
        BOOL    bRestoreView;
        SHELLVIEWID vid;
        DWORD   fFlags;
        DWORD   dwVersion;
    } ie40;
} PersistSVOCX;

//
// Flags for dwExtra. Having a flag indicate that we have some extra
// streamed data after this structure + persisted link.
//
// NOTE: All data stored this way (instead of storing an offset to
// the data, such as dwOffPersistLink) will be lost on downgrade
// cases and cases where we have to emulate old stream formats.
//
#define SVO_EXTRA_TOOLBARS 0x00000001

// Random flags we need to persist
#define SVO_FLAGS_OFFLINE           0x00000001
#define SVO_FLAGS_SILENT            0x00000002
#define SVO_FLAGS_REGISTERASBROWSER 0x00000004
#define SVO_FLAGS_REGISTERASDROPTGT 0x00000008

#define SVO_VERSION 0 // increment for upgrade changes when size doesn't change

HRESULT CWebBrowserOC::Load(IStream *pstm)
{
    IPSMSG(TEXT("Load"));
    // Load _size
    ULONG cbRead;
    PersistSVOCX sPersist;
    HRESULT hres, hresNavigate = E_FAIL;
    DWORD dwExtra = 0;

    // It is illegal to call Load or InitNew more than once
    if (_fInit)
    {
        TraceMsg(TF_SHDCONTROL, "shv IPersistStream::Load called when ALREADY INITIALIZED!");
        ASSERT(FALSE);
        return E_FAIL;
    }

    // we need an IShellLink to read into
    if (_plinkA == NULL)
    {
        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plinkA));
        if (FAILED(hres))
            return hres;
    }

    // remember our starting location
    ULARGE_INTEGER liStart;
    //ULARGE_INTEGER liEnd;
    LARGE_INTEGER liMove;
    liMove.LowPart = liMove.HighPart = 0;
    hres = pstm->Seek(liMove, STREAM_SEEK_CUR, &liStart);
    if (FAILED(hres))
    {
        return hres;
    }

    // Zero initialize our struct
    ZeroMemory(&sPersist, SIZEOF(sPersist));

    hres = pstm->Read(&sPersist, SIZEOF(DWORD), &cbRead);
    if (SUCCEEDED(hres))
    {
        // Validate the data
        if (cbRead != SIZEOF(DWORD) ||
            sPersist.ie30.cbSize < SIZEOF(sPersist.ie30))
        {
            TraceMsg(DM_ERROR, "Someone is asking us to read the wrong thing.");
            hres = E_FAIL;
        }
        else
        {
            DWORD cbSizeToRead = sPersist.ie30.cbSize;
            if (cbSizeToRead > SIZEOF(sPersist))
            {
                // must be a newer struct, only read what we know (ie, don't trash the stack!)
                cbSizeToRead = SIZEOF(sPersist);
            }
            cbSizeToRead -= SIZEOF(DWORD); // remove what we've already read
            hres = pstm->Read(&sPersist.ie30.sizeObject, cbSizeToRead, &cbRead);
            if (SUCCEEDED(hres))
            {
                if (cbRead != cbSizeToRead)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // read ie30 data
                    //
                    if (EVAL(sPersist.ie30.cbSize >= SIZEOF(sPersist.ie30)))
                    {
                        _size = sPersist.ie30.sizeObject;
                        _fs = sPersist.ie30.fs;

                        // IE3 saved size in pixels IE4 saves size in HIM already
                        //
                        _sizeHIM = _size;
                        if (sPersist.ie30.cbSize == SIZEOF(sPersist.ie30) ||
                            sPersist.ie30.cbSize == SIZEOF(sPersist) - SIZEOF(sPersist.ie40.dwVersion)) // handle upgrade
                        {
                            // Size is in pixels.  Adjust _sizeHIM to Hi Metric.
                            PixelsToMetric(&_sizeHIM);
                        }
                        else
                        {
                            // Size is in Hi Metric.  Adjust _size to Pixels.
                            MetricToPixels(&_size);
                        }

                        if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
                            _psb->_fldBase._fld._fs = _fs;
                            
                        // Load _plinkA
                        IPersistStream* ppstm;
                        hres = _plinkA->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                        if (SUCCEEDED(hres))
                        {
                            ASSERT(sPersist.ie30.dwOffPersistLink >= sPersist.ie30.cbSize);
                            liMove.LowPart = liStart.LowPart + sPersist.ie30.dwOffPersistLink;

                            hres = pstm->Seek(liMove, STREAM_SEEK_SET, NULL);
                            if (SUCCEEDED(hres))
                            {
                                hres = ppstm->Load(pstm);
                                if (SUCCEEDED(hres)) 
                                {
                                    // We always save link info last,
                                    // so remember where we are in the stream.
                                    // Since we don't have more dwOff variables
                                    // currently, don't bother remebering this...
                                    //hres = pstm->Seek(liMove, STREAM_SEEK_CUR, &liEnd);
                                    //if (SUCCEEDED(hres))
                                        _fInit = TRUE;
                                
                                    // in case the target moved invoke link tracking (ignore errors)
                                    _plinkA->Resolve(_hwnd, SLR_NO_UI);

                                    // If we already have the client site,
                                    // navigate now. Otherwise, navigate
                                    // when the client site is set.
                                    if (_pcli) 
                                    {
                                        LPITEMIDLIST pidl;
                                        if (SUCCEEDED(_plinkA->GetIDList(&pidl)) && pidl)
                                        {
                                            ASSERT(FALSE == _psb->_fAsyncNavigate);
                                            _psb->_fAsyncNavigate = TRUE;
                                            hresNavigate = _BrowseObject(pidl);
                                            _psb->_fAsyncNavigate = FALSE;
                                            ILFree(pidl);
                                        }
                                    } 
                                    else 
                                    {
                                        _fNavigateOnSetClientSite = TRUE;
                                    }
                                }
                            }

                            ppstm->Release();
                        }
                    } // read ie30 data


                    // temp upgrade hack for older struct
                    if (sPersist.ie30.cbSize == SIZEOF(sPersist) - SIZEOF(sPersist.ie40.dwVersion))
                    {
                        // dwVersion field is already correct, update cbSize
                        // to pass below size check
                        sPersist.ie30.cbSize = SIZEOF(sPersist);
                    }

                    // read ie40 data
                    if (SUCCEEDED(hres) &&
                        sPersist.ie30.cbSize >= SIZEOF(sPersist))
                    {
                        if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
                        {
                            if (sPersist.ie40.bRestoreView)
                            {
                                _psb->_fldBase._fld._vidRestore = sPersist.ie40.vid;
                                // since we read the ie40 data, this is a cache hit
                                _psb->_fldBase._fld._dwViewPriority = VIEW_PRIORITY_CACHEHIT;
                            }
                        }

                        // We let ambients take precedence over what we have persisted
                        VARIANT_BOOL fAmbient;
                        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
                        {
                            put_Offline(fAmbient);
                        } 
                        else
                        {
                            put_Offline((sPersist.ie40.fFlags & SVO_FLAGS_OFFLINE) ? -1 : FALSE);
                        }
                        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
                        {
                            put_Silent(fAmbient);
                        }
                        else
                        {
                            put_Silent((sPersist.ie40.fFlags & SVO_FLAGS_SILENT) ? -1 : FALSE);
                        }

                        
                        put_RegisterAsDropTarget(BOOL_TO_VARIANTBOOL(sPersist.ie40.fFlags & SVO_FLAGS_REGISTERASDROPTGT));

                        _fShouldRegisterAsBrowser = (sPersist.ie40.fFlags & SVO_FLAGS_REGISTERASBROWSER) ? TRUE : FALSE;

                        // remember this for later
                        dwExtra = sPersist.ie40.dwExtra;
                    }
                    else
                    {
                        // if CLSID_WebBrowser_V1 reads an old stream format,
                        // it means that we must write out an old stream format later
                        // remember this...
                        if (_pObjectInfo->lVersion == VERSION_1)
                        {
                            _fEmulateOldStream = TRUE;
                        }
                    } // read ie40 data
                }

                // if we read all the data then make sure we're at
                // the end of the stream
                if (SUCCEEDED(hres) && _fInit)
                {
                    //liMove.LowPart = liEnd.LowPart;
                    //hres = pstm->Seek(liMove, STREAM_SEEK_SET, NULL);

                    // now we can read in extra streamed data if we have it
                    if (dwExtra & SVO_EXTRA_TOOLBARS)
                    {
                        DWORD dwTotal;
                        hres = pstm->Read(&dwTotal, SIZEOF(dwTotal), NULL);
                        if (SUCCEEDED(hres)) 
                        {
                            ASSERT(dwTotal >= SIZEOF(dwTotal));
                            dwTotal -= SIZEOF(dwTotal);

                            if (_hmemSB) 
                            {
                                GlobalFree(_hmemSB);
                            }

                            _hmemSB = GlobalAlloc(GPTR, dwTotal);
                            if (_hmemSB) 
                            {
                                hres = pstm->Read((BYTE*)_hmemSB, dwTotal, NULL);
                            }
                            else 
                            {
                                hres = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            }
        }
    }

    _OnLoaded(FAILED(hresNavigate));

    if (SUCCEEDED(hres))
        hres = S_OK;    // convert S_FALSE to S_OK
 
    return hres;
}

HRESULT CWebBrowserOC_SavePersistData(IStream *pstm, SIZE* psizeObj,
    FOLDERSETTINGS* pfs, IShellLinkA* plinkA, SHELLVIEWID* pvid,
    BOOL fOffline, BOOL fSilent, BOOL fRegisterAsBrowser, BOOL fRegisterAsDropTarget,
    BOOL fEmulateOldStream, DWORD *pdwExtra)
{
    ULONG cbWritten;
    PersistSVOCX sPersist;
    HRESULT hres;

    // This means that this instance of CWebBrowserOC was created using
    // the ie30 CLSID and we were persisted from an old format stream.
    // Under this scenario, we have to write out a stream format that
    // can be read by the old ie30 object.
    if (fEmulateOldStream && pdwExtra)
    {
        // The only data we stream out that can't be read back in by
        // the old ie30 webbrowser is the dwExtra data.
        *pdwExtra = 0;
    }


    ZeroMemory(&sPersist, SIZEOF(sPersist));

    sPersist.ie30.cbSize = fEmulateOldStream ? SIZEOF(sPersist.ie30) : SIZEOF(sPersist);
    sPersist.ie30.sizeObject = *psizeObj;
    sPersist.ie30.fs = *pfs;
    sPersist.ie30.dwOffPersistLink = SIZEOF(sPersist);
    if (pvid)
    {
        sPersist.ie40.bRestoreView = TRUE;
        sPersist.ie40.vid = *pvid;
    }
    sPersist.ie40.dwExtra = pdwExtra ? *pdwExtra : 0;
    if (fOffline)
        sPersist.ie40.fFlags |= SVO_FLAGS_OFFLINE;
    if (fSilent)
        sPersist.ie40.fFlags |= SVO_FLAGS_SILENT;
    if (fRegisterAsBrowser)
        sPersist.ie40.fFlags |= SVO_FLAGS_REGISTERASBROWSER;
    if (fRegisterAsDropTarget)
        sPersist.ie40.fFlags |= SVO_FLAGS_REGISTERASDROPTGT;
    sPersist.ie40.dwVersion = SVO_VERSION;

    hres = pstm->Write(&sPersist, SIZEOF(sPersist), &cbWritten);
    IPSMSG3(TEXT("Save 1st Write(&_size) returned"), hres, cbWritten, sizeof(*psizeObj));
    if (SUCCEEDED(hres))
    {
        // Save plinkA
        ASSERT(plinkA);
        IPersistStream* ppstm;
        hres = plinkA->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
        if (SUCCEEDED(hres))
        {
            hres = ppstm->Save(pstm, TRUE);
            IPSMSG2(TEXT("Save plink->Save() returned"), hres);

            ppstm->Release();
        }
    }

    return hres;
}

BOOL CWebBrowserOC::_GetViewInfo(SHELLVIEWID* pvid)
{
    BOOL bGotView = FALSE;

    if (_psb)
    {
        if (_psb->GetShellView())
        {
            _psb->GetShellView()->GetCurrentInfo(&_fs);
        }
        else
        {
            _fs = _psb->_fldBase._fld._fs;
        }
        bGotView = FileCabinet_GetDefaultViewID2(&_psb->_fldBase, pvid);
    }
    
    return bGotView;
}

HRESULT CWebBrowserOC::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    LPITEMIDLIST pidl;
    SHELLVIEWID vid;
    BOOL bGotView;
    VARIANT_BOOL fOffline, fSilent, fRegDT;

    IPSMSG(TEXT("Save"));
    IS_INITIALIZED;

    pidl = NULL;
    if (_psb)
        pidl = _psb->_bbd._pidlCur;

    // we need an IShellLink to save with
    if (_plinkA == NULL)
    {
        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plinkA));
        if (FAILED(hres))
            return hres;
    }
    _plinkA->SetIDList(pidl);

    bGotView = _GetViewInfo(&vid);

    DWORD dwExtra = 0;

    get_Offline(&fOffline);
    get_Silent(&fSilent);
    get_RegisterAsDropTarget(&fRegDT);

    hres = CWebBrowserOC_SavePersistData(pstm, _fEmulateOldStream ? &_size : &_sizeHIM, &_fs, _plinkA,
            (bGotView ? &vid : NULL),
            fOffline, fSilent, _fShouldRegisterAsBrowser, fRegDT,
            _fEmulateOldStream, &dwExtra);

    ASSERT(!(dwExtra & SVO_EXTRA_TOOLBARS));

    if (fClearDirty)
    {
        _fDirty = FALSE;
    }

    return hres;
}

void CWebBrowserOC::_OnLoaded(BOOL fUpdateBrowserReadyState)
{
    IEFrameAuto * piefa;
    if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa))))
    {
        piefa->put_DefaultReadyState(READYSTATE_COMPLETE, fUpdateBrowserReadyState);
        piefa->Release();
    }
}

HRESULT CWebBrowserOC::InitNew(void)
{
    IPSMSG(TEXT("InitNew"));

    _InitDefault();

    // On the InitNew case, we do want to update the browser's ready state
    _OnLoaded(TRUE);

    return NOERROR;
}

// IPersistPropertyBag

static const struct {
    LPOLESTR pName;
    UINT     flag;
} g_boolprops[] = {
    {L"AutoArrange",        FWF_AUTOARRANGE},
    {L"NoClientEdge",       FWF_NOCLIENTEDGE},
    {L"AlignLeft",          FWF_ALIGNLEFT},
    {L"NoWebView",          FWF_NOWEBVIEW},
    {L"HideFileNames",      FWF_HIDEFILENAMES},
    {L"SingleClick",        FWF_SINGLECLICKACTIVATE},
    {L"SingleSelection",    FWF_SINGLESEL},
    {L"NoFolders",          FWF_NOSUBFOLDERS},
    {L"Transparent",        FWF_TRANSPARENT},
};

HRESULT CWebBrowserOC::Load(IPropertyBag *pBag, IErrorLog *pErrorLog)
{
    BOOL fOffline = FALSE;
    BOOL fSilent = FALSE;
    BOOL fRegisterAsBrowser = FALSE;
    BOOL fRegisterAsDropTgt = FALSE;
    BOOL fUpdateBrowserReadyState = TRUE;
    VARIANT_BOOL fAmbient;

    // It is illegal to call ::Load or ::InitNew more than once
    if (_fInit)
    {
        TraceMsg(TF_SHDCONTROL, "shv IPersistPropertyBag::Load called when ALREADY INITIALIZED!");
        ASSERT(FALSE);
        return E_FAIL;
    }

    _InitDefault();

    // grab all our DWORD-sized (VT_UI4) properties
    struct {
        LPOLESTR pName;
        DWORD*   pdw;
    } rgLoadProps[] = {
        {L"Height",         (DWORD *)&_size.cy},
        {L"Width",          (DWORD *)&_size.cx},
        {L"ViewMode",       (DWORD *)&_fs.ViewMode},
        {L"Offline",        (DWORD *)&fOffline},
        {L"Silent",         (DWORD *)&fSilent},
        {L"RegisterAsBrowser", (DWORD *)&fRegisterAsBrowser},
        {L"RegisterAsDropTarget", (DWORD *)&fRegisterAsDropTgt}
    };

    for (int i = 0; i < ARRAYSIZE(rgLoadProps); i++)
    {
        SHPropertyBag_ReadDWORD(pBag, rgLoadProps[i].pName, rgLoadProps[i].pdw);
    }

    // We let ambients take precedence over what we have persisted
    if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
    {
        put_Offline(fAmbient);
    } 
    else
    {
        put_Offline(BOOL_TO_VARIANTBOOL(fOffline));
    }

    if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
    {
        put_Silent(fAmbient);
    }
    else
    {
        put_Silent(BOOL_TO_VARIANTBOOL(fSilent));
    }

    // If You use fOffline or fSilent after this, you will have to re-init them according 
    // to the returned values of fAmbient in the if statements above
    
    put_RegisterAsDropTarget(BOOL_TO_VARIANTBOOL(fRegisterAsDropTgt));

    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(fRegisterAsBrowser);

    // IE3 saved PIXEL size, IE4 saves HIMETRIC size
    DWORD lVal;
    HRESULT hr = SHPropertyBag_ReadDWORD(pBag, L"ExtentX", &lVal);
    if (SUCCEEDED(hr))
    {
        _sizeHIM.cx = lVal;
        hr = SHPropertyBag_ReadDWORD(pBag, L"ExtentY", &lVal);
        if (SUCCEEDED(hr))
        {
            _sizeHIM.cy = lVal;
        }
    }

    if (FAILED(hr))
    {
        // convert IE3 info to HIMETRIC
        _sizeHIM = _size;
        PixelsToMetric(&_sizeHIM);
    }

    hr = S_OK;

    for (i = 0; i < ARRAYSIZE(g_boolprops); i++)
    {
        if (SHPropertyBag_ReadBOOLDefRet(pBag, g_boolprops[i].pName, FALSE))
            _fs.fFlags |= g_boolprops[i].flag;
        else
            _fs.fFlags &= ~g_boolprops[i].flag;
    }

    // grab special properties

    if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
    {
        if (SUCCEEDED(SHPropertyBag_ReadGUID(pBag, L"ViewID", &_psb->_fldBase._fld._vidRestore)))
        {
            // we sucessfully read the ViewID, so this is a cache hit
            _psb->_fldBase._fld._dwViewPriority = VIEW_PRIORITY_CACHEHIT;
        }

        _psb->_fldBase._fld._fs = _fs;

        BSTR bstrVal;
        if (SUCCEEDED(SHPropertyBag_ReadBSTR(pBag, L"Location", &bstrVal)))
        {
            ASSERT(FALSE == _psb->_fAsyncNavigate);

            hr = WrapSpecialUrl(&bstrVal);
            if (SUCCEEDED(hr))
            {
                _psb->_fAsyncNavigate = TRUE;

                if (FAILED(Navigate(bstrVal, NULL, NULL, NULL, NULL)))
                {
                    TraceMsg(TF_SHDCONTROL, "Load PropertyBag Navigate FAILED!");
                }
                else
                {
                    // Navigate is successful (at least initially), let it update ReadyState
                    //
                    fUpdateBrowserReadyState = FALSE;
                }
                _psb->_fAsyncNavigate = FALSE;
            }
            SysFreeString(bstrVal);
        }
    }

    _OnLoaded(fUpdateBrowserReadyState);
 
    return hr;
}
HRESULT CWebBrowserOC::Save(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    IS_INITIALIZED;

    HRESULT hres;
    VARIANT var;
    int i;
    SHELLVIEWID vid;
    BOOL bGotView = FALSE;

    VARIANT_BOOL f;
    BOOL fOffline;
    BOOL fSilent;
    BOOL fRegisterAsDropTgt;
    BOOL fRegisterAsBrowser;
    
    get_Offline(&f);
    fOffline = f ? TRUE : FALSE;
    get_Silent(&f);
    fSilent = f ? TRUE : FALSE;
    get_RegisterAsDropTarget(&f);
    fRegisterAsDropTgt = f ? TRUE : FALSE;
    fRegisterAsBrowser = _fShouldRegisterAsBrowser ? TRUE : FALSE;

    // our state may have changed
    bGotView = _GetViewInfo(&vid);

    // save all our DWORD-sized properties
    struct {
        LPOLESTR pName;
        DWORD*   pdw;
    } rgLoadProps[] = {
        {L"ExtentX",        (DWORD *)&_sizeHIM.cx},
        {L"ExtentY",        (DWORD *)&_sizeHIM.cy},
        {L"ViewMode",       (DWORD *)&_fs.ViewMode},
        {L"Offline",        (DWORD *)&fOffline},
        {L"Silent",         (DWORD *)&fSilent},
        {L"RegisterAsBrowser", (DWORD *)&fRegisterAsBrowser},
        {L"RegisterAsDropTarget", (DWORD *)&fRegisterAsDropTgt},

        // IE3 OC stuff here
        {L"Height",         (DWORD *)&_size.cy},
        {L"Width",          (DWORD *)&_size.cx}
    };
    VariantInit(&var);
    var.vt = VT_I4; // VB doesn't understand VT_UI4! (pBag->Write succeeds,
                    // but it doesn't write anything! The load then fails!)
    int nCount = ARRAYSIZE(rgLoadProps);
    if (_pObjectInfo->lVersion != VERSION_1)
        nCount -= 2;

    for (i = 0; i < nCount; i++)
    {
        var.lVal = *rgLoadProps[i].pdw;
        hres = pBag->Write(rgLoadProps[i].pName, &var);
        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Save PropertyBag could not save %ws for DWORD", rgLoadProps[i].pName);
            return hres;
        }
    }

    // save all our _fs.fFlags (VT_BOOL) flags
    var.vt = VT_BOOL;
    for (i = 0; i < ARRAYSIZE(g_boolprops); i++)
    {
        var.boolVal = BOOL_TO_VARIANTBOOL(_fs.fFlags & g_boolprops[i].flag);
        hres = pBag->Write(g_boolprops[i].pName, &var);
        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Load PropertyBag did not save %ws for BOOL", g_boolprops[i].pName);
        }
    }

    // save special properties

    if (bGotView)
    {
        SHPropertyBag_WriteGUID(pBag, L"ViewID", &(GUID)vid);
    }

    var.vt = VT_BSTR;
    if (SUCCEEDED(get_LocationURL(&var.bstrVal)))
    {
        hres = pBag->Write(L"Location", &var);

        VariantClear(&var);

        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Save PropertyBag could not save Location");
            return hres;
        }
    }
    else
    {
        var.vt = VT_EMPTY;
        TraceMsg(TF_SHDCONTROL, "Save PropertyBag get_Location FAILED!");
    }

    return NOERROR;
}


// IPersistString

STDMETHODIMP CWebBrowserOC::Initialize(LPCWSTR pwszInit)
{
    HRESULT hr = E_OUTOFMEMORY;
    BSTR bstr = SysAllocString(pwszInit);
    if (bstr)
    {
        hr = Navigate(bstr, NULL, NULL, NULL, NULL);
        SysFreeString(bstr);
    }
    return hr;
}


#define THISCLASS CWebBrowserOC
HRESULT CWebBrowserOC::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IWebBrowser2),
        QITABENTMULTI(THISCLASS, IDispatch, IWebBrowser2), // VBA QI's IDispatch and assumes it gets the "default" automation interface, which is IWebBrowser2
        QITABENTMULTI(THISCLASS, IWebBrowser, IWebBrowser2),
        QITABENTMULTI(THISCLASS, IWebBrowserApp, IWebBrowser2),
        QITABENT(THISCLASS, IPersistString),
        QITABENT(THISCLASS, IOleCommandTarget),
        QITABENT(THISCLASS, IObjectSafety),
        QITABENT(THISCLASS, ITargetEmbedding),
        QITABENT(THISCLASS, IExpDispSupport),
        QITABENT(THISCLASS, IExpDispSupportOC),
        QITABENT(THISCLASS, IPersistHistory),
        QITABENT(THISCLASS, IPersistStorage),
        { 0 },
    };
    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
    {
        hres = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);

        // we want to expose our aggregated CIEFrameAuto's interfaces
        // in addition to ours.
        if (FAILED(hres))
        {
            hres = _pauto->QueryInterface(riid, ppvObj);
        }
    }

    return hres;
}

// *** IOleInPlaceActiveObject ***
HRESULT CWebBrowserOC::OnFrameWindowActivate(BOOL fActivate)
{
    if (_psb)
        _psb->OnFrameWindowActivateBS(fActivate);
        
    return S_OK;
}

HRESULT CWebBrowserOC::TranslateAccelerator(LPMSG lpMsg)
{
    if (_psb)
    {
        // FEATURE REVIEW: what wID should we really pass? Is 0 ok?
        if (S_OK == _psb->_TranslateAccelerator(lpMsg, 0, DIRECTION_FORWARD_TO_CHILD))
            return S_OK;
    }
    else
    {
        IOIPAMSG(TEXT("TranslateAccelerator cannot forward to _psb"));
    }

    // SUPERCLASS has no accelerators
    return S_FALSE;
}

HRESULT CWebBrowserOC::EnableModeless(BOOL fEnable)
{
    SUPERCLASS::EnableModeless(fEnable);
    if (_psb)
    {
        return _psb->_EnableModeless(fEnable, DIRECTION_FORWARD_TO_CHILD);
    }
    else
    {
        IOIPAMSG(TEXT("EnableModeless cannot forward to _psb"));
        return S_OK;
    }
}


HRESULT CWebBrowserOC::_OnActivateChange(IOleClientSite* pActiveSite, UINT uState)
{
    HRESULT hres = SUPERCLASS::_OnActivateChange(pActiveSite, uState);

    if (SUCCEEDED(hres))
    {
        UINT uViewState;

        switch (uState)
        {
        case OC_DEACTIVE:       uViewState = SVUIA_DEACTIVATE; break;
        case OC_INPLACEACTIVE:  uViewState = SVUIA_INPLACEACTIVATE; break;
        case OC_UIACTIVE:       uViewState = SVUIA_ACTIVATE_FOCUS; break;
        default:                ASSERT(FALSE); return E_INVALIDARG;
        }

        if (_psb)
            _psb->_UIActivateView(uViewState);
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "shv _OnActivateChange failed, _psb=0x%x", _psb);
    }

    return hres;
}

void CWebBrowserOC::_OnInPlaceActivate(void)
{
    HWND       hwnd = NULL;

    SUPERCLASS::_OnInPlaceActivate();

    _RegisterWindow();

    if (_pipsite)
    {

        // we have to hold on to the target frame until we deactivate,
        // because the psbFrame will delete this thing when it shuts down
        // *before* we are actually deactivated, leaking the unadvise
        // in ieframeauto.
        ASSERT(NULL==_pTargetFramePriv);
        if (SUCCEEDED(IUnknown_QueryService(_pipsite, IID_ITargetFrame2, IID_PPV_ARG(ITargetFramePriv, &_pTargetFramePriv))))
        {
            _pTargetFramePriv->OnChildFrameActivate(SAFECAST(this, IConnectionPointContainer* ));
        }

        ASSERT(NULL==_pctContainer);
        if (FAILED(_pipsite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pctContainer))))
        {
            // NT 305187 discover.exe crash on exit when _pcli is NULL
            if (_pcli) 
            {
                // APPCOMPAT: It should be on IOleInPlaceSite,
                // but MSHTML currently has it on IOleContainer.
                IOleContainer *pCont;
                if (SUCCEEDED(_pcli->GetContainer(&pCont)))
                {
                    pCont->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pctContainer));
                    pCont->Release();
                }
            }
        }

        if (_pipframe && SUCCEEDED(_pipframe->GetWindow(&hwnd)))
        {
            // Check to see if our inplace frame is VB5.  If so, we have to hack around 
            // _pipframe->EnableModeless calls
            //
            const TCHAR VBM_THUNDER[] = TEXT("Thunder");
            TCHAR strBuf[VB_CLASSNAME_LENGTH];

            // Check to see if the inplace frame we just called is VB5's forms engine.
            //
            ZeroMemory(strBuf, ARRAYSIZE(strBuf));    // Clear the buffer
            GetClassName(hwnd, strBuf, (VB_CLASSNAME_LENGTH - 1));  // Get the class name of the window.
            if (StrCmpN(strBuf, VBM_THUNDER, (sizeof(VBM_THUNDER)/sizeof(TCHAR))-1) == 0)   // Is the first part "Thunder"?
            {
                _fHostedInVB5 = TRUE;
            }
        }

        {
            //
            // App compat:  Check for imagineer technical
            //

            const WCHAR STR_IMAGINEER[] = L"imagine.exe";
            WCHAR szBuff[MAX_PATH];

            if (GetModuleFileName(NULL, szBuff, ARRAYSIZE(szBuff)))
            {
                LPWSTR pszFile = PathFindFileName(szBuff);

                if (pszFile)
                {
                    _fHostedInImagineer = (0 == StrNCmpI(pszFile, STR_IMAGINEER,
                                                 ARRAYSIZE(STR_IMAGINEER) - 1));
                }
            }
        }
    }
    else
    {
        IOIPAMSG(TEXT("_OnInPlaceActivate doesn't have pipsite!"));
    }
}

void CWebBrowserOC::_OnInPlaceDeactivate(void)
{
    _UnregisterWindow();

    if (_pTargetFramePriv)
    {
        _pTargetFramePriv->OnChildFrameDeactivate(SAFECAST(this, IConnectionPointContainer*));
        ATOMICRELEASE(_pTargetFramePriv);
    }

    ATOMICRELEASE(_pctContainer);

    SUPERCLASS::_OnInPlaceDeactivate();
}


/*
 ** Ambient properties we care about
 */

// We forward IOleControl calls to the docobj.
// This helper function returns the docobj's IOleControl interface.
//
// NOTE: we may want to fail this when the WebBrowserOC was created
//       using IE3's classid just to be safe...
//
IOleControl* GetForwardingIOC(IWebBrowser* pwb)
{
    IOleControl* poc = NULL;
    IDispatch* pdisp;

    if (SUCCEEDED(pwb->get_Document(&pdisp)))
    {
        pdisp->QueryInterface(IID_PPV_ARG(IOleControl, &poc));

        pdisp->Release();
    }

    return poc;
}
STDMETHODIMP CWebBrowserOC::GetControlInfo(LPCONTROLINFO pCI)
{
    HRESULT hres = E_NOTIMPL;

    // REVIEW: What if we return some docobjects CONTROLINFO here and
    //         we navigate somewhere else. Do we have to know when this
    //         happens and tell our container that the CONTROLINFO has
    //         changed??

    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        hres = poc->GetControlInfo(pCI);
        poc->Release();
    }

    return hres;
}
STDMETHODIMP CWebBrowserOC::OnMnemonic(LPMSG pMsg)
{
    HRESULT hres = E_NOTIMPL;

    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        hres = poc->OnMnemonic(pMsg);
        poc->Release();
    }

    return hres;
}
HRESULT __stdcall CWebBrowserOC::OnAmbientPropertyChange(DISPID dispid)
{
    IS_INITIALIZED;

    // First let our base class know about the change
    //
    SUPERCLASS::OnAmbientPropertyChange(dispid);

    // Forward ambient property changes down to the docobject
    // if it is something other than offline or silent
    // for offline and silent, we call the methods to set
    // the properties so that we remember it and these 
    // methods forward downwards on their own and so we we
    // end up forwarding twice. 

    if((dispid == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED) || (dispid == DISPID_AMBIENT_SILENT))
    {
        VARIANT_BOOL fAmbient;
        if (SUPERCLASS::_GetAmbientProperty(dispid, VT_BOOL, &fAmbient))
        {
            if (dispid == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED)
            {
                put_Offline(fAmbient);
            } 
            else if(dispid == DISPID_AMBIENT_SILENT) 
            {
                put_Silent(fAmbient);
            }
        }
        // return ; // BharatS 01/20/97
        // APPCOMPAT --- This could be avoided if the forwarding
        // from simply calling put_offline worked fine but it does not
        // and so the second forwarding can be removed when that is fixed


    }
    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        poc->OnAmbientPropertyChange(dispid);
        poc->Release();
    }

    return S_OK;
}
STDMETHODIMP CWebBrowserOC::FreezeEvents(BOOL bFreeze)
{
    // First let our base class know about the change
    //
    SUPERCLASS::FreezeEvents(bFreeze);

    // Forward this down to the docobject
    //
    IOleControl* poc = GetForwardingIOC(_pautoWB2);

    // delegate only if the freezeevents count is balanced when
    // you receive a FALSE. There may be FALSE calls coming in,
    // before we get a chance to delegate the pending freezeevents calls
    // TRUE is always delegated.
    if (poc && (bFreeze || (_cPendingFreezeEvents == 0)))
    {
        poc->FreezeEvents(bFreeze);
    }
    else
    {
        // keeping a total number of FreezeEvents(TRUE) calls 
        // that we have to make up for.
        if ( bFreeze )
        {
            _cPendingFreezeEvents++;
        }
        else 
        {
            // Don't let this go negative, otherwise we'll send 4 billion FreezeEvents(TRUE) 
            // to the DocObject in CWebBrowserOC::_OnSetShellView. (QFE [alanau])(ferhane)
            if (EVAL(_cPendingFreezeEvents > 0))
            {
                _cPendingFreezeEvents --;
            }        
        }
    }

    if (poc)
        poc->Release();

    return S_OK;
}

// CWebBrowserSB just started viewing psvNew - do our OC stuff now
//
void CWebBrowserOC::_OnSetShellView(IShellView* psvNew)
{
    _fDirty = TRUE;
    // NOTE: Document, Type, LocationName, LocationURL, Busy just changed...
    // PropertyChanged(DISPID_LOCATION);
    // NOTE: that is the job of the CBaseBrowser to tell us really.
    //    ideally we would not put this here at all (or in _OnReleaseShellV...
    _SendAdvise(OBJECTCODE_DATACHANGED);    // implies OBJECTCODE_VIEWCHANGED

    // we might have received FreezeEvents(TRUE) calls from the container
    // and if the document was not ready, we might not have had a chance
    // to pass them down the stream. This is the time to make up for it.

    if (_cPendingFreezeEvents > 0)
    {
        IOleControl* poc = GetForwardingIOC(_pautoWB2);

        if (poc)
        {
            for ( ; _cPendingFreezeEvents > 0; _cPendingFreezeEvents-- )
            {
                // Forward this down to the docobject
                poc->FreezeEvents(TRUE);
            }

            poc->Release();
        }
    }
}

// CWebBrowserSB is releasing the currently viewed IShellView
void CWebBrowserOC::_OnReleaseShellView()
{
}


// *** IOleCommandTarget
//
// our version simply forwards to the object below our CWebBrowserSB
//
HRESULT CWebBrowserOC::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (_psb && _psb->_bbd._pctView)
        return _psb->_bbd._pctView->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OLECMDERR_E_UNKNOWNGROUP;
}
HRESULT CWebBrowserOC::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (_psb) 
    {
        if (pguidCmdGroup==NULL) 
        {
            switch(nCmdID) 
            {
            case OLECMDID_STOP:
                {
                    LPITEMIDLIST pidlIntended = (_psb->_bbd._pidlPending) ? ILClone(_psb->_bbd._pidlPending) : NULL;
                    _psb->_CancelPendingNavigation();

                    // We've just canceled the pending navigation.  We may not have a current page!  The following
                    // accomplishes two goals:
                    //
                    //  1.  Gives the user some information about the frame that couldn't navigate.
                    //  2.  Allows the browser to reach READYSTATE_COMPLETE
                    //
                    if (!_psb->_bbd._pidlCur)
                    {
                        // We display the navcancl.htm page in most cases.
                        // However, we won't display it if the call has 
                        // explicitly specified that we shouldn't.
                        //
                        if (  !pvarargIn
                           || V_VT(pvarargIn) != VT_BOOL
                           || V_BOOL(pvarargIn) == VARIANT_TRUE)
                        {
                            TCHAR   szResURL[MAX_URL_STRING];

                            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                   HINST_THISDLL,
                                                   ML_CROSSCODEPAGE,
                                                   TEXT("navcancl.htm"),
                                                   szResURL,
                                                   ARRAYSIZE(szResURL),
                                                   TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hr))
                            {
                                _psb->_ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                    }

                    if(pidlIntended)
                        ILFree(pidlIntended);
                    break;  // Note that we need to fall through.
                }

            case OLECMDID_ENABLE_INTERACTION:
                if (pvarargIn && pvarargIn->vt == VT_I4) 
                {
                    _psb->_fPausedByParent = BOOLIFY(pvarargIn->lVal);
                }
                break;  // Note that we need to fall through.
            }

            hr = S_OK;
            // WARNING: fall through to forward down 
        }
        if (_psb->_bbd._pctView)
            hr = _psb->_bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return hr;
}

//
//  We hit this code if the normal IOleCommandTarget chain is broken (such as
// browser band in the browser bar). In this case, we get the command target
// to the top level browser and send OLECMDID_SETDOWNLOADSTATE to it.
//
// Returns:
//      S_OK    If we found the top level browser and it processed it.
//      hresRet Otherwise
//
HRESULT CWebBrowserOC::_SetDownloadState(HRESULT hresRet, DWORD nCmdexecopt, VARIANTARG *pvarargIn)
{
    ASSERT(hresRet == OLECMDERR_E_UNKNOWNGROUP || hresRet == OLECMDERR_E_NOTSUPPORTED);

    IOleCommandTarget* pcmdtTop;
    if (_psb && SUCCEEDED(_psb->_QueryServiceParent(SID_STopLevelBrowser, IID_PPV_ARG(IOleCommandTarget, &pcmdtTop)))) 
    {
        ASSERT(pcmdtTop != _psb);
        VARIANTARG var;
        if (pvarargIn && pvarargIn->lVal) 
        {
            ASSERT(pvarargIn->vt == VT_I4 || pvarargIn->vt == VT_BOOL || pvarargIn->vt == VT_UNKNOWN);
            //
            // Notice that we pass the pointer to this OC so that the top
            // level browser can keep track of it. This is a new behavior
            // which is different from IE 3.0. 
            //
            var.vt = VT_UNKNOWN;
            var.punkVal = SAFECAST(this, IOleCommandTarget*);
        }
        else
        {
            var.vt = VT_BOOL;
            var.lVal = FALSE;
        }
        HRESULT hresT = pcmdtTop->Exec(NULL, OLECMDID_SETDOWNLOADSTATE, nCmdexecopt, &var, NULL);

        TraceMsg(DM_FORSEARCHBAND, "WBOC::_SetDownloadState pcmdTop->Exec returned %x", hresT);

        if (SUCCEEDED(hresT)) 
        {
            hresRet = S_OK;
        }
        pcmdtTop->Release();
    } 
    else 
    {
        TraceMsg(DM_FORSEARCHBAND, "WBOC::_SetDownloadState can't find the top guy");
    }

    return hresRet;
}

#ifdef FEATURE_FRAMES

// *** ITargetEmedding ***

HRESULT CWebBrowserOC::GetTargetFrame(ITargetFrame **ppTargetFrame)
{
    if (_psb)
    {
        return _psb->QueryServiceItsOwn(IID_ITargetFrame2, IID_PPV_ARG(ITargetFrame, ppTargetFrame));
    }
    else
    {
        *ppTargetFrame = NULL;
        return E_FAIL;
    }
}

#endif

// *** CImpIConnectionPoint override ***
CConnectionPoint* CWebBrowserOC::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint *pccp;

    // Warning: Some apps (MSDN for one) passes in IID_IDispatch and
    // expect the ole events.  So we need to be careful on which one we return.
    //
    if (fdisp && IsEqualIID(iid, IID_IDispatch))
    {
        if (_pObjectInfo->lVersion == VERSION_1)
            pccp = &m_cpWB1Events;
        else
            pccp = &m_cpEvents;
    }

    else if (IsEqualIID(iid, DIID_DWebBrowserEvents2))
    {
        pccp = &m_cpEvents;
    }
    else if (IsEqualIID(iid, DIID_DWebBrowserEvents))
    {
        pccp = &m_cpWB1Events;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CWebBrowserOC::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 3,
                m_cpEvents.CastToIConnectionPoint(),
                m_cpWB1Events.CastToIConnectionPoint(),
                m_cpPropNotify.CastToIConnectionPoint());
}



/*
** Properties and Methods we implement
*/

// Invoke perf
//
HRESULT CWebBrowserOC::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hres = S_OK;

    // we should probably check that riid is IID_NULL...

   _fInsideInvokeCall = TRUE;   // we're inside an invoke

    switch (dispidMember)
    {
    // handle ReadyState immediately for performance (avoid oleaut a tad longer)...
    case DISPID_READYSTATE:
        ASSERT(pdispparams && pdispparams->cArgs==0);
        if (EVAL(pvarResult) && (wFlags & DISPATCH_PROPERTYGET))
        {
            ZeroMemory(pvarResult, SIZEOF(*pvarResult));
            pvarResult->vt = VT_I4;
            hres = get_ReadyState((READYSTATE*)(&pvarResult->lVal));
            goto Cleanup;
        }
        break; // let the below invoke call give us the proper error value

    // forward these two down to our embedded object so that
    // Trident can handle cross-frame security correctly
    case DISPID_SECURITYCTX:
    case DISPID_SECURITYDOMAIN:
    {
        IDispatch* pdisp;
        if (SUCCEEDED(_pautoWB2->get_Document(&pdisp)))
        {
            hres = pdisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            pdisp->Release();
            goto Cleanup;
        }

        break;
    }

    default:
        // handle the default after the switch.
        break;
    }

    hres = CShellOcx::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

Cleanup:

   _fInsideInvokeCall = FALSE;   // We are leaving the invoke

    return hres;
}


// IObjectSafety override so script can't talk to us from an unsafe zone
HRESULT CWebBrowserOC::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    HRESULT hr = CObjectSafety::SetInterfaceSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);

    // If we are hosted in IEXPLORER.EXE or EXPLORER.EXE (eventually this should be the default, but we need longer app-compat simmer time)
    // And we can get a URL from our parent
    // And the policy for that URL is "disable WebOC script access" (default for internet zone)
    if (GetModuleHandle(TEXT("EXPLORER.EXE")) || GetModuleHandle(TEXT("IEXPLORE.EXE")))
    {
        IHTMLDocument2 *pHtmlDoc;
        if (SUCCEEDED(GetHTMLDoc2(_pcli, &pHtmlDoc))) // if the parent isn't trident, then we must be client-side code hosting weboc directly - no need to bail
        {
            BSTR bstrURL;
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrURL)))
            {
                DWORD dwPolicy = 0;
                DWORD dwContext = 0;

                ZoneCheckUrlEx(bstrURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_ACTIVEX_NO_WEBOC_SCRIPT, 0, NULL);

                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    // Then we don't support script access - override whatever we were told above.
                    hr = E_ACCESSDENIED;
                }

                SysFreeString(bstrURL);
            }
            pHtmlDoc->Release();
        }
    }

    return hr;
}


//
// Wrap around iedisp
//

#define WRAP_WB2(fn, args, nargs) \
    HRESULT CWebBrowserOC :: fn args { return _pautoWB2-> fn nargs; }
#define WRAP_WB2_DESIGN(fn, args, nargs) \
    HRESULT CWebBrowserOC :: fn args { if (_IsDesignMode()) return E_FAIL; else return _pautoWB2-> fn nargs; }

// IWebBrowser methods
//
WRAP_WB2_DESIGN(GoBack, (), ())
WRAP_WB2_DESIGN(GoForward, (), ())
WRAP_WB2_DESIGN(GoHome, (), ())
WRAP_WB2_DESIGN(GoSearch, (), ())
WRAP_WB2_DESIGN(Refresh, (), ())
WRAP_WB2_DESIGN(Refresh2, (VARIANT * Level), (Level))
WRAP_WB2_DESIGN(Stop, (), ())
WRAP_WB2(get_Type, (BSTR * pbstrType), (pbstrType))
WRAP_WB2(get_LocationName, (BSTR * pbstrLocationName), (pbstrLocationName))
WRAP_WB2(get_LocationURL, (BSTR * pbstrLocationURL), (pbstrLocationURL))
WRAP_WB2(get_Busy, (VARIANT_BOOL * pBool), (pBool))

HRESULT CWebBrowserOC::Navigate(BSTR      URL,
                        VARIANT * Flags,
                        VARIANT * TargetFrameName,
                        VARIANT * PostData,
                        VARIANT * Headers)
{
    HRESULT hr = S_OK;

    if (_dwSafetyOptions)
    {
        hr = WrapSpecialUrl(&URL);
        if (SUCCEEDED(hr))
        {
            if (!AccessAllowedToNamedFrame(TargetFrameName))
                hr = E_ACCESSDENIED;
            else
                hr = _pautoWB2->Navigate(URL, Flags, TargetFrameName, PostData, Headers);
        }
    }
    else
        hr = _pautoWB2->Navigate(URL, Flags, TargetFrameName, PostData, Headers);

    return hr;
}

HRESULT CWebBrowserOC::get_Application(IDispatch **ppDisp)
{
    PROPMSG(TEXT("get_Application"));
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CWebBrowserOC::get_Parent(IDispatch **ppDisp)
{
    HRESULT hres = E_FAIL;
    PROPMSG(TEXT("get_Parent"));

    if (ppDisp)
        *ppDisp = NULL;

    if (_pcli)
    {
        IOleContainer* pContainer;

        hres = _pcli->GetContainer(&pContainer);
        if (SUCCEEDED(hres))
        {
            hres = pContainer->QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));

            if (SUCCEEDED(hres) && _dwSafetyOptions)
                hres = MakeSafeForScripting((IUnknown**)ppDisp);

            pContainer->Release();
        }
        else
        {
            PROPMSG(TEXT("get_Parent couldn't find the container!"));
        }
    }
    else
    {
        PROPMSG(TEXT("get_Parent does not have _pcli!"));
    }

    // if there was an error *ppDisop is NULL, and so VB realizes 
    // this is a "nothing" dispatch -- returning failure causes 
    // error boxes to appear. ugh.

    return S_OK;
}
HRESULT CWebBrowserOC::get_Container(IDispatch **ppDisp)
{
    // Container property is "same as parent" unless there is no parent.
    // Since we always have a parent, let get_Parent handle this.
    PROPMSG(TEXT("get_Containter passing off to get_Parent"));
    return get_Parent(ppDisp);
}
HRESULT CWebBrowserOC::get_Document(IDispatch **ppDisp)
{
    HRESULT hres = _pautoWB2->get_Document(ppDisp);

    if (FAILED(hres) && ppDisp)
    {
        *ppDisp = NULL;
    }

    if (SUCCEEDED(hres) && _dwSafetyOptions)
        hres = MakeSafeForScripting((IUnknown**)ppDisp);


    // if there was an error *ppDisop is NULL, and so VB realizes 
    // this is a "nothing" dispatch -- returning failure causes 
    // error boxes to appear. ugh.

    return S_OK;
}

HRESULT CWebBrowserOC::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    PROPMSG(TEXT("get_TopLevelContainer"));

    if (!pBool)
        return E_INVALIDARG;

    *pBool = FALSE;

    return S_OK;
}


void FireEvent_OnSetWindowPos(IUnknown *punkCPContainer, DISPID dispid, long lValue)
{
    VARIANTARG args[1];
    IUnknown_CPContainerInvokeParam(punkCPContainer, DIID_DWebBrowserEvents2,
                                    dispid, args, 1, VT_I4, lValue);
}

HRESULT CWebBrowserOC::get_Left(long * pl)
{
    *pl = _rcPos.left;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Left(long Left)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETLEFT, Left);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.left = Left;

        return _pipsite->OnPosRectChange(&rc);
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Left has no _pipsite to notify!");
        return E_UNEXPECTED;
    }
}
HRESULT CWebBrowserOC::get_Top(long * pl)
{
    *pl = _rcPos.top;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Top(long Top)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETTOP, Top);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.top = Top;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Top has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}
HRESULT CWebBrowserOC::get_Width(long * pl)
{
    *pl = _rcPos.right - _rcPos.left;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Width(long Width)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETWIDTH, Width);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.right = rc.left + Width;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Width has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}
HRESULT CWebBrowserOC::get_Height(long * pl)
{
    *pl = _rcPos.bottom - _rcPos.top;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Height(long Height)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETHEIGHT, Height);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.bottom = rc.top + Height;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Height has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}

// IWebBrowserApp methods
//
WRAP_WB2_DESIGN(PutProperty, (BSTR szProperty, VARIANT vtValue), (szProperty, vtValue))
WRAP_WB2_DESIGN(GetProperty, (BSTR szProperty, VARIANT * pvtValue), (szProperty, pvtValue))
WRAP_WB2(get_FullName, (BSTR * pbstrFullName), (pbstrFullName))
WRAP_WB2(get_Path, (BSTR * pbstrPath), (pbstrPath))

HRESULT CWebBrowserOC::Quit()
{
    return E_FAIL;
}
HRESULT CWebBrowserOC::ClientToWindow(int * pcx, int * pcy)
{
    LONG lX = *pcx, lY = *pcy;

    VARIANTARG args[2];
    IUnknown_CPContainerInvokeParam(_pautoEDS, DIID_DWebBrowserEvents2,
                                    DISPID_CLIENTTOHOSTWINDOW, args, 2, 
                                    VT_I4 | VT_BYREF, &lX,
                                    VT_I4 | VT_BYREF, &lY);
    *pcx = lX;
    *pcy = lY;

    return S_OK;
}
HRESULT CWebBrowserOC::get_Name(BSTR * pbstrName)
{
    *pbstrName = LoadBSTR(IDS_SHELLEXPLORER);
    return *pbstrName ? S_OK : E_OUTOFMEMORY;
}
HRESULT CWebBrowserOC::get_HWND(LONG_PTR * pHWND)
{
    *pHWND = NULL;
    return E_FAIL;
}

HRESULT CWebBrowserOC::get_FullScreen(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(_fFullScreen);
    return S_OK;
}
HRESULT CWebBrowserOC::put_FullScreen(VARIANT_BOOL Value)
{
    _fFullScreen = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONFULLSCREEN, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_Visible(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(_fVisible);
    return S_OK;
}
HRESULT CWebBrowserOC::put_Visible(VARIANT_BOOL Value)
{
    _fVisible = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONVISIBLE, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_StatusBar(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(!_fNoStatusBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_StatusBar(VARIANT_BOOL Value)
{
    _fNoStatusBar = !VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONSTATUSBAR, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_StatusText(BSTR * pbstr)
{
    *pbstr = NULL;
    return E_FAIL;
}
HRESULT CWebBrowserOC::put_StatusText(BSTR bstr)
{
    return E_FAIL;
}
HRESULT CWebBrowserOC::get_ToolBar(int * pBool)
{
    // BOGUS: variant values for int type
    *pBool = (!_fNoToolBar) ? VARIANT_TRUE : VARIANT_FALSE; 
    return S_OK;
}
HRESULT CWebBrowserOC::put_ToolBar(int iToolbar)
{
    _fNoToolBar = (!iToolbar) ? TRUE : FALSE;
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONTOOLBAR, iToolbar);
    return S_OK;
}
HRESULT CWebBrowserOC::get_MenuBar(VARIANT_BOOL * pvbMenuBar)
{
    *pvbMenuBar = BOOL_TO_VARIANTBOOL(!_fNoMenuBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_MenuBar(VARIANT_BOOL vbMenuBar)
{
    _fNoMenuBar = !VARIANTBOOL_TO_BOOL(vbMenuBar);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONMENUBAR, vbMenuBar);
    return S_OK;
}
HRESULT CWebBrowserOC::get_AddressBar(VARIANT_BOOL * pvbAddressBar)
{
    *pvbAddressBar = BOOL_TO_VARIANTBOOL(!_fNoAddressBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_AddressBar(VARIANT_BOOL vbAddressBar)
{
    _fNoAddressBar = !VARIANTBOOL_TO_BOOL(vbAddressBar);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONADDRESSBAR, vbAddressBar);
    return S_OK;
}

HRESULT CWebBrowserOC::put_Resizable(VARIANT_BOOL vbResizable)
{
    FireEvent_OnAdornment(_pautoEDS, DISPID_WINDOWSETRESIZABLE, vbResizable);
    return S_OK;
}

// IWebBrowser2 methods
//
WRAP_WB2_DESIGN(QueryStatusWB, (OLECMDID cmdID, OLECMDF * pcmdf), (cmdID, pcmdf))
WRAP_WB2_DESIGN(ShowBrowserBar, (VARIANT * pvaClsid, VARIANT * pvaShow, VARIANT * pvaSize), (pvaClsid, pvaShow, pvaSize))
WRAP_WB2(get_ReadyState, (READYSTATE * plReadyState), (plReadyState))
WRAP_WB2(get_RegisterAsDropTarget, (VARIANT_BOOL * pbRegister), (pbRegister))
WRAP_WB2(put_RegisterAsDropTarget, (VARIANT_BOOL bRegister), (bRegister))
WRAP_WB2(get_Offline, (VARIANT_BOOL * pbOffline), (pbOffline))
WRAP_WB2(put_Offline, (VARIANT_BOOL bOffline), (bOffline))
WRAP_WB2(get_Silent, (VARIANT_BOOL * pbSilent), (pbSilent))
WRAP_WB2(put_Silent, (VARIANT_BOOL bSilent), (bSilent))


HRESULT
CWebBrowserOC::Navigate2(VARIANT * URL,
                         VARIANT * Flags,
                         VARIANT * TargetFrameName,
                         VARIANT * PostData,
                         VARIANT * Headers)
{
    HRESULT hr = S_OK;

    if (_dwSafetyOptions && ((WORD)VT_BSTR == URL->vt) && URL->bstrVal)
    {
        hr = WrapSpecialUrl(&URL->bstrVal);
        if (SUCCEEDED(hr))
        {
            if (!AccessAllowedToNamedFrame(TargetFrameName))
                hr = E_ACCESSDENIED;
            else
                hr = _pautoWB2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers);
        }
    }
    else
        hr = _pautoWB2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers);

    return hr;
}

HRESULT  CWebBrowserOC::ExecWB(OLECMDID cmdID,  OLECMDEXECOPT cmdexecopt, 
                      VARIANT * pvaIn, VARIANT * pvaOut)
{ 
    HRESULT hr = E_FAIL;

    if ( !_IsDesignMode() )
    {

        // do not process print preview commands given from script for security reasons
        // Ferhane IE60 Bug#16693
        // Print templates have extra privelages.
        // Print/Preview allows you to specify a custom print template URL as a BSTR or in a safearray.
        // This is a security hole if available from script.  Disallow it.
        if (    _fInsideInvokeCall
            && (    cmdID == OLECMDID_PRINTPREVIEW
                ||  cmdID == OLECMDID_PRINT)
            &&  pvaIn
            &&  (   V_VT(pvaIn) == VT_BSTR
                ||  V_VT(pvaIn) == VT_ARRAY)
            )
        {
            return E_ACCESSDENIED;      // More meaningful than E_FAIL
        }

        // if _dwSafetyOptions are set then we are suppossed to be 
        // running in secure mode. This means the UI-less printing should NOT
        // be honored.  This is a security issue, see ie bug 23620.
        // otherwise just let the call go through
        if ((cmdID == OLECMDID_PRINT) && _dwSafetyOptions)
        {
            // so if the UI-less- request flag is set we need to unset it.
            if (cmdexecopt == OLECMDEXECOPT_DONTPROMPTUSER)
                cmdexecopt = OLECMDEXECOPT_DODEFAULT;
        }

        // If the optional argument pvargin is not specified make it VT_EMPTY.
        if (pvaIn && (V_VT(pvaIn) == VT_ERROR) && (V_ERROR(pvaIn) == DISP_E_PARAMNOTFOUND))
        {
            V_VT(pvaIn) = VT_EMPTY;
            V_I4(pvaIn) = 0;
        }

        // If the optional argument pvargin is not specified make it VT_EMPTY.
        if (pvaOut && (V_VT(pvaOut) == VT_ERROR) && (V_ERROR(pvaOut) == DISP_E_PARAMNOTFOUND))
        {
            V_VT(pvaOut) = VT_EMPTY;
            V_I4(pvaOut) = 0;
        }

        if (    cmdID == OLECMDID_PASTE
            ||  cmdID == OLECMDID_COPY
            ||  cmdID == OLECMDID_CUT)
        {
            BSTR bstrUrl;

            if (_dwSafetyOptions)
                return S_OK;

            if (SUCCEEDED(get_LocationURL(&bstrUrl)))
            {
                DWORD dwPolicy = 0;
                DWORD dwContext = 0;

                ZoneCheckUrlEx(bstrUrl, &dwPolicy, SIZEOF(dwPolicy), &dwContext, SIZEOF(dwContext),
                               URLACTION_SCRIPT_PASTE, 0, NULL);

                SysFreeString(bstrUrl);

                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                    return S_OK;
            }
        }

        // now pass along the call
        hr = _pautoWB2->ExecWB(cmdID, cmdexecopt, pvaIn, pvaOut); 
    }

    return hr;
}

HRESULT CWebBrowserOC::get_RegisterAsBrowser(VARIANT_BOOL * pbRegister)
{
    *pbRegister = BOOL_TO_VARIANTBOOL(_fShouldRegisterAsBrowser);
    return S_OK;
}

HRESULT CWebBrowserOC::put_RegisterAsBrowser(VARIANT_BOOL bRegister)
{
    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(bRegister);

    if (bRegister)
        _RegisterWindow();
    else
        _UnregisterWindow();

    return S_OK;
}

HRESULT CWebBrowserOC::get_TheaterMode(VARIANT_BOOL * pvbTheaterMode)
{
    *pvbTheaterMode = BOOL_TO_VARIANTBOOL(_fTheaterMode);
    return S_OK;
}
HRESULT CWebBrowserOC::put_TheaterMode(VARIANT_BOOL Value)
{
    _fTheaterMode = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONTHEATERMODE, Value);
    return S_OK;
}

// IExpDispSupport
//
HRESULT CWebBrowserOC::OnTranslateAccelerator(MSG *pMsg,DWORD grfModifiers)
{
    return IUnknown_TranslateAcceleratorOCS(_pcli, pMsg, grfModifiers);
}

HRESULT CWebBrowserOC::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
    VARIANT * pVarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    // We get first crack at this
    HRESULT hres = _pautoEDS->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);

    // let the container get second crack at ambient properties
    //
    if (FAILED(hres))
    {
        if (!_pDispAmbient)
        {
            if (_pcli)
                _pcli->QueryInterface(IID_PPV_ARG(IDispatch, &_pDispAmbient));
        }
        if (_pDispAmbient)
        {
            hres = _pDispAmbient->Invoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);
        }
    }
   
    return hres;    
}

// IExpDispSupportOC
//
HRESULT CWebBrowserOC::OnOnControlInfoChanged()
{
    HRESULT hres = E_NOTIMPL;

    if (_pcli)
    {
        IOleControlSite* pocs;
        if (SUCCEEDED(_pcli->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
        {
            hres = pocs->OnControlInfoChanged();
            pocs->Release();
        }
    }

    return hres;
}
HRESULT CWebBrowserOC::GetDoVerbMSG(MSG *pMsg)
{
    if (_pmsgDoVerb)
    {
        *pMsg = *_pmsgDoVerb;
        return S_OK;
    }

    return E_FAIL;
}


HRESULT CWebBrowserOC::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    _InitDefault();

    ASSERT(_psb);

    HRESULT hr = E_FAIL;

    if (_psb)
    {
        hr = _psb->LoadHistory(pstm, pbc);
    
        _OnLoaded(FAILED(hr));

        TraceMsg(TF_TRAVELLOG, "WBOC::LoadHistory pstm = %x, pbc = %x, hr = %x", pstm, pbc, hr);
    }
    return hr;
}

HRESULT CWebBrowserOC::SaveHistory(IStream *pstm)
{
    ASSERT(_psb);
    
    TraceMsg(TF_TRAVELLOG, "WBOC::SaveHistory calling psb->SaveHistory");

    return _psb ? _psb->SaveHistory(pstm) : E_FAIL;
}

HRESULT CWebBrowserOC::SetPositionCookie(DWORD dw)
{
    ASSERT(_psb);

    TraceMsg(TF_TRAVELLOG, "WBOC::SetPositionCookie calling psb->GetPositionCookie");
    return _psb ? _psb->SetPositionCookie(dw) : E_FAIL;
}

HRESULT CWebBrowserOC::GetPositionCookie(DWORD *pdw)
{
    ASSERT(_psb);

    TraceMsg(TF_TRAVELLOG, "WBOC::GetPositionCookie calling psb->GetPositionCookie");
    return _psb ? _psb->GetPositionCookie(pdw) : E_FAIL;
}

HMODULE CWebBrowserOC::_GetBrowseUI()
{
    if (_hBrowseUI == HMODULE_NOTLOADED)
    {
        _hBrowseUI = LoadLibrary(TEXT("browseui.dll"));
    }

    return _hBrowseUI;
}

BOOL CWebBrowserOC::AccessAllowedToNamedFrame(VARIANT *varTargetFrameName)
{
    BOOL            fAllowed        = TRUE;
    HRESULT         hr              = S_OK;
    ITargetFrame2 * pTopTargetFrame = NULL;
    IUnknown      * punkTargetFrame = NULL;
    IWebBrowser2  * pIWB2Target     = NULL;
    BSTR            bstrTargetUrl   = NULL;
    BSTR            bstrSrcUrl      = NULL;

    if (varTargetFrameName && ((WORD)VT_BSTR == varTargetFrameName->vt) && varTargetFrameName->bstrVal)
    {
        IEFrameAuto * piefa = NULL;
        
        hr = _pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa));
        if (SUCCEEDED(hr))
        {

            hr = TargetQueryService((IShellBrowser *)piefa, IID_PPV_ARG(ITargetFrame2, &pTopTargetFrame));

            if (SUCCEEDED(hr))
            {
                hr = pTopTargetFrame->FindFrame(
                              varTargetFrameName->bstrVal,
                              FINDFRAME_JUSTTESTEXISTENCE,
                              &punkTargetFrame);
                if (SUCCEEDED(hr) && punkTargetFrame)
                {
                    // yes, we found a frame with that name.  QI for the automation
                    // interface on that frame.
                    hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pIWB2Target));

                    if (SUCCEEDED(hr))
                    {
                        hr = pIWB2Target->get_LocationURL(&bstrTargetUrl);

                        if (SUCCEEDED(hr))
                        {
                            hr = _pautoWB2->get_LocationURL(&bstrSrcUrl);
                            if (SUCCEEDED(hr))
                            {
                                fAllowed = AccessAllowed(_pcli, bstrSrcUrl, bstrTargetUrl);
                                SysFreeString(bstrSrcUrl);
                            }
                            SysFreeString(bstrTargetUrl);
                        }
                        pIWB2Target->Release();
                    }
                    punkTargetFrame->Release();
                }
                pTopTargetFrame->Release();
            }
            piefa->Release();
        }
    }
    return fAllowed;
}


// The SECURELOCK enumeration must be sorted in order of security level, and we may
// need to insert new values into the middle of the list in future.  So we'll map
// the values to a set of constants.

BOOL SecureLockToIconConstant(int nSecureLock, LONG *plIconConstant)
{
    BOOL fRet = TRUE;

    switch (nSecureLock)
    {
    case SECURELOCK_SET_UNSECURE         : *plIconConstant = secureLockIconUnsecure;          break;
    case SECURELOCK_SET_MIXED            : *plIconConstant = secureLockIconMixed;             break;
    case SECURELOCK_SET_SECUREUNKNOWNBIT : *plIconConstant = secureLockIconSecureUnknownBits; break;
    case SECURELOCK_SET_SECURE40BIT      : *plIconConstant = secureLockIconSecure40Bit;       break;
    case SECURELOCK_SET_SECURE56BIT      : *plIconConstant = secureLockIconSecure56Bit;       break;
    case SECURELOCK_SET_SECURE128BIT     : *plIconConstant = secureLockIconSecure128Bit;      break;
    case SECURELOCK_SET_FORTEZZA         : *plIconConstant = secureLockIconSecureFortezza;    break;
    default:
        // Don't need to fire an event
        fRet = FALSE;
    }

    return fRet;
}

void CWebBrowserOC::_OnSetSecureLockIcon(int lock)  
{
    LONG lIconConstant;

    if (SecureLockToIconConstant(lock, &lIconConstant))
    {
        // Fire the OnUpdateSecurityIcon event only from the DWebBrowserEvents2 connection point

        VARIANTARG args[1];
        IUnknown_CPContainerInvokeParam(_pautoEDS, DIID_DWebBrowserEvents2,
            DISPID_SETSECURELOCKICON, args, 1, VT_I4, lIconConstant);
    }
}

// CWebBrowserSB implementation

CWebBrowserSB::CWebBrowserSB(IUnknown* pauto, CWebBrowserOC* psvo)
        : CBASEBROWSER(NULL)
        , _psvo(psvo)
{
    _Initialize(0, pauto);
}

CWebBrowserSB::~CWebBrowserSB()
{
}

HRESULT CWebBrowserSB::QueryInterface(REFIID riid, void ** ppvObj)
{
    HRESULT hr = CBASEBROWSER::QueryInterface(riid, ppvObj);

    if (FAILED(hr) && (riid == IID_IIsWebBrowserSB))
        hr = CBASEBROWSER::QueryInterface(IID_IUnknown, ppvObj);

    return hr;
}

BOOL VirtualTopLevelBrowser(IOleClientSite * pcls)
{
    IOleContainer * poc;
    BOOL fNonStandard = FALSE;

    if (SUCCEEDED(pcls->GetContainer(&poc)))
    {
        ITargetContainer * ptc;

        // Is our container hosting us?
        if (SUCCEEDED(poc->QueryInterface(IID_PPV_ARG(ITargetContainer, &ptc))))
        {
            fNonStandard = TRUE;
            ptc->Release();
        }
        poc->Release();
    }

    return fNonStandard;
}

HRESULT CWebBrowserSB::SetTopBrowser()
{
    HRESULT hres = CBASEBROWSER::SetTopBrowser();

    if (_fTopBrowser && EVAL(_psvo))
        _fNoTopLevelBrowser = VirtualTopLevelBrowser(_psvo->_pcli);

    return hres;
}


LRESULT CWebBrowserSB::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lret = CBASEBROWSER::WndProcBS(hwnd, uMsg, wParam, lParam);

    switch(uMsg)
    {
    case WM_DESTROY:
        //  Because we won't get WM_NCDESTROY here, we should clean up
        // this member variable here. 
        _bbd._hwnd = NULL;
        break;
    }

    return lret;
}

// *** IOleWindow methods ***

// CBASEBROWSER maps SetStatusTextSB to SendControlMsg,
// so we don't need a CWebBrowserSB::SetStatusTextSB implementation.

HRESULT CWebBrowserSB::_EnableModeless(BOOL fEnable, BOOL fDirection)
{
    HRESULT hres = S_OK;

    CBASEBROWSER::EnableModelessSB(fEnable);

    if (fDirection == DIRECTION_FORWARD_TO_PARENT)
    {
        if (_psvo && _psvo->_pipframe)
        {
            hres = _psvo->_pipframe->EnableModeless(fEnable);
            if (!fEnable && _psvo->_fHostedInVB5)
            {
                // APPHACK: VB5 -- If we haven't put up a dialog between the EnableModelessSB(FALSE) call and this
                // call, we'll end up with a message on the queue that will disable all windows.
                // Let's peek for this message and dispatch it if it is VB5's.
                //
                #define VBM_POSTENABLEMODELESS  0x1006
                #define VBM_MAINCLASS1          TEXT("ThunderRT5Main")
                #define VBM_MAINCLASS2          TEXT("ThunderRT6Main")
                #define VBM_MAINCLASS3          TEXT("ThunderMain")

                MSG   msg;
                HWND  hwnd = NULL;
                TCHAR strBuf[15];

                if (PeekMessage( &msg, NULL, VBM_POSTENABLEMODELESS, VBM_POSTENABLEMODELESS, PM_NOREMOVE))
                {
                    /* On Win95, apparently PeekMessage can return one type of message
                     * outside the range specified: WM_QUIT.  Double-check the message we 
                     * got back.
                     */
                    if (msg.message == VBM_POSTENABLEMODELESS)
                    {
                        GetClassName(msg.hwnd, strBuf, sizeof(strBuf)/sizeof(strBuf[0]));
                        if (StrCmp(strBuf, VBM_MAINCLASS1) == 0 ||
                            StrCmp(strBuf, VBM_MAINCLASS2) == 0 ||
                            StrCmp(strBuf, VBM_MAINCLASS3) == 0)
                        {
                            PeekMessage( &msg, msg.hwnd, VBM_POSTENABLEMODELESS, VBM_POSTENABLEMODELESS, PM_REMOVE);
                            TraceMsg(TF_SHDCONTROL, "shv CWebBrowserSB::_EnableModeless dispatching VBM_POSTENABLEMODELESS" );
                            DispatchMessage(&msg);
                        }
                    }
                }
            }
            else
            {
                // If we're a subframe 
                //   AND the EnableModeless(FALSE) count (_cRefCannotNavigate) has become zero
                //   AND our window is disabled
                // THEN the likely scenario is that VB5 failed to reenable us.  Trace it and reenable
                //   ourselves.
                //
                if (!_fTopBrowser 
                    && _cRefCannotNavigate == 0 
                    && GetWindowLong(_bbd._hwnd, GWL_STYLE) & WS_DISABLED)
                {
                    TraceMsg(TF_WARNING, "shv Subframe was left disabled.  Reenabling ourselves.");
                    EnableWindow(_bbd._hwnd, TRUE);
                }
            }
        }
        else if (_psvo && _psvo->_pcli) 
        {
            IShellBrowser* psbParent;
            if (SUCCEEDED(IUnknown_QueryService(_psvo->_pcli, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psbParent)))) 
            {
                psbParent->EnableModelessSB(fEnable);
                psbParent->Release();
            }
        } 
        else 
        {
            IOIPAMSG(TEXT("_EnableModeless NOT forwarding on to _pipframe"));
        }
    }
    else // DIRECTION_FORWARD_TO_CHILD
    {
        ASSERT(fDirection == DIRECTION_FORWARD_TO_CHILD);
        if (_bbd._psv)
        {
            hres = _bbd._psv->EnableModelessSV(fEnable);
        }
        else
        {
            IOIPAMSG(TEXT("_EnableModeless NOT forwarding on to _psv"));
        }
    }

    return hres;
}

HRESULT CWebBrowserSB::EnableModelessSB(BOOL fEnable)
{
    return _EnableModeless(fEnable, DIRECTION_FORWARD_TO_PARENT);
}

HRESULT CWebBrowserSB::_TranslateAccelerator(LPMSG lpmsg, WORD wID, BOOL fDirection)
{
    // see if we handle it
    HRESULT hr = CBASEBROWSER::TranslateAcceleratorSB(lpmsg, wID);
    if (hr == S_OK)
    {
        IOIPAMSG(TEXT("_TranslateAccelerator: CBASEBROWSER's TranslateAcceleratorSB handled it"));
    }
    else if (fDirection == DIRECTION_FORWARD_TO_PARENT)
    {
        if (_psvo && _psvo->_pipframe)
        {
            hr = _psvo->_pipframe->TranslateAccelerator(lpmsg, wID);
        }
        else
        {
            IOIPAMSG(TEXT("_TranslateAccelerator NOT forwarding on to _pipframe"));
            hr = S_FALSE;
        }
    }
    else // fDirection == DIRECTION_FORWARD_TO_CHILD
    {
        if (_bbd._psv)
        {
            hr = _bbd._psv->TranslateAccelerator(lpmsg);
        }
        else
        {
            IOIPAMSG(TEXT("_TranslateAccelerator NOT forwarding on to _psv"));
            hr = S_FALSE;
        }
    }

    return hr;
}

HRESULT CWebBrowserSB::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    return _TranslateAccelerator(lpmsg, wID, DIRECTION_FORWARD_TO_PARENT);
}

HRESULT CWebBrowserSB::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT * pret)
{
    // let CBASEBROWSER try first so we get automation notifications working
    HRESULT hres = CBASEBROWSER::SendControlMsg(id, uMsg, wParam, lParam, pret);

    // if we're in a blocking frame, our GetControlWindow above will fail
    // causing CBASEBROWSER to fail. try to map to an IOleInPlaceFrame call.
    if (FAILED(hres) && _psvo)
    {
        // forward status bar text changes to the frame.
        if ((id == FCW_STATUS) &&
            (uMsg == SB_SETTEXT || uMsg == SB_SETTEXTW) && // trying to set status text
            (!(wParam & SBT_OWNERDRAW)) &&  // we don't own the window -- this can't work
            (((wParam & 0x00FF) == 0x00FF) || ((wParam & 0x00FF)== 0))) // simple or 0th item
        {
            WCHAR szStatusText[256];

            if (uMsg == SB_SETTEXT) {
                if (lParam)
                {
                    SHTCharToUnicode((LPTSTR)lParam, szStatusText, ARRAYSIZE(szStatusText));
                }
                else
                {
                    szStatusText[0] = L'\0';
                }

                lParam = (LPARAM) szStatusText;
            }
            else if (!lParam)
            {
                // uMsg == SB_SETTEXTW
                // Found a container that doesn't like null string pointers.  Pass an empty string instead.
                // (IE v 4.1 bug 64629)
                szStatusText[0] = 0;
                lParam = (LPARAM) szStatusText;
            }

            if (_psvo->_pipframe)
            {
                if (pret)
                {
                    *pret = 0;
                }
                hres = _psvo->_pipframe->SetStatusText((LPCOLESTR)lParam);
            }
            else
            {
                IOIPAMSG(TEXT("SetStatusTextSB NOT forwarding on to _pipframe"));
            }
        }
    }

    return hres;
}


HRESULT CWebBrowserSB::OnViewWindowActive(struct IShellView * psv)
{
    if (_psvo)
    {
        // The view is notifying us that it just went UIActive,
        // we need to update our state. OC_UIACTIVE normally
        // tells the view to UIActivate itself, but in this case
        // it already is. Avoid an infinite loop and pass FALSE.
        _psvo->_DoActivateChange(NULL, OC_UIACTIVE, FALSE);
    }

    return CBASEBROWSER::OnViewWindowActive(psv);
}


LRESULT CWebBrowserSB::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // explicitly do nothing...
    // this is just to override CBASEBROWSER's _DefWindowProc.
    return 0;
}

void CWebBrowserSB::_ViewChange(DWORD dwAspect, LONG lindex)
{
    //
    // forward this notify up to the OC's OBJECTCODE_VIEWCHANGE handler so it
    // gets forwarded on to our container.
    //
    if (_psvo)
        _psvo->_ViewChange(dwAspect, lindex);

    //
    // also let the base browser handle this view change in case nobody else is
    // handling palette messages.  most of the time this will be a nop but in
    // the case where a WM_QUERYNEWPALETTE makes it down to us this will allow
    // us to manage the palette properly.
    //
    CBASEBROWSER::_ViewChange(dwAspect, lindex);
}

HRESULT CWebBrowserSB::ActivatePendingView()
{
    CVOCBMSG(TEXT("_ActivatePendingView"));

    // CBASEBROWSER::_ActivatePendingView will send a NavigateComplete
    // event. During this event our parent may destroy us. We then fault
    // dereferencing _psvo below. So we need to wrap this function with
    // an AddRef/Release.  (bug 15424)
    //
    AddRef();

    HRESULT hres = CBASEBROWSER::ActivatePendingView();

    if (SUCCEEDED(hres) && _psvo)
        _psvo->_OnSetShellView(_bbd._psv);

    Release();

    return hres;
}

HRESULT CWebBrowserSB::ReleaseShellView(void)
{
    CVOCBMSG(TEXT("_ReleaseShellView"));

    if (_psvo)
        _psvo->_OnReleaseShellView();

    return CBASEBROWSER::ReleaseShellView();
}


/// IBrowserService stuff
HRESULT CWebBrowserSB::GetParentSite(struct IOleInPlaceSite** ppipsite)
{
    HRESULT hres = E_FAIL;  // assume error
    *ppipsite = NULL;        // assume error

    if (_psvo)
    {
        if (_psvo->_pipsite) 
        {
            *ppipsite = _psvo->_pipsite;
            _psvo->_pipsite->AddRef();
            hres = S_OK;
        } 
        else if (_psvo->_pcli) 
        {
            hres = _psvo->_pcli->QueryInterface(IID_PPV_ARG(IOleInPlaceSite, ppipsite));
        }
        else 
        {
            // Is it expected?
            TraceMsg(DM_WARNING, "CWBSB::GetParentSite called when _pcli is NULL");
        }
    }

    return hres;
}

#ifdef FEATURE_FRAMES
HRESULT CWebBrowserSB::GetOleObject(struct IOleObject** ppobjv)
{
    if (_psvo == NULL)
    {
        *ppobjv = NULL;
        return E_FAIL;
    }
    return _psvo->QueryInterface(IID_PPV_ARG(IOleObject, ppobjv));
}
#endif

HRESULT CWebBrowserSB::SetNavigateState(BNSTATE bnstate)
{
    // Do our own things (such as firing events and update _fNavigate).
    HRESULT hres = CBASEBROWSER::SetNavigateState(bnstate);

    //
    // Then, tell the container to update the download state.
    // This will start the animation if this OC is either in a frameset
    // or in a browser band.
    //
    VARIANTARG var;
    var.vt = VT_I4;
    var.lVal = _fNavigate;
    Exec(NULL, OLECMDID_SETDOWNLOADSTATE, 0, &var, NULL);

    return hres;
}


LRESULT CWebBrowserSB::OnNotify(LPNMHDR pnm)
{
    switch(pnm->code) 
    {
    case SEN_DDEEXECUTE:
    {
        IShellBrowser *psbTop;
        if (pnm->idFrom == 0 && SUCCEEDED(_QueryServiceParent(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psbTop)))) 
        {   
            HWND hwndTop;
            
            psbTop->GetWindow(&hwndTop);
            psbTop->Release();
            if (psbTop != this)
                return SendMessage(hwndTop, WM_NOTIFY, 0, (LPARAM)pnm);
        }
        break;
    }

    default:
        return CBASEBROWSER::OnNotify(pnm);
    }

    return S_OK;
}

// IServiceProvider stuff
//

HRESULT CWebBrowserSB::_QueryServiceParent(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;

    // Pass it on to our parent
    if (_psvo && _psvo->_pcli)
    {
        hres = IUnknown_QueryService(_psvo->_pcli, guidService, riid, ppvObj);
    }
    else
    {
        CVOCBMSG(TEXT("QueryService doesn't have _pipsite!"));
    }

    return hres;
}

// NOTES:
//  If SID_STopLevelBrowser, go to parent (upto the top level browser)
//  If SID_SWebBrowserApp, go to parent (up to the top level browser automation)
//  If SID_SContainerDispatch, expose CWebBrowserOC (instead of _pauto)
//  Then, try CBASEBROWSER::QueryService, which will handle SID_SHlinkFrame,
//  SID_SUrlHistory, SID_SShellBrowser, etc.
//  If all fails and not SID_SShellBrowser, then we go up the parent chain.
//
HRESULT CWebBrowserSB::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;  // service object not found

    *ppvObj = NULL; // assume error

    // if the guidService is SID_QIClientSite then delegate the iid to the 
    // container through a queryinterface call.
    if (_psvo && _psvo->_pcli && IsEqualGUID( guidService, SID_QIClientSite))
    {
        return _psvo->_pcli->QueryInterface( riid, ppvObj);
    }

    // If guidService is SID_STopLevelBrowser, we should not ask the super
    // class to handle. Instead, we ask the parent to handle (if any).
    if (IsEqualGUID(guidService, SID_STopLevelBrowser) || 
        IsEqualGUID(guidService, SID_STopWindow)) 
    {
        // APPCOMPAT: WebBrowser is not supposed to respond to QS(SID_SInetExp) because
        //  it does not support IWebBrowserApp. However, rejecting this causes
        //  a stack fault when opening a frame-set. We need to find out what is causing
        //  this stack fault but I'll backup this delta for now to stop GPF.
        //
        //   || IsEqualGUID(guidService, SID_SWebBrowserApp)
        goto AskParent;
    }

    if (IsEqualGUID(guidService, SID_STopFrameBrowser)) 
    {
        BOOL fAskParent = TRUE;

        // Don't ask the parent if we are a desktop component and we are
        // not doing drag/drop.  Treat it as a top level frame.  For all other
        // cases, ask the parent.
        if (!IsEqualIID(riid, IID_IDropTarget) && _ptfrm)
        {
            IUnknown *pUnkParent;
            if (SUCCEEDED(_ptfrm->GetParentFrame(&pUnkParent)))
            {
                if (pUnkParent) 
                {
                    // Has a parent, not a desktop component
                    pUnkParent->Release();
                } 
                else 
                {
                    // Doesn't have a parent, must be a desktop component so
                    // fall through to call our CBASEBROWSER::QueryService
                    fAskParent = FALSE;
                }
            }
        }

        if (fAskParent)
            goto AskParent;
    }

    // If the containee is asking for SID_SContainerDispatch (parent),
    // we should return the automation interface of the buddy CWebBrowserOC.
    if (IsEqualGUID(guidService, SID_SContainerDispatch)) 
    {
        if (_psvo) 
        {
            return _psvo->QueryInterface(riid, ppvObj);
        }
        return E_UNEXPECTED;
    }

    // If the guidService is SID_SVersionHost,
    // give the host a crack at it first
    //
    if (IsEqualGUID(guidService, SID_SVersionHost))
    {
        hr = _QueryServiceParent(guidService, riid, ppvObj);
        
        // Return if the host handled the service,
        //
        if (S_OK == hr)
            return hr;
    }

    hr = CBASEBROWSER::QueryService(guidService, riid, ppvObj);

    // Notes: If guidService is SID_SShellBrowser, it indicates that
    //  the caller wants to talk to the immediate IShellBrowser.
    //  We should not try our parent in that case. Doing it so will
    //  break nested browser (frame set). In addition, notice that
    //  we don't want to go up the parent chain if hr is E_NOINTERFACE
    //  (which indicates unsuccessfull QueryInterface).
    //
    //  We don't want a shell view in a frame-set add buttons on the
    // toolbar. We should skip AskParent if guidService is SID_SExplroerToolbar. 

    if (FAILED(hr) && hr != E_NOINTERFACE
        && !IsEqualIID(guidService, SID_SShellBrowser)
        && !IsEqualIID(guidService, SID_SExplorerToolbar))
    {
AskParent:
        hr = _QueryServiceParent(guidService, riid, ppvObj);

        // hey, we're the top-level browser if there ain't no top-level browser
        // above us. (Such as our OC embedded in AOL/CIS/VB.) We must do this
        // or we don't get a _tlGlobal on the top frame, so navigation history
        // is screwy and the back/forward buttons are incorrect.
        if (FAILED(hr) && 
            (IsEqualGUID(guidService, SID_STopLevelBrowser) ||
             IsEqualGUID(guidService, SID_STopFrameBrowser) ||
             IsEqualGUID(guidService, SID_STopWindow)))
        {
            hr = CBASEBROWSER::QueryService(guidService, riid, ppvObj);
        }
    }
    return hr;
}


// IOleCommandTarget
//
// We simply forward to the container above our parent OC

HRESULT CWebBrowserSB::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    HRESULT hresLocal;

    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
    {
        hres = S_OK;
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            if (rgCmds[i].cmdID == SHDVID_CANGOBACK ||
                rgCmds[i].cmdID == SHDVID_CANGOFORWARD)
            {
                hresLocal = CBASEBROWSER::QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
            }
            else if (_psvo && _psvo->_pctContainer)
            {
                hresLocal = _psvo->_pctContainer->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);

                if (hresLocal == OLECMDERR_E_UNKNOWNGROUP || hresLocal == OLECMDERR_E_NOTSUPPORTED)
                {
                    hresLocal = CBASEBROWSER::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
                }
            }
            else
                hresLocal = OLECMDERR_E_NOTSUPPORTED;
            if (hresLocal != S_OK) hres = hresLocal;
        }
    } 
    else    
    {
        if (_psvo && _psvo->_pctContainer)
            hres = _psvo->_pctContainer->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

        // if container does not support the command try base browser
        // before we only used to return an error
        if (hres == OLECMDERR_E_UNKNOWNGROUP || hres == OLECMDERR_E_NOTSUPPORTED)
        {
            hres = CBASEBROWSER::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
    }

    return hres;
}


struct WBCMDLIST {
    const GUID* pguidCmdGroup;
    DWORD       nCmdID;
};

//
//  SBCMDID_CANCELNAVIGATION:                                           
//   Don't pass SBCMDID_CANCELNAVIGATION up to ROOT browser.  Canceling 
//  here doesn't need to be forwarded and will cause navigations of to  
//  initiated by javascript: navigations in this frame to be aborted.   
//                                                                      
//  SHDVID_ACTIVATEMENOW:                                               
//   The DocHost's request to activate the pending view must be handled 
//  by THIS browser, not the parent's -- if we're in a frameset page,   
//  we've probably already activated the top-level browser, now we may  
//  be trying to activate an individual frame.                          
//
const WBCMDLIST c_acmdWBSB[] = {
        { NULL, OLECMDID_HTTPEQUIV },
        { NULL, OLECMDID_HTTPEQUIV_DONE },
        { &CGID_ShellDocView, SHDVID_GETPENDINGOBJECT },
        { &CGID_ShellDocView, SHDVID_ACTIVATEMENOW },   
        { &CGID_ShellDocView, SHDVID_DOCFAMILYCHARSET },
        { &CGID_Explorer, SBCMDID_CANCELNAVIGATION },
        { &CGID_Explorer, SBCMDID_CREATESHORTCUT },     
        { &CGID_ShellDocView, SHDVID_CHECKINCACHEIFOFFLINE },
        { &CGID_ShellDocView, SHDVID_SETPRINTSTATUS },
        { &CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD },
        { &CGID_DocHostCmdPriv, DOCHOST_DOCCANNAVIGATE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_GETSHELLBROWSE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_GETIDLIST },
        { &CGID_InternetExplorer, IECMDID_SET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW },
        { &CGID_InternetExplorer, IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW },
        { &CGID_DocHostCmdPriv, DOCHOST_SETBROWSERINDEX },
};

HRESULT CWebBrowserSB::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    //
    //  First, test if the spcified command is supposed to processed by
    // this browser or not. If that's the case, just call CBASEBROWSER::Exec
    // and return.
    //
    for (int i=0; i<ARRAYSIZE(c_acmdWBSB); i++) 
    {
        if (nCmdID == c_acmdWBSB[i].nCmdID) 
        {
            if (pguidCmdGroup==NULL || c_acmdWBSB[i].pguidCmdGroup==NULL) 
            {
                if (pguidCmdGroup==c_acmdWBSB[i].pguidCmdGroup) 
                {
                    return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                }
            } 
            else if (IsEqualGUID(*pguidCmdGroup, *c_acmdWBSB[i].pguidCmdGroup)) 
            {
                return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
        }
    }

    // In some cases, we need perform some additional operations
    // before passing it to the parent. 
    //
    if (pguidCmdGroup == NULL)
    {                
        switch(nCmdID) {
        case OLECMDID_SETDOWNLOADSTATE:
            if (pvarargIn) 
            {
                _setDescendentNavigate(pvarargIn);
            }
            break;
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
    {
        switch (nCmdID) 
        {
        /* The DocHost's request to activate the pending view must be handled
         * by THIS browser, not the parent's -- then we forward up the chain
         * so that all potentially blocked frames can attempt to deactivate
         */
        case SHDVID_DEACTIVATEMENOW:
            if (_cbScriptNesting  > 0)
                _cbScriptNesting--;
            hres = CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            if (FAILED(hres) || _cbScriptNesting > 0)
                return hres;
            break;

        case SHDVID_NODEACTIVATENOW:
            _cbScriptNesting++;
            if (_cbScriptNesting > 1)
                return S_OK;
            break;

        case SHDVID_DELEGATEWINDOWOM:
            if (_psvo && _psvo->_pauto)
            {
                // Forward this command to the CIEFrameAuto instance for this webOC.
                return IUnknown_Exec(_psvo->_pauto, &CGID_ShellDocView, nCmdID, 0, pvarargIn, NULL);
            }
            break;

        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Explorer))
    {
        //  this needs to be handled by the specific browser that 
        //  received the exec.
        switch (nCmdID)
        {
        case SBCMDID_UPDATETRAVELLOG:
        case SBCMDID_REPLACELOCATION:
            return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

        case SBCMDID_SETSECURELOCKICON:
            {
                CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
               
                // Let the WebBrowserOC fire the event
                if (_psvo)
                {
                    _psvo->_OnSetSecureLockIcon(_bbd._eSecureLockIcon);   
                }
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup)) 
    {
        // These are ignored so that Explorer bar changes are done once - and only in response to
        // global changes applied to top Document if frameset of browser.
        //    NOT for changes applied to frames
        //    NOT for changes applied to browserbands
        return S_OK;
    }

    //
    // Forward this EXEC to the container (if we have). 
    //
    if (_psvo && _psvo->_pctContainer)
        hres = _psvo->_pctContainer->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    //
    // if the above exec failed, we're probably in some random container
    // so let CBASEBROWSER try to simulate a top-level frame.
    // might as well be a bit paranoid and make sure it failed with "i dunno"
    //
    if (hres == OLECMDERR_E_UNKNOWNGROUP || hres == OLECMDERR_E_NOTSUPPORTED) 
    {
        if (pguidCmdGroup==NULL && nCmdID==OLECMDID_SETDOWNLOADSTATE && _psvo) 
        {
            TraceMsg(DM_FORSEARCHBAND, "WBSB::QueryStatus Container does not support OLECMDID_SETDOWNLOADSTATE");
            hres = _psvo->_SetDownloadState(hres, nCmdexecopt, pvarargIn);
        }

        if (hres != S_OK) 
        {
            hres = CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    return hres;
}


HRESULT CWebBrowserSB::_SwitchActivationNow()
{
    CBASEBROWSER::_SwitchActivationNow();

    if (_bbd._psv && 
        _psvo && 
        _psvo->_nActivate < OC_INPLACEACTIVE && 
        _psvo->_dwDrawAspect)
    {
        // pass on the SetExtent to the now ready browser...
        IPrivateOleObject * pPrivOle;
        if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IPrivateOleObject, &pPrivOle))))
        {
            // we have an ole object, delegate downwards...
            pPrivOle->SetExtent( _psvo->_dwDrawAspect, &_psvo->_sizeHIM );
            pPrivOle->Release();
        }
    }
    return S_OK;
}

BOOL CWebBrowserSB::_HeyMoe_IsWiseGuy()
{
    BOOL fRet;

    if (_psvo)
    {
        fRet = _psvo->_HeyMoe_IsWiseGuy();
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

HRESULT CWebBrowserSB::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // if client does not specify we will do so for them
    if (SBSP_DEFBROWSER == (wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)))
    {
        IShellBrowser *psbDesktop;
        if (SUCCEEDED(QueryService(SID_SShellDesktop, IID_PPV_ARG(IShellBrowser, &psbDesktop))))
        {
            HRESULT hr = psbDesktop->BrowseObject(pidl, wFlags);
            psbDesktop->Release();
            return hr;
        }
        wFlags |= SBSP_SAMEBROWSER; // always navigate in place
    }

    return CBASEBROWSER::BrowseObject(pidl, wFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\smallutil.cpp ===
#include "priv.h"
#include <mluisupp.h>

#include "SmallUtil.hpp"


CCancellableThread::CCancellableThread()
{
    _hCancelEvent = NULL;
    _hThread = NULL;
    _fIsFinished = FALSE;
    _dwThreadResult = 0;
}

CCancellableThread::~CCancellableThread()
{
    if (_hCancelEvent)
        CloseHandle(_hCancelEvent);

    if (_hThread)
    {
        DWORD dwThreadStatus;
        if (0 != GetExitCodeThread(_hThread, &dwThreadStatus)
           && dwThreadStatus == STILL_ACTIVE)
        {
            ASSERT(0);  // bad error case, shouldn't need to terminate thread.
            TerminateThread(_hThread, 0);
        }
        CloseHandle(_hThread);
    }
}


BOOL CCancellableThread::Initialize()
{
    BOOL retVal = FALSE;
    
    _hCancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!_hCancelEvent)
        goto doneCCancellableThreadInitialize;

    retVal = TRUE;
doneCCancellableThreadInitialize:
    return retVal;
}


BOOL CCancellableThread::IsCancelled()
{
    if (!_hCancelEvent)
        return FALSE;

    DWORD dwEventWaitResult;
    dwEventWaitResult = WaitForSingleObject(_hCancelEvent, 0);

    if (dwEventWaitResult == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}


BOOL CCancellableThread::IsFinished()
{
    return _fIsFinished;
}


BOOL CCancellableThread::GetResult(PDWORD pdwResult)
{
    BOOL retVal = FALSE;

    if (IsFinished() != TRUE)
        goto doneCCancellableThreadGetStatus;

    *pdwResult = _dwThreadResult;
    retVal = TRUE;
    
doneCCancellableThreadGetStatus:
    return retVal;
}


BOOL CCancellableThread::WaitForNotRunning(DWORD dwMilliseconds, PBOOL pfFinished)
{
    BOOL retVal = FALSE;
    BOOL result;

    if (NULL == _hThread)
    {
        result = TRUE;
    }
    else
    {
        DWORD dwWaitResult;

        dwWaitResult = WaitForSingleObject(_hThread, dwMilliseconds);

        if (dwWaitResult == WAIT_OBJECT_0)
            result = TRUE;
        else if (dwWaitResult == WAIT_TIMEOUT)
            result = FALSE;
        else
        {
            DWORD dwError = GetLastError();
            goto doneCCancellableThreadWaitForComplete;
        }
    }

    retVal = TRUE;
    
doneCCancellableThreadWaitForComplete:
    if (retVal == TRUE && pfFinished != NULL)
        *pfFinished = result;

    return retVal;
}


BOOL CCancellableThread::Run()
{
    BOOL retVal = FALSE;

    if (!_hThread)
    {
        DWORD dw;
        retVal = (NULL != (_hThread = CreateThread(NULL, 0, threadProc, (void *)this, 0, &dw)));
    }
    return retVal;
}


BOOL CCancellableThread::NotifyCancel()
{
    if (!_hCancelEvent) 
        return FALSE;
    
    if (0 == SetEvent(_hCancelEvent))
        return FALSE;

    return TRUE;
}


DWORD WINAPI CCancellableThread::threadProc(void *pParameter)
{
    CCancellableThread *pThis = (CCancellableThread *)pParameter;
    
    if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
    {
        pThis->_dwThreadResult = pThis->run();

        CoUninitialize();
    }
    pThis->_fIsFinished = TRUE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\smallutil.hpp ===
#ifndef _SMALLUTIL_H_
#define _SMALLUTIL_H_



//  CCancellableThread
//
//  Lets you define a thread object that can be cancelled by the creator.
//To implement the thread, derivce from CCancellableThread and override the
//run() function.  run() will be ran in its own thread, and the value returned
//by run can be accessed by GetResult().  run() should check IsCancelled()
//at appropriate intervals and exit early if true.
//  Clients of the cancellable thread then create the object, and execute Run()
//when ready.  If they wish to cancel, they can call NotifyCancel().

class CCancellableThread
{
private:
    HANDLE _hCancelEvent;
    HANDLE _hThread;

    static DWORD WINAPI threadProc(void *pParameter);

    BOOL _fIsFinished;
    DWORD _dwThreadResult;
    
public:
    CCancellableThread();
    ~CCancellableThread();

    virtual BOOL Initialize();

    BOOL IsCancelled();
    BOOL IsFinished();
    BOOL GetResult(PDWORD pdwResult);

    BOOL Run();
    BOOL NotifyCancel();
    BOOL WaitForNotRunning(DWORD dwMilliseconds, PBOOL pfFinished = NULL);

protected:
    virtual DWORD run() = 0;
};



//  CQueueSortOf - a queue(sort of) used to store stuff
//in a renumerable way..

class CQueueSortOf
{
  //  This sort-of-queue is just a data structure to build up a list of items
  //(always adding to the end) and then be able to enumerate that list
  //repeatedly from start to end.
  //  The list does not own any of the objects added to it..
    typedef struct SEntry
    {
        SEntry* pNext;
        void* data;
    } *PSEntry;

    PSEntry m_pHead, m_pTail;

public:
    CQueueSortOf()
    {
        m_pHead = NULL;
        m_pTail = NULL;
    }

    ~CQueueSortOf()
    {
        while(m_pHead != NULL)
        {
            PSEntry temp = m_pHead;
            m_pHead = m_pHead->pNext;
            delete temp;
        }
    }

    bool InsertAtEnd(void* newElement)
    {
        PSEntry pNewEntry = new SEntry;

        if (pNewEntry == NULL)
            return false;

        pNewEntry->data = newElement;
        pNewEntry->pNext = NULL;

        if (m_pHead == NULL)
        {
            m_pHead = m_pTail = pNewEntry;
        }
        else
        {
            m_pTail->pNext = pNewEntry;
            m_pTail = pNewEntry;
        }

        return true;
    }

    // enumerations are managed by an 'iterator' which simply a void pointer into
    //the list.  To start an enumeration, pass NULL as the iterator.  The end
    //of enumeration will be indicated by a NULL iterator being returned.
    void* StepEnumerate(void* iterator)
    {
        return (iterator == NULL) ? m_pHead : ((PSEntry)iterator)->pNext;
    }

    void* Get(void* iterator)
    {
        return ((PSEntry)iterator)->data;
    }
};


//  CGrowingString is a simple utility class that allows you to create
//a string and append to it without worrying about reallocating memory
//every time.

class CGrowingString
{
public:
    WCHAR* m_pszString;
    long m_iBufferSize;
    long m_iStringLength;

    CGrowingString()
    {
        m_pszString = NULL;
        m_iBufferSize = 0;
        m_iStringLength = 0;
    }

    ~CGrowingString()
    {
        delete[] m_pszString;
    }

    BOOL AppendToString(LPCWSTR pszNew)
    {
        long iLength = lstrlen(pszNew);

        if (m_pszString == NULL
            || m_iStringLength + iLength + 1 > m_iBufferSize)
        {
            long iNewSize = max(1024, m_iStringLength + iLength * 10);
            WCHAR* pNewBuffer = new WCHAR[iNewSize];
            if (pNewBuffer == NULL)
                return FALSE;
            if (m_pszString == NULL)
            {
                m_pszString = pNewBuffer;
                m_iBufferSize = iNewSize;
            }
            else
            {
                StrCpyNW(pNewBuffer, m_pszString, m_iStringLength + 1);
                delete[] m_pszString;
                m_pszString = pNewBuffer;
                m_iBufferSize = iNewSize;
            }
        }

        StrCpyNW(m_pszString + m_iStringLength, pszNew, iLength+1);
        m_iStringLength += iLength;
        m_pszString[m_iStringLength] = L'\0';
        return TRUE;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\srchasst.cpp ===
#include "priv.h"
#include "caggunk.h"
#include "srchasst.h"
#include "dhuihand.h"
#include "mlang.h"  // fo char conversion
#include "..\browseui\legacy.h"  // for CITIDM_GETFOLDERSEARCHES
#include "varutil.h"
#include <wininet.h>

/////////////////////////////////////////////////////////////////////////////
// CSearchAssistantOC

//  If you change this, change browseui also.
const WCHAR c_wszThisBandIsYourBand[] = L"$$SearchBand$$";

//  HKLM values
#define REG_SZ_SEARCH       L"Software\\Microsoft\\Internet Explorer\\Search"
#define REG_SZ_SEARCHASSIST L"SearchAssistant"
#define REG_SZ_SEARCHCFG    L"CustomizeSearch"

//  HKCU values
#define REG_SZ_IE_MAIN      L"Software\\Microsoft\\Internet Explorer\\Main" 
#define REG_SZ_IE_SEARCURL  L"Software\\Microsoft\\Internet Explorer\\SearchURL"
#define REG_SZ_SEARCHBAR    L"Search Bar"
#define REG_SZ_USECUSTOM    L"Use Custom Search URL"
#define REG_SZ_AUTOSEARCH   L"AutoSearch"
#define REG_SZ_PROVIDER     L"Provider"
#define REG_SZ_USE_SEARCH_COMP  L"Use Search Asst"

#define SAOC_VERSION        2

const WCHAR c_wszSearchProps[] = REG_SZ_SEARCH L"\\SearchProperties";

STDAPI_(VARIANT_BOOL) UseCustomInternetSearch()
{
    VARIANT_BOOL bRet;
    DWORD dwVal;
    DWORD cbVal = sizeof(dwVal);
    
    if ((SHGetValueW(HKEY_CURRENT_USER, 
                    REG_SZ_IE_MAIN, 
                    REG_SZ_USECUSTOM, 
                    NULL, 
                    &dwVal, 
                    &cbVal) == ERROR_SUCCESS) &&
        (FALSE != dwVal))
    {
        bRet = VARIANT_TRUE;
    }
    else
    {
        bRet = VARIANT_FALSE;
    }

    return bRet;
}

STDAPI_(BOOL) GetSearchAssistantUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize)
{
    BOOL bResult;
    WCHAR wszUrlTmp[MAX_URL_STRING];
    WCHAR *pwszUrlRead;
    DWORD cb;

    ASSERT(pwszUrl);
    *pwszUrl = 0;

    if (bSubstitute)
    {
        cb = sizeof(wszUrlTmp);
        pwszUrlRead = wszUrlTmp;
    }
    else
    {
        cb = cchUrl * sizeof(WCHAR);
        pwszUrlRead = pwszUrl;
    }
    
    bResult = SHGetValueW(HKEY_LOCAL_MACHINE, 
                          REG_SZ_SEARCH, 
                          bCustomize ? REG_SZ_SEARCHCFG : REG_SZ_SEARCHASSIST,
                          NULL, (BYTE *)pwszUrlRead, &cb) == ERROR_SUCCESS;
    if (bResult && bSubstitute)
    {
        bResult = SUCCEEDED(URLSubstitution(wszUrlTmp, pwszUrl, cchUrl, URLSUB_ALL));
    }

    return bResult;
}

STDAPI_(BOOL) GetDefaultInternetSearchUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute)
{
    BOOL bResult = FALSE;
    DWORD cb;

    ASSERT(pwszUrl);
    *pwszUrl = 0;

    if (UseCustomInternetSearch())
    {
        //  First try the user specific value
        cb = cchUrl * sizeof(TCHAR);
        bResult = SHGetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_SEARCHBAR, 
                             NULL, (BYTE *)pwszUrl, &cb) == ERROR_SUCCESS;
    }
    
    if (!bResult)
    {
        bResult = GetSearchAssistantUrlW(pwszUrl, cchUrl, bSubstitute, FALSE);
    }

    return bResult;
}

STDAPI_(BOOL) GetSearchAssistantUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize)
{
    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

    BOOL bResult = GetSearchAssistantUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute, bCustomize);

    SHUnicodeToAnsi(wszUrl, pszUrl, cchUrl);

    return bResult;
}

STDAPI_(BOOL) GetDefaultInternetSearchUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute)
{
    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

    BOOL bResult = GetDefaultInternetSearchUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute);

    SHUnicodeToAnsi(wszUrl, pszUrl, cchUrl);

    return bResult;
}

void SetDefaultInternetSearchUrlW(LPCWSTR pwszUrl)
{
    DWORD dwUseCustom = FALSE;
    DWORD cb;
    
    if ((NULL != pwszUrl) && (0 != *pwszUrl))
    {
        cb = (lstrlenW(pwszUrl) + 1) * sizeof(WCHAR);
        if (SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_SEARCHBAR, REG_SZ,
                        pwszUrl, cb) == ERROR_SUCCESS)
        {
            dwUseCustom = TRUE;
        }
    }

    cb = sizeof(dwUseCustom);

    SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USECUSTOM, REG_DWORD, 
                &dwUseCustom, cb);
}

HRESULT CSearch_Create(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl, ISearch **ppSearch)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(ppSearch);
    *ppSearch = NULL;

    if (bstrTitle && bstrUrl && pguid)
    {
        BSTR _bstrTitle = SysAllocString(bstrTitle);
        BSTR _bstrUrl   = SysAllocString(bstrUrl);

        if (_bstrTitle && _bstrUrl)
        {
            CSearch *ps = new CSearch(pguid, _bstrTitle, _bstrUrl);

            if (ps)
            {
                hres = ps->QueryInterface(IID_ISearch, (void **)ppSearch);
                ps->Release();
            }
        }
        else
        {
            if (_bstrTitle)
                SysFreeString(_bstrTitle);

            if (_bstrUrl)
                SysFreeString(_bstrUrl);

            hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}

CSearch::CSearch(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl) :
    _cRef(1), _bstrTitle(bstrTitle), _bstrUrl(bstrUrl),
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_ISearch)
{
    SHStringFromGUID(*pguid, _szId, ARRAYSIZE(_szId));
}

CSearch::~CSearch()
{
    if (_bstrTitle)
        SysFreeString(_bstrTitle);

    if (_bstrUrl)
        SysFreeString(_bstrUrl);
}

STDMETHODIMP CSearch::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSearch, ISearch),
        QITABENTMULTI(CSearch, IDispatch, ISearch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearch::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSearch::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CSearch::get_Title(BSTR *pbstrTitle)
{
    HRESULT hres = NOERROR;
    
    *pbstrTitle = SysAllocString(_bstrTitle);
    if (!*pbstrTitle)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearch::get_Id(BSTR  *pbstrId)
{
    HRESULT hres = NOERROR;

    *pbstrId = SysAllocString(_szId);
    if (!*pbstrId)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearch::get_Url(BSTR *pbstrUrl)
{
    HRESULT hres = NOERROR;
    
    *pbstrUrl = SysAllocString(_bstrUrl);
    if (!*pbstrUrl)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearchCollection_Create(IFolderSearches *pfs, ISearches **ppSearches)
{
    HRESULT hres = E_INVALIDARG;
    
    ASSERT(ppSearches);
    *ppSearches = NULL;

    if (pfs)
    {
        CSearchCollection *psc = new CSearchCollection(pfs);

        if (psc)
        {
            hres = psc->QueryInterface(IID_ISearches, (void **)ppSearches);
            psc->Release();
        }
        else
            hres = E_OUTOFMEMORY;
    }
    
    return hres;
}

CSearchCollection::CSearchCollection(IFolderSearches *pfs) :
    _cRef(1), CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_ISearches)
{
    GUID guid;

    if (SUCCEEDED(pfs->DefaultSearch(&guid)))
        SHStringFromGUID(guid, _szDefault, ARRAYSIZE(_szDefault));
    
    _hdsaItems = DSA_Create(SIZEOF(URLSEARCH), 4);
    if (_hdsaItems)
    {
        IEnumUrlSearch *penum;

        if (SUCCEEDED(pfs->EnumSearches(&penum)))
        {
            URLSEARCH    us;
            ULONG        cElt;

            penum->Reset();
            while (S_OK == penum->Next(1, &us, &cElt) && 1 == cElt)
                DSA_AppendItem(_hdsaItems, &us);

            penum->Release();
        }
    }
}

CSearchCollection::~CSearchCollection()
{
    DSA_Destroy(_hdsaItems);
    _hdsaItems = NULL;
}

STDMETHODIMP CSearchCollection::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSearchCollection, ISearches),
        QITABENTMULTI(CSearchCollection, IDispatch, ISearches),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearchCollection::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSearchCollection::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CSearchCollection::get_Count(long *plCount)
{
    *plCount = 0;
    
    if (_hdsaItems)
    {
        *plCount =  DSA_GetItemCount(_hdsaItems);
    }
    return S_OK;
}

STDMETHODIMP CSearchCollection::get_Default(BSTR *pbstrDefault)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    *pbstrDefault = SysAllocString(_szDefault);
    if (*pbstrDefault)
        hres = S_OK;
    
    return hres;
}

STDMETHODIMP CSearchCollection::Item(VARIANT index, ISearch **ppid)
{
    HRESULT hres = E_NOTIMPL;
    
    *ppid = NULL;
    
    switch (index.vt)
    {
        case VT_I2:
            index.lVal = (long)index.iVal;
            // And fall through...

        case VT_I4:
            if ((index.lVal >= 0) && (index.lVal < DSA_GetItemCount(_hdsaItems)))
            {
                LPURLSEARCH pus;

                pus = (LPURLSEARCH)DSA_GetItemPtr(_hdsaItems, index.lVal);
                ASSERT(pus);
                
                hres = CSearch_Create(&pus->guid, pus->wszName, pus->wszUrl, ppid);
            }

            break;
    }

    return hres;
}

STDMETHODIMP CSearchCollection::_NewEnum(IUnknown **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}


CSearchAssistantOC::CSearchAssistantOC()
    :   m_punkSite(NULL)
{
#ifdef UNIX
    m_dwSafety = 0;
#endif
}

CSearchAssistantOC::~CSearchAssistantOC()
{
    ATOMICRELEASE(m_pSearchBandTBHelper);
    ATOMICRELEASE(m_punkSite);
}

HRESULT CSearchAssistantOC::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::SetClientSite(IOleClientSite *pClientSite)
{
    if (NULL != pClientSite)
    {
        HRESULT hr;       
        IWebBrowser2 *pWebBrowser2;

        hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_IWebBrowser2, 
                                   (void **)&pWebBrowser2);
        if (SUCCEEDED(hr))
        {
            BSTR bstrProp = SysAllocString(c_wszThisBandIsYourBand);
            if (bstrProp)
            {
                VARIANT var;
                hr = pWebBrowser2->GetProperty(bstrProp, &var);
                if (SUCCEEDED(hr))
                {
                    if (var.vt == VT_UNKNOWN)
                    {
                        ATOMICRELEASE(m_pSearchBandTBHelper);

                        hr = var.punkVal->QueryInterface(IID_ISearchBandTBHelper, 
                                                         (void **)&m_pSearchBandTBHelper);
                        ASSERT(SUCCEEDED(hr));

                        if (m_pSearchBandTBHelper)
                            m_pSearchBandTBHelper->SetOCCallback(this);
                    }

                    VariantClear(&var);
                }

                SysFreeString(bstrProp);
            }
            
            pWebBrowser2->Release();
        }
    }
    else
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            m_pSearchBandTBHelper->SetOCCallback(NULL);
            ATOMICRELEASE(m_pSearchBandTBHelper);
        }
    }
    return IOleObjectImpl<CSearchAssistantOC>::SetClientSite(pClientSite);
}

STDMETHODIMP CSearchAssistantOC::QueryStatus(const GUID *pguidCmdGroup,
                                             ULONG cCmds, 
                                             OLECMD prgCmds[],
                                             OLECMDTEXT *pCmdText)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CSearchAssistantOC::Exec(const GUID *pguidCmdGroup,
                                      DWORD nCmdID, 
                                      DWORD nCmdexecopt,
                                      VARIANT *pvaIn,
                                      VARIANT *pvaOut)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (NULL == pguidCmdGroup)
    {
        switch (nCmdID)
        {
            case SBID_SEARCH_NEXT:
                if ((NULL != pvaIn) && (pvaIn->vt == VT_I4))
                {
                    Fire_OnNextMenuSelect(pvaIn->lVal);

                    hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
                break;

            case SBID_SEARCH_NEW:
                if (NULL != pvaOut)
                {
                    m_bEventHandled = VARIANT_FALSE;

                    Fire_OnNewSearch();

                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_bEventHandled;

                    hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
                break;
        }
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::AddNextMenuItem(BSTR bstrText, long idItem)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            hr = m_pSearchBandTBHelper->AddNextMenuItem(bstrText, idItem);

            ASSERT(SUCCEEDED(hr));

        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::ResetNextMenu()
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            hr = m_pSearchBandTBHelper->ResetNextMenu();
            
            ASSERT(SUCCEEDED(hr));
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


STDMETHODIMP CSearchAssistantOC::SetDefaultSearchUrl(BSTR bstrUrl)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        SetDefaultInternetSearchUrlW(bstrUrl);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

STDMETHODIMP CSearchAssistantOC::NavigateToDefaultSearch()
{
    HRESULT hr;
    

    IWebBrowser2 *pWebBrowser2;

    hr = IUnknown_QueryService(m_spClientSite, SID_SWebBrowserApp, IID_IWebBrowser2, 
                               (void **)&pWebBrowser2);
    if (SUCCEEDED(hr))
    {
        WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

        if (GetDefaultInternetSearchUrlW(wszUrl, ARRAYSIZE(wszUrl), TRUE))
        {
            BSTR bstrUrl = SysAllocString(wszUrl);


            if (NULL != bstrUrl) 
            {
                VARIANT varFrame;
                varFrame.vt = VT_BSTR;
                varFrame.bstrVal = SysAllocString(L"_search");
                if (NULL != varFrame.bstrVal)
                {
                    hr = pWebBrowser2->Navigate(bstrUrl, NULL, &varFrame, NULL, NULL);

                    ASSERT(SUCCEEDED(hr));

                    SysFreeString(varFrame.bstrVal);
                }

                SysFreeString(bstrUrl);
            }
        }
        pWebBrowser2->Release();
    }
 
    return S_OK;
}

typedef struct _GUIDREST
{
    const GUID *  pguid;
    RESTRICTIONS  rest;
} GUIDREST;

HRESULT CSearchAssistantOC::IsRestricted(BSTR bstrGuid, VARIANT_BOOL *pVal)
{
    HRESULT hr;
    GUID guid;

    if (IsTrustedSite())
    {
        *pVal = VARIANT_FALSE; // default to not restricted
        if (SUCCEEDED(SHCLSIDFromString(bstrGuid, &guid)))
        {
            // find computer is special because if it restricted then we show
            // it else don't show it (restriction name is HASFINDCOMPUTER
            if (IsEqualGUID(guid, SRCID_SFindComputer))
            {
                if (!SHRestricted(REST_HASFINDCOMPUTERS))
                    *pVal = VARIANT_TRUE;
            }
            else
            {
                static GUIDREST agr[] = 
                {
                    {&SRCID_SFileSearch, REST_NOFIND},
                    // rest_nofindprinter does not exist yet
                    //{&SRCID_SFindPrinter, REST_NOFINDPRINTER},
                };

                for (int i=0; i < ARRAYSIZE(agr); i++)
                {
                    if (IsEqualGUID(guid, *agr[i].pguid))
                    {
                        if (SHRestricted(agr[i].rest))
                            *pVal = VARIANT_TRUE;
                        break;
                    }
                }
            }
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

HRESULT CSearchAssistantOC::get_ShellFeaturesEnabled(VARIANT_BOOL *pVal)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (pVal)
        {
            *pVal = (GetUIVersion() >= 5) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

HRESULT CSearchAssistantOC::get_SearchAssistantDefault(VARIANT_BOOL *pVal)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (pVal)
        {
            *pVal = !UseCustomInternetSearch();
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_Searches(ISearches **ppid)
{
    HRESULT hr;
    *ppid = NULL;

    if (IsTrustedSite())
    {
        IServiceProvider *psp;
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &psp));
        if (SUCCEEDED(hr))
        {
            IOleCommandTarget *pct;

            hr = psp->QueryService(SID_SExplorerToolbar, IID_IOleCommandTarget, (void **)&pct);
            if (SUCCEEDED(hr))
            {
                VARIANTARG var = {0};
                
                hr = pct->Exec(&CGID_PrivCITCommands, CITIDM_GETFOLDERSEARCHES, 0, NULL, &var);
                if (SUCCEEDED(hr))
                {
                    IFolderSearches *pfs;

                    ASSERT(var.vt == VT_UNKNOWN && var.punkVal);
                    hr = var.punkVal->QueryInterface(IID_IFolderSearches, (void **)&pfs);
                    if (SUCCEEDED(hr))
                    {
                        hr = CSearchCollection_Create(pfs, ppid);
                        pfs->Release();
                    }
                    var.punkVal->Release();
                }
                pct->Release();
                
                hr = S_OK;
            }

            psp->Release();
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_InWebFolder(VARIANT_BOOL *pVal)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        ASSERT(pVal);
        *pVal = VARIANT_FALSE;

        IBrowserService2 *pbs;
        
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_IBrowserService2, (void **)&pbs);

        if (SUCCEEDED(hr))
        {
            ITEMIDLIST *pidl;

            hr = pbs->GetPidl(&pidl);

            if (SUCCEEDED(hr))
            {
                // REARCHITECT: Don't use ILIsWeb().  We should use IShellFolder2::GetDefaultSearchGUID() and
                //   test for SRCID_SWebSearch vs. SRCID_SFileSearch/SRCID_SFindComputer/SRCID_SFindPrinter.
                //   This is because Shell Extensions need a way to indicate what kind of search they want
                //   and ILIsWeb() doesn't provide that.  An example of this is "Web Folders" won't return
                //   TRUE from ILIsWeb().  The use of ILIsWeb() should be limited.
                if (ILIsWeb(pidl))
                {
                    *pVal = VARIANT_TRUE;
                }
                
                ILFree(pidl);
            }
            pbs->Release();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    return hr;
}

HRESULT GetPerLocalePath(WCHAR *pwszKeyName, int cchKeyName)
{
    HRESULT hr;

    ASSERT(cchKeyName >= (ARRAYSIZE(c_wszSearchProps) + 1));
    
    hr = StringCchCopy(pwszKeyName, cchKeyName, c_wszSearchProps);
    if (SUCCEEDED(hr))
    {
        *(pwszKeyName + (ARRAYSIZE(c_wszSearchProps) - 1)) = L'\\';

        GetWebLocaleAsRFC1766(pwszKeyName + ARRAYSIZE(c_wszSearchProps),
                              cchKeyName - (ARRAYSIZE(c_wszSearchProps)));
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::PutProperty(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR bstrValue)
{
    HRESULT hr = E_ACCESSDENIED;

    if (IsTrustedSite())
    {
        HKEY hkey;
        LPCWSTR pwszKeyName;
        WCHAR wszKeyName[MAX_PATH];
        DWORD dwDisposition;

        if (bPerLocale)
        {
            hr = GetPerLocalePath(wszKeyName, ARRAYSIZE(wszKeyName));
            pwszKeyName = wszKeyName;
        }
        else
        {
            hr = S_OK;
            pwszKeyName = c_wszSearchProps;
        }

        if (SUCCEEDED(hr))
        {
            if (RegCreateKeyExW(HKEY_CURRENT_USER, pwszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS)
            {
                if ((NULL != bstrValue) && (bstrValue[0] != 0))
                {
                    RegSetValueExW(hkey, bstrName, 0, REG_BINARY, (LPBYTE)bstrValue,
                                   SysStringByteLen(bstrValue));
                }
                else
                {
                    //  Empty or NULL string means remove the property
                    RegDeleteValue(hkey, bstrName);
                }
                RegCloseKey(hkey);
            }
        }
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::GetProperty(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR *pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pbstrValue)
    {
        hr = E_ACCESSDENIED;
        *pbstrValue = NULL;
        
        if (IsTrustedSite())
        {
            HKEY hkey;
            LPCWSTR pwszKeyName;
            WCHAR wszKeyName[MAX_PATH];

            if (bPerLocale)
            {
                hr = GetPerLocalePath(wszKeyName, ARRAYSIZE(wszKeyName));
                pwszKeyName = wszKeyName;
            }
            else
            {
                hr = S_OK;
                pwszKeyName = c_wszSearchProps;
            }

            if (SUCCEEDED(hr))
            {
                if (RegOpenKeyExW(HKEY_CURRENT_USER, pwszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
                {
                    DWORD dwType;
                    DWORD cbSize;

                    if ((RegQueryValueExW(hkey, bstrName, NULL, &dwType, NULL, &cbSize) == ERROR_SUCCESS) &&
                        (dwType == REG_BINARY))
                    {
                        BSTR bstrValue = SysAllocStringByteLen(NULL, cbSize);

                        if (NULL != bstrValue)
                        {
                            if (RegQueryValueExW(hkey, bstrName, NULL, &dwType, (LPBYTE)bstrValue, &cbSize) == ERROR_SUCCESS)
                            {
                                *pbstrValue = bstrValue;
                            }
                            else
                            {
                                SysFreeString(bstrValue);
                            }
                        }
                    }

                    RegCloseKey(hkey);
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_EventHandled(VARIANT_BOOL bHandled)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        m_bEventHandled = bHandled;
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::GetSearchAssistantURL(VARIANT_BOOL bSubstitute, VARIANT_BOOL bCustomize, BSTR *pbstrValue)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pbstrValue)
        {
            WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

            if (GetSearchAssistantUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute, bCustomize))
            {
                *pbstrValue = SysAllocString(wszUrl);
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::NotifySearchSettingsChanged()
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)SEARCH_SETTINGS_CHANGED, 3000);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_ASProvider(BSTR Provider)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (Provider)
        {
            DWORD dwRet = SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_SEARCURL, REG_SZ_PROVIDER, REG_SZ,
                                      Provider, (lstrlenW(Provider) + 1) * sizeof(WCHAR));

            ASSERT(ERROR_SUCCESS == dwRet);
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_ASProvider(BSTR *pProvider)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pProvider)
        {
            HKEY hkey;

            if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, REG_SZ_IE_SEARCURL, 0, KEY_QUERY_VALUE, &hkey))
            {
                DWORD dwType;
                DWORD dwSize;
                
                if ((ERROR_SUCCESS == RegQueryValueExW(hkey, REG_SZ_PROVIDER, NULL,
                                                       &dwType, NULL, &dwSize)) && 
                                                       (REG_SZ == dwType))
                {
                    *pProvider = SysAllocStringByteLen(NULL, dwSize);
                    if (NULL != *pProvider)
                    {
                        if (ERROR_SUCCESS != RegQueryValueExW(hkey, REG_SZ_PROVIDER, NULL,
                                                              &dwType, (LPBYTE)*pProvider, &dwSize))
                        {
                            *pProvider = 0;
                        }
                    }
                }
                RegCloseKey(hkey);
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_ASSetting(int Setting)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        DWORD dwRet = SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_AUTOSEARCH, REG_DWORD,
                                  &Setting, sizeof(DWORD));

        ASSERT(ERROR_SUCCESS == dwRet);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_ASSetting(int *pSetting)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pSetting)
        {
            DWORD dwSize = sizeof(int);

            *pSetting = -1;
            
            DWORD dwRet = SHGetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_AUTOSEARCH, NULL,
                                      pSetting, &dwSize);

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

BOOL CSearchAssistantOC::IsTrustedSite()
{
    if (!m_bSafetyInited && m_spClientSite)
    {
        m_bSafetyInited = TRUE;

        IHTMLDocument2 *pHTMLDocument2;
      
        HRESULT hr = GetHTMLDoc2(m_spClientSite, &pHTMLDocument2);

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pHTMLDocument2);

            IHTMLLocation *pHTMLLocation;

            hr = pHTMLDocument2->get_location(&pHTMLLocation);

            if (SUCCEEDED(hr) && (NULL != pHTMLLocation))
            {           
                BSTR bstrUrl;

                pHTMLLocation->get_href(&bstrUrl);

                if (SUCCEEDED(hr) && (NULL != bstrUrl))
                {
                    HKEY hkey;
                    
                    //  FEATURE (tnoonan)
                    //  This code is duped with CSearchBand::_IsSafeUrl in browseui
                    
                    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SafeSites", 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
                    {        
                        WCHAR wszValue[MAX_PATH];
                        WCHAR wszData[MAX_URL_STRING];
                        WCHAR wszExpandedUrl[MAX_URL_STRING];
                        DWORD cbData = SIZEOF(wszData);
                        DWORD cchValue = ARRAYSIZE(wszValue);

                        for (int i=0; RegEnumValueW(hkey, i, wszValue, &cchValue, NULL, NULL, (LPBYTE)wszData, &cbData) == ERROR_SUCCESS; i++)
                        {
                            if (SHExpandEnvironmentStringsW(wszData, wszExpandedUrl, ARRAYSIZE(wszExpandedUrl)) > 0)
                            {
                                cchValue = ARRAYSIZE(wszExpandedUrl);
                                if (SUCCEEDED(UrlCanonicalizeW(wszExpandedUrl, wszExpandedUrl, &cchValue, 0)))
                                {
                                    if (cchValue > 0)
                                    {
                                        BOOL bRet;
                                        if (wszExpandedUrl[cchValue-1] == L'*')
                                        {
                                            bRet = StrCmpNIW(bstrUrl, wszExpandedUrl, cchValue - 1) == 0;
                                        }
                                        else
                                        {
                                            bRet = StrCmpIW(bstrUrl, wszExpandedUrl) == 0;
                                        }

                                        m_bIsTrustedSite = bRet ? TRUE : FALSE;
                                        
                                        if (m_bIsTrustedSite)
                                            break;
                                    }
                                }
                                cbData = SIZEOF(wszData);
                                cchValue = ARRAYSIZE(wszValue);
                            }
                        }
                        RegCloseKey(hkey);
                    }

                    SysFreeString(bstrUrl);
                }
                
                pHTMLLocation->Release();
            }
            
            pHTMLDocument2->Release();
        }
    }

    return m_bIsTrustedSite;
}

HRESULT CSearchAssistantOC::UpdateRegistry(BOOL bRegister)
{
    //this control uses selfreg.inx, not the ATL registry goo
    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::FindOnWeb()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SWebSearch ) ;
}

STDMETHODIMP CSearchAssistantOC::FindFilesOrFolders()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SFileSearch ) ;
}

STDMETHODIMP CSearchAssistantOC::FindComputer()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SFindComputer ) ;
}

STDMETHODIMP CSearchAssistantOC::FindPrinter()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    HRESULT hr = E_FAIL;
    IShellDispatch2* psd2;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                           IID_PPV_ARG(IShellDispatch2, &psd2) )) ) )
    {
        hr = psd2->FindPrinter( NULL, NULL, NULL ) ;
        psd2->Release();
    }
    return hr ;
}

STDMETHODIMP CSearchAssistantOC::FindPeople()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
    {
        return E_ACCESSDENIED;
    }

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.hwnd = HWND_DESKTOP;
    sei.lpVerb = TEXT("open");
    sei.lpFile = TEXT("wab.exe");
    sei.lpParameters = TEXT("/find");
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;

    if (!ShellExecuteEx(&sei))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return S_OK;
    }
}

// Wininet helper method to retry autodetection

// check to make sure that the hosting page is on
// the local computer.
// stolen from the zones code by joshco
//
STDMETHODIMP CSearchAssistantOC::LocalZoneCheck( )
{
    HRESULT hr = E_ACCESSDENIED;

    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!m_spClientSite)
        return S_FALSE;

    //  1)  Get an IHTMLDocument2 pointer
    //  2)  Get URL from doc
    //  3)  Check if doc URL zone is local, if so everything's S_OK
    //  4)  Otherwise, get and compare doc URL SID to requested URL SID

    IHTMLDocument2 *pHtmlDoc;
    if (SUCCEEDED(GetHTMLDoc2(m_spClientSite, &pHtmlDoc)))
    {
        ASSERT(pHtmlDoc);
        BSTR bstrDocUrl;
        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
        {
            ASSERT(bstrDocUrl);

            DWORD dwZoneID = URLZONE_UNTRUSTED;
            if (SUCCEEDED(GetZoneFromUrl(bstrDocUrl, m_spClientSite, &dwZoneID)))
            {
                if (dwZoneID == URLZONE_LOCAL_MACHINE)
                    hr = S_OK;
            }

            SysFreeString(bstrDocUrl);
        }
        pHtmlDoc->Release();
    }
    else
    {
        //  If we don't have an IHTMLDocument2 we aren't running in a browser that supports
        //  our OM.  We shouldn't block in this case since we could potentially
        //  get here from other hosts (VB, WHS, etc.).
        hr = S_FALSE;
    }

    return hr;
}

// set flags so that the next navigate will cause 
// a proxy autodetection cycle
// used in dnserr.htm along with location.reload.
// added by joshco
//
STDMETHODIMP CSearchAssistantOC::NETDetectNextNavigate()
{
    HRESULT hr = S_FALSE;

 CHAR  szConnectionName[100];
 DWORD dwBufLen;
 DWORD dwFlags;
 BOOL fResult;

 if (  LocalZoneCheck() != S_OK ) {
     // some security problem.. time to bail.
    hr=E_ACCESSDENIED;
    goto error;
    }

 dwBufLen = sizeof(szConnectionName);

       // find the connection name via internetconnected state
       
 fResult = InternetGetConnectedStateExA(&dwFlags,  szConnectionName,dwBufLen, 0 );

 INTERNET_PER_CONN_OPTION_LISTA list;
 INTERNET_PER_CONN_OPTIONA option;
       
 list.dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
 if(!fResult || (dwFlags & INTERNET_CONNECTION_LAN))
    {
        list.pszConnection = NULL;
    }
    else
    {
        list.pszConnection =  szConnectionName;
    }

 list.dwOptionCount = 1;
 list.pOptions = &option;
 option.dwOption = INTERNET_PER_CONN_FLAGS;
 dwBufLen= sizeof(list);

   // now call internetsetoption to do it..
   // first set this connectoid to enable autodetect
 if ( ! InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
         &list,&dwBufLen) ) 
    {
           goto error;
    }
               
 option.Value.dwValue |= PROXY_TYPE_AUTO_DETECT ;

 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
        &list,sizeof(list))) 
   {
         goto error;
   }

 if ( ! InternetInitializeAutoProxyDll(0) ) {
         goto error;
   }

 //  Now set the autodetect flags for this connectoid to
 //  do a passive detect and shut itself off if it doesnt work
 option.dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
 
 if ( ! InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
         &list,&dwBufLen) ) 
    {
           goto error;
    }
               
 option.Value.dwValue &= ~(AUTO_PROXY_FLAG_DETECTION_RUN) ;

 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
        &list,sizeof(list))) 
   {
         goto error;
   }


 
 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_SETTINGS_CHANGED,NULL, 0) ) {
         goto error;
   }



 hr=S_OK;
 error: ;
     
 return hr;
}

STDMETHODIMP CSearchAssistantOC::PutFindText(BSTR FindText)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        IServiceProvider *pServiceProvider;
        
        hr = IUnknown_QueryService(m_pSearchBandTBHelper, 
                                   SID_SProxyBrowser, 
                                   IID_IServiceProvider, 
                                   (void **)&pServiceProvider);
        if (SUCCEEDED(hr))
        {
            IWebBrowser2 *pWebBrowser2;
            hr = pServiceProvider->QueryService(SID_SWebBrowserApp, 
                                                IID_IWebBrowser2, 
                                                (void **)&pWebBrowser2);
            if (SUCCEEDED(hr))
            {
                ::PutFindText(pWebBrowser2, FindText);
                pWebBrowser2->Release();
            }
            pServiceProvider->Release();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_Version(int *pVersion)
{
    if (NULL != pVersion)
    {
        *pVersion = SAOC_VERSION;
    }
    return S_OK;
}

// x_hex_digit and URLEncode were stolen from trident

inline int x_hex_digit(int c)
{
    if (c >= 0 && c <= 9)
    {
        return c + '0';
    }
    if (c >= 10 && c <= 15)
    {
        return c - 10 + 'A';
    }
    return '0';
}

/*
   The following array was copied directly from NCSA Mosaic 2.2
 */
static const unsigned char isAcceptable[96] =
/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,    /* 2x   !"#$%&'()*+,-./  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,    /* 3x  0123456789:;<=>?  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,    /* 5x  PQRSTUVWXYZ[\]^_  */
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};   /* 7x  pqrstuvwxyz{\}~  
DEL */

// Performs URL-encoding of null-terminated strings. Pass NULL in pbOut
// to find buffer length required. Note that '\0' is not written out.

int URLEncode(char * pbOut, const char * pchIn)
{
    int     lenOut = 0;
    char *  pchOut = pbOut;

    ASSERT(pchIn);

    for (; *pchIn; pchIn++, lenOut++)
    {
        if (*pchIn == ' ')
        {
            if (pchOut)
                *pchOut++ = '+';
        }
        else if (*pchIn >= 32 && *pchIn <= 127 && isAcceptable[*pchIn - 32])
        {
            if (pchOut)
                *pchOut++ = *pchIn;
        }
        else
        {
            if (pchOut)
                *pchOut++ = '%';
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit((*pchIn >> 4) & 0xf);
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit(*pchIn & 0xf);
        }
    }
    return lenOut;
}

STDMETHODIMP CSearchAssistantOC::EncodeString(BSTR bstrValue, BSTR bstrCharSet, VARIANT_BOOL bUseUTF8, BSTR *pbstrResult)
{

    if ((NULL != bstrValue) && (NULL != pbstrResult))
    {
        HRESULT hr;
        IMultiLanguage2 *pMultiLanguage2;

        *pbstrResult = NULL;
        
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IMultiLanguage2, &pMultiLanguage2));

        if (SUCCEEDED(hr))
        {
            UINT uiCodePage = CP_BOGUS;
            UINT cchVal = SysStringLen(bstrValue);
            DWORD dwMode = 0;

            if (!bUseUTF8)
            {
                //  We're not using UTF so try and get the code page from the 
                //  charset.
                
                MIMECSETINFO info;
                
                hr = pMultiLanguage2->GetCharsetInfo(bstrCharSet, &info);

                if (SUCCEEDED(hr))
                {                   
                    hr = pMultiLanguage2->ConvertStringFromUnicodeEx(&dwMode,
                                                                     info.uiCodePage,
                                                                     bstrValue,
                                                                     &cchVal,
                                                                     NULL,
                                                                     NULL,
                                                                     MLCONVCHARF_NOBESTFITCHARS,
                                                                     NULL);
                    if (S_OK == hr)
                    {
                        uiCodePage = info.uiCodePage;
                    }
                }
            }
            else
            {
                uiCodePage = CP_UTF_8;
            }

            if (uiCodePage == CP_BOGUS)
            {
                //  we have characters which don't work in the charset or the charset
                //  is unknown to MLang, maybe MLang can figure out a code page to use.
                
                IMLangCodePages *pMLangCodePages;

                //  When all else fails...
                uiCodePage = CP_ACP;

                hr = pMultiLanguage2->QueryInterface(IID_IMLangCodePages,
                                                     (void **)&pMLangCodePages);
                if (SUCCEEDED(hr))
                {
                    DWORD dwCodePages = 0;
                    long cchProcessed = 0;
                    UINT uiTmpCP = 0;
                    
                    if (SUCCEEDED(pMLangCodePages->GetStrCodePages(bstrValue, cchVal, 
                                                                   0, &dwCodePages,
                                                                   &cchProcessed)) 

                        &&

                        SUCCEEDED(pMLangCodePages->CodePagesToCodePage(dwCodePages,
                                                                       0,
                                                                       &uiTmpCP)))
                    {
                        uiCodePage = uiTmpCP;
                    }

                    pMLangCodePages->Release();
                }
            }

            dwMode = 0;

            UINT cbVal = 0;

            //  Ask MLang how big of a buffer we need
            hr = pMultiLanguage2->ConvertStringFromUnicode(&dwMode,
                                                           uiCodePage,
                                                           bstrValue,
                                                           &cchVal,
                                                           NULL,
                                                           &cbVal);

            if (SUCCEEDED(hr))
            {
                CHAR *pszValue = new CHAR[cbVal + 1];

                if (NULL != pszValue)
                {
                    //  Really convert the string
                    hr = pMultiLanguage2->ConvertStringFromUnicode(&dwMode,
                                                                   uiCodePage,
                                                                   bstrValue,
                                                                   &cchVal,
                                                                   pszValue,
                                                                   &cbVal);
                    if (SUCCEEDED(hr))
                    {
                        pszValue[cbVal] = 0;
                        
                        int cbEncVal = URLEncode(NULL, pszValue);
                        CHAR *pszEncVal = new CHAR[cbEncVal];

                        if (NULL != pszEncVal)
                        {
                            URLEncode(pszEncVal, pszValue);

                            int cchResult = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                                                pszEncVal, cbEncVal,
                                                                NULL, 0);

                            *pbstrResult = SysAllocStringLen(NULL, cchResult);

                            if (NULL != *pbstrResult)
                            {
                                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                                    pszEncVal, cbEncVal,
                                                    *pbstrResult, cchResult);
                            }

                            delete [] pszEncVal;
                        }
                    }
                    delete [] pszValue;
                }
            }
            pMultiLanguage2->Release();
        }
    }


    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::get_ShowFindPrinter(VARIANT_BOOL *pbShowFindPrinter)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != pbShowFindPrinter)
        {
            IShellDispatch2* psd;

            *pbShowFindPrinter = VARIANT_FALSE;

            if (SUCCEEDED(CoCreateInstance(CLSID_Shell, 0, CLSCTX_INPROC_SERVER, 
                                          IID_PPV_ARG(IShellDispatch2, &psd))))
            {
                BSTR bstrName = SysAllocString( L"DirectoryServiceAvailable");

                if (bstrName)
                {
                    VARIANT varRet = {0};
                    
                    if (SUCCEEDED(psd->GetSystemInformation(bstrName, &varRet)))
                    {
                        ASSERT(VT_BOOL == varRet.vt);
                        *pbShowFindPrinter = varRet.boolVal;
                    }
                    SysFreeString(bstrName);
                }
                psd->Release();
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


STDMETHODIMP CSearchAssistantOC::get_SearchCompanionAvailable(VARIANT_BOOL *pbAvailable)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        if (pbAvailable != NULL)
        {
            BOOL fSCAvailable = FALSE;
            // need to determine if search companion is available on system and supports user locale
            ISearchCompanionInfo*   psci;
            hr = CoCreateInstance(CLSID_SearchCompanionInfo, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISearchCompanionInfo, &psci));
            if (SUCCEEDED(hr))
            {
                hr = psci->IsSearchCompanionInetAvailable(&fSCAvailable);
                psci->Release();
            }
            *pbAvailable = fSCAvailable ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_UseSearchCompanion(VARIANT_BOOL bUseSC)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        LPCTSTR pszUseSC = bUseSC ? TEXT("yes") : TEXT("no");
        SHSetValue(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USE_SEARCH_COMP, REG_SZ, pszUseSC, CbFromCch(lstrlen(pszUseSC) + 1));

        if (bUseSC)
        {
            // disable "Use Custom Search URL" as SC won't launch if custom search URL is defined
            DWORD dwUseCustom = FALSE;
            SHSetValue(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USECUSTOM, REG_DWORD, &dwUseCustom, sizeof(dwUseCustom));
        }
        
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_UseSearchCompanion(VARIANT_BOOL *pbUseSC)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        if (pbUseSC != NULL)
        {
            BOOL fUseSC = SHRegGetBoolUSValue(REG_SZ_IE_MAIN, REG_SZ_USE_SEARCH_COMP, FALSE, FALSE);
            *pbUseSC = fUseSC ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}


#ifdef ENABLE_THIS_FOR_IE5X

STDMETHODIMP CSearchAssistantOC::RefreshLocation(IDispatch *pLocation)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pLocation)
        {
            IHTMLLocation *pHTMLLocation;

            IUnknown_QueryService(pLocation, IID_IHTMLLocation, IID_IHTMLLocation, (void **)&pHTMLLocation);

            if (pHTMLLocation)
            {
                pHTMLLocation->reload(VARIANT_TRUE);
                pHTMLLocation->Release();
            }
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;

}

#endif
//-------------------------------------------------------------------------//
#define REG_SZ_SHELL_SEARCH TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\") \
                            TEXT("Explorer\\FindExtensions\\Static\\ShellSearch")
//-------------------------------------------------------------------------//
HRESULT GetSearchURLs( 
    IN REFGUID guidSearch, 
    OUT LPTSTR pszUrl, 
    IN DWORD cch, 
    OUT OPTIONAL LPTSTR pszUrlNavNew, 
    OUT DWORD cchNavNew, 
    OUT BOOL *pfRunInProcess )
{
    HRESULT hr = E_FAIL ;
    DWORD   cb ;
    DWORD   dwType ;
    DWORD   dwErr ;

    *pfRunInProcess = FALSE ;
    if( pszUrlNavNew && cchNavNew )
        *pszUrlNavNew = 0 ;

    if( IsEqualGUID( guidSearch, SRCID_SWebSearch ) )
    {
        if( GetDefaultInternetSearchUrlW( pszUrl, cch, TRUE ) )
            hr = S_OK ;
    }
    else
    {
        //  The shell search URL-eating stuff was adapted from
        //  CShellSearchExt::_GetSearchUrls() in browseui\searchext.cpp,
        //  and should be kept in sync.

        TCHAR szSubKey[32];
        HKEY  hkey, hkeySub;
        if( (dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_SZ_SHELL_SEARCH, 
                                   0, KEY_QUERY_VALUE, &hkey )) != ERROR_SUCCESS )
            return HRESULT_FROM_WIN32( dwErr ) ;

        hr = E_FAIL ;

        for (int i = 0; SUCCEEDED(StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i)) && (RegOpenKeyEx(hkey, szSubKey, NULL, KEY_QUERY_VALUE, &hkeySub) == ERROR_SUCCESS); i++)
        {
            TCHAR szSearchGuid[MAX_PATH];

            cb = SIZEOF(szSearchGuid);
            if( SHGetValue( hkeySub, TEXT("SearchGUID"), NULL, &dwType, (BYTE*)szSearchGuid, &cb ) == ERROR_SUCCESS )
            {
                GUID guid;
                SHCLSIDFromString(szSearchGuid, &guid);

                if( IsEqualGUID( guid, guidSearch ) )
                {
                    cb = cch * sizeof(TCHAR);
                    if( SHGetValue( hkeySub, TEXT("SearchGUID\\Url"), NULL, 
                                    &dwType, (BYTE*)pszUrl, &cb ) == ERROR_SUCCESS )
                    {
                        if( pszUrlNavNew && cchNavNew )
                        {
                            // See if there is a secondary URL that we should navigate to
                            cb = cchNavNew * sizeof(TCHAR);
                            SHGetValue(hkeySub, TEXT("SearchGUID\\UrlNavNew"), NULL, &dwType, (BYTE*)pszUrlNavNew, &cb);
                        }

                        // try to grab the RunInProcess flag
                        *pfRunInProcess = (BOOL)SHRegGetIntW( hkeySub, L"RunInProcess", 0 );

                        RegCloseKey(hkeySub);
                        hr = S_OK ;
                        break;
                    }
                }
            }
            RegCloseKey(hkeySub);
        }
        RegCloseKey( hkey ) ;
    }
    return hr ;
}

STDMETHODIMP _IsShellSearchBand( REFGUID guidSearch )
{
    if (IsEqualGUID( guidSearch, SRCID_SFileSearch ) ||
        IsEqualGUID( guidSearch, SRCID_SFindComputer ) ||
        IsEqualGUID( guidSearch, SRCID_SFindPrinter ) )
        return S_OK;
    return S_FALSE;
}

//-------------------------------------------------------------------------//
//  Establishes the correct shell search dialog, etc.
STDMETHODIMP _ShowShellSearchBand( IWebBrowser2* pwb2, REFGUID guidSearch )
{
    ASSERT( pwb2 );
    ASSERT( S_OK == _IsShellSearchBand( guidSearch ) );

    HRESULT hr;
    VARIANT varBand;
    if (SUCCEEDED( (hr = InitBSTRVariantFromGUID(&varBand, CLSID_FileSearchBand)) ))
    {
        //  Retrieve the FileSearchBand's unknown from the browser frame as a VT_UNKNOWN property;
        //  (FileSearchBand initialized and this when he was created and hosted.)
        VARIANT varFsb;
        if (SUCCEEDED( (hr = pwb2->GetProperty( varBand.bstrVal, &varFsb )) ))
        {
            if (VT_UNKNOWN == varFsb.vt && varFsb.punkVal != NULL )
            {
                //  Retrieve the IFileSearchBand interface
                IFileSearchBand* pfsb;
                if (SUCCEEDED( (hr = varFsb.punkVal->QueryInterface( IID_PPV_ARG(IFileSearchBand, &pfsb) )) ))
                {
                    //  Assign the correct search type to the band
                    VARIANT varSearchID;
                    if (SUCCEEDED( (hr = InitBSTRVariantFromGUID(&varSearchID, guidSearch)) ))
                    {
                        VARIANT      varNil = {0};
                        VARIANT_BOOL bNavToResults = VARIANT_FALSE ; 
                            // Note [scotthan]: we only navigate to results when we create a 
                            // new frame for the search, which we never do from srchasst.
                        pfsb->SetSearchParameters( &varSearchID.bstrVal, bNavToResults, &varNil, &varNil );
                        VariantClear( &varSearchID );
                    }
                    pfsb->Release();
                }
            }
            VariantClear( &varFsb );
        }
        VariantClear( &varBand );
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  The goop to show a search band in the current browser frame.
//  6/1
HRESULT CSearchAssistantOC::ShowSearchBand( REFGUID guidSearch ) 
{
    HRESULT           hr = E_FAIL;
    TCHAR             szUrl[MAX_URL_STRING];
    TCHAR             szUrlNavNew[MAX_URL_STRING];
    CLSID             clsidBand;
    BOOL              fShellSearchBand = FALSE;
    BOOL              fRunInProcess = FALSE;
    IUnknown*         punkSite = m_punkSite ? m_punkSite : (IUnknown*)m_spClientSite;

    if( !punkSite )
        return E_UNEXPECTED ;

    //  Determine band class and whether the band supports navigation
    if( (fShellSearchBand = (S_OK == _IsShellSearchBand( guidSearch ))) )
    {
        if (SHRestricted(REST_NOFIND) && IsEqualGUID(guidSearch, SRCID_SFileSearch))
            return E_ACCESSDENIED;
        clsidBand = CLSID_FileSearchBand;
    }
    else
    {
        clsidBand = CLSID_SearchBand;
        //  we need to navigate to a search URL, grope the registry for that special URL
        if( FAILED( (hr= GetSearchURLs( guidSearch, szUrl, ARRAYSIZE(szUrl), 
                                        szUrlNavNew, ARRAYSIZE(szUrlNavNew), 
                                        &fRunInProcess )) ) )
            return hr;
    }
        
    //  FEATURE [scotthan]: this function will fail unless invoked from within a browser.
    //  This sits fine for now since SearchAsst is designed as a browser band.
    IWebBrowser2* pwb2;
    hr = IUnknown_QueryServiceForWebBrowserApp(punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        SA_BSTRGUID bstrClsid;
        InitFakeBSTR(&bstrClsid, clsidBand);

        VARIANT var;
        var.bstrVal = bstrClsid.wsz;
        var.vt = VT_BSTR;

        VARIANT  varNil = {0};
            
        // show a search bar
        hr = pwb2->ShowBrowserBar(&var, &varNil, &varNil);
        if( SUCCEEDED( hr ) )
        {
            VARIANT varFlags;
            if( fShellSearchBand )
            {
                hr= _ShowShellSearchBand( pwb2, guidSearch );
            }
            else
            {
                varFlags.vt = VT_I4;
                varFlags.lVal = navBrowserBar;
                var.bstrVal = SysAllocString( szUrl );
                var.vt = VT_BSTR ;

                // navigate the search bar to the correct url
                hr = pwb2->Navigate2(&var, &varFlags, &varNil, &varNil, &varNil);

                SysFreeString(var.bstrVal);
                    
                if( SUCCEEDED( hr ) )
                {
                    hr = pwb2->put_Visible( TRUE ) ;
                }
            }
        }
        pwb2->Release();
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::SetSite( IUnknown* punkSite )
{
    ATOMICRELEASE(m_punkSite);
    if ((m_punkSite = punkSite) != NULL)
        m_punkSite->AddRef() ;
    return S_OK ;
}

STDMETHODIMP CSearchAssistantOC::GetSite( REFIID riid, void** ppvSite )
{
    if( !m_punkSite )
        return E_FAIL ;
    return m_punkSite->QueryInterface( riid, ppvSite ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\srchasst.h ===
#ifndef __SRCHASST_H_
#define __SRCHASST_H_

#include "caggunk.h"
#include "dspsprt.h"

class CSearch : public ISearch,
                protected CImpIDispatch
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch members
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    //ISearch methods
    STDMETHODIMP get_Title(BSTR *pbstrTitle);
    STDMETHODIMP get_Id(BSTR *pbstrId);
    STDMETHODIMP get_Url(BSTR *pbstrUrl);

private:
    CSearch(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl);
    ~CSearch();
    
    LONG _cRef;
    BSTR _bstrTitle;
    BSTR _bstrUrl;
    TCHAR _szId[40];

    friend HRESULT CSearch_Create(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl, ISearch **ppSearch);
};

class CSearchCollection : public ISearches,
                          protected CImpIDispatch
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch members
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    STDMETHODIMP get_Count(long *plCount);
    STDMETHODIMP get_Default(BSTR *pbstr);
    STDMETHODIMP Item(VARIANT index, ISearch **ppid);
    STDMETHODIMP _NewEnum(IUnknown **ppunk);

private:
    CSearchCollection(IFolderSearches *pfs);
    ~CSearchCollection();
    
    LONG  _cRef;
    TCHAR _szDefault[40];
    HDSA  _hdsaItems;

    friend HRESULT CSearchCollection_Create(IFolderSearches *pfs, ISearches **ppSearches);
};

//////////////////////////////////////////////////////////////////////////////
// CProxy_SearchAssistantEvents
template <class T>
class CProxy_SearchAssistantEvents : public IConnectionPointImpl<T, &
DIID__SearchAssistantEvents, CComDynamicUnkArray>
{
public:
//methods:
//_SearchAssistantEvents : IDispatch
public:
    void Fire_OnNextMenuSelect(int idItem)
    {
        VARIANTARG* pvars = new VARIANTARG[1];

        if (NULL != pvars)
        {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= idItem;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
    }

    void Fire_OnNewSearch()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSearchAssistantOC
class ATL_NO_VTABLE CSearchAssistantOC : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSearchAssistantOC, &CLSID_SearchAssistantOC>,
    public CComControl<CSearchAssistantOC>,
    public IDispatchImpl<ISearchAssistantOC3, &IID_ISearchAssistantOC3, &LIBID_SHDocVw>,
    public IProvideClassInfo2Impl<&CLSID_SearchAssistantOC, &DIID__SearchAssistantEvents, &LIBID_SHDocVw>,
    public IQuickActivateImpl<CSearchAssistantOC>,
    public IOleControlImpl<CSearchAssistantOC>,
    public IOleObjectImpl<CSearchAssistantOC>,
    public IOleInPlaceActiveObjectImpl<CSearchAssistantOC>,
    public IViewObjectExImpl<CSearchAssistantOC>,
    public IOleInPlaceObjectWindowlessImpl<CSearchAssistantOC>,
    public IDataObjectImpl<CSearchAssistantOC>,
    public CProxy_SearchAssistantEvents<CSearchAssistantOC>,
    public IConnectionPointContainerImpl<CSearchAssistantOC>,
    public IObjectSafetyImpl<CSearchAssistantOC, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IOleCommandTarget,
    public IObjectWithSite  // HACKHACK: need non-IOleClientSite host for FindXXX methods.
{
public:
    CSearchAssistantOC();
    ~CSearchAssistantOC();

BEGIN_COM_MAP(CSearchAssistantOC)
    COM_INTERFACE_ENTRY(ISearchAssistantOC3)
    COM_INTERFACE_ENTRY_IID(IID_ISearchAssistantOC, ISearchAssistantOC3)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CSearchAssistantOC)
    CONNECTION_POINT_ENTRY(DIID__SearchAssistantEvents)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CSearchAssistantOC)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

public:
    // *** ISearchAssistantOC methods ***

    STDMETHOD(AddNextMenuItem)(BSTR bstrText, long idItem);
    STDMETHOD(SetDefaultSearchUrl)(BSTR bstrUrl);
    STDMETHOD(NavigateToDefaultSearch)();
    STDMETHOD(IsRestricted)(BSTR bstrGuid, VARIANT_BOOL *pVal);
    STDMETHOD(get_ShellFeaturesEnabled)(VARIANT_BOOL *pVal);
    STDMETHOD(get_SearchAssistantDefault)(VARIANT_BOOL *pVal);
    STDMETHOD(get_Searches)(ISearches **ppid);
    STDMETHOD(get_InWebFolder)(VARIANT_BOOL *pVal);
    STDMETHOD(PutProperty)(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR bstrValue);
    STDMETHOD(GetProperty)(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR *pbstrValue);
    STDMETHOD(put_EventHandled)(VARIANT_BOOL bHandled);
    STDMETHOD(ResetNextMenu)();
    STDMETHOD(FindOnWeb)() ;
    STDMETHOD(FindFilesOrFolders)() ;
    STDMETHOD(FindComputer)() ;
    STDMETHOD(FindPrinter)() ;
    STDMETHOD(FindPeople)() ;
    STDMETHOD(GetSearchAssistantURL)(VARIANT_BOOL bSubstitute, VARIANT_BOOL bCustomize, BSTR *pbstrValue);
    STDMETHOD(NotifySearchSettingsChanged)();
    STDMETHOD(put_ASProvider)(BSTR Provider);
    STDMETHOD(get_ASProvider)(BSTR *pProvider);
    STDMETHOD(put_ASSetting)(int Setting);
    STDMETHOD(get_ASSetting)(int *pSetting);
    STDMETHOD(NETDetectNextNavigate)();
    STDMETHOD(PutFindText)(BSTR FindText);
    STDMETHOD(get_Version)(int *pVersion);
    STDMETHOD(EncodeString)(BSTR bstrValue, BSTR bstrCharSet, VARIANT_BOOL bUseUTF8, BSTR *pbstrResult);

    // *** ISearchAssistantOC2 methods ***
    STDMETHOD(get_ShowFindPrinter)(VARIANT_BOOL *pbShowFindPrinter);

    // *** ISearchAssistantOC3 methods ***
    STDMETHOD(get_SearchCompanionAvailable)(VARIANT_BOOL *pbAvailable);
    STDMETHOD(put_UseSearchCompanion)(VARIANT_BOOL bUseSC);
    STDMETHOD(get_UseSearchCompanion)(VARIANT_BOOL *pbUseSC);

    // *** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown*) ;
    STDMETHOD(GetSite)(REFIID, void**) ;

    // *** IOleObject overrides ***
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup,
                           ULONG cCmds, 
                           OLECMD prgCmds[],
                           OLECMDTEXT *pCmdText);
    
    STDMETHOD(Exec)(const GUID *pguidCmdGroup,
                    DWORD nCmdID, 
                    DWORD nCmdexecopt,
                    VARIANT *pvaIn,
                    VARIANT *pvaOut);

    HRESULT OnDraw(ATL_DRAWINFO& di);

    BOOL    IsTrustedSite();
    HRESULT ShowSearchBand( REFGUID guidSearch ) ;

    static HRESULT UpdateRegistry(BOOL bRegister);

private:

    ISearchBandTBHelper *m_pSearchBandTBHelper;

    BOOL        m_bSafetyInited  : 1;
    BOOL        m_bIsTrustedSite : 1;
    IUnknown*   m_punkSite ; // to accomodate clients who aren't hosting us as an OC.
    
    VARIANT_BOOL m_bEventHandled;

    STDMETHOD(LocalZoneCheck)(); // for wininet netdetect security
};


#define CP_BOGUS                ((UINT)-1)
#define CP_UTF_8                65001

#endif // __SRCHASST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\splash.cpp ===
/* Copyright 1997 Microsoft */

#include "priv.h"
#include "resource.h"

#include <mluisupp.h>

#define TIMER_TIMEOUT      1
#define SPLASHWM_DISMISS    WM_USER

////////////////////////////////////////////////////////////////////////////
//
//  InitLF -- modified from comdlg32\fonts.c, used by ShowSplashScreen
//
//  Initalize a LOGFONT structure to some base generic regular type font.
//
////////////////////////////////////////////////////////////////////////////

VOID InitLF(
    HDC hdc,
    LPLOGFONT lplf)
{
    TEXTMETRIC tm;

    lplf->lfEscapement = 0;
    lplf->lfOrientation = 0;
    lplf->lfOutPrecision = OUT_DEFAULT_PRECIS;
    lplf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lplf->lfQuality = DEFAULT_QUALITY;
    lplf->lfPitchAndFamily = DEFAULT_PITCH;
    lplf->lfItalic = 0;
    lplf->lfWeight = FW_NORMAL;
    lplf->lfStrikeOut = 0;
    lplf->lfUnderline = 0;
    lplf->lfWidth = 0;            // otherwise we get independant x-y scaling

    GetTextMetrics(hdc, &tm);   // get the current textmetrics
    lplf->lfCharSet = tm.tmCharSet;

    lplf->lfFaceName[0] = 0;
    MLLoadString(IDS_SPLASH_FONT, lplf->lfFaceName, ARRAYSIZE(lplf->lfFaceName));

    TCHAR szTmp[16];
    MLLoadString(IDS_SPLASH_SIZE, szTmp, ARRAYSIZE(szTmp));
    lplf->lfHeight = StrToInt(szTmp);
}

BOOL g_fShown = FALSE;

class CIESplashScreen : public ISplashScreen
{
protected:
    HBITMAP  _hbmSplash;     // The bitmap to display.
    HBITMAP  _hbmOld;
    HDC      _hdc;
    HWND     _hwnd;
    LONG     _cRef;

public:
    CIESplashScreen( HRESULT * pHr );
    ~CIESplashScreen();

    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef) ( THIS );
    STDMETHOD_(ULONG, Release) ( THIS );

    STDMETHOD ( Show ) ( HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwshnd );
    STDMETHOD ( Dismiss ) ( void );
    
    static LRESULT s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _RegisterWindowClass(void);
    HWND ShowSplashScreen(HINSTANCE hinst, UINT idResHi, UINT idResLow);

};


CIESplashScreen::CIESplashScreen(HRESULT * pHr) : _cRef (1)
{
    DllAddRef();
    *pHr = NOERROR;
}

CIESplashScreen::~CIESplashScreen()
{
    if (_hdc)
    {
        // select the previous hbm we got when we put the splash in there,
        // so that we can now destroy the hbitmap
        SelectObject( _hdc, _hbmOld );
        DeleteObject(_hdc);
    }

    // destroy the hbitmpa, can only do this if we have deselected it above...
    if (_hbmSplash)
        DeleteObject(_hbmSplash);

    DllRelease();
}

STDMETHODIMP CIESplashScreen::QueryInterface (REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;
    if ( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ISplashScreen ))
    {
        *ppv = SAFECAST( this, ISplashScreen *);
        this->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CIESplashScreen::AddRef ( )
{
    _cRef ++;
    return _cRef;
}

STDMETHODIMP_(ULONG) CIESplashScreen::Release ( )
{
    _cRef --;
    if ( !_cRef )
    {
        delete this;
        return 0;
    }
    return _cRef;
}

STDMETHODIMP CIESplashScreen::Show ( HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwnd )
{
    if ( !phwnd )
    {
        return E_INVALIDARG;
    }
    
    // First thing to do is to see if see if browser or a splash screen up...
    if ( g_fShown )
        return NULL;
    
    *phwnd = ShowSplashScreen( hinst, idResHi, idResLow );
    
    return ( *phwnd ? NOERROR : E_UNEXPECTED );
}

STDMETHODIMP CIESplashScreen::Dismiss ( void )
{
    if ( _hwnd )
    {
        // Synchronously dismiss the splash screen then post a message to
        // destroy the window.
        SendMessage(_hwnd, SPLASHWM_DISMISS, 0, 0);
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    return S_OK;
}

HWND CIESplashScreen::ShowSplashScreen( HINSTANCE hinst, UINT idResHi, UINT idResLow )
{
    // don't show splash screen for IE in intergrated mode or if it's been disabled 
    // by the admin
    if (
        ( (WhichPlatform() == PLATFORM_INTEGRATED) && (hinst == HINST_THISDLL) ) ||
        ( SHRestricted2(REST_NoSplash, NULL, 0) )
       )
    {
        return NULL;
    }
    
    if (!_RegisterWindowClass())
        return NULL;

    // provide default bitmap resource ID's for IE
    if (hinst == HINST_THISDLL)
    {
        if (idResHi == -1)
            idResHi = IDB_SPLASH_IEXPLORER_HI;
        if (idResLow == -1)
            idResLow = IDB_SPLASH_IEXPLORER;
    }
            
     // Now load the appropriate bitmap depending on colors, only use the 256 colour splash
     // if we are greater than 256 colours (such as 32K or 65K upwards), this will mean we don't have
     // to flash the palette just to put up the splash screen.
    _hbmSplash = (HBITMAP)LoadImage(hinst, MAKEINTRESOURCE((GetCurColorRes() > 8) ? idResHi : idResLow), 
                                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    _hdc = CreateCompatibleDC(NULL);
    
    if (!_hbmSplash || !_hdc)
        return NULL;

    // remember the old hbitmap so we can select it back before we delete the bitmap..
    _hbmOld = (HBITMAP) SelectObject(_hdc, _hbmSplash);

    // set font and color for text
    LOGFONT lf;
    HFONT   hfont;
    HFONT   hfontOld;
    
    InitLF(_hdc, &lf);
    hfont = CreateFontIndirect(&lf);
    if ( hfont == NULL ) // show the bitmap without text if we can't create the font
        goto Done;

    // select the new font and remember the old one
    hfontOld = (HFONT)SelectObject(_hdc, hfont);

    if (hfontOld)
    {
        SetTextColor(_hdc, RGB(0,0,0));
        SetBkColor(_hdc, RGB(255,255,255));
        SetBkMode(_hdc, TRANSPARENT);
    
        // draw the text on top of the selected bitmap
        TCHAR   szText[512], szY[32];
        RECT    rect;
    
        MLLoadString(IDS_SPLASH_Y1, szY, ARRAYSIZE(szY));
        MLLoadString(IDS_SPLASH_STR1, szText, ARRAYSIZE(szText));
        SetRect(&rect, 104, StrToInt(szY), 386, StrToInt(szY) + 10);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_SINGLELINE | DT_CALCRECT);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_SINGLELINE);

        MLLoadString(IDS_SPLASH_Y2, szY, ARRAYSIZE(szY));
        MLLoadString(IDS_SPLASH_STR2, szText, ARRAYSIZE(szText));
        SetRect(&rect, 104, StrToInt(szY), 386, 400);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_CALCRECT);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT);

        // select back the old font and delete the new one
        SelectObject(_hdc, hfontOld);
    }

    DeleteObject(hfont);
     
Done:
    // we now have everything in the DC, ready for painting.
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TEXT("CIESplashScreen"), NULL, 
                           WS_OVERLAPPED | WS_CLIPCHILDREN,
                           CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
                           NULL, (HMENU)NULL, HINST_THISDLL, this);
    if (_hwnd)
        ShowWindow(_hwnd, SW_NORMAL);

    return _hwnd;
}

LRESULT CIESplashScreen::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    CIESplashScreen *piess = (CIESplashScreen*)GetWindowPtr0(hwnd);

    if (!piess && (uMsg != WM_CREATE))
        return DefWindowProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_CREATE:
        DllAddRef();        // make sure we are not unloaded while in dialog
        if (lParam)
        {
            DWORD dwExStyles;

            piess = (CIESplashScreen*)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowPtr0(hwnd, piess);

            //
            // Turn off mirroring for the GUI splash screen bitmap.
            //
            if ((dwExStyles=GetWindowLong(hwnd, GWL_EXSTYLE))&RTL_MIRRORED_WINDOW)
            {
                SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles&~RTL_MIRRORED_WINDOW);
            }

            // Now lets try to center the window on the screen.
            BITMAP bm;

            GetObject(piess->_hbmSplash, sizeof(bm), &bm);

            SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & 
                          ~(WS_CAPTION|WS_SYSMENU|WS_BORDER|WS_THICKFRAME));
            SetWindowPos(hwnd, HWND_TOP, 
                         (GetSystemMetrics(SM_CXSCREEN) - bm.bmWidth) / 2, 
                         (GetSystemMetrics(SM_CYSCREEN) - bm.bmHeight) / 2, 
                         bm.bmWidth, bm.bmHeight, 0);

            // Set a 5 second timer to time it out.
            SetTimer(hwnd, TIMER_TIMEOUT, 15000, NULL);
        }
        g_fShown = TRUE;
        break;

    case WM_NCDESTROY:
        // the splash screen has left the building
        g_fShown = FALSE;
        
        DllRelease();
        break;

    case WM_ERASEBKGND:
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            HDC hdc = (HDC)wParam;

            BitBlt((HDC)hdc, 0, 0, rc.right, rc.bottom, piess->_hdc, 0, 0, SRCCOPY);

            return 1;
        }
        break;

    case WM_TIMER:
        // Now assume it is the right one.
        KillTimer( hwnd, TIMER_TIMEOUT );
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        break;

    case SPLASHWM_DISMISS:
        // Hide ourselves and remove our reference to piess - it may be gone at any point
        // after this call.
        ShowWindow(hwnd, SW_HIDE);
        SetWindowPtr0(hwnd, 0);
        break;

    case WM_ACTIVATE:
        if ( wParam == WA_INACTIVE && hwnd != NULL )
        {
            KillTimer( hwnd, TIMER_TIMEOUT );

            // create a new timer for 2 seconds after loss of activation...
            SetTimer( hwnd, TIMER_TIMEOUT, 2000, NULL );
            break;
        }
        // drop through
    
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}


BOOL CIESplashScreen::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};

    //wc.style         = 0;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(CIESplashScreen *);
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    //wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = TEXT("CIESplashScreen");

    return SHRegisterClass(&wc);
}

STDAPI CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_FAIL;
    CIESplashScreen * pSplash = new CIESplashScreen( & hr );
    if ( !pSplash )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pSplash;
        return hr;
    }
    
    *ppunk = SAFECAST(pSplash, ISplashScreen *);
    return NOERROR;
}

STDAPI SHCreateSplashScreen(ISplashScreen **ppSplash)
{
    return CIESplashScreen_CreateInstance(NULL, (IUnknown **)ppSplash, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "priv.h"

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


//#define _WIN32_WINNT 0x0400       // (scotth): Use what is defined in priv.h
#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities
#define _ATL_NO_UUIDOF

extern "C"
inline HRESULT __stdcall OleCreatePropertyFrame(
  HWND hwndOwner,    //Parent window of property sheet dialog box
  UINT x,            //Horizontal position for dialog box
  UINT y,            //Vertical position for dialog box
  LPCOLESTR lpszCaption,
                     //Pointer to the dialog box caption
  ULONG cObjects,    //Number of object pointers in lplpUnk
  LPUNKNOWN FAR* lplpUnk,
                     //Pointer to the objects for property sheet
  ULONG cPages,      //Number of property pages in lpPageClsID
  LPCLSID lpPageClsID,
                     //Array of CLSIDs for each property page
  LCID lcid,         //Locale identifier for property sheet locale
  DWORD dwReserved,  //Reserved
  LPVOID lpvReserved //Reserved
)
{
    return S_OK;
}
 
#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\strmwrap.cpp ===
#include "priv.h"

#define MAX_STREAMS 5 
#define CP_UNICODE 1200

class CStreamWrap : public IStream
{

public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write) (THIS_ VOID const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream **ppstm);

    HRESULT Init(IStream *aStreams[], UINT cStreams, UINT uiCodePage);
    CStreamWrap();

private:
    ~CStreamWrap();

    LONG        _cRef;
    IStream     *_aStreams[MAX_STREAMS];
    BOOL        _fFirstReadForStream[MAX_STREAMS];
    UINT        _cStreams;
    UINT        _iCurStream;
    UINT        _uiCodePage;
    UINT        _uiBOM;         // Byte order marker
};

CStreamWrap::CStreamWrap() : _cRef(1)
{
}

CStreamWrap::~CStreamWrap()
{
    while (_cStreams--)
    {
        if (_aStreams[_cStreams])
        {
            _aStreams[_cStreams]->Release();
            _aStreams[_cStreams] = NULL;
        }
    }
}

HRESULT CStreamWrap::Init(IStream *aStreams[], UINT cStreams, UINT uiCodePage)
{
    if (cStreams > ARRAYSIZE(_aStreams))
        return E_FAIL; 
    
    for (_cStreams = 0; _cStreams < cStreams; _cStreams++)
    {
        _aStreams[_cStreams] = aStreams[_cStreams];
        _fFirstReadForStream[_cStreams] = TRUE;
        _aStreams[_cStreams]->AddRef();
    }

    _uiCodePage = uiCodePage;
    _uiBOM = 0xfeff;            // FEATURE - set default to byte order of machine
    
    return S_OK;
}

STDMETHODIMP CStreamWrap::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IStream *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    this->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CStreamWrap::AddRef()
{
    return InterlockedIncrement(&this->_cRef);
}

STDMETHODIMP_(ULONG) CStreamWrap::Release()
{
    ASSERT( 0 != this->_cRef );
    ULONG cRef = InterlockedDecrement(&this->_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// Byte order marker macros
#define IS_BOM_LITTLE_ENDIAN(pv) ((*(WORD*)pv) == 0xfffe)
#define IS_BOM_BIG_ENDIAN(pv)    ((*(WORD*)pv) == 0xfeff)

STDMETHODIMP CStreamWrap::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    ULONG cbReadTotal = 0;
    ULONG cbLeftToRead = cb;
    HRESULT hres = NOERROR;

    while (cbLeftToRead && (_iCurStream < _cStreams))
    {
        ULONG cbReadThisStream;
        hres = _aStreams[_iCurStream]->Read(pv, cbLeftToRead, &cbReadThisStream);

        // REVIEW: what if one stream's implementation returns a failure code
        // when reading at the end of the stream?  We bail prematurely.
        if (SUCCEEDED(hres))
        {
            cbLeftToRead -= cbReadThisStream;

            if(_uiCodePage == CP_UNICODE)
            {
                if((_fFirstReadForStream[_iCurStream]) &&
                   (cbReadThisStream >= 2) &&
                   ((IS_BOM_LITTLE_ENDIAN(pv)) || (IS_BOM_BIG_ENDIAN(pv)))
                   )
                {
                    if(_iCurStream == 0)
                    {
                        _uiBOM = (*(WORD*)pv);    // Save first streams byte order marker as default
                    }
                    else
                    {
                        // REVIEW: should handle swapping bytes to default for IE6
                        if(_uiBOM != (*(WORD*)pv))  // BOM not default
                            return(E_FAIL);
                            
                        // Skip past unicode document lead bytes
                        cbReadThisStream -= 2;
                        MoveMemory((BYTE*)pv, (BYTE*)pv+2, cbReadThisStream);
                    }
                }

                _fFirstReadForStream[_iCurStream] = FALSE;
            }
            cbReadTotal += cbReadThisStream;
            pv = (char *)pv + cbReadThisStream;

            if (cbLeftToRead)
            {
                _iCurStream++;
                hres = S_OK;
            }
        }
        else
            break;
    }

    if (pcbRead)
        *pcbRead = cbReadTotal;

    if (SUCCEEDED(hres) && cbLeftToRead)
        hres = S_FALSE; // still success! but not completely

    return hres;
}

STDMETHODIMP CStreamWrap::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
        *pcbWritten = 0;
    return E_NOTIMPL;
}

// FEATURE: could at least support seaking to 0, as that's a common thing to do.
// REVIEW: not too hard to implement thoroughly - cache Stat calls on each
// substream (help implement ::Stat in this file too, which IMO is needed.)
STDMETHODIMP CStreamWrap::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

//
// REVIEW: this could use the internal buffer in the stream to avoid
// extra buffer copies.
//
STDMETHODIMP CStreamWrap::CopyTo(IStream *pstmTo, ULARGE_INTEGER cb,
             ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    BYTE buf[512];
    ULONG cbRead;
    HRESULT hres = NOERROR;

    if (pcbRead)
    {
        pcbRead->LowPart = 0;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
    }

    ASSERT(cb.HighPart == 0);

    while (cb.LowPart)
    {
        hres = this->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);

        if (FAILED(hres) || (cbRead == 0))
            break;

        if (pcbRead)
            pcbRead->LowPart += cbRead;

        cb.LowPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->LowPart += cbRead;

        if (FAILED(hres) || (cbRead == 0))
            break;
    }

    return hres;
}

STDMETHODIMP CStreamWrap::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamWrap::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// FEATURE: you gotta support Stat, or Trident will barf on this stream.
//         Trivial to implement too, just call Stat on each sub-stream.
STDMETHODIMP CStreamWrap::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}


// REVIEW: so simple to implement, it's probably worth doing
STDMETHODIMP CStreamWrap::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}

// in:
//      ppstm       array of stream pointers
//      cStreams    number of streams in the array
//

SHDOCAPI SHCreateStreamWrapperCP(IStream *aStreams[], UINT cStreams, DWORD grfMode, UINT uiCodePage, IStream **ppstm)
{
    HRESULT hres;

    *ppstm = NULL;

    if (grfMode != STGM_READ)
        return E_INVALIDARG;

    CStreamWrap *pwrap = new CStreamWrap();
    if (pwrap)
    {
        hres = pwrap->Init(aStreams, cStreams, uiCodePage);
        if (SUCCEEDED(hres))
            pwrap->QueryInterface(IID_IStream, (void **)ppstm);
        pwrap->Release();
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\swindows.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include "basesb.h"
#include "cnctnpt.h"
#include "stdenum.h"
#include "winlist.h"
#include <varutil.h>

#define WM_INVOKE_ON_RIGHT_THREAD   (WM_USER)

class CSDEnumWindows;

class WindowData
{
private:
    long m_cRef;

public:
    // Pidl variable is changed on the fly requiring reads/writes to be
    // protected by critical sections. Pid is also changed after creation but
    // only by _EnsurePid. So as long code calls _EnsurePid before reading Pid
    // no critical sections are required to read.
    
    LPITEMIDLIST pidl;
    IDispatch *pid;     // The IDispatch for the item
    long      lCookie;  // The cookie to make sure that the person releasing is the one that added it
    HWND      hwnd;     // The top hwnd, so we can
    DWORD     dwThreadId; // when it is in the pending box...
    BOOL      fActive:1;
    int       swClass;
    
    WindowData()
    {
        ASSERT(pid == NULL);
        ASSERT(hwnd == NULL);
        ASSERT(pidl == NULL);
        
        m_cRef = 1;
    }

    ~WindowData()
    {
        if (pid)
        {
            pid->Release();
        }
        ILFree(pidl); // null is OK
    }
    
    ULONG AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    ULONG Release()
    {
        ASSERT( 0 != m_cRef );
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }
};


class CSDWindows : public IShellWindows
                 , public IConnectionPointContainer
                 , protected CImpIDispatch
{
    friend CSDEnumWindows;

public:
    CSDWindows(void);

    BOOL Init(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IConnectionPointContainer
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID iid, IConnectionPoint ** ppCP);

    // IShellWindows
    STDMETHODIMP get_WindowPath (BSTR *pbs);
    STDMETHODIMP get_Count(long *plCount);
    STDMETHODIMP Item(VARIANT, IDispatch **ppid);
    STDMETHODIMP _NewEnum(IUnknown **ppunk);
    STDMETHODIMP Register(IDispatch *pid, long HWND, int swClass, long *plCookie);
    STDMETHODIMP RegisterPending(long lThreadId, VARIANT* pvarloc, VARIANT* pvarlocRoot, int swClass, long *plCookie);
    STDMETHODIMP Revoke(long lCookie);

    STDMETHODIMP OnNavigate(long lCookie, VARIANT* pvarLoc);
    STDMETHODIMP OnActivated(long lCookie, VARIANT_BOOL fActive);
    STDMETHODIMP FindWindowSW(VARIANT* varLoc, VARIANT* varlocRoot, int swClass, long * phwnd, int swfwOptions, IDispatch** ppdispAuto);
    STDMETHODIMP OnCreated(long lCookie, IUnknown *punk);
    STDMETHODIMP ProcessAttachDetach(VARIANT_BOOL fAttach);

private:
    ~CSDWindows(void);
    WindowData* _FindItem(long lCookie);
    WindowData* _FindAndRemovePendingItem(HWND hwnd, long lCookie);
    void _EnsurePid(WindowData *pwd);
    void _DoInvokeCookie(DISPID dispid, long lCookie, BOOL fCheckThread);
    HRESULT _Item(VARIANT index, IDispatch **ppid, BOOL fRemoveDeadwood);
    static LRESULT CALLBACK s_ThreadNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    int _NewCookie();
#ifdef DEBUG
    void _DBDumpList(void);
#endif

    LONG            m_cRef;
    LONG            m_cProcessAttach;
    HDPA            m_hdpa;             // DPA to hold information about each window
    HDPA            m_hdpaPending;      // DPA to hold information about pending windows.
    LONG            m_cTickCount;       // used to generate cookies
    HWND            m_hwndHack;
    DWORD           m_dwThreadID;
    // Embed our Connection Point object - implmentation in cnctnpt.cpp
    CConnectionPoint m_cpWindowsEvents;
};

class CSDEnumWindows : public IEnumVARIANT
{
public:
    CSDEnumWindows(CSDWindows *psdw);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumFORMATETC
    STDMETHODIMP Next(ULONG, VARIANT *, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumVARIANT **);

private:
    ~CSDEnumWindows();

    LONG        m_cRef;
    CSDWindows  *m_psdw;
    int         m_iCur;
};

STDAPI CSDWindows_CreateInstance(IShellWindows **ppsw)
{
    HRESULT hr = E_OUTOFMEMORY;   // assume failure...
    *ppsw = NULL;

    CSDWindows* psdf = new CSDWindows();
    if (psdf)
    {
        if (psdf->Init())
        {
            hr = psdf->QueryInterface(IID_PPV_ARG(IShellWindows, ppsw));
        }
        psdf->Release();
    }
    return hr;
}

CSDWindows::CSDWindows(void) :
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IShellWindows)
{
    DllAddRef();
    m_cRef = 1;
    ASSERT(m_hdpa == NULL);
    ASSERT(m_hdpaPending == NULL);
    ASSERT(m_cProcessAttach == 0);

    m_cpWindowsEvents.SetOwner((IUnknown*)SAFECAST(this, IShellWindows*), &DIID_DShellWindowsEvents);
}

int DPA_SWindowsFree(void *p, void *d)
{
    ((WindowData*)p)->Release();
    return 1;
}

CSDWindows::~CSDWindows(void)
{
    if (m_hdpa)
    {
        // We need to release the data associated with all of the items in the list
        // as well as release our usage of the interfaces...
        HDPA hdpa = m_hdpa;
        m_hdpa = NULL;

        DPA_DestroyCallback(hdpa, DPA_SWindowsFree, 0);
        hdpa = NULL;
    }
    if (m_hdpaPending)
    {
        // We need to release the data associated with all of the items in the list
        // as well as release our usage of the interfaces...
        HDPA hdpa = m_hdpaPending;
        m_hdpaPending = NULL;

        DPA_DestroyCallback(hdpa, DPA_SWindowsFree, 0);
        hdpa = NULL;
    }
    if (m_hwndHack)
    {
        DestroyWindow(m_hwndHack);
    }

    DllRelease();
}

BOOL CSDWindows::Init(void)
{
    m_hdpa = ::DPA_Create(0);
    m_hdpaPending = ::DPA_Create(0);
    m_dwThreadID = GetCurrentThreadId();
    m_hwndHack = SHCreateWorkerWindow(s_ThreadNotifyWndProc, NULL, 0, 0, (HMENU)0, this);

    if (!m_hdpa || !m_hdpaPending || !m_hwndHack)
        return FALSE;

    return TRUE;
}

STDMETHODIMP CSDWindows::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSDWindows, IConnectionPointContainer), 
        QITABENT(CSDWindows, IShellWindows),
        QITABENTMULTI(CSDWindows, IDispatch, IShellWindows),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSDWindows::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSDWindows::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// IShellWindows implementation

STDMETHODIMP CSDWindows::get_Count(long *plCount)
{
#ifdef DEBUG
    if (*plCount == -1)
        _DBDumpList();
#endif

    *plCount = 0;

    ENTERCRITICAL;
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->hwnd)
        {
            (*plCount)++;   // only count those with non NULL hwnd
        }
    }
    LEAVECRITICAL;
    return S_OK;
}

#ifdef DEBUG
void CSDWindows::_DBDumpList(void)
{
    ENTERCRITICAL;
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        TCHAR szClass[32];
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);

        szClass[0] = 0;
        if (IsWindow(pwd->hwnd))
        {
            GetClassName(pwd->hwnd, szClass, ARRAYSIZE(szClass));
        }

        TraceMsg(DM_TRACE, "csdw.dbdl: i=%d hwnd=%x (class=%s) cookie=%d tid=%d IDisp=%x pidl=%x fActive=%u swClass=%d", i,
            pwd->hwnd, szClass, pwd->lCookie, pwd->dwThreadId,
            pwd->pid, pwd->pidl, pwd->fActive, pwd->swClass);
    }
    LEAVECRITICAL;
}
#endif

/*
 * function to ensure that the pid is around and registered.
 * For delay registered guys, this involves calling back to the registered
 * window handle via a private message to tell it to give us a marshalled
 * IDispatch.
 *
 * Callers of _EnusrePid must have pwd addref'ed to ensure it will stay
 * alive.
 */

#define WAIT_TIME 20000 // 20 seconds

void CSDWindows::_EnsurePid(WindowData *pwd)
{
    IDispatch *pid = pwd->pid;
    if (!pid) 
    {
        ASSERT(pwd->hwnd);

#ifndef NO_MARSHALLING
        // we can not pass a stream between two processes, so we ask 
        // the other process to create a shared memory block with our
        // information in it such that we can then create a stream on it...

        // IDispatch from.  They will CoMarshalInterface their IDispatch
        // into the stream and return TRUE if successful.  We then
        // reset the stream pointer to the head and unmarshal the IDispatch
        // and store it in our list.
        DWORD       dwProcId = GetCurrentProcessId();
        DWORD_PTR   dwResult;

        // Use SendMessageTimeoutA since SendMessageTimeoutW doesn't work on w95.
        if (SendMessageTimeoutA(pwd->hwnd, WMC_MARSHALIDISPATCHSLOW, 0, 
                (LPARAM)dwProcId, SMTO_ABORTIFHUNG, WAIT_TIME, &dwResult) && dwResult)
        {
            // There should be an easier way to get this but for now...
            DWORD cb;
            LPBYTE pv = (LPBYTE)SHLockShared((HANDLE)dwResult, dwProcId);
            
            // Don't know for sure a good way to get the size so assume that first DWORD
            // is size of rest of the area
            if (pv && ((cb = *((DWORD*)pv)) > 0))
            {
                IStream *pIStream;
                if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pIStream))) 
                {
                    const LARGE_INTEGER li = {0, 0};
    
                    pIStream->Write(pv + sizeof(DWORD), cb, NULL);
                    pIStream->Seek(li, STREAM_SEEK_SET, NULL);
                    CoUnmarshalInterface(pIStream, IID_PPV_ARG(IDispatch, &pid));
                    pIStream->Release();
                }
            }
            SHUnlockShared(pv);
            SHFreeShared((HANDLE)dwResult, dwProcId);
        }
#else
        // UNIX IE has no marshalling capability YET 
        SendMessage(pwd->hwnd, WMC_MARSHALIDISPATCHSLOW, 0, (LPARAM)&(pid));
        // Since we don't use CoMarshal... stuff here we need to increment the
        // reference count.
        pid->AddRef();
#endif
        if (pid)
        {
            pid->AddRef();

            ENTERCRITICAL;
        
            // make sure a race on this did not already set pwd->pid
            if (NULL == pwd->pid)
            {
                pwd->pid = pid;
            }
        
            LEAVECRITICAL;

            pid->Release();
        }
    }
}

typedef struct
{
    WindowData * pwd;
    HDPA hdpaWindowList;
    int swClass;
} TMW;

BOOL CALLBACK CSDEnumWindowsProc(HWND hwnd, LPARAM lParam)
{
    TMW *ptwm = (TMW *) lParam;
    BOOL fFound = FALSE;

    // We walk a global hdpa window list, so we better be in a critical section.
    ASSERTCRITICAL;
    
    ASSERT(ptwm && ptwm->hdpaWindowList);
    ptwm->pwd = NULL;
    
    for (int i = DPA_GetPtrCount(ptwm->hdpaWindowList) - 1; (i >= 0) && !fFound; i--)
    {
        WindowData *pwd = (WindowData*)DPA_FastGetPtr(ptwm->hdpaWindowList, i);
        if (pwd->hwnd == hwnd && (ptwm->swClass == -1 || ptwm->swClass == pwd->swClass))
        {
            ptwm->pwd = pwd;
            pwd->AddRef();
            fFound = TRUE;
            break;
        }
    }
    return !fFound;
}

void CSDGetTopMostWindow(TMW* ptmw)
{
    EnumWindows(CSDEnumWindowsProc, (LPARAM)ptmw);
}


// Just like Item, except caller can specify if error is returned vs window deleted when
// window is in enumeration list but can't get idispatch.   This permits ::Next
// operator to skip bad windows, but still return valid ones.

HRESULT CSDWindows::_Item(VARIANT index, IDispatch **ppid, BOOL fRemoveDeadwood)
{
    TMW tmw;
    tmw.pwd = NULL;
    tmw.hdpaWindowList = m_hdpa;
    tmw.swClass = -1;

    *ppid = NULL;

    // This is sortof gross, but if we are passed a pointer to another variant, simply
    // update our copy here...
    if (index.vt == (VT_BYREF|VT_VARIANT) && index.pvarVal)
    {
        index = *index.pvarVal;
    }

    ASSERT(!(fRemoveDeadwood && index.vt != VT_I2 && index.vt != VT_I4));

Retry:

    switch (index.vt)
    {
    case VT_UI4:
        tmw.swClass = index.ulVal;
        // fall through
        
    case VT_ERROR:
        {
            HWND hwnd = GetActiveWindow();
            if (!hwnd)
            {
                hwnd = GetForegroundWindow();
            }

            if (hwnd)
            {
                ENTERCRITICAL;

                if (!CSDEnumWindowsProc(hwnd, (LPARAM)&tmw)) 
                {
                    ASSERT(tmw.pwd);
                }

                LEAVECRITICAL;
            }
            if (!tmw.pwd)
            {
                ENTERCRITICAL;
                CSDGetTopMostWindow(&tmw);
                LEAVECRITICAL;
            }
        }
        break;

    case VT_I2:
        index.lVal = (long)index.iVal;
        // And fall through...

    case VT_I4:
        if ((index.lVal >= 0))
        {
            ENTERCRITICAL;
            tmw.pwd = (WindowData*)DPA_GetPtr(m_hdpa, index.lVal);
            if (tmw.pwd)
            {
                tmw.pwd->AddRef();
            }
            LEAVECRITICAL;
        }
        break;

    default:
        return E_INVALIDARG;
    }

    if (tmw.pwd) 
    {
        _EnsurePid(tmw.pwd);
        
        *ppid = tmw.pwd->pid;
        if (tmw.pwd->hwnd && !IsWindow(tmw.pwd->hwnd))
        {
            *ppid = NULL;
        }
        
        if (*ppid)
        {
            (*ppid)->AddRef();
            tmw.pwd->Release();
            tmw.pwd = NULL;
            return S_OK;
        }
        else if (fRemoveDeadwood)
        {
            // In case the window was blown away in a fault we should try to recover...
            // We can only do this if caller is expecting to have item deleted out from
            // under it (see CSDEnumWindows::Next, below)
            Revoke(tmw.pwd->lCookie);
            tmw.swClass = -1;
            tmw.pwd->Release();
            tmw.pwd = NULL;
            goto Retry;
        }
        else
        {
            tmw.pwd->Release();
            tmw.pwd = NULL;
        }
    }

    return S_FALSE;   // Not a strong error, but a null pointer type of error
}

/*
 * This is essentially an array lookup operator for the collection.
 * Collection.Item by itself the same as the collection itself.
 * Otherwise you can refer to the item by index or by path, which
 * shows up in the VARIANT parameter.  We have to check the type
 * of the variant to see if it's VT_I4 (an index) or VT_BSTR (a
 * path) and do the right thing.
 */

STDMETHODIMP CSDWindows::Item(VARIANT index, IDispatch **ppid)
{
    return _Item(index, ppid, FALSE);
}

STDMETHODIMP CSDWindows::_NewEnum(IUnknown **ppunk)
{
    *ppunk = new CSDEnumWindows(this);
    return *ppunk ? S_OK : E_OUTOFMEMORY;
}

// IConnectionPointContainer

STDMETHODIMP CSDWindows::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    if (IsEqualIID(iid, DIID_DShellWindowsEvents) ||
        IsEqualIID(iid, IID_IDispatch))
    {
        *ppCP = m_cpWindowsEvents.CastToIConnectionPoint();
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}



STDMETHODIMP CSDWindows::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1, m_cpWindowsEvents.CastToIConnectionPoint());
}

void CSDWindows::_DoInvokeCookie(DISPID dispid, long lCookie, BOOL fCheckThread)
{
    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.  Note: if we add more notification types we may want to
    // have this function call the equivelent code as is in iedisp code for DoInvokeParam.
    //
    if (m_cpWindowsEvents.IsEmpty())
        return;

    if (fCheckThread && (m_dwThreadID != GetCurrentThreadId()))
    {
        PostMessage(m_hwndHack, WM_INVOKE_ON_RIGHT_THREAD, (WPARAM)dispid, (LPARAM)lCookie);
        return;
    }

    VARIANTARG VarArgList[1] = {0};
    DISPPARAMS dispparams = {0};

    // fill out DISPPARAMS structure
    dispparams.rgvarg = VarArgList;
    dispparams.cArgs = 1;

    VarArgList[0].vt = VT_I4;
    VarArgList[0].lVal = lCookie;

    IConnectionPoint_SimpleInvoke(&m_cpWindowsEvents, dispid, &dispparams);
}

// Guarantee a non-zero cookie, since 0 is used as a NULL value in
// various places (eg shbrowse.cpp)
int CSDWindows::_NewCookie()
{
    m_cTickCount++;
    if (0 == m_cTickCount)
    {
        m_cTickCount++;
    }
    return m_cTickCount;
}

STDMETHODIMP CSDWindows::Register(IDispatch *pid, long hwnd, int swClass, long *plCookie)
{
    if (!plCookie || (hwnd == NULL && swClass != SWC_CALLBACK) || (swClass == SWC_CALLBACK && pid == NULL))
        return E_POINTER;

    BOOL fAllocatedNewItem = FALSE;

    // If the pid isn't specified now (delay register), we'll call back later to
    // get it if we need it.
    if (pid)
    {
        pid->AddRef();
    }

    // We need to be carefull as to not leave a window of opertunity between removing the item from
    // the pending list till it is on the main list or some other thread could open a different window
    // up... Also guard m_hdpa
    // To avoid deadlocks, do not add any callouts to the code below!
    ENTERCRITICAL; 

    // First see if we have
    WindowData *pwd = _FindAndRemovePendingItem(IntToPtr_(HWND, hwnd), 0);
    if (!pwd)
    {
        pwd = new WindowData();
        if (!pwd)
        {
            LEAVECRITICAL;
            
            if (pid)
            {
                pid->Release();
            }
            return E_OUTOFMEMORY;
        }

        pwd->lCookie = _NewCookie();
    }

    pwd->pid = pid;
    pwd->swClass = swClass;
    pwd->hwnd = IntToPtr_(HWND, hwnd);

    if (plCookie)
    {
        *plCookie = pwd->lCookie;
    }

    // Give our refcount to the DPA
    if ( -1 == DPA_AppendPtr(m_hdpa, pwd) )
    {
        //  Failed to add, free the memory;
        pwd->Release( );
        *plCookie = 0;

        LEAVECRITICAL;
        return E_OUTOFMEMORY;
    }

    LEAVECRITICAL;
    
    // We should now notify anyone waiting that there is a window registered...
    _DoInvokeCookie(DISPID_WINDOWREGISTERED, pwd->lCookie, TRUE);

    return S_OK;
}

STDMETHODIMP CSDWindows::RegisterPending(long lThreadId, VARIANT* pvarloc, VARIANT* pvarlocRoot, int swClass, long *plCookie)
{
    if (plCookie)
    {
        *plCookie = 0;
    }

    HRESULT hr = E_OUTOFMEMORY;
    WindowData *pwd = new WindowData();
    if (pwd)
    {
        // pwd is not in any DPA at this point so it is safe to change
        // variables outside of critical section
        pwd->swClass = swClass;
        pwd->dwThreadId = (DWORD)lThreadId;
        pwd->pidl = VariantToIDList(pvarloc);
        if (pwd->pidl)
        {
            ASSERT(!pvarlocRoot || pvarlocRoot->vt == VT_EMPTY);

            ENTERCRITICAL; // guards m_hdpa access

            pwd->lCookie = _NewCookie();
            if (plCookie)
            {
                *plCookie = pwd->lCookie;
            }

            // Give our refcount to the DPA
            if ( -1 == DPA_AppendPtr(m_hdpaPending, pwd) )
            {
                pwd->Release();
            }

            LEAVECRITICAL;

            hr = S_OK;     // success
        }
        else
        {
            pwd->Release();
        }
    }
    return hr;
}

WindowData* CSDWindows::_FindItem(long lCookie)
{
    WindowData * pResult = NULL;

    ENTERCRITICAL;
    
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->lCookie == lCookie)
        {
            pResult = pwd;
            pResult->AddRef();
        }
    }
    
    LEAVECRITICAL;

    return pResult;
}

WindowData* CSDWindows::_FindAndRemovePendingItem(HWND hwnd, long lCookie)
{
    WindowData* pwdRet = NULL; // assume error
    DWORD dwThreadId = hwnd ? GetWindowThreadProcessId(hwnd, NULL) : 0;

    ENTERCRITICAL;
    
    for (int i = DPA_GetPtrCount(m_hdpaPending) - 1;i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpaPending, i);
        if ((pwd->dwThreadId == dwThreadId)  || (pwd->lCookie == lCookie))
        {
            pwdRet = pwd;
            DPA_DeletePtr(m_hdpaPending, i);
            break;
        }
    }
    
    // Since we are both removing the WindowData from the pending array (Release)
    // and returning it (AddRef) we can just leave its refcount alone. The
    // caller should release it when they are done with it.
    
    LEAVECRITICAL;
    
    return pwdRet;
}

STDMETHODIMP CSDWindows::Revoke(long lCookie)
{
    WindowData *pwd = NULL;
    HRESULT hr = S_FALSE;

    ENTERCRITICAL; // guards m_hdpa
    
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->lCookie == lCookie)
        {
            // Remove it from the list while in semaphore...
            // Since we are deleting the WindowData from the array we should not
            // addref it. We are taking the refcount from the array.
            DPA_DeletePtr(m_hdpa, i);
            break;
        }
    }
    
    LEAVECRITICAL;

    if ((i >= 0) || (pwd = _FindAndRemovePendingItem(NULL, lCookie)))
    {
        // event for window going away
        _DoInvokeCookie(DISPID_WINDOWREVOKED, pwd->lCookie, TRUE);
        pwd->Release();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CSDWindows::OnNavigate(long lCookie, VARIANT* pvarLoc)
{
    HRESULT hr;
    WindowData* pwd = _FindItem(lCookie);
    if (pwd)
    {
        // NOTE: this is where we mess with the pidl inside of a WindowData struct.
        // this is why we need to protect all access to pwd->pidl with a critsec
        
        ENTERCRITICAL;

        ILFree(pwd->pidl);
        pwd->pidl = VariantToIDList(pvarLoc);
        hr = pwd->pidl ? S_OK : E_OUTOFMEMORY;

        LEAVECRITICAL;

        pwd->Release();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CSDWindows::OnActivated(long lCookie, VARIANT_BOOL fActive)
{
    WindowData* pwd = _FindItem(lCookie);
    if (pwd) 
    {
        pwd->fActive = (BOOL)fActive;
        pwd->Release();
    }
    return pwd ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CSDWindows::OnCreated(long lCookie, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    WindowData* pwd = _FindItem(lCookie);
    if (pwd)
    {
        _EnsurePid(pwd);
        ITargetNotify *ptgn;
        if (pwd->pid && SUCCEEDED(pwd->pid->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgn))))
        {
            hr = ptgn->OnCreate(punk, lCookie);
            ptgn->Release();
        }
        
        pwd->Release();
    }
    return hr;
}

void _FreeWindowDataAndPidl(WindowData **ppwd, LPITEMIDLIST *ppidl)
{
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    if (*ppwd)
    {
        (*ppwd)->Release();
        *ppwd = NULL;
    }
}

BOOL _GetWindowDataAndPidl(HDPA hdpa, int i, WindowData **ppwd, LPITEMIDLIST *ppidl)
{
    _FreeWindowDataAndPidl(ppwd, ppidl);

    ENTERCRITICAL;

    *ppwd = (WindowData*)DPA_GetPtr(hdpa, i);
    if (*ppwd)
    {
        (*ppwd)->AddRef();

        // NOTE: pwd->pidl can change out from under us when we are outside of 
        // the critsec so we must clone it so we can play with it when we don't
        // hold the critsec

        *ppidl = ILClone((*ppwd)->pidl);
    }

    LEAVECRITICAL;

    return *ppwd ? TRUE : FALSE;
}

STDMETHODIMP CSDWindows::FindWindowSW(VARIANT* pvarLoc, VARIANT* pvarLocRoot, int swClass, 
                                      long *phwnd, int swfwOptions, IDispatch** ppdispOut)
{
    HRESULT hr = S_FALSE;   // success, but none found
    int i;

    LPITEMIDLIST pidlFree = VariantToIDList(pvarLoc);
    LPCITEMIDLIST pidl = pidlFree ? pidlFree : &s_idlNULL;

    ASSERT(!pvarLocRoot || pvarLocRoot->vt == VT_EMPTY);

    long lCookie = 0;

    if (pvarLoc && (swfwOptions & SWFO_COOKIEPASSED))
    {
        if (pvarLoc->vt == VT_I4)
        {
            lCookie = pvarLoc->lVal;
        }
        else if (pvarLoc->vt == VT_I2)
        {
            lCookie = (LONG)pvarLoc->iVal;
        }
    }

    if (ppdispOut)
    {
        *ppdispOut = NULL;
    }

    if (phwnd)
    {
        *phwnd = NULL;
    }

    if (swfwOptions & SWFO_NEEDDISPATCH)
    {
        if (!ppdispOut)
        {
            ILFree(pidlFree);
            return E_POINTER;
        }
    }

    WindowData* pwd = NULL;
    LPITEMIDLIST pidlCur = NULL;

    // If no PIDL we will assume an Empty idl...
    if (swfwOptions & SWFO_INCLUDEPENDING)
    {
        for (i = 0; _GetWindowDataAndPidl(m_hdpaPending, i, &pwd, &pidlCur); i++)
        {
            if ((pwd->swClass == swClass) &&
                (!lCookie || (lCookie == pwd->lCookie)) &&
                ILIsEqual(pidlCur, pidl))
            {
                if (phwnd)
                {
                    *phwnd = pwd->lCookie;   // Something for them to use...
                }

                _FreeWindowDataAndPidl(&pwd, &pidlCur);
                // found a pending window, return E_PENDING to say that the open is currently pending
                hr = E_PENDING;
                break;
            }

            _FreeWindowDataAndPidl(&pwd, &pidlCur);
        }
    }

    if (S_FALSE == hr)
    {
        for (i = 0; _GetWindowDataAndPidl(m_hdpa, i, &pwd, &pidlCur); i++)
        {
            if ((pwd->swClass == swClass) &&
                (!lCookie || (lCookie == pwd->lCookie)) &&
                (pidlCur && ILIsEqual(pidlCur, pidl)))
            {
                if (swfwOptions & SWFO_NEEDDISPATCH)
                {
                    _EnsurePid(pwd);
                }

                if (phwnd)
                {
                    // test the found window to see if it is valid, if not
                    // blow it away and start over
                    if (pwd->hwnd && !IsWindow(pwd->hwnd))
                    {
                        Revoke(pwd->lCookie);
                        i = 0;      // start over in this case
            
                        _FreeWindowDataAndPidl(&pwd, &pidlCur);
                        continue;
                    }
                    *phwnd = PtrToLong(pwd->hwnd); // windows handles 32b
                    hr = S_OK;  // terminate the loop
                }

                if (swfwOptions & SWFO_NEEDDISPATCH)
                {
                    hr = pwd->pid ? pwd->pid->QueryInterface(IID_PPV_ARG(IDispatch, ppdispOut)) : E_NOINTERFACE;
                }
                _FreeWindowDataAndPidl(&pwd, &pidlCur);
                break;
            }
            _FreeWindowDataAndPidl(&pwd, &pidlCur);
        }
    }

    ILFree(pidlFree);
    return hr;
}

HRESULT CSDWindows::ProcessAttachDetach(VARIANT_BOOL fAttach)
{
    if (fAttach)
    {
        InterlockedIncrement(&m_cProcessAttach);
    }
    else 
    {
        ASSERT( 0 != m_cProcessAttach );
        if (0 == InterlockedDecrement(&m_cProcessAttach))
        {
            // last process ref, we can now blow away the object in the shell context...
            if (g_dwWinListCFRegister) 
            {
#ifdef DEBUG
                long cwindow;
                get_Count(&cwindow);
                if (cwindow != 0)
                {
                    TraceMsg(DM_ERROR, "csdw.pad: cwindow=%d (!=0)", cwindow);
                }
#endif
                CoRevokeClassObject(g_dwWinListCFRegister);
                g_dwWinListCFRegister = 0;
            }
        }
    }
    return S_OK;
}

CSDEnumWindows::CSDEnumWindows(CSDWindows *psdw)
{
    DllAddRef();
    m_cRef = 1;
    m_psdw = psdw;
    m_psdw->AddRef();
    m_iCur = 0;
}

CSDEnumWindows::~CSDEnumWindows(void)
{
    DllRelease();
    m_psdw->Release();
}

STDMETHODIMP CSDEnumWindows::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSDEnumWindows, IEnumVARIANT),    // IID_IEnumVARIANT
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSDEnumWindows::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSDEnumWindows::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CSDEnumWindows::Next(ULONG cVar, VARIANT *pVar, ULONG *pulVar)
{
    ULONG       cReturn = 0;
    HRESULT     hr;

    if (!pulVar)
    {
        if (cVar != 1)
            return E_POINTER;
    }
    else
    {
        *pulVar = 0;
    }

    VARIANT index;
    index.vt = VT_I4;

    while (cVar > 0)
    {
        IDispatch *pid;

        index.lVal = m_iCur++;
        
        hr = m_psdw->_Item(index, &pid, TRUE);            
        if (S_OK != hr)
            break;

        pVar->pdispVal = pid;
        pVar->vt = VT_DISPATCH;
        pVar++;
        cReturn++;
        cVar--;
    }

    if (NULL != pulVar)
    {
        *pulVar = cReturn;
    }

    return cReturn ? S_OK : S_FALSE;
}

STDMETHODIMP CSDEnumWindows::Skip(ULONG cSkip)
{
    long cItems;
    m_psdw->get_Count(&cItems);

    if ((int)(m_iCur + cSkip) >= cItems)
        return S_FALSE;

    m_iCur += cSkip;
    return S_OK;
}

STDMETHODIMP CSDEnumWindows::Reset(void)
{
    m_iCur = 0;
    return S_OK;
}

STDMETHODIMP CSDEnumWindows::Clone(LPENUMVARIANT *ppEnum)
{
    CSDEnumWindows *pNew = new CSDEnumWindows(m_psdw);
    if (pNew)
    {
        *ppEnum = SAFECAST(pNew, IEnumVARIANT *);
        return S_OK;
    }

    *ppEnum = NULL;
    return E_OUTOFMEMORY;
}

LRESULT CALLBACK CSDWindows::s_ThreadNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSDWindows* pThis = (CSDWindows*)GetWindowPtr0(hwnd);
    LRESULT lRes = 0;
    
    if (uMsg < WM_USER)
    {
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else    
    {
        switch (uMsg) 
        {
        case WM_INVOKE_ON_RIGHT_THREAD:
            pThis->_DoInvokeCookie((DISPID)wParam, (LONG)lParam, FALSE);
            break;
        }
    }
    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\tasklist.cpp ===
#include "priv.h"
#include "resource.h"
#include <trayp.h>

class TaskbarList : public ITaskbarList2
{
public:
    TaskbarList();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITaskbarList Methods
    STDMETHODIMP HrInit(void);
    STDMETHODIMP AddTab(HWND hwnd);
    STDMETHODIMP DeleteTab(HWND hwnd);
    STDMETHODIMP ActivateTab(HWND hwnd);
    STDMETHODIMP SetActiveAlt(HWND hwnd);

    // ITaskbarList2 Methods
    STDMETHODIMP MarkFullscreenWindow(HWND hwnd, BOOL fFullscreen);

protected:
    ~TaskbarList();
    HWND _HwndGetTaskbarList(void);

    UINT        _cRef;
    HWND        _hwndTaskbarList;
    int         _wm_shellhook;
};


//////////////////////////////////////////////////////////////////////////////
//
// TaskbarList Object
//
//////////////////////////////////////////////////////////////////////////////

STDAPI TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    
    TaskbarList *pTL = new TaskbarList();
    if (pTL)
    {
        *ppunk = SAFECAST(pTL, IUnknown *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


TaskbarList::TaskbarList() 
{
    _cRef = 1;
    _hwndTaskbarList = NULL;
    _wm_shellhook = RegisterWindowMessage(TEXT("SHELLHOOK"));
    DllAddRef();
}       


TaskbarList::~TaskbarList()
{
    ASSERT(_cRef == 0);                 // should always have zero

    DllRelease();
}    

HWND TaskbarList::_HwndGetTaskbarList(void)
{
    if (_hwndTaskbarList && IsWindow(_hwndTaskbarList))
        return _hwndTaskbarList;

    _hwndTaskbarList = FindWindow(TEXT("Shell_TrayWnd"), NULL);
    if (_hwndTaskbarList)
        _hwndTaskbarList = (HWND)SendMessage(_hwndTaskbarList, WMTRAY_QUERY_VIEW, 0, 0);
    
    return _hwndTaskbarList;
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT TaskbarList::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(TaskbarList, ITaskbarList),
        QITABENT(TaskbarList, ITaskbarList2),
        { 0 },
    };

    return QISearch(this, qit, iid, ppv);
}

ULONG TaskbarList::AddRef()
{
    return ++_cRef;
}

ULONG TaskbarList::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;   
}


//////////////////////////////////
//
// ITaskbarList Methods...
//
HRESULT TaskbarList::HrInit(void)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL == NULL)
        return E_NOTIMPL;

    return S_OK;
}

HRESULT TaskbarList::AddTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWCREATED, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::DeleteTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWDESTROYED, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::ActivateTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
    {
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWACTIVATED, (LPARAM) hwnd);
        SendMessage(hwndTL, TBC_SETACTIVEALT , 0, (LPARAM) hwnd);
    }
    return S_OK;
}


HRESULT TaskbarList::SetActiveAlt(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, TBC_SETACTIVEALT , 0, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::MarkFullscreenWindow(HWND hwnd, BOOL fFullscreen)
{
    if (GetUIVersion() >= 6)
    {
        HWND hwndTL = _HwndGetTaskbarList();

        if (hwndTL)
            SendMessage(hwndTL, TBC_MARKFULLSCREEN, (WPARAM) fFullscreen, (LPARAM) hwnd);

        return S_OK;
    }

    return E_FAIL;   // ITaskbarList2 not supported downlevel
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\tframe.cpp ===
#include "priv.h"
#include <varutil.h>
#include "hlframe.h"
#include "winlist.h"
#include "resource.h" //CLSID_SearchBand
#include "interned.h" // IHTMLPrivateWindow

// Locally defined FINDFRAME flag used to guarantee ITargetFrame vs ITargetFrame2 compatibility

#define FINDFRAME_OLDINTERFACE FINDFRAME_INTERNAL


STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, LPVOID *ppv);
HRESULT TargetQueryService(LPUNKNOWN punk, REFIID riid, void **ppvObj);
HRESULT CoCreateNewIEWindow( DWORD dwClsContext, REFIID riid, void **ppvunk );

/******************************************************************

    NAME:       SetOleStrMember

    SYNOPSIS:   sets a new value for OleStr member
******************************************************************/
HRESULT SetOleStrMember(WCHAR **ppszMember, LPCOLESTR pszNewValue)
{
    HRESULT hr;

    if (*ppszMember)
    {
        LocalFree(*ppszMember);
        *ppszMember = NULL;
    }

    if (pszNewValue)
    {
        *ppszMember = StrDupW(pszNewValue);
        hr = *ppszMember ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        *ppszMember = NULL;
        hr = S_OK;
    }
    return hr;
}

/******************************************************************

    NAME:       GetOleStrMember

    SYNOPSIS:   gets a value for OleStr member as new CoTaskMemAlloc
    LPOLESTR
******************************************************************/
HRESULT GetOleStrMember(LPCOLESTR pszMember, WCHAR **ppszReturnValue)
{
    HRESULT hr;

    if (pszMember)
        hr = SHStrDupW(pszMember, ppszReturnValue);
    else
    {
        hr = S_OK;
        *ppszReturnValue = NULL;
    }
    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameName

    SYNOPSIS:   Sets the Frame Name.  Frees current one if exists.

********************************************************************/

STDMETHODIMP CIEFrameAuto::SetFrameName(LPCOLESTR pszFrameName)
{
    //  AOL and other 3rd Party 3.0 compatibility.  The ITargetNotify
    //  object that sets off a window open operation via AOL container
    //  registers itself in ShellCallbacks list and wnsprintf's the
    //  coresponding cookie in the front of the frame name ("" if there
    //  is no frame name as in _blank).  we extract the cookie, notify
    //  all registered callbacks, then set the name MINUS the _[NNNNN..]
    //  that was prepending to the frame name.
    if (pszFrameName && lstrlen(pszFrameName) >= 2 && pszFrameName[0] == '_' && pszFrameName[1] == '[')
    {
#define MAX_COOKIE 24
        WCHAR wszCookie[MAX_COOKIE + 1];   // big enough for "cbCookie"
        int i;
        long cbCookie;
        BOOL fNonDigit = FALSE;
        IShellWindows*   psw = NULL;

        for (i = 2; i < MAX_COOKIE && pszFrameName[i] && pszFrameName[i] != ']'; i++)
        {
            wszCookie[i-2] = pszFrameName[i];
            if (i != 2 || pszFrameName[2] != '-')
                fNonDigit = fNonDigit ||  pszFrameName[i] < '0' || pszFrameName[i] > '9';
        }
        wszCookie[i-2] = 0;
        if (i >= 3 && pszFrameName[i] == ']' && !fNonDigit)
        {
            cbCookie = StrToIntW(wszCookie);
            psw = WinList_GetShellWindows(TRUE);
            if (psw)
            {
                IUnknown *punkThis;
                if (SUCCEEDED(QueryInterface(IID_PPV_ARG(IUnknown, &punkThis))))
                {
                    psw->OnCreated(cbCookie, punkThis);
                    punkThis->Release();
                }
                psw->Release();
            }
            pszFrameName = pszFrameName + i + 1;
            if (pszFrameName[0] == 0) 
                pszFrameName = NULL;
        }
    }
    return SetOleStrMember(&m_pszFrameName, pszFrameName);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameName

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::GetFrameName(WCHAR **ppszFrameName)
{
    return GetOleStrMember(m_pszFrameName, ppszFrameName);
}


/*******************************************************************

    NAME:       CIEFrameAuto::_GetParentFramePrivate

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.
    
    NOTE: THIS PRIVATE VERSION doesn't check for parent being desktopframe.

********************************************************************/
HRESULT CIEFrameAuto::_GetParentFramePrivate(LPUNKNOWN *ppunkParentFrame)
{
    LPOLEOBJECT pOleObject = NULL;
    LPOLECLIENTSITE pOleClientSite = NULL;
    HRESULT hr = S_OK;
    LPUNKNOWN punkParent = NULL;

    //  Start off with OleObject for this OCX embedding, it will
    //  be null if we're top level (a CIEFrameAuto, not a CVOCBrowser)
    _GetOleObject(&pOleObject);
    if (pOleObject != NULL)
    {

    //  Assumes GetClientSite succeeds and returns NULL if we
    //  are not embedded
        hr = pOleObject->GetClientSite(&pOleClientSite);
        if (FAILED(hr)) 
            goto errExit;
        pOleObject->Release();
        pOleObject = NULL;

    //  If pOleClientSite is NULL, then we are at the top level
        if (pOleClientSite == NULL)
        {
            hr = S_OK;
            goto errExit;
        }
        else
        {
            hr = TargetQueryService(pOleClientSite, IID_PPV_ARG(IUnknown, &punkParent));
            if (FAILED(hr)) 
            {
                // if parent container does not support ITargetFrame, then
                // the parent container must be some other app, like VB.  In this
                // case, we've already found the outermost frame (us).  Return
                // S_OK and a NULL ptgfTargetFrame which indicates that we are the
                // outermost HTML frame.
                hr = S_OK;
            }
            SAFERELEASE(pOleClientSite);
        }
    }

errExit:
    SAFERELEASE(pOleObject);
    SAFERELEASE(pOleClientSite);
    *ppunkParentFrame = punkParent;
    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::GetParentFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.

********************************************************************/
STDMETHODIMP CIEFrameAuto::GetParentFrame(LPUNKNOWN *ppunkParentFrame)
{
    HRESULT hr = _GetParentFramePrivate(ppunkParentFrame);
    
    //  Check if the parent is the desktop, if so, the frame chain stops
    //  at us
    if (SUCCEEDED(hr) && *ppunkParentFrame)
    {
       LPTARGETFRAME2 ptgfParent;
       DWORD dwOptions;

       if (SUCCEEDED((*ppunkParentFrame)->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgfParent))))
       {
           ptgfParent->GetFrameOptions(&dwOptions);
           if (dwOptions & FRAMEOPTIONS_DESKTOP)
           {
               (*ppunkParentFrame)->Release();
               *ppunkParentFrame = NULL;
           }
           ptgfParent->Release();
       }
    }
    return hr;
}

// PLEASE PROPOGATE ANY CHANGES TO THESE ENUMS TO \mshtml\iextag\httpwfh.h
typedef enum _TARGET_TYPE {
TARGET_FRAMENAME,
TARGET_SELF,
TARGET_PARENT,
TARGET_BLANK,
TARGET_TOP,
TARGET_MAIN,
TARGET_SEARCH,
TARGET_MEDIA
} TARGET_TYPE;

typedef struct _TARGETENTRY {
    TARGET_TYPE targetType;
    const WCHAR *pTargetValue;
} TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SEARCH, L"_search"},
    {TARGET_MEDIA, L"_media"},
    {TARGET_SELF, NULL}
};


/*******************************************************************

    NAME:       ParseTargetType

    SYNOPSIS:   Maps pszTarget into a target class.

    IMPLEMENTATION:
    Treats unknown MAGIC targets as _self

********************************************************************/
// PLEASE PROPOGATE ANY CHANGES TO THIS FUNCTION TO \mshtml\iextag\httpwf.cxx
TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') 
        return TARGET_FRAMENAME;
        
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) 
            return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;

}

/*******************************************************************

    NAME:       TargetQueryService

    SYNOPSIS:   Returns a pointer to containing Browser's ITargetFrame
                interface (or NULL if container does not support it)

    NOTES:      If we don't yet have this interface pointer yet,
                this function will QueryInterface to get it.

********************************************************************/
HRESULT TargetQueryService(LPUNKNOWN punk, REFIID riid, void **ppvObj)
{
    //  Get the ITargetFrame for the embedding.
    return IUnknown_QueryService(punk, IID_ITargetFrame2, riid, ppvObj);
}


/*******************************************************************

    NAME:       _TargetTopLevelWindows

    SYNOPSIS:   see FindFrame, does the named targets across windows

********************************************************************/
HRESULT _TargetTopLevelWindows(LPTARGETFRAMEPRIV ptgfpThis, LPCOLESTR pszTargetName, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame)
{
    IShellWindows*   psw = NULL;
    HRESULT hr = E_FAIL;

    *ppunkTargetFrame = NULL;
    psw = WinList_GetShellWindows(TRUE);
    if (psw != NULL)
    {
        IUnknown *punkEnum;
        IEnumVARIANT *penumVariant;
        VARIANT VarResult;
        BOOL fDone = FALSE;
        LPTARGETFRAMEPRIV ptgfpWindowFrame;

        hr = psw->_NewEnum(&punkEnum);
        if (SUCCEEDED(hr))
        {
            hr = punkEnum->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &penumVariant));
            if (SUCCEEDED(hr))
            {
                while (!fDone)
                {
                    VariantInit(&VarResult);
                    hr = penumVariant->Next(1, &VarResult, NULL);
                    if (hr == NOERROR)
                    {
                        if (VarResult.vt == VT_DISPATCH && VarResult.pdispVal)
                        {
                            hr = VarResult.pdispVal->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpWindowFrame));
                            if (SUCCEEDED(hr))
                            {
                                if (ptgfpWindowFrame != ptgfpThis)
                                {
                                    hr = ptgfpWindowFrame->FindFrameDownwards(pszTargetName, dwFlags, ppunkTargetFrame);
                                    if (SUCCEEDED(hr) && *ppunkTargetFrame != NULL)
                                    {
                                        fDone = TRUE;
                                    }
                                }
                                ptgfpWindowFrame->Release();
                            }
                        }
                        VariantClear(&VarResult);
                    }
                    else
                    {
                        fDone = TRUE;
                    }
                }
                penumVariant->Release();
            }
            punkEnum->Release();
        }
        psw->Release();
    }
    return hr;
}

/*******************************************************************

  NAME:         CreateTargetFrame

  SYNOPSIS:     Creates a new window, if pszTargetName is not special
                target, names it pszTargetName.  returns IUnknown for
                the object that implements ITargetFrame,IHlinkFrame and
                IWebBrowserApp.
********************************************************************/
// PLEASE PROPOGATE ANY CHANGES TO THIS FUNCTION TO \mshtml\iextag\httpwf.cxx
HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk)
{
    LPTARGETFRAME2 ptgfWindowFrame;
    HRESULT hr = S_OK;

    //  Launch a new window, set it's frame name to pszTargetName
    //  return it's IUnknown. If the new window is passed to us,
    //  just set the target name.

    if (NULL == *ppunk)
    {
        hr = CoCreateNewIEWindow(CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUnknown, ppunk));
    }

    if (SUCCEEDED(hr))
    {
        //  Don't set frame name if target is special or missing
        if (pszTargetName && ParseTargetType(pszTargetName) == TARGET_FRAMENAME)
        {
            HRESULT hrLocal;
            hrLocal = (*ppunk)->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgfWindowFrame));
            if (SUCCEEDED(hrLocal))
            {
                ptgfWindowFrame->SetFrameName(pszTargetName);
                ptgfWindowFrame->Release();
            }
        }

        // Even if we don't set the frame name, we still want to return
        // success, otherwise we'd have a blank window hanging around.
    }

    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::_DoNamedTarget

    SYNOPSIS:   see FindFrame, does the named targets.  checks itself
    then if that fails, all children except for punkContextFrame (if
    punkContextFrame != NULL).  if all of the above fail, will recurse
    upwards if necessary, if punkContextFrame != NULL.  if punkContextFrame
    is NULL, then this works out to checking ourself and all children
    then giving up.

********************************************************************/
HRESULT CIEFrameAuto::_DoNamedTarget(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN * ppunkTargetFrame)
{
    // asserts
    HRESULT hr = S_OK;
    HRESULT hrLocal;
    LPUNKNOWN punkParent = NULL;
    LPUNKNOWN punkThisFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpParent = NULL;
    LPUNKNOWN punkThis = NULL;
    LPUNKNOWN punkChildObj = NULL;
    LPUNKNOWN punkChildFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpChild = NULL;
    LPOLECONTAINER pOleContainer = NULL;
    LPENUMUNKNOWN penumUnknown = NULL;
    LPUNKNOWN punkProxyContextFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;

    ASSERT(ppunkTargetFrame);

    *ppunkTargetFrame = NULL;

    hr = QueryInterface(IID_PPV_ARG(IUnknown, &punkThis));
    ASSERT(punkThis != NULL);

    if (FAILED(hr))
        goto exitPoint;

    //  First check for match on US!
    if (m_pszFrameName && !StrCmpW(pszTargetName, m_pszFrameName))
    {
        *ppunkTargetFrame = punkThis;
        //  Set punkThis to NULL to prevent Release at exit
        punkThis = NULL;
        goto exitPoint;
    }
    //  we ask our ShellView's embedded DocObject if it supports ITargetFrame.  If it does,
    //  we first let it look for the target.
    hrLocal = GetFramesContainer(&pOleContainer);
    if (SUCCEEDED(hrLocal) && pOleContainer != NULL)
    {
        hr = pOleContainer->EnumObjects(OLECONTF_EMBEDDINGS, &penumUnknown);
        if (hr != S_OK || penumUnknown == NULL)
            goto exitPoint;

        while (TRUE)
        {
            hr = penumUnknown->Next(1, &punkChildObj, NULL);
            if (punkChildObj == NULL)
            {
                hr = S_OK;
                break;
            }
            hrLocal = punkChildObj->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpChild));
            if (SUCCEEDED(hrLocal))
            {
                hr = ptgfpChild->QueryInterface(IID_PPV_ARG(IUnknown, &punkChildFrame));
                if (FAILED(hr))
                    goto exitPoint;

                //  IF this isn't the punkContextFrame, see if embedding supports ITargetFrame
                if (punkChildFrame != punkContextFrame)
                {
                    hr = ptgfpChild->FindFrameDownwards(pszTargetName, dwFlags, ppunkTargetFrame);
                    if (hr != S_OK || *ppunkTargetFrame != NULL)
                        goto exitPoint;
                }
            }
            punkChildObj->Release();
            punkChildObj = NULL;
            SAFERELEASE(punkChildFrame);
            SAFERELEASE(ptgfpChild);
        }
    }

    if (!(*ppunkTargetFrame) && pOleContainer)
    {
        hr = _FindWindowByName(pOleContainer, pszTargetName, ppunkTargetFrame);
        if (S_OK == hr)
            goto exitPoint;
    }

    //  We don't recurse to parent in punkContextFrame is NULL
    if (punkContextFrame == NULL)
        goto exitPoint;

    hr = GetParentFrame(&punkParent);

    if (hr != S_OK)
        goto exitPoint;

    if (punkParent != NULL)
    {
        //  We have a parent, recurse upwards, with ourself as context frame
        hr = punkParent->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpParent));
        if (hr != S_OK)
            goto exitPoint;

        hr = ptgfpParent->FindFrameInContext(pszTargetName,
                                             punkThis,
                                             dwFlags,
                                             ppunkTargetFrame);
        goto exitPoint;
    }

    //  At this point we've come to the top level frame.
    //  Enumerate top level windows, unless we're a toolbar

    *ppunkTargetFrame = NULL;
    if (_psb != _psbProxy)
    {
        //  Webbar : Find in context of top frame of proxy
        hr = TargetQueryService(_psbProxy, IID_PPV_ARG(ITargetFramePriv, &ptgfpTarget));
        if (SUCCEEDED(hr) && ptgfpTarget)
        {
            hr = ptgfpTarget->QueryInterface(IID_PPV_ARG(IUnknown, &punkProxyContextFrame));
            if (SUCCEEDED(hr))
            {
                hr = ptgfpTarget->FindFrameInContext(pszTargetName,
                                                     punkProxyContextFrame,
                                                     dwFlags,
                                                     ppunkTargetFrame);
                if (*ppunkTargetFrame)
                    goto exitPoint;
            }
        }
    }
    else if (!(FINDFRAME_OLDINTERFACE & dwFlags))
    {
        hr = _TargetTopLevelWindows((LPTARGETFRAMEPRIV)this, pszTargetName, dwFlags, ppunkTargetFrame);
        if (*ppunkTargetFrame)
            goto exitPoint;
    }

    //  Now we have exhausted all frames.  Unless FINDFRAME_JUSTTESTEXISTENCE
    //  is set in dwFlags, create a new window, set it's frame name and return it
    if (dwFlags & FINDFRAME_JUSTTESTEXISTENCE)
    {
        hr = S_OK;
    }
    else
    {
        //  CreateTargetFrame will not work with AOL 3.01 clients
        //  so we must return E_FAIL

        hr = E_FAIL;
    }


exitPoint:
    SAFERELEASE(punkProxyContextFrame);
    SAFERELEASE(ptgfpTarget);
    SAFERELEASE(punkThis);
    SAFERELEASE(punkThisFrame);
    SAFERELEASE(ptgfpParent);
    SAFERELEASE(punkParent);
    SAFERELEASE(punkChildFrame);
    SAFERELEASE(ptgfpChild);
    SAFERELEASE(penumUnknown);
    SAFERELEASE(pOleContainer);
    SAFERELEASE(punkChildObj);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::_FindWindowByName
//
//  Synopsis  : Searches the give container for the given frame name.
//              This method is called when _DoNamedTarget fails to find
//              the target frame in one of the container's embeddings.
//
//+-------------------------------------------------------------------------

HRESULT
CIEFrameAuto::_FindWindowByName(IOleContainer * pOleContainer,
                                LPCOLESTR       pszTargetName,
                                LPUNKNOWN     * ppunkTargetFrame)
{
    HRESULT hr;
    IHTMLDocument2     * pDocument;
    IHTMLPrivateWindow * pPrivWindow;
    IHTMLWindow2       * pHTMLWindow;
    IServiceProvider   * pServiceProvider;
    IWebBrowserApp     * pWebBrowserApp;

    ASSERT(pOleContainer);
    ASSERT(ppunkTargetFrame);

    hr = pOleContainer->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDocument));
    if (SUCCEEDED(hr))
    {
        hr = pDocument->get_parentWindow(&pHTMLWindow);
        if (SUCCEEDED(hr))
        {
            hr = pHTMLWindow->QueryInterface(IID_PPV_ARG(IHTMLPrivateWindow, &pPrivWindow));
            pHTMLWindow->Release(); // being reused below

            if (SUCCEEDED(hr))
            {
                hr = pPrivWindow->FindWindowByName(pszTargetName, &pHTMLWindow);
                if (S_OK == hr)
                {
                    hr = pHTMLWindow->QueryInterface(IID_PPV_ARG(IServiceProvider, &pServiceProvider));
                    if (S_OK == hr)
                    {
                        hr = pServiceProvider->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowserApp, &pWebBrowserApp));
                        if (S_OK == hr)
                        {
                            *ppunkTargetFrame = SAFECAST(pWebBrowserApp, IUnknown*);
                            (*ppunkTargetFrame)->AddRef();

                            pWebBrowserApp->Release();
                        }
                        pServiceProvider->Release();
                    }
                    pHTMLWindow->Release();
                }
                pPrivWindow->Release();
            }
        }
        pDocument->Release();
    }

    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameSrc

    SYNOPSIS:   Sets the Frame original SRC url.  Frees current one if exists.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameSrc(LPCOLESTR pszFrameSrc)
{
    return SetOleStrMember(&m_pszFrameSrc, pszFrameSrc);
}

IShellView* CIEFrameAuto::_GetShellView(void)
{
    IShellView* psv = NULL;
    if (_psb) 
    {
        _psb->QueryActiveShellView(&psv);
    }

    return psv;
}

/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameSrc

    SYNOPSIS:   Gets the Frame original URL.  Allocates a copy (this is an
    [OUT] parameter

    NOTES:      If we are at top level, SRC is dynamic, so ask our
    contained DocObject to do it for us.

********************************************************************/
HRESULT CIEFrameAuto::GetFrameSrc(WCHAR **ppszFrameSrc)
{
    LPUNKNOWN punkParent = NULL;
    LPTARGETFRAME ptgfTargetFrame = NULL;
    LPTARGETCONTAINER ptgcTargetContainer = NULL;

    *ppszFrameSrc = NULL;
    HRESULT hr = GetParentFrame(&punkParent);
    if (hr != S_OK) 
        goto exitPoint;

    // If we're an embedding we have original src. If we're top level and
    // src has been set, return that, else defer to document
    if (punkParent != NULL || m_pszFrameSrc)
    {
        hr = GetOleStrMember(m_pszFrameSrc, ppszFrameSrc);
    }
    else // We're top level without an explicit SRC
    {
        *ppszFrameSrc = NULL;
        hr = S_OK; // review: since we are w/o SRC, we should succeed even though we don't fill out ppszFrameSrc in failure case?
        IShellView* psv = _GetShellView();
        if (psv)
        {
            HRESULT hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(ITargetContainer, &ptgcTargetContainer));
            if (SUCCEEDED(hrLocal))
            {
                hr = ptgcTargetContainer->GetFrameUrl(ppszFrameSrc);
            }
            else
            {
                //  Backwards compatibility
                hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(ITargetFrame, &ptgfTargetFrame));
                if (SUCCEEDED(hrLocal))
                {
                    hr = ptgfTargetFrame->GetFrameSrc(ppszFrameSrc);
                }
            }
            psv->Release();
        }
    }

exitPoint:
    SAFERELEASE(punkParent);
    SAFERELEASE(ptgfTargetFrame);
    SAFERELEASE(ptgcTargetContainer);
    return hr;
}



    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFramesContainer

    SYNOPSIS:   Returns an addref'ed pointer to the LPOLECONTAINER
    for our nested frames.  Can be NULL.

********************************************************************/
HRESULT CIEFrameAuto::GetFramesContainer(LPOLECONTAINER *ppContainer)
{
    LPTARGETFRAME ptgfTargetFrame = NULL;
    LPTARGETCONTAINER ptgcTargetContainer = NULL;

    HRESULT hr = E_FAIL;
    *ppContainer = NULL;
    IShellView* psv = _GetShellView();
    if (psv)
    {
        HRESULT hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(ITargetContainer, &ptgcTargetContainer));
        if (SUCCEEDED(hrLocal))
        {
            hr = ptgcTargetContainer->GetFramesContainer(ppContainer);
        }
        else
        {
            //  Backwards compatibility
            hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(ITargetFrame, &ptgfTargetFrame));
            if (SUCCEEDED(hrLocal))
            {
                hr = ptgfTargetFrame->GetFramesContainer(ppContainer);
            }
        }
        psv->Release();
    }
    SAFERELEASE(ptgcTargetContainer);
    SAFERELEASE(ptgfTargetFrame);

    return hr;
}


/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameOptions

    SYNOPSIS:   Sets the Frame Options.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameOptions(DWORD dwFlags)
{
    m_dwFrameOptions = dwFlags;
    return S_OK;
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameOptions

    SYNOPSIS:   Returns the frame options

********************************************************************/

HRESULT CIEFrameAuto::GetFrameOptions(LPDWORD pdwFlags)
{
    *pdwFlags = m_dwFrameOptions;

    // If we are full screen turn on a few extras...
    VARIANT_BOOL fFullScreen;
    if ((SUCCEEDED(get_FullScreen(&fFullScreen)) && fFullScreen == VARIANT_TRUE) ||
        (SUCCEEDED(get_TheaterMode(&fFullScreen)) && fFullScreen == VARIANT_TRUE)) 
    {
        *pdwFlags |= FRAMEOPTIONS_SCROLL_AUTO | FRAMEOPTIONS_NO3DBORDER;
    } 
    else if (_psbProxy != _psb) 
    {
        // If we are in the WebBar, turn off the 3D border. 
        *pdwFlags |= FRAMEOPTIONS_NO3DBORDER;
    }
    // if we are desktop, turn on FRAMEOPTIONS_DESKTOP
    if (_fDesktopFrame)
    {
        *pdwFlags |= FRAMEOPTIONS_DESKTOP;
    }
    return S_OK;
}


/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameMargins

    SYNOPSIS:   Sets the Frame margins.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    m_dwFrameMarginWidth = dwWidth;
    m_dwFrameMarginHeight = dwHeight;
    return S_OK;
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameMargins

    SYNOPSIS:   Returns the frame margins

********************************************************************/

HRESULT CIEFrameAuto::GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight)
{
    *pdwWidth = m_dwFrameMarginWidth;
    *pdwHeight = m_dwFrameMarginHeight;
    return S_OK;
}

/*******************************************************************

    NAME:       CIEFrameAuto::_fDesktopComponent

    SYNOPSIS:   Returns TRUE if this frame is a desktop component
    top level frame or a the top frame of a browser band other than
    the search pane.  These panes need special treatment of FindFrame
    and navigate.

*******************************************************************/
BOOL CIEFrameAuto::_fDesktopComponent()
{
    BOOL fInDesktop = FALSE;
    LPUNKNOWN punkParent;

    //  Special interpretation for desktop components and non-search browser bands
    //  NULL pszTargetName at top level frames is defined as being targeted
    //  to the window whose frame is "_desktop".  this will create a new top level
    //  browser as necessary and return it's frame.
    if (SUCCEEDED(_GetParentFramePrivate(&punkParent)) && punkParent)
    {
        DWORD dwOptions;
        LPTARGETFRAME2 ptgfTop;
        //  not a top level frame unless our parent is desktop frame
        if (SUCCEEDED(punkParent->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgfTop))))
        {
            if (SUCCEEDED(ptgfTop->GetFrameOptions(&dwOptions)))
            {
                fInDesktop = (dwOptions & FRAMEOPTIONS_DESKTOP) ? TRUE:FALSE;
            }
            ptgfTop->Release();
        }
        punkParent->Release();
    }
    else if (m_dwFrameOptions & FRAMEOPTIONS_BROWSERBAND)
    {
        //  a browser band - check for search band (proxied hlinkframe)
        fInDesktop = _psb == _psbProxy;
    }
    return fInDesktop;
}

//  ITargetFrame2 members
    
/*******************************************************************

    NAME:       CIEFrameAuto::GetTargetAlias

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::GetTargetAlias(LPCOLESTR pszTargetName, WCHAR **ppszTargetAlias)
{
    //  Special interpretation for desktop components and non-search browser bands
    //  NULL pszTargetName and "_top" at top level frames are defined as being targeted
    //  to the window whose frame is "_desktop".  this will create a new top level
    //  browser as necessary and return it's frame.

    if (pszTargetName == NULL && _fDesktopComponent())
        return GetOleStrMember(L"_desktop", ppszTargetAlias);
    *ppszTargetAlias = NULL;
    return E_FAIL;
}

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the frame referenced
    by pszTarget. This pointer must be Released by Caller after use.
    punkContextFrame, if not NULL, is the IUnknown pointer for the immediate
    descendent frame in whose subtree the Target reference (eg anchor with a Target tag)
    resides.  dwFlags are flags which modify FindFrame's behaviour and
    can be any combination of FINDFRAME_FLAGS. In particular, SETTING
    FINDFRAME_JUSTTESTEXISTENCE allows the caller to defeat the default
    FindFrame behavior of creating a new top level frame named pszTarget,
    if pszTarget does not exist.

    IMPLEMENTATION:

    NOTE: In HTML all anchors and other TARGET tags can occur ONLY in
    leaf FRAMES!!

    punkContextFrame is significant only if pszTarget is not
    a MAGIC target name (_self, _top, _blank, _parent).

    Non-MAGIC target names:

    first off, this frame should check if it matches pszTarget and return
    it's own IUnknown pointer forthwith.

    if punkContextFrame is not NULL, all child Frames
    except punkContextFrame should be searched (depth first) for
    pszTarget with punkContextFrame == NULL.  on failure, the parent of this
    frame should be recursively called with this frame replacing punkContextFrame.
    if this is a top level Frame (so there is no parent), all top level frames
    should be called with punkContextFrame == NULL.  if this fails, then a new top level
    frame should be created (unless FINDFRAME_JUSTTESTEXISTENCE is set in
    dwFlags), named pszTarget and its IUnknown returned.

    if punkContextFrame is NULL, all child Frames should be searched
    depth first for pszTarget.  on failure, NULL should be returned.


    MAGIC target names:

    _self should return the IUnknown of this ITargetFrame
    _top should be recursively passed up to the top level ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _parent should return the IUnknown of the FrameParent ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _blank should be recursively passed up to the top level ITargetFrame,
    which should create a unnamed top level frame

********************************************************************/

STDMETHODIMP CIEFrameAuto::FindFrame(LPCOLESTR pszTargetName,
                                           DWORD dwFlags,
                                           LPUNKNOWN *ppunkTargetFrame)
{
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;
    LPUNKNOWN punkContextFrame = NULL;
    HRESULT hr = E_FAIL;
    BOOL fInContext = TRUE;
    BOOL fWasMain = FALSE;
    TARGET_TYPE targetType;

    if (pszTargetName == NULL || *pszTargetName == 0)
        pszTargetName = L"_self";
    targetType  = ParseTargetType(pszTargetName);
    if (targetType == TARGET_MAIN)
    {
        fWasMain = TRUE;
        pszTargetName = L"_self";
    }

    *ppunkTargetFrame = NULL;

    // Default behavior:
    //  If this is a webbar and targeting _main, find frame in _psbProxy and return it
    //  If this is in browser, find frame relative to ourselves
    if (_psb != _psbProxy && fWasMain)
    {
        //  Webbar : Find in context of top frame of proxy
        hr = TargetQueryService(_psbProxy, IID_PPV_ARG(ITargetFramePriv, &ptgfpTarget));
    }
    else
    {
        //   Browser : A normal find in context in ourself
        hr = QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpTarget));
    }

    if (SUCCEEDED(hr) && ptgfpTarget)
    {
        if (fInContext) 
        {
            hr = ptgfpTarget->QueryInterface(IID_PPV_ARG(IUnknown, &punkContextFrame));
            if (SUCCEEDED(hr))
            {
                hr = ptgfpTarget->FindFrameInContext(pszTargetName,
                                                     punkContextFrame,
                                                     dwFlags,
                                                     ppunkTargetFrame);
            }
        }
        else
        {
            hr = ptgfpTarget->FindFrameDownwards(pszTargetName,
                                                 dwFlags,
                                                 ppunkTargetFrame);
        }

    }

    SAFERELEASE(punkContextFrame);
    SAFERELEASE(ptgfpTarget);
    if (SUCCEEDED(hr) 
        && *ppunkTargetFrame == NULL
        && !(FINDFRAME_OLDINTERFACE&dwFlags)) hr = S_FALSE;
    return hr;
}

//  ITargetFramePriv members

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrameDownwards

    SYNOPSIS:   

    IMPLEMENTATION:


********************************************************************/

STDMETHODIMP CIEFrameAuto::FindFrameDownwards(LPCOLESTR pszTargetName,
                                              DWORD dwFlags,
                                              LPUNKNOWN *ppunkTargetFrame)
{
    return FindFrameInContext(pszTargetName, 
                              NULL, 
                              dwFlags | FINDFRAME_JUSTTESTEXISTENCE,
                              ppunkTargetFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrameInContext

    SYNOPSIS:   

    IMPLEMENTATION:


********************************************************************/

// can this function be any bigger?

STDMETHODIMP CIEFrameAuto::FindFrameInContext(LPCOLESTR pszTargetName,
                                              LPUNKNOWN punkContextFrame,
                                              DWORD dwFlags,
                                              LPUNKNOWN *ppunkTargetFrame)
{
    //asserts
    TARGET_TYPE targetType;
    HRESULT hr = S_OK;
    LPUNKNOWN punkParent = NULL;
    LPUNKNOWN punkThisFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTargetFrame = NULL;
    LPUNKNOWN punkThis = NULL;

    targetType  = ParseTargetType(pszTargetName);
    if (targetType == TARGET_FRAMENAME)
    {
        hr = _DoNamedTarget(pszTargetName, punkContextFrame, dwFlags, ppunkTargetFrame);
        goto exitPoint;
    }

    //  Must be a Magic Target

    //for search, first show the search bar and then reach across to get it's TargetFrame
    if (targetType == TARGET_SEARCH)
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        InitFakeBSTR(&strGuid, CLSID_SearchBand);

        vaGuid.vt = VT_BSTR;
        vaGuid.bstrVal = strGuid.wsz;

        //if we're in an explorer bar, use the proxy's pbs
        IBrowserService *pbs = _pbs;
        if (_psb != _psbProxy)
        {
            EVAL(SUCCEEDED(_psbProxy->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))));
        }

        IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &vaGuid, NULL);

        VARIANT vaPunkBand = {0};
        hr = IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_GETBROWSERBAR, NULL, NULL, &vaPunkBand);

        if (_psb != _psbProxy)
        {
            ATOMICRELEASE(pbs);
        }

        if (hr == S_OK)
        {
            IDeskBand* pband = (IDeskBand*)vaPunkBand.punkVal;
            ASSERT(pband);
            
            if (pband)
            {
                IBrowserBand* pbb;
                hr = pband->QueryInterface(IID_PPV_ARG(IBrowserBand, &pbb));
                if (SUCCEEDED(hr))
                {
                    // now, get the pidl search pane is navigated to.
                    // if it's null we have to navigate it to something -- default search url (web search)
                    // this used to be in CSearchBand::_NavigateOC but caused problems
                    // if user had dial up networking set up and tried to get to the file search we would 
                    // first set pidl to web search url (_NavigateOC is called by _CreateOCHost) which would 
                    // cause AutoDial dialog to come up and then we would navigate the pane to the file search
                    // (nt5 bug#186970) reljai -- 6/22/98
                    VARIANT varPidl = {0};
                    if (SUCCEEDED(IUnknown_Exec(pbb, &CGID_SearchBand, SBID_GETPIDL, 0, NULL, &varPidl)))
                    {
                        ISearchItems* psi;
                        LPITEMIDLIST  pidl = VariantToIDList(&varPidl);
                        
                        VariantClear(&varPidl);
                        if (!pidl && SUCCEEDED(IUnknown_QueryService(pbb, SID_SExplorerToolbar, IID_PPV_ARG(ISearchItems, &psi))))
                        {
                            // get the default search url
                            WCHAR wszSearchUrl[INTERNET_MAX_URL_LENGTH];
                            if (SUCCEEDED(psi->GetDefaultSearchUrl(wszSearchUrl, ARRAYSIZE(wszSearchUrl))))
                            {
                                IBandNavigate* pbn;
                                if (SUCCEEDED(pbb->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn))))
                                {
                                    // reuse pidl
                                    IECreateFromPathW(wszSearchUrl, &pidl);
                                    pbn->Select(pidl);
                                    pbn->Release();
                                }
                            }
                            psi->Release();
                        }
                        ILFree(pidl);
                    }
                    
                    IWebBrowser2* pwb;
                    hr = pbb->GetObjectBB(IID_PPV_ARG(IWebBrowser2, &pwb));
                    //set the search pane's opener property
                    if (SUCCEEDED(hr))
                    {
                        IDispatch* pdisp;
                        if (SUCCEEDED(pwb->get_Document(&pdisp)) && pdisp)
                        {
                            IHTMLDocument2* pDoc;
                            if (SUCCEEDED(pdisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc))) && pDoc)
                            {
                                IHTMLWindow2* pWindow;
                                if (SUCCEEDED(pDoc->get_parentWindow(&pWindow)) && pWindow)
                                {
                                    VARIANT var;
                                    VariantInit(&var);
                                    var.vt = VT_DISPATCH;
                                    // unknown or dispatch QI?
                                    _omwin.QueryInterface(IID_IUnknown, (void **)&var.pdispVal);
                                    
                                    pWindow->put_opener(var);

                                    VariantClear(&var);
                                    pWindow->Release();
                                }
                                pDoc->Release();
                            }
                            pdisp->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = pwb->QueryInterface(IID_ITargetFramePriv, (void **)ppunkTargetFrame);
                        pwb->Release();
                    }
                    pbb->Release();
                }
                pband->Release();
            }
        }
        else
        {
            //maybe we're the search bar
            //hack to let search pane know to remember the next navigation
            IUnknown *punkThis;
            if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IUnknown, &punkThis))))
            {
                hr = QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpTargetFrame));
                if (SUCCEEDED(hr))
                    *ppunkTargetFrame = ptgfpTargetFrame;
                ptgfpTargetFrame = NULL;
                punkThis->Release();
            }
        }
        
        goto exitPoint;
    }

    // content pane of MediaBar:
    if (targetType == TARGET_MEDIA)
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        InitFakeBSTR(&strGuid, CLSID_MediaBand);

        vaGuid.vt = VT_BSTR;
        vaGuid.bstrVal = strGuid.wsz;

        //if we're in an explorer bar, use the proxy's pbs
        IBrowserService *pbs = _pbs;
        if (_psb != _psbProxy)
        {
            EVAL(SUCCEEDED(_psbProxy->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))));
        }

        IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &vaGuid, NULL);

        VARIANT vaPunkBand = {0};
        hr = IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_GETBROWSERBAR, NULL, NULL, &vaPunkBand);

        if (_psb != _psbProxy)
        {
            ATOMICRELEASE(pbs);
        }

        if (hr == S_OK)
        {
            IDeskBand* pband = (IDeskBand*)vaPunkBand.punkVal;
            ASSERT(pband);
            
            if (pband)
            {
                IBrowserBand* pbb;
                hr = pband->QueryInterface(IID_PPV_ARG(IBrowserBand, &pbb));
                if (SUCCEEDED(hr))
                {
                    IWebBrowser2* pwb;
                    hr = pbb->GetObjectBB(IID_PPV_ARG(IWebBrowser2, &pwb));

                    //set the media pane's opener property
                    if (SUCCEEDED(hr))
                    {
                        IDispatch* pdisp;
                        if (SUCCEEDED(pwb->get_Document(&pdisp)) && pdisp)
                        {
                            IHTMLDocument2* pDoc;
                            if (SUCCEEDED(pdisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc))) && pDoc)
                            {
                                IHTMLWindow2* pWindow;
                                if (SUCCEEDED(pDoc->get_parentWindow(&pWindow)) && pWindow)
                                {
                                    VARIANT var;
                                    VariantInit(&var);
                                    var.vt = VT_DISPATCH;
                                    // are we supposed to QI for dispatch or unknown here?
                                    _omwin.QueryInterface(IID_IUnknown, (void**)&var.pdispVal);
                                    
                                    pWindow->put_opener(var);

                                    VariantClear(&var);
                                    pWindow->Release();
                                }
                                pDoc->Release();
                            }
                            pdisp->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = pwb->QueryInterface(IID_ITargetFramePriv, (void **)ppunkTargetFrame);
                        pwb->Release();
                    }

                    pbb->Release();
                }
                pband->Release();
            }
        }
        else
        {
            ASSERT(0);      // means we have no explorer bands at all........
                            // but the SHDVID_SHOWBROWSERBAR just before does launch the media bar
        }
        
        goto exitPoint;
    }



    hr = QueryInterface(IID_PPV_ARG(IUnknown, &punkThis));
    ASSERT(punkThis != NULL);
    if (targetType == TARGET_SELF)
    {
        *ppunkTargetFrame = punkThis;
    //  Set punkThis to NULL to prevent Release at exit
        punkThis = NULL;
    }
    else  // _blank, _parent, _top
    {
        hr = GetParentFrame(&punkParent);
        if (hr != S_OK) goto exitPoint;

        if (punkParent == NULL)
        {
            if (targetType == TARGET_PARENT || targetType == TARGET_TOP)
            {
                *ppunkTargetFrame = punkThis;
                //  Set punkThis to NULL to prevent Release at exit
                punkThis = NULL;
            }
            else // TARGET_BLANK
            {
                if (dwFlags & FINDFRAME_JUSTTESTEXISTENCE)
                {
                    //  It is the client's responsibility to handle "_blank"
                    hr = S_OK;
                }
                else
                {
                    //  CreateTargetFrame will not work with AOL 3.01 clients
                    //  so we must return E_FAIL

                    hr = E_FAIL;
                }
                *ppunkTargetFrame = NULL;
            }
        }
        else // punkParent != NULL
        {
            //  Handle parent ourself, defer _top and _blank to top level frame
            if (targetType == TARGET_PARENT)
            {
                *ppunkTargetFrame = punkParent;
                //  Set punkThisFrame to NULL to prevent Release at exit
                punkParent = NULL;
            }
            else
            {
                hr = punkParent->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpTargetFrame));
                if (hr != S_OK) 
                    goto exitPoint;
                hr = ptgfpTargetFrame->FindFrameInContext(pszTargetName,
                                             punkThis,
                                             dwFlags,
                                             ppunkTargetFrame);
            }
        }
    }

exitPoint:
    SAFERELEASE(punkThis);
    SAFERELEASE(punkThisFrame);
    SAFERELEASE(ptgfpTargetFrame);
    SAFERELEASE(punkParent);
    return hr;
}

HRESULT CIEFrameAuto::_GetOleObject(IOleObject** ppobj)
{
    HRESULT hres = E_UNEXPECTED;
    if (_pbs) {
        hres = _pbs->GetOleObject(ppobj);
    }

    return hres;
}

//  ITargetFrame implementation for backwards compatibility

HRESULT CIEFrameAuto::CTargetFrame::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->QueryInterface(riid, ppvObj);
}

ULONG CIEFrameAuto::CTargetFrame::AddRef(void) 
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->AddRef();
}

ULONG CIEFrameAuto::CTargetFrame::Release(void) 
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->Release();
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameName

    SYNOPSIS:   Sets the Frame Name.  Frees current one if exists.

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::SetFrameName(LPCOLESTR pszFrameName)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameName(pszFrameName);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameName

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::GetFrameName(WCHAR **ppszFrameName)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameName(ppszFrameName);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetParentFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.

********************************************************************/
STDMETHODIMP CIEFrameAuto::CTargetFrame::GetParentFrame(LPUNKNOWN *ppunkParentFrame)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetParentFrame(ppunkParentFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::FindFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the frame referenced
    by pszTarget. This pointer must be Released by Caller after use.
    punkContextFrame, if not NULL, is the IUnknown pointer for the immediate
    descendent frame in whose subtree the Target reference (eg anchor with a Target tag)
    resides.  dwFlags are flags which modify FindFrame's behaviour and
    can be any combination of FINDFRAME_FLAGS. In particular, SETTING
    FINDFRAME_JUSTTESTEXISTENCE allows the caller to defeat the default
    FindFrame behavior of creating a new top level frame named pszTarget,
    if pszTarget does not exist.

    IMPLEMENTATION:

    NOTE: In HTML all anchors and other TARGET tags can occur ONLY in
    leaf FRAMES!!

    punkContextFrame is significant only if pszTarget is not
    a MAGIC target name (_self, _top, _blank, _parent).

    Non-MAGIC target names:

    first off, this frame should check if it matches pszTarget and return
    it's own IUnknown pointer forthwith.

    if punkContextFrame is not NULL, all child Frames
    except punkContextFrame should be searched (depth first) for
    pszTarget with punkContextFrame == NULL.  on failure, the parent of this
    frame should be recursively called with this frame replacing punkContextFrame.
    if this is a top level Frame (so there is no parent), all top level frames
    should be called with punkContextFrame == NULL.  if this fails, then a new top level
    frame should be created (unless FINDFRAME_JUSTTESTEXISTENCE is set in
    dwFlags), named pszTarget and its IUnknown returned.

    if punkContextFrame is NULL, all child Frames should be searched
    depth first for pszTarget.  on failure, NULL should be returned.


    MAGIC target names:

    _self should return the IUnknown of this ITargetFrame
    _top should be recursively passed up to the top level ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _parent should return the IUnknown of the FrameParent ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _blank should be recursively passed up to the top level ITargetFrame,
    which should create a unnamed top level frame

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::FindFrame(LPCOLESTR pszTargetName,
                                      LPUNKNOWN punkContextFrame,
                                      DWORD dwFlags,
                                      LPUNKNOWN *ppunkTargetFrame)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);
    
    return pie->FindFrame(pszTargetName, dwFlags|FINDFRAME_OLDINTERFACE, ppunkTargetFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::RemoteNavigate

    SYNOPSIS:   Used in response to WM_COPYDATA message with dwData
                equal to TF_NAVIGATE.  Does a FindFrame (named
                target only) and if frame is not found returns
                S_FALSE.  If found, returns S_OK and fires off the
                navigate. cLength is number of ULONGs in pulData

    TODO:       Relies on RemoteNavigate member of top level MSHTML
                docobject host.  Need to write the equivalent code
                to work if top level frame contains some other DocObject.
                Post,etc require help from bindstatuscallback.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::RemoteNavigate(ULONG cLength,ULONG *pulData)
{
    //  FEATURE chrisfra 10/22/96 - this is now here purely for backwards compatibility and
    //  should be removed for ie4.0
    return E_FAIL;
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameSrc

    SYNOPSIS:   Sets the Frame original SRC url.  Frees current one if exists.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameSrc(LPCOLESTR pszFrameSrc)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameSrc(pszFrameSrc);
}
    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameSrc

    SYNOPSIS:   Gets the Frame original URL.  Allocates a copy (this is an
    [OUT] parameter

    NOTES:      If we are at top level, SRC is dynamic, so ask our
    contained DocObject to do it for us.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::GetFrameSrc(WCHAR **ppszFrameSrc)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameSrc(ppszFrameSrc);
}



    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFramesContainer

    SYNOPSIS:   Returns an addref'ed pointer to the LPOLECONTAINER
    for our nested frames.  Can be NULL.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::GetFramesContainer(LPOLECONTAINER *ppContainer)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFramesContainer(ppContainer);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameOptions

    SYNOPSIS:   Sets the Frame Options.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameOptions(DWORD dwFlags)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameOptions(dwFlags);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameOptions

    SYNOPSIS:   Returns the frame options

********************************************************************/

HRESULT CIEFrameAuto::CTargetFrame::GetFrameOptions(LPDWORD pdwFlags)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameOptions(pdwFlags);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameMargins

    SYNOPSIS:   Sets the Frame margins.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameMargins(dwWidth, dwHeight);
}

    
/*******************************************************************

  NAME:       CIEFrameAuto::CTargetFrame::GetFrameMargins

    SYNOPSIS:   Returns the frame margins

********************************************************************/

HRESULT CIEFrameAuto::CTargetFrame::GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameMargins(pdwWidth, pdwHeight);
}


/*******************************************************************

  NAME:       CIEFrameAuto::FindBrowserByIndex

    SYNOPSIS:   Returns an IUnknown that points to a Browser that
                has the requested index

********************************************************************/

HRESULT CIEFrameAuto::FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser)
{
    HRESULT hr = S_OK;
    IOleContainer * poc = NULL;
    IBrowserService *pbs;
    ASSERT(ppunkBrowser);
    *ppunkBrowser = NULL;

    if (!_psb)
        return E_FAIL;

    // first check self
    if(SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        ASSERT(pbs);
        if(dwID == pbs->GetBrowserIndex())
        {
            //  this is the one...
            *ppunkBrowser = (IUnknown *)pbs;
            goto exitPoint;
        }
        SAFERELEASE(pbs);
    }

    hr = GetFramesContainer(&poc);
    if (SUCCEEDED(hr) && poc)
    {
        IEnumUnknown *penum = NULL;

        hr = E_FAIL;
        
        if (S_OK != poc->EnumObjects(OLECONTF_EMBEDDINGS, &penum) || penum == NULL) 
            goto exitPoint;

        IUnknown *punk;
        while (S_OK == penum->Next(1, &punk, NULL))
        {
            if (punk == NULL)
               break;

            ITargetFramePriv *ptf;
            if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptf))))
            {
                ASSERT(ptf);

                hr = ptf->FindBrowserByIndex(dwID, ppunkBrowser);
                ptf->Release();
            }

            punk->Release();
        
            if (SUCCEEDED(hr))  //foundit!
                break;

        }

        // Native frames - no WebBrowser OC in frame. Note that 
        // if a WebOC is included on a web page with an <OBJECT>
        // tag, navigations in the WebOC will be placed in the travel 
        // log. However, since the WebOC does not currently support 
        // ITravelLogClient, back and forward will not work correctly.
        // The WebOC will need to be updated to support ITravelLogClient.
        //        
        if (FAILED(hr))
        {
            IHTMLDocument2 *pDoc;
            if (SUCCEEDED(poc->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc))))
            {
                IHTMLWindow2 *pWnd;
                if (SUCCEEDED(pDoc->get_parentWindow(&pWnd)))
                {
                    IHTMLWindow2 *pTop;
                    if (SUCCEEDED(pWnd->get_top(&pTop)))
                    {
                        ITravelLogClient *ptlc;
                        if (SUCCEEDED(pTop->QueryInterface(IID_PPV_ARG(ITravelLogClient, &ptlc))))
                        {
                            hr = ptlc->FindWindowByIndex(dwID, ppunkBrowser);
                            ptlc->Release();
                        }
                        pTop->Release();
                    }
                    pWnd->Release();
                }
                pDoc->Release();
            }
        }
        
        SAFERELEASE(penum);
        poc->Release();
    }
    else 
    {
        hr = E_FAIL;
    }

exitPoint:

    return hr;
}

//  External helper function for TRIDENT when it stands alone w/o the steely thews of
//  shdocvw CIEFrameAuto to shield it's pityfull body.
STDAPI HlinkFindFrame(LPCWSTR pszFrameName, LPUNKNOWN *ppunk)
{
    HRESULT hres = E_FAIL;

    *ppunk = NULL;
    if (pszFrameName)
    {
        switch (ParseTargetType(pszFrameName))
        {
        case TARGET_FRAMENAME:
            hres = _TargetTopLevelWindows(NULL, pszFrameName, FINDFRAME_JUSTTESTEXISTENCE, ppunk);
            break;
        case TARGET_BLANK:
            hres = S_FALSE;
            break;
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\thicket.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       thicket.hxx
//
//  Contents:   Save as Office9 'Thicket' format API
//
//----------------------------------------------------------------------------

#ifndef _THICKET_HXX_
#define _THICKET_HXX_

void SaveBrowserFile( HWND hwnd, LPUNKNOWN punk );

#endif // _THICKET_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\tbext.h ===
///////////////////////////////////////////////////////
// File:   TBBxt.h    (Toolbar Button Extension Headers
// Author: Karim Farouki
//
// We declare here three classes:
// (1) CToolbarExt a base class that takes care of the
//     button work for our custom extensions
// (2) CToolbarExtBand the object which deals with custom
//     buttons that plug into bands
// (3) CToolbarExtExec the object which deals with custom
//     buttons (or tools menu items) that exec stuff.
//
// The latter two are derived from the former 

#ifndef _TBEXT_H
#define _TBEXT_H

#include "priv.h"

//
// Internal interface for accessing ther properties of a button/menu extension.
// This interface will likely go away afer IE5B2 when we move this functionality to
// a browser helper object.
//
typedef enum _tagGetPropertyIDs 
{
    TBEX_BUTTONTEXT     = 100,     // VT_BSTR
    TBEX_TOOLTIPTEXT    = 101,     // VT_BSTR
    TBEX_GRAYICON       = 102,     // HICON as a VT_BYREF
    TBEX_HOTICON        = 103,     // HICON as a VT_BYREF
    TBEX_GRAYICONSM     = 104,     // HICON as a VT_BYREF     
    TBEX_HOTICONSM      = 105,     // HICON as a VT_BYREF
    TBEX_DEFAULTVISIBLE = 106,     // VT_BOOL
    TMEX_MENUTEXT       = 200,     // VT_BSTR   
    TMEX_STATUSBARTEXT  = 201,     // VT_BSTR
    TMEX_CUSTOM_MENU    = 202,     // VT_BSTR
} GETPROPERTYIDS;

interface IBrowserExtension : IUnknown
{
    virtual STDMETHODIMP Init(REFGUID refguid) = 0;
    virtual STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * varProperty) = 0;
};

class CToolbarExt : public IBrowserExtension,
                    public IOleCommandTarget,
                    public IObjectWithSite
{
public:
    // Constructor/Destructor
    CToolbarExt();
    virtual ~CToolbarExt();

    // IUnknown Interface Members
    STDMETHODIMP            QueryInterface(const IID& iid, void** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);
    STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * pvarProperty);

    // IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut) = 0;

    // IObjectWithSite Interface Members        
    STDMETHODIMP SetSite(IUnknown* pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

protected:
    BOOL _RegGetBoolValue(LPCWSTR pszPropName, BOOL fDefault);
    BOOL _RegReadString(HKEY hkeyThisExtension, LPCWSTR szPropName, BSTR * pbstrProp, BOOL fExpand = FALSE);
    HICON _ExtractIcon(LPWSTR pszPath, int resid, int cx, int cy);
    HRESULT _GetIcon(LPCWSTR pszIcon, int nWidth, int nHeight, HICON& rhIcon, VARIANTARG * pvarProperty);

    long            _cRef;
    HICON           _hIcon;             // gray icon regular size
    HICON           _hIconSm;           // gray icon small
    HICON           _hHotIcon;          // Hot... are color versions of above
    HICON           _hHotIconSm;
    BSTR            _bstrButtonText;    // The buttons caption
    BSTR            _bstrToolTip;       // This is optional (not supported on our side yet)
    HKEY            _hkeyThisExtension; 
    HKEY            _hkeyCurrentLang;   // optional location for localized strings
    IShellBrowser*  _pisb;              // passed in by IObjectWithSite::SetSite()  Used to load band
};

class CToolbarExtBand : public CToolbarExt
{
public:
    // Constructor / Destructor
    CToolbarExtBand();
    virtual ~CToolbarExtBand();
    
    // Overridden IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);

    // Overridden IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);

protected:
    BOOL            _bBandState;        // This is a hack... ideally state will be determined from the browser
    BSTR            _bstrBandCLSID;     // CLSID of band to load.  Kept as BSTR because this is how it is passed
                                        // to load the band
};

class CToolbarExtExec : public CToolbarExt
{
public:
    // Constructor / Destructor
    CToolbarExtExec();
    virtual ~CToolbarExtExec();
    
    // Overridden IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);
    STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * pvarProperty);

    // Overridden IObjectWithSite Interface Members        
    STDMETHODIMP SetSite(IUnknown* pUnkSite);

    // Overridden IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);

protected:
    BOOL            _bButton;           // Does this object support being a button?
    BOOL            _bMenuItem;         // Does it support being a menu item?
    BOOL            _bExecCalled;       // if Exec was called
    BSTR            _bstrExec;          // Thing to ShellExecute
    BSTR            _bstrScript;        // Script to Execute
    BSTR            _bstrMenuText;
    BSTR            _bstrMenuCustomize; // the menu that is to be customized
    BSTR            _bstrMenuStatusBar;
    IUnknown*       _punkExt;           // (Optional) created when button is first pressed
};

#endif // _TBEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\tlog.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include <hlink.h>
#include "iface.h"
#include "resource.h"
#include <mluisupp.h>
#include "shdocfl.h"

class CTravelLog;

class CEnumEntry : public IEnumTravelLogEntry
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IEnumTravelLogEntry specific methods  
    STDMETHODIMP Next(ULONG  cElt, ITravelLogEntry **rgElt, ULONG *pcEltFetched);
    STDMETHODIMP Skip(ULONG cElt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumTravelLogEntry **ppEnum);

    CEnumEntry();
    void Init(CTravelLog *ptl, IUnknown *punk, DWORD dwOffset, DWORD dwFlags); 
    void  SetBase();

protected:
    ~CEnumEntry();
    
    LONG            _cRef;
    DWORD           _dwFlags;
    DWORD           _dwOffset; 
    LONG            _lStart;
    CTravelLog      *_ptl;
    IUnknown        *_punk;
};

class CTravelEntry : public ITravelEntry, 
                     public ITravelLogEntry,
                     public IPropertyBag
{
public:
    CTravelEntry(BOOL fIsLocalAnchor);

    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelEntry specific methods
    STDMETHODIMP Update(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP Invoke(IUnknown *punk);
    STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    
    // *** ITravelLogEntry specific methods
    STDMETHODIMP GetTitle(LPOLESTR *ppszTitle);
    STDMETHODIMP GetURL(LPOLESTR *ppszURL);  
    
    // *** IPropertyBag specific methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

    static HRESULT CreateTravelEntry(IBrowserService *pbs, BOOL fIsLocalAnchor, CTravelEntry **ppte);
    void SetPrev(CTravelEntry *ptePrev);
    void SetNext(CTravelEntry *pteNext);
    CTravelEntry *GetPrev() {return _ptePrev;}
    CTravelEntry *GetNext() {return _pteNext;}
    void RemoveSelf();
    BOOL CanInvoke(IUnknown *punk, BOOL fAllowLocalAnchor);
    HRESULT GetIndexBrowser(IUnknown *punkIn, IUnknown ** ppsbOut) const;
    DWORD Size();
    DWORD ListSize();
    HRESULT Clone(CTravelEntry **ppte);
    HRESULT UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext);
    HRESULT UpdateSelf(IUnknown *punk) 
        {return Update(punk, (_type == TET_LOCALANCHOR));}
    BOOL IsExternal(void)
        { return (_type==TET_EXTERNALNAV); }
    HRESULT GetDisplayName(LPTSTR psz, DWORD cch, DWORD dwFlags);
    BOOL IsEqual(LPCITEMIDLIST pidl)
        {return ILIsEqual(pidl, _pidl);}
    BOOL IsLocalAnchor(void)
        { return (_type==TET_LOCALANCHOR);}
        
protected:
    CTravelEntry(void);
    HRESULT _InvokeExternal(IUnknown *punk);
    HRESULT _UpdateTravelLog(IUnknown *punk, BOOL fIsLocalAnchor);
    HRESULT _UpdateFromTLClient(IUnknown * punk, IStream ** ppStream);
    LONG _cRef;

    ~CTravelEntry();
    void _Reset(void);
    enum {
        TET_EMPTY   = 0,
        TET_DEFAULT = 1,
        TET_LOCALANCHOR,
        TET_EXTERNALNAV
    };

    DWORD _type;            //  flags for our own sake...
    LPITEMIDLIST _pidl;     //  pidl of the entry
    HGLOBAL _hGlobalData;   //  the stream data saved by the entry
    DWORD _bid;             //  the BrowserIndex for frame specific navigation
    DWORD _dwCookie;        //  if _hGlobalData is NULL the cookie should be set
    WCHAR * _pwzTitle;
    WCHAR * _pwzUrlLocation;
    
    IHlink *_phl;
    IHlinkBrowseContext *_phlbc;
    IPropertyBag    *_ppb;

    CTravelEntry *_ptePrev;
    CTravelEntry *_pteNext;
};


CTravelEntry::CTravelEntry(BOOL fIsLocalAnchor) : _cRef(1)
{
    //these should always be allocated
    //  thus they will always start 0
    if (fIsLocalAnchor)
        _type = TET_LOCALANCHOR;
    else
        ASSERT(!_type);

    ASSERT(!_pwzTitle);
    ASSERT(!_pwzUrlLocation);
    ASSERT(!_pidl);
    ASSERT(!_hGlobalData);
    ASSERT(!_bid);
    ASSERT(!_dwCookie);
    ASSERT(!_ptePrev);
    ASSERT(!_pteNext);
    ASSERT(!_phl);
    ASSERT(!_ppb);
    ASSERT(!_phlbc);
    TraceMsg(TF_TRAVELLOG, "TE[%X] created _type = %x", this, _type);
}

CTravelEntry::CTravelEntry(void) : _cRef(1)
{
    ASSERT(!_type);
    ASSERT(!_pwzTitle);
    ASSERT(!_pwzUrlLocation);
    ASSERT(!_pidl);
    ASSERT(!_hGlobalData);
    ASSERT(!_bid);
    ASSERT(!_dwCookie);
    ASSERT(!_ptePrev);
    ASSERT(!_pteNext);
    ASSERT(!_phl);
    ASSERT(!_ppb);
    ASSERT(!_phlbc);

    TraceMsg(TF_TRAVELLOG, "TE[%X] created", this, _type);
}

HGLOBAL CloneHGlobal(HGLOBAL hGlobalIn)
{
    DWORD dwSize = (DWORD)GlobalSize(hGlobalIn);
    HGLOBAL hGlobalOut = GlobalAlloc(GlobalFlags(hGlobalIn), dwSize);
    HGLOBAL hGlobalResult = NULL;

    if (NULL != hGlobalOut)
    {
        LPVOID pIn= GlobalLock(hGlobalIn);

        if (NULL != pIn)
        {
            LPVOID pOut= GlobalLock(hGlobalOut);

            if (NULL != pOut)
            {
                memcpy(pOut, pIn, dwSize);
                GlobalUnlock(hGlobalOut);
                hGlobalResult = hGlobalOut;
            }

            GlobalUnlock(hGlobalIn);
        }

        if (!hGlobalResult)
        {
            GlobalFree(hGlobalOut);
            hGlobalOut = NULL;
        }
    }

    return hGlobalResult;
}


HRESULT 
CTravelEntry::Clone(CTravelEntry **ppte)
{
    //  dont ever clone an external entry
    if (_type == TET_EXTERNALNAV)
        return E_FAIL;

    HRESULT hr = S_OK;
    CTravelEntry *pte = new CTravelEntry();
    if (pte)
    {
        pte->_type = _type;
        pte->_bid = _bid;
        pte->_dwCookie = _dwCookie;

        if (_pwzTitle)
        {
            pte->_pwzTitle = StrDup(_pwzTitle);
            if (!pte->_pwzTitle)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (_pwzUrlLocation)
        {
            pte->_pwzUrlLocation = StrDup(_pwzUrlLocation);
            if (!pte->_pwzUrlLocation)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (_pidl)
        {
            pte->_pidl = ILClone(_pidl);
            if (!pte->_pidl)
                hr = E_OUTOFMEMORY;
        }
        else
            pte->_pidl = NULL;

        if (_hGlobalData)
        {
            pte->_hGlobalData = CloneHGlobal(_hGlobalData);
            if (NULL == pte->_hGlobalData)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            ASSERT(NULL == pte->_hGlobalData);
        }
    }
    else 
        hr = E_OUTOFMEMORY;

    if (FAILED(hr) && pte)
    {
        pte->Release();
        *ppte = NULL;
    }
    else
        *ppte = pte;

    TraceMsg(TF_TRAVELLOG, "TE[%X] Clone hr = %x", this, hr);

    return hr;
}

CTravelEntry::~CTravelEntry()
{
    ILFree(_pidl);

    if (_hGlobalData)
    {
        GlobalFree(_hGlobalData);
        _hGlobalData = NULL;
    }

    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    if (_pteNext)
    {
        _pteNext->Release();
    }

    // Don't need to release _ptePrev because TravelEntry only addref's pteNext

    ATOMICRELEASE(_ppb);
    ATOMICRELEASE(_phl);
    ATOMICRELEASE(_phlbc);
    
    TraceMsg(TF_TRAVELLOG, "TE[%X] destroyed ", this);
}

HRESULT CTravelEntry::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CTravelEntry, ITravelEntry), // IID_ITravelEntry
        QITABENT(CTravelEntry, ITravelLogEntry),
        QITABENT(CTravelEntry, IPropertyBag),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CTravelEntry::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTravelEntry::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

//+-------------------------------------------------------------------------
//
//  Method    : CTravelEntry::GetIndexBrowser
//
//  Synopsis  : This method finds and returns the IUnknown of the browser
//              with the index in _bid. This method first checks to see
//              if the passed in punk supports ITravelLogClient. If it 
//              doesn't, it checks for IBrowserService. 
//
//--------------------------------------------------------------------------

HRESULT
CTravelEntry::GetIndexBrowser(IUnknown * punk, IUnknown ** ppunkBrowser) const
{
    HRESULT hr = E_FAIL;
    
    ASSERT(ppunkBrowser);

    ITravelLogClient * ptlcTop;
    hr = punk->QueryInterface(IID_PPV_ARG(ITravelLogClient, &ptlcTop));
    if (SUCCEEDED(hr))
    {
        hr = ptlcTop->FindWindowByIndex(_bid, ppunkBrowser);
        ptlcTop->Release();
    }

    TraceMsg(TF_TRAVELLOG, "TE[%X]::GetIndexBrowser _bid = %X, hr = %X", this, _bid, hr);
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CTravelEntry::CanInvoke
//
//  Synopsis  : This method determines if the current travel entry can
//              be invoked. There are two criteria that determine if
//              this entry can be invoked. 
//              1) If the entry is a local anchor, fAllowLocalAnchor must
//                 be TRUE.
//              2) A browser with the index in _bid must exist. 
//
//--------------------------------------------------------------------------

BOOL CTravelEntry::CanInvoke(IUnknown *punk, BOOL fAllowLocalAnchor)
{
    IUnknown * punkBrowser = NULL;
    BOOL       fRet = IsLocalAnchor() ? fAllowLocalAnchor : TRUE;

    fRet = fRet && SUCCEEDED(GetIndexBrowser(punk, &punkBrowser));

    SAFERELEASE(punkBrowser);

    return fRet;
}

DWORD CTravelEntry::Size()
{
    DWORD cbSize = SIZEOF(*this);

    if (_pidl)
        cbSize += ILGetSize(_pidl);

    if (_hGlobalData)
    {
        cbSize += (DWORD)GlobalSize(_hGlobalData);
    }

    if (_pwzTitle)
    {
        cbSize += (DWORD)LocalSize(_pwzTitle);
    }

    if (_pwzUrlLocation)
    {
        cbSize += (DWORD)LocalSize(_pwzUrlLocation);
    }

    return cbSize;
}

DWORD CTravelEntry::ListSize()
{
    CTravelEntry *pte = GetNext();

    DWORD cb = Size();
    while (pte)
    {
        cb += pte->Size();
        pte = pte->GetNext();
    }
    return cb;
}


void CTravelEntry::_Reset()
{
    Pidl_Set(&_pidl, NULL);

    if (NULL != _hGlobalData)
    {
        GlobalFree(_hGlobalData);
        _hGlobalData = NULL;
    }

    ATOMICRELEASE(_phl);
    ATOMICRELEASE(_phlbc);

    _bid = 0;
    _type = TET_EMPTY;
    _dwCookie = 0;

    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    TraceMsg(TF_TRAVELLOG, "TE[%X]::_Reset", this);
}

HRESULT CTravelEntry::_UpdateTravelLog(IUnknown *punk, BOOL fIsLocalAnchor)
{
    IBrowserService *pbs;
    HRESULT hr = E_FAIL;
    //  we need to update here
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        ITravelLog *ptl;
        if (SUCCEEDED(pbs->GetTravelLog(&ptl)))
        {
            hr = ptl->UpdateEntry(punk, fIsLocalAnchor);
            ptl->Release();
        }
        pbs->Release();
    }

    return hr;
}

HRESULT CTravelEntry::_InvokeExternal(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    ASSERT(_phl);
    ASSERT(_phlbc);
    
    TraceMsg(TF_TRAVELLOG, "TE[%X]::InvokeExternal entered on _bid = %X, _phl = %X, _phlbc = %X", this, _bid, _phl, _phlbc);

    HWND hwnd = NULL;
    IOleWindow *pow;
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IOleWindow, &pow))))
    {
        pow->GetWindow(&hwnd);
        pow->Release();
    }

    // set the size and position of the browser frame window, so that the
    // external target can sync up its frame window to those coordinates
    HLBWINFO hlbwi = {0};

    hlbwi.cbSize = sizeof(hlbwi);
    hlbwi.grfHLBWIF = 0;

    if (hwnd) 
    {
        WINDOWPLACEMENT wp = {0};

        wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(hwnd, &wp);
        hlbwi.grfHLBWIF = HLBWIF_HASFRAMEWNDINFO;
        hlbwi.rcFramePos = wp.rcNormalPosition;
        if (wp.showCmd == SW_SHOWMAXIMIZED)
            hlbwi.grfHLBWIF |= HLBWIF_FRAMEWNDMAXIMIZED;
    }

    _phlbc->SetBrowseWindowInfo(&hlbwi);

    //
    //  right now we always now we are going back, but later on
    //  maybe we should ask the browser whether this is back or forward
    //
    hr = _phl->Navigate(HLNF_NAVIGATINGBACK, NULL, NULL, _phlbc);

    IWebBrowser2 *pwb;
    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pwb))))
    {
        ASSERT(pwb);
        pwb->put_Visible(FALSE);
        pwb->Release();
    }

    _UpdateTravelLog(punk, FALSE);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::InvokeExternal exited hr = %X", this, hr);

    return hr;
}

HRESULT CTravelEntry::Invoke(IUnknown *punk)
{
    IPersistHistory *pph = NULL;
    HRESULT hr = E_FAIL;
    IUnknown * punkBrowser = NULL;
    IHTMLWindow2 * pWindow = NULL;

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Invoke entered on _bid = %X", this, _bid);
    TraceMsgW(TF_TRAVELLOG, "TE[%X]::Invoke title '%s'", this, _pwzTitle);

    if (_type == TET_EXTERNALNAV)
    {
        hr = _InvokeExternal(punk);
        goto Quit;
    }

    // Get the window/browser with the index. If that
    // fails, punk may be a IHTMLWindow2. If so,
    // get its IPersistHistory so the travel entry
    // can be loaded directly. (This is needed by Trident
    // in order to navigate in frames when traveling
    // backwards or forwards.
    //
    hr = GetIndexBrowser(punk, &punkBrowser);
    if (SUCCEEDED(hr))
    {
        hr = punkBrowser->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));
    }
    else
    {
        hr = punk->QueryInterface(IID_PPV_ARG(IHTMLWindow2, &pWindow));
        if (SUCCEEDED(hr))
        {
            hr = pWindow->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));
        }
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pph);

        if (_type == TET_LOCALANCHOR)
        {
            ITravelLogClient * pTLClient;
            hr = pph->QueryInterface(IID_PPV_ARG(ITravelLogClient, &pTLClient)); 
            if (SUCCEEDED(hr))
            {
                hr = pTLClient->LoadHistoryPosition(_pwzUrlLocation, _dwCookie);
                pTLClient->Release();
            }
            else
            {
                hr = pph->SetPositionCookie(_dwCookie);
            }
        }
        else
        {
            //  we need to clone it
            ASSERT(_hGlobalData);
            
            HGLOBAL hGlobal = CloneHGlobal(_hGlobalData);
            if (NULL != hGlobal)
            {
                IStream *pstm;
                hr = CreateStreamOnHGlobal(hGlobal, TRUE, &pstm);
                if (SUCCEEDED(hr))
                {
                    hr = pph->LoadHistory(pstm, NULL);
                    pstm->Release();
                }
                else
                {
                    GlobalFree(hGlobal);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        pph->Release();
    }

Quit:

    SAFERELEASE(punkBrowser);
    SAFERELEASE(pWindow);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Invoke exited on _bid = %X, hr = %X", this, _bid, hr);
    return hr;
}

HRESULT CTravelEntry::UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext)
{
    TraceMsg(TF_TRAVELLOG, "TE[%X]::UpdateExternal entered on punk = %X, punkhlbc = %X", this, punk, punkHLBrowseContext);

    _Reset();
    ASSERT(punkHLBrowseContext);
    punkHLBrowseContext->QueryInterface(IID_PPV_ARG(IHlinkBrowseContext, &_phlbc));
    ASSERT(_phlbc);

    _type = TET_EXTERNALNAV;

    HRESULT hr = E_FAIL;

    //
    //  right now we only support externals being previous.  we never actually navigate
    //  to another app.  we handle everything in pane ourselves.
    //  so theoretically we never need to worry about HLID_NEXT
    _phlbc->GetHlink((ULONG) HLID_PREVIOUS, &_phl);
    
    IBrowserService *pbs;
    punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs));

    if (pbs && _phl) 
    {
        _bid = pbs->GetBrowserIndex();

        WCHAR *pwszTarget;
        hr = _phl->GetStringReference(HLINKGETREF_ABSOLUTE, &pwszTarget, NULL);
        if (SUCCEEDED(hr))
        {
            // create pidl
            hr = IECreateFromPath(pwszTarget, &_pidl);
            OleFree(pwszTarget);
        }
    }

    ATOMICRELEASE(pbs);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::UpdateExternal exited _bid = %X, hr = %X", this, _bid, hr);

    return hr;
}

HRESULT CTravelEntry::Update(IUnknown *punk, BOOL fIsLocalAnchor)
{
    ASSERT(punk);
        
    //  this means that we went back to an external app, 
    //  and now we are going forward again.  we dont persist 
    //  any state info about them that would be different.
    if (_type == TET_EXTERNALNAV)
    {
        TraceMsg(TF_TRAVELLOG, "TE[%X]::Update NOOP on external entry", this);
        return S_OK;
    }

    _Reset();
    
    // Try ITravelLogClient first. If that fails, revert to IBrowserService.
    //
    IStream *pstm = NULL;
    IPersistHistory *pph = NULL;
    HRESULT hr = _UpdateFromTLClient(punk, &pstm);
    if (S_OK != hr)
        goto Cleanup;

    
    hr = punk->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));

    ASSERT(SUCCEEDED(hr));

    if (S_OK != hr)
        goto Cleanup;

    if (fIsLocalAnchor)
    {
        //  persist a cookie
        //
        _type = TET_LOCALANCHOR;
        hr = pph->GetPositionCookie(&_dwCookie);
    }
    else
    {
        _type = TET_DEFAULT;

        //  persist a stream
        //
        ASSERT(!_hGlobalData);

        if (!pstm)
        {
            hr = CreateStreamOnHGlobal(NULL, FALSE, &pstm);
            if (hr != S_OK)
                goto Cleanup;
                
            pph->SaveHistory(pstm);
        }

        STATSTG stg;
        HRESULT hrStat = pstm->Stat(&stg, STATFLAG_NONAME);

        hr = GetHGlobalFromStream(pstm, &_hGlobalData);

        //  This little exercise here is to shrink the memory block we get from
        //  the OLE API which allocates blocks in chunks of 8KB.  Typical stream
        //  sizes are only a few hundred bytes.

        if (S_OK != hrStat)
            goto Cleanup;
            
        HGLOBAL hGlobalTemp = GlobalReAlloc(_hGlobalData, stg.cbSize.LowPart, GMEM_MOVEABLE);
        if (NULL != hGlobalTemp)
        {
            _hGlobalData = hGlobalTemp;
        }
    }

Cleanup:
    if (FAILED(hr))
        _Reset();

    SAFERELEASE(pstm);
    SAFERELEASE(pph);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Update exited on _bid = %X, hr = %X", this, _bid, hr);
    
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Method    : CTravelEntry::_UpdateFromTLClient
//
//  Synopsis  : Updates the travel entry using the ITravelLogClient interface
//
//------------------------------------------------------------------------------

HRESULT
CTravelEntry::_UpdateFromTLClient(IUnknown * punk, IStream ** ppStream)
{
    HRESULT    hr;
    WINDOWDATA windata = {0};
    ITravelLogClient * ptlc = NULL;
    
    hr = punk->QueryInterface(IID_PPV_ARG(ITravelLogClient, &ptlc));
    if (S_OK != hr)
        goto Cleanup;

    hr = ptlc->GetWindowData(&windata);
    if (S_OK != hr)
        goto Cleanup;
            
    _bid = windata.dwWindowID;
                
    ILFree(_pidl);

    if (windata.pidl)
    {
        _pidl = ILClone(windata.pidl);
    }
    else
    {
        hr = IEParseDisplayNameWithBCW(windata.uiCP, windata.lpszUrl, NULL, &_pidl);
        if (S_OK != hr)
            goto Cleanup;
    }

    ASSERT(_pidl);

    // If there is an url location, append it to the end of the url
    //
    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    if (windata.lpszUrlLocation && *windata.lpszUrlLocation)
    {
        _pwzUrlLocation = StrDup(windata.lpszUrlLocation);
    }

    //  Pick up the title as a display name for menus and such.
    //
    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (windata.lpszTitle)
        _pwzTitle = StrDup(windata.lpszTitle);

    *ppStream = windata.pStream;

    TraceMsgW(TF_TRAVELLOG, "TE[%X]::_UpdateFromTLClient - ptlc:[0x%X] _bid:[%ld] Url:[%ws] Title:[%ws] UrlLocation:[%ws] ppStream:[0x%X]",
              this, ptlc, _bid, windata.lpszUrl, _pwzTitle, _pwzUrlLocation, *ppStream);

Cleanup:
    ILFree(windata.pidl);

    CoTaskMemFree(windata.lpszUrl);
    CoTaskMemFree(windata.lpszUrlLocation);
    CoTaskMemFree(windata.lpszTitle);
    
    SAFERELEASE(ptlc);

    // Don't release windata.pStream. It will
    // be released when ppStream is released.
    
    return hr;
}

HRESULT CTravelEntry::GetPidl(LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    if (EVAL(ppidl))
    {
        hr = SHILClone(_pidl, ppidl);
    }
    return hr;
}

void CTravelEntry::SetNext(CTravelEntry *pteNext)
{
    if (_pteNext)
        _pteNext->Release();

    _pteNext = pteNext;

    if (_pteNext) 
    {
        _pteNext->_ptePrev = this;
    }
}

void CTravelEntry::SetPrev(CTravelEntry *ptePrev)
{
    _ptePrev = ptePrev;
    if (_ptePrev)
        _ptePrev->SetNext(this);
}

//
//  this is for removing from the middle of the list...
//
void CTravelEntry::RemoveSelf()
{
    if (_pteNext)
        _pteNext->_ptePrev = _ptePrev;

    // remove yourself from the list
    if (_ptePrev) 
    {
        // after this point, we may be destroyed so can't touch any more member vars
        _ptePrev->_pteNext = _pteNext;
    }

    _ptePrev = NULL;
    _pteNext = NULL;

    // we lose a reference now because we're gone from _ptePrev's _pteNext
    // (or if we were the top of the list, we're also nuked)
    Release();
}


HRESULT GetUnescapedUrlIfAppropriate(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cch)
{
    TCHAR szUrl[MAX_URL_STRING];

    // The SHGDN_NORMAL display name will be the pretty name (Web Page title) unless
    // it's an FTP URL or the web page didn't set a title.
    if (SUCCEEDED(IEGetDisplayName(pidl, szUrl, SHGDN_NORMAL)) && UrlIs(szUrl, URLIS_URL))
    {
        // NT #279192, If an URL is escaped, it normally contains three types of
        // escaped chars.
        // 1) Seperating type chars ('#' for frag, '?' for params, etc.)
        // 2) DBCS chars,
        // 3) Data (a bitmap in the url by escaping the binary bytes)
        // Since #2 is very common, we want to try to unescape it so it has meaning
        // to the user.  UnEscaping isn't safe if the user can copy or modify the data
        // because they could loose data when it's reparsed.  One thing we need to
        // do for #2 to work is for it to be in ANSI when unescaped.  This is needed
        // or the DBCS lead and trail bytes will be in unicode as [0x<LeadByte> 0x00]
        // [0x<TrailByte> 0x00].  Being in ANSI could cause a problem if the the string normally
        // crosses code pages, but that is uncommon or non-existent in the IsURLChild()
        // case.
        CHAR szUrlAnsi[MAX_URL_STRING];

        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));
        UrlUnescapeA(szUrlAnsi, NULL, NULL, URL_UNESCAPE_INPLACE|URL_UNESCAPE_HIGH_ANSI_ONLY);
        SHAnsiToTChar(szUrlAnsi, pszUrl, cch);
    }
    else
    {
        StrCpyN(pszUrl, szUrl, cch);    // Truncate if needed
    }

    return S_OK;
}


#define TEGDN_FORSYSTEM     0x00000001

HRESULT CTravelEntry::GetDisplayName(LPTSTR psz, DWORD cch, DWORD dwFlags)
{
    if (!psz || !cch)
        return E_INVALIDARG;

    psz[0] = 0;
    if ((NULL != _pwzTitle) && (*_pwzTitle != 0))
    {
        StrCpyNW(psz, _pwzTitle, cch);
    }
    else if (_pidl)
    {
        GetUnescapedUrlIfAppropriate(_pidl, psz, cch);
    }

    if (dwFlags & TEGDN_FORSYSTEM)
    {
        if (!SHIsDisplayable(psz, g_fRunOnFE, g_bRunOnNT5))
        {
            // Display name isn't system-displayable.  Just use the path/url instead.
            SHTitleFromPidl(_pidl, psz, cch, FALSE);
        }
    }

    SHCleanupUrlForDisplay(psz);
    return psz[0] ? S_OK : E_FAIL;
}

HRESULT CTravelEntry::GetTitle(LPOLESTR *ppszTitle)
{
    HRESULT     hres = S_OK;
    TCHAR       szTitle[MAX_BROWSER_WINDOW_TITLE];

    ASSERT(IS_VALID_WRITE_PTR(ppszTitle, LPOLESTR));

    hres = GetDisplayName(szTitle, ARRAYSIZE(szTitle), TEGDN_FORSYSTEM);
    if (SUCCEEDED(hres))
    {
        ASSERT(*szTitle);

        hres = SHStrDup(szTitle, ppszTitle);
    }

    return hres;
}


HRESULT CTravelEntry::GetURL(LPOLESTR *ppszUrl)
{
    HRESULT         hres = E_FAIL;
    LPITEMIDLIST    pidl = NULL;
    WCHAR           wszURL[MAX_URL_STRING];

    if (_pidl)
        hres = ::IEGetDisplayName(_pidl, wszURL, SHGDN_FORPARSING);

    if (SUCCEEDED(hres))
        hres = SHStrDup(wszURL, ppszUrl);

    return hres;
}

HRESULT CTravelEntry::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    if (!_ppb)
    {
        return E_INVALIDARG;
    }
    return _ppb->Read(pszPropName, pVar, pErrorLog);
}

HRESULT CTravelEntry::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hres = S_OK;

    if (!_ppb)
    {
        hres = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &_ppb));
    }
    
    if (SUCCEEDED(hres))
    {
        ASSERT(_ppb);
        hres = _ppb->Write(pszPropName, pVar);
    }
    return hres;
}

    
class CTravelLog : public ITravelLog, 
                   public ITravelLogEx
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelLog specific methods
    STDMETHODIMP AddEntry(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP UpdateEntry(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext);
    STDMETHODIMP Travel(IUnknown *punk, int iOffset);
    STDMETHODIMP GetTravelEntry(IUnknown *punk, int iOffset, ITravelEntry **ppte);
    STDMETHODIMP FindTravelEntry(IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte);
    STDMETHODIMP GetToolTipText(IUnknown *punk, int iOffset, int idsTemplate, LPWSTR pwzText, DWORD cchText);
    STDMETHODIMP InsertMenuEntries(IUnknown *punk, HMENU hmenu, int nPos, int idFirst, int idLast, DWORD dwFlags);
    STDMETHODIMP Clone(ITravelLog **pptl);
    STDMETHODIMP_(DWORD) CountEntries(IUnknown *punk);
    STDMETHODIMP Revert(void);

    // *** ITravelLogEx specific methods
    STDMETHODIMP FindTravelEntryWithUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl, ITravelEntry ** ppte);
    STDMETHODIMP TravelToUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl);
    STDMETHOD(DeleteIndexEntry)(IUnknown *punk,  int index);
    STDMETHOD(DeleteUrlEntry)(IUnknown *punk, UINT uiCP, LPOLESTR pszUrl);
    STDMETHOD(CountEntryNodes)(IUnknown *punk, DWORD dwFlags, DWORD *pdwCount);
    STDMETHOD(CreateEnumEntry)(IUnknown *punk, IEnumTravelLogEntry **ppEnum, DWORD dwFlags);
    STDMETHOD(DeleteEntry)(IUnknown *punk, ITravelLogEntry *pte);
    STDMETHOD(InsertEntry)(IUnknown *punkBrowser, ITravelLogEntry *pteRelativeTo, BOOL fPrepend, 
                        IUnknown* punkTLClient, ITravelLogEntry **ppEntry);
    STDMETHOD(TravelToEntry)(IUnknown *punkBrowser, ITravelLogEntry *pteDestination);


    CTravelLog();

protected:
    ~CTravelLog();
    HRESULT _FindEntryByOffset(IUnknown *punk, int iOffset, CTravelEntry **ppte);
    HRESULT _FindEntryByPidl(IUnknown * punk, LPCITEMIDLIST pidl, CTravelEntry ** ppte);
    HRESULT _FindEntryByPunk(IUnknown * punk, ITravelLogEntry *pteSearch, CTravelEntry ** ppte);
        
    void _DeleteFrameSetEntry(IUnknown *punk, CTravelEntry *pte);
    void _Prune(void);
    
    LONG _cRef;
    DWORD _cbMaxSize;
    DWORD _cbTotalSize;

    CTravelEntry *_pteCurrent;  //pteCurrent
    CTravelEntry *_pteUpdate;
    CTravelEntry *_pteRoot;
};

CTravelLog::CTravelLog() : _cRef(1) 
{
    ASSERT(!_pteCurrent);
    ASSERT(!_pteUpdate);
    ASSERT(!_pteRoot);

    DWORD dwType, dwSize = SIZEOF(_cbMaxSize), dwDefault = 1024 * 1024;
    
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TravelLog"), TEXT("MaxSize"), &dwType, (LPVOID)&_cbMaxSize, &dwSize, FALSE, (void *)&dwDefault, SIZEOF(dwDefault));
    TraceMsg(TF_TRAVELLOG, "TL[%X] created", this);
}

CTravelLog::~CTravelLog()
{
    //DestroyList by releasing the root
    SAFERELEASE(_pteRoot);
    TraceMsg(TF_TRAVELLOG, "TL[%X] destroyed ", this);
}

HRESULT CTravelLog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CTravelLog, ITravelLog),   // IID_ITravelLog
        QITABENT(CTravelLog, ITravelLogEx), // IID_ITravelLogEx
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CTravelLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTravelLog::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

HRESULT CTravelLog::AddEntry(IUnknown *punk, BOOL fIsLocalAnchor)
{
    ASSERT(punk);

    if (SHRestricted2W(REST_NoNavButtons, NULL, 0))
    {
        return S_FALSE;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::AddEntry punk = %X, IsLocal = %s", this, punk, fIsLocalAnchor ? "TRUE" : "FALSE");

    CTravelEntry *pte = new CTravelEntry(fIsLocalAnchor);
    if (pte)
    {
        //replace the current with the new

        if (_pteCurrent)
        {
            CTravelEntry *pteNext = _pteCurrent->GetNext();
            if (pteNext)
            {
                _cbTotalSize -= pteNext->ListSize();
            }

            //  the list keeps its own ref count, and only needs
            //  to be modified when passed outside of the list

            //  setnext will release the current next if necessary
            //  this will also set pte->prev = pteCurrent
            _pteCurrent->SetNext(pte);
        }
        else
            _pteRoot = pte;

        _cbTotalSize += pte->Size();

        _pteCurrent = pte;

        ASSERT(_cbTotalSize == _pteRoot->ListSize());
    }
    TraceMsg(TF_TRAVELLOG, "TL[%X]::AddEntry punk = %X, IsLocal = %d, pte = %X", this, punk, fIsLocalAnchor, pte);

    return pte ? S_OK : E_OUTOFMEMORY;
}

void CTravelLog::_Prune(void)
{
    // FEATURE: need an increment or something

    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    while (_cbTotalSize > _cbMaxSize && _pteRoot != _pteCurrent)
    {
        CTravelEntry *pte = _pteRoot;
        _pteRoot = _pteRoot->GetNext();

        _cbTotalSize -= pte->Size();
        pte->RemoveSelf();

        ASSERT(_cbTotalSize == _pteRoot->ListSize());
    }
}


HRESULT CTravelLog::UpdateEntry(IUnknown *punk, BOOL fIsLocalAnchor)
{
    CTravelEntry *pte = _pteUpdate ? _pteUpdate : _pteCurrent;

    //  this can happen under weird stress conditions, evidently
    if (!pte)
        return E_FAIL;

    _cbTotalSize -= pte->Size();
    HRESULT hr = pte->Update(punk, fIsLocalAnchor);
    _cbTotalSize += pte->Size();

    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    // Debug prints need to be before _Prune() since pte can get freed by _Prune() resulting
    // in a crash if pte->Size() is called
    TraceMsg(TF_TRAVELLOG, "TL[%X]::UpdateEntry pte->Size() = %d", this, pte->Size());
    TraceMsg(TF_TRAVELLOG, "TL[%X]::UpdateEntry punk = %X, IsLocal = %d, hr = %X", this, punk, fIsLocalAnchor, hr);
    
    _Prune();

    _pteUpdate = NULL;

    return hr;
}

HRESULT CTravelLog::UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext)
{
    CTravelEntry *pte = _pteUpdate ? _pteUpdate : _pteCurrent;

    ASSERT(punk);
    ASSERT(pte);
    ASSERT(punkHLBrowseContext);

    if (pte)
        return pte->UpdateExternal(punk, punkHLBrowseContext);

    return E_FAIL;
}

HRESULT CTravelLog::Travel(IUnknown *punk, int iOffset)
{
    ASSERT(punk);
    HRESULT hr = E_FAIL;

    CTravelEntry *pte;

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Travel entered with punk = %X, iOffset = %d", this, punk, iOffset);

    if (SUCCEEDED(_FindEntryByOffset(punk, iOffset, &pte)))
    {
#ifdef DEBUG
            TCHAR szPath[MAX_PATH];
            LPITEMIDLIST pidl;
            pte->GetPidl(&pidl);
            
            SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            ILFree(pidl);
            TraceMsgW(TF_TRAVELLOG, "TL[%X]::URL %s", this, szPath);
#endif

        // we will update where we are before we move away...
        //  but external navigates dont go through the normal activation
        //  so we dont want to setup the external to be updated
        //  _pteUpdate is also what allows us to Revert().
        if (!_pteCurrent->IsExternal() && !_pteUpdate)
            _pteUpdate = _pteCurrent;

        _pteCurrent = pte;
        hr = _pteCurrent->Invoke(punk);

        //
        //  if the entry bails with an error, then we need to reset ourself
        //  to what we were.  right now, the only place this should happen
        //  is if an Abort was returned from SetPositionCookie
        //  because somebody aborted during before navigate.
        //  but i think that any error means that we can legitimately Revert().
        //
        if (FAILED(hr))
        {
            Revert();
        }
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Travel exited with hr = %X", this, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::TravelToUrl
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Travels to the specified URL in the travel log.
//
//----------------------------------------------------------------------------

HRESULT
CTravelLog::TravelToUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl)
{
    ASSERT(punk);
    ASSERT(lpszUrl);

    HRESULT        hr;
    LPITEMIDLIST   pidl;
    CTravelEntry * pte    = NULL;
    TCHAR          szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD          cchOut = ARRAYSIZE(szUrl);
    
    hr = UrlCanonicalize(lpszUrl, szUrl, &cchOut, URL_ESCAPE_SPACES_ONLY);
    if (SUCCEEDED(hr))
    {
        hr = IEParseDisplayName(uiCP, szUrl, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = _FindEntryByPidl(punk, pidl, &pte);
            ILFree(pidl);
    
            if (SUCCEEDED(hr))
            {
                // We will update where we are before we move away...
                // but external navigates don't go through the normal activation
                // so we dont want to setup the external to be updated
                // _pteUpdate is also what allows us to Revert().
                //
                if (!_pteCurrent->IsExternal() && !_pteUpdate)
                {
                    _pteUpdate = _pteCurrent;
                }

                _pteCurrent = pte;
                hr = _pteCurrent->Invoke(punk);
            
                //  If the entry bails with an error, then we need to reset ourself
                //  to what we were. Right now, the only place this should happen
                //  is if an Abort was returned from SetPositionCookie
                //  because somebody aborted during before navigate.
                //  But i think that any error means that we can legitimately Revert().
                //
                if (FAILED(hr))
                {
                    Revert();
                }
            }
        }
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::TravelToUrl exited with hr = %X", this, hr);

    return hr;
}


HRESULT CTravelLog::_FindEntryByOffset(IUnknown *punk, int iOffset, CTravelEntry **ppte)
{
    CTravelEntry *pte = _pteCurrent;
    BOOL fAllowLocalAnchor = TRUE;

    if (iOffset < 0)
    {
        while (iOffset && pte)
        {
            pte = pte->GetPrev();
            if (pte && pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                iOffset++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }

        }
    }
    else if (iOffset > 0)
    {
        while (iOffset && pte)
        {
            pte = pte->GetNext();
            if (pte && pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                iOffset--;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }
        }
    }

    if (pte)
    {

        *ppte = pte;
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CTravelLog::GetTravelEntry(IUnknown *punk, int iOffset, ITravelEntry **ppte)
{
    HRESULT hr;
    BOOL fCheckExternal = FALSE;
    if (iOffset == TLOG_BACKEXTERNAL) 
    {
        iOffset = TLOG_BACK;
        fCheckExternal = TRUE;
    }

    if (iOffset == 0)
    {
        //  APPCOMPAT - going back and fore between external apps is dangerous - zekel 24-JUN-97
        //  we always fail if the current is external
        //  this is because word will attempt to navigate us to 
        //  the same url instead of FORE when the user selects
        //  it from the drop down.
        if (_pteCurrent && _pteCurrent->IsExternal())
        {
            hr = E_FAIL;
            ASSERT(!_pteCurrent->GetPrev());
            TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry current is External", this);
            goto Quit;
        }
    }

    CTravelEntry *pte;
    hr = _FindEntryByOffset(punk, iOffset, &pte);

    //
    // If TLOG_BACKEXTERNAL is specified, we return S_OK only if the previous
    // entry is external.
    //
    if (fCheckExternal && SUCCEEDED(hr)) 
    {
        if (!pte->IsExternal()) 
        {
            hr = E_FAIL;
        }
        TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry(BACKEX)", this);
    }

    if (ppte && SUCCEEDED(hr)) 
    {
        hr = pte->QueryInterface(IID_PPV_ARG(ITravelEntry, ppte));
    }

Quit:

    TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry iOffset = %d, hr = %X", this, iOffset, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindTravelEntry
//
//  Synopsis  : Finds the travel entry with the specified PIDL and returns
//              the ITravelEntry interface of the entry.
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::FindTravelEntry(IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte)
{
    CTravelEntry * pte = _pteRoot;
    
    _FindEntryByPidl(punk, pidl, &pte);
    
    if (pte)
    {
        return pte->QueryInterface(IID_PPV_ARG(ITravelEntry, ppte));
    }

    *ppte =  NULL;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::_FindEntryByPidl
//
//  Synopsis  : Finds and returns the travel entry with the specified PIDL.
//              This private method returns a CTravelEntry instead of
//              an ITravelEntry.
//
//----------------------------------------------------------------------------

HRESULT
CTravelLog::_FindEntryByPidl(IUnknown * punk, LPCITEMIDLIST pidl, CTravelEntry ** ppte)
{
    CTravelEntry * pte = _pteRoot;
    BOOL fAllowLocalAnchor = TRUE;

    ASSERT(punk);
    ASSERT(pidl);
    ASSERT(ppte);
    
    while (pte)
    {
        if (pte->CanInvoke(punk, fAllowLocalAnchor) && pte->IsEqual(pidl))
        {
            *ppte = pte;
            return S_OK;
        }

        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();

        pte = pte->GetNext();
    }

    *ppte = NULL;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindEntryByPunk
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Find the entry object given its punk.
//
//----------------------------------------------------------------------------

HRESULT 
CTravelLog::_FindEntryByPunk(IUnknown * punk, ITravelLogEntry *pteSearch, CTravelEntry ** ppte)
{
    CTravelEntry     *pte = _pteRoot;
    ITravelEntry     *pteCur;
    BOOL             fAllowLocalAnchor = TRUE;

    ASSERT(ppte);

    // check for the current entry.
    // often the current entry will fail CanInvoke because it's incomplete at this time.
    if (IsSameObject(pteSearch, SAFECAST(_pteCurrent, ITravelEntry*)))
    {
        *ppte = _pteCurrent;
        return S_OK;
    }

    while (pte)
    {
        pteCur = SAFECAST(pte, ITravelEntry*);
        
        if ((pte->CanInvoke(punk, fAllowLocalAnchor)) && IsSameObject(pteCur, pteSearch))
        {
            *ppte = pte;
            return S_OK;
        }
        
        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
        pte = pte->GetNext();
    }
    
    *ppte = NULL;
    return E_FAIL;
}
//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindTravelEntryWithUrl
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Finds and returns the travel entry with the specified URL.
//
//----------------------------------------------------------------------------

HRESULT 
CTravelLog::FindTravelEntryWithUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl, ITravelEntry ** ppte)
{
    LPITEMIDLIST pidl;
    HRESULT      hr = E_FAIL;
    
    ASSERT(punk);
    ASSERT(lpszUrl);
    ASSERT(ppte);

    if (SUCCEEDED(IEParseDisplayNameWithBCW(uiCP, lpszUrl, NULL, &pidl)))
    {
        hr = FindTravelEntry(punk, pidl, ppte);
        ILFree(pidl);
    }
        
    return hr;
}


HRESULT CTravelLog::Clone(ITravelLog **pptl)
{
    CTravelLog *ptl = new CTravelLog();
    HRESULT hr = S_OK;

    if (ptl && _pteCurrent)
    {
        // first set the current pointer
        hr = _pteCurrent->Clone(&ptl->_pteCurrent);
        if (SUCCEEDED(hr))
        {
            ptl->_cbTotalSize = _cbTotalSize;
            
            CTravelEntry *pteSrc;
            CTravelEntry *pteClone, *pteDst = ptl->_pteCurrent;
            
            //  then we need to loop forward and set each
            for (pteSrc = _pteCurrent->GetNext(), pteDst = ptl->_pteCurrent;
                pteSrc; pteSrc = pteSrc->GetNext())
            {
                ASSERT(pteDst);
                if (FAILED(pteSrc->Clone(&pteClone)))
                    break;

                ASSERT(pteClone);
                pteDst->SetNext(pteClone);
                pteDst = pteClone;
            }
                
            //then loop back and set them all
            for (pteSrc = _pteCurrent->GetPrev(), pteDst = ptl->_pteCurrent;
                pteSrc; pteSrc = pteSrc->GetPrev())
            {
                ASSERT(pteDst);
                if (FAILED(pteSrc->Clone(&pteClone)))
                    break;

                ASSERT(pteClone);
                pteDst->SetPrev(pteClone);
                pteDst = pteClone;
            }   

            //  the root is the furthest back we could go
            ptl->_pteRoot = pteDst;

        }
    }
    else 
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl));
    }
    else 
    {
        *pptl = NULL;
    }
    
    if (ptl) 
        ptl->Release();

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Clone hr = %x, ptlClone = %X", this, hr, ptl);

    return hr;
}

// HACKHACK: 3rd parameter used to be idsTemplate, which we would use to grab the
// string template.  However, since there's no way the caller can specify the hinst
// of the module in which to look for this resource, this broke in the shdocvw /
// browseui split (callers would pass offsets into browseui.dll; we'd look for them in
// shdocvw.dll).  My solution is is to ignore this parameter entirely and assume that:
//
//  if iOffset is negative, the caller wants the "back to" text
//  else, the caller wants the "forward to" text
//
// tjgreen 14-july-98.
//
HRESULT CTravelLog::GetToolTipText(IUnknown *punk, int iOffset, int, LPWSTR pwzText, DWORD cchText)
{
    TraceMsg(TF_TRAVELLOG, "TL[%X]::ToolTip entering iOffset = %d, ptlClone = %X", this, iOffset);
    ASSERT(pwzText);
    ASSERT(cchText);

    *pwzText = 0;

    CTravelEntry *pte;
    HRESULT hr = _FindEntryByOffset(punk, iOffset, &pte);
    if (SUCCEEDED(hr))
    {
        ASSERT(pte);

        TCHAR szName[MAX_URL_STRING];
        pte->GetDisplayName(szName, ARRAYSIZE(szName), 0);

        int idsTemplate = (iOffset < 0) ? IDS_NAVIGATEBACKTO : IDS_NAVIGATEFORWARDTO;

        TCHAR szTemplate[80];
        if (MLLoadString(idsTemplate, szTemplate, ARRAYSIZE(szTemplate))) 
        {
            DWORD cchTemplateLen = lstrlen(szTemplate);
            DWORD cchLen = cchTemplateLen + lstrlen(szName);
            if (cchLen > cchText) 
            {
                // so that we don't overflow the pwzText buffer
                // review: do we even need this now that we are using StringCchPrintf below?
                szName[cchText - cchTemplateLen - 1] = 0;
            }

            StringCchPrintf(pwzText, cchText, szTemplate, szName);
        }
        else
            hr = E_UNEXPECTED;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::ToolTip exiting hr = %X, pwzText = %ls", this, hr, pwzText);
    return hr;
}

HRESULT CTravelLog::InsertMenuEntries(IUnknown *punk, HMENU hmenu, int iIns, int idFirst, int idLast, DWORD dwFlags)
{
    ASSERT(idLast >= idFirst);
    ASSERT(hmenu);
    ASSERT(punk);

    int cItemsBack = idLast - idFirst + 1;
    int cItemsFore = 0;
    
    CTravelEntry *pte;
    LONG cAdded = 0;

    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertMenuEntries entered on punk = %X, hmenu = %X, iIns = %d, idRange = %d-%d, flags = %X", this, punk, hmenu, iIns, idFirst, idLast, dwFlags);


    ASSERT(cItemsFore >= 0);
    ASSERT(cItemsBack >= 0);

    if (IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
        cItemsBack--;

    if (IsFlagSet(dwFlags, TLMENUF_BACKANDFORTH))
    {
        cItemsFore = cItemsBack / 2;
        cItemsBack = cItemsBack - cItemsFore;
    }
    else if (IsFlagSet(dwFlags, TLMENUF_FORE))
    {
        cItemsFore = cItemsBack;
        cItemsBack = 0;
    }

    TCHAR szName[40];
    UINT uFlags = MF_STRING | MF_ENABLED | MF_BYPOSITION;
    
    while (cItemsFore)
    {
        if (SUCCEEDED(_FindEntryByOffset(punk, cItemsFore, &pte)))
        {
            pte->GetDisplayName(szName, ARRAYSIZE(szName), TEGDN_FORSYSTEM);
            ASSERT(*szName);
            FixAmpersands(szName, ARRAYSIZE(szName));
            InsertMenu(hmenu, iIns, uFlags, idLast, szName);
            cAdded++;
            TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Fore id = %d, szName = %s", this, idLast, szName);
        }
        
        cItemsFore--;
        idLast--;
    }

    if (IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
    {
        // clear the name
        *szName = 0;

        //have to get the title from the actual pbs
        LPITEMIDLIST pidl = NULL;
        IBrowserService *pbs;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->GetPidl(&pidl);

            WCHAR wzTitle[MAX_PATH];
            if (SUCCEEDED(pbs->GetTitle(NULL, wzTitle, ARRAYSIZE(wzTitle))))
            {
                StrCpyN(szName, wzTitle, ARRAYSIZE(szName));
            }
            else if (pidl)
            {
                GetUnescapedUrlIfAppropriate(pidl, szName, ARRAYSIZE(szName));
            }

            pbs->Release();
        }

        if (!SHIsDisplayable(szName, g_fRunOnFE, g_bRunOnNT5) && pidl)
        {
            // Display name isn't system-displayable.  Just use the path/url instead.
            SHTitleFromPidl(pidl, szName, ARRAYSIZE(szName), FALSE);
        }

        if (!(*szName))
            TraceMsg(TF_ERROR, "CTravelLog::InsertMenuEntries -- failed to find title for current entry");

        ILFree(pidl);

        FixAmpersands(szName, ARRAYSIZE(szName));
        InsertMenu(hmenu, iIns, uFlags | (IsFlagSet(dwFlags, TLMENUF_CHECKCURRENT) ? MF_CHECKED : 0), idLast, szName);
        cAdded++;
        TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Current id = %d, szName = %s", this, idLast, szName);

        idLast--;
    }

    
    if (IsFlagSet(dwFlags, TLMENUF_BACKANDFORTH))
    {
        //  we need to reverse the order of insertion for back
        //  when both directions are displayed
        int i;
        for (i = 1; i <= cItemsBack; i++, idLast--)
        {
            if (SUCCEEDED(_FindEntryByOffset(punk, -i, &pte)))
            {
                pte->GetDisplayName(szName, ARRAYSIZE(szName), TEGDN_FORSYSTEM);
                ASSERT(*szName);
                FixAmpersands(szName, ARRAYSIZE(szName));
                InsertMenu(hmenu, iIns, uFlags, idLast, szName);
                cAdded++;
                TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Back id = %d, szName = %s", this, idLast, szName);

            }
        }
    }
    else while (cItemsBack)
    {
        if (SUCCEEDED(_FindEntryByOffset(punk, -cItemsBack, &pte)))
        {
            pte->GetDisplayName(szName, ARRAYSIZE(szName), TEGDN_FORSYSTEM);
            ASSERT(*szName);
            FixAmpersands(szName, ARRAYSIZE(szName));
            InsertMenu(hmenu, iIns, uFlags, idLast, szName);
            cAdded++;
            TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Back id = %d, szName = %s", this, idLast, szName);
        }

        cItemsBack--;
        idLast--;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertMenuEntries exiting added = %d", this, cAdded);
    return cAdded ? S_OK : S_FALSE;
}

DWORD CTravelLog::CountEntries(IUnknown *punk)
{
    CTravelEntry *pte = _pteRoot;
    DWORD dw = 0;
    BOOL fAllowLocalAnchor = TRUE;

    while (pte)
    {
        if (pte->CanInvoke(punk, fAllowLocalAnchor))
            dw++;

        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();

        pte = pte->GetNext();
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::CountEntries count = %d", this, dw);
    return dw;
}

HRESULT CTravelLog::Revert(void)
{
    // this function should only be called when
    //  we have travelled, and we stop the travel before finishing
    if (_pteUpdate)
    {
        // trade them back
        _pteCurrent = _pteUpdate;
        _pteUpdate = NULL;
        return S_OK;
    }
    return E_FAIL;
}


//
// delete nodes belonging to the frameset pte 
//
void CTravelLog::_DeleteFrameSetEntry(IUnknown *punk, CTravelEntry *pte)
{
    ASSERT(pte);

    CTravelEntry    *ptetmp = pte;
    BOOL            fAllowLocalAnchor = TRUE;

    while (ptetmp && ptetmp != _pteCurrent)
        ptetmp = ptetmp->GetNext();

    if (ptetmp)
    {
        // entry on left of _pteCurrent , delete on left
        do 
        {
            if (pte == _pteRoot)
                _pteRoot =  pte->GetNext();

            ptetmp = pte;
            pte = pte->GetPrev();
            fAllowLocalAnchor = fAllowLocalAnchor && ptetmp->IsLocalAnchor();

            _cbTotalSize -= ptetmp->Size();
            ptetmp->RemoveSelf();

        } while (pte && !(pte->CanInvoke(punk, fAllowLocalAnchor)));    
    }
    else if (pte)
    {
        do 
        {
            ptetmp = pte;
            pte = pte->GetNext();
            fAllowLocalAnchor = fAllowLocalAnchor && ptetmp->IsLocalAnchor();

            _cbTotalSize -= ptetmp->Size();
            ptetmp->RemoveSelf();

        } while (pte && !(pte->CanInvoke(punk, fAllowLocalAnchor)));
    }
}
    
    
//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteIndexEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete the entry given by index. 
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::DeleteIndexEntry(IUnknown *punk, int index)
{
    HRESULT         hres = E_FAIL;

    CTravelEntry    *pte;
    IBrowserService *pbs;
    BOOL            fAllowLocalAnchor = TRUE;
    
    ASSERT(punk);

    if (index == 0)              // don't delete current entry
        return hres;            

    hres = _FindEntryByOffset(punk, index, &pte);
    if (SUCCEEDED(hres)) 
    {
        _DeleteFrameSetEntry(punk, pte);

        ASSERT(_cbTotalSize  == _pteRoot->ListSize());
    
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
    }
    
    return hres;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteUrlEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete all the entries given by URL. Fails for current entry. 
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::DeleteUrlEntry(IUnknown *punk, UINT uiCP, LPOLESTR lpszUrl)
{
    HRESULT         hres = E_FAIL;
    CTravelEntry    *pte;
    IBrowserService *pbs;
    LPITEMIDLIST    pidl;
    BOOL            fAllowLocalAnchor = TRUE;
    int             count = 0;
    
    ASSERT(punk);
    
    if (SUCCEEDED(IEParseDisplayNameWithBCW(uiCP, lpszUrl, NULL, &pidl)))
    {
        // delete only if different from current
        if (!_pteCurrent->IsEqual(pidl))
        {
            hres = S_OK;
            while(SUCCEEDED(_FindEntryByPidl(punk, pidl, &pte)))
            {
                _DeleteFrameSetEntry(punk, pte);
                count++;
                    
                ASSERT(_cbTotalSize == _pteRoot->ListSize());
            }
        } 

        ILFree(pidl);

        if (count && SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
    }   
    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete the entries given by punk. Fails for current entry. 
//
//----------------------------------------------------------------------------
HRESULT CTravelLog::DeleteEntry(IUnknown *punk, ITravelLogEntry *ptleDelete)
{
    HRESULT         hres;

    CTravelEntry    *pte;
    BOOL            fAllowLocalAnchor = TRUE;
    IBrowserService *pbs;

    ASSERT(punk);

    hres = _FindEntryByPunk(punk, ptleDelete, &pte);
    if (SUCCEEDED(hres) && pte != _pteCurrent) // don't remove current
    {
        _DeleteFrameSetEntry(punk, pte);

        ASSERT(_cbTotalSize  == _pteRoot->ListSize());
    
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
    } 
    else
    {
        hres = E_FAIL;
    }
    return hres;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::CountEntryNodes
//
//  Synopsis  : Counts Back/Forward entries including the current one
//              as given by dwFlags
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::CountEntryNodes(IUnknown *punk, DWORD dwFlags, DWORD *pdwCount)
{
    CTravelEntry    *pte;
    BOOL fAllowLocalAnchor = TRUE;
        
    ASSERT(punk);
    DWORD dwCount = 0;
    
    if (!_pteCurrent)
    {
        *pdwCount = 0;
        return S_OK;
    }

    if (IsFlagSet(dwFlags, TLMENUF_BACK))
    {
        pte = _pteRoot;
        while (pte != _pteCurrent)
        {
            if (pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                dwCount++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }   
            pte = pte->GetNext();
        }
    } 

    if (IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
    {
        if (_pteCurrent->CanInvoke(punk, fAllowLocalAnchor))
        {
            dwCount++;
            fAllowLocalAnchor = fAllowLocalAnchor && _pteCurrent->IsLocalAnchor();
        }   
    }
    
    if (IsFlagSet(dwFlags, TLMENUF_FORE))
    {
        pte = _pteCurrent->GetNext();
        while (pte)
        {
            if (pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                dwCount++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }   
            pte = pte->GetNext();
        }
    } 

    *pdwCount = dwCount;
    
    TraceMsg(TF_TRAVELLOG, "TL[%X]::CountEntryNodes count = %d", this, *pdwCount);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::CreateEnumEntry
//
//  Synopsis  : Returns an enumerator object for the back/fore travel entries 
//              as selected by the dwFlags option
//
//----------------------------------------------------------------------------
HRESULT 
CTravelLog::CreateEnumEntry(IUnknown *punk, IEnumTravelLogEntry **ppEnum, DWORD dwFlags)
{
    ASSERT(punk);
    ASSERT(ppEnum);
    
    *ppEnum = 0;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumEntry *penum = new CEnumEntry();
    if (penum)
    {
        penum->Init(this, punk, 0, dwFlags);
        *ppEnum = SAFECAST(penum, IEnumTravelLogEntry *);
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLogEx::InsertEntry
//
//  Synopsis  : Inserts an entry into the specified position in the 
//              travellog and calls Update with the given IUnknown.
//
//----------------------------------------------------------------------------
HRESULT
CTravelLog::InsertEntry(IUnknown *punkBrowser, ITravelLogEntry *pteRelativeTo, BOOL fPrepend, 
                        IUnknown* punkTLClient, ITravelLogEntry **ppEntry)
{
    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertEntry", this);
  
    ASSERT(punkBrowser);

    CTravelEntry * pteRelative;
    _FindEntryByPunk(punkBrowser, pteRelativeTo, &pteRelative);

    if (!pteRelative)
        pteRelative = _pteCurrent;

    CTravelEntry *pte = new CTravelEntry(FALSE);
    if (!pte)
        return E_OUTOFMEMORY;

    if (fPrepend)
    {
        // keep relative alive as it's reconnected
        pteRelative->AddRef();
        pte->SetPrev(pteRelative->GetPrev());
        pteRelative->SetPrev(pte);
        if (pteRelative == _pteRoot)
        {
            _pteRoot = pte;
        }
    }
    else
    {
        CTravelEntry * pteNext = pteRelative->GetNext();
        if (pteNext)
            pteNext->AddRef();
        pte->SetNext(pteNext);
        pteRelative->SetNext(pte);
    }

    // update will fill in all the data from the passed in TL Client
    HRESULT hres = pte->Update(punkTLClient, FALSE);

    _cbTotalSize += pte->Size();
    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    IBrowserService *pbs;
    if (SUCCEEDED(punkBrowser->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        pbs->UpdateBackForwardState();
        pbs->Release();
        hres = S_OK;
    }

    // return the ITLEntry for the new entry
    if (SUCCEEDED(hres) && ppEntry)
    {
        hres = pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, ppEntry));
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::TravelToEntry
//
//  Synopsis  : Travels directly to the specified entry.
//              Invoke cannot be called directly due to update strangeness.
//
//----------------------------------------------------------------------------
HRESULT CTravelLog::TravelToEntry(
    IUnknown *punkBrowser,
    ITravelLogEntry *pteDestination)
{
    HRESULT hr = E_FAIL;
    CTravelEntry    *pte = NULL;

    ASSERT(punkBrowser);
    ASSERT(pteDestination);

    _FindEntryByPunk(punkBrowser, pteDestination , &pte);
    if (pte)
    {
        if (!_pteCurrent->IsExternal() && !_pteUpdate)
            _pteUpdate = _pteCurrent;

        _pteCurrent = pte;

        hr = pte->Invoke(punkBrowser);

        if (FAILED(hr))
        {
            Revert();
        }
    }


    return hr;
}


HRESULT CreateTravelLog(ITravelLog **pptl)
{
    HRESULT hres;
    CTravelLog *ptl =  new CTravelLog();
    if (ptl)
    {
        hres = ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl));
        ptl->Release();
    }
    else
    {
        *pptl = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

CEnumEntry::CEnumEntry() :_cRef(1)
{   
    ASSERT(!_ptl);
    ASSERT(!_punk);

    TraceMsg(TF_TRAVELLOG, "EET[%X] created ", this);
}

CEnumEntry::~CEnumEntry()
{
    SAFERELEASE(_ptl);
    SAFERELEASE(_punk);
    
    TraceMsg(TF_TRAVELLOG, "EET[%X] destroyed ", this);
}

HRESULT CEnumEntry::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CEnumEntry, IEnumTravelLogEntry), 
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CEnumEntry::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEnumEntry::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}


void CEnumEntry::Init(CTravelLog *ptl, IUnknown *punk, DWORD dwOffset, DWORD dwFlags)
{
    ASSERT(ptl);
    ASSERT(punk);
    
    _ptl        = ptl;
    _dwFlags    = dwFlags;
    _punk       = punk;
    _dwOffset   = dwOffset;
    _lStart     = 0;
    
    _ptl->AddRef();
    _punk->AddRef();
    
    SetBase();
}

void  CEnumEntry::SetBase()
{   
    ITravelEntry *ptetmp;

// the start is always computed relative to the current entry
    if (IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE|TLEF_RELATIVE_BACK))
    {
        _lStart = -1;
        while (SUCCEEDED(_ptl->GetTravelEntry(_punk, _lStart, &ptetmp)))
        {
            _lStart--;
            ptetmp->Release();
        }
        _lStart++;
    }
    else if (!IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT))
        _lStart = IsFlagSet(_dwFlags, TLEF_RELATIVE_BACK) ? -1: 1;
}

HRESULT CEnumEntry::Reset()
{
    _dwOffset = 0;

// base changes when add/delete entries
    SetBase();
    return S_OK;
}

HRESULT CEnumEntry::Skip(ULONG cElt)
{
    HRESULT        hres;
    ITravelEntry   *pte;
    ULONG          uCount;
    LONG           lIndex;
    
    BOOL fToRight = IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE);
    BOOL fIncludeCurrent = IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT);

    for (uCount = 0;  uCount < cElt; uCount++)
    {
        lIndex = fToRight ? _lStart + _dwOffset : _lStart - _dwOffset;
        if (lIndex || fIncludeCurrent)
        {
           if (SUCCEEDED(hres = _ptl->GetTravelEntry(_punk, lIndex, &pte)))
            {   
                _dwOffset++;
                pte->Release();
            }
            else
                break;
        }
        else
        {
            _dwOffset++;
            uCount--;
        }
    }
        
    if (uCount != cElt)
        hres = S_FALSE;

    return hres;
}

HRESULT CEnumEntry::Next(ULONG  cElt, ITravelLogEntry **rgpte2, ULONG *pcEltFetched)
{
    HRESULT         hres = S_OK;
    ULONG           uCount = 0;
    ITravelEntry    *pte;
    LONG            lIndex;
    BOOL           fToRight;
    BOOL           fIncludeCurrent;
    
    fToRight = IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE);
    fIncludeCurrent = IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT);
    
    if (pcEltFetched)
        *pcEltFetched = 0;
        
    for (uCount = 0; uCount < cElt; uCount++)
    {
        lIndex = fToRight ? _lStart + _dwOffset : _lStart - _dwOffset;
        if (lIndex || fIncludeCurrent)
        {
            hres = _ptl->GetTravelEntry(_punk, lIndex, &pte);
            if (SUCCEEDED(hres))
            {
                _dwOffset++;
                pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, &rgpte2[uCount]));
                pte->Release();
            }
            else
                break;  
        } 
        else
        {        
            _dwOffset++;
            uCount--;
        }
    }
    
    if (pcEltFetched )
        *pcEltFetched = uCount;

    if (uCount != cElt)
    {
        hres = S_FALSE;
        for(;uCount < cElt; uCount++)
            rgpte2[uCount] = 0;
    }
    return hres;
}

STDMETHODIMP CEnumEntry::Clone(IEnumTravelLogEntry **ppEnum)
{
    HRESULT     hres = E_OUTOFMEMORY;
    CEnumEntry  *penum;

    ASSERT(ppEnum);
    
    *ppEnum = 0;
    penum = new CEnumEntry();

    if (penum)
    {
        penum->Init(_ptl, _punk, _dwOffset, _dwFlags);
        *ppEnum = SAFECAST(penum, IEnumTravelLogEntry*);
        hres = S_OK;
    }

    return hres;
}


// Helper object for creating new travel entries
class CPublicTravelLogCreateHelper : public ITravelLogClient, IPersistHistory
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // ITravelLogClient methods

    STDMETHODIMP FindWindowByIndex(DWORD dwID, IUnknown **ppunk);
    STDMETHODIMP GetWindowData(WINDOWDATA *pwindata);
    STDMETHODIMP LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
    { return SetPositionCookie(dwCookie); }
    
    // IPersist methods. (dummy)
    STDMETHODIMP GetClassID(CLSID *pClassID)
    { ASSERT(FALSE); return E_NOTIMPL; } 
 
    // IPersistHistory methods. (dummy)
    // These should never be called, but Update QI's the client to see if it supports IPH.
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc)
    { return E_NOTIMPL; }

    STDMETHODIMP SaveHistory(IStream *pStream)
    { ASSERT(FALSE); return S_OK; }

    STDMETHODIMP SetPositionCookie(DWORD dwPositioncookie)
    { return E_NOTIMPL; }
    
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie)
    { return E_NOTIMPL; }


    CPublicTravelLogCreateHelper(IBrowserService *pbs, LPCOLESTR pszUrl, LPCOLESTR pszTitle);
    

protected:
    ~CPublicTravelLogCreateHelper();

    LONG                 _cRef;
    IBrowserService        *_pbs;
    LPOLESTR             _pszUrl;
    LPOLESTR             _pszTitle;
};

CPublicTravelLogCreateHelper::CPublicTravelLogCreateHelper(IBrowserService *pbs, LPCOLESTR pszUrl, LPCOLESTR pszTitle) : _pbs(pbs), _cRef(1) 
{
    ASSERT(_pbs);
    ASSERT(!_pszUrl);
    ASSERT(!_pszTitle);
    ASSERT(pszUrl);
    ASSERT(pszTitle);

    if (_pbs)
        _pbs->AddRef();
        
    if (pszUrl)
    {
        SHStrDup(pszUrl, &_pszUrl);
    }
    
    if (pszTitle)
    {
        SHStrDup(pszTitle, &_pszTitle);
    }
    
    TraceMsg(TF_TRAVELLOG, "TPLCH[%X] created", this);
}

CPublicTravelLogCreateHelper::~CPublicTravelLogCreateHelper()
{
    SAFERELEASE(_pbs);
    CoTaskMemFree(_pszUrl);
    CoTaskMemFree(_pszTitle);

    TraceMsg(TF_TRAVELLOG, "TPLCH[%X] destroyed ", this);
}

HRESULT CPublicTravelLogCreateHelper ::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CPublicTravelLogCreateHelper , ITravelLogClient),
        QITABENT(CPublicTravelLogCreateHelper , IPersistHistory),
        QITABENT(CPublicTravelLogCreateHelper , IPersist),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CPublicTravelLogCreateHelper ::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublicTravelLogCreateHelper ::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}


// ITravelLogClient::FindWindowByIndex
HRESULT
CPublicTravelLogCreateHelper::FindWindowByIndex(DWORD dwID, IUnknown **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}


// ITravelLogClient::GetWindowData
// turns around and talks to the browser
HRESULT 
CPublicTravelLogCreateHelper::GetWindowData(WINDOWDATA *pwindata)
{
    ITravelLogClient2 *pcli;
    HRESULT hres = _pbs->QueryInterface(IID_PPV_ARG(ITravelLogClient2, &pcli));
    if (SUCCEEDED(hres))
        hres = pcli->GetDummyWindowData(_pszUrl, _pszTitle, pwindata);

    if (pcli)
        pcli->Release();

    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}


// Implements the publicly exposed interface ITravelLogStg (can be QS'd for from top browser)
class CPublicTravelLog : public ITravelLogStg
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelLogStg specific methods
    STDMETHODIMP CreateEntry(LPCOLESTR pszUrl, LPCOLESTR pszTitle, ITravelLogEntry *ptleRelativeTo, 
                            BOOL fPrepend, ITravelLogEntry **pptle);
    STDMETHODIMP TravelTo(ITravelLogEntry *ptle);
    STDMETHODIMP EnumEntries(TLENUMF flags, IEnumTravelLogEntry **ppenum);
    STDMETHODIMP FindEntries(TLENUMF flags, LPCOLESTR pszUrl, IEnumTravelLogEntry **ppenum);
    STDMETHODIMP GetCount(TLENUMF flags, DWORD *pcEntries);
    STDMETHODIMP RemoveEntry(ITravelLogEntry *ptle);
    STDMETHODIMP GetRelativeEntry(int iOffset, ITravelLogEntry **ptle);

    CPublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx);
    

protected:
    ~CPublicTravelLog();

    LONG                 _cRef;
    IBrowserService        *_pbs;
    ITravelLogEx        *_ptlx;
};


CPublicTravelLog::CPublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx) : _pbs(pbs), _ptlx(ptlx), _cRef(1) 
{
    ASSERT(pbs);
    ASSERT(ptlx);

    // We don't addref _pbs because we are always contained within the browser serivce, 
    // so avoid the circular ref.
    if (_ptlx)
        _ptlx->AddRef();
    
    TraceMsg(TF_TRAVELLOG, "TLP[%X] created", this);
}

CPublicTravelLog::~CPublicTravelLog()
{
    // We don't need to release _pbs because we are always contained within the browser serivce, 
    // so we didn't addref to avoid the circular ref so don't release 
    SAFERELEASE(_ptlx);
    
    TraceMsg(TF_TRAVELLOG, "TLP[%X] destroyed ", this);
}

HRESULT CPublicTravelLog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CPublicTravelLog, ITravelLogStg),       // IID_ITravelLogStg
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CPublicTravelLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublicTravelLog::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::CreateEntry
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Insert a new dummy entry.
//              Creates an entry in the travel log and passes CPTHCEHelper
//              as travel log client; that gets called back and fills in the
//              data from the browser.
//
//----------------------------------------------------------------------------

HRESULT CPublicTravelLog::CreateEntry(LPCOLESTR pszUrl, LPCOLESTR pszTitle, ITravelLogEntry *ptleRelativeTo, 
                                      BOOL fPrepend, ITravelLogEntry **pptle)
{
    HRESULT     hres = E_FAIL;
    CPublicTravelLogCreateHelper * ptlch;
    ITravelLogClient *ptlc;

    ptlch = new CPublicTravelLogCreateHelper(_pbs, pszUrl, pszTitle);
    if (!ptlch)
        return E_OUTOFMEMORY;
        
    ptlc = SAFECAST(ptlch, ITravelLogClient *);
    if (ptlc)
    {
        // Create TLogEntry and have it get its data from the helper.
        hres = _ptlx->InsertEntry(_pbs, ptleRelativeTo, fPrepend, ptlc, pptle);
    }

    ptlc->Release();

    return hres;
}


HRESULT CPublicTravelLog::TravelTo(ITravelLogEntry *ptle)
{
    if (ptle)
        return _ptlx->TravelToEntry(_pbs, ptle);
    else
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::EnumEntries
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Get an enumerators for specific entries given by flags.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::EnumEntries(TLENUMF flags, IEnumTravelLogEntry **ppenum)
{    
    return _ptlx->CreateEnumEntry(_pbs, ppenum, flags);
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::FindEntries
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Allow to retrieve  duplicate entries.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::FindEntries(TLENUMF flags, LPCOLESTR pszUrl, IEnumTravelLogEntry **ppenum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::GetCount
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Public methods to get ITravelLogEx count.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::GetCount(TLENUMF flags, DWORD *pcEntries)
{
    return _ptlx->CountEntryNodes(_pbs, flags, pcEntries);
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::RemoveEntry
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Delete the entry ant its frameset.
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::RemoveEntry(ITravelLogEntry *ptle)
{
    HRESULT     hr = E_FAIL;

    if (ptle)
          hr = _ptlx->DeleteEntry(_pbs, ptle);
     
    return hr;
}


HRESULT CPublicTravelLog::GetRelativeEntry(int iOffset, ITravelLogEntry **pptle)
{
    HRESULT            hr = E_FAIL;
    ITravelEntry*    pte;
    ITravelLog*        ptl;

    if (SUCCEEDED(_ptlx->QueryInterface(IID_PPV_ARG(ITravelLog, &ptl))))
    {
        hr =  ptl->GetTravelEntry(_pbs, iOffset, &pte);
        if (SUCCEEDED(hr) && pte)
        {
            hr = pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, pptle));
            pte->Release();
        }
        ptl->Release();
    }

    return hr;
}

// public method used by the browser to create us
HRESULT CreatePublicTravelLog(IBrowserService *pbs, ITravelLogEx* ptlx, ITravelLogStg **pptlstg)
{
    HRESULT         hres;
    
    CPublicTravelLog *ptlp =  new CPublicTravelLog(pbs, ptlx);    
    if (ptlp)
    {
        hres = ptlp->QueryInterface(IID_PPV_ARG(ITravelLogStg, pptlstg));
        ptlp->Release();        
    }
    else
    {
        *pptlstg = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\tbext.cpp ===
////////////////////////////////////////////////////////////////////////////
// File:   TBExt.cpp   (toolbar extension classes)
// Author: Karim Farouki
//
// We define here three classes:
// (1) CToolbarExt a base class that takes care of the
//     button work for our custom extensions
// (2) CToolbarExtBand the object which deals with custom
//     buttons that plug into bands
// (3) CToolbarExtExec the object which deals with custom
//     buttons (or tools menu items) that exec stuff.
//
// The latter two are derived from the former 
#include "priv.h"
#include <mshtmcid.h>
#include "tbext.h"


//////////////////////////////
// Class CToolbarExt
//
// This is the base class from which CToolbarExtBand and CToolbarExtExec
// both inherit.  It takes care of all the ToolbarButton specific stuff
// like lazy loading the appropriate icons, and keeping track of the button
// text.

// Constructor / Destructor
//
CToolbarExt::CToolbarExt() : _cRef(1)
{ 
    ASSERT(_hIcon == NULL);
    ASSERT(_hIconSm == NULL);
    ASSERT(_hHotIcon == NULL);
    ASSERT(_hHotIconSm == NULL);
    ASSERT(_bstrButtonText == NULL);
    ASSERT(_bstrToolTip == NULL);
    ASSERT(_hkeyThisExtension == NULL);
    ASSERT(_hkeyCurrentLang == NULL);
    ASSERT(_pisb == NULL);
    
    DllAddRef();
}

// Destructor
//
CToolbarExt::~CToolbarExt() 
{ 
    if (_pisb)
        _pisb->Release();
    
    if (_bstrButtonText)
        SysFreeString(_bstrButtonText);

    if (_bstrToolTip)
        SysFreeString(_bstrToolTip);

    if (_hIcon)
        DestroyIcon(_hIcon);

    if (_hIconSm)
        DestroyIcon(_hIconSm);

    if (_hHotIcon)
        DestroyIcon(_hHotIcon);

    if (_hHotIconSm)
        DestroyIcon(_hHotIconSm);

    if (_hkeyThisExtension)
        RegCloseKey(_hkeyThisExtension);

    if (_hkeyCurrentLang)
        RegCloseKey(_hkeyCurrentLang);

    DllRelease();
}


// IUnknown implementation
//
STDMETHODIMP CToolbarExt::QueryInterface(const IID& iid, void** ppv)
{    
	if (iid == IID_IUnknown)
    	*ppv = static_cast<IBrowserExtension*>(this); 
	else if (iid == IID_IBrowserExtension)
		*ppv = static_cast<IBrowserExtension*>(this);
	else if (iid == IID_IOleCommandTarget)
        *ppv = static_cast<IOleCommandTarget*>(this);
    else if (iid == IID_IObjectWithSite)
        *ppv = static_cast<IObjectWithSite*>(this);
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CToolbarExt::AddRef()
{
	return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CToolbarExt::Release() 
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
	if ( 0 == cRef )
	{
		delete this;
	}
	return cRef;
}

// IBrowserExtension::Init Implementation.  We'll read the ButtonText here but wait on the icons until
// a specific variant of the icon is requested.
STDMETHODIMP CToolbarExt::Init(REFGUID rguid)
{
    HRESULT hr = S_OK;
    LPOLESTR pszGUID;

    if (SUCCEEDED(StringFromCLSID(rguid, &pszGUID)))
    {
        //Open the extension reg key associated with this guid
        WCHAR szKey[MAX_PATH];

        if (SUCCEEDED(StringCchCopy(szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Internet Explorer\\Extensions\\"))))
        {
            if (SUCCEEDED(StringCchCat(szKey, ARRAYSIZE(szKey), pszGUID)))
            {
                // We will keep _hkeyThisExtension around... it will be closed in the destructor!
                if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_READ, &_hkeyThisExtension) == ERROR_SUCCESS ||
                    RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &_hkeyThisExtension) == ERROR_SUCCESS)
                {
                    // See if there is a subkey for the current language
                    LANGID langid = MLGetUILanguage();
                    WCHAR szBuff[MAX_PATH];
                    if (SUCCEEDED(StringCchPrintf(szBuff, ARRAYSIZE(szBuff), L"Lang%04x", langid)))
                    {
                        RegOpenKeyEx(_hkeyThisExtension, szBuff, 0, KEY_READ, &_hkeyCurrentLang);
                    }
                    // Now get the button text
                    _RegReadString(_hkeyThisExtension, TEXT("ButtonText"), &_bstrButtonText);

                }
            }
        }

        CoTaskMemFree(pszGUID);
    }

    if (!_bstrButtonText)
        hr = E_FAIL;

    return hr;
}

//
// Gets the icon closest to the desired size from an .ico file or from the 
// resource in a .dll of .exe file
//
HICON CToolbarExt::_ExtractIcon
(
    LPWSTR pszPath, // file to get icon from
    int resid,      // resource id (0 if unused)
    int cx,         // desired icon width
    int cy          // desired icon height
)
{
    HICON hIcon = NULL;

    WCHAR szPath[MAX_PATH];
    SHExpandEnvironmentStrings(pszPath, szPath, ARRAYSIZE(szPath));

    // If no resource id, assume it's an ico file
    if (resid == 0)
    {
        hIcon = (HICON)LoadImage(0, szPath, IMAGE_ICON, cx, cy, LR_LOADFROMFILE);
    }

    // Otherwise, see if it's a resouce
    if (hIcon == NULL)
    {
        HINSTANCE hInst = LoadLibraryEx(szPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (hInst)
        {
            hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(resid), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR);
            FreeLibrary(hInst);
        }
    }

    return hIcon;
}

//
// Returns the desired icon in pvarProperty
//
HRESULT CToolbarExt::_GetIcon
(
    LPCWSTR pszIcon,            // Name of icon value in registry
    int nWidth,                 // icon width
    int nHeight,                // icon height
    HICON& rhIcon,              // location to cached icon
    VARIANTARG * pvarProperty   // used for return icon
)
{
    HRESULT hr = S_OK;
    if (pvarProperty)
    {
        if (rhIcon == NULL)
        {
            BSTR bstrIconName;
            if (_RegReadString(_hkeyThisExtension, pszIcon, &bstrIconName, TRUE))
            {
                // Parse entry such as "file.ext,1" to get the icon index
                int nIconIndex = PathParseIconLocation(bstrIconName);

                // If the entry was ",#" then it's an index into our built-in button bitmap
                if (*bstrIconName == L'\0')
                {
                    pvarProperty->vt = VT_I4;
                    pvarProperty->lVal = nIconIndex;
                    SysFreeString(bstrIconName);
                    return hr;
                }
                else
                {
                    rhIcon = _ExtractIcon(bstrIconName, nIconIndex, nWidth, nHeight);
                }
                SysFreeString(bstrIconName);
            }
        }

        if (rhIcon)
        {
            pvarProperty->vt = VT_BYREF;
            pvarProperty->byref = rhIcon;
        }
        else
        {
            VariantInit(pvarProperty);
        }
    }
    return hr;
}

//
// Implementation of IBrowserExtension::GetProperty().  There are two important points here:
// (1) We are lazy loading the appropriate icons.  This way if the user never goes into small icon
//     mode we never create the images...
// (2) If we are called with a NULL pvarProperty then we must still return S_OK if the iPropID
//     is for a property that we support and E_NOTIMPL if we do not.  This is why the if (pvarProperty)
//     check is done for each case rather tan outside the case block.  This behavior is important
//     for CBrowserExtension::Update() who passes in a NULL pvarProperty but still is trying to determine
//     what kind of extension this is!
//
STDMETHODIMP CToolbarExt::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT hr = S_OK;

    if (pvarProperty)
        VariantInit(pvarProperty); // in case of failure
    
    switch (iPropID)
    {
        case TBEX_BUTTONTEXT:
            if (pvarProperty)
            {
                pvarProperty->bstrVal = SysAllocString(_bstrButtonText);
                if (pvarProperty->bstrVal)
                {
                    pvarProperty->vt = VT_BSTR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            break;

        case TBEX_GRAYICON:

            // For Whistler, we now use a 24 x 24 icons
            if (SHUseClassicToolbarGlyphs())
            {
                hr = _GetIcon(TEXT("Icon"), 20, 20, _hIcon, pvarProperty);
            }
            else
            {
                hr = _GetIcon(TEXT("Icon"), 24, 24, _hIcon, pvarProperty);
            }
            break;

        case TBEX_GRAYICONSM:
            hr = _GetIcon(TEXT("Icon"), 16, 16, _hIconSm, pvarProperty);
            break;

        case TBEX_HOTICON:
            // For Whistler, we now use a 24 x 24 icons
            if (SHUseClassicToolbarGlyphs())
            {
                hr = _GetIcon(TEXT("HotIcon"), 20, 20, _hHotIcon, pvarProperty);
            }
            else
            {
                hr = _GetIcon(TEXT("HotIcon"), 24, 24, _hHotIcon, pvarProperty);
            }
            break;

        case TBEX_HOTICONSM:
            hr = _GetIcon(TEXT("HotIcon"), 16, 16, _hHotIconSm, pvarProperty);
            break;

        case TBEX_DEFAULTVISIBLE:
            if (pvarProperty)
            {
                BOOL fVisible = _RegGetBoolValue(L"Default Visible", FALSE);
                pvarProperty->vt = VT_BOOL;
                pvarProperty->boolVal = fVisible ? VARIANT_TRUE : VARIANT_FALSE;
            }
            break;

        default:
            hr = E_NOTIMPL;
    }

    return hr;
}

//
// IOleCommandTarget Implementation
//
STDMETHODIMP CToolbarExt::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        // Default to all commands enabled
        for (ULONG i = 0; i < cCmds; i++)
        {
//            if (prgCmds[i].cmdID == 1)
                // Execing this object is supported and can be done at this point
                rgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;
//            else
//                prgCmds[i].cmdf = 0;
        }
        hr = S_OK;
    }

    // Return an empty pCmdText
    if (pCmdText != NULL)
    {
        pCmdText->cwActual = 0;
    }
    return hr;
}

//
// IObjectWithSite Implementation
//
STDMETHODIMP CToolbarExt::SetSite(IUnknown* pUnkSite)
{
    if (_pisb != NULL)
    {
        _pisb->Release();
        _pisb = NULL;
    }
    
    if (pUnkSite)
        pUnkSite->QueryInterface(IID_IShellBrowser, (void **)&_pisb);
        
    return S_OK;
}
   
STDMETHODIMP CToolbarExt::GetSite(REFIID riid, void ** ppvSite)
{
    return E_NOTIMPL;
}


BOOL CToolbarExt::_RegGetBoolValue
(
    LPCWSTR         pszPropName,
    BOOL            fDefault
)
{
    WCHAR szData[MAX_PATH];
    DWORD cbData = SIZEOF(szData);

    if ((_hkeyCurrentLang && RegQueryValueEx(_hkeyCurrentLang, pszPropName, NULL, NULL, (unsigned char *)szData, &cbData) == ERROR_SUCCESS) ||
        (_hkeyThisExtension && RegQueryValueEx(_hkeyThisExtension, pszPropName, NULL, NULL, (unsigned char *)szData, &cbData) == ERROR_SUCCESS))
    {
        if ((0 == StrCmpI(L"TRUE", szData)) || 
            (0 == StrCmpI(L"YES", szData)))
        {
            fDefault = TRUE;        // We read TRUE from the registry.
        }
        else if ((0 == StrCmpI(L"FALSE", szData)) || 
            (0 == StrCmpI(L"NO", szData)))
        {
            fDefault = FALSE;        // We read TRUE from the registry.
        }
    }

    return fDefault;
}



// Private Helper Functions
//
// shlwapi has some similar function; however, they all insist on reopening and closing the key in question
// with each read.  It is explicitly suggested that we use our own helper if we are caching the key...
BOOL CToolbarExt::_RegReadString
(
    HKEY hkeyThisExtension,
    LPCWSTR pszPropName,
    BSTR * pbstrProp,
    BOOL fExpand            // = FALSE, Expand Environment strings
    )
{
    WCHAR   szData[MAX_PATH];
    *pbstrProp = NULL;
    BOOL fSuccess = FALSE;
    
    // First try the optional location for localized content
    if (_hkeyCurrentLang)
    {
        if (SUCCEEDED(SHLoadRegUIString(_hkeyCurrentLang, pszPropName, szData, ARRAYSIZE(szData))))
        {
            fSuccess = TRUE;
        }
    }

    // Next try default location
    if (!fSuccess && _hkeyThisExtension)
    {
        if (SUCCEEDED(SHLoadRegUIString(hkeyThisExtension, pszPropName, szData, ARRAYSIZE(szData))))
        {
            fSuccess = TRUE;
        }
    }

    if (fSuccess)
    {
        LPWSTR psz = szData;
        WCHAR szExpand[MAX_PATH];
        if (fExpand)
        {
            SHExpandEnvironmentStrings(szData, szExpand, ARRAYSIZE(szExpand));
            psz = szExpand;
        }
        *pbstrProp = SysAllocString(psz);
    }
    return (NULL != *pbstrProp);
}


///////////////////////////////////////////////////////////
// Class CToolbarExtBand
//
// This class adds to the base functionality of CToolbarExt
// by storing the CLSID for a registered band, and displaying that
// band upon execution of IOleCommandTarget::Exec
//
//
STDAPI CToolbarExtBand_CreateInstance(
            IUnknown        * punkOuter,
            IUnknown        ** ppunk,
            LPCOBJECTINFO   poi
            )
{
    HRESULT hr = S_OK;

    *ppunk = NULL;

    CToolbarExtBand * lpTEB = new CToolbarExtBand();

    if (lpTEB == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpTEB, IBrowserExtension *);

    return hr;
}

// Constructor / Destructor
//
CToolbarExtBand::CToolbarExtBand()
{
    ASSERT(_cRef == 1);
    ASSERT(_bBandState == FALSE);
    ASSERT(_bstrBandCLSID == NULL);
}

// Destructor
//
CToolbarExtBand::~CToolbarExtBand() 
{ 
    if (_bstrBandCLSID)
        SysFreeString(_bstrBandCLSID);
}

// IBrowserExtension::Init()   We pass the majroity of the work on to the base class, then we load
// the BandCLSID and cache it.
STDMETHODIMP CToolbarExtBand::Init(REFGUID rguid)
{
    HRESULT hr = CToolbarExt::Init(rguid);
    
    _RegReadString(_hkeyThisExtension, TEXT("BandCLSID"), &_bstrBandCLSID);
    
    if (!(_bstrButtonText && _bstrBandCLSID))
        hr = E_FAIL;

    return hr;
}
    
STDMETHODIMP CToolbarExtBand::QueryStatus
(
    const GUID * pguidCmdGroup,
    ULONG  cCmds,
    OLECMD prgCmds[],
    OLECMDTEXT * pCmdText
    )
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        VARIANT varClsid;
      
        // Default to all commands enabled
        for (ULONG i = 0; i < cCmds; i++)
        {
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = _bstrBandCLSID;
            prgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;

            hr = IUnknown_Exec(_pisb, &CGID_ShellDocView, SHDVID_ISBROWSERBARVISIBLE, 0, &varClsid, NULL);
            if (S_OK == hr)
            {
                prgCmds[i].cmdf |= OLECMDF_LATCHED;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Take the pIShellBrowser (obtained from IObjectWithSite::SetSite()) and disply the band
STDMETHODIMP CToolbarExtBand::Exec( 
                const GUID              * pguidCmdGroup,
                DWORD                   nCmdID,
                DWORD                   nCmdexecopt,
                VARIANT                 * pvaIn,
                VARIANT                 * pvaOut
                )
{
    HRESULT hr = E_FAIL;
    
    if (_pisb)
    {
        VARIANT varClsid;
        varClsid.vt = VT_BSTR;
        varClsid.bstrVal = _bstrBandCLSID;
      
        _bBandState = !_bBandState;
        IUnknown_Exec(_pisb, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, _bBandState, &varClsid, NULL);

        hr = S_OK;
    }
    
    return hr;
}


///////////////////////////////////////////////////////////////////////
// Class CToolbarExtExec
//
// Expands on the base class by adding support for tools menu plug-ins.
// An instance of this class can be a button OR a menu OR BOTH.  It also
// keeps track of a BSTR which it ShellExecutes in its IOleCommandTarget::Exec()
//
STDAPI CToolbarExtExec_CreateInstance(
            IUnknown        * punkOuter,
            IUnknown        ** ppunk,
            LPCOBJECTINFO   poi
            )
{
    HRESULT hr = S_OK;

    *ppunk = NULL;

    CToolbarExtExec * lpTEE = new CToolbarExtExec();

    if (lpTEE == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpTEE, IBrowserExtension *);

    return hr;
}

CToolbarExtExec::CToolbarExtExec()
{
    ASSERT(_cRef == 1);
    ASSERT(_bstrToolTip == NULL);
    ASSERT(_bstrExec == NULL);
    ASSERT(_bstrScript == NULL);
    ASSERT(_bstrMenuText == NULL);
    ASSERT(_bstrMenuCustomize == NULL);
    ASSERT(_bstrMenuStatusBar == NULL);
    ASSERT(_punkExt == NULL);
}

CToolbarExtExec::~CToolbarExtExec()
{
    if (_bstrToolTip)
        SysFreeString(_bstrToolTip);

    if (_bstrExec)
        SysFreeString(_bstrExec);

    if (_bstrScript)
        SysFreeString(_bstrScript);

    if (_bstrMenuText)
        SysFreeString(_bstrMenuText);

    if (_bstrMenuCustomize)
        SysFreeString(_bstrMenuCustomize);

    if (_bstrMenuStatusBar)
        SysFreeString(_bstrMenuStatusBar);

    if (_punkExt)
        _punkExt->Release();
}

// Pass on the work for the toolbar button intiaztion to the base class then determine the object
// type and initialize the menu information if necessary...
STDMETHODIMP CToolbarExtExec::Init(REFGUID rguid)
{
    HRESULT hr = CToolbarExt::Init(rguid);

    // If the baseclass initialization went OK, then we have a working button
    if (hr == S_OK)
        _bButton = TRUE;

    // Get app and/or script to execute (optional)
    _RegReadString(_hkeyThisExtension, TEXT("Exec"), &_bstrExec, TRUE);
    _RegReadString(_hkeyThisExtension, TEXT("Script"), &_bstrScript, TRUE);

        
    // See if we have a menu item
    if (_RegReadString(_hkeyThisExtension, TEXT("MenuText"), &_bstrMenuText))
    {
        _RegReadString(_hkeyThisExtension, TEXT("MenuCustomize"), &_bstrMenuCustomize);
        _RegReadString(_hkeyThisExtension, TEXT("MenuStatusBar"), &_bstrMenuStatusBar);
        _bMenuItem = TRUE;
    }

    if (_bMenuItem || _bButton)
    {
        hr = S_OK;
    }

    return hr;
}

// It we're a button try passing the work on to the base class, if that doesn't cut it we'll
// check the menu stuff...
STDMETHODIMP CToolbarExtExec::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT     hr = S_OK;
    BOOL        fImple = FALSE;

    if (_bButton)
    {
        // If The generic button's getproperty returns S_OK then our job here is done
        if (CToolbarExt::GetProperty(iPropID, pvarProperty) == S_OK)
            fImple = TRUE;
    }

    if (_bMenuItem && !fImple)
    {
        fImple = TRUE;

        if (pvarProperty)
            VariantInit(pvarProperty);

        switch (iPropID)
        {
            case TMEX_CUSTOM_MENU:
            {
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuCustomize);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            break;

            case TMEX_MENUTEXT:
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuText);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            case TMEX_STATUSBARTEXT:
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuStatusBar);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            default:
                fImple = FALSE;
        }
    }

    if (!fImple)
        hr = E_NOTIMPL;

    return hr;
}

STDMETHODIMP CToolbarExtExec::SetSite(IUnknown* punkSite)
{
    // Give the external object our site
    IUnknown_SetSite(_punkExt, punkSite);
    
    // Call base class
    return CToolbarExt::SetSite(punkSite);
}

STDMETHODIMP CToolbarExtExec::QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD rgCmds[], OLECMDTEXT * pCmdText)
{
    HRESULT hr = S_OK;

    // Pass query to external object if it exists
    IOleCommandTarget* pCmd;
    if (_punkExt && SUCCEEDED(_punkExt->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmd)))
    {
        hr = pCmd->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
        pCmd->Release();
    }
    else
    {
        // Let base class handle this
        hr = CToolbarExt::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
    }

    return hr;
}

// Shell execute the _bstrExec 
STDMETHODIMP CToolbarExtExec::Exec(
                const GUID              * pguidCmdGroup,
                DWORD                   nCmdId,
                DWORD                   nCmdexecopt,
                VARIANT                 * pvaIn,
                VARIANT                 * pvaOut
                )
{
    HRESULT hr = S_OK;

    //
    // The first time this is called, we lazy instantiate an external object if
    // one is registered.. This object can JIT in components and provide a
    // command target.
    //
    if (!_bExecCalled)
    {
        // We only do this once
        _bExecCalled = TRUE;

        BSTR bstrExtCLSID;
        if (_RegReadString(_hkeyThisExtension, TEXT("clsidExtension"), &bstrExtCLSID))
        {
            // We have an extension clsid, so create the object.  This gives the object an oportunity
            // to jit in code when its button or menu is invoked.
            CLSID clsidExt;

            if (CLSIDFromString(bstrExtCLSID, &clsidExt) == S_OK)
            {
                if (SUCCEEDED(CoCreateInstance(clsidExt, NULL, CLSCTX_INPROC_SERVER,
                                     IID_IUnknown, (void **)&_punkExt)))
                {
                    // Give the object our site (optional)
                    IUnknown_SetSite(_punkExt, _pisb);
                }
            }
            SysFreeString(bstrExtCLSID);
        }
    }

    // Pass command to external object if it exists
    IOleCommandTarget* pCmd;
    if (_punkExt && SUCCEEDED(_punkExt->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmd)))
    {
        hr = pCmd->Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
        pCmd->Release();
    }

    // Run a script if one was specified
    if(_bstrScript && _pisb)
    {
        IOleCommandTarget *poct = NULL;
        VARIANT varArg;
        varArg.vt = VT_BSTR;
        varArg.bstrVal = _bstrScript;
        hr = _pisb->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&poct);
        if (SUCCEEDED(hr))
        {
            // Tell MSHTML to execute the script
            hr = poct->Exec(&CGID_MSHTML, IDM_RUNURLSCRIPT, 0, &varArg, NULL);
            poct->Release();
        }
    }

    // Launch executable if one was specified
    if (_bstrExec)
    {
        SHELLEXECUTEINFO sei = { 0 };

        sei.cbSize = sizeof(sei);
        sei.lpFile = _bstrExec;
        sei.nShow = SW_SHOWNORMAL;

        // We are using ShellExecuteEx over ShellExecute because the Unicode version of ShellExecute
        // is bogus on 95/98
        if (ShellExecuteExW(&sei) == FALSE)
            hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\thicket.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------
#include "priv.h"

//#include "headers.hxx"
//#include "formkrnl.hxx"
#include <platform.h>
#include <mlang.h>
#include "resource.h"
#include "impexp.h"
#include "reload.h"
//#include <siterc.h>
#include "packager.h"
#include "iehelpid.h"
#include "thicket.h"
#include "apithk.h"
#include <strsafe.h>

#include <mluisupp.h>
#include <mshtmcid.h>

#define NUM_OLE_CMDS                          1

#define SAVEAS_OK                             0x00000001
#define SAVEAS_NEVER_ASK_AGAIN                0x00000002

#define CODEPAGE_UNICODE                      0x000004B0
#define CODEPAGE_UTF8                         0x0000FDE9
#define UNICODE_TEXT                          TEXT("Unicode")

#define REGSTR_VAL_SAVEDIRECTORY              TEXT("Save Directory")
#define REGKEY_SAVEAS_WARNING_RESTRICTION     TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")
#define REGVALUE_SAVEAS_WARNING               TEXT("NoSaveAsPOSTWarning")

#define WM_WORKER_THREAD_COMPLETED            WM_USER + 1000

#define MAX_ENCODING_DESC_LEN                 1024


const static DWORD aSaveAsHelpIDs[] =
{
    IDC_SAVE_CHARSET,   IDH_CHAR_SET_SAVE_AS,
    0,                  0
};

INT_PTR CALLBACK SaveAsWarningDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
                                      LPARAM lParam);

HRESULT SaveToThicket( HWND hwnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                       UINT codepageSrc, UINT codepageDst,
                       UINT iPackageStyle );

HRESULT
FormsGetFileName(
        HWND hwndOwner,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex,
        BOOL bForceHTMLOnly);
HRESULT
GetFileNameFromURL( LPWSTR pwszURL, LPTSTR pszFile, DWORD cchFile);

void ReportThicketError( HWND hwnd, HRESULT hr );

#define DOWNLOAD_PROGRESS  0x9001
#define DOWNLOAD_COMPLETE  0x9002
#define THICKET_TIMER      0x9003
#define THICKET_INTERVAL   1000

#define MDLGMSG(psz, x)         TraceMsg(0, "shd TR-MODELESS::%s %x", psz, x)

static DWORD s_dwInetComVerMS = 0;
static DWORD s_dwInetComVerLS = 0;

struct ThicketCPInfo
{
    UINT    cpSrc;
    UINT    cpDst;
    LPWSTR lpwstrDocCharSet;
};

class CThicketUI
{
public:
    CThicketUI(void) :
        _hDlg(NULL),
        _hWndProg(NULL),
        _iErrorDL(0),
        _hrDL(E_FAIL),
#ifndef NO_MARSHALLING
        _pstmDoc(NULL),
#else
        _pDoc(NULL),
#endif
        _pszFileName(NULL),
        _dwDLMax(0),
        _codepageSrc(0),
        _codepageDst(0),
        _iPackageStyle(PACKAGE_THICKET),
        _fCancel(FALSE) {};

    ~CThicketUI(void) 
    { 
#ifndef NO_MARSHALLING
        SAFERELEASE(_pstmDoc);
#endif
        SAFELOCALFREE(_pszFileName); 
    };

    // CThicketUI methods
    HRESULT SaveDocument( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                          UINT codepageSrc, UINT codepageDst,
                          UINT iPackageStyle );

protected:
    static BOOL_PTR ThicketUIDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI ThicketUIThreadProc( LPVOID );

    BOOL DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    HWND                _hDlg;
    HWND                _hWndProg;
    int                 _iErrorDL;
    HRESULT             _hrDL;
#ifndef UNIX
    IStream             *_pstmDoc;      // marshalled IHTMLDocument2
#else
    IHTMLDocument2      *_pDoc;
#endif
    LPTSTR              _pszFileName;
    DWORD               _dwDLMax;
    UINT                _codepageSrc;
    UINT                _codepageDst;
    BOOL                _fThreadStarted;
    UINT                _iPackageStyle;
    BOOL                _fCancel;
};

HRESULT
CThicketUI::SaveDocument( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                          UINT codepageSrc, UINT codepageDst,
                          UINT iPackageStyle)
{
    _pszFileName = StrDup(pszFileName);
    _codepageSrc = codepageSrc;
    _codepageDst = codepageDst;
    _iPackageStyle = iPackageStyle;

#ifndef NO_MARSHALLING
    // We don't do anything with pDoc until we're on the worker thread,
    // so marshall it.
    _hrDL = CoMarshalInterThreadInterfaceInStream(IID_IHTMLDocument2, pDoc, &_pstmDoc);

    if (SUCCEEDED(_hrDL))
#else
    _pDoc = pDoc;
#endif
    {
        // Needs to be modal cuz we're going to work with pDoc on the worker thread
        // so we don't want the user to navigate away from it, close the window, etc.
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SAVETHICKET),
                         hWnd, CThicketUI::ThicketUIDlgProc, (LPARAM)this);

     //   HWND hwnd = MLCreateDialogParamWrap(MLGetHinst(), MAKEINTRESOURCE(IDD_SAVETHICKET),
     //                                 NULL, CThicketUI::ThicketUIDlgProc, (LPARAM)this);
     //   if (!hwnd)
     //       _hrDL = E_FAIL;
    }

    return _hrDL;
}

BOOL_PTR
CThicketUI::ThicketUIDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL        fRet = FALSE;
    CThicketUI* ptui = NULL;

    if (msg == WM_INITDIALOG)
    {
        ptui = (CThicketUI*)lParam;
    }
    else
        ptui = (CThicketUI*)GetWindowLongPtr(hDlg, DWLP_USER);

    if (ptui)
    {
        fRet = ptui->DlgProc(hDlg, msg, wParam, lParam);

        if (msg == WM_DESTROY || msg == WM_WORKER_THREAD_COMPLETED)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL
CThicketUI::DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;

    switch (msg)
    {
    case WM_INITDIALOG:
        _hDlg = hDlg;
        _hWndProg = GetDlgItem(hDlg, IDC_THICKETPROGRESS);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        _hrDL = S_FALSE;

#ifndef NO_MARSHALLING
        //_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThicketUIThreadProc, this, 0, &_idThread);
        if (!(_fThreadStarted = SHQueueUserWorkItem(ThicketUIThreadProc,
                                                    this,
                                                    0,
                                                    (DWORD_PTR)NULL,
                                                    (DWORD_PTR *)NULL,
                                                    "shdocvw.dll",
                                                    TPS_LONGEXECTIME)))
            _hrDL = E_FAIL;
#else
        ThicketUIThreadProc((LPVOID)this);
#endif

        if (FAILED(_hrDL))
             EndDialog(hDlg, 0);
        else
        {
            ShowWindow(hDlg, SW_SHOWNORMAL);
            Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, IDA_DOWNLOAD);
            ShowWindow(GetDlgItem(hDlg, IDD_DOWNLOADICON), SW_HIDE);
        }
        fRet = FALSE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            _fCancel = TRUE;
            // and wait for the worker thread to quit, polling at WM_TIMER
            break;

        default:
            break;
        }
        break;

    case WM_WORKER_THREAD_COMPLETED:
        _hrDL = (DWORD) wParam;
        EndDialog(hDlg,0);
        break;

    //case WM_CLOSE:
    //    KillTimer( hDlg, THICKET_TIMER );
    //    _fCancel = TRUE;
    //    while( _hrDL == S_FALSE );
    //    break;

    case WM_DESTROY:
        _fCancel = TRUE;
        while( _hrDL == S_FALSE )
        {
            Sleep(0);
        }
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}

DWORD WINAPI CThicketUI::ThicketUIThreadProc( LPVOID ppv )
{
    HRESULT hr = S_OK;
    CThicketUI* ptui = (CThicketUI *)ppv;

    ASSERT(ptui);

    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IHTMLDocument2 *pDoc = NULL;

#ifndef NO_MARSHALLING
        hr = CoGetInterfaceAndReleaseStream( ptui->_pstmDoc, IID_IHTMLDocument2,(LPVOID*)&pDoc);

        // CoGetInterfaceAndReleaseStream always releases the stream
        ptui->_pstmDoc = NULL;
#else
        pDoc = ptui->_pDoc;
        pDoc->AddRef();
#endif

        if (SUCCEEDED(hr))
        {
            CThicketProgress    tprog( ptui->_hDlg );
            CDocumentPackager   docPkgr(ptui->_iPackageStyle);

            hr = S_FALSE;

            hr = docPkgr.PackageDocument( pDoc, ptui->_pszFileName,
                          &ptui->_fCancel, &tprog,
                          0, 100,
                          ptui->_codepageDst );

            pDoc->Release(); // release marshalled interface
        }

        CoUninitialize();
    }

    PostMessage(ptui->_hDlg, WM_WORKER_THREAD_COMPLETED, hr, 0);

    return 0;
}


//+------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------
HRESULT
SaveToThicket( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
               UINT codepageSrc, UINT codepageDst, UINT iPackageStyle )
{
    HRESULT     hr;
    CThicketUI* ptui;

#ifdef OLD_THICKET
    LPTSTR      lpszURL;

    lpszURL = bstrDocURL;

    const   DWORD       dwMaxPathLen        = 24;

    URL_COMPONENTS urlComp;
    TCHAR   rgchUrlPath[MAX_PATH];
    TCHAR   rgchCanonicalUrl[MAX_URL_STRING];
    DWORD   dwLen;

    dwLen = ARRAYSIZE(rgchCanonicalUrl);

    hr = UrlCanonicalize( lpszURL, rgchCanonicalUrl, &dwLen, 0);
    if (FAILED(hr))
        return E_FAIL;

    ZeroMemory(&urlComp, sizeof(urlComp));

    urlComp.dwStructSize = sizeof(urlComp);
    urlComp.lpszUrlPath = rgchUrlPath;
    urlComp.dwUrlPathLength = ARRAYSIZE(rgchUrlPath);

    hr = InternetCrackUrl(rgchCanonicalUrl, lstrlen(rgchCanonicalUrl), ICU_DECODE, &urlComp);
    if (FAILED(hr))
        return E_FAIL;

    // Since this is not a snap-shot, saving the doc over itself is a no-op.
    // This means we can avoid some nasty issues with the save-over, safe-save,
    // et al, by short circuiting the save here.
    if ( StrCmpI(pszFileName, rgchUrlPath) == 0 )
    {
        if (PathFileExists(pszFileName))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

#endif //OLD_THICKET

    ptui = new CThicketUI;
    if (ptui)
    {
        hr = ptui->SaveDocument( hWnd, pszFileName, pDoc, codepageSrc, codepageDst, iPackageStyle );
        delete ptui;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//+------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------

void SaveBrowserFile( HWND hwnd, LPUNKNOWN punk )
{
    HRESULT         hr;
    TCHAR           szFileDst[MAX_PATH];
    DWORD           iFilter = 1;
    IHTMLDocument2  *pDoc;
    BSTR            bstrURL = NULL;
    ThicketCPInfo   tcpi;
    BSTR            bstrCharSet = NULL;
    BSTR            bstrTitle = NULL;
    BSTR            bstrMime = NULL;
    IOleCommandTarget *pOleCommandTarget = NULL;
    WCHAR          *pwzExt = NULL;
    OLECMD          pCmd[NUM_OLE_CMDS];
    ULONG           nCmds = NUM_OLE_CMDS;
    BOOL            bForceHTMLOnly = FALSE;

    static const WCHAR *wzImage = L" Image";
    

    hr = punk->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
    if (FAILED(hr))
        goto Cleanup;

    if (FAILED(pDoc->get_URL( &bstrURL )))
        goto Cleanup;

    hr = pDoc->get_charset( &bstrCharSet );
    if (FAILED(hr))
        goto Cleanup;

    tcpi.cpSrc = CP_ACP;
    tcpi.lpwstrDocCharSet = bstrCharSet;

    // If it is an image file, then bring up trident to do the save.
    // APPCOMPAT: This is a crappy way to do this. We are hard-coding the
    // image types, so we know to put up the "Save as image" dialog.
    // We originally tried looking at the MIME type, but Trident returns
    // inconsistent MIME types to us (ex. under some platforms we get
    // "JPG Image" and under others we get "JPG File"!).

    ASSERT(bstrURL);

    pwzExt = bstrURL + lstrlenW(bstrURL);

    while (pwzExt > bstrURL && *pwzExt != L'.')
    {
        pwzExt--;
    }

    hr = pDoc->QueryInterface(IID_IOleCommandTarget,
                              (void **)&pOleCommandTarget);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pwzExt > bstrURL) {

        // Found a "dot". Now pwzExt points to what we think is the extension

        if (!StrCmpIW(pwzExt, L".JPG") ||
            !StrCmpIW(pwzExt, L".GIF") ||
            !StrCmpIW(pwzExt, L".BMP") ||
            !StrCmpIW(pwzExt, L".XBM") ||
            !StrCmpIW(pwzExt, L".ART") ||
            !StrCmpIW(pwzExt, L".PNG") ||
            !StrCmpIW(pwzExt, L".WMF") ||
            !StrCmpIW(pwzExt, L".TIFF") ||
            !StrCmpIW(pwzExt, L".JPEG"))
        {
            hr = pOleCommandTarget->Exec(&CGID_MSHTML, IDM_SAVEPICTURE, 0,
                                         NULL, NULL);

            // FEATURE: Handle a failed HR here. It is very unlikely that
            // this will fail, yet regular save-as code (that follows)
            // will succeed. We always exit out of here, so we will
            // never get two UI dialogs thrown at the user. We should
            // come up with a good scheme to propagate an error dialog
            // to the user. Possible scenario: low disk space causing
            // a fail-out.

            goto Cleanup;
        }
    }

    // IE5 RAID #54672: Save-as has problems saving pages generated by POSTs
    // This code is to detect if the page was generated by POST data and
    // warn the user that saving may not work.

    pCmd[0].cmdID = SHDVID_PAGEFROMPOSTDATA;
    hr = pOleCommandTarget->QueryStatus(&CGID_ShellDocView, nCmds, pCmd, NULL);

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pCmd[0].cmdf & OLECMDF_LATCHED)
    {
        HKEY         hkeySaveAs = 0;
        DWORD        dwValue = 0;
        DWORD        dwSize = 0;
        INT_PTR      iFlags = 0;

        bForceHTMLOnly = TRUE;

        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         REGKEY_SAVEAS_WARNING_RESTRICTION, 0,
                         KEY_READ, &hkeySaveAs) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);

            if (RegQueryValueEx(hkeySaveAs, REGVALUE_SAVEAS_WARNING, NULL,
                                NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
            {

                if (dwValue)
                {
                    // restriction set, don't show dialog
                    RegCloseKey(hkeySaveAs);
                    goto Continue;
                }
            }

            RegCloseKey(hkeySaveAs);
        }

        iFlags = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_SAVEAS_WARNING),
                                hwnd, SaveAsWarningDlgProc, (LPARAM)0);

        if (!(iFlags & SAVEAS_OK))
        {
            goto Cleanup;
        }
        
        if (iFlags & SAVEAS_NEVER_ASK_AGAIN)
        {
            HKEY                 hkey = 0;
            DWORD                dwNeverAsk = 1;

            if (RegOpenKeyEx(HKEY_CURRENT_USER,
                             REGKEY_SAVEAS_WARNING_RESTRICTION, 0,
                             KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
            {

                RegSetValueEx(hkey, REGVALUE_SAVEAS_WARNING, 0, REG_DWORD,
                              (CONST BYTE *)&dwNeverAsk,
                              sizeof(dwNeverAsk));
                RegCloseKey(hkey);
            }
        }
    }
    
Continue:

    // Suggest a file name
    
    szFileDst[0] = 0;

    // Our favorite candidate is the title,  fall back on the file name.
    hr = pDoc->get_title(&bstrTitle);
    if (SUCCEEDED(hr) && lstrlenW(bstrTitle))
    {
        hr = StringCchCopy(szFileDst, ARRAYSIZE(szFileDst), bstrTitle);
    }
    else
        hr = GetFileNameFromURL(bstrURL, szFileDst, ARRAYSIZE(szFileDst));

    if (FAILED(hr))
        goto Cleanup;

    PathCleanupSpec(NULL, szFileDst);

    hr = FormsGetFileName(hwnd, szFileDst, ARRAYSIZE(szFileDst),
                          (LONG_PTR)&tcpi, &iFilter, bForceHTMLOnly);

    if (hr==S_OK)
        hr = SaveToThicket( hwnd, szFileDst, pDoc, tcpi.cpSrc, tcpi.cpDst, iFilter);

Cleanup:

    if (FAILED(hr))
        ReportThicketError(hwnd, hr);

    if (pOleCommandTarget)
        pOleCommandTarget->Release();

    if (pDoc)
        pDoc->Release();

    if (bstrURL)
        SysFreeString(bstrURL);

    if (bstrCharSet)
        SysFreeString(bstrCharSet);

    if (bstrTitle)
        SysFreeString(bstrTitle);

    return;
}

void ReportThicketError( HWND hwnd, HRESULT hr )
{
    LPTSTR lpstrMsg = NULL;

    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
    case E_OUTOFMEMORY:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRMEM);
        break;

    case E_ACCESSDENIED:
    case STG_E_ACCESSDENIED:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRACC);
        break;

    case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
    case STG_E_MEDIUMFULL:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRFULL);
        break;

    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRFNF);
        break;

    case E_ABORT:
        // Ray says we don't want a canceled message box.
        //lpstrMsg = MAKEINTRESOURCE(IDS_THICKETABORT);
        break;

    case E_FAIL:
    default:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRMISC);
        break;
    }

    if ( lpstrMsg )
    {
        MLShellMessageBox(
                        hwnd,
                        lpstrMsg,
                        MAKEINTRESOURCE(IDS_THICKETERRTITLE),
                        MB_OK | MB_ICONERROR);
    }
}

//+--------------------------------------------------------------------------
//
//  File:       file.cxx
//
//  Contents:   Import/export dialog helpers
//
//  History:    16-May-95   RobBear     Taken from formtool
//
//---------------------------------------------------------------------------

const CHAR c_szNT4ResourceLocale[]      = ".DEFAULT\\Control Panel\\International";
const CHAR c_szWin9xResourceLocale[]    = ".Default\\Control Panel\\desktop\\ResourceLocale";
const CHAR c_szLocale[]                 = "Locale";

LANGID
MLGetShellLanguage()
{
    LANGID  lidShell = 0;

    // FEATURE: this fn is copied from shlwapi. there really should be a
    // shlwapi export. if MLGetUILanguage has any merit, then
    // MLGetShellLanguage has merit as well.

    if (IsOS(OS_WIN2000ORGREATER))
    {
        static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

        if (pfnGetUserDefaultUILanguage == NULL)
        {
            HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

            if (hmod)
                pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
        }
        if (pfnGetUserDefaultUILanguage)
            lidShell = pfnGetUserDefaultUILanguage();
    }
    else
    {
        CHAR szLangID[12];
        DWORD cb, dwRet;

        cb = sizeof(szLangID) - 2*sizeof(szLangID[0]);  // avoid 2 byte buffer overrun
        if (IsOS(OS_NT))
            dwRet = SHGetValueA(HKEY_USERS, c_szNT4ResourceLocale, c_szLocale, NULL, szLangID + 2, &cb);
        else
            dwRet = SHGetValueA(HKEY_USERS, c_szWin9xResourceLocale, NULL, NULL, szLangID + 2, &cb);

        if (ERROR_SUCCESS == dwRet)
        {
            // IE uses a string rep of the hex value
            szLangID[0] = '0';
            szLangID[1] = 'x';
            StrToIntExA(szLangID, STIF_SUPPORT_HEX, (LPINT)&lidShell);
        }
    }

    return lidShell;
}

/*
 *  Stolen from Trident's src\core\cdutil\file.cxx
 */

// Hook procedure for open file dialog.

UINT_PTR APIENTRY SaveOFNHookProc(HWND hdlg,
                                  UINT uiMsg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    ULONG i, iCurSel;
    BOOL  bFoundEncoding = FALSE;
    WCHAR wzEncoding[MAX_ENCODING_DESC_LEN];

    switch (uiMsg)
    {
        // Populate the dropdown.
        case WM_INITDIALOG:
        {
            HRESULT hr;
            LPOPENFILENAME pofn = (LPOPENFILENAME)lParam;
            ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;
            IMultiLanguage2 *pMultiLanguage = NULL;
            IEnumCodePage  *pEnumCodePage = NULL;
            //UINT            codepageDefault = ptcpi->cp;
            MIMECSETINFO    csetInfo;
            LANGID          langid;

#ifdef UNIX
            SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ptcpi);
#endif /* UNIX */

            hr = CoCreateInstance(
                    CLSID_CMultiLanguage,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMultiLanguage2,
                    (void**)&pMultiLanguage);
            if (hr)
                break;

            hr = pMultiLanguage->GetCharsetInfo(ptcpi->lpwstrDocCharSet,&csetInfo);
            if (hr)
                break;

#ifndef UNIX
            // the shell combobox where this stuff shows up
            // doesn't know how to fontlink... so we have
            // to stay in the shell's codepage
            langid = MLGetShellLanguage();
#else
            langid = GetSystemDefaultLangID();
#endif /* UNIX */
            if (pMultiLanguage->EnumCodePages( MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID,
                                               langid,
                                               &pEnumCodePage) == S_OK)
            {
                MIMECPINFO cpInfo;
                ULONG      ccpInfo;
                UINT       cpDefault;

                if (pMultiLanguage->GetCodePageInfo(csetInfo.uiInternetEncoding, langid, &cpInfo) == S_OK &&
                    !(cpInfo.dwFlags & MIMECONTF_SAVABLE_BROWSER))
                {
                    // If the codepage selected is not savable (eg JP_AUTO),
                    // use the family codepage.
                    cpDefault = cpInfo.uiFamilyCodePage;
                }
                else
                    cpDefault = csetInfo.uiInternetEncoding;

                ptcpi->cpSrc = csetInfo.uiInternetEncoding;

                if (cpDefault == CODEPAGE_UNICODE &&
                    pofn->nFilterIndex == PACKAGE_MHTML) {
                    cpDefault = CODEPAGE_UTF8;
                }

                for (i = 0; pEnumCodePage->Next(1, &cpInfo, &ccpInfo) == S_OK; ++i)
                {
                    TCHAR *lpszDesc;
                    INT_PTR iIdx;

                    if (cpInfo.uiCodePage == CODEPAGE_UNICODE &&
                        pofn->nFilterIndex == PACKAGE_MHTML) {
                        i--;
                        continue;
                    }

                    if (cpDefault == cpInfo.uiCodePage)
                    {
                       bFoundEncoding = SUCCEEDED(StringCchCopyW(wzEncoding, ARRAYSIZE(wzEncoding), cpInfo.wszDescription));
                    }

                    lpszDesc = cpInfo.wszDescription;

                    iIdx = SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)lpszDesc);
                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                       CB_SETITEMDATA, iIdx,
                                       (LPARAM)cpInfo.uiCodePage);
                }

                if (bFoundEncoding)
                {
                    INT_PTR iIndex = 0;

                    iIndex = SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                CB_FINDSTRINGEXACT, -1,
                                                (LPARAM)wzEncoding);

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                       (WPARAM)iIndex, 0);
                }
                else
                {
                    // No encoding found! Bad error. Recover by selecting
                    // the first one.

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                       0, 0);
                }

            }
            SAFERELEASE(pEnumCodePage);
            SAFERELEASE(pMultiLanguage);
            break;
        }

#ifdef UNIX
        case WM_COMMAND:
        {
          switch (GET_WM_COMMAND_ID(wParam,lParam))
          {
            case IDOK:
            {
                 ThicketCPInfo *ptcpi = (ThicketCPInfo *)GetWindowLongPtr(hdlg,DWLP_USER);

                 ptcpi->cpDst = CP_ACP;
                 iCurSel = (int) SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);
                 ptcpi->cpDst =
                 (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                 (WPARAM)iCurSel, (LPARAM)0);

                 // To spare us from re-instantiating MLANG, we'll set the src and dest
                 // to CP_ACP if no change is indicated.
                 if (ptcpi->cpDst == ptcpi->cpSrc)
                    ptcpi->cpDst = ptcpi->cpSrc = CP_ACP;
           }
           break;
         }
        }
        break;
#endif /* UNIX */

        case WM_NOTIFY:
        {
            LPOFNOTIFY phdr = (LPOFNOTIFY)lParam;

            switch (phdr->hdr.code)
            {
                case CDN_FILEOK:
                {
                    LPOPENFILENAME pofn = (LPOPENFILENAME)phdr->lpOFN;
                    ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;

                    iCurSel = (int) SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);
                    ptcpi->cpDst = //*(UINT *)phdr->lpOFN->lCustData =
                        (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);
                }

                // HACK! This case is implemented to implement a hack for
                // IE5 RAID #60672. MIMEOLE cannot save UNICODE encoding,
                // so when the user selects MHTML saves, we should remove
                // this option.  This code should be removed when MIMEOLE
                // fixes their bug (targeted for NT5 RTM). Contact SBailey
                // for the status of this.

                case CDN_TYPECHANGE:
                {
                    LPOPENFILENAME pofn = (LPOPENFILENAME)phdr->lpOFN;
                    ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;
                    UINT uiCPSel, uiCP;
                    int iType = pofn->nFilterIndex;
                    UINT iCount;
                    int iCurSel;
                    int iSet = -1;

                    if (iType == PACKAGE_MHTML)
                    {
                        iCurSel = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);

                        uiCPSel = (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);
                         
                        // If you selected unicode, make it look like you
                        // really selected UTF-8

                        if (uiCPSel == CODEPAGE_UNICODE)
                        {
                            uiCPSel = CODEPAGE_UTF8;
                        }

                        i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                     CB_FINDSTRINGEXACT,
                                                     (WPARAM)0,
                                                     (LPARAM)UNICODE_TEXT);
                        if (i != CB_ERR)
                        {
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                               CB_DELETESTRING, i, (LPARAM)0);
                        }

                        iCount = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                         CB_GETCOUNT, 0, 0);

                        // Set selected item back

                        for (i = 0; i < iCount; i++)
                        {
                            uiCP = (UINT)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                                            (WPARAM)i, (LPARAM)0);
                            if (uiCP == uiCPSel)
                            {
                                iSet = i;
                            }
                        }

                        if (iSet != 0xffffffff)
                        {
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                               (WPARAM)iSet, (LPARAM)0);
                        }
                    }
                    else
                    {
                        // Store current selection

                        iCurSel = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);

                        uiCPSel = (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);

                        // Add unicode back in, if it was removed

                        i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                     CB_FINDSTRINGEXACT,
                                                     (WPARAM)0,
                                                     (LPARAM)UNICODE_TEXT);

                        if (i == CB_ERR) {
                            // Unicode does not exist, add it back in
                            i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                         CB_ADDSTRING, 0,
                                                         (LPARAM)UNICODE_TEXT);
    
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                               CB_SETITEMDATA, i,
                                               (LPARAM)CODEPAGE_UNICODE);

    
                            // Make sure the same encoding selected before is
                            // still selected.
                            iCount = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                             CB_GETCOUNT, 0, 0);
                            for (i = 0; i < iCount; i++)
                            {
                                uiCP = (UINT)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                                                (WPARAM)i, (LPARAM)0);
                                if (uiCP == uiCPSel)
                                {
                                    iSet = i;
                                }
                            }
    
                            if (iCurSel != 0xffffffff)
                            {
                                SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                                   (WPARAM)iSet, (LPARAM)0);
                            }
                        }

                    }

                }
                break;
            }
        }
        break;

        case WM_HELP:
        {
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle,
                          c_szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR)aSaveAsHelpIDs);
        }
        break;

        case WM_CONTEXTMENU:
        {
            SHWinHelpOnDemandWrap((HWND) wParam,
                          c_szHelpFile, 
                          HELP_CONTEXTMENU,
                          (DWORD_PTR)aSaveAsHelpIDs);
        }
        break;
    }
    return (FALSE);
}

//
// Protect the naive users from themselves, if somebody enters a filename
// of microsoft.com when saving http://www.microsoft.com we don't want
// to save a .COM file since this will be interpreted as an executable.
// bad things will happen
//
void CleanUpFilename(LPTSTR pszFile, int iPackageStyle)
{
    //
    // If we find .COM as the file extension replace it with the file extension
    // of the filetype they are saving the file as
    //
    LPTSTR pszExt = PathFindExtension(pszFile);

    ASSERT(pszExt);
    if (StrCmpI(pszExt, TEXT(".COM")) == 0) // REVIEW any other file types???
    {
        //
        // Map the package style to a default extension. NOTE this relies on 
        // the fact that the filter index maps to the PACKAGE style enum
        // (as does the rest of the thicket code).
        //
        switch (iPackageStyle)
        {
        case PACKAGE_THICKET:
        case PACKAGE_HTML:
            StringCchCat(pszFile, MAX_PATH, TEXT(".htm")); 
            break;

        case PACKAGE_MHTML:
            StringCchCat(pszFile, MAX_PATH, TEXT(".mht")); 
            break;

        case PACKAGE_TEXT:
            StringCchCat(pszFile, MAX_PATH, TEXT(".txt")); 
            break;

        default:
            ASSERT(FALSE);  // Unknown package type
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsGetFileName
//
//  Synopsis:   Gets a file name using either the GetOpenFileName or
//              GetSaveFileName functions.
//
//  Arguments:  [fSaveFile]   -- TRUE means use GetSaveFileName
//                               FALSE means use GetOpenFileName
//
//              [idFilterRes] -- The string resource specifying text in the
//                                  dialog box.  It must have the
//                                  following format:
//                            Note: the string has to be _one_ contiguous string.
//                                  The example is broken up to make it fit
//                                  on-screen. The verical bar ("pipe") characters
//                                  are changed to '\0'-s on the fly.
//                                  This allows the strings to be localized
//                                  using Espresso.
//
//          IDS_FILENAMERESOURCE, "Save Dialog As|         // the title
//                                 odg|                    // default extension
//                                 Forms3 Dialog (*.odg)|  // pairs of filter strings
//                                 *.odg|
//                                 Any File (*.*)|
//                                 *.*|"
//
//              [pstrFile]    -- Buffer for file name.
//              [cchFile]     -- Size of buffer in characters.
//
//  Modifies:   [pstrFile]
//
//----------------------------------------------------------------------------
#ifdef _MAC
extern "C" {
char * __cdecl _p2cstr(unsigned char *);
}
#endif

#define CHAR_DOT                TEXT('.')
#define CHAR_DOT_REPLACEMENT    TEXT('_')

void ReplaceDotsInFileName(LPTSTR pszFileName)
{
    ASSERT(pszFileName);

    while (*pszFileName)
    {
        if (*pszFileName == CHAR_DOT)
        {
            *pszFileName = CHAR_DOT_REPLACEMENT;
        }
        pszFileName++;
    }
}


HRESULT
FormsGetFileName(
        HWND hwndOwner,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex,
        BOOL bForceHTMLOnly)
{
    HRESULT         hr  = S_OK;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    LPTSTR          pstr;
    OPENFILENAME    ofn;
    TCHAR           achBuffer[4096];    //  Max. size of a string resource
    TCHAR *         cp;
    TCHAR *         pstrExt;
    int             cbBuffer;
    TCHAR           achPath[MAX_PATH];
    DWORD           dwType = REG_SZ;
    DWORD           cbData = MAX_PATH * sizeof(TCHAR);
    int             idFilterRes;


    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndOwner;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
#ifndef UNIX
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
#else
                            OFN_NOCHANGEDIR;
#endif /* UNIX */

    ofn.lpfnHook        = NULL;
    ofn.nMaxFile        = cchFile;
    ofn.lCustData       = lCustData;
    ofn.lpstrFile       = pstrFile;
#ifndef NO_IME
    // We add an extra control to the save file dialog.

    if (lCustData)
    {
        ofn.Flags |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
        ofn.lpfnHook = SaveOFNHookProc;
        ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ADDTOSAVE_DIALOG);
        ofn.hInstance = g_hinst;
    }

#endif

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = pstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt >= pstrFile )
    {
        if( *pstrExt == TEXT('.') )
            break;
        pstrExt--;
    }
    if( pstrExt < pstrFile )
        pstrExt = NULL;

    // Load the filter spec.
    // FEATURE: Convert table to stringtable for localization

    if ( SHRestricted2W( REST_NoBrowserSaveWebComplete, NULL, 0 ) )
        idFilterRes = IDS_NOTHICKET_SAVE;
    else if ( s_dwInetComVerMS != 0xFFFFFFFF )
    {
#ifndef UNIX
        if (s_dwInetComVerMS == 0)
        {
            TCHAR szPath[MAX_PATH];

            GetSystemDirectory( szPath, MAX_PATH );
            if (SUCCEEDED(StringCchCat(szPath, MAX_PATH, TEXT("\\INETCOMM.DLL"))))
            {
                if (FAILED(GetVersionFromFile(szPath, &s_dwInetComVerMS, &s_dwInetComVerLS)))
                    s_dwInetComVerMS = 0xFFFFFFFF;
            }
        }

        if (s_dwInetComVerMS >= 0x50000 && s_dwInetComVerMS != 0xFFFFFFFF)
            idFilterRes = IDS_THICKET_SAVE;
        else
            idFilterRes = IDS_NOMHTML_SAVE;
#else
        // on UNIX we don't have inetcomm.dll if oe is not installed
        {
           HINSTANCE hInetComm = NULL;

           if ((hInetComm = LoadLibrary(TEXT("INETCOMM.DLL"))))
           {
              idFilterRes = IDS_THICKET_SAVE;
              FreeLibrary(hInetComm);
           }
           else
              idFilterRes = IDS_NOMHTML_SAVE;
        }
#endif
    }
    else
        idFilterRes = IDS_THICKET_SAVE;

    cbBuffer = MLLoadShellLangString(idFilterRes, achBuffer, ARRAYSIZE(achBuffer));
    ASSERT(cbBuffer > 0);
    if ( ! cbBuffer )
        return E_FAIL;

    ofn.lpstrTitle = achBuffer;

    for ( cp = achBuffer; *cp; cp++ )
    {
        if ( *cp == TEXT('|') )
        {
            *cp = TEXT('\0');
        }
    }

    ASSERT(ofn.lpstrTitle);

    // Default extension is second string.
    pstr = (LPTSTR) ofn.lpstrTitle;
    while (*pstr++)
    {
    }

    // N.B. (johnv) Here we assume that filter index one corresponds with the default
    //  extension, otherwise we would have to introduce a default filter index into
    //  the resource string.
    ofn.nFilterIndex    = ((pnFilterIndex)? *pnFilterIndex : 1);
    ofn.lpstrDefExt     = pstr;

    // Filter is third string.
    while(*pstr++)
    {
    }

    ofn.lpstrFilter = pstr;

    // Try to match the extension with an entry in the filter list
    // If we match, remove the extension from the incoming path string,
    //   set the default extension to the one we found, and appropriately
    //   set the filter index.

    if (pstrExt && !bForceHTMLOnly)
    {
        // N.B. (johnv) We are searching more than we need to.

        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( StrStr( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = TEXT('\0');

                break;
            }
            pSearch += lstrlen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    // Suggest HTML Only as default save-type

    if (bForceHTMLOnly)
    {
        // NOTE: These are hard-coded indices based on shdoclc.rc's
        // IDS_THICKET_SAVE, IDS_NOMHTML_SAVE, IDS_NOTHICKET_SAVE ordering.
        // This saves us the perf hit of doing string comparisons to find
        // HTML only

        switch (idFilterRes)
        {
            case IDS_NOTHICKET_SAVE:
                ofn.nFilterIndex = 1;
                break;

            case IDS_NOMHTML_SAVE:
                ofn.nFilterIndex = 2;
                break;

            default:
                ASSERT(idFilterRes == IDS_THICKET_SAVE);
                ofn.nFilterIndex = 3;
                break;
        }
    }

    if ( SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, REGSTR_VAL_SAVEDIRECTORY,
                    &dwType, achPath, &cbData) != ERROR_SUCCESS ||
         !PathFileExists(achPath))
    {
        SHGetSpecialFolderPath(hwndOwner, achPath, CSIDL_PERSONAL, FALSE);
    }

    ofn.lpstrInitialDir = achPath;

    // We don't want to suggest dots in the filename
    ReplaceDotsInFileName(pstrFile);

    // Now, at last, we're ready to call the save file dialog
    fOK = GetSaveFileName(&ofn);

    // if working with the abbreviated format list, adjust the index
    if (idFilterRes == IDS_NOTHICKET_SAVE)
        ofn.nFilterIndex += 2;
    else if ( idFilterRes == IDS_NOMHTML_SAVE && ofn.nFilterIndex > 1 )
        ofn.nFilterIndex += 1;

    if (fOK)
    {
        //
        // Protect the naive users from themselves, if somebody enters a filename
        // of microsoft.com when saving http://www.microsoft.com we don't want
        // to save a .COM file since this will be interpreted as an executable.
        // bad things will happen
        //
        CleanUpFilename(pstrFile, ofn.nFilterIndex);

        TCHAR *lpszFileName;

        if (SUCCEEDED(StringCchCopy(achPath, ARRAYSIZE(achPath), pstrFile)))
        {
            lpszFileName = PathFindFileName( achPath );
            *lpszFileName = 0;

            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, REGSTR_VAL_SAVEDIRECTORY,
                    REG_SZ, achPath, (lstrlen(achPath) * sizeof(TCHAR)));

            if (pnFilterIndex)
                *pnFilterIndex = ofn.nFilterIndex;

            if (ofn.nFilterIndex != PACKAGE_MHTML)
            {
                // we can only do this if we're not packaging MHTML
                // because MHTML requires that we tag with the explicit
                // charset, even if it was the default. unlike thicket
                // which inherits the charset from the original document,
                // MHTML must be explicitly tagged or else some system
                // charset tags will sneak in.

                ThicketCPInfo * ptcpi = (ThicketCPInfo *)lCustData;

                // To spare us from re-instantiating MLANG, we'll set the src and dest
                // to CP_ACP if no change is indicated.
                if (ptcpi->cpDst == ptcpi->cpSrc)
                ptcpi->cpDst = ptcpi->cpSrc = CP_ACP;
            }
        }
    }
    else
    {
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
        }
        else
        {
            hr = S_FALSE;
        }
#else // WINCE
        hr = E_FAIL;
#endif // WINCE
    }

    return hr;
}

HRESULT
GetFileNameFromURL( LPWSTR pwszURL, LPTSTR pszFile, DWORD cchFile)
{
    HRESULT         hr = S_OK;
    PARSEDURLW      puw = {0};
    int             cchUrl;

    cchUrl = SysStringLen(pwszURL);

    if (cchUrl)
    {
        puw.cbSize = sizeof(PARSEDURLW);
        if (SUCCEEDED(ParseURLW(pwszURL, &puw)))
        {
            OLECHAR *pwchBookMark;
            DWORD   dwSize;
            INTERNET_CACHE_ENTRY_INFOW      ceiT;
            LPINTERNET_CACHE_ENTRY_INFOW    pcei = NULL;

            // Temporarily, null out the '#' in the url
            pwchBookMark = StrRChrW(puw.pszSuffix, NULL,'#');
            if (pwchBookMark)
            {
                *pwchBookMark = 0;
            }

            dwSize = sizeof(INTERNET_CACHE_ENTRY_INFO);
            if ( !GetUrlCacheEntryInfoW( pwszURL, &ceiT, &dwSize ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                 (pcei = (LPINTERNET_CACHE_ENTRY_INFOW)new BYTE[dwSize]) != NULL &&
                 GetUrlCacheEntryInfoW( pwszURL, pcei, &dwSize ) )
            {
                StrCpyN(pszFile, PathFindFileName(pcei->lpszLocalFileName), cchFile);
                PathUndecorate(pszFile);
            }

            if(pcei)
                delete[] pcei;

            if (pwchBookMark)
                *pwchBookMark = '#';

            if ( !pszFile[0] )
            {
                OLECHAR *pwchQuery;
                TCHAR   szFileT[MAX_PATH];

                // Temporarily, null out the '?' in the url
                pwchQuery = StrRChrW(puw.pszSuffix, NULL,'?');
                if (pwchQuery)
                {
                    *pwchQuery = 0;
                }

                // IE5 bug 15055 - http://my.excite.com/?uid=B56E4E2D34DF3FED.save_uid
                // fails to save because we were passing "my.excite.com/" as the file
                // name to the file dialog. It doesn't like this.
                if (!pwchQuery || (pwchQuery[-1] != '/' && pwchQuery[-1] != '\\'))
                {
                    dwSize = ARRAYSIZE(szFileT);

                    StrCpyN(szFileT, PathFindFileName(puw.pszSuffix), dwSize);

                    if ( !InternetCanonicalizeUrl( szFileT, pszFile, &dwSize, ICU_DECODE | ICU_NO_ENCODE) )
                        StrCpyN(pszFile, szFileT, cchFile);

                    pszFile[cchFile - 1] = 0;
                }

                if (pwchQuery)
                    *pwchQuery = '?';
            }
        }
    }

    if (!pszFile[0])
    {
        MLLoadString(IDS_UNTITLED, pszFile, cchFile);
    }

    return hr;
}

INT_PTR CALLBACK SaveAsWarningDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
                                      LPARAM lParam)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    int         iFlags = 0;
    INT_PTR     bChecked = 0;

    switch (msg)
    {
        case WM_INITDIALOG:
            MessageBeep(MB_ICONEXCLAMATION);
            fRet = TRUE;

        case WM_COMMAND:
            bChecked = SendDlgItemMessage(hDlg, IDC_SAVEAS_WARNING_CB,
                                                  BM_GETCHECK, 0, 0 );
            iFlags = (bChecked) ? (SAVEAS_NEVER_ASK_AGAIN) : (0);

            switch (LOWORD(wParam))
            {
                case IDYES:
                    iFlags |= SAVEAS_OK;
                    // fall through

                case IDNO:
                    EndDialog(hDlg, iFlags);
                    fRet = TRUE;
                    break;
            }
    
        default:
            fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\track.h ===
#ifndef TRACK_INC_
#define TRACK_INC_

#include "urltrack.h"

typedef struct _LRecord
{
    struct _LRecord    *pNext;
    LPTSTR              pthisUrl;         // URL name of this document
    DWORD               Context;         // browsing from
    BOOL                fuseCache;
    FILETIME            ftIn;
}LRecord;

class   CUrlTrackingStg : public IUrlTrackingStg
{
public:
     CUrlTrackingStg ();
    ~CUrlTrackingStg (void);

    // IUnknown methods
    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IUrlTrackingStg methods
    STDMETHODIMP     OnLoad(LPCTSTR lpUrl, BRMODE ContextMode, BOOL fUseCache);
    STDMETHODIMP     OnUnload(LPCTSTR lpUrl);

protected:
    LPINTERNET_CACHE_ENTRY_INFO          QueryCacheEntry (LPCTSTR lpUrl);

    HANDLE           OpenLogFile (LPCTSTR lpFileName);
    HRESULT          UpdateLogFile(LRecord* pNode, SYSTEMTIME* pst);

    LRecord*         AddNode();
    void             DeleteFirstNode();
    void             DeleteCurrentNode(LRecord *pThis);
    LRecord*         FindCurrentNode(LPCTSTR lpUrl);

    void             ReadTrackingPrefix();
    BOOL             ConvertToPrefixedURL(LPCTSTR lpszUrl, LPTSTR *lplpPrefixedUrl);

    HRESULT          WininetWorkAround(LPCTSTR lpszUrl, LPCTSTR lpOldFile, LPTSTR lpFile);
    void             DetermineAppModule();

private:
    DWORD   _cRef;
            
    HANDLE           _hFile;                // handle to log file
    LRecord         *_pRecords;             // link list of tracked items
    LPTSTR           _lpPfx;    

    BOOL             _fModule:1;
    BOOL             _fScreenSaver:1;
};


#endif // TRACK_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urlhook.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: urlhook.cpp
//
// History:
//         9-24-96  by dli
//------------------------------------------------------------------------

#include "priv.h"
#include "sccls.h"
#include "resource.h"

#include <mluisupp.h>

// CURRENT_USER
static const TCHAR c_szSearchUrl[]     = TSZIEPATH TEXT("\\SearchUrl");


#define TF_URLSEARCHHOOK 0

// structure for the character replacement in URL searches
typedef struct _SUrlCharReplace {
    TCHAR from;
    TCHAR to[10];
} SUrlCharReplace;


class CURLSearchHook : public IURLSearchHook2
{
public:
    CURLSearchHook();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IURLSearchHook
    virtual STDMETHODIMP Translate(LPWSTR lpwszSearchURL, DWORD cchBufferSize);

    // *** IURLSearchHook2
    virtual STDMETHODIMP TranslateWithSearchContext(LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSearchContext);
        
protected:
    // IUnknown 
    UINT _cRef;

    HRESULT _IsKeyWordSearch(LPCTSTR pcszURL);
    HRESULT _IsURLSearchable(LPTSTR pszURL, HKEY * phkeySearch, LPCTSTR * pcszQuery);
    HRESULT _ReplaceChars(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszReplaced, int cchReplaced);
    HRESULT _Search(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszTranslatedURL, DWORD cchTranslatedUrl, PTSTR pszSearchUrl, ISearchContext * pSC); 
    void    _ConvertToUtf8(LPWSTR pszQuery, int cch);

}; 


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::QI(%s) is AddRefing _cRef=%lX", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif


CURLSearchHook::CURLSearchHook()
    : _cRef(1)
{
    DllAddRef();
}

HRESULT CURLSearchHook::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);
    
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IURLSearchHook) ||
        IsEqualIID(riid, IID_IURLSearchHook2))
    {
        *ppvObj = SAFECAST(this, IURLSearchHook2 *);
        TraceMsg(TF_URLSEARCHHOOK, "QI IURLSEARCHHOOK succeeded");
    } 
    else
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
     
    
    _AddRef(TEXT("IURLSearchHook"));
    return S_OK;
}


ULONG CURLSearchHook::AddRef()
{
    _cRef++;
    TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::AddRef called, new _cRef=%lX", this, _cRef);
    return _cRef;
}

ULONG CURLSearchHook::Release()
{
    _cRef--;
    TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::Release called, new _cRef=%lX", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    DllRelease();
    return 0;
}

HRESULT CURLSearchHook::_IsKeyWordSearch(LPCTSTR pcszURL)
{
    TCHAR szAcceptedRequestKey[256];
    
    LPTSTR lpsz = szAcceptedRequestKey;
    LPTSTR lpszKey = szAcceptedRequestKey;
   
    // load the accepted request keywords and compare them with what the user typed in
    MLLoadString(IDS_URL_SEARCH_KEY, szAcceptedRequestKey, ARRAYSIZE(szAcceptedRequestKey)-1);
    
    int RequestKeyLen = 0;
    while (*lpsz) {
        if (*lpsz == TEXT(' ')){ 
            if (! StrCmpNI(pcszURL, lpszKey, RequestKeyLen+1))      
                return S_OK;        
            else {
                lpsz++;
                lpszKey = lpsz;
                RequestKeyLen = 0;
            }
        }
        else {      
            lpsz++;
            RequestKeyLen++;
        }
    }
    
    return S_FALSE;
}   


// This function determines if we will do an autosearch on the string user typed in 
//
// Priorities:
// 1  ---  Key word search: search with "go", "find" and so on
// 2  ---  possible URL address: contains '.', ':', '/' and '\\', so don't search 
// 3  ---  Space triggered search.
// 4  ---  Don't search. 
HRESULT CURLSearchHook::_IsURLSearchable(LPTSTR pszURL, HKEY * phkeySearch, LPCTSTR * ppcszQuery)
{
    BOOL fExtendedChar = FALSE;
    TCHAR szRegSearchKey[MAX_PATH];
    LPTSTR pszKey = StrChr(pszURL, TEXT(' '));
    if (pszKey == NULL)
    {
        // No keyword, but if any of the characters are non-ascii, we will default
        // to search because it's likely not a url
        fExtendedChar = HasExtendedChar(pszURL);
        if (!fExtendedChar)
            return S_FALSE;

        pszKey = pszURL;
    }
    
    StrCpyN(szRegSearchKey, c_szSearchUrl, ARRAYSIZE(szRegSearchKey));
    
    if ((_IsKeyWordSearch(pszURL) == S_FALSE) && !fExtendedChar)        
    {
        // Find the end of the default Registry Subkey and 
        // append the keyword so the regkey becomes:
        // Software\Microsoft\Internet Explorer\SearchUrl\go
        ASSERT((ARRAYSIZE(c_szSearchUrl) + 1) < ARRAYSIZE(szRegSearchKey));
        PTSTR pszEnd = &szRegSearchKey[ARRAYSIZE(c_szSearchUrl) - 1];
        *pszEnd++ = TEXT('\\');
        const int cchBuf = ARRAYSIZE(szRegSearchKey) - (ARRAYSIZE(c_szSearchUrl) + 1);
        const int cchToCopy = (int) (pszKey - pszURL + 1);
        StrCpyN(pszEnd, pszURL, min(cchBuf, cchToCopy));

        // See if this is a search keyword in the registry
        if (OpenRegUSKey(szRegSearchKey, 0, KEY_READ, phkeySearch) == ERROR_SUCCESS)
        {  
            PathRemoveBlanks(pszKey);
            *ppcszQuery = pszKey;
            return S_OK;
        }

        // No keyword so use entire "url" for the search
        pszKey = pszURL;

        if (StrCSpn(pszURL, TEXT(":/\\")) != lstrlen(pszURL))
        {
            return S_FALSE;
        }
    }
    
    // Null out the key to signal that we should use the internal hard-coded search string
    *phkeySearch = NULL;
    PathRemoveBlanks(pszKey);
    *ppcszQuery = pszKey;
    return S_OK;
}

HRESULT CURLSearchHook::_ReplaceChars(HKEY hkeySearch, LPCTSTR pcszQuery, LPTSTR pszReplaced, int cchReplaced)
{
    // The following are strings and its lengthes passed in RegEnumValue
    TCHAR szOrig[2];
    DWORD dwOrigLen;
    
    TCHAR szMatch[10];
    DWORD dwMatchLen;
    
    HDSA  hdsaReplace = NULL;
    
    // If we are using our hard-coded search url, we get the char replacements from the string table
    if (NULL == hkeySearch)
    {
        WCHAR szSub[MAX_PATH];
        if (MLLoadString(IDS_SEARCH_SUBSTITUTIONS, szSub, ARRAYSIZE(szSub)) && *szSub != NULL)
        {
            // The first char is our deliminator followed by replacement pairs (", ,+,#,%23,&,%26,?,%3F,+,%2B,=,%3d")
            WCHAR chDelim = szSub[0];
            LPWSTR pszFrom = &szSub[1];
            BOOL fDone = FALSE;
            LPWSTR pszNext;
            do
            {
                // Null terminater our source string
                LPWSTR pszTo = StrChr(pszFrom, chDelim);
                if (NULL == pszTo)
                {
                    break;
                }
                *pszTo = L'\0';

                // Null terminate the dest string
                ++pszTo;
                LPWSTR pszToEnd = StrChr(pszTo, chDelim);
                if (pszToEnd)
                {
                    *pszToEnd = L'\0';
                    pszNext = pszToEnd + 1;
                }
                else
                {
                    pszNext = NULL;
                }
        
                // If the "from" string is one char and the "to" substitution fits, store this pair
                SUrlCharReplace scr;
                if (pszFrom[1] == L'\0' && lstrlen(pszTo) < ARRAYSIZE(scr.to))
                {
                    scr.from = pszFrom[0];
                    StrCpyN(scr.to, pszTo, ARRAYSIZE(scr.to));
        
                    if (!hdsaReplace)
                        hdsaReplace = DSA_Create(SIZEOF(SUrlCharReplace), 4); 
                    if (hdsaReplace)
                        DSA_AppendItem(hdsaReplace, &scr);
                }

                pszFrom = pszNext;
            } 
            while (pszNext != NULL);
        }
    }

    // The search url is in the registry, so get the char substitutions from there
    else
    {
        DWORD dwType;
        LONG lRegEnumResult;
        DWORD dwiValue = 0; 
        do
        {
            dwOrigLen = ARRAYSIZE(szOrig);
            dwMatchLen = SIZEOF(szMatch);
            lRegEnumResult = RegEnumValue(hkeySearch, dwiValue, szOrig,
                                          &dwOrigLen, NULL, &dwType, (PBYTE)szMatch,
                                          &dwMatchLen);
            dwiValue++;         
            SUrlCharReplace         scr;
            
            if ((lRegEnumResult == ERROR_SUCCESS) && (dwType == REG_SZ) && (dwOrigLen == 1) 
                && dwMatchLen < ARRAYSIZE(scr.to))
            {
                scr.from = szOrig[0];
                StrCpyN(scr.to, szMatch, ARRAYSIZE(scr.to));
            
                if (!hdsaReplace)
                    hdsaReplace = DSA_Create(SIZEOF(SUrlCharReplace), 4); 
                if (hdsaReplace)
                    DSA_AppendItem(hdsaReplace, &scr);
            }       
        } while ((lRegEnumResult == ERROR_SUCCESS) || (lRegEnumResult == ERROR_MORE_DATA));
    }
            
            
    if (hdsaReplace)
    {
        // Replace all characters found in the registry by their matches in the search key word
        LPTSTR lpHead = pszReplaced;
        int cchHead = cchReplaced;
        int ich;
        int ihdsa;
        BOOL bCharFound;
        int querylen = lstrlen(pcszQuery);
        for (ich = 0; ich < querylen && cchHead > 1; ich++)
        {
            bCharFound = FALSE;
            // First look through the DSA array to find a match
            for (ihdsa = 0; ihdsa < DSA_GetItemCount(hdsaReplace); ihdsa++)
            {
                SUrlCharReplace *pscr;
                pscr = (SUrlCharReplace *)DSA_GetItemPtr(hdsaReplace, ihdsa);
                if (pscr && pscr->from == pcszQuery[ich])
                {
                    int szLen = lstrlen(pscr->to);
                    StrCpyN(lpHead, pscr->to, cchHead);    
                    lpHead += szLen;
                    cchHead -= szLen;
                    bCharFound = TRUE;
                    break;
                }
            }
            
            // Copy the character over if there is no replacements
            if (!bCharFound)
            {
                *lpHead = pcszQuery[ich];
                lpHead++;
                cchHead--;
            }
        }       

        if (cchHead > 0)
            *lpHead = 0;
        
        DSA_Destroy(hdsaReplace);
        hdsaReplace = NULL;
    }
    
    return S_OK;
    
}       

void  CURLSearchHook::_ConvertToUtf8(LPWSTR pszQuery, int cch)
{
    // Only need to covert if extended characters found
    if (HasExtendedChar(pszQuery))
    {
        ConvertToUtf8Escaped(pszQuery, cch);
    }
}

// pszTranslatedUrl is the output of this function
HRESULT CURLSearchHook::_Search(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszTranslatedUrl, DWORD cchTranslatedUrl, PTSTR pszSearchUrl, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;

    // Get the search provider from the registry 
    DWORD dwType;
    WCHAR szProvider[MAX_PATH];
    szProvider[0] = 0;
    DWORD cbProvider = sizeof(szProvider);
    if (SHRegGetUSValue(c_szSearchUrl, L"Provider", &dwType, &szProvider, &cbProvider, FALSE, NULL, 0) != ERROR_SUCCESS ||
        dwType != REG_SZ)
    {
        szProvider[0] = 0;
    }

    TCHAR szSearchPath[MAX_URL_STRING];
    DWORD dwSearchPathLen = SIZEOF(szSearchPath);        
    BOOL  fSuccess;

    if (pszSearchUrl != NULL)
    {
        StrCpyNW(szSearchPath, pszSearchUrl, ARRAYSIZE(szSearchPath));
        fSuccess = TRUE;
    }
    else
    {
        // Find the search URL in the registry or our string table
        if (hkeySearch)
        {
            fSuccess = (RegQueryValueEx(hkeySearch, NULL, NULL, NULL, (PBYTE)szSearchPath, &dwSearchPathLen) == ERROR_SUCCESS);
        }
        else
        {

            // See if we want the hardcoded intranet or internet url
            UINT ids = (StrCmpI(szProvider, L"Intranet") == 0) ? IDS_SEARCH_INTRANETURL : IDS_SEARCH_URL;

            // Use our internal hard-coded string
            fSuccess = MLLoadString(ids, szSearchPath, ARRAYSIZE(szSearchPath));
        }
    }

    if (fSuccess && lstrlen(szSearchPath) > 1)
    {
        // 1. Look in the registry and find all of the original characters and it's
        // matches and store them in the DSA arrays of SURlCharReplace
        // 2. Replace all of the occurences of the original characters in the 
        // URL search key word by their matches.
        // 3. Append the search URL and the search key words
        
        TCHAR szURLReplaced[MAX_URL_STRING];
        
        StrCpyN(szURLReplaced, pcszQuery, ARRAYSIZE(szURLReplaced));
        _ReplaceChars(hkeySearch, pcszQuery, szURLReplaced, ARRAYSIZE(szURLReplaced));

        //
        // If we are using our search engine, convert the string to UTF8 and escape it
        // so that it appears like normal ascii
        //
        if (NULL == hkeySearch)
        {
            _ConvertToUtf8(szURLReplaced, ARRAYSIZE(szURLReplaced));
        }

        // If this is an old-style url, there will be a %s in it for the search string.
        // Otherwise there will be the following parameters:
        //
        // http://whatever.com?p=%1&srch=%2&prov=%3&utf8
        //
        //  %1 = search string
        //  %2 = how to display results:
        //        "1" = just show me results in full window
        //        "2" = show results in full window, but redirect if possible
        //        "3" = show results in the search pane, and take me to the most
        //              likely site in the main window if there is one
        //  %3 = search provider name
        //
        LPWSTR pszParam1 = StrStr(szSearchPath, L"%1");
        if (NULL != pszParam1)
        {
            //
            // We can't use FormatMessage because on win95 it converts to ansi
            // using the system code page and the translation back is lossy.
            // So we'll replace the parameters ourselves. Arrrggg.
            //

            // First convert %1 to %s
            pszParam1[1] = L's';

            // Next replace %2 with the display option in %2 
            LPWSTR pszParam2 = StrStr(szSearchPath, L"%2");
            if (NULL != pszParam2)
            {
                DWORD dwValue;
                    
                if (pSC != NULL)
                {
                    hr = pSC->GetSearchStyle(&dwValue);
                }
                else
                {
                    DWORD cbValue = sizeof(dwValue);
                    if (SHRegGetUSValue(REGSTR_PATH_MAIN, L"AutoSearch", &dwType, &dwValue, &cbValue, FALSE, NULL, 0) != ERROR_SUCCESS ||
                        dwValue > 9)
                    {
                        // Default to "display results in search pane and go to most likely site"
                        dwValue = 3;
                    }
                }

                *pszParam2 = (WCHAR)dwValue + L'0';
                StrCpyN(pszParam2 + 1, pszParam2 + 2, (int)(ARRAYSIZE(szSearchPath) - ((pszParam2 + 1) - szSearchPath)));
            }

            // Finally, find the third Param and convert it to %s too
            LPWSTR pszParam3 = StrStr(szSearchPath, L"%3");
            if (pszParam3)
            {
                // Insert the provider in the third param
                WCHAR szTemp[MAX_URL_STRING];
                StrCpyN(szTemp, pszParam3 + 2, ARRAYSIZE(szTemp));
                *pszParam3 = 0;
                StrCatBuff(szSearchPath, szProvider, ARRAYSIZE(szSearchPath));
                StrCatBuff(szSearchPath, szTemp, ARRAYSIZE(szSearchPath));
            }
        }

        // Now replace the %s with the search string
        wnsprintf(pszTranslatedUrl, cchTranslatedUrl, szSearchPath, szURLReplaced);
        hr = S_OK;
    }

    if (hkeySearch)
        RegCloseKey(hkeySearch);
    return hr;
}

HRESULT CURLSearchHook::TranslateWithSearchContext(LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    TCHAR szSearchURL[MAX_URL_STRING];

    SHUnicodeToTChar(lpwszSearchURL, szSearchURL, ARRAYSIZE(szSearchURL));
    
    HKEY hkeySearch;
    LPCTSTR pcszQuery;
    if (_IsURLSearchable(szSearchURL, &hkeySearch, &pcszQuery) == S_OK)
    {
        BSTR bstrSearchUrl = NULL;

        if (pSC != NULL)
        {
            pSC->GetSearchUrl(&bstrSearchUrl);
        }

        hr = _Search(hkeySearch, pcszQuery, szSearchURL, ARRAYSIZE(szSearchURL), bstrSearchUrl, pSC);
        if (hr == S_OK)
            SHTCharToUnicode(szSearchURL, lpwszSearchURL, cchBufferSize); 

        if (bstrSearchUrl != NULL)
        {
            SysFreeString(bstrSearchUrl);
        }
    }
    
    return hr;
}

HRESULT CURLSearchHook::Translate(LPWSTR lpwszSearchURL, DWORD cchBufferSize)
{
    return TranslateWithSearchContext(lpwszSearchURL, cchBufferSize, NULL);
}


#ifdef DEBUG
extern void remove_from_memlist(void *pv);
#endif

STDAPI CURLSearchHook_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;

    CURLSearchHook *pcush = new CURLSearchHook;

    if (pcush)
    {
        //
        // HACK:(dli)
        //
        //   IURLSearchHook objects are free-threaded objects, meaning that
        // they are cacheed and shared between different IEXPLORE processes, 
        // and they are only deleted when the SHDOCVW DLL ref count is 0. 
        // So, we can remove them from the SATOSHI's memlist.
        //
        // By the way, SATOSHI has Okayed this. Don't copy this code without
        // talking to SATOSHI.
        //
        *ppunk = (IUnknown *) pcush;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urlhist.cpp ===
//
// Copyright (c) 1996  Microsoft Corporation
//
// Module Name: Url History Interfaces
//
// Author:
//    Zeke Lucas (zekel)  10-April-96
//

// !!! Take NOTE: CUrlHistory *MUST* be thread safe! DANGER, WILL ROBINSON, DANGER!

#include "priv.h"
#include "sccls.h"
#include "ishcut.h"
#include <inetreg.h>
#include <varutil.h>
#include "iface.h"
#include "util.h"
#include "strsafe.h"

#define DM_UHRETRIEVE   0
#define DM_URLCLEANUP   0
#define DM_HISTGENERATE 0
#define DM_HISTPROP     0
#define DM_HISTEXTRA    0
#define DM_HISTCOMMIT   0
#define DM_HISTSPLAT    0
#define DM_HISTMISS     0
#define DM_HISTNLS      0

#define DW_FOREVERLOW (0xFFFFFFFF)
#define DW_FOREVERHIGH (0x7FFFFFFF)

#ifdef UNICODE
    #define VT_LPTSTR    VT_LPWSTR
#else
    #define VT_LPTSTR    VT_LPSTR
#endif

inline UINT DW_ALIGNED(UINT i) {
    return ((i+3) & 0xfffffffc);
}

inline BOOL IS_DW_ALIGNED(UINT i) {
    return ((i & 3)==0);
}

// Old one (beta-2)
typedef struct _HISTDATAOLD
{
    WORD cbSize;
    DWORD dwFlags;
    WORD wTitleOffset;
    WORD aFragsOffset;
    WORD cFrags;            //right now the top five bits are used for Prop_MshtmlMCS
    WORD wPropNameOffset;    
    WORD wMCSIndex;
} HISTDATAOLD, *LPHISTDATAOLD;

// Forward reference
typedef struct HISTEXTRA* LPHISTEXTRA;

// Version 0.01
//
// PID_INTSITE_WHATSNEW         stored as a HISTEXTRA
// PID_INTSITE_AUTHOR           stored as a HISTEXTRA
// PID_INTSITE_LASTVISIT        from lpCEI->LastAccessTime
// PID_INTSITE_LASTMOD          from lpCEI->LastModifiedTime
// PID_INTSITE_VISITCOUNT       dwVisits
// PID_INTSITE_DESCRIPTION      stored as a HISTEXTRA
// PID_INTSITE_COMMENT          stored as a HISTEXTRA
// PID_INTSITE_FLAGS            dwFlags
// PID_INTSITE_CONTENTLEN       (never used)
// PID_INTSITE_CONTENTCODE      (never used)
// PID_INTSITE_RECURSE          (never used)
// PID_INTSITE_WATCH            dwWatch
// PID_INTSITE_SUBSCRIPTION     stored as a HISTEXTRA
// PID_INTSITE_URL              URL itself
// PID_INTSITE_TITLE            Title
// PID_INTSITE_FRAGMENT         Visited Fragment (private)
//

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// HACKHACK:  If you change this data structure, you must talk
//            to Adrian Canter (adrianc) -- we put a copy of it
//            in wininet\urlcache\401imprt.cxx to make importing
//            from old-style cache happen quick n' dirty
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
struct _HISTDATA_V001
{
    UINT  cbSize : 16;           // size of this header
    UINT  cbVer  : 16;           // version
    DWORD           dwFlags;    // PID_INTSITE_FLAGS (PIDISF_ flags)
    DWORD           dwWatch;    // PID_INTSITE_WATCH (PIDISM_ flags)
    DWORD           dwVisits;   // PID_INTSITE_VISITCOUNT
};

#define HISTDATA_VER    2

class CHistoryData : public _HISTDATA_V001
{
public:
    LPHISTEXTRA _GetExtra(void)  const {
        ASSERT( this->cbSize == sizeof(_HISTDATA_V001) );
        ASSERT( this->cbVer == HISTDATA_VER );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbSize);
    }

    const HISTEXTRA * _FindExtra(UINT idExtra) const;
    HISTEXTRA * _FindExtraForSave(UINT idExtra) {
        return (HISTEXTRA*)_FindExtra(idExtra);
    }
    void _GetTitle(LPTSTR szTitle, UINT cchMax) const;
    BOOL _HasFragment(LPCTSTR pszFragment) const;
    BOOL _IsOldHistory(void) const {
        return (cbSize==SIZEOF(HISTDATAOLD) && cbVer==0);
    };

    static CHistoryData* s_GetHistoryData(LPINTERNET_CACHE_ENTRY_INFO lpCEI);
    static CHistoryData* s_AllocateHeaderInfo(UINT cbExtra, const CHistoryData* phdPrev, ULONG* pcbTotal);

    HISTEXTRA* CopyExtra(HISTEXTRA* phextCur) const;
    UINT GetTotalExtraSize() const;
};


//
//  Right after HISTDATA (always at cbSize), we have optional (typically
// variable length) data which has following data structure. It may have
// more than one but always has a null-terimiator (cbExtra == 0).
//
struct HISTEXTRA
{
    UINT cbExtra : 16;
    UINT idExtra : 8;   // PID_INTSITE_*
    UINT vtExtra : 8;   // VT_*
    BYTE abExtra[1];    // abExtra[cbExtra-4];

    BOOL IsTerminator(void) const {
        return (this->cbExtra==0);
    }

    const HISTEXTRA* GetNextFast(void) const {
        ASSERT( ! IsTerminator() );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
    }

    HISTEXTRA* GetNextFastForSave(void) const {
        ASSERT( ! IsTerminator() );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
    }

    const HISTEXTRA* GetNext(void) const {
        if (this->cbExtra) {
            return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
        }
        return NULL;
    }
};


// We want to make sure that our history binary data is valid so
// we don't crash or something
BOOL ValidateHistoryData(LPINTERNET_CACHE_ENTRY_INFOA pcei)
{
    DWORD cb = 0;

    if (!pcei->lpHeaderInfo)
    {
        ASSERT(pcei->dwHeaderInfoSize==0);
        pcei->dwHeaderInfoSize = 0;
        return TRUE;
    }
    
    // First, let's check HISTDATA
    CHistoryData* phd = (CHistoryData*)pcei->lpHeaderInfo;
    if ((phd->cbSize!=sizeof(_HISTDATA_V001))
        ||
        (phd->cbSize > pcei->dwHeaderInfoSize))
    {
        pcei->dwHeaderInfoSize = 0;
        pcei->lpHeaderInfo = NULL;
        return FALSE;
    }

    cb += phd->cbSize;
    
    // Now, let's check HISTEXTRA
    LPHISTEXTRA phe = phd->_GetExtra();
    while (phe && !phe->IsTerminator())
    {
        cb += phe->cbExtra;
        if (cb >= pcei->dwHeaderInfoSize)
        {
            // Hmm. We're expecting more data than we got. Not good. Prune the rest off.
            // We're adding 1 for the terminator
            pcei->dwHeaderInfoSize = cb - phe->cbExtra + 4;
            phe->cbExtra = 0;
            return FALSE;
        }
        phe = phe->GetNextFastForSave();
    }

    // Add a DWORD for the terminator
    cb += sizeof(DWORD);
    // ASSERT(pcei->dwHeaderInfoSize==cb);
    return TRUE;    
}

//
//  Typically, we need 200-300 bytes to retrieve a cached entry in this
// history database. To avoid allocating memory in 99% of cases, we
// allocate 500 bytes in the stack and call LocalAlloc only if we need
// more than that. 
//
#define DEFAULT_CEI_BUFFER_SIZE         (500 * sizeof(WCHAR))

const TCHAR c_szHistoryPrefix[] = TEXT("Visited: ");

struct CEI_PREALLOC {
    LPINTERNET_CACHE_ENTRY_INFO pcei;

    LPCTSTR pszFragment;
    TCHAR szPrefixedUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    union {
        INTERNET_CACHE_ENTRY_INFO cei;
        BYTE ab[DEFAULT_CEI_BUFFER_SIZE];
    };

    CEI_PREALLOC() : pcei(NULL), pszFragment(NULL) {}
    ~CEI_PREALLOC() {
        if (pcei && pcei != &cei) {
            TraceMsg(DM_TRACE, "CEI_PREALLOC::dtr freeing pcei");
            LocalFree(pcei);
            pcei = NULL;
        }
    }
};

#define VER_HISTDATA    1

typedef CHistoryData HISTDATA;

typedef HISTDATA* LPHISTDATA;

//  CUrlHistory manages the other interfaces and handles alot of the basic functions
class   CUrlHistory : public IUrlHistoryPriv
{
public:
    CUrlHistory (void);
    ~CUrlHistory(void);

    // IUnknown methods

    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IUrlHistoryStg methods
    STDMETHODIMP AddUrl(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags);
    STDMETHODIMP DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags);
    STDMETHODIMP QueryUrl(LPCWSTR pwszUrl, DWORD dwFlags, LPSTATURL lpSTATURL);
    STDMETHODIMP BindToObject(LPCWSTR pwszUrl, REFIID riid, void **ppvOut);
    STDMETHODIMP EnumUrls(IEnumSTATURL **ppEnum);

    // IUrlHistoryStg2 methods
    STDMETHODIMP AddUrlAndNotify(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory);
    STDMETHODIMP ClearHistory();

    // IUrlHistoryPriv methods
    STDMETHOD(QueryUrlA)(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL);
    STDMETHOD(CleanupHistory)(void);
    STDMETHOD_(DWORD,GetDaysToKeep)(void) { return s_GetDaysToKeep(); }
    STDMETHOD(GetProperty)(LPCTSTR pszUrl, PROPID pid, PROPVARIANT* pvarOut);
    STDMETHOD(GetUserName)(LPTSTR pszUserName, DWORD cchUserName);
    STDMETHOD(AddUrlAndNotifyCP)(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory, UINT* pcodepage);

   
    static void  s_Init();
    static DWORD   s_GetDaysToKeep(void);

protected:

    void _WriteToHistory(LPCTSTR pszPrefixedurl,
                         FILETIME& ftExpires,
                         IOleCommandTarget *poctNotify,
                         IUnknown *punkSFHistory);

    friend class CEnumSTATURL;
    // friend class CUrlHObj;
    friend class IntsiteProp;

    static HRESULT s_CleanupHistory(void);
    static HRESULT s_EnumUrls(IEnumSTATURL **ppEnum);
    static HRESULT s_DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags);
    
    static void s_ConvertToPrefixedUrlW(  
                                IN LPCWSTR pwszUrl,
                                OUT LPTSTR pszPrefixedUrl,
                                IN DWORD cchPrefixedUrl, 
                                OUT LPCTSTR *ppszFragment
                              );

    static HRESULT s_QueryUrlCommon(
                          LPCTSTR lpszPrefixedUrl,
                          LPCTSTR lpszFragment,
                          DWORD dwFlags,
                          LPSTATURL lpSTATURL
                          );

    static void s_RetrievePrefixedUrlInfo(
                LPCTSTR lpszUrl, CEI_PREALLOC* pbuf);
    static BOOL s_CommitUrlCacheEntry(LPCTSTR pszPrefixedUrl, 
                        LPINTERNET_CACHE_ENTRY_INFO pcei);

    static BOOL s_IsCached(IN LPCTSTR pszUrl)
        { return ::GetUrlCacheEntryInfoEx(pszUrl, NULL, NULL, NULL, NULL, NULL, INTERNET_CACHE_FLAG_ALLOW_COLLISIONS); }

    static HISTDATA* s_GenerateHeaderInfo(
            IN LPCTSTR pszTitle, 
            IN HISTDATA* phdPrev,
            IN LPCTSTR pszFragment,
            OUT LPDWORD pcbHeader
            );

    static HRESULT s_GenerateSTATURL(IN PCTSTR pszUrl, IN LPINTERNET_CACHE_ENTRY_INFO lpCEI, IN DWORD dwFlags, OUT LPSTATURL lpsu);
    static void s_UpdateIcon(Intshcut* pintshcut, DWORD dwFlags);

    DWORD   _cRef;
    static TCHAR   s_szUserPrefix[INTERNET_MAX_USER_NAME_LENGTH + 1];
    static DWORD   s_cchUserPrefix ;
    static DWORD   s_dwDaysToKeep;
    
};


class CEnumSTATURL      : public IEnumSTATURL
{
public:

    CEnumSTATURL() : _cRef(1) {}
    ~CEnumSTATURL();

    // IUnknown methods

    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //  IEnumXXXX methods

    STDMETHODIMP Next (ULONG celt, LPSTATURL rgelt, ULONG * pceltFetched) ;
    STDMETHODIMP Skip(ULONG celt) ;
    STDMETHODIMP Reset(void) ;
    STDMETHODIMP Clone(IEnumSTATURL ** ppenum) ;

    //  IEnumSTATURL methods

    STDMETHODIMP SetFilter(LPCWSTR poszFilter, DWORD dwFlags) ;

private:

    HRESULT RetrieveFirstUrlInfo(void);
    HRESULT RetrieveNextUrlInfo(void);

    DWORD _cRef;

    //  search object parameters
    LPWSTR m_poszFilter;
    DWORD  m_dwFilter;

    HANDLE m_hEnum;
    TCHAR _szPrefixedUrl[MAX_URL_STRING];
    DWORD m_cchPrefixedUrl;
    LPCTSTR m_lpszFragment;
    LPINTERNET_CACHE_ENTRY_INFO m_lpCEI;
    DWORD m_cbCEI;

};


#define FILETIME_SEC                            10000000
#define SECS_PER_DAY                            (60 * 60 * 24)

#define CCHHISTORYPREFIX (ARRAYSIZE(c_szHistoryPrefix) - 1)
#define CLEANUP_HISTORY_INTERVAL (24 * 60 * 60 * 1000) // One day, in milliseconds

DWORD g_tCleanupHistory = 0;


#define OFFSET_TO_LPTSTR(p, o)          ( (LPTSTR) ( (LPBYTE) (p) + (o) ) )
#define OFFSET_TO_LPBYTE(p, o)          ( (LPBYTE) ( (LPBYTE) (p) + (o) ) )
#define OFFSET_TO_LPWORD(p, o)          ( (LPWORD) ( (LPBYTE) (p) + (o) ) )

#define LPTSTR_TO_OFFSET(p, s)          ( (WORD) ( (LPTSTR) (s) - (LPTSTR) (p) ) )
#define LPBYTE_TO_OFFSET(p, b)          ( (WORD) ( (LPBYTE) (b) - (LPBYTE) (p) ) )

// NOTE: REARCHITECT chrisfra 3/26/97 , ext\cachevu\priv.h has a duplicate copy of this
// structure and uses it to access cache.  this needs to be covered by procedural or
// object interface and moved to a common location.

// This structure uses the flags bits as follows: if HFL_VERSIONED is true, then
// the rest of the flags word is the version.

#define HFL_VERSIONED (0x80000000)


//
// We store binary data in the lpHeaderInfo field.  CommitUrlCacheEntryW tries
// to convert this data to ansi and messes it up.  To get around this we thunk
// through to the A version CommitUrlCacheEntry.
//

BOOL
CommitUrlCacheEntryBinary(
    IN LPCWSTR  lpszUrlName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize
)
{
    ASSERT(lpszUrlName);

    CHAR szUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    SHUnicodeToAnsi(lpszUrlName, szUrl, ARRAYSIZE(szUrl));

    INTERNET_CACHE_ENTRY_INFOA cei;
    cei.lpHeaderInfo = (LPSTR)lpHeaderInfo;
    cei.dwHeaderInfoSize = dwHeaderSize;
    ValidateHistoryData(&cei);

    return CommitUrlCacheEntryA(szUrl, NULL, ExpireTime, LastModifiedTime,
                                CacheEntryType, lpHeaderInfo, dwHeaderSize,
                                NULL, NULL);
}

GetUrlCacheEntryInfoBinary(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
{
    ASSERT(lpszUrlName);

    BOOL fRet;

    CHAR szUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    SHUnicodeToAnsi(lpszUrlName, szUrl, ARRAYSIZE(szUrl));

    //
    // Warning!  This doesn't convert any of thge string parameters in
    // lpCacheEntryInfo back to unicode.  History only uses
    // lpCacheEntryInfo->lpHeaderInfo so this isn't a problem.
    //

    fRet =  GetUrlCacheEntryInfoA(szUrl,
                                 (LPINTERNET_CACHE_ENTRY_INFOA)lpCacheEntryInfo,
                                 lpdwCacheEntryInfoBufferSize);

    //
    // Set unused out paramters to NULL incase someone tries to use them
    //

    lpCacheEntryInfo->lpszSourceUrlName = NULL;
    lpCacheEntryInfo->lpszLocalFileName = NULL;
    lpCacheEntryInfo->lpszFileExtension = NULL;

    if (fRet)
    {
        ValidateHistoryData((LPINTERNET_CACHE_ENTRY_INFOA)lpCacheEntryInfo);
    }
    return fRet;
}

//
// Warning!  This function converts cei structures for use by history.  It is
// not a generic conversion.  It converts the minimum data required by history.
//
int
CacheEntryInfoAToCacheEntryInfoW(
    LPINTERNET_CACHE_ENTRY_INFOA pceiA,
    LPINTERNET_CACHE_ENTRY_INFOW pceiW,
    int cbceiW
    )
{
    int nRet;

    ASSERT(pceiA->lpszSourceUrlName);
    int cchSourceUrlName = lstrlenA(pceiA->lpszSourceUrlName) + 1;

    int cbRequired = sizeof(INTERNET_CACHE_ENTRY_INFOA) +
                     pceiA->dwHeaderInfoSize + 
                     cchSourceUrlName * sizeof(WCHAR);

    if (cbRequired <= cbceiW)
    {
        ASSERT(sizeof(*pceiA) == sizeof(*pceiW));

        // Copy the structure.
        *pceiW = *(INTERNET_CACHE_ENTRY_INFOW*)pceiA;

        // Append the binary data.  Note dwHeaderInfoSize is already copied.
        pceiW->lpHeaderInfo = (LPWSTR)(pceiW + 1);
        memcpy(pceiW->lpHeaderInfo, pceiA->lpHeaderInfo, pceiA->dwHeaderInfoSize);

        // Append the source url name.
        pceiW->lpszSourceUrlName = (LPWSTR)((BYTE*)(pceiW + 1) + pceiW->dwHeaderInfoSize);
        SHAnsiToUnicode(pceiA->lpszSourceUrlName, pceiW->lpszSourceUrlName,
                        cchSourceUrlName);

        // Null out bogus pointers so we'll fault if someone deref's them
        pceiW->lpszLocalFileName = NULL;
        pceiW->lpszFileExtension = NULL;

        nRet = 0;
    }
    else
    {
        nRet = cbRequired;
    }

    return nRet;
}

HANDLE
FindFirstUrlCacheEntryBinary(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
{
    ASSERT(NULL != lpszUrlSearchPattern);
    ASSERT(NULL != lpFirstCacheEntryInfo);
    ASSERT(NULL != lpdwFirstCacheEntryInfoBufferSize);

    HANDLE hRet;

    CHAR szPattern[MAX_PATH];

    ASSERT(lstrlenW(lpszUrlSearchPattern) < ARRAYSIZE(szPattern));
    SHUnicodeToAnsi(lpszUrlSearchPattern, szPattern, ARRAYSIZE(szPattern));

    BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFOA* pceiA = (INTERNET_CACHE_ENTRY_INFOA*)ab;
    DWORD dwSize;
    BOOL fAllocated = FALSE;

    pceiA->dwStructSize = dwSize = sizeof(ab);

    hRet = FindFirstUrlCacheEntryA(szPattern, pceiA, &dwSize);

    if (NULL == hRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pceiA = (INTERNET_CACHE_ENTRY_INFOA*)LocalAlloc(LPTR, dwSize);

        if (pceiA)
        {
            fAllocated = TRUE;

            pceiA->dwStructSize = dwSize;

            hRet = FindFirstUrlCacheEntryA(szPattern, pceiA, &dwSize);
            
            ASSERT(hRet || GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }
    
    if (hRet)
    {
        int nRet;

        ValidateHistoryData(pceiA);
        nRet = CacheEntryInfoAToCacheEntryInfoW(pceiA, lpFirstCacheEntryInfo,
                                                *lpdwFirstCacheEntryInfoBufferSize);

        if (nRet)
        {
            FindCloseUrlCache(hRet);
            hRet = NULL;
            *lpdwFirstCacheEntryInfoBufferSize = nRet;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    if (fAllocated)
    {
        LocalFree(pceiA);
        pceiA = NULL;
    }

    return hRet;
}

BOOL
FindNextUrlCacheEntryBinary(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
{
    ASSERT(NULL != hEnumHandle);
    ASSERT(NULL != lpNextCacheEntryInfo);
    ASSERT(NULL != lpdwNextCacheEntryInfoBufferSize);

    BOOL fRet;

    BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFOA* pceiA = (INTERNET_CACHE_ENTRY_INFOA*)ab;
    DWORD dwSize;
    BOOL fAllocated = FALSE;

    pceiA->dwStructSize = dwSize = sizeof(ab);

    fRet = FindNextUrlCacheEntryA(hEnumHandle, pceiA, &dwSize);
    
    if (!fRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pceiA = (INTERNET_CACHE_ENTRY_INFOA*)LocalAlloc(LPTR, dwSize);

        if (pceiA)
        {
            fAllocated = TRUE;

            pceiA->dwStructSize = dwSize;

            fRet = FindNextUrlCacheEntryA(hEnumHandle, pceiA, &dwSize);
            
            ASSERT(fRet || GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    if (fRet)
    {
        int nRet;

        ValidateHistoryData(pceiA);
        nRet = CacheEntryInfoAToCacheEntryInfoW(pceiA, lpNextCacheEntryInfo,
                                                *lpdwNextCacheEntryInfoBufferSize);

        if (nRet)
        {
            fRet = FALSE;
            *lpdwNextCacheEntryInfoBufferSize = nRet;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    if (fAllocated)
    {
        LocalFree(pceiA);
        pceiA = NULL;
    }
  
    return fRet;
}

#define DEFAULT_DAYS_TO_KEEP    21
static const TCHAR c_szRegValDaysToKeep[] = TEXT("DaysToKeep");
static const TCHAR c_szRegValDirectory[] = TEXT("Directory");

#define DIR_SEPARATOR_CHAR  TEXT('\\')


// ** this has been moved to util.cpp 07.28.2000 **
// thunk to shell32.SHGetFolderPath() so this code works downlevel
// HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
// ** this has been moved to util.cpp 07.28.2000 **

HRESULT SHGetHistoryPIDL(LPITEMIDLIST *ppidlHistory)
{
    *ppidlHistory = NULL;

    TCHAR szHistory[MAX_PATH];

    szHistory[0] = 0;

    HRESULT hres = SHGetFolderPathD(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szHistory);
    if (hres != S_OK)
    {
        GetHistoryFolderPath(szHistory, ARRAYSIZE(szHistory));
        PathRemoveFileSpec(szHistory);  // get the trailing slash
        PathRemoveFileSpec(szHistory);  // trim the "content.ie5" junk
    }

    if (szHistory[0])
    {
        TCHAR szIniFile[MAX_PATH];
        PathCombine(szIniFile, szHistory, TEXT("desktop.ini"));

        if (GetFileAttributes(szIniFile) == -1)
        {
            DWORD dwAttrib = GetFileAttributes(szHistory);
            dwAttrib &= ~FILE_ATTRIBUTE_HIDDEN;
            dwAttrib |=  FILE_ATTRIBUTE_SYSTEM;

            // make sure system, but not hidden
            SetFileAttributes(szHistory, dwAttrib);

            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("ConfirmFileOp"), TEXT("0"), szIniFile);
            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), TEXT("{FF393560-C2A7-11CF-BFF4-444553540000}"), szIniFile);
        }

        IShellFolder *psfDesktop;
        hres = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hres)) 
        {
            hres = psfDesktop->ParseDisplayName(NULL, NULL, 
                                    szHistory, NULL, ppidlHistory, NULL); 
            psfDesktop->Release();
        }
    }
    else
        hres = E_FAIL;
    return hres;
}

//
// This function is called from hist/hsfolder.cpp
//
HRESULT CUrlHistory::GetUserName(LPTSTR pszUserName, DWORD cchUserName)
{
    s_Init();
    
    if (cchUserName < s_cchUserPrefix)
    {
        return E_FAIL;
    }
    CopyMemory(pszUserName, s_szUserPrefix, (s_cchUserPrefix-1) * sizeof(TCHAR));
    pszUserName[s_cchUserPrefix-1] = 0;
    return S_OK;
}

//
// This function is called from hist/hsfolder.cpp
//
DWORD CUrlHistory::s_GetDaysToKeep(void)
{
    HKEY hk;
    DWORD cbDays = SIZEOF(DWORD);
    DWORD dwDays = DEFAULT_DAYS_TO_KEEP;
    DWORD dwType;


    DWORD Error = RegOpenKeyEx(
                               HKEY_CURRENT_USER,
                               REGSTR_PATH_URLHISTORY,
                               0,
                               KEY_READ,
                               &hk);


    if(Error)
    {
        Error = RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             REGSTR_PATH_URLHISTORY,
                             0,
                             KEY_READ,
                             &hk);
    }


    if(!Error)
    {
        Error = RegQueryValueEx(
                                hk,
                                c_szRegValDaysToKeep,
                                0,
                                &dwType,
                                (LPBYTE) &dwDays,
                                &cbDays);

        RegCloseKey(hk);
    }

    return dwDays;
}

IUrlHistoryPriv* g_puhUrlHistory = NULL;

void CUrlHistory_CleanUp()
{
    // Release will clean up the global
    ENTERCRITICAL;
    if (g_puhUrlHistory)
        g_puhUrlHistory->Release();
    LEAVECRITICAL;
}

STDAPI CUrlHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppunk = NULL;

    // !!! Take NOTE: CUrlHistory *MUST* be thread safe!

    // aggregation checking is handled in class factory
    ENTERCRITICAL;
    
    if (!g_puhUrlHistory) 
    {
        CUrlHistory *pcuh = new CUrlHistory;
        if (pcuh) 
        {
            g_puhUrlHistory = SAFECAST(pcuh, IUrlHistoryPriv *);
            // The memory tracking code thinks this is a leak
        }
    }

    if (g_puhUrlHistory)
    {
        *ppunk = SAFECAST(g_puhUrlHistory, IUnknown*);
        g_puhUrlHistory->AddRef();
        hr = S_OK;
    }

    LEAVECRITICAL;

    return hr;
}





//
//  Public members of CUrlHistory
//

CUrlHistory::CUrlHistory(void) : _cRef(1)
{
    //
    // Update s_dwDaysToKeep for each call
    //
    s_dwDaysToKeep = s_GetDaysToKeep();
    
#ifdef DEBUG
    if (g_dwPrototype & 0x00000020) {
        s_CleanupHistory();
    }
#endif

    DllAddRef();
}

CUrlHistory::~CUrlHistory(void)
{
    DllRelease();
}

HRESULT LoadHistoryShellFolder(IUnknown *punk, IHistSFPrivate **ppsfpHistory)
{
    HRESULT hr;

    *ppsfpHistory = NULL;
    if (punk)
    {
        hr = punk->QueryInterface(IID_IHistSFPrivate, (void **)ppsfpHistory);
    }
    else
    {
        LPITEMIDLIST pidlHistory;

        hr = SHGetHistoryPIDL(&pidlHistory);
        if (SUCCEEDED(hr))
        {
            hr = SHBindToObject(NULL, IID_IHistSFPrivate, pidlHistory, (void **)ppsfpHistory);
            ILFree(pidlHistory);
        }
    }
    return hr;
}

//  ClearHistory on a per user basis.  moved from inetcpl to facilitate changes in
//  implementation.
HRESULT CUrlHistory::ClearHistory()
{
    HRESULT hr;
    IEnumSTATURL *penum;
    IHistSFPrivate *psfpHistory = NULL;

    hr = THR(EnumUrls(&penum));

    if (SUCCEEDED(hr))
    {
        penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);

        ULONG cFetched;
        STATURL rsu[1] = {{sizeof(STATURL), NULL, NULL}};
        while (SUCCEEDED(penum->Next(1, rsu, &cFetched)) && cFetched)
        {
            ASSERT(rsu[0].pwcsUrl);

            hr = THR(DeleteUrl(rsu[0].pwcsUrl, URLFLAG_DONT_DELETE_SUBSCRIBED));

            OleFree(rsu[0].pwcsUrl);
            rsu[0].pwcsUrl = NULL;

            ASSERT(!rsu[0].pwcsTitle);
        }
        penum->Release();
    }
    hr = LoadHistoryShellFolder(NULL, &psfpHistory);
    if (SUCCEEDED(hr))
    {
        hr = psfpHistory->ClearHistory();
        psfpHistory->Release();
    }
    return hr;
}

extern void _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days);

HRESULT CUrlHistory::s_CleanupHistory(void)
{
    TraceMsg(DM_URLCLEANUP, "CUH::s_CleanupHistory called");

    HRESULT hr;
    DWORD tCurrent = GetTickCount();

    if (!g_tCleanupHistory || (tCurrent > g_tCleanupHistory + CLEANUP_HISTORY_INTERVAL)) {
        g_tCleanupHistory = tCurrent;
    } else {
#ifdef DEBUG
        if (!(g_dwPrototype & 0x00000020))
#endif
        return S_OK;
    }

    SYSTEMTIME st;
    FILETIME ftNow;
    FILETIME ftOldest;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftOldest, -((int)s_GetDaysToKeep()));

    IEnumSTATURL * penum = NULL;
    if (SUCCEEDED(s_EnumUrls(&penum)))
    {
        STATURL rsu[1] = {{sizeof(STATURL), NULL, NULL}};
        ULONG cFetched = 0;

        penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);

        while (S_OK == penum->Next(1, rsu, &cFetched))
        {
            ASSERT(cFetched);
            ASSERT(rsu[0].pwcsUrl);
            ASSERT(rsu[0].pwcsTitle==NULL);

#ifdef DEBUG
            TCHAR szUrl[MAX_URL_STRING];
            SHUnicodeToTChar(rsu[0].pwcsUrl, szUrl, ARRAYSIZE(szUrl));
#endif
            // check to see if expires is not special && ftLastUpdated is earlier
            // than we need
            if (CompareFileTime(&(rsu[0].ftLastUpdated), &ftOldest) < 0 &&
                (rsu[0].ftExpires.dwLowDateTime != DW_FOREVERLOW ||
                 rsu[0].ftExpires.dwHighDateTime != DW_FOREVERHIGH))
            {
                hr = THR(s_DeleteUrl(rsu[0].pwcsUrl, 0));
#ifdef DEBUG
                TraceMsg(DM_URLCLEANUP, "CUH::s_Cleanup deleting %s", szUrl);
#endif
            } else {
#ifdef DEBUG
                TraceMsg(DM_URLCLEANUP, "CUH::s_Cleanup keeping  %s", szUrl);
#endif
            }

            CoTaskMemFree(rsu[0].pwcsUrl);
            rsu[0].pwcsUrl = NULL;
            cFetched = 0;
            
            ASSERT(!rsu[0].pwcsTitle);
        }

        penum->Release();
    }
    else 
        ASSERT(FALSE);

    TraceMsg(DM_URLCLEANUP, "CUH::s_CleanupHistory (expensive!) just called");
    return S_OK;
}

HRESULT CUrlHistory::CleanupHistory()
{
    return CUrlHistory::s_CleanupHistory();
}


TCHAR CUrlHistory::s_szUserPrefix[INTERNET_MAX_USER_NAME_LENGTH + 1] = TEXT("");
DWORD CUrlHistory::s_cchUserPrefix = 0;
DWORD CUrlHistory::s_dwDaysToKeep = 0;


void CUrlHistory::s_Init(void)
{
    // Cache the user name only once per process
    if (!s_cchUserPrefix)
    {
        ENTERCRITICAL;
        // Maybe it changed since entering the crit sec.
        // This really happened to me (BryanSt)
        // We do it twice for perf reasons.
        if (!s_cchUserPrefix)
        {
            ASSERT(s_szUserPrefix[0] == '\0');
            s_cchUserPrefix = ARRAYSIZE(s_szUserPrefix);

            //  Get the current user or set to default
            ::GetUserName(s_szUserPrefix, &s_cchUserPrefix);

            StringCchCat(s_szUserPrefix, ARRAYSIZE(s_szUserPrefix), TEXT("@"));
            s_cchUserPrefix = lstrlen(s_szUserPrefix);
        }

        LEAVECRITICAL;
    }

}


HRESULT CUrlHistory::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IUrlHistoryStg2) ||
        IsEqualIID(riid, IID_IUrlHistoryPriv) ||
         IsEqualIID(riid, IID_IUrlHistoryStg))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IUrlHistoryPriv *);
        hr = S_OK;

    }
    else if (IsEqualIID(riid, CLSID_CUrlHistory))
    {
        AddRef();
        *ppvObj = (LPVOID) this;
        hr = S_OK;
    }
    return hr;
}


ULONG CUrlHistory::AddRef(void)
{
    _cRef++;

    return _cRef;
}

ULONG CUrlHistory::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (!_cRef)
    {
        //time to go bye bye
        ENTERCRITICAL;
        g_puhUrlHistory = NULL;
        LEAVECRITICAL;
        delete this;
        return 0;
    }

    return _cRef;
}

//
// Converts a normal URL to a URL with the correct cache prefix.     
// it also finds a fragment (local Anchor) if it exists in the URL.  
//                                                                   
// if the URL is invalid, then the returned lplpszPrefixedUrl is just
// the prefix.  this is used primarily for doing enumeration.        
//
void CUrlHistory::s_ConvertToPrefixedUrlW(
                                       IN LPCWSTR pszUrl,
                                       OUT LPTSTR pszPrefixedUrl,
                                       IN DWORD cchPrefixedUrl,
                                       OUT LPCTSTR *ppszFragment
                                       )
{
    //
    // Make it sure that s_cchUserPrefix is initialized.
    //
    s_Init();

    //  Prefix + UserPrefix + '@'

    ASSERT(pszPrefixedUrl && ppszFragment);

    //  clear the out params
    pszPrefixedUrl[0] = L'\0';
    *ppszFragment = NULL;


    //  if there is no URL, send back a default case
    //  this is just for EnumObjects
    if (!pszUrl || !*pszUrl)
    {
        StringCchPrintf(pszPrefixedUrl, cchPrefixedUrl, L"%s%s", c_szHistoryPrefix, s_szUserPrefix);
    }
    else
    {
        int slen;
        int nScheme;
        LPWSTR pszFragment;

        StringCchPrintf(pszPrefixedUrl, cchPrefixedUrl, L"%s%s", c_szHistoryPrefix, s_szUserPrefix);
        slen = lstrlen(pszPrefixedUrl);
        StringCchCopy(pszPrefixedUrl + slen, cchPrefixedUrl - slen, pszUrl);

        // Only strip the anchor fragment if it's not JAVASCRIPT: or VBSCRIPT:, because a # could not an
        // anchor but a string to be evaluated by a script engine like #00ff00 for an RGB color.
        nScheme = GetUrlSchemeW(pszPrefixedUrl);      
        if (nScheme == URL_SCHEME_JAVASCRIPT || nScheme == URL_SCHEME_VBSCRIPT)
        {
            pszFragment = NULL;
        }
        else
        {
            //  locate local anchor fragment if possible
            pszFragment = StrChr(pszPrefixedUrl + slen, L'#');  // a-naghej Added " + slen" to fix WinSe bug# 13822 & 13926
        }

        if(pszFragment)     
        {
            //  kill the '#' so that lpszPrefixedUrl is isolated
            *pszFragment = L'\0';
            *ppszFragment = pszFragment+1;
        }

        //  check for trailing slash and eliminate
        LPWSTR pszT = CharPrev(pszPrefixedUrl, pszPrefixedUrl + lstrlen(pszPrefixedUrl));
        if (pszT[0] == L'/') {
            TraceMsg(DM_HISTNLS, "CUH::s_Convert removing the trailing slash of %s", pszPrefixedUrl);
            ASSERT(lstrlen(pszT)==1);
            pszT[0] = L'\0';
        }
    }
}


//
// Basically a wrapper function for RetreiveUrlCacheEntryInfo 
// meant to be called with the prefixed Url.                  
// it handles allocating the buffer and reallocating if necessary.
//
void CUrlHistory::s_RetrievePrefixedUrlInfo(
        LPCTSTR pszUrl, CEI_PREALLOC* pbuf)
{
    TraceMsg(DM_UHRETRIEVE, "CURLHistory::s_RetrievePrefixUrlInfo called (%s)", pszUrl);

    s_Init();

    DWORD cbCEI = SIZEOF(pbuf->ab);
    pbuf->pcei = &pbuf->cei;

    BOOL fSuccess = GetUrlCacheEntryInfoBinary(pszUrl, pbuf->pcei, &cbCEI);

    if (!fSuccess) {
        pbuf->pcei = NULL;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            TraceMsg(DM_TRACE, "CUH::s_RetrievePUI not enough buffer. Allocate! (%d)", cbCEI);
            pbuf->pcei = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, cbCEI);
            if (pbuf->pcei) {
                fSuccess = GetUrlCacheEntryInfoBinary(pszUrl, pbuf->pcei, &cbCEI);
                if (!fSuccess) {
                    TraceMsg(DM_HISTMISS, "CUH::s_Retrieve (%s) failed %x (on second attempt)",
                             pszUrl, GetLastError());
                    LocalFree(pbuf->pcei);
                    pbuf->pcei = NULL;
                    SetLastError(ERROR_FILE_NOT_FOUND);
                } 
            }
        } else {
            TraceMsg(DM_HISTMISS, "CUH::s_Retrieve (%s) failed %x (on first attempt)",
                     pszUrl, GetLastError());
            SetLastError(ERROR_FILE_NOT_FOUND);
        }
    }
}

//
// Return the total of a double-null terminated string (including the
// terminating null).
//
UINT lstrzlen(LPCTSTR pszz)
{
    for (LPCTSTR psz=pszz; *psz; psz += lstrlen(psz) + 1) ;
    return (unsigned int)(psz+1-pszz);
}


    /*++

     Routine Description:

     this creates a buffer that holds a HISTDATA, and everything the HISTDATAs offsets
     point to.  it only sets those offsets that are passed in.

     Arguments:

     lpszTitle          Title to place in the buffer

     lpBase                     this is the base of the offsets in aFrags

     aFrags                     an array of offsets to the fragments to place in the buffer

     cFrags                     number of fragments in aFrags

     lpszNewFrag                this is an additional fragment to add in the new buffer

     pcbHeader                  this is a pointer to the final size of the buffer returned

     NOTE: any of the arguments except pcbHeader may be NULL.
     if lpBase is NULL, then aFrags must also be NULL. this is CALLERs responsibility!
     if a parameter is NULL, then it just isnt added to the buffer.

     Return Value:

     POINTER
     Success - a valid pointer to a buffer that must be freed.

     Failure - NULL. this only fails with ERROR_NOT_ENOUGH_MEMORY

     NOTE:  Caller must free the returned pointer.  *pcbHeader only set upon successful return.

     --*/

HISTDATA* CUrlHistory::s_GenerateHeaderInfo(
                                  IN LPCTSTR pszTitle,
                                  IN HISTDATA* phdPrev,         
                                  IN LPCTSTR pszFragment,
                                  OUT LPDWORD pcbHeader
                                  )
{
    DWORD cbHeader = 0;
    UINT cbHistExtra = 0;
    HISTEXTRA* phextPrev;

    // Get the size for title
    UINT cchTitle = 0;
    if (pszTitle[0]) {
        cchTitle = lstrlen(pszTitle) + 1;
        cbHistExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchTitle * sizeof(TCHAR)));

        if (phdPrev && (phextPrev = phdPrev->_FindExtraForSave(PID_INTSITE_TITLE))!=NULL) {
            phextPrev->vtExtra = VT_EMPTY;
        }
    }

    // Get the size of fragments
    UINT cchFragsPrev = 0;
    UINT cchFragment = 0;
    if (pszFragment) {
        cchFragment = lstrlen(pszFragment) + 2;  // Double NULL terminated
        if (phdPrev && (phextPrev=phdPrev->_FindExtraForSave(PID_INTSITE_FRAGMENT))!=NULL) {
            cchFragsPrev = lstrzlen((LPCTSTR)phextPrev->abExtra) - 1; // lstrzlen includes both terminating nulls
                                                                      // -1 since cchFragment already accounts
                                                                      // for double terminating NULLs.
            ASSERT(cchFragsPrev != (UINT)-1);
            phextPrev->vtExtra = VT_EMPTY;
        }
        cbHistExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchFragsPrev + cchFragment) * sizeof(TCHAR));
    }

    // Get the size of other extra
    if (phdPrev) {
        cbHistExtra += phdPrev->GetTotalExtraSize();
    }

    // Allocate it
    CHistoryData* phdNew = CHistoryData::s_AllocateHeaderInfo(
                                cbHistExtra, phdPrev,
                                &cbHeader);

    if (phdNew) {
        HISTEXTRA* phext = phdNew->_GetExtra();

        ASSERT( phext );

        // Append title
        if (pszTitle[0]) {
            phext->cbExtra = DW_ALIGNED((cchTitle * sizeof(TCHAR)) + SIZEOF(HISTEXTRA));
            phext->idExtra = PID_INTSITE_TITLE;
            phext->vtExtra = VT_LPTSTR; 
            StringCchCopy((LPTSTR)phext->abExtra, cchTitle, pszTitle);
            phext = phext->GetNextFastForSave();
        }

        // Append fragment     
        if (pszFragment) {
            // Copy pszFragment to the top.
            StringCchCopy((LPTSTR)phext->abExtra, cchFragment, pszFragment);
            // Double NULL terminate.  Note cchFragment = strlen + 2
            *(((LPTSTR)phext->abExtra) + cchFragment - 1) = TEXT('\0');

            // Copy existing fragments if any
            if (cchFragsPrev) {
                ASSERT(phdPrev);
                phextPrev = phdPrev->_FindExtraForSave(PID_INTSITE_FRAGMENT);
                ASSERT(phextPrev);
                if (phextPrev) {
                    ASSERT(IS_DW_ALIGNED(phextPrev->cbExtra));
                    memcpy(phext->abExtra + ((cchFragment - 1) * sizeof(TCHAR)), phextPrev->abExtra,
                           (cchFragsPrev + 1) * sizeof(TCHAR));
                }
            }

            ASSERT(lstrzlen((LPCTSTR)phext->abExtra) == cchFragsPrev + cchFragment);
            phext->cbExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchFragsPrev + cchFragment) * sizeof(TCHAR));
            phext->idExtra = PID_INTSITE_FRAGMENT;
            phext->vtExtra = VT_NULL;    // HACK (means internal)
            phext = phext->GetNextFastForSave();
        }

        // Migrate extra data from previous one
        if (phdPrev) {
            phext = phdPrev->CopyExtra(phext);
        }

        ASSERT( phext->cbExtra == 0); // terminator
        ASSERT( (LPBYTE)phdNew+cbHeader == (LPBYTE)phext+SIZEOF(DWORD) );
        ASSERT( cbHistExtra == phdNew->GetTotalExtraSize() );
    }

    *pcbHeader = cbHeader;

    TraceMsg(DM_HISTGENERATE, "CUH::s_GenerateHeader allocated %d bytes (%d extra)",
             cbHeader, cbHistExtra);

    return phdNew;
}

// FEATURE: Move this to UTIL.CPP
LPWSTR AllocOleStrFromTChar(LPCTSTR psz)
{
    DWORD cch = lstrlen(psz) + 1;
    LPWSTR pwsz = (LPWSTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
    if (pwsz) {
        SHTCharToUnicode(psz, pwsz, cch);
    }
    return pwsz;
}

HRESULT CUrlHistory::s_GenerateSTATURL(
                               IN PCTSTR pszPrefixedURL,
                               IN LPINTERNET_CACHE_ENTRY_INFO lpCEI,
                               IN DWORD dwFlags,
                               OUT LPSTATURL lpSTATURL)
{
    ASSERT(lpCEI);
    ASSERT(lpSTATURL);

    if (!lpCEI || !lpSTATURL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    LPHISTDATA phd =  CHistoryData::s_GetHistoryData(lpCEI);
    // I've seen lpCEI->lpszSourceUrlName be NULL with help "ms-its:" URLs. 
    LPCTSTR pszUrl = lpCEI->lpszSourceUrlName ? lpCEI->lpszSourceUrlName : pszPrefixedURL; 
    if (pszUrl && *pszUrl)
    {
       pszUrl += s_cchUserPrefix + CCHHISTORYPREFIX;
    }

    ZeroMemory(lpSTATURL, SIZEOF(STATURL));

    lpSTATURL->ftLastUpdated = lpCEI->LastModifiedTime;
    lpSTATURL->ftExpires = lpCEI->ExpireTime;
    lpSTATURL->ftLastVisited = lpCEI->LastSyncTime;

    if(dwFlags & STATURL_QUERYFLAG_ISCACHED)
    {
        if (pszUrl)
        {
            if (s_IsCached(pszUrl))
                lpSTATURL->dwFlags |= STATURLFLAG_ISCACHED;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if (dwFlags & STATURL_QUERYFLAG_TOPLEVEL)
    {
        if (phd) {
            if (phd->dwFlags & PIDISF_HISTORY)
            {
                lpSTATURL->dwFlags |= STATURLFLAG_ISTOPLEVEL;
            }
        }
    }

    if (!(dwFlags & STATFLAG_NONAME))
    {
        if (!(dwFlags & STATURL_QUERYFLAG_NOURL))
        {
            if (pszUrl)
            {
                //  set the Url
                lpSTATURL->pwcsUrl = AllocOleStrFromTChar(pszUrl);      // This will RIP if NULL is passed.
                if (lpSTATURL->pwcsUrl == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        if (!(dwFlags & STATURL_QUERYFLAG_NOTITLE))
        {
            //  is there a title to set?
            if (phd)
            {
                const HISTEXTRA* phextTitle = phd->_FindExtra(PID_INTSITE_TITLE);

                if (phextTitle && phextTitle->vtExtra == VT_LPTSTR) {
                    lpSTATURL->pwcsTitle = AllocOleStrFromTChar((LPCTSTR)phextTitle->abExtra);
                    if (lpSTATURL->pwcsTitle == NULL) {
                        if (lpSTATURL->pwcsUrl)
                            CoTaskMemFree(lpSTATURL->pwcsUrl);
                        lpSTATURL->pwcsUrl = NULL;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    ASSERT(SUCCEEDED(hr) || (lpSTATURL->pwcsUrl==NULL && lpSTATURL->pwcsTitle==NULL));
    return hr;
}

    /*++

     Routine Description:

     Places the specified URL into the history.

     If it does not exist, then it is created.  If it does exist it is overwritten.

     Arguments:

     pwszUrl                    - The URL in question.

     pwszTitle  - pointer to the friendly title that should be associated
     with this URL. If NULL, no title will be added.

     dwFlags             - Sets options for storage type and durability
     Not implemented yet

     Return Value:

     HRESULT
     Success - S_OK

     Failure - E_ hresult

     --*/


HRESULT CUrlHistory::AddUrl(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags                // Storage options
                         )              
{
    BOOL fWriteHistory = TRUE;

    if (ADDURL_ADDTOCACHE == dwFlags)
    {
        fWriteHistory = FALSE;
    }
    
    return AddUrlAndNotify(pwszUrl, pwszTitle, dwFlags, fWriteHistory, NULL, NULL);
}


BOOL CUrlHistory::s_CommitUrlCacheEntry(LPCTSTR pszPrefixedUrl, 
                        LPINTERNET_CACHE_ENTRY_INFO pcei)
{
    if (s_dwDaysToKeep==0) {
        s_dwDaysToKeep = s_GetDaysToKeep();
    }

    //
    //  prepare the expire time
    //
    SYSTEMTIME st;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &pcei->LastModifiedTime);

    //
    // Assume the normal expiration date ... we add 6 days to expiration date
    // to make sure when we show the oldest week, we'll still have data for days
    // that are past the s_dwDaysToKeep
    //
    LONGLONG llExpireHorizon = SECS_PER_DAY * (s_dwDaysToKeep + 6);
    llExpireHorizon *= FILETIME_SEC;
    pcei->ExpireTime.dwLowDateTime = pcei->LastModifiedTime.dwLowDateTime + (DWORD) (llExpireHorizon % 0xFFFFFFFF);
    pcei->ExpireTime.dwHighDateTime = pcei->LastModifiedTime.dwHighDateTime + (DWORD) (llExpireHorizon / 0xFFFFFFFF);

    //
    // Check if it's subscribed
    //
    CHistoryData* phd =  CHistoryData::s_GetHistoryData(pcei);
    if (phd && phd->_FindExtra(PID_INTSITE_SUBSCRIPTION)) {
        //
        // It's subscribed. Keep it forever (until unsubscribed). 
        //
        TraceMsg(DM_URLCLEANUP, "CUH::s_CommitUrlCacheEntry found subscription key %s", pszPrefixedUrl);
        pcei->ExpireTime.dwLowDateTime = DW_FOREVERLOW;
        pcei->ExpireTime.dwHighDateTime = DW_FOREVERHIGH;
    }

#ifdef DEBUG
    LPCTSTR pszTitle = TEXT("(no extra data)");
    if (phd) {
        const HISTEXTRA* phext = phd->_FindExtra(PID_INTSITE_TITLE);
        if (phext && phext->vtExtra==VT_LPTSTR) {
            pszTitle = (LPCTSTR)phext->abExtra;
        } else {
            pszTitle = TEXT("(no title property)");
        }

        TraceMsg(DM_HISTCOMMIT, "CURL::s_C calling Commit for %s with %s",
            pszPrefixedUrl, pszTitle);
    }
#endif

    return CommitUrlCacheEntryBinary(pszPrefixedUrl,    
                                     pcei->ExpireTime,  
                                     pcei->LastModifiedTime,                    
                                     pcei->CacheEntryType | URLHISTORY_CACHE_ENTRY,
                                     (LPBYTE)pcei->lpHeaderInfo,
                                     pcei->dwHeaderInfoSize);
}

void CUrlHistory::_WriteToHistory(LPCTSTR pszPrefixedUrl, FILETIME& ftExpires, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory)
{
    IHistSFPrivate *psfpHistory;
    HRESULT hr = LoadHistoryShellFolder(punkSFHistory, &psfpHistory);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlNotify = NULL;
        //
        //      prepare the local mod time
        //
        SYSTEMTIME st;
        GetLocalTime (&st);
    
        FILETIME ftLocModified; // new history written in "User Perceived Time"
        SystemTimeToFileTime(&st, &ftLocModified);
        hr = psfpHistory->WriteHistory(pszPrefixedUrl,
                                ftExpires,
                                ftLocModified,
                                poctNotify ? &pidlNotify : NULL);
        if (pidlNotify)
        {
            VARIANTARG var;
            InitVariantFromIDList(&var, pidlNotify);

            poctNotify->Exec(&CGID_Explorer, SBCMDID_SELECTHISTPIDL, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

            ILFree(pidlNotify);
            VariantClear(&var);
        }
        psfpHistory->Release();
    }
    // if we made it to here, we win!
}

void CUrlHistory::s_UpdateIcon(Intshcut* pintshcut, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH];
    int niIcon = 0;
    UINT uFlags;

    // mask off the other stuff so we get consistent results.
    dwFlags &= PIDISF_RECENTLYCHANGED;
    
    // Get the old icon location 
    pintshcut->GetIconLocationFromFlags(0, szPath, SIZECHARS(szPath),
        &niIcon, &uFlags, dwFlags);
    
    // property.
//    int icachedImage = SHLookupIconIndex(PathFindFileName(szPath), niIcon, uFlags);
    int icachedImage = Shell_GetCachedImageIndex(szPath, niIcon, uFlags);

    TraceMsg(DM_HISTSPLAT, "CUH::s_UpdateIcon splat flag is changed for %s (%d)",
            szPath, icachedImage);

    SHUpdateImage(szPath, niIcon, uFlags, icachedImage );
}

HRESULT CUrlHistory::AddUrlAndNotify(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags,                // Storage options
                         IN BOOL fWriteHistory,         // Write History ShellFolder
                         IN IOleCommandTarget *poctNotify,
                         IN IUnknown *punkSFHistory)
{
    return AddUrlAndNotifyCP(pwszUrl, pwszTitle, dwFlags, fWriteHistory,
                           poctNotify, punkSFHistory, NULL);
}




HRESULT CUrlHistory::AddUrlAndNotifyCP(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags,                // Storage options
                         IN BOOL fWriteHistory,         // Write History ShellFolder
                         IN IOleCommandTarget *poctNotify,
                         IN IUnknown *punkSFHistory,
                         UINT* pcodepage)               
{
    if (pcodepage) {
        *pcodepage = CP_ACP;    // this is default.
    }

    HRESULT hr = S_OK;
    LPCWSTR pwszTitleToStore = pwszTitle;

    //  check to make sure we got an URL
    if (!pwszUrl || !pwszUrl[0])
    {
        TraceMsg( TF_WARNING, "CUrlHistory::AddUrlAndNotifyCP() - pwszUrl is NULL or Empty!" );
        return E_INVALIDARG;
    }

    if (pwszTitleToStore && 0 == StrCmpIW(pwszTitleToStore, pwszUrl))
    {
        //  Suppress redundant title data
        pwszTitleToStore = NULL;
    }

    CEI_PREALLOC buf;
    INTERNET_CACHE_ENTRY_INFO cei = { 0 };

    // Wininet URL cache only supports 8-bit ANSI, so we need to encode any characters
    // which can't be converted by the system code page, in order to allow Unicode
    // filenames in History.  The URLs will remain in the encoded form through most of
    // the History code paths, with only the display and navigation code needing to be
    // aware of the UTF8

    LPCTSTR pszUrlSource = pwszUrl; // points to the URL that we decide to use

    TCHAR szEncodedUrl[MAX_URL_STRING];
    BOOL bUsedDefaultChar;
    
    // Find out if any of the chars will get scrambled.  We can use our szEncodedUrl 
    // buffer to store he multibyte result because we don't actually want it
    
    WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, 
        (LPSTR) szEncodedUrl, sizeof(szEncodedUrl), NULL, &bUsedDefaultChar);
    
    StrCpyN(szEncodedUrl, pwszUrl, ARRAYSIZE(szEncodedUrl));
    SHCleanupUrlForDisplay(szEncodedUrl);
    pszUrlSource = szEncodedUrl;

    if (bUsedDefaultChar)
    {
        // one or more chars couldn't be converted, so we store the UTF8 escaped string
        ConvertToUtf8Escaped(szEncodedUrl, ARRAYSIZE(szEncodedUrl));
    }

    s_ConvertToPrefixedUrlW(pszUrlSource, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    LPHISTDATA phdPrev = NULL;

    TCHAR szTitle[MAX_PATH];
    szTitle[0] = '\0';

    LPINTERNET_CACHE_ENTRY_INFO             pceiUrl = NULL;

    //
    //  if there is already an entry for this Url, then we will reuse some of the
    //  settings.  retrieve the relevant info if possible.
    //
    if (buf.pcei)
    {
        // The existing one cannot be copied since the size may vary.
        // That is, the s_RetrievePrefixedUrlInfo above may allocate a larger buffer than expected.
        pceiUrl = buf.pcei;

        phdPrev = CHistoryData::s_GetHistoryData( pceiUrl );
        if (pwszTitle==NULL && phdPrev) {
            phdPrev->_GetTitle(szTitle, ARRAYSIZE(szTitle));
        }

        if (pcodepage && phdPrev) {
            //
            // NOTES: This is the best place get the codepage stored
            //  in this URL history.
            //
            const HISTEXTRA* phextCP =phdPrev->_FindExtra(PID_INTSITE_CODEPAGE);
            if (phextCP && phextCP->vtExtra == VT_UI4) {
                *pcodepage = *(DWORD*)phextCP->abExtra;
                TraceMsg(DM_TRACE, "CUH::AddAndNotify this URL has CP=%d",
                         *pcodepage);
            }
        }

    }
    else
    {
        pceiUrl = &cei;

        cei.CacheEntryType = NORMAL_CACHE_ENTRY;
        ASSERT(cei.dwHeaderInfoSize == 0);
    }

    ASSERT( pceiUrl );

    if ( ! pceiUrl )
    {
        TraceMsg( TF_ERROR, "CUrlHistory::AddUrlAndNotifyCP() - pceiUrl is NULL!" );
        return E_FAIL;
    }

    //
    //  search for a fragment if necessary
    //
    if (buf.pszFragment && phdPrev)
    {
        if (phdPrev->_HasFragment(buf.pszFragment)) {
            buf.pszFragment = NULL;
        }
    }

    // Override the title if specified.
    if (pwszTitleToStore) {
        // GetDisplayableTitle puts szTitle[0] = '\0' if it's
        // not displayable with shell codepage
        StringCchCopy(szTitle, ARRAYSIZE(szTitle), pwszTitleToStore);
    } 

    CHistoryData* phdNew = s_GenerateHeaderInfo(
               szTitle, phdPrev, buf.pszFragment, &pceiUrl->dwHeaderInfoSize);

    if (phdNew)
    {
        pceiUrl->lpHeaderInfo = (LPTSTR)phdNew;

        //
        // [alanau] Background: See IE5 Bug #110378 and related.
        //
        // For secure URLs (https:) that respond with a cache control header (pragma: no-cache or
        // cache-control: no-cache or no-store), we presume that these can contain sensitive data that
        // the site did not want retained on the client machine.  Therefore, we do not write a history entry
        // for such sites.
        //
        // Previously, a check was made in CDocObjectHost::CDOHBindStatusCallback::OnObjectAvailable(), where
        // the binding was queried for INTERNET_REQFLAG_CACHE_WRITE_DISABLED.  This flag would be set not only 
        // for https: URLs but for http: URLs that contained cache-control: no-store.  With Native Frames, however,
        // OnObjectAvailable() is no longer called (as Trident performs the bind), so SHDOCVW doesn't have access
        // to the PIB any longer.  However, all we are really interested in is whether or not the URL is in cache,
        // and we have a straightforward way to check that.
        // 
        // Note that IE 5.5 has a deliberate change of behavior to write http: (non-secure) URLs that 
        // contain cache-control: no-store to history.

        // If caller specified to write history, and the scheme is a history-enabled scheme,
        //
        if (fWriteHistory && !UrlIsNoHistoryW(pwszUrl))
        {
            // If it's https://, we have more work to do.
            //
            if (URL_SCHEME_HTTPS == GetUrlScheme(pwszUrl))
            {
                // Check the cache.  If https: and in cache, add to history.
                //
                if (UrlIsInCache(pwszUrl))
                {
                    phdNew->dwFlags |= PIDISF_HISTORY;
                }
            }
            else
            {
                // Not https:, so turn on history flag.
                //
                phdNew->dwFlags |= PIDISF_HISTORY;
            }
        }
        else
        {
            phdNew->dwFlags &= ~PIDISF_HISTORY; // clear the flag
        }

        BOOL fUpdateIcon = FALSE;
    
        if (phdNew->dwFlags & PIDISF_RECENTLYCHANGED) {
            fUpdateIcon = TRUE;
            phdNew->dwFlags &= ~PIDISF_RECENTLYCHANGED;
        }

        if ( s_CommitUrlCacheEntry( buf.szPrefixedUrl, pceiUrl ) )
        {
            if (fUpdateIcon) {
                TraceMsg(DM_HISTSPLAT, "CUH::AddAndNotify remove splat!");

                // APPCOMPAT: This is a temporary hack to make splat update
                //  work as bad as previously.
                Intshcut* pintshcut = new Intshcut();
                if (pintshcut) {
                    pintshcut->SetURL(pwszUrl ,0);
                    s_UpdateIcon(pintshcut, PIDISF_RECENTLYCHANGED);
                    pintshcut->Release();
                }
            }
    
            //
            //  When we have successfully updated the global history and
            // we have updated something in the HISTDATA, update the
            // date-based history as well.
            //
            //
            // Cache IShellFolder for the history folder if we don't have
            // it yet.
            //
            // Use the previously set PIDISF_HISTORY flag to decide whether or not to write history here too.
            if (phdNew->dwFlags & PIDISF_HISTORY)
            {
                _WriteToHistory( buf.szPrefixedUrl, pceiUrl->ExpireTime, poctNotify, punkSFHistory );
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError ());
        }

        LocalFree(phdNew);
        phdNew = NULL;
    }

#ifdef DEBUG
    if (g_dwPrototype & 0x00000020) {
        TCHAR szUrl[MAX_URL_STRING];
        SHUnicodeToTChar(pwszUrl, szUrl, ARRAYSIZE(szUrl));
        PROPVARIANT var = { 0 };
        HRESULT hrT = GetProperty(szUrl, PID_INTSITE_SUBSCRIPTION, &var);
        if (SUCCEEDED(hrT)) {
            TraceMsg(DM_TRACE, "CUH::AddAndNotify got property vt=%d lVal=%x",
                        var.vt, var.lVal);
            PropVariantClear(&var);
        } else {
            TraceMsg(DM_TRACE, "CUH::AddAndNotify failed to get property (%x)", hrT);
        }
    }
#endif

    return hr;
}


HRESULT CUrlHistory::QueryUrl(
                          IN LPCWSTR pwszUrl,
                          IN DWORD dwFlags,
                          OUT LPSTATURL lpSTATURL
                          )
{
    if (!pwszUrl || !pwszUrl[0])
    {
        return E_INVALIDARG;
    }

    if (lpSTATURL)
    {
        lpSTATURL->pwcsUrl = NULL;
        lpSTATURL->pwcsTitle = NULL;
    }

    LPCTSTR pszFragment;
    TCHAR szPrefixedUrl[MAX_URL_STRING];

    s_ConvertToPrefixedUrlW(pwszUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &pszFragment);
    return s_QueryUrlCommon(szPrefixedUrl, pszFragment, dwFlags, lpSTATURL);
}

HRESULT CUrlHistory::s_QueryUrlCommon(
                          IN LPCTSTR lpszPrefixedUrl,
                          LPCTSTR lpszFragment,
                          IN DWORD dwFlags,
                          OUT LPSTATURL lpSTATURL
                          )

    /*++

     Routine Description:

     Checks to see if Url is a valid History item

     Arguments:

     pwszUrl                    - The URL in question.

     dwFlags             - Flags on the query

     lpSTATURL           - points to a STATURL storage structure
     If this is NULL, then a S_OK means the URL was found.


     Return Value:

     HRESULT
     Success            - S_OK, Item found and STATURL filled

     Failure            - valid E_ code
     HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) indicates the URL is not available


     --*/

{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    LPHISTDATA phd = NULL;
    CEI_PREALLOC buf;

    //
    //  if there is no data required, and there are no fragments
    //  we dont need to get a copy of the CEI
    //
    if(!lpSTATURL && !lpszFragment)
    {
        if(s_IsCached(lpszPrefixedUrl))
            hr = S_OK;
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        goto quit;
    }

    s_RetrievePrefixedUrlInfo(lpszPrefixedUrl, &buf);
    if (buf.pcei)
    {
        DEBUG_CODE(DWORD cbNHI = buf.pcei->dwHeaderInfoSize;)
        phd = CHistoryData::s_GetHistoryData(buf.pcei);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError ());
        goto quit;
    }


    //
    //  Need to check for local anchor fragments
    //
    if (lpszFragment)
    {
        if (phd && phd->_HasFragment(lpszFragment))
        {
            hr = S_OK;
        }
    } else {
        hr = S_OK;
    }

    //  check to see if we should fill the STATURL
    if (S_OK == hr && lpSTATURL) {
        hr = s_GenerateSTATURL(lpszPrefixedUrl, buf.pcei, dwFlags, lpSTATURL);
    }

quit:

    if (S_OK != hr && lpSTATURL)
    {
        if (lpSTATURL->pwcsUrl)
        {
            LocalFree(lpSTATURL->pwcsUrl);
            lpSTATURL->pwcsUrl = NULL;
        }

        if (lpSTATURL->pwcsTitle)
        {
            LocalFree(lpSTATURL->pwcsTitle);
            lpSTATURL->pwcsTitle = NULL;
        }
    }

    return hr;
}

HRESULT CUrlHistory::QueryUrlA(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL)
{
    TCHAR szPrefixedUrl[MAX_URL_STRING];
    LPCTSTR lpszFragment = NULL;
    HRESULT hr = S_OK;

    if (!pszUrl || !pszUrl[0]) {
        return E_INVALIDARG;
    }

    if (lpSTATURL)
    {
        lpSTATURL->pwcsUrl = NULL;
        lpSTATURL->pwcsTitle = NULL;
    }

    TCHAR szUrl[MAX_URL_STRING];

    SHAnsiToUnicode(pszUrl, szUrl, ARRAYSIZE(szUrl));
    CUrlHistory::s_ConvertToPrefixedUrlW(szUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &lpszFragment);

    return CUrlHistory::s_QueryUrlCommon(szPrefixedUrl, lpszFragment, dwFlags, lpSTATURL);
}

HRESULT CUrlHistory::s_DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags)
{
    DWORD Error = ERROR_SUCCESS;
    TCHAR szPrefixedUrl[MAX_URL_STRING];
    LPCTSTR lpszFragment;
    BOOL  fDoDelete = TRUE;
    
    if (!pwszUrl || !pwszUrl[0]) {
        return E_INVALIDARG;
    }

    s_ConvertToPrefixedUrlW(pwszUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &lpszFragment);

    // don't delete it if its not a subscription
    if (dwFlags & URLFLAG_DONT_DELETE_SUBSCRIBED) {
        CEI_PREALLOC buf;
        // query to find out if its a subscription
        s_RetrievePrefixedUrlInfo(szPrefixedUrl, &buf);
        if (buf.pcei &&
            //  Hack alert (chrisfra) avoid deleting subscriptions, etc!
            ((buf.pcei)->ExpireTime.dwLowDateTime  == DW_FOREVERLOW) &&
            ((buf.pcei)->ExpireTime.dwHighDateTime == DW_FOREVERHIGH))
        {
            fDoDelete = FALSE;
            // re-write it as a non-history item and just a subscription
            CHistoryData *phdPrev = CHistoryData::s_GetHistoryData(buf.pcei);
            if (phdPrev) // offset into pcei structure
            {
                phdPrev->dwFlags &= ~PIDISF_HISTORY;
                s_CommitUrlCacheEntry(szPrefixedUrl, buf.pcei);
            }
            else {
                // I'd rather return ERROR_OUT_OF_PAPER...
                Error = ERROR_FILE_NOT_FOUND;
            }
        }
    }

    if (fDoDelete) {
        if(!::DeleteUrlCacheEntry(szPrefixedUrl))
            Error = GetLastError();
    }

    return HRESULT_FROM_WIN32(Error);
}

HRESULT CUrlHistory::DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags)
{
    return s_DeleteUrl(pwszUrl, dwFlags);
}

HRESULT CUrlHistory::BindToObject (LPCWSTR pwszUrl, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    return E_NOTIMPL;
}

HRESULT CUrlHistory::s_EnumUrls(IEnumSTATURL **ppEnum)
{
    HRESULT hres = E_OUTOFMEMORY;
    *ppEnum = NULL;
    CEnumSTATURL *penum = new CEnumSTATURL();
    if (penum)
    {
        *ppEnum = (IEnumSTATURL *)penum;
        hres = S_OK;
    }
    return hres;
}

HRESULT CUrlHistory::EnumUrls(IEnumSTATURL **ppEnum)
{
    return s_EnumUrls(ppEnum);
}

HRESULT CUrlHistory::GetProperty(LPCTSTR pszURL, PROPID pid, PROPVARIANT* pvarOut)
{
    HRESULT hres = E_FAIL;  // assume error
    PropVariantInit(pvarOut);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(pszURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);
    if (buf.pcei) {
        CHistoryData* phdPrev =  CHistoryData::s_GetHistoryData(buf.pcei);
        if (phdPrev) {
            const HISTEXTRA* phextPrev;

            switch(pid) {
            case PID_INTSITE_FLAGS:
                pvarOut->vt = VT_UI4;
                pvarOut->lVal = phdPrev->dwFlags;
                hres = S_OK;
                break;
        
            case PID_INTSITE_LASTVISIT:
                pvarOut->vt = VT_FILETIME;
                pvarOut->filetime = buf.pcei->LastAccessTime;
                hres = S_OK;
                break;

            case PID_INTSITE_LASTMOD:
                pvarOut->vt = VT_FILETIME;
                pvarOut->filetime = buf.pcei->LastModifiedTime;
                hres = S_OK;
                break;

            case PID_INTSITE_WATCH:
                pvarOut->vt = VT_UI4;
                pvarOut->lVal = phdPrev->dwWatch;
                hres = S_OK;
                break;

            case PID_INTSITE_VISITCOUNT:
                pvarOut->vt   = VT_UI4;
                pvarOut->lVal = buf.pcei->dwHitRate;
                hres = S_OK;
                break;

            default:
                phextPrev = phdPrev->_FindExtra(pid);
                LPCWSTR pwsz;

                if (phextPrev) {
                    WCHAR wszBuf[MAX_URL_STRING];

                    switch(phextPrev->vtExtra) {
                    case VT_UI4:
                    case VT_I4:
                        pvarOut->vt = phextPrev->vtExtra;
                        pvarOut->lVal = *(DWORD*)phextPrev->abExtra;
                        hres = S_OK;
                        break;

                    case VT_LPSTR:
                        AnsiToUnicode((LPCSTR)phextPrev->abExtra, wszBuf, ARRAYSIZE(wszBuf));
                        pwsz = wszBuf;
                        goto Return_LPWSTR;

                    case VT_LPWSTR:
                        pwsz = (LPWSTR)phextPrev->abExtra;
Return_LPWSTR:
                        int cch = lstrlenW(pwsz)+1;
                        pvarOut->pwszVal = (LPWSTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
                        if (pvarOut->pwszVal) {
                            if (SUCCEEDED(StringCchCopyW(pvarOut->pwszVal, cch, pwsz)))
                            {
                                pvarOut->vt = VT_LPWSTR;
                                hres = S_OK;
                            }
                            else
                            {
                                hres = E_OUTOFMEMORY;
                            }
                        } else {
                            hres = E_OUTOFMEMORY;
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
    return hres;
}

//
//  IEnumSTATURL methods
//
CEnumSTATURL::~CEnumSTATURL()
{
    if(m_lpCEI)
    {
        LocalFree(m_lpCEI);
        m_lpCEI = NULL;
    }

    if(m_hEnum)
        FindCloseUrlCache(m_hEnum);

    return;
}

HRESULT CEnumSTATURL::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        *ppvObj = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(IID_IEnumSTATURL, riid))
    {
        *ppvObj = (IEnumSTATURL *) this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CEnumSTATURL::AddRef(void)
{
    _cRef++;

    return _cRef;
}


ULONG CEnumSTATURL::Release(void)
{
    _cRef--;

    if (!_cRef)
    {
        delete this;
        return 0;
    }

    return _cRef;
}



HRESULT CEnumSTATURL::RetrieveFirstUrlInfo()
{

    HRESULT hr = S_OK;

    ASSERT(!m_lpCEI);

    m_cbCEI = DEFAULT_CEI_BUFFER_SIZE;
    m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, DEFAULT_CEI_BUFFER_SIZE);
    if (!m_lpCEI)
    {
        hr = E_OUTOFMEMORY;
        goto quit;
    }

    while (TRUE)
    {
        m_hEnum = FindFirstUrlCacheEntryBinary(_szPrefixedUrl,
                                                   m_lpCEI,
                                                   &m_cbCEI);

        if (!m_hEnum)
        {
            DWORD Error = GetLastError ();

            LocalFree(m_lpCEI);
            m_lpCEI = NULL;

            if (Error == ERROR_INSUFFICIENT_BUFFER)
            {
                m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, m_cbCEI);
                if (!m_lpCEI)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                if (ERROR_NO_MORE_ITEMS == Error)
                    hr = S_FALSE;
                else
                    hr = HRESULT_FROM_WIN32(Error);
                break;
            }
        }
        else break;
    }

quit:

    m_cbCEI = (DWORD)max(m_cbCEI, DEFAULT_CEI_BUFFER_SIZE);

    return hr;
}

// This function should not becaused if the previous call failed
// and ::Reset() was never called.
HRESULT CEnumSTATURL::RetrieveNextUrlInfo()
{
    HRESULT hr = S_OK;
    BOOL ok;

    ASSERT(m_hEnum);

    while (TRUE)
    {

        ok = FindNextUrlCacheEntryBinary(m_hEnum,
                                             m_lpCEI,
                                             &m_cbCEI);

        if (!ok)
        {
            DWORD Error = GetLastError ();

            if (m_lpCEI)
            {
                LocalFree(m_lpCEI);
                m_lpCEI = NULL;
            }

            if (Error == ERROR_INSUFFICIENT_BUFFER)
            {
                m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, m_cbCEI);
                if (!m_lpCEI)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                if (ERROR_NO_MORE_ITEMS == Error)
                    hr = S_FALSE;
                else
                    hr = HRESULT_FROM_WIN32(Error);
                break;
            }
        }
        else break;
    }

    m_cbCEI = (DWORD)max(m_cbCEI, DEFAULT_CEI_BUFFER_SIZE);

    return hr;
}




HRESULT CEnumSTATURL::Next(ULONG celt, LPSTATURL rgelt, ULONG * pceltFetched)
    /*++

     Routine Description:

     Searches through the History looking for URLs that match the search pattern,
     and copies the STATURL into the buffer.

     Arguments:



     Return Value:



     --*/

{
    HRESULT hr = S_OK;
    BOOL found = FALSE;
    LPHISTDATA phd = NULL;

    if(pceltFetched)
        *pceltFetched = 0;

    if(!celt)
        goto quit;

    if (!m_hEnum)
    {
        //must handle new enumerator
        CUrlHistory::s_ConvertToPrefixedUrlW(m_poszFilter, _szPrefixedUrl, ARRAYSIZE(_szPrefixedUrl), &m_lpszFragment);

        //loop until we get our first handle or bag out
        hr = RetrieveFirstUrlInfo();
        if (S_OK != hr || !m_lpCEI)
            goto quit;

        m_cchPrefixedUrl = lstrlen(_szPrefixedUrl);

        while(StrCmpN(_szPrefixedUrl, m_lpCEI->lpszSourceUrlName, m_cchPrefixedUrl))
        {
            hr = RetrieveNextUrlInfo();
            if(S_OK != hr || !m_lpCEI)
                goto quit;
        }
    }
    else
    {
        do
        {
            hr = RetrieveNextUrlInfo();
            if (S_OK != hr || !m_lpCEI)
                goto quit;

        } while(StrCmpN(_szPrefixedUrl, m_lpCEI->lpszSourceUrlName, m_cchPrefixedUrl));
    }

    hr = CUrlHistory::s_GenerateSTATURL(NULL, m_lpCEI, m_dwFilter, rgelt);

    if(SUCCEEDED(hr) && pceltFetched)
        (*pceltFetched)++;



quit:
    if (pceltFetched) {
        ASSERT((0 == *pceltFetched && (S_FALSE == hr || FAILED(hr))) ||
               (*pceltFetched && S_OK == hr));
    }

    return hr;


}

HISTEXTRA* CHistoryData::CopyExtra(HISTEXTRA* phextCur) const
{
    const HISTEXTRA* phext;
    for (phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFast())
    {
        if (phext->vtExtra != VT_EMPTY) {
            TraceMsg(DM_HISTEXTRA, "CHD::CopyExtra copying vt=%d id=%d %d bytes",
                    phext->vtExtra, phext->idExtra, phext->cbExtra);
            memcpy(phextCur, phext, phext->cbExtra);
            phextCur = phextCur->GetNextFastForSave();
        } else {
            TraceMsg(DM_HISTEXTRA, "CHD::CopyExtra skipping vt=%d id=%d %d bytes",
                    phext->vtExtra, phext->idExtra, phext->cbExtra);
        }
    }

    return phextCur;
}

CHistoryData* CHistoryData::s_AllocateHeaderInfo(UINT cbExtra, const HISTDATA* phdPrev, ULONG* pcbTotal)
{
    DWORD cbTotal = SIZEOF(HISTDATA) + SIZEOF(DWORD) + cbExtra;

    LPHISTDATA phdNew = (LPHISTDATA)LocalAlloc(LPTR, cbTotal);
    if (phdNew) {
        if (phdPrev) {
            *phdNew = *phdPrev; // Copy all the field
        }
        phdNew->cbSize = SIZEOF(HISTDATA);
        phdNew->cbVer = HISTDATA_VER;
        *pcbTotal = cbTotal;
    }

    return phdNew;
}

//
// Returns the total size of extra data (exclude VT_EMPTY)
//
UINT CHistoryData::GetTotalExtraSize() const
{
    const HISTEXTRA* phext;
    UINT cbTotal = 0;
    for (phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFast())
    {
        if (phext->vtExtra != VT_EMPTY) {
            cbTotal += phext->cbExtra;
        }
    }

    return cbTotal;
}

HRESULT CEnumSTATURL::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumSTATURL::Reset(void)
{
    if(m_hEnum)
    {
        FindCloseUrlCache(m_hEnum);
        m_hEnum = NULL;
    }

    if(m_poszFilter)
    {
        LocalFree(m_poszFilter);
        m_poszFilter = NULL;
    }

    if(m_lpCEI)
    {
        LocalFree(m_lpCEI);
        m_lpCEI = NULL;
    }

    m_dwFilter = 0;


    return S_OK;
}

HRESULT CEnumSTATURL::Clone(IEnumSTATURL ** ppenum)
{
    return E_NOTIMPL;
}

//  IEnumSTATURL methods

HRESULT CEnumSTATURL::SetFilter(LPCWSTR poszFilter, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if(poszFilter)
    {
        m_poszFilter = StrDupW(poszFilter);
        if (!m_poszFilter)
        {
            hr = E_OUTOFMEMORY;
            goto quit;
        }

    }

    m_dwFilter = dwFlags;

quit:

    return hr;

}

const HISTEXTRA * CHistoryData::_FindExtra(UINT idExtra) const
{
    for (const HISTEXTRA* phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFastForSave())
    {
        if (phext->idExtra == idExtra) {
            return phext;
        }
    }

    return NULL;
}

CHistoryData* CHistoryData::s_GetHistoryData(LPINTERNET_CACHE_ENTRY_INFO lpCEI)
{
    CHistoryData* phd = (CHistoryData*)lpCEI->lpHeaderInfo;
    if (phd && phd->_IsOldHistory()) {
        TraceMsg(DM_TRACE, "CHistoryData::GetHistoryData found old header. Ignore");
        phd = NULL;
    }

    if (phd && phd->cbVer != HISTDATA_VER) {
        TraceMsg(DM_TRACE, "CHistoryData::GetHistoryData found old header (%d). Ignore",
                 phd->cbVer);
        phd = NULL;
    }

    return phd;
}

BOOL CHistoryData::_HasFragment(LPCTSTR pszFragment) const
{
    BOOL fHas = FALSE;
    const HISTEXTRA* phext = _FindExtra(PID_INTSITE_FRAGMENT);

    if (phext) {
        for (LPCTSTR psz=(LPCTSTR)(phext->abExtra); *psz ; psz += lstrlen(psz)+1) {
            if (StrCmp(psz, pszFragment)==0) {
                fHas = TRUE;
                break;
            }
        }
    }

    return fHas;
}

void CHistoryData::_GetTitle(LPTSTR szTitle, UINT cchMax) const
{
    szTitle[0] = '\0';
    const HISTEXTRA* phext = _FindExtra(PID_INTSITE_TITLE);
    if (phext && phext->vtExtra == VT_LPSTR) {
        StringCchCopy(szTitle, cchMax, (LPCTSTR)phext->abExtra);
    }
}


#ifdef USE_NEW_HISTORYDATA
#include "urlprop2.cpp"
#endif // USE_NEW_HISTORYDATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\url.cpp ===
/*
 * url.cpp - IUniformResourceLocator implementation for InternetShortcut class.
 */


/* Headers
 **********/

#include "priv.h"
#pragma hdrstop
#define INC_OLE2
#include "intshcut.h"


/* Module Constants
 *******************/

const TCHAR c_szURLPrefixesKey[]        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes");
const TCHAR c_szDefaultURLPrefixKey[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix");

// DPA array that holds the IURLSearchHook Pointers
static HDPA g_hdpaHooks = NULL;

// CURRENT_USER
static const TCHAR c_szURLSearchHook[] = TSZIEPATH TEXT("\\URLSearchHooks");


/***************************** Private Functions *****************************/


int DPA_DestroyURLSearchHooksCallback(LPVOID p, LPVOID d)
{
    IURLSearchHook * psuh = (IURLSearchHook *)p;
    ASSERT(psuh);
    ATOMICRELEASET(psuh, IURLSearchHook);

    return 1; 
}

extern "C" {
    
void DestroyHdpaHooks()
{
    if (g_hdpaHooks)
    {
        ENTERCRITICAL;
        //---------------------------- Critical Section -------------------------
        HDPA hdpa = g_hdpaHooks;
        g_hdpaHooks = NULL;
        //-----------------------------------------------------------------------
        LEAVECRITICAL;
        if (hdpa)
        {
            DPA_DestroyCallback(hdpa, DPA_DestroyURLSearchHooksCallback, 0);
            hdpa = NULL;
        }
    }
}

}

HRESULT InvokeURLSearchHook(IURLSearchHook * pusHook, LPCTSTR pcszQuery, LPTSTR pszResult, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(pusHook);
    WCHAR szSearchURL[MAX_URL_STRING]; 

    SHTCharToUnicode(pcszQuery, szSearchURL, ARRAYSIZE(szSearchURL));

    // if we can get an IURLSearchHook2, we'll pass in the
    // search context, otherwise we'll just do without

    IURLSearchHook2 * pUSH2 = NULL;
    hr = pusHook->QueryInterface(IID_IURLSearchHook2, (void **)&pUSH2);
    if (SUCCEEDED(hr))
    {
        RIP(pUSH2 != NULL);
        hr = pUSH2->TranslateWithSearchContext(szSearchURL, ARRAYSIZE(szSearchURL), pSC);
        pUSH2->Release();
    }
    else
    {
        hr = pusHook->Translate(szSearchURL, ARRAYSIZE(szSearchURL));
    }
            
    // In case the URLSearchHook worked, convert result to TCHAR
    // This includes two cases: S_OK and S_FALSE
    if (SUCCEEDED(hr))
    {
        //WARNING: (dli) Assuming pszResult size = MAX_URL_STRING 
        SHUnicodeToTChar(szSearchURL, pszResult, MAX_URL_STRING);
    }

    return hr;    
}


/* 
 * Returns: 
 * S_OK         Search handled completely, pszResult has the full URL to browse to. 
 * 0x00000000   Stop running any further IURLSearchHooks and pass this URL back to 
 *              the browser for browsing.
 *
 * S_FALSE      Query has been preprocessed, pszResult has the result of the preprocess, 
 * 0x00000001   further search still needed. Go on executing the rest of the IURLSearchHooks 
 *              The preprocessing steps can be: 1. replaced certain characters
 *                                              2. added more hints 
 *
 * E_ABORT      Search handled completely, stop running any further IURLSearchHooks, 
 * 0x80004004   but NO BROWSING NEEDED as a result, pszResult is a copy of pcszQuery. 
 *              FEATURE: This is not fully implemented, yet, making IURLQualify return this
 *              involves too much change. 
 * 
 * E_FAIL       This Hook was unsuccessful. Search not handled at all, pcszQueryURL has the 
 * 0x80004005   query string. Please go on running other IURLSearchHooks. 
 * return
 */

HRESULT TryURLSearchHooks(LPCTSTR pcszQuery, LPTSTR pszResult, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    
    TCHAR szNewQuery[MAX_URL_STRING];
    StrCpyN(szNewQuery, pcszQuery, ARRAYSIZE(szNewQuery));

    int ihdpa;
    for (ihdpa = 0; ihdpa < (g_hdpaHooks ? DPA_GetPtrCount(g_hdpaHooks) : 0); ihdpa++)
    {
        IURLSearchHook * pusHook;
        pusHook = (IURLSearchHook *) DPA_GetPtr(g_hdpaHooks, ihdpa);
        if (!pusHook)
            return E_FAIL;
        hr = InvokeURLSearchHook(pusHook, szNewQuery, pszResult, pSC);
        if ((hr == S_OK) || (hr == E_ABORT))
            break;
        else if (hr == S_FALSE)
            StrCpyN(szNewQuery, pszResult, ARRAYSIZE(szNewQuery));
    }

    return hr;
}


void InitURLSearchHooks()
{
    HDPA hdpa = DPA_Create(4);
    
    // We need to look in LOCAL_MACHINE if this registry entry doesn't exist in CURRENT_USER.
    // The installer needs to install the values into LOCAL_MACHINE so they are accessable
    // to all users.  Then anyone wanting to modify the value, will need to determine if they
    // want to add it to a specific user's CURRENT_USER or modify the LOCAL_MACHINE value to 
    // apply the change to all users.  (bryanst - #6722)
    HUSKEY hkeyHooks;
    if ((hdpa) && (SHRegOpenUSKey(c_szURLSearchHook, KEY_READ, NULL, &hkeyHooks, FALSE) == ERROR_SUCCESS))
    {    
        TCHAR szCLSID[GUIDSTR_MAX];
        DWORD dwccCLSIDLen;
        LONG lEnumReturn;
        DWORD dwiValue = 0;
        
        do {
            dwccCLSIDLen = ARRAYSIZE(szCLSID);
            lEnumReturn = SHRegEnumUSValue(hkeyHooks, dwiValue, szCLSID, &dwccCLSIDLen, 
                                       NULL, NULL, NULL, SHREGENUM_DEFAULT);
            if (lEnumReturn == ERROR_SUCCESS)
            {
                CLSID clsidHook;
                if (SUCCEEDED(SHCLSIDFromString(szCLSID, &clsidHook)))
                {
                    IURLSearchHook * pusHook;
                    HRESULT hr = CoCreateInstance(clsidHook, NULL, CLSCTX_INPROC_SERVER, 
                                                  IID_PPV_ARG(IURLSearchHook, &pusHook));
        
                    if (SUCCEEDED(hr))
                        DPA_AppendPtr(hdpa, pusHook);
                }   
            }
            dwiValue++;            
        } while (lEnumReturn == ERROR_SUCCESS);
        
        SHRegCloseUSKey(hkeyHooks);
    }
    
    ENTERCRITICAL;
    //---------------------------- Critical Section --------------------------
    if (!g_hdpaHooks)
    {
        g_hdpaHooks = hdpa;
        hdpa = NULL;
    }
    //------------------------------------------------------------------------
    LEAVECRITICAL;
    
    if (hdpa)
    {
        DPA_DestroyCallback(hdpa, DPA_DestroyURLSearchHooksCallback, 0);
        hdpa = NULL;
    }
}

    
HRESULT ApplyURLSearch(LPCTSTR pcszQuery, LPTSTR pszTranslatedUrl, ISearchContext * pSC)
{
    if (!g_hdpaHooks)
        InitURLSearchHooks();
    
    return TryURLSearchHooks(pcszQuery, pszTranslatedUrl, pSC);
}

/*----------------------------------------------------------
Purpose: This function qualifies a string as a URL.  Strings
         such as "www.foo.com" would have the scheme guessed
         if the correct flags are given.  Local paths are 
         converted to "file:" URLs.

         pszTranslatedURL may point to the same buffer as 
         pcszURL.

         If the given string is already a URL (not necessarily
         canonicalized, though), this function will not touch it, 
         unless UQF_CANONICALIZE is set, in which case the string 
         will be canonicalized.

Returns: S_OK or S_FALSE means we filled in pszTranslatedURL.
         S_OK means we altered the URL to qualify it too.
         various failure codes too

Cond:    --
*/
SHDOCAPI
IURLQualifyWithContext(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    IN  DWORD cchTranslatedURL,
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected,
    ISearchContext *  pSC)
{
    HRESULT hres = S_FALSE;
    DWORD cchSize;

    SHSTR strOut;
    BOOL bWasCorrected = FALSE; 

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszTranslatedURL, TCHAR, MAX_URL_STRING));

    if (pbWasSearchURL)
        *pbWasSearchURL = FALSE;

    // Special cases: URLs of the form <drive>:<filename>
    //                URLs of the form \<filename>
    // we'll assume that if the second character is a : or |, this is an url of
    // that form, and we will guess "file://" for the prefix.
    // we'll assume any url that begins with a single \ is a file: url
 
    // NOTE: We do this here because these are cases where the protocol is 
    // left off, and is likely to be incorrectly guessed, such as a 
    // relative path \data\ftp\docs, would wrongly be turned 
    // into "ftp://\data\ftp\docs".
 

    // Note: PathIsURL returns TRUE for non-canonicalized URLs too
    if (PathIsURL(pcszURL))
    {
        LPCWSTR pcszTemp = pcszURL;
        cchSize = MAX_URL_STRING;
        if (IsFlagSet(dwFlags, UQF_AUTOCORRECT))
        {
            hres = UrlFixup(pcszURL, pszTranslatedURL, cchSize);
            if (hres == S_OK)
            {
                bWasCorrected = TRUE;
                pcszTemp = pszTranslatedURL;
            }
        }

        if (dwFlags & UQF_CANONICALIZE)
            hres = UrlCanonicalize(pcszTemp, pszTranslatedURL, &cchSize, 0);
        else if (pszTranslatedURL != pcszTemp)
            StrCpyN(pszTranslatedURL, pcszTemp, cchTranslatedURL);

        hres = S_OK;
    }
    else
    {
        // Look for file paths
        if (IsFlagClear(dwFlags, UQF_IGNORE_FILEPATHS) && ( pcszURL[1] == TEXT(':') || pcszURL[1] == TEXT('|') || pcszURL[0] == TEXT('\\')))
        {
            hres = strOut.SetSize(MAX_PATH);

            if(SUCCEEDED(hres))
            {
                //  SHSTRs have a size granularity, so the size
                //  will be equal to or greater than what was set.
                //  this means we need to get it our self.
                DWORD cchOut = strOut.GetSize();
                TCHAR szCurrentDir[MAX_PATH];

                //
                //  APPCOMPAT - IE30 compatibility - zekel 8-Jan-97
                //  we need to GetCurrentDirectory() in order to
                //  put a default drive letter on the path
                //  if necessary.  
                //

                if(GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir))
                    PathCombine(strOut.GetInplaceStr(), szCurrentDir, pcszURL);
                else
                    hres = strOut.SetStr(pcszURL);

                if(SUCCEEDED(hres))
                {
                    hres = UrlCreateFromPath(strOut, strOut.GetInplaceStr(), &cchOut, 0);
                    if (E_POINTER == hres && SUCCEEDED(hres = strOut.SetSize(cchOut)))
                    {
                        cchOut = strOut.GetSize();
                        hres = UrlCreateFromPath(strOut, strOut.GetInplaceStr(), &cchOut, 0);
                    }
                }
            }
        }
        else if (SUCCEEDED(hres = strOut.SetSize(MAX_URL_STRING)))
        {
            //  all the Apply*() below rely on MAX_URL_STRING

            // No; begin processing general-case URLs.  Try to guess the
            // protocol or resort to the default protocol.

            DWORD cchOut = strOut.GetSize();
            if (IsFlagSet(dwFlags, UQF_GUESS_PROTOCOL))
                hres = UrlApplyScheme(pcszURL, strOut.GetInplaceStr(), &cchOut, URL_APPLY_GUESSSCHEME);

            //
            // Try to auto-correct the protocol
            //
            if (hres == S_FALSE &&
                IsFlagSet(dwFlags, UQF_AUTOCORRECT))
            {
                hres = UrlFixup(pcszURL, strOut.GetInplaceStr(), strOut.GetSize());
                bWasCorrected = (hres == S_OK);
            }

            if (hres == S_FALSE &&
                IsFlagSet(dwFlags, UQF_USE_DEFAULT_PROTOCOL)) 
            {
                // run the search with or without the search context
                hres = ApplyURLSearch(pcszURL, strOut.GetInplaceStr(), pSC);
                if (SUCCEEDED(hres) && pbWasSearchURL) {
                    *pbWasSearchURL = TRUE;
                }
                
                // If that fails, then tack on the default protocol
                if (FAILED(hres) || hres == S_FALSE)
                {
                    cchOut = strOut.GetSize();
                    hres = UrlApplyScheme(pcszURL, strOut.GetInplaceStr(), &cchOut, URL_APPLY_DEFAULT);
                }
            }

            // Did the above fail?
            if (S_FALSE == hres)
            {
                // Yes; return the real reason why the URL is bad
                hres = URL_E_INVALID_SYNTAX;
            }
            else if (dwFlags & UQF_CANONICALIZE)
            {
                // No; canonicalize
                cchSize = strOut.GetSize();
                hres = UrlCanonicalize(strOut, strOut.GetInplaceStr(), &cchSize, 0);
            }
        }

        if (SUCCEEDED(hres))
        {
            StrCpyN(pszTranslatedURL, strOut, cchTranslatedURL);
        }
    }

    if (pbWasCorrected)
        *pbWasCorrected = bWasCorrected;

    return hres;
}

SHDOCAPI
IURLQualify(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected)
{
    //  this is exported
    return IURLQualifyWithContext(pcszURL, dwFlags, MAX_URL_STRING, pszTranslatedURL, pbWasSearchURL, pbWasCorrected, NULL);
}


/***************************** Exported Functions ****************************/


STDAPI
URLQualifyA(
    LPCSTR pszURL, 
    DWORD  dwFlags,         // UQF_*
    LPSTR *ppszOut)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRING_PTRA(pszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszOut, LPSTR));

    *ppszOut = NULL;

    WCHAR szTempTranslatedURL[MAX_URL_STRING];
    WCHAR szURL[MAX_URL_STRING];

    SHAnsiToUnicode(pszURL, szURL, ARRAYSIZE(szURL));

    hres = IURLQualifyWithContext(szURL, dwFlags, ARRAYSIZE(szTempTranslatedURL), szTempTranslatedURL, NULL, NULL, NULL);

    if (SUCCEEDED(hres))
    {
        CHAR szOut[MAX_URL_STRING];

        SHUnicodeToAnsi(szTempTranslatedURL, szOut, ARRAYSIZE(szOut));

        *ppszOut = StrDupA(szOut);

        if (!*ppszOut)
            hres = E_OUTOFMEMORY;
    }

    return hres;
}


STDAPI
URLQualifyW(
    LPCWSTR pszURL, 
    DWORD  dwFlags,         // UQF_*
    LPWSTR *ppszOut)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRING_PTRW(pszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszOut, LPWSTR));

    WCHAR szTempTranslatedURL[MAX_URL_STRING];

    hres = IURLQualify(pszURL, dwFlags, szTempTranslatedURL, NULL, NULL);

    if (SUCCEEDED(hres))
    {
        *ppszOut = StrDup(szTempTranslatedURL);

        if (!*ppszOut)
            hres = E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urltrack.cpp ===
/*-------------------------------------------------------*/
//Copyright (c) 1997  Microsoft Corporation
//
//Module Name: Url Tracking Log Interfaces
//
//    Urltrack.cpp
//
//
//Author:
//
//    Pei-Hwa Lin (peihwal)  19-March-97
//
//Environment:
//
//    User Mode - Win32
//
//Revision History:
//    5/13/97   due to cache container type change, allow
//              OPEN_ALWAYS when CreateFile
//    5/14/97   remove IsOnTracking, TRACK_ALL, unused code
/*-------------------------------------------------------*/

#include "priv.h"
#include <wininet.h>
#include "basesb.h"
#include "bindcb.h"
#include <strsafe.h>
const WCHAR c_szPropURL[] = L"HREF";
const WCHAR c_szProptagName[] = L"Item";
const TCHAR c_szLogContainer[] = TEXT("Log");

#define MY_MAX_STRING_LEN           512



//---------------------------------------------------------------------------
//
// IUnknown interfaces
//
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IUrlTrackingStg))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IUrlTrackingStg *);
        hr = S_OK;

    }

    return hr;
}


ULONG
CUrlTrackingStg :: AddRef(void)
{
    _cRef ++;
    return _cRef;
}

ULONG
CUrlTrackingStg :: Release(void)
{

    ASSERT(_cRef > 0);

    _cRef--;

    if (!_cRef)
    {
        //time to go bye bye
        delete this;
        return 0;
    }

    return _cRef;
}

//---------------------------------------------------------------------------
//
// C'tor/D'tor
//
//---------------------------------------------------------------------------
CUrlTrackingStg :: CUrlTrackingStg()
{

    _hFile = NULL;
    _pRecords = NULL;
    _lpPfx = NULL;
}

CUrlTrackingStg :: ~CUrlTrackingStg()
{
    // browser exit
    while (_pRecords)
    {
        OnUnload(_pRecords->pthisUrl);
    };

    if (_lpPfx)
    {
        GlobalFree(_lpPfx);
        _lpPfx = NULL;
    }

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = NULL;
    }
}


//---------------------------------------------------------------------------
//
// Helper functions
//
//---------------------------------------------------------------------------
LRecord *
CUrlTrackingStg :: AddNode()
{
    LRecord* pTemp;
    LRecord* pNew = NULL;
    
    pNew = (LRecord *)LocalAlloc(LPTR, sizeof(LRecord));
    if (pNew == NULL)
        return NULL;
    
    pNew->pNext = NULL;
    if (_pRecords == NULL)
    {
        //special case for first node
        _pRecords = pNew;
    }
    else
    {
        for (pTemp = _pRecords; pTemp->pNext; pTemp = pTemp->pNext);
        pTemp->pNext = pNew;
    }
    
    return pNew;
}

void
CUrlTrackingStg :: DeleteFirstNode()
{
    LRecord *pTemp;

    if (!_pRecords)
        return;

    pTemp = _pRecords;
    _pRecords = pTemp->pNext;
    delete [] pTemp->pthisUrl;
    LocalFree(pTemp);
    pTemp = NULL;
    return;
}

void
CUrlTrackingStg :: DeleteCurrentNode(LRecord *pThis)
{
    LRecord *pPrev;
    
    if (_pRecords == pThis)
    {
        DeleteFirstNode();
        return;
    }

    pPrev = _pRecords;
    do
    {
        if (pPrev->pNext == pThis)
        {
            pPrev->pNext = pThis->pNext;
            delete [] pThis->pthisUrl;
            LocalFree(pThis);
            pThis = NULL;
            break;
        }
        pPrev = pPrev->pNext;
    }
    while (pPrev);

    return;
}

//
// return Current node by comparing url strings
//
LRecord*
CUrlTrackingStg :: FindCurrentNode
(
    IN  LPCTSTR       lpUrl
)
{
    LRecord* pThis = NULL;

    ASSERT(_pRecords);
    if (!_pRecords)                 // missed OnLoad
        return NULL;

    pThis = _pRecords;
    do
    {
        if (!StrCmpI(lpUrl, pThis->pthisUrl))
            break;

        pThis = pThis->pNext;
    }
    while (pThis);

    return pThis;
}

void
CUrlTrackingStg :: DetermineAppModule()
{
    TCHAR   szModule[MAX_PATH];
    LPTSTR  szExt;
        
    if (GetModuleFileName(NULL, szModule, MAX_PATH))        
    {
        szExt = PathFindExtension(szModule);
        TraceMsg(0, "tracking: AppModule %s", szModule);
            
        if (StrCmpI(szExt, TEXT(".SCR")) == 0)
            _fScreenSaver = TRUE;
        else
            _fScreenSaver = FALSE;
                
    }
    else
        _fScreenSaver = FALSE;

    _fModule = TRUE;
}
            
//---------------------------------------------------------------------------
//
// OnLoad(LPTSTR lpUrl, BRMODE context, BOOL fUseCache)
//      a new page is loaded
//      this function will remember time entering this page, context browsing
//      from and page URL string.
//      (lpUrl does NOT contain "track:" prefix)
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: OnLoad
(
    IN  LPCTSTR    lpUrl,
    IN  BRMODE     ContextMode,
    IN  BOOL       fUseCache
)
{
    HRESULT     hr = E_OUTOFMEMORY;
    SYSTEMTIME  st;
    LRecord*    pNewNode = NULL;

    GetLocalTime(&st);

    pNewNode = AddNode();
    if (!pNewNode)
        return hr;

    int cch = lstrlen(lpUrl)+1;
    pNewNode->pthisUrl = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
    if (pNewNode->pthisUrl == NULL)
        return hr;

    // store log info
    hr = StringCchCopy(pNewNode->pthisUrl, cch, lpUrl);
    if (SUCCEEDED(hr))
    {
        if (!_fModule)
            DetermineAppModule();

        // if it's from SS, the fullscreen flag will be set,
        // need to override ContextMode passed in
        if (_fScreenSaver)
            pNewNode->Context = BM_SCREENSAVER;
        else
            pNewNode->Context = (ContextMode > BM_THEATER) ? BM_UNKNOWN : ContextMode;

        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
        DWORD       cbcei = MAX_CACHE_ENTRY_INFO_SIZE;

        if (GetUrlCacheEntryInfo(lpUrl, pcei, &cbcei))
            pNewNode->fuseCache = (pcei->dwHitRate - 1) ? TRUE : FALSE;     // off 1 by download
        else
            pNewNode->fuseCache = 0;

        SystemTimeToFileTime(&st, &(pNewNode->ftIn));
    }

    return hr; 
}



//---------------------------------------------------------------------------
//
// OnUnLoad(LPTSTR lpUrl)
//      current page is unloaded
//      1)find url cache entry and get file handle
//      2)calculate total time duration visiting this page
//      3)commit delta log string to file cache entry
//      (lpUrl contains "Tracking: " prefix)
//
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: OnUnload
(
    IN  LPCTSTR   lpUrl
)
{
    HRESULT     hr = E_FAIL;
    LPTSTR       lpPfxUrl = NULL;
    LRecord*    pNode = NULL;;
    SYSTEMTIME  st;
    LPINTERNET_CACHE_ENTRY_INFO pce = NULL;
    TCHAR       lpFile[MAX_PATH];
    

    // 
    GetLocalTime(&st);

    pNode = FindCurrentNode(lpUrl);
    if (!pNode)
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (cannot find internal tracking log");
        return hr;
    }

    //QueryCacheEntry() and OpenLogFile() can be combined in one if CacheAPI supports
    //WriteUrlCacheEntryStream()
    ConvertToPrefixedURL(lpUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        return E_OUTOFMEMORY;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (cannot find url cache entry)");
        DeleteCurrentNode(pNode);
    
        // free pce
        GlobalFree(lpPfxUrl);
        lpPfxUrl = NULL;
        return hr;
    }

    // work around -- begin
    hr = WininetWorkAround(lpPfxUrl, pce->lpszLocalFileName, &lpFile[0]);
    if (FAILED(hr))
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (failed to work around wininet)");
        DeleteCurrentNode(pNode);
        if (_hFile)
        {
            CloseHandle(_hFile);
            _hFile = NULL;
        }
        GlobalFree(lpPfxUrl);
        lpPfxUrl = NULL;
        return hr;
    }
    
    hr = UpdateLogFile(pNode, &st);

    // commit change to cache
    if(SUCCEEDED(hr))
    {
        hr = (CommitUrlCacheEntry(lpPfxUrl, 
                lpFile,    //
                pce->ExpireTime,                    //ExpireTime
                pce->LastModifiedTime,              //LastModifiedTime
                pce->CacheEntryType,
                NULL,                               //lpHeaderInfo
                0,                                  //dwHeaderSize
                NULL,                               //lpszFileExtension
                0) ) ?                              //reserved
                S_OK : E_FAIL;
    }
    
    // work around -- end

    DeleteCurrentNode(pNode);
    
    // free pce
    GlobalFree(pce);
    pce = NULL;

    GlobalFree(lpPfxUrl);
    lpPfxUrl = NULL;

    return hr;
}

//---------------------------------------------------------------------------
// 
// Cache helper funcitons
// This is a workaround for Wininet cache
// Later when we commit change to URL cache will fail if localFile size is changed
//  [IN] lpszSourceUrlName and lpszLocalFileName remain the same when calling 
//       this routine
//  [OUT] new local file name 
//
//---------------------------------------------------------------------------
HRESULT CUrlTrackingStg :: WininetWorkAround(LPCTSTR lpszUrl, LPCTSTR lpOldFile, LPTSTR lpFile)
{
    HRESULT  hr = E_FAIL;

    ASSERT(!_hFile);

    if (!CreateUrlCacheEntry(lpszUrl, 512, TEXT("log"), lpFile, 0))
        return E_FAIL;
    
    if (lpOldFile)
    {
        if (!CopyFile(lpOldFile, lpFile, FALSE))
            return E_FAIL;

        DeleteFile(lpOldFile);
    }

    _hFile = OpenLogFile(lpFile);

	if (_hFile != INVALID_HANDLE_VALUE)
		_hFile = NULL;

    return (_hFile) ? S_OK : E_FAIL;        
}

LPINTERNET_CACHE_ENTRY_INFO
CUrlTrackingStg :: QueryCacheEntry
(
    IN  LPCTSTR     lpUrl
)
{
    // get cache entry info
    LPINTERNET_CACHE_ENTRY_INFO       lpCE = NULL;
    DWORD    dwEntrySize;
    BOOL     bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)GlobalAlloc(LPTR, MAX_CACHE_ENTRY_INFO_SIZE);
    if (lpCE)
    {
        dwEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;

        while (!(bret = GetUrlCacheEntryInfo(lpUrl, lpCE, &dwEntrySize)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                GlobalFree(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFO)GlobalAlloc(LPTR, dwEntrySize);
                if (!lpCE)
                    break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        GlobalFree(lpCE);
        lpCE = NULL;
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;

}


//---------------------------------------------------------------------------
// 
// File helper funcitons
//
//---------------------------------------------------------------------------

//
// 1)open log file 
// 2)move file pointer to end of file
//
HANDLE
CUrlTrackingStg :: OpenLogFile
(
    IN LPCTSTR  lpFileName
)
{
    HANDLE hFile = NULL;
    
    hFile = CreateFile(lpFileName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,  // | FILE_FLAG_SEQUENTIAL_SCAN,  
            NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;        

    return hFile;
    
}

const TCHAR c_szLogFormat[] = TEXT("hh':'mm':'ss");
const LPTSTR c_szMode[] = { TEXT("N"),       // normal browsing
                            TEXT("S"),       // screen saver
                            TEXT("D"),       // desktop component
                            TEXT("T"),       // theater mode
                            TEXT("U"),       // unknown
                          };     

HRESULT
CUrlTrackingStg :: UpdateLogFile
(
    IN LRecord*     pNode,
    IN SYSTEMTIME*  pst
)
{
    FILETIME    ftOut;
    DWORD       dwWritten= 0;
    HRESULT     hr = E_FAIL;
    ULARGE_INTEGER ulIn, ulOut, ulTotal;

    ASSERT(_hFile);
    
    // calculate delta of time
    SystemTimeToFileTime(pst, &ftOut);

    // #34829: use 64-bit calculation
	ulIn.LowPart = pNode->ftIn.dwLowDateTime;
	ulIn.HighPart = pNode->ftIn.dwHighDateTime;
	ulOut.LowPart = ftOut.dwLowDateTime;
	ulOut.HighPart = ftOut.dwHighDateTime;
	QUAD_PART(ulTotal) = QUAD_PART(ulOut) - QUAD_PART(ulIn);
    
    ftOut.dwLowDateTime = ulTotal.LowPart;
    ftOut.dwHighDateTime = ulTotal.HighPart;

    // log string: timeEnter+Duration
    SYSTEMTIME  stOut, stIn;
    TCHAR   lpLogString[MY_MAX_STRING_LEN];
    TCHAR   pTimeIn[10], pTimeOut[10];
    
    FileTimeToSystemTime(&ftOut, &stOut);
    FileTimeToSystemTime(&(pNode->ftIn), &stIn);
    
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stIn, c_szLogFormat, pTimeIn, 10);
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stOut, c_szLogFormat, pTimeOut, 10);
    // #34832: add Date in logs
    // #28266: add LFCR in logs
    lpLogString[0] = '\0';
    hr = StringCchPrintf(lpLogString, ARRAYSIZE(lpLogString), TEXT("%s %d %.2d-%.2d-%d %s %s\r\n"), 
                                c_szMode[pNode->Context], 
                                pNode->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut);

    if (SUCCEEDED(hr))
    {
        // move file pointer to end
        if (0xFFFFFFFF == SetFilePointer(_hFile, 0, 0, FILE_END))
        {
            CloseHandle(_hFile);
            _hFile = NULL;
            return hr;
        }
        
        // write ANSI string to file
        char szLogInfo[MY_MAX_STRING_LEN];

        SHTCharToAnsi(lpLogString, szLogInfo, ARRAYSIZE(szLogInfo));
        hr = (WriteFile(_hFile, szLogInfo, lstrlenA(szLogInfo), &dwWritten, NULL)) ?
                S_OK : E_FAIL;
           
        CloseHandle(_hFile);
        _hFile = NULL;
    }

    return hr;  

}

//-----------------------------------------------------------------------------
//
// ReadTrackingPrefix
//
// read prefix string from registry
//-----------------------------------------------------------------------------
void
CUrlTrackingStg :: ReadTrackingPrefix(void)
{
    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFO cInfo;
        TCHAR  szBuffer[MAX_PATH+MAX_PATH];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainer(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!StrCmpI(ContainerInfo.cInfo.lpszName, c_szLogContainer))
            {
                DWORD cch = lstrlen(ContainerInfo.cInfo.lpszCachePrefix)+1;
                ASSERT(ContainerInfo.cInfo.lpszCachePrefix[0]);

                _lpPfx = (LPTSTR)GlobalAlloc(LPTR, cch * sizeof(TCHAR));
                if (!_lpPfx)
                    SetLastError(ERROR_OUTOFMEMORY);

                StringCchCopy(_lpPfx, cch, ContainerInfo.cInfo.lpszCachePrefix);
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainer(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                //  This code used to check GetLastError() for ERROR_NO_MORE_ITEMS before
                //  it would break.  Well, that could put us in an infinite loop if the
                //  reason for failure were something else (like insufficient buffer) because
                //  wininet would not move forward in it's enumeration and we would not
                //  have done anything to address the error.
                break;
            }

        }

        FindCloseUrlCache(hEnum);
    }
}


// caller must free lplpPrefixedUrl
BOOL 
CUrlTrackingStg :: ConvertToPrefixedURL(LPCTSTR lpszUrl, LPTSTR *lplpPrefixedUrl)
{
    BOOL    bret = FALSE;

    ASSERT(lpszUrl);
    if (!lpszUrl)
        return bret;

    //ASSERT(lplpPrefixedUrl);

    if (!_lpPfx)
        ReadTrackingPrefix();
    
    if (_lpPfx)
    {
        int len = lstrlen(lpszUrl) + lstrlen(_lpPfx) + 1;
        
        *lplpPrefixedUrl = (LPTSTR)GlobalAlloc(LPTR, len * sizeof(TCHAR));
        if (*lplpPrefixedUrl)
        {
            bret = SUCCEEDED(StringCchPrintf(*lplpPrefixedUrl, len, TEXT("%s%s"), _lpPfx, lpszUrl));
        }
    }

    return bret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urlprop.h ===
/*
 * urlprop.h - URL properties class implementation description.
 */

#ifndef _URLPROP_H_
#define _URLPROP_H_

#include "propstg.h"

#ifdef __cplusplus

// URL Property object

class URLProp : public IPropertyStorage
    {
private:
    ULONG       m_cRef;
    CLSID       m_clsid;
    FMTID       m_fmtid;
    DWORD       m_grfFlags;

    // private methods

protected:
    HPROPSTG    m_hstg;
    FILETIME    m_ftModified;
    FILETIME    m_ftCreated;
    FILETIME    m_ftAccessed;

public:
    URLProp(void);
    virtual ~URLProp(void);

    // IUnknown methods
    
    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // IPropertyStorage methods

    virtual STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);
    virtual STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst);
    virtual STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    virtual STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    virtual STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    virtual STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    virtual STDMETHODIMP SetClass(REFCLSID clsid);
    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);
    virtual STDMETHODIMP Revert(void);
    virtual STDMETHODIMP Enum(IEnumSTATPROPSTG** ppenm);
    virtual STDMETHODIMP Stat(STATPROPSETSTG* pstatpsstg);
    virtual STDMETHODIMP SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime);

    // other methods
    
    virtual STDMETHODIMP Init(void);

    STDMETHODIMP GetProp(PROPID pid, LPTSTR pszBuf, int cchBuf);
    STDMETHODIMP GetProp(PROPID pid, int * piVal);
    STDMETHODIMP GetProp(PROPID pid, LPDWORD pdwVal);
    STDMETHODIMP GetProp(PROPID pid, WORD * pwVal);
    STDMETHODIMP GetProp(PROPID pid, IStream **ppStream);
    STDMETHODIMP SetProp(PROPID pid, LPCTSTR psz);
    STDMETHODIMP SetProp(PROPID pid, int iVal);
    STDMETHODIMP SetProp(PROPID pid, DWORD dwVal);
    STDMETHODIMP SetProp(PROPID pid, WORD wVal);
    STDMETHODIMP SetProp(PROPID pid, IStream *pStream);

    STDMETHODIMP IsDirty(void);

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCURLProp(const URLProp *pcurlprop);
#endif

    };

typedef URLProp * PURLProp;
typedef const URLProp CURLProp;
typedef const URLProp * PCURLProp;


// Internet Shortcut Property object

class IntshcutProp : public URLProp
    {

    typedef URLProp super;

private:
    TCHAR       m_szFile[MAX_PATH];

    // private methods

    STDMETHODIMP LoadFromFile(LPCTSTR pszFile);

public:
    IntshcutProp(void);
    ~IntshcutProp(void);

    // IPropertyStorage methods

    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);

    // other methods
    
    STDMETHODIMP Init(void);
    STDMETHODIMP InitFromFile(LPCTSTR pszFile);

    STDMETHODIMP SetFileName(LPCTSTR pszFile);
    STDMETHODIMP SetURLProp(LPCTSTR pszURL, DWORD dwFlags);
    STDMETHODIMP SetIDListProp(LPCITEMIDLIST pcidl);

    STDMETHODIMP SetProp(PROPID pid, LPCTSTR psz);
    STDMETHODIMP SetProp(PROPID pid, int iVal)          { return super::SetProp(pid, iVal); }
    STDMETHODIMP SetProp(PROPID pid, DWORD dwVal)       { return super::SetProp(pid, dwVal); }
    STDMETHODIMP SetProp(PROPID pid, WORD wVal)         { return super::SetProp(pid, wVal); }
    STDMETHODIMP SetProp(PROPID pid, IStream *pStream)  { return super::SetProp(pid, pStream); }

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntshcutProp(const IntshcutProp *pcisprop);
#endif

    };

typedef IntshcutProp * PIntshcutProp;
typedef const IntshcutProp CIntshcutProp;
typedef const IntshcutProp * PCIntshcutProp;

class Intshcut;

// Internet Site Property object

class IntsiteProp : public URLProp
    {
private:
    TCHAR       m_szURL[INTERNET_MAX_URL_LENGTH];
    Intshcut *  m_pintshcut;
    BOOL        m_fPrivate;

    // private methods

    STDMETHODIMP LoadFromDB(LPCTSTR pszURL);

public:
    IntsiteProp(void);
    ~IntsiteProp(void);

    // IPropertyStorage methods

    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);

    // other methods
    
    STDMETHODIMP Init(void);
    STDMETHODIMP InitFromDB(LPCTSTR pszURL, Intshcut * pintshcut, BOOL fPrivObj);

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntsiteProp(const IntsiteProp *pcisprop);
#endif

    };

typedef IntsiteProp * PIntsiteProp;
typedef const IntsiteProp CIntsiteProp;
typedef const IntsiteProp * PCIntsiteProp;


DWORD
SchemeTypeFromURL(
   LPCTSTR pszURL);

#endif  // __cplusplus


//
// Prototypes for all modules
//

#ifdef __cplusplus
extern "C" {
#endif

typedef const PARSEDURL CPARSEDURL;
typedef const PARSEDURL * PCPARSEDURL;

STDAPI
CIntshcutProp_CreateInstance(
   IN  LPUNKNOWN punkOuter, 
   IN  REFIID    riid, 
   OUT LPVOID *  ppvOut);

STDAPI
CIntsiteProp_CreateInstance(
   IN  LPUNKNOWN punkOuter, 
   IN  REFIID    riid, 
   OUT LPVOID *  ppvOut);


// Worker routines for updating the ini file corresponding to a shortcut

HRESULT 
ReadStringFromFile(IN  LPCTSTR    pszFile, 
                   IN  LPCTSTR    pszSectionName,
                   IN  LPCTSTR    pszName,
                   OUT LPWSTR *   ppwsz,
                   IN  CHAR *     pszBuf);

HRESULT 
ReadBStrFromFile(IN  LPCTSTR      pszFile, 
                 IN  LPCTSTR      pszSectionName,
                 IN  LPCTSTR      pszName,
                 OUT BSTR *       pBstr);

HRESULT
ReadUnsignedFromFile(
    IN  LPCTSTR pszFile,
    IN  LPCTSTR pszSectionName,
    IN  LPCTSTR pszName,
    OUT LPDWORD pdwVal);

HRESULT 
WriteGenericString(
    IN LPCTSTR pszFile, 
    IN LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPCWSTR pwsz);

HRESULT 
WriteSignedToFile(
    IN LPCTSTR  pszFile,
    IN LPCTSTR  pszSectionName,
    IN LPCTSTR  pszName,
    IN int      nVal);

HRESULT 
WriteUnsignedToFile(
    IN LPCTSTR  pszFile,
    IN LPCTSTR  pszSectionName,
    IN LPCTSTR  pszName,
    IN DWORD    nVal);

HRESULT 
ReadURLFromFile(
    IN  LPCTSTR  pszFile, 
    IN  LPCTSTR pszSectionName,
    OUT LPTSTR * ppsz);

HRESULT 
ReadBinaryFromFile(
   IN LPCTSTR pszFile,
   IN LPCTSTR pszSectionName,
   IN LPCTSTR pszName,
   IN LPVOID  pvData,
   IN DWORD   cbData);

HRESULT 
WriteBinaryToFile(
  IN LPCTSTR pszFile,
  IN  LPCTSTR pszSectionName,
  IN LPCTSTR pszName,
  IN LPVOID  pvData,
  IN DWORD   cbSize);

#define DeletePrivateProfileString(pszSection, pszKey, pszFile) \
WritePrivateProfileString(pszSection, pszKey, NULL, pszFile)
#define SHDeleteIniString(pszSection, pszKey, pszFile) \
           SHSetIniString(pszSection, pszKey, NULL, pszFile)
#ifdef __cplusplus
};  // extern "C"
#endif

#endif  // _URLPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urlprop.cpp ===
/*
* urlprop.cpp - Implementation for URLProp class.
*/


#include "priv.h"
#include <shsemip.h>  // SHIsConsistentPidl
#include "ishcut.h"

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

#define MAX_BUF_INT         (1 + 10 + 1)        // -2147483647

const TCHAR c_szIntshcut[]       = ISHCUT_INISTRING_SECTION;



#ifdef DEBUG

BOOL IsValidPCURLProp(PCURLProp pcurlprop)
{
    return (IS_VALID_READ_PTR(pcurlprop, CURLProp) &&
            (NULL == pcurlprop->m_hstg ||
             IS_VALID_HANDLE(pcurlprop->m_hstg, PROPSTG)));
}


BOOL IsValidPCIntshcutProp(PCIntshcutProp pcisprop)
{
    return (IS_VALID_READ_PTR(pcisprop, CIntshcutProp) &&
            IS_VALID_STRUCT_PTR(pcisprop, CURLProp));
}

BOOL IsValidPCIntsiteProp(PCIntsiteProp pcisprop)
{
    return (IS_VALID_READ_PTR(pcisprop, CIntsiteProp) &&
            IS_VALID_STRUCT_PTR(pcisprop, CURLProp));
}


#endif


BOOL AnyMeatW(LPCWSTR pcsz)
{
    ASSERT(! pcsz || IS_VALID_STRING_PTRW(pcsz, -1));
    
    return(pcsz ? StrSpnW(pcsz, L" \t") < lstrlenW(pcsz) : FALSE);
}


/*----------------------------------------------------------
Purpose: Read an arbitrary named string from the .ini file.

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT ReadStringFromFile(IN  LPCTSTR    pszFile, 
                           IN  LPCTSTR    pszSectionName,
                           IN  LPCTSTR    pszName,
                           OUT LPWSTR *   ppwsz,
                           IN  CHAR *     pszBuf)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PWSTR));
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * INTERNET_MAX_URL_LENGTH);
    if (*ppwsz)
    {
        DWORD cch;
        
        hres = S_OK;

        cch = SHGetIniString(pszSectionName, pszName,
            *ppwsz, INTERNET_MAX_URL_LENGTH, pszFile);
        if (0 == cch)                                
        {
            hres = S_FALSE;
            LocalFree(*ppwsz);
            *ppwsz = NULL;
        }
    }
    
    return hres;
}

/*----------------------------------------------------------
Purpose: Read an arbitrary named string from the .ini file.
         Return a BSTR

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT ReadBStrFromFile(IN  LPCTSTR      pszFile, 
                           IN  LPCTSTR    pszSectionName,
                           IN  LPCTSTR    pszName,
                           OUT BSTR *     pBStr)
{
    CHAR szTempBuf[INTERNET_MAX_URL_LENGTH];
    WCHAR *pwsz;
    HRESULT hres = E_OUTOFMEMORY;
    *pBStr = NULL;
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(IS_VALID_WRITE_PTR(pBStr, PWSTR));

    // (Pass in an empty string so we can determine from the return
    // value whether there is any text associated with this name.)
    hres = ReadStringFromFile(pszFile, pszSectionName, pszName, &pwsz, szTempBuf);
    if (S_OK == hres)                                
    {
        *pBStr = SysAllocString(pwsz);
        LocalFree(pwsz);
        pwsz = NULL;
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: read an arbitrary named unsigend int from the .ini file. note in order to implement
         ReadSignedFromFile one'll need to use ReadStringFromFile and then StrToIntEx. this is
         because GetPrivateProfileInt can't return a negative.

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT
ReadUnsignedFromFile(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPDWORD pdwVal)
{
    HRESULT hr;
    int     iValue;

    ASSERT(IS_VALID_STRING_PTR(pszFile,        -1));
    ASSERT(IS_VALID_STRING_PTR(pszSectionName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName,        -1));

    if (NULL == pdwVal)
        return E_INVALIDARG;
    *pdwVal = 0;

    hr     = S_OK;
    iValue = GetPrivateProfileInt(pszSectionName, pszName, 1, pszFile);
    if (1 == iValue) {
        iValue = GetPrivateProfileInt(pszSectionName, pszName, 2, pszFile);
        hr     = (2 != iValue) ? S_OK : S_FALSE;
        ASSERT(S_FALSE == hr || 1 == iValue);
    }

    if (S_OK == hr)
        *pdwVal = (DWORD)iValue;

    return hr;
}

/*----------------------------------------------------------
Purpose: Write number to URL (ini) file

*/
HRESULT WriteSignedToFile(IN LPCTSTR  pszFile,
                          IN LPCTSTR  pszSectionName,
                          IN LPCTSTR  pszName,
                          IN int      nVal)
{
    HRESULT hres;
    TCHAR szVal[MAX_BUF_INT];
    int cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    
    cch = wnsprintf(szVal, ARRAYSIZE(szVal), TEXT("%d"), nVal);
    ASSERT(cch > 0);
    ASSERT(cch < SIZECHARS(szVal));
    ASSERT(cch == lstrlen(szVal));
    
    hres = WritePrivateProfileString(pszSectionName, pszName, szVal,
        pszFile) ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write number to URL (ini) file

*/
HRESULT WriteUnsignedToFile(IN LPCTSTR  pszFile,
                            IN  LPCTSTR pszSectionName,
                            IN LPCTSTR  pszName,
                            IN DWORD    nVal)
{
    HRESULT hres;
    TCHAR szVal[MAX_BUF_INT];
    int cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    
    cch = wnsprintf(szVal, ARRAYSIZE(szVal), TEXT("%u"), nVal);
    ASSERT(cch > 0);
    ASSERT(cch < SIZECHARS(szVal));
    ASSERT(cch == lstrlen(szVal));
    
    hres = WritePrivateProfileString(pszSectionName, pszName, szVal,
        pszFile) ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write binary data to URL (ini) file

*/
HRESULT WriteBinaryToFile(IN LPCTSTR pszFile,
                          IN  LPCTSTR pszSectionName,
                          IN LPCTSTR pszName,
                          IN LPVOID  pvData,
                          IN DWORD   cbSize)
{
    HRESULT hres;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    hres = (WritePrivateProfileStruct(pszSectionName, pszName, pvData, cbSize, pszFile))
        ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the hotkey from the URL (ini) file

*/
HRESULT ReadBinaryFromFile(IN LPCTSTR pszFile,
                           IN LPCTSTR pszSectionName,
                           IN LPCTSTR pszName,
                           IN LPVOID  pvData,
                           IN DWORD   cbData)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    memset(pvData, 0, cbData);
    
    if (GetPrivateProfileStruct(pszSectionName, pszName, pvData, cbData, pszFile))
        hres = S_OK;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Real the URL from the URL (ini) file

*/
HRESULT 
ReadURLFromFile(
    IN  LPCTSTR  pszFile, 
    IN  LPCTSTR pszSectionName,
    OUT LPTSTR * ppsz)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    *ppsz = (LPTSTR)LocalAlloc(LPTR, SIZEOF(TCHAR) * INTERNET_MAX_URL_LENGTH);
    if (*ppsz)
    {
        DWORD cch;

        cch = SHGetIniString(pszSectionName, ISHCUT_INISTRING_URL,
            *ppsz, INTERNET_MAX_URL_LENGTH, pszFile);
        if (0 != cch)
        {
            PathRemoveBlanks(*ppsz);
            hres = S_OK;
        }
        else
        {
            LocalFree(*ppsz);
            *ppsz = NULL;    
            hres = S_FALSE;     
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the icon location from the URL (ini) file

Returns: S_OK  value was obtained from file
         S_FALSE value wasn't in file

         E_OUTOFMEMORY
*/
HRESULT 
ReadIconLocation(
    IN  LPCTSTR  pszFile,
    OUT LPWSTR * ppwsz,
    OUT int *    pniIcon,
    IN CHAR *    pszBuf)
{
    HRESULT hres = E_OUTOFMEMORY;
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PTSTR));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));
    
    *ppwsz = NULL;
    *pniIcon = 0;
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * MAX_PATH);
    if (*ppwsz)
    {
        hres = S_FALSE;     // assume no value exists in the file
        
        cch = SHGetIniString(c_szIntshcut,
           ISHCUT_INISTRING_ICONFILE, *ppwsz,
            MAX_PATH, pszFile);
        
        if (0 != cch)
        {
            TCHAR szIndex[MAX_BUF_INT];
            // The icon index is all ASCII so don't need SHGetIniString
            cch = GetPrivateProfileString(c_szIntshcut,
                ISHCUT_INISTRING_ICONINDEX, c_szNULL, 
                szIndex, SIZECHARS(szIndex),
                pszFile);
            if (0 != cch)
            {
                if (StrToIntEx(szIndex, 0, pniIcon))
                    hres = S_OK;
            }
        }
        
        if (S_OK != hres)
        {
            LocalFree(*ppwsz);
            *ppwsz = NULL;    
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write icon location to URL (ini) file

*/
HRESULT 
    WriteIconFile(
    IN LPCTSTR pszFile,
    IN LPCWSTR pszIconFile)
{
    HRESULT hres = S_OK;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(! pszIconFile ||
        IS_VALID_STRING_PTRW(pszIconFile, -1));
    
    if (*pszFile)
    {
        if (AnyMeatW(pszIconFile))
        {
            hres = SHSetIniString(c_szIntshcut, ISHCUT_INISTRING_ICONFILE, pszIconFile,
                pszFile) ? S_OK : E_FAIL;
        }
        else
        {
            // NOTE: since this function removes both the file and the index
            // values, then this function must be called *after* any call 
            // to WriteIconIndex.  One way to do this is make sure 
            // PID_IS_ICONINDEX < PID_IS_ICONFILE, since the index will
            // be enumerated first.
            
            hres = (SHDeleteIniString(c_szIntshcut, ISHCUT_INISTRING_ICONFILE,
                pszFile) &&
                DeletePrivateProfileString(c_szIntshcut, ISHCUT_INISTRING_ICONINDEX,
                pszFile))
                ? S_OK : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write icon index to URL (ini) file

*/
HRESULT 
WriteIconIndex(
    IN LPCTSTR pszFile,
    IN int     niIcon)
{
    HRESULT hres;
    
    if (*pszFile)
        hres = WriteSignedToFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_ICONINDEX, niIcon);
    else
        hres = S_FALSE;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the hotkey from the URL (ini) file

*/
HRESULT 
ReadHotkey(
    IN LPCTSTR pszFile, 
    IN WORD *  pwHotkey)
{
    HRESULT hres = S_FALSE;
    TCHAR szHotkey[MAX_BUF_INT];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));
    
    *pwHotkey = 0;
    
    cch = GetPrivateProfileString(c_szIntshcut,
        TEXT("Hotkey"), c_szNULL,
        szHotkey, SIZECHARS(szHotkey),
        pszFile);
    if (0 != cch)
    {
        int nVal;
        
        if (StrToIntEx(szHotkey, 0, &nVal))
        {
            *pwHotkey = nVal;
            hres = S_OK;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write hotkey to URL (ini) file

*/
HRESULT 
WriteHotkey(
    IN LPCTSTR pszFile, 
    IN WORD    wHotkey)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    if (*pszFile)
    {
        if (wHotkey)
        {
            hres = WriteUnsignedToFile(pszFile, c_szIntshcut, TEXT("Hotkey"), wHotkey);
        }
        else
        {
            hres = DeletePrivateProfileString(c_szIntshcut, TEXT("Hotkey"), pszFile)
                ? S_OK
                : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the working directory from the URL (ini) file

*/
HRESULT 
ReadWorkingDirectory(
    IN  LPCTSTR  pszFile,
    OUT LPWSTR * ppwsz)
{
    HRESULT hres = E_OUTOFMEMORY;
    TCHAR szPath[MAX_PATH];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PWSTR));
    
    *ppwsz = NULL;
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * MAX_PATH);
    if (*ppwsz)
    {
        hres = S_FALSE;
        
        cch = SHGetIniString(c_szIntshcut,
            ISHCUT_INISTRING_WORKINGDIR,
            szPath, SIZECHARS(szPath), pszFile);
        if (0 != cch)
        {
            TCHAR szFullPath[MAX_PATH];
            PTSTR pszFileName;
            
            if (0 < GetFullPathName(szPath, SIZECHARS(szFullPath), szFullPath,
                &pszFileName))
            {
                SHTCharToUnicode(szFullPath, *ppwsz, MAX_PATH);
                
                hres = S_OK;
            }
        }
        
        if (S_OK != hres)
        {
            LocalFree(*ppwsz);
            *ppwsz = NULL;    
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write the working directory to the URL (ini) file.

*/
HRESULT 
WriteGenericString(
    IN LPCTSTR pszFile, 
    IN  LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPCWSTR pwsz)          OPTIONAL
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(! pwsz || IS_VALID_STRING_PTRW(pwsz, -1));
    
    if (*pszFile)
    {
        if (AnyMeatW(pwsz))
        {
            hres = (SHSetIniString(pszSectionName, pszName, pwsz,
                pszFile)) ? S_OK : E_FAIL;
        }
        else
        {
            hres = (SHDeleteIniString(pszSectionName, pszName, pszFile))
                ? S_OK : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the show-command flag from the URL (ini) file

*/
HRESULT 
ReadShowCmd(
    IN  LPCTSTR pszFile, 
    OUT PINT    pnShowCmd)
{
    HRESULT hres = S_FALSE;
    TCHAR szT[MAX_BUF_INT];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));
    
    *pnShowCmd = SW_NORMAL;
    
    cch = GetPrivateProfileString(c_szIntshcut,
        TEXT("ShowCommand"), c_szNULL, szT,
        SIZECHARS(szT), pszFile);
    if (0 != cch)
    {
        if (StrToIntEx(szT, 0, pnShowCmd))
        {
            hres = S_OK;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write showcmd to URL (ini) file

*/
HRESULT 
WriteShowCmd(
    IN LPCTSTR pszFile, 
    IN int     nShowCmd)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    if (*pszFile)
    {
        if (SW_NORMAL != nShowCmd)
        {
            hres = WriteSignedToFile(pszFile, c_szIntshcut, TEXT("ShowCommand"), nShowCmd);
        }
        else
        {
            hres = DeletePrivateProfileString(c_szIntshcut, TEXT("ShowCommand"), pszFile)
                ? S_OK
                : E_FAIL;
        }
    }
    
    return hres;
}



/*----------------------------------------------------------
Purpose: Read the IDList from the URL (ini) file

*/
HRESULT 
ReadIDList(
    IN  LPCTSTR pszFile, 
    OUT LPITEMIDLIST *ppidl)
{
    HRESULT hres = S_FALSE;
    ULONG cb;

    ASSERT(ppidl);

    // Delete the old one if any.
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    cb = GetPrivateProfileInt(c_szIntshcut, TEXT("ILSize"), 0, pszFile);
    // constrain the size to a ushort
    if (cb && !HIWORD(cb))
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = IEILCreate(cb);
        if (pidl)
        {
            hres = E_FAIL;
            // Read its contents
            if (GetPrivateProfileStruct(c_szIntshcut, TEXT("IDList"), (LPVOID)pidl, cb, pszFile))
            {
                if (SHIsConsistentPidl(pidl, cb))
                {
                    *ppidl = pidl;
                    hres = S_OK;
                }
            }

            if (FAILED(hres))
            {
                ILFree(pidl);
            }
        }
        else
        {
           hres = E_OUTOFMEMORY;
        }
    }
    
    return hres;
}

HRESULT
WriteStream(
    IN LPCTSTR pszFile, 
    IN IStream *pStream,
    IN LPCTSTR pszStreamName,
    IN LPCTSTR pszSizeName)
{
    HRESULT hr = E_FAIL;
    ULARGE_INTEGER li = {0};
    
    if(pStream)
        IStream_Size(pStream, &li);

    if (li.LowPart)
    {
        ASSERT(!li.HighPart);
        LPVOID pv = LocalAlloc(LPTR, li.LowPart);

        if (pv && SUCCEEDED(hr = IStream_Read(pStream, pv, li.LowPart)))
        {
            //  we have loaded the data properly, time to write it out

            if (SUCCEEDED(hr = WriteUnsignedToFile(pszFile, c_szIntshcut, pszSizeName, li.LowPart)))
                hr = WriteBinaryToFile(pszFile, c_szIntshcut, pszStreamName, pv, li.LowPart);
        }

        if (pv)
        {
            LocalFree(pv);
            pv = NULL;
        }
    }
    else
    {
        // delete the keys if
        // 1. pStream is NULL, or
        // 2. pStream in empty (cbPidl == 0).
        if (DeletePrivateProfileString(c_szIntshcut, pszSizeName, pszFile) &&
            DeletePrivateProfileString(c_szIntshcut, pszStreamName, pszFile))
        {
            hr = S_OK;
        }
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Write IDList to URL (ini) file

*/
HRESULT 
WriteIDList(
    IN LPCTSTR pszFile, 
    IN IStream *pStream)
{
    return WriteStream(pszFile, pStream, TEXT("IDList"), TEXT("ILSize"));
}




/********************************** Methods **********************************/



//==========================================================================================
// URLProp class implementation 
//==========================================================================================


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the properties in this object

*/
STDMETHODIMP_(void) URLProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        PropStg_Dump(m_hstg, 0);
    }
}

#endif


/*----------------------------------------------------------
Purpose: Constructor for URLProp 

*/
URLProp::URLProp(void) : m_cRef(1)
{
    // Don't validate this until after construction.
    
    m_hstg = NULL;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    return;
}


/*----------------------------------------------------------
Purpose: Destructor for URLProp

*/
URLProp::~URLProp(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    if (m_hstg)
    {
        PropStg_Destroy(m_hstg);
        m_hstg = NULL;
    }
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    return;
}


STDMETHODIMP_(ULONG) URLProp::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) URLProp::Release()
{
    m_cRef--;
    if (m_cRef > 0)
        return m_cRef;
    
    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method for URLProp

*/
STDMETHODIMP URLProp::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyStorage))
    {
        *ppvObj = SAFECAST(this, IPropertyStorage *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: Initialize the object

Returns: S_OK
         E_OUTOFMEMORY
*/
STDMETHODIMP URLProp::Init(void)
{
    HRESULT hres = S_OK;
    
    // Don't stomp on ourselves if this has already been initialized 
    if (NULL == m_hstg)
    {
        hres = PropStg_Create(&m_hstg, PSTGF_DEFAULT);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the string property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN LPTSTR pszBuf,
    IN int    cchBuf)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pszBuf);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pszBuf = TEXT('\0');
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_LPWSTR == propvar.vt)
        {
            SHUnicodeToTChar(propvar.pwszVal, pszBuf, cchBuf);
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_LPWSTR, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN int * piVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(piVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *piVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_I4 == propvar.vt)
        {
            *piVal = propvar.lVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_I4, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN LPDWORD pdwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pdwVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pdwVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_UI4 == propvar.vt)
        {
            *pdwVal = propvar.ulVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_UI4, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN WORD * pwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pwVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pwVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_UI2 == propvar.vt)
        {
            *pwVal = propvar.uiVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_UI2, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the IStream property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN IStream **ppStream)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(ppStream);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *ppStream = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_STREAM == propvar.vt)
        {
            *ppStream = propvar.pStream;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt && propvar.lVal != 0)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_STREAM, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        // Do not PropVariantClear(&propvar), because it will call pStream->Release().
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the string property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN LPCTSTR psz)         OPTIONAL
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;

    // WARNING:: this function gets called as part of ShellExecute which can be
    // called by 16 bit apps so don't put mondo strings on stack...
    WCHAR *pwsz = NULL;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    if (psz && *psz)
    {
        SHStrDup(psz, &pwsz);
        propvar.vt = VT_LPWSTR;
        propvar.pwszVal = pwsz;
    }
    else
        propvar.vt = VT_EMPTY;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);

    if (pwsz)
        CoTaskMemFree(pwsz);

    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the int property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN int     iVal)
{
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_I4;
    propvar.lVal = iVal;
    
    return WriteMultiple(1, &propspec, &propvar, 0);
}


/*----------------------------------------------------------
Purpose: Helper function that sets the dword property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN DWORD   dwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_UI4;
    propvar.ulVal = dwVal;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the word property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN WORD    wVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_UI2;
    propvar.uiVal = wVal;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the IStream* property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN IStream *pStream)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_STREAM;
    propvar.pStream = pStream;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


STDMETHODIMP URLProp::IsDirty(void)
{
    return PropStg_IsDirty(m_hstg);
}


STDMETHODIMP URLProp::ReadMultiple(IN ULONG         cpspec,
                                   IN const PROPSPEC rgpropspec[],
                                   IN PROPVARIANT   rgpropvar[])
{
    HRESULT hres = PropStg_ReadMultiple(m_hstg, cpspec, rgpropspec, rgpropvar);
    
    if (SUCCEEDED(hres))
    {
        // Set the accessed time
        SYSTEMTIME st;
        
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftAccessed);
    }
    
    return hres;
}


STDMETHODIMP URLProp::WriteMultiple(IN ULONG         cpspec,
                                    IN const PROPSPEC rgpropspec[],
                                    IN const PROPVARIANT rgpropvar[],
                                    IN PROPID        propidFirst)
{
    HRESULT hres = PropStg_WriteMultiple(m_hstg, cpspec, rgpropspec, 
        rgpropvar, propidFirst);
    
    if (SUCCEEDED(hres))
    {
        // Set the modified time
        SYSTEMTIME st;
        
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftModified);
    }
    
    return hres;
}

STDMETHODIMP URLProp::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpropspec[])
{
    return PropStg_DeleteMultiple(m_hstg, cpspec, rgpropspec);
}


STDMETHODIMP URLProp::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPWSTR rgpwszName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP URLProp::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPWSTR rgpwszName[])
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::DeletePropertyNames method for URLProp

*/
STDMETHODIMP
URLProp::DeletePropertyNames(
    IN ULONG    cpropid,
    IN const PROPID rgpropid[])
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::SetClass method for URLProp

*/
STDMETHODIMP
URLProp::SetClass(
    IN REFCLSID rclsid)
{
    CopyMemory(&m_clsid, &rclsid, SIZEOF(m_clsid));
    
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Commit method for URLProp

*/
STDMETHODIMP
URLProp::Commit(
    IN DWORD dwFlags)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Revert method for URLProp

*/
STDMETHODIMP URLProp::Revert(void)
{
#ifdef DEBUG
    Dump();
#endif
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Enum method for URLProp

*/
STDMETHODIMP URLProp::Enum(IEnumSTATPROPSTG ** ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Stat method for URLProp

*/
STDMETHODIMP
URLProp::Stat(
    IN STATPROPSETSTG * pstat)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;

    if (IS_VALID_WRITE_PTR(pstat, STATPROPSETSTG))
    {
        pstat->fmtid = m_fmtid;
        pstat->clsid = m_clsid;
        pstat->grfFlags = m_grfFlags;
        pstat->mtime = m_ftModified;
        pstat->ctime = m_ftCreated;
        pstat->atime = m_ftAccessed;

        hres = S_OK;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::SetTimes method for URLProp

*/
STDMETHODIMP
URLProp::SetTimes(
    IN const FILETIME * pftModified,        OPTIONAL
    IN const FILETIME * pftCreated,         OPTIONAL
    IN const FILETIME * pftAccessed)        OPTIONAL
{
    HRESULT hres;
    
    if (pftModified && !IS_VALID_READ_PTR(pftModified, FILETIME) ||
        pftCreated && !IS_VALID_READ_PTR(pftCreated, FILETIME) ||
        pftAccessed && !IS_VALID_READ_PTR(pftAccessed, FILETIME))
    {
        hres = STG_E_INVALIDPARAMETER;
    }
    else
    {
        if (pftModified)
            m_ftModified = *pftModified;
        
        if (pftCreated)
            m_ftCreated = *pftCreated;
        
        if (pftAccessed)
            m_ftAccessed = *pftAccessed;
        
        hres = S_OK;
    }
    
    return hres;
}

#ifdef DEBUG

STDMETHODIMP_(void) IntshcutProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        TraceMsg(TF_ALWAYS, "  IntshcutProp obj: %s", m_szFile);
        URLProp::Dump();
    }
}

#endif


IntshcutProp::IntshcutProp(void)
{
    // Don't validate this until after construction.
    
    *m_szFile = 0;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));
}

IntshcutProp::~IntshcutProp(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));
}


// (These are not related to PID_IS_*) 
#define IPROP_ICONINDEX     0 
#define IPROP_ICONFILE      1
#define IPROP_HOTKEY        2 
#define IPROP_WORKINGDIR    3
#define IPROP_SHOWCMD       4
#define IPROP_WHATSNEW      5     
#define IPROP_AUTHOR        6 
#define IPROP_DESC          7 
#define IPROP_COMMENT       8
#define IPROP_URL           9       // these two must be the last 
#define IPROP_SCHEME        10      //  in this list.  See LoadFromFile.
#define CPROP_INTSHCUT      11      // Count of properties 

// (we don't write the URL or the scheme in the massive write sweep)
#define CPROP_INTSHCUT_WRITE    (CPROP_INTSHCUT - 2)      

/*----------------------------------------------------------
Purpose: Load the basic property info like URL.

Returns: 
Cond:    --
*/
STDMETHODIMP IntshcutProp::LoadFromFile(LPCTSTR pszFile)
{
    HRESULT hres;
    LPWSTR pwszBuf;
    LPTSTR pszBuf;
    CHAR *pszTempBuf;
    static const PROPSPEC rgpropspec[CPROP_INTSHCUT] = 
    {
        // This must be initialized in the same order as how the
        // IPROP_* values were defined.
        { PRSPEC_PROPID, PID_IS_ICONINDEX },
        { PRSPEC_PROPID, PID_IS_ICONFILE },
        { PRSPEC_PROPID, PID_IS_HOTKEY },
        { PRSPEC_PROPID, PID_IS_WORKINGDIR },
        { PRSPEC_PROPID, PID_IS_SHOWCMD },
        { PRSPEC_PROPID, PID_IS_WHATSNEW },
        { PRSPEC_PROPID, PID_IS_AUTHOR },
        { PRSPEC_PROPID, PID_IS_DESCRIPTION },
        { PRSPEC_PROPID, PID_IS_COMMENT },
        { PRSPEC_PROPID, PID_IS_URL },
        { PRSPEC_PROPID, PID_IS_SCHEME },
    };
    PROPVARIANT rgpropvar[CPROP_INTSHCUT] = { 0 };
    
    ASSERT(pszFile);

    // try to allocate a temporary buffer, don't put on stack as this may be called
    // by 16 bit apps through the shellexecute thunk
    pszTempBuf = (CHAR*)LocalAlloc(LMEM_FIXED, INTERNET_MAX_URL_LENGTH * sizeof(CHAR));
    if (!pszTempBuf)
        return E_OUTOFMEMORY;

    if (!g_fRunningOnNT)
    {
        // Flush the cache first to encourage Win95 kernel to zero-out
        // its buffer.  Kernel GP-faults with hundreds of writes made to
        // ini files.
        WritePrivateProfileString(NULL, NULL, NULL, pszFile);
    }
    
    // Get the URL 
    hres = ReadURLFromFile(pszFile, c_szIntshcut, &pszBuf);
    if (S_OK == hres)
    {
        // Call this method because it does more work before
        // setting the property 
        SetURLProp(pszBuf, (IURL_SETURL_FL_GUESS_PROTOCOL | IURL_SETURL_FL_USE_DEFAULT_PROTOCOL));
        
        LocalFree(pszBuf);
        pszBuf = NULL;
    }
    
    // Get the IDList
    LPITEMIDLIST pidl = NULL;
    hres = ReadIDList(pszFile, &pidl);
    if (S_OK == hres)
    {
        // Call this method because it does more work before
        // setting the property 
        SetIDListProp(pidl);
        
        ILFree(pidl);
    }

#ifndef UNIX

    // Get icon location
    int nVal;
    hres = ReadIconLocation(pszFile, &pwszBuf, &nVal, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_ICONFILE].vt = VT_LPWSTR;
        rgpropvar[IPROP_ICONFILE].pwszVal = pwszBuf;
        
        rgpropvar[IPROP_ICONINDEX].vt = VT_I4;
        rgpropvar[IPROP_ICONINDEX].lVal = nVal;
    }
    
    // Get the hotkey 
    WORD wHotkey;
    hres = ReadHotkey(pszFile, &wHotkey);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_HOTKEY].vt = VT_UI2;
        rgpropvar[IPROP_HOTKEY].uiVal = wHotkey;
    }
    
    // Get the working directory 
    hres = ReadWorkingDirectory(pszFile, &pwszBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_WORKINGDIR].vt = VT_LPWSTR;
        rgpropvar[IPROP_WORKINGDIR].pwszVal = pwszBuf;
    }
    
    // Get the showcmd flag 
    hres = ReadShowCmd(pszFile, &nVal);
    rgpropvar[IPROP_SHOWCMD].vt = VT_I4;
    if (S_OK == hres)
        rgpropvar[IPROP_SHOWCMD].lVal = nVal;
    else
        rgpropvar[IPROP_SHOWCMD].lVal = SW_NORMAL;
    
    
    // Get the What's New bulletin 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_WHATSNEW, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_WHATSNEW].vt = VT_LPWSTR;
        rgpropvar[IPROP_WHATSNEW].pwszVal = pwszBuf;
    }
    
    // Get the Author 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_AUTHOR, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_AUTHOR].vt = VT_LPWSTR;
        rgpropvar[IPROP_AUTHOR].pwszVal = pwszBuf;
    }
    
    // Get the Description 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_DESC, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_DESC].vt = VT_LPWSTR;
        rgpropvar[IPROP_DESC].pwszVal = pwszBuf;
    }
    
    // Get the Comment
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_COMMENT, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_COMMENT].vt = VT_LPWSTR;
        rgpropvar[IPROP_COMMENT].pwszVal = pwszBuf;
    }

#endif /* !UNIX */
    
    // Write it all out to our in-memory storage.  Note we're using 
    // CPROP_INTSHCUT_WRITE, which should be the size of the array minus the
    // url and scheme propids, since they were written separately 
    // above.
    hres = WriteMultiple(CPROP_INTSHCUT_WRITE, (PROPSPEC *)rgpropspec, rgpropvar, 0);
    if (SUCCEEDED(hres))
    {
        // Unmark *all* these properties, since we're initializing from
        // the file
        PropStg_DirtyMultiple(m_hstg, ARRAYSIZE(rgpropspec), rgpropspec, FALSE);
    }
    
    // Get the times.  We don't support the Accessed time for internet
    // shortcuts updating this field would cause the shortcut to be
    // constantly written to disk to record the Accessed time simply
    // when a property is read.  A huge perf hit!

    ZeroMemory(&m_ftAccessed, sizeof(m_ftAccessed));
    
    DWORD cbData = SIZEOF(m_ftModified);
    ReadBinaryFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_MODIFIED, &m_ftModified, cbData);
    
    // Free up the buffers that we allocated 
    int cprops;
    PROPVARIANT * ppropvar;
    for (cprops = ARRAYSIZE(rgpropvar), ppropvar = rgpropvar; 0 < cprops; cprops--)
    {
        if (VT_LPWSTR == ppropvar->vt)
        {
            ASSERT(ppropvar->pwszVal);
            LocalFree(ppropvar->pwszVal);
            ppropvar->pwszVal = NULL;
        }
        ppropvar++;
    }

    LocalFree((HLOCAL)pszTempBuf);
    pszTempBuf = NULL;
    
    return hres;
}

STDMETHODIMP IntshcutProp::Init(void)
{
    return URLProp::Init();
}

STDMETHODIMP IntshcutProp::InitFromFile(LPCTSTR pszFile)
{
    // Initialize the in-memory property storage from the file
    // and database
    HRESULT hres = Init();
    if (SUCCEEDED(hres) && pszFile)
    {
        StrCpyN(m_szFile, pszFile, SIZECHARS(m_szFile));
        hres = LoadFromFile(m_szFile);
    }
    else
        m_szFile[0] = 0;
    
    return hres;
}


typedef struct
{
    LPTSTR pszFile;
} COMMITISDATA;

/*----------------------------------------------------------
Purpose: Commit the values for any known properties to the file

         Note this callback is called only for dirty values.

Returns: S_OK if alright
         S_FALSE to skip this value
         error to stop
  
*/
STDAPI CommitISProp(
    IN PROPID        propid,
    IN PROPVARIANT * ppropvar,
    IN LPARAM        lParam)
{
    HRESULT hres = S_OK;
    COMMITISDATA * pcd = (COMMITISDATA *)lParam;
    
    ASSERT(ppropvar);
    ASSERT(pcd);
    
    LPWSTR pwsz;
    USHORT uiVal;
    LONG lVal;
    IStream *pStream;
    
    switch (propid)
    {
    case PID_IS_URL:
    case PID_IS_ICONFILE:
    case PID_IS_WORKINGDIR:
    case PID_IS_WHATSNEW:
    case PID_IS_AUTHOR:
    case PID_IS_DESCRIPTION:
    case PID_IS_COMMENT:
        if (VT_LPWSTR == ppropvar->vt)
            pwsz = ppropvar->pwszVal;
        else
            pwsz = NULL;
        
        switch (propid)
        {
        case PID_IS_URL:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_URL, pwsz);
            break;
            
        case PID_IS_ICONFILE:
            hres = WriteIconFile(pcd->pszFile, pwsz);
            break;
            
        case PID_IS_WORKINGDIR:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_WORKINGDIR, pwsz);
            break;
            
        case PID_IS_WHATSNEW:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_WHATSNEW, pwsz);
            break;
            
        case PID_IS_AUTHOR:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_AUTHOR, pwsz);
            break;
            
        case PID_IS_DESCRIPTION:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_DESC, pwsz);
            break;
            
        case PID_IS_COMMENT:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_COMMENT, pwsz);
            break;
            
        default:
            ASSERT(0);      // should never get here
            break;
        }
        break;
        
        case PID_IS_ICONINDEX:
            if (VT_I4 == ppropvar->vt)
                hres = WriteIconIndex(pcd->pszFile, ppropvar->lVal);
            break;
            
        case PID_IS_HOTKEY:
            if (VT_UI2 == ppropvar->vt)
                uiVal = ppropvar->uiVal;
            else
                uiVal = 0;
            
            hres = WriteHotkey(pcd->pszFile, uiVal);
            break;
            
        case PID_IS_SHOWCMD:
            if (VT_I4 == ppropvar->vt)
                lVal = ppropvar->lVal;
            else
                lVal = SW_NORMAL;
            
            hres = WriteShowCmd(pcd->pszFile, lVal);
            break;
            
        case PID_IS_SCHEME:
            // Don't write this one out
            break;
            
        case PID_IS_IDLIST:
            if (VT_STREAM == ppropvar->vt)
                pStream = ppropvar->pStream;
            else
                pStream = NULL;
                
            hres = WriteIDList(pcd->pszFile, pStream);
            break;
                  
                  
        default:
            TraceMsg(TF_WARNING, "Don't know how to commit url property (%#lx)", propid);
            ASSERT(0);
            break;
    }
    
#ifdef DEBUG
    if (FAILED(hres))
        TraceMsg(TF_WARNING, "Failed to save url property (%#lx) to file %s", propid, pcd->pszFile);
#endif
  
    return hres;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Commit method for URLProp

*/
STDMETHODIMP
IntshcutProp::Commit(
    IN DWORD dwFlags)
{
    HRESULT hres;
    COMMITISDATA cd;
    
    TraceMsg(TF_INTSHCUT, "Writing properties to \"%s\"", m_szFile);

    cd.pszFile = m_szFile;
    
    // Enumerate thru the dirty property values that get saved to the
    // file
    hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, CommitISProp, (LPARAM)&cd);
    
    if (SUCCEEDED(hres))
    {
        // Now mark everything clean 
        PropStg_DirtyAll(m_hstg, FALSE);

        // Save the times.  Don't write out the Accessed time for perf.
        // See LoadFromFile.
        EVAL(SUCCEEDED(WriteBinaryToFile(m_szFile, c_szIntshcut, ISHCUT_INISTRING_MODIFIED, &m_ftModified, 
                                         SIZEOF(m_ftModified))));
    }
    
#ifdef DEBUG
    Dump();
#endif
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function to set the file name.

*/
STDMETHODIMP 
IntshcutProp::SetFileName(
    IN LPCTSTR pszFile)
{
    if(pszFile)
    {
        ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
        StrCpyN(m_szFile, pszFile, SIZECHARS(m_szFile));
    }
    else
    {
        *m_szFile = TEXT('\0');;
    }

    return S_OK;
}



/*----------------------------------------------------------
Purpose: Helper function that sets the URL.

*/
STDMETHODIMP
IntshcutProp::SetIDListProp(
    LPCITEMIDLIST pcidl)
{
    HRESULT hres;
    IStream *pstmPidl;
    
    if (pcidl)
    {
        // ???
        // PERF: This loads OLE. Is this OK?
        
        hres = CreateStreamOnHGlobal(NULL, TRUE, &pstmPidl);
        if (SUCCEEDED(hres))
        {
            hres = ILSaveToStream(pstmPidl, pcidl);
            
            if (SUCCEEDED(hres))
                hres = SetProp(PID_IS_IDLIST, pstmPidl);

            pstmPidl->Release();
        }
    }
    else
    {
        hres = SetProp(PID_IS_IDLIST, NULL); 
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the URL.  This function
         optionally canonicalizes the string as well.

*/
STDMETHODIMP
IntshcutProp::SetURLProp(
    IN LPCTSTR pszURL,              OPTIONAL
    IN DWORD   dwFlags)
{
    HRESULT hres;

    // Warning this function can be called as part of shellexecute which can be
    // thunked up to by a 16 bit app, so be carefull what you put on stack...
    
    BOOL bChanged;

    struct tbufs
    {
        TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
        TCHAR szUrlT[INTERNET_MAX_URL_LENGTH];
    };

    struct tbufs *ptbufs;

    ptbufs = (struct tbufs *)LocalAlloc(LMEM_FIXED, sizeof(struct tbufs));
    if (!ptbufs)
        return E_OUTOFMEMORY;
    
    hres = GetProp(PID_IS_URL, ptbufs->szUrl, INTERNET_MAX_URL_LENGTH);
    
    bChanged = !(( !pszURL && S_OK != hres) ||
        (pszURL && S_OK == hres && 0 == StrCmp(pszURL, ptbufs->szUrl)));
    
    hres = S_OK;
    if (bChanged)
    {
        if (NULL == pszURL)
        {
            hres = SetProp(PID_IS_URL, pszURL);
            if (S_OK == hres)
                hres = SetProp(PID_IS_SCHEME, URL_SCHEME_UNKNOWN);
        }
        else
        {
            DWORD dwFlagsT = UQF_CANONICALIZE;
            
            // Translate the URL 
            
            if (IsFlagSet(dwFlags, IURL_SETURL_FL_GUESS_PROTOCOL))
                SetFlag(dwFlagsT, UQF_GUESS_PROTOCOL);
            
            if (IsFlagSet(dwFlags, IURL_SETURL_FL_USE_DEFAULT_PROTOCOL))
                SetFlag(dwFlagsT, UQF_USE_DEFAULT_PROTOCOL);
            
            // Translate the URL 
            hres = IURLQualify(pszURL, dwFlagsT, ptbufs->szUrlT, NULL, NULL);
            
            if (SUCCEEDED(hres))
            {
                // Is the URL different after being translated? 
                bChanged = (0 != StrCmp(ptbufs->szUrlT, ptbufs->szUrl));
                
                hres = S_OK;
                if (bChanged)
                {
                    // Yes; validate and get the scheme
                    PARSEDURL pu;
                    
                    pu.cbSize = SIZEOF(pu);
                    hres = ParseURL(ptbufs->szUrlT, &pu);
                    
                    if (S_OK == hres)
                        hres = SetProp(PID_IS_URL, ptbufs->szUrlT);
                    
                    if (S_OK == hres)
                        hres = SetProp(PID_IS_SCHEME, (DWORD)pu.nScheme);
                }
            }
        }
    }

    LocalFree((HLOCAL)ptbufs);
    ptbufs = NULL;
    
    return hres;
}

/*----------------------------------------------------------
Purpose: Helper function that sets the string property

*/
STDMETHODIMP
IntshcutProp::SetProp(
    IN PROPID  pid,
    IN LPCTSTR psz)         OPTIONAL
{
    HRESULT hr;

    // WARNING:: this function gets called as part of ShellExecute which can be
    // called by 16 bit apps so don't put mondo strings on stack...
    LPCWSTR pszUrl = psz;
    LPWSTR pszTemp = NULL;

    // For URLs, we need to check for security spoofs
    if (PID_IS_URL == pid && psz && IsSpecialUrl((LPWSTR)psz)) //FEATURE: remove cast
    {
        SHStrDup(psz, &pszTemp);

        if (NULL != pszTemp)
        {
            // Unescape the url and look for a security context delimitor
            hr = WrapSpecialUrlFlat(pszTemp, lstrlen(pszTemp)+1);
            if (E_ACCESSDENIED == hr)
            {
                // Security delimitor found, so wack it off
                SHRemoveURLTurd(pszTemp);
                pszUrl = pszTemp;
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    hr = super::SetProp(pid, pszUrl);

    if (pszTemp)
    {
        CoTaskMemFree(pszTemp);
    }
    return hr;
}

    
STDAPI CIntshcutProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;
    
    *ppvOut = NULL;
    
    if (punkOuter)
    {
        // No
        hres = CLASS_E_NOAGGREGATION;
    }
    else
    {
        IUnknown * piunk = (IUnknown *)(IPropertyStorage *)new IntshcutProp;
        if ( !piunk ) 
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = piunk->QueryInterface(riid, ppvOut);
            piunk->Release();
        }
    }
    
    return hres;        // S_OK or E_NOINTERFACE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\urlprop2.cpp ===
//==========================================================================================
// HISTDATA helper (should be a static member)
//==========================================================================================


#define CUrlHistoryProp IntsiteProp

//==========================================================================================
// IntsiteProp class implementation
//==========================================================================================

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the properties in this object

*/
STDMETHODIMP_(void)
    CUrlHistoryProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        TraceMsg(TF_ALWAYS, "  Intsite Property obj: %s", m_szURL);
        URLProp::Dump();
    }
}

#endif


/*----------------------------------------------------------
Purpose: Constructor for URLProp 

*/
CUrlHistoryProp::CUrlHistoryProp(void)
{
    // Don't validate this until after construction.
    
    // This object should only be allocated, not used on the stack,
    // because we don't zero-initialize the member variables.
    // Here's a sanity assertion.
    
    ASSERT(NULL == m_pintshcut);
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntsiteProp));
    
    return;
}


/*----------------------------------------------------------
Purpose: Destructor for CUrlHistoryProp

*/
CUrlHistoryProp::~CUrlHistoryProp(void)
{
    if (m_pintshcut)
    {
        if (!m_fPrivate)
            m_pintshcut->Release();
        m_pintshcut = NULL;
    }
    
    return;
}

STDAPI CIntsiteProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;
    
    *ppvOut = NULL;
    
    ASSERT(punkOuter==NULL)

    IUnknown * piunk = (IUnknown *)new IntsiteProp;
    if ( !piunk ) 
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        hres = piunk->QueryInterface(riid, ppvOut);
        piunk->Release();
    }
    
    return hres;        // S_OK or E_NOINTERFACE
}

HRESULT CUrlHistoryProp::Init(void)
{
    return URLProp::Init();
}

STDMETHODIMP CUrlHistoryProp::InitFromDB(LPCTSTR pszURL, Intshcut *pintshcut, BOOL fPrivObj)
{
    // TraceMsg(DM_HISTPROP, "CUHP::InitFromDB called for %s", pszURL);

    // Initialize the in-memory property storage from the file
    // and database
    
    HRESULT hres = Init();
    if (SUCCEEDED(hres))
    {
        if (NULL == m_pintshcut)
        {
            m_fPrivate = fPrivObj;
            if (!m_fPrivate)
                pintshcut->AddRef();
            m_pintshcut = pintshcut;
        }
        else
        {
            // We can't switch from Private->Public or visaversa.
            ASSERT(fPrivObj == m_fPrivate);
        }
        
        if (pszURL)
        {
            // Is this really a URL?? 
            PARSEDURL pu;
            
            pu.cbSize = SIZEOF(pu);
            hres = ParseURL(pszURL, &pu);
            
            if (S_OK == hres)
            {
                // Yes; go ahead and initialize
                StrCpyN(m_szURL, pszURL, SIZECHARS(m_szURL));

                hres = LoadFromDB(pszURL);
            }
        }
    }
    
    return hres;
}

HRESULT CUrlHistoryProp::LoadFromDB(
    IN LPCTSTR pszURL)
{
    TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB called for %s", pszURL);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(pszURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    //
    //	if there is already an entry for this Url, then we will reuse some of the
    //	settings.  retrieve the relevant info if possible.
    //
    if (buf.pcei) {
        CHistoryData* phdPrev =  CHistoryData::s_GetHistoryData(buf.pcei);
        if (phdPrev) {
            //
            // Initialize non-string properties first
            //
            const static PROPSPEC c_aprspec[] = {
                { PRSPEC_PROPID, PID_INTSITE_FLAGS },
                { PRSPEC_PROPID, PID_INTSITE_LASTVISIT },
                { PRSPEC_PROPID, PID_INTSITE_LASTMOD },
                { PRSPEC_PROPID, PID_INTSITE_WATCH },
            };
            PROPVARIANT apropvar[ARRAYSIZE(c_aprspec)] = { 0 };

            apropvar[0].vt = VT_UI4;
            apropvar[0].lVal = phdPrev->dwFlags;
            apropvar[1].vt = VT_FILETIME;
            apropvar[1].filetime = buf.pcei->LastAccessTime;
            apropvar[2].vt = VT_FILETIME;
            apropvar[2].filetime = buf.pcei->LastModifiedTime;
            apropvar[3].vt = VT_UI4;
            apropvar[3].lVal = phdPrev->dwWatch;

            TraceMsg(DM_HISTPROP, "CUHP::InitFromDB calling WriteMultiple (wFlags=%x)", phdPrev->dwFlags);
      	    WriteMultiple(ARRAYSIZE(c_aprspec), c_aprspec, apropvar, 0);
            PropStg_DirtyMultiple(m_hstg, ARRAYSIZE(c_aprspec), c_aprspec, FALSE);

            //
            // Then, initialize others
            //
            PROPSPEC prspec;
            prspec.ulKind = PRSPEC_PROPID;

            for (const HISTEXTRA* phextPrev = phdPrev->_GetExtra();
                 phextPrev && !phextPrev->IsTerminator();
                 phextPrev = phextPrev->GetNextFast())
            {
                TraceMsg(DM_HISTPROP, "CUHP::InitFromDB found HISTEXTRA (id=%d, vt=%d)",
                         phextPrev->idExtra, phextPrev->cbExtra);

                WCHAR wszBuf[MAX_URL_STRING]; // NOTES: scope must be right
                apropvar[0].vt = phextPrev->vtExtra;

                switch(phextPrev->vtExtra) {
                case VT_LPWSTR:
                    apropvar[0].pwszVal = (LPWSTR)phextPrev->abExtra;
                    break;

                case VT_LPSTR:
                    //
                    // Notice that we always convert it to LPWSTR
                    //
                    {
                        apropvar[0].pwszVal = wszBuf;
                        LPCSTR pszExtra = (LPCSTR)phextPrev->abExtra;
                        AnsiToUnicode(pszExtra, wszBuf, ARRAYSIZE(wszBuf));
                        apropvar[0].vt = VT_LPWSTR;
                    }
                    break;

                case VT_UI4:
                case VT_I4:
                    apropvar[0].lVal = *(DWORD*)phextPrev->abExtra;
                    break;

                case VT_NULL:
                    ASSERT(phextPrev->idExtra == PID_INTSITE_FRAGMENT);
                    continue;

                default:
                    ASSERT(0);
                    continue;
                }

                prspec.propid = phextPrev->idExtra;
                WriteMultiple(1, &prspec, apropvar, 0);
                PropStg_DirtyMultiple(m_hstg, 1, &prspec, FALSE);
            }
        } else {
            TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB can't get phdPrev");
        }
    } else {
        TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB can't get pcei");
    }

    return S_OK;
}


struct URLHIST_ENUMPARAM {
    CUrlHistoryProp* that;
    INTERNET_CACHE_ENTRY_INFO cei;
    LPINTERNET_CACHE_ENTRY_INFO pceiPrev;
    CHistoryData* phdPrev;
    LPHISTEXTRA phextCur;
    UINT cbHistExtra;
    BOOL fDirty;
};

STDAPI s_CommitHistItem(
    IN PROPID        propid,
    IN PROPVARIANT * ppropvar,
    IN LPARAM        lParam)
{
    URLHIST_ENUMPARAM* peparam = (URLHIST_ENUMPARAM*)lParam;
    CHistoryData* phdNew = (CHistoryData*)peparam->cei.lpHeaderInfo;

    TraceMsg(DM_HISTEXTRA, "CUHP::s_CommitHistItem called for id=%d vt=%d (phextCur=%x)",
                propid, ppropvar->vt, peparam->phextCur);

    UINT cbExtra = 0;
    UINT cbRequired;

    switch(propid) {
    case PID_INTSITE_FLAGS:
        if (ppropvar->vt == VT_UI4 && phdNew) {
            TraceMsg(DM_HISTPROP, "CUHP::s_CommitHistItem updating PID_INSITE_FLAGS (%x to %x)",
                     phdNew->dwFlags, ppropvar->lVal);
            phdNew->dwFlags = ppropvar->lVal;
            peparam->fDirty = TRUE;
        }
        break;

    case PID_INTSITE_WATCH:
        if (ppropvar->vt == VT_UI4 && phdNew) {
            TraceMsg(DM_HISTPROP, "CUHP::s_CommitHistItem updating PID_INSITE_WATCH (%x to %x)",
                     phdNew->dwFlags, ppropvar->lVal);
            phdNew->dwWatch = ppropvar->lVal;
            peparam->fDirty = TRUE;
        }
        break;

    case PID_INTSITE_LASTVISIT:
    case PID_INTSITE_LASTMOD:
        // They are read-only. We can change it if we want.
        ASSERT(0);
        break;

    default:
        switch(ppropvar->vt) {
        case VT_UI4:
        case VT_I4:
            cbExtra = DW_ALIGNED(SIZEOF(HISTEXTRA)-SIZEOF(peparam->phextCur->abExtra)+SIZEOF(UINT));
            if (peparam->phextCur) {
                peparam->phextCur->cbExtra = cbExtra;
                peparam->phextCur->idExtra = propid;
                peparam->phextCur->vtExtra = ppropvar->vt;
                *(DWORD*)peparam->phextCur->abExtra = ppropvar->lVal;
                peparam->fDirty = TRUE;
            }
            break;

        case VT_LPWSTR:
            cbRequired = WideCharToMultiByte(CP_ACP, 0, ppropvar->pwszVal, -1,
                                NULL, 0, NULL, NULL);
            cbExtra = DW_ALIGNED(SIZEOF(HISTEXTRA) + cbRequired);
            if (peparam->phextCur)
            {
                peparam->phextCur->cbExtra = cbExtra;
                peparam->phextCur->idExtra = propid;
                peparam->phextCur->vtExtra = VT_LPSTR;
                WideCharToMultiByte(CP_ACP, 0, ppropvar->pwszVal, -1, 
                    (LPSTR)peparam->phextCur->abExtra, cbRequired, NULL, NULL);
                peparam->fDirty = TRUE;
            }
            break;

        case VT_EMPTY:
            if (peparam->phextCur) {
                peparam->fDirty = TRUE;
            }
            break;

        default:
            ASSERT(0);
            break;
        }

        if (peparam->phextCur) {
            // We are saving the data, move the write pointer.
            TraceMsg(DM_HISTEXTRA, "s_CommitHistItem moving phextCur forward %d bytes",
                     peparam->phextCur->cbExtra);
            peparam->phextCur = peparam->phextCur->GetNextFastForSave();
            ASSERT(peparam->phextCur->cbExtra == 0);
        } else {
            // We are calcurating the required size, just add the size.
            TraceMsg(DM_HISTEXTRA, "s_CommitHistItem adding %d", cbExtra);
            peparam->cbHistExtra += cbExtra;

            // Remove existing one. 
            if (peparam->phdPrev) {
                // FEATURE: Bad const to non-const cast
                HISTEXTRA* phextPrev =
                    (HISTEXTRA*)peparam->phdPrev->_FindExtra(propid);
    
                if (phextPrev) {
                    TraceMsg(DM_HISTEXTRA, "s_CommitHistItem invalidate an old one id=%d %d bytes",
                              phextPrev->idExtra, phextPrev->cbExtra);
                    phextPrev->vtExtra = VT_EMPTY;
                }
            }
	}
    }
    return S_OK;
};

HRESULT CUrlHistoryProp::Commit(IN DWORD dwFlags)
{
    TraceMsg(DM_HISTPROP, "CUHP::Commit called for %s", m_szURL);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(m_szURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    HRESULT hres;
    URLHIST_ENUMPARAM eparam = { this };
    ASSERT(eparam.fDirty == FALSE);

    eparam.pceiPrev = buf.pcei;
    if (eparam.pceiPrev) {
        eparam.cei = *eparam.pceiPrev;
        eparam.phdPrev =  CHistoryData::s_GetHistoryData(eparam.pceiPrev);
    }

    // First, enemerate once to get the size for extra. 
    eparam.cei.lpHeaderInfo = NULL;
    eparam.cbHistExtra = 0;
    hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, s_CommitHistItem, (LPARAM)&eparam);

    DWORD dwFlagsPrev = 0;
    if (eparam.phdPrev) {
        eparam.cbHistExtra += eparam.phdPrev->GetTotalExtraSize();
        dwFlagsPrev = eparam.phdPrev->dwFlags;
    }

    TraceMsg(DM_HISTEXTRA, "CUHP::Commit total size is %d", eparam.cbHistExtra);

    CHistoryData* phdNew = CHistoryData::s_AllocateHeaderInfo(
                                eparam.cbHistExtra, eparam.phdPrev,
                                &eparam.cei.dwHeaderInfoSize);

    if (phdNew) {
        eparam.cei.lpHeaderInfo = (LPTSTR)phdNew;
        eparam.phextCur = phdNew->_GetExtra();

        // Enumerate again to fill the extra data. 
        hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, s_CommitHistItem, (LPARAM)&eparam);

        if (eparam.fDirty)
        {
            if (eparam.phdPrev) {
                eparam.phdPrev->CopyExtra(eparam.phextCur);
            }

            TraceMsg(DM_HISTPROP, "CUHP::Commit It's dirty. save it (header = %d bytes)",
                     eparam.cei.dwHeaderInfoSize);

            ASSERT(eparam.cbHistExtra == phdNew->GetTotalExtraSize());

            CUrlHistory::s_CommitUrlCacheEntry(buf.szPrefixedUrl, &eparam.cei);

            if ((dwFlagsPrev & PIDISF_RECENTLYCHANGED)
                    != (phdNew->dwFlags & PIDISF_RECENTLYCHANGED))
            {
                // Yes; update the images
                CUrlHistory::s_UpdateIcon(m_pintshcut, dwFlagsPrev);
            }
        }

        LocalFree(phdNew);
        phdNew = NULL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\util.cpp ===
#include "priv.h"
#include "sccls.h"
#include "shlobj.h"

#include <tchar.h>

#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif

#include "resource.h"
#include "mshtml.h"     // for IHTMLElement
#include "mlang.h"      // fo char conversion
#include <advpub.h>     // for IE activesetup GUID
#include "winineti.h"   // For name of a mutex used in IsWininetLoadedAnywhere()
#include "htregmng.h"
#include <ntverp.h>
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>
#include <winuser.h>
#include <mluisupp.h>
#include "shdocfl.h"
#include <shlwapip.h>
#include "inetnot.h"
#include <shfolder.h>

#include "..\inc\brutil.cpp"

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

const VARIANT c_vaEmpty = {0};

const TCHAR c_szRegKeyTypedURLs[]     = TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs");

#define DM_SESSIONCOUNT     0

int     g_cxIcon = 0;
int     g_cyIcon = 0;
int     g_cxSmIcon = 0;
int     g_cySmIcon = 0;


const DISPPARAMS c_dispparamsNoArgs = {NULL, NULL, 0, 0};
const LARGE_INTEGER c_li0 = { 0, 0 };

const ITEMIDLIST s_idlNULL = { 0 } ;

// 07.28.2000 - Moved from urlhist.cpp since its used in two places now.
#ifdef UNICODE
#define SHGETFOLDERPATH "SHGetFolderPathW"
#else
#define SHGETFOLDERPATH "SHGetFolderPathA"
#endif
#undef SHGetFolderPath
typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

PFNSHGETFOLDERPATH g_pfnGetFolderPath = NULL;

HRESULT SHGetFolderPathD(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
{
    if (!g_pfnGetFolderPath)
    {
        // note, this is already loaded so this LoadLibray() is fast
        HMODULE hmod = LoadLibrary(TEXT("shell32.dll"));
        g_pfnGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, SHGETFOLDERPATH);

        // not there, must be downlevel shell32, use shfolder.dll instead
        if (!g_pfnGetFolderPath)
        {
            hmod = LoadLibrary(TEXT("shfolder.dll"));
            g_pfnGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, SHGETFOLDERPATH);
        }
        // note, we leak the hmod, for shell32/shfolder that is OK
    }

    HRESULT hr;
    if (g_pfnGetFolderPath) 
        hr = g_pfnGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);
    else
    {
        *pszPath = 0;
        hr = E_FAIL;
    }
    return hr;
}


int InitColorDepth(void)
{
    static int s_lrFlags = 0;              // Flags passed to LoadImage
    if (s_lrFlags == 0)
    {
        int nColorRes, nIconDepth = 0;
        HKEY hkey;

        // Determine the color depth so we can load the best image
        // (This code was stolen from FileIconInit in shell32)

        // Get the user preferred icon size (and color depth) from the
        // registry.
        //
        if (NO_ERROR == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_METRICS, &hkey))
        {
            nIconDepth = SHRegGetIntW(hkey, L"Shell Icon Bpp", nIconDepth);
            RegCloseKey(hkey);
        }

        nColorRes = GetCurColorRes();

        if (nIconDepth > nColorRes)
            nIconDepth = 0;

        if (nColorRes <= 8)
            nIconDepth = 0; // wouldn't have worked anyway

        if (nColorRes > 4 && nIconDepth <= 4)
            s_lrFlags = LR_VGACOLOR;
        else
            s_lrFlags = LR_DEFAULTCOLOR;
    }
    return s_lrFlags;
}

HICON   g_hiconSplat = NULL;
HICON   g_hiconSplatSm = NULL;      // small version

void LoadCommonIcons(void)
{
    if (NULL == g_hiconSplat)
    {
        // Use LoadLibraryEx so we don't load code pages
        HINSTANCE hinst = LoadLibrary(TEXT("url.dll"));
        if (hinst)
        {
            int lrFlags = InitColorDepth();
            g_hiconSplat   = (HICON)LoadImage(hinst, MAKEINTRESOURCE(IDI_URL_SPLAT), IMAGE_ICON, g_cxIcon, g_cyIcon, lrFlags);
            g_hiconSplatSm = (HICON)LoadImage(hinst, MAKEINTRESOURCE(IDI_URL_SPLAT), IMAGE_ICON, g_cxSmIcon, g_cySmIcon, lrFlags);

            FreeLibrary(hinst);
        }
    }
}

STDAPI_(BOOL) UrlHitsNetW(LPCWSTR pszURL)
{
    BOOL fResult;

    // Handle the easy ones on our own and call URLMON for the others.

    switch (GetUrlScheme(pszURL))
    {
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
        // DSheldon - What about UNC and WebDav?
        fResult = FALSE;
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_FTP:
    case URL_SCHEME_GOPHER:
    case URL_SCHEME_TELNET:
    case URL_SCHEME_WAIS:
        fResult = TRUE;
        break;

    default:
        {
        DWORD fHitsNet;
        DWORD dwSize;
        fResult = SUCCEEDED(CoInternetQueryInfo(
                            pszURL, QUERY_USES_NETWORK,
                            0, &fHitsNet, sizeof(fHitsNet), &dwSize, 0)) && fHitsNet;
        }
    }

    return fResult;
}

STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption)
{
    DWORD fRetVal;
    DWORD dwSize;
    return SUCCEEDED(CoInternetQueryInfo(
                        pszURL, QueryOption,
                        0, &fRetVal, sizeof(fRetVal), &dwSize, 0)) && fRetVal;
}

// see if a given URL is in the cache
STDAPI_(BOOL) UrlIsInCache(LPCTSTR pszURL)
{
    return CallCoInternetQueryInfo(pszURL, QUERY_IS_CACHED);
}

// see if a given URL is in the cache OR if it is mapped

STDAPI_(BOOL) UrlIsMappedOrInCache(LPCTSTR pszURL)
{
    return CallCoInternetQueryInfo(pszURL, QUERY_IS_CACHED_OR_MAPPED);
}

BOOL IsFileUrlW(LPCWSTR pcwzUrl)
{
    return (GetUrlSchemeW(pcwzUrl) == URL_SCHEME_FILE);
}

BOOL IsFileUrl(LPCSTR psz)
{
    return (GetUrlSchemeA(psz) == URL_SCHEME_FILE);
}

BOOL PathIsFilePath(LPCWSTR lpszPath)
{
    if ((lpszPath[0] == TEXT('\\')) || (lpszPath[0] != TEXT('\0') && lpszPath[1] == TEXT(':')))
        return TRUE;

    return IsFileUrlW(lpszPath);
}

BOOL IsSubscribableW(LPCWSTR pszUrl)
{
    //  FEATURE: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeW(pszUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

DWORD SHRandom(void)
{
    GUID guid;
    DWORD dw;

    CoCreateGuid(&guid);
    HashData((LPBYTE)&guid, SIZEOF(guid), (LPBYTE)&dw, SIZEOF(dw));

    return dw;
}

// See if we are hosted by IE (explorer.exe or iexplore.exe)
BOOL IsInternetExplorerApp()
{
    if ((g_fBrowserOnlyProcess) ||                  // if in iexplore.exe process,
        (GetModuleHandle(TEXT("EXPLORER.EXE"))))        // or explorer.exe process,
    {
        return TRUE;                                // then we are IE
    }

    return FALSE;
}

BOOL IsTopFrameBrowser(IServiceProvider *psp, IUnknown *punk)
{
    IShellBrowser *psb;

    ASSERT(psp);
    ASSERT(punk);

    BOOL fRet = FALSE;
    if (SUCCEEDED(psp->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        fRet = IsSameObject(psb, punk);
        psb->Release();
    }
    return fRet;
}

STDAPI_(BSTR) LoadBSTR(UINT uID)
{
    WCHAR wszBuf[MAX_PATH];
    if (MLLoadStringW(uID, wszBuf, ARRAYSIZE(wszBuf)))
    {
        return SysAllocString(wszBuf);
    }
    return NULL;
}

BOOL StringIsUTF8W(LPCWSTR pwz, DWORD cb)
{
    BOOL  fRC = FALSE;
    WCHAR *pb;
    WCHAR b;
    DWORD dwCnt;
    DWORD dwUTF8Cnt;

    if (!pwz || !(*pwz) || cb == 0)
        return(FALSE);

    pb = (WCHAR*)pwz;
    while(cb-- && *pb)
    {
        if (*pb > 255)   // Non ansi so bail
            return(FALSE);
            
        if ((*pb & 0xc0) == 0xc0) // bit pattern starts with 11
        {
            dwCnt = dwUTF8Cnt = 0;
            b = *pb;
            while((b & 0xc0) == 0xc0)
            {
                dwCnt++;
                if ((*(pb+dwCnt) & 0xc0) == 0x80)   // bits at dwCnt bytes from current offset in str aren't 10
                    dwUTF8Cnt++;
                b = (b << 1) & 0xff;
            }
            if (dwCnt == dwUTF8Cnt)
                fRC = TRUE;       // Found UTF8 encoded chars
                
            pb += ++dwCnt;
        }
        else
        {
            pb++;
        }
    }

    return(fRC);
}

BOOL UTF8Enabled(void)
{
    static DWORD   dwIE = URL_ENCODING_NONE;
    DWORD dwOutLen = sizeof(DWORD);
    
    if (dwIE == URL_ENCODING_NONE)
        UrlMkGetSessionOption(URLMON_OPTION_URL_ENCODING, &dwIE, sizeof(DWORD), &dwOutLen, NULL);
    return dwIE == URL_ENCODING_ENABLE_UTF8;
}

//
// PrepareURLForDisplay
//
//     Decodes without stripping file:// prefix
//

#undef PrepareURLForDisplay
BOOL PrepareURLForDisplayW(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut)
{
    if (PathIsFilePath(pwz))
    {
        if (IsFileUrlW(pwz))
            return SUCCEEDED(PathCreateFromUrlW(pwz, pwzOut, pcbOut, 0));

        StrCpyNW(pwzOut, pwz, *pcbOut);
        *pcbOut = lstrlenW(pwzOut);
        return TRUE;
    }
    
    BOOL fRet = SUCCEEDED(UrlUnescapeW((LPWSTR)pwz, pwzOut, pcbOut, 0));
    if (fRet)
    {
        SHCleanupUrlForDisplay(pwzOut);
    }
    return fRet;
}

// ****************************************************************************
// BEGIN - MOVE TO SHLWAPI
//
// TODO (grzegorz): move this code to shlwapi.dll
// ****************************************************************************

#define QUERY       L'?'
#define POUND       L'#'
#define HEX_ESCAPE  L'%'
#define TERMSTR(pch)      *(pch) = L'\0'

BOOL IsHex(WCHAR ch)
{
    return (   (ch >= TEXT('0') && ch <= TEXT('9')) 
            || (ch >= TEXT('A') && ch <= TEXT('F'))
            || (ch >= TEXT('a') && ch <= TEXT('f')));
}

WORD HexToWord(WCHAR ch)
{
    if(ch >= TEXT('0') && ch <= TEXT('9'))
        return (WORD) ch - TEXT('0');
    if(ch >= TEXT('A') && ch <= TEXT('F'))
        return (WORD) ch - TEXT('A') + 10;
    if(ch >= TEXT('a') && ch <= TEXT('f'))
        return (WORD) ch - TEXT('a') + 10;

    ASSERT(FALSE);  //we have tried to use a non-hex number
    return (WORD) -1;
}

inline BOOL IsEscapedOctetW(LPCWSTR pch)
{
    return (pch[0] == HEX_ESCAPE && IsHex(pch[1]) && IsHex(pch[2])) ? TRUE : FALSE;
}

WCHAR TranslateEscapedOctetW(LPCWSTR pch)
{
    WCHAR ch;
    ASSERT(IsEscapedOctetW(pch));

    pch++;
    ch = (WCHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}

HRESULT CopyOutW(PSHSTRW pstr, LPWSTR psz, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if ((*pcch > cch) && psz)
        StrCpyNW(psz, pstr->GetStr(), cch + 1);
    else
        hr = E_POINTER;

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

HRESULT ShdocvwUrlUnescapeInplaceW(LPWSTR psz, DWORD dwFlags, UINT uiCP)
{
    WCHAR *pchSrc = psz;
    WCHAR *pchDst = psz;

    HRESULT hr = S_OK;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            StrCpyNW(pchDst, pchSrc, lstrlenW(pchSrc));
            pchDst += lstrlenW(pchDst);
            break;
        }

        if (IsEscapedOctetW(pchSrc))
        {
            int cchAnsi = 0;
            int cchDst;
            SHSTRA strAnsi;
            LPSTR pchDstAnsi;

            hr = strAnsi.SetStr(pchDst);
            if (FAILED(hr))
                return hr;
            else
                pchDstAnsi = strAnsi.GetInplaceStr();

            while (*pchSrc && IsEscapedOctetW(pchSrc))
            {
                WCHAR ch =  TranslateEscapedOctetW(pchSrc);

                *pchDstAnsi++ = LOBYTE(ch);
                pchSrc += 3; // enuff for "%XX"
                cchAnsi++;
            }

            if (cchAnsi)
            {
                TERMSTR(pchDstAnsi);
                // we have min 2 extra chars in pchDst to use, so we can pass cchAnsi + 1
                cchDst = SHAnsiToUnicodeCP(uiCP, strAnsi, pchDst, cchAnsi + 1);
                pchDst += cchDst - 1;
            }
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return hr;
}

HRESULT ShdocvwUrlUnescapeW(LPWSTR pszUrl, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags, UINT uiCP)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "ShdocvwUrlUnescapeW: Caller passed invalid pszUrl");

    if (dwFlags & URL_UNESCAPE_INPLACE)
    {
        return ShdocvwUrlUnescapeInplaceW(pszUrl, dwFlags, uiCP);
    }

    RIPMSG(NULL != pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "ShdocvwUrlUnescapeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL == pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "ShdocvwUrlUnescapeW: Caller passed invalid pszOut");

    if (   !pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRW str;
    HRESULT hr = str.SetStr(pszUrl);
    if (SUCCEEDED(hr))
    {
        ShdocvwUrlUnescapeInplaceW(str.GetInplaceStr(), dwFlags, uiCP);
        hr = CopyOutW(&str, pszOut, pcchOut);
    }

    return hr;
}
// ****************************************************************************
// END - MOVE TO SHLWAPI
// ****************************************************************************

//
// PrepareURLForDisplayUTF8W
//
// pwz -          [In] UTF8 encoded string like "%e6%aa%e4%a6.doc".
// pwzOut -       [Out]  UTF8 decoded string.
// pcchOut -      [In/Out] Count of characters in pwzOut on input.  Number of chars copies to pwzOut on output
//                         including the terminating null.
// fUTF8Enabled - [In] Flag to indicated whether UTF8 is enabled.
// uiCP -         [In] Codepage used to convert escaped characters, when fUTF8Enabled is false
//
// pwz and pwzOut can be the same buffer.
//
// Returns:
//    S_OK upon success.
//    E_FAIL for failure.
//    ERROR_BUFFER_OVERFLOW if the number of converted chars is greater than the passed in size of output buffer.
//
//    Note: If UTF8 is not enabled or the string does not contain UTF8 the output string will be unescaped
//    and will return S_OK.
//
HRESULT _PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled, UINT uiCP)
{
    HRESULT hr = E_FAIL;
    DWORD   cch;
    DWORD   cch1;
    CHAR    szBuf[MAX_URL_STRING];
    CHAR    *pszBuf = szBuf;

    if (!pwz || !pwzOut || !pcchOut)
    {
        if (pcchOut)
            *pcchOut = 0;
        return(hr);
    }
        
    cch = *pcchOut;
    cch1 = ARRAYSIZE(szBuf);
    if (uiCP != (UINT)-1)
        hr = ShdocvwUrlUnescapeW((LPWSTR)pwz, pwzOut, pcchOut, 0, fUTF8Enabled ? CP_UTF8 : uiCP);
    else
    {
        hr = UrlUnescapeW((LPWSTR)pwz, pwzOut, pcchOut, 0);
        if (SUCCEEDED(hr))
        {
            if (fUTF8Enabled && StringIsUTF8W(pwzOut, cch))
            {
                if (*pcchOut > ARRAYSIZE(szBuf)) // Internal buffer not big enough so alloc one
                {
                    if ((pszBuf = (CHAR *)LocalAlloc(LPTR, ((*pcchOut)+1) * sizeof(CHAR))) == NULL)
                    {
                        *pcchOut = 0;
                        return(E_OUTOFMEMORY);
                    }
                    cch1 = *pcchOut;
                }

                // Compress wide string
                CHAR *pIn = (CHAR *)pwzOut;
                CHAR *pOut = pszBuf;
                while((*pIn != '\0') || (*(pIn+1) != '\0') && --cch1)
                {
                    if (*pIn != '\0')
                    {
                        *pOut = *pIn;
                        pOut++;
                    }
                    pIn++;
                }
                *pOut = '\0';

                // Convert to UTF8 wide string
                if ((cch1 = SHAnsiToUnicodeCP(CP_UTF8, pszBuf, pwzOut, cch)) != 0)
                {
                    hr = S_OK;
                    *pcchOut = cch1;
                }

                // SHAnsiToUnicode doesn't tell us if it has truncated the convertion to fit the output buffer
                RIPMSG(cch1 != cch, "_PrepareURLForDisplayUTF8W: Passed in size of out buf equal to converted size; buffer might be truncated");

                if ((pszBuf != NULL) && (pszBuf != szBuf))
                {
                    LocalFree((CHAR *)pszBuf);
                    pszBuf = NULL;
                }
            }
            else
            {
                hr = S_OK;;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        SHCleanupUrlForDisplay(pwzOut);
    }

    return(hr);
}

HRESULT PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled)
{
    return _PrepareURLForDisplayUTF8W(pwz, pwzOut, pcchOut, fUTF8Enabled, (UINT)-1);
}

//
// PrepareURLForExternalApp -
//
//   Decodes and strips, if needed, file:// prefix
//

//  APPCOMPAT - for IE30 compatibility reasons, we have to Unescape all Urls - zekel - 1-JUL-97
//  before passing them to an APP.  this does limit their use, but
//  people already depend on this behavior.  specifically MS Chat.
BOOL PrepareURLForExternalApp (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut)
{
    if (IsFileUrlW(psz))
        return SUCCEEDED(PathCreateFromUrl(psz, pszOut, pcchOut, 0));
    else
        return SUCCEEDED(UrlUnescape((LPWSTR)psz, pszOut, pcchOut, 0));

}

SHDOCAPI
IURLQualifyWithContext(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    IN  DWORD cchTranslatedURL,
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected,
    ISearchContext *  pSC);


BOOL ParseURLFromOutsideSourceWithContextW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, ISearchContext * pSC)
{
    // This is our hardest case.  Users and outside applications might
    // type fully-escaped, partially-escaped, or unescaped URLs at us.
    // We need to handle all these correctly.  This API will attempt to
    // determine what sort of URL we've got, and provide us a returned URL
    // that is guaranteed to be FULLY escaped.
    
    IURLQualifyWithContext(psz, UQF_DEFAULT, *pcchOut, pszOut, pbWasSearchURL, NULL, pSC);

    //
    //  go ahead and canonicalize this appropriately
    //
    if (FAILED(UrlCanonicalize(pszOut, pszOut, pcchOut, URL_ESCAPE_SPACES_ONLY)))
    {
        //
        //  we cant resize from here.
        //  NOTE UrlCan will return E_POINTER if it is an insufficient buffer
        //
        TraceMsg(DM_ERROR, "sdv PUFOS:UC() failed.");
        return FALSE;
    }

    return TRUE;
} // ParseURLFromOutsideSource

BOOL ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL)
{
    return ParseURLFromOutsideSourceWithContextW(psz, pszOut, pcchOut, pbWasSearchURL, NULL);
} // ParseURLFromOutsideSource
BOOL ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL)
{
    SHSTRW strw;
    DWORD cch ;

    ASSERT(psz);
    ASSERT(pszOut);
    ASSERT(pcchOut && *pcchOut);

    //
    //  WARNING: we arent guaranteed to have the correct cch's here - zekel - 27-jan-97
    //  but for now this is adequate.
    //
    if (SUCCEEDED(strw.SetStr(psz)) && SUCCEEDED(strw.SetSize(cch = *pcchOut)) &&
        ParseURLFromOutsideSourceW(strw, strw.GetInplaceStr(), pcchOut, pbWasSearchURL))
    {
        return SHUnicodeToAnsi((LPCWSTR)strw, pszOut, cch);
    }

    return FALSE;
}

int DPA_ILFreeCallback(void * p, void * d)
{
    Pidl_Set((LPITEMIDLIST*)&p, NULL);
    return 1;
}

void _DeletePidlDPA(HDPA hdpa)
{
    DPA_DestroyCallback(hdpa, (PFNDPAENUMCALLBACK)DPA_ILFreeCallback, 0);
    hdpa = NULL;
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}

#ifndef ALPHA_WARNING_IS_DUMB

#pragma message("building with alpha warning enabled")

void AlphaWarning(HWND hwnd)
{
    static BOOL fShown = FALSE;
    TCHAR szTemp[265];
    TCHAR szFull[2048];
    szFull[0] = TEXT('\0');
    int i = IDS_ALPHAWARNING;

    if (fShown)
        return;

    fShown = TRUE;

    while(MLLoadShellLangString (i++, szTemp, ARRAYSIZE(szTemp))) {
        StrCatBuff(szFull, szTemp, ARRAYSIZE(szFull));
    }

    MessageBox(hwnd, szFull, TEXT("Internet Explorer"), MB_ICONINFORMATION | MB_OK);
}
#endif


#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0

PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister = NULL;
PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister = NULL;

BOOL g_fNewNotify = FALSE;   // Are we using classic mode (W95 or new mode?

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

BOOL SHIsRegisteredClient(LPCTSTR pszClient)
{
    LONG cbSize = 0;
    TCHAR szKey[80];

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("Software\\Clients\\%s"), pszClient);
    return (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, NULL, &cbSize) == ERROR_SUCCESS) &&
           (cbSize > sizeof(TCHAR));
}

// Exporting by ordinal is not available on UNIX.
// But we have all these symbols exported because it's UNIX default.
#ifdef UNIX
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _fname)
#else
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _ord)
#endif

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne;

    // See if we need to still figure out which version of SHChange Notify to call?
    if  (g_pfnSHChangeNotifyDeregister == NULL)
    {

        HMODULE hmodShell32 = ::GetModuleHandle(TEXT("SHELL32"));
        if (!hmodShell32)
            return 0;   // Nothing registered...

        g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                          "NTSHChangeNotifyRegister",
                                                                                          (LPSTR)640);
        if (g_pfnSHChangeNotifyRegister && (WhichPlatform() == PLATFORM_INTEGRATED))
        {
            g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                                  "NTSHChangeNotifyDeregister",
                                                                                                  (LPSTR)641);
            g_fNewNotify = TRUE;
        }
        else
        {
            g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                              "SHChangeNotifyRegister",
                                                                                              (LPSTR)2);
            g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                                  "SHChangeNotifyDeregister",
                                                                                                  (LPSTR)4);
        }

        if  (g_pfnSHChangeNotifyDeregister == NULL)
            return 0;   // Could not get either to work...
    }

    uFlags |= SHCNRF_ShellLevel | SHCNRF_InterruptLevel;
    if (g_fNewNotify)
        uFlags |= SHCNRF_NewDelivery;

    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;
    return g_pfnSHChangeNotifyRegister(hwnd, uFlags, dwEvents, nMsg, 1, &fsne);
}

//----------------------------------------------------------------------------
// Just like shells SHRestricted() only this put up a message if the restricion
// is in effect.
// REARCHITECT: this function is identical to shell32's SHIsRestricted
BOOL SHIsRestricted(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        SHRestrictedMessageBox(hwnd);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    if (SHRestricted2W(rest, pwzUrl, dwReserved))
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        SHRestrictedMessageBox(hwnd);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid)
{
    switch (uViewMode)
    {
    case FVM_ICON:
        *pvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *pvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *pvid = VID_List;
        break;

    case FVM_DETAILS:
        *pvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *pvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *pvid = VID_Tile;
        break;

    default:
        *pvid = VID_LargeIcons;
        return(FALSE);
    }

    return(TRUE);
}

HIMAGELIST g_himlSysSmall = NULL;
HIMAGELIST g_himlSysLarge = NULL;

void _InitSysImageLists()
{
    if (!g_himlSysSmall)
    {
        Shell_GetImageLists(&g_himlSysLarge, &g_himlSysSmall);

        ImageList_GetIconSize(g_himlSysLarge, &g_cxIcon, &g_cyIcon);
        ImageList_GetIconSize(g_himlSysSmall, &g_cxSmIcon, &g_cySmIcon);
    }
}

// Copied from shell32 (was _ILCreate), which does not export this.
// The fsmenu code needs this function.
STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // needed for external task allicator

    return pidl;
}

DWORD CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt)
{
    DWORD dwEffect = DROPEFFECT_NONE;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pdtobj->QueryGetData(&fmte) == S_OK)
        dwEffect = DROPEFFECT_COPY | DROPEFFECT_LINK;
    else
    {
        InitClipboardFormats();

        fmte.cfFormat = g_cfHIDA;
        if (pdtobj->QueryGetData(&fmte) == S_OK)
            dwEffect = DROPEFFECT_LINK;
        else {
            fmte.cfFormat = g_cfURL;

            if (pdtobj->QueryGetData(&fmte) == S_OK)
                dwEffect = DROPEFFECT_LINK | DROPEFFECT_COPY | DROPEFFECT_MOVE;
        }
    }

    return dwEffect;
}



// MapNbspToSp
//
// Purpose:
//     dsheldon: nbsp == Non-breaking space
//     Unicode character code point 0x00a0 is designated to HTML
//     entity &nbsp, but some windows code pages don't have code
//     point that can map from 0x00a0. In the most occasion in the
//     shell, NBSP is just a space when it's rendered so we can
//     replace it with 0x0020 safely.
//     This function takes lpwszIn as a string that has
//     non-displayable characters in it, and tries to translate
//     it again after removing NBSP (00a0) from it.
//     returns S_OK if this re-translation is successful.
//
#define nbsp 0x00a0
HRESULT SHMapNbspToSp(LPCWSTR lpwszIn, LPSTR lpszOut, int cbszOut)
{
    BOOL fFoundNbsp = FALSE;
    BOOL fNotDisplayable = TRUE; // assumes FAIL
    LPWSTR pwsz, p;

    if (!lpwszIn || !lpszOut || cbszOut == 0)
        return E_FAIL;

    ASSERT(IS_VALID_STRING_PTRW(lpwszIn, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(lpszOut, TCHAR, cbszOut));

    int cch = lstrlenW(lpwszIn) + 1;
    pwsz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
    if (pwsz)
    {
        StrCpyNW(pwsz, lpwszIn, cch);
        p = pwsz;
        while (*p)
        {
            if (*p== nbsp)
            {
                *p= 0x0020; // replace with space
                if (!fFoundNbsp)
                    fFoundNbsp = TRUE;
            }
            p++;
        }

        // don't call WC2MB unless we found Nbsp - for perf reason
        if (fFoundNbsp)
        {
            int iret = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, lpszOut,
                                           cbszOut, NULL, &fNotDisplayable);

            if (!fNotDisplayable && iret == 0)
            {
                // truncated. make it dbcs safe.
                SHTruncateString(lpszOut, cbszOut);
            }
        }

        LocalFree((LOCALHANDLE)pwsz);
        pwsz = NULL;
    }

    return (fFoundNbsp && !fNotDisplayable) ? S_OK : S_FALSE;
}
#undef nbsp


int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault)
{
    SHPropertyBag_ReadInt(pPropBag, pszKey, &iDefault);
    return iDefault;
}

HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    InitClipboardFormats();

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfPreferredEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hres))
        {
            GlobalFree((HGLOBAL)pdw);
            pdw = NULL;
        }
    }
    return hres;
}

HRESULT DragDrop(HWND hwnd, IShellFolder * psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD *pdwEffect)
{
    HRESULT hres = E_FAIL;
    LPCITEMIDLIST pidlChild;

    if (!psfParent)
        IEBindToParentFolder(pidl, &psfParent, &pidlChild);
    else 
    {
        pidlChild = pidl;
        psfParent->AddRef();
    }

    if (psfParent)
    {
        DWORD dwAttrib = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

        psfParent->GetAttributesOf(1, &pidlChild, &dwAttrib);

        IDataObject *pdtobj;
        hres = psfParent->GetUIObjectOf(NULL, 1, &pidlChild, IID_IDataObject, NULL, (void**)&pdtobj);
        if (SUCCEEDED(hres))
        {
            DWORD dwEffect = (DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK) & dwAttrib;

            if (dwPrefEffect)
            {
                //win95 shell32 doesn't know about preferred drop effect, so make it the only effect
                if (IsOS(OS_WIN95ORGREATER) && (WhichPlatform() == PLATFORM_BROWSERONLY))
                {
                    dwEffect = DROPEFFECT_LINK & dwAttrib;
                }
                else if (dwPrefEffect & dwEffect)
                {
                    _SetPreferredDropEffect(pdtobj, dwPrefEffect);
                }
            }
            ASSERT(dwEffect);

            // Win95 Browser Only - the shell32 in this process doesn't know
            // ole is loaded, even though it is.
            SHLoadOLE(SHELLNOTIFY_OLELOADED);
            IDragSourceHelper* pDragImages;

            if (SUCCEEDED(CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDragSourceHelper, &pDragImages))))
            {
                pDragImages->InitializeFromWindow(hwnd, 0, pdtobj);
                pDragImages->Release();
            }

            hres = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffect);
            if (pdwEffect)
                *pdwEffect = dwEffect;

            pdtobj->Release();
        }

        psfParent->Release();
    }

    return hres;
}

#define IEICONTYPE_GETFILEINFO              0x00000001
#define IEICONTYPE_DEFAULTICON              0x00000002

typedef struct tagIEICONS
{
    int nDefaultIcon;
    int nIEIcon;
    LPCTSTR szFile;
    LPCTSTR szFileExt;
    int nIconResourceNum;
    LPCTSTR szCLSID;
    DWORD dwType;
} IEICONS;

IEICONS g_IEIcons[] = {
    {-1, -1, TEXT("MSHTML.DLL"), TEXT(".htm"), 1, NULL, IEICONTYPE_GETFILEINFO},
    {-1, -1, TEXT("URL.DLL"), TEXT("http\\DefaultIcon"), 0, TEXT("{FBF23B42-E3F0-101B-8488-00AA003E56F8}"), IEICONTYPE_DEFAULTICON}
};

//This function returns the IE icon regardless of the which browser is  default


void _GenerateIEIcons(void)
{
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(g_IEIcons); nIndex++)
    {
        SHFILEINFO sfi;
        TCHAR szModule[MAX_PATH];

        HMODULE hmod = GetModuleHandle(g_IEIcons[nIndex].szFile);
        if (hmod)
        {
            GetModuleFileName(hmod, szModule, ARRAYSIZE(szModule));
        }
        else
        {   //HACKHACK : This is a hack to get the mstml
            TCHAR   szKey[GUIDSTR_MAX * 4];
            TCHAR   szGuid[GUIDSTR_MAX];

            //The CLSID used here belongs to MS HTML Generic Page. If someone changes the guid then we
            // are  tossed.
            if (!g_IEIcons[nIndex].szCLSID)
                SHStringFromGUID(CLSID_HTMLDocument, szGuid, GUIDSTR_MAX);
            wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\InProcServer32"), g_IEIcons[nIndex].szCLSID ? g_IEIcons[nIndex].szCLSID : szGuid);

            long cb = SIZEOF(szModule);
            RegQueryValue(HKEY_CLASSES_ROOT, szKey, szModule, &cb);

        }
        g_IEIcons[nIndex].nIEIcon = Shell_GetCachedImageIndex(szModule, g_IEIcons[nIndex].nIconResourceNum, 0);

        switch(g_IEIcons[nIndex].dwType)
        {
        case IEICONTYPE_GETFILEINFO:
            sfi.iIcon = 0;
            StrCpyN(szModule, TEXT("c:\\notexist"), ARRAYSIZE(szModule));
            StrCatBuff(szModule, g_IEIcons[nIndex].szFileExt, ARRAYSIZE(szModule));
            SHGetFileInfo(szModule, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);
            g_IEIcons[nIndex].nDefaultIcon = sfi.iIcon;
            break;

        case IEICONTYPE_DEFAULTICON:
            {
                TCHAR szPath[MAX_PATH];
                DWORD cbSize = SIZEOF(szPath);

                SHGetValue(HKEY_CLASSES_ROOT, g_IEIcons[nIndex].szFileExt, TEXT(""), NULL, szPath, &cbSize);
                g_IEIcons[nIndex].nDefaultIcon = Shell_GetCachedImageIndex(szPath, PathParseIconLocation(szPath), 0);
            }
            break;
        }
    }
}

int IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int *piSelectedImage)
{
    int nIndex;
    int nIcon = SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, piSelectedImage);

    if (-1 == g_IEIcons[0].nDefaultIcon)
        _GenerateIEIcons();

    for (nIndex = 0; nIndex < ARRAYSIZE(g_IEIcons); nIndex++)
    {
        if ((nIcon == g_IEIcons[nIndex].nDefaultIcon) ||
            (piSelectedImage && *piSelectedImage == g_IEIcons[nIndex].nDefaultIcon))
        {
            nIcon = g_IEIcons[nIndex].nIEIcon;
            if (piSelectedImage)
                *piSelectedImage = nIcon;
            break;
        }
    }
    return nIcon;
}

void IEInvalidateImageList(void)
{
    g_IEIcons[0].nDefaultIcon = -1;
}

int _GetIEHTMLImageIndex()
{
    if (-1 == g_IEIcons[0].nDefaultIcon)
        _GenerateIEIcons();

    return g_IEIcons[0].nIEIcon;
}

// Checks to see if any process at all
// has loaded wininet
static BOOL g_fWininetLoadedSomeplace = FALSE;
BOOL IsWininetLoadedAnywhere()
{
    HANDLE hMutex = NULL;
    BOOL fRet;

    if (g_fWininetLoadedSomeplace)
        return TRUE;

    //
    // Use OpenMutexA so it works on W95.
    // wininet is ansi and created this mutex with CreateMutexA
    hMutex = OpenMutexA(SYNCHRONIZE, FALSE, WININET_STARTUP_MUTEX);

    if (hMutex)
    {
        fRet = TRUE;
        g_fWininetLoadedSomeplace = TRUE;
        CloseHandle(hMutex);
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}



//   Checks if global state is offline
BOOL SHIsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if (!IsWininetLoadedAnywhere())
        return FALSE;

    // Since wininet is already loaded someplace
    // We have to load wininet to check if offline

    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci = {0};
    if (fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

// This API is documented and is called by apps outside
// the shell such as OE
STDAPI_(void) SetShellOfflineState(BOOL fPutOffline)
{
    BOOL fWasOffline = SHIsGlobalOffline();
    if (fWasOffline != fPutOffline)
    {   
        SetGlobalOffline(fPutOffline); // Set the state
        // Tell all browser windows to update their title   
        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); 
    }
}


BOOL GetHistoryFolderPath(LPTSTR pszPath, int cchPath)
{
    INTERNET_CACHE_CONFIG_INFO cci;
    DWORD cbcci = sizeof(INTERNET_CACHE_CONFIG_INFO);

    if (GetUrlCacheConfigInfo(&cci, &cbcci, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        StrCpyN(pszPath, cci.CachePaths[0].CachePath, cchPath);
        return TRUE;
    }
    return FALSE;
}

// in:
//      pidlRoot    root part of pidl.
//      pidl        equal to or child below pidlRoot
//      pszKey      root key to store stuff under, should match pidlRoot
//      grfMode     read/write
//
// example:
//      pidlRoot = c:\win\favorites
//      pidl     = c:\win\favorites\channels
//      pszKey   = "MenuOrder\Favorites"
//      result -> stream comes from HKCU\...\MenuOrder\Favorites\channels
//

IStream * OpenPidlOrderStream(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidl, LPCSTR pszKey, DWORD grfMode)
{
    LPITEMIDLIST pidlAlloc = NULL;
    TCHAR   szRegPath[MAX_URL_STRING];
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    SHAnsiToTChar(pszKey, szKey, ARRAYSIZE(szKey));
    StrCpyN(szRegPath, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, szKey, ARRAYSIZE(szRegPath));

    // deal with ordinal vs true pidls
    if (HIWORD(pidlRoot) == 0)
    {
        // Sundown: coercion to int since we are assuming ordinal pidl
        SHGetSpecialFolderLocation(NULL, PtrToLong(pidlRoot), &pidlAlloc);
        pidlRoot = pidlAlloc;
    }

    // build a reg key from the names of the items below the pidlRoot folder. we do
    // this because IEGetDisplayName(SFGAO_FORPARSING) has a bug for file system
    // junctions (channel contents) that returns garbage path names.

    if (pidlRoot)
    {
        LPITEMIDLIST pidlCopy = ILClone(pidl);
        if (pidlCopy)
        {
            LPCITEMIDLIST pidlTail = ILFindChild(pidlRoot, pidlCopy);
            if (pidlTail)
            {
                LPITEMIDLIST pidlNext;
                for (pidlNext = ILGetNext(pidlTail); pidlNext; pidlNext = ILGetNext(pidlNext))
                {
                    WORD cbSave = pidlNext->mkid.cb;
                    pidlNext->mkid.cb = 0;

                    IShellFolder *psf;
                    LPCITEMIDLIST pidlChild;

                    // we do a full bind every time, we could skip this for sub items
                    // and bind from this point down but this code is simpler and binds
                    // aren't that bad...

                    if (SUCCEEDED(IEBindToParentFolder(pidlCopy, &psf, &pidlChild)))
                    {
                        LPWSTR pszName;
                        if (SUCCEEDED(DisplayNameOfAsOLESTR(psf, pidlChild, SHGDN_NORMAL, &pszName)))
                        {
                            StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
                            StrCatBuff(szRegPath, pszName, ARRAYSIZE(szRegPath));
                            CoTaskMemFree(pszName);
                        }
                        psf->Release();
                    }
                    pidlNext->mkid.cb = cbSave;
                }
            }
            ILFree(pidlCopy);
        }
        if (pidlAlloc)
            ILFree(pidlAlloc);
        return SHOpenRegStream(HKEY_CURRENT_USER, szRegPath, TEXT("Order"), grfMode);
    }
    return NULL;
}

/**********************************************************************
* SHRestricted2
*
* These are new restrictions that apply to browser only and integrated
* mode.  (Since we're not changing shell32 in browser only mode, we
* need to duplicate the functionality.)
*
* FEATURE: What window will listen to the WM_WININICHANGE
*           lParam="Policy" message and invalidate the cache?
*           Remember not to cache the per zone values.
\**********************************************************************/

// The ZAW compliant policy location.
const TCHAR c_szInfodeliveryBase[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery");
const TCHAR c_szInfodeliveryKey[] = TEXT("Restrictions");

// The normal policy location.
const TCHAR c_szExplorerBase[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies");
const TCHAR c_szExplorerKey[] = TEXT("Explorer");

// The browser policy location that SP2 used
const TCHAR c_szBrowserBase[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer");
const TCHAR c_szBrowserKey[]  = TEXT("Restrictions");
const TCHAR c_szToolbarKey[]  = TEXT("Toolbars\\Restrictions");

const SHRESTRICTIONITEMS c_rgRestrictionItems[] =
{
    // explorer restrictions
    { REST_NOTOOLBARCUSTOMIZE,      c_szExplorerKey,    TEXT("NoToolbarCustomize") },
    { REST_NOBANDCUSTOMIZE,         c_szExplorerKey,    TEXT("NoBandCustomize")    },
    { REST_SMALLICONS,              c_szExplorerKey,    TEXT("SmallIcons")        },
    { REST_LOCKICONSIZE,            c_szExplorerKey,    TEXT("LockIconSize")      },
    { REST_SPECIFYDEFAULTBUTTONS,   c_szExplorerKey,    TEXT("SpecifyDefaultButtons") },
    { REST_BTN_BACK,                c_szExplorerKey,    TEXT("Btn_Back")      },
    { REST_BTN_FORWARD,             c_szExplorerKey,    TEXT("Btn_Forward")   },
    { REST_BTN_STOPDOWNLOAD,        c_szExplorerKey,    TEXT("Btn_Stop")      },
    { REST_BTN_REFRESH,             c_szExplorerKey,    TEXT("Btn_Refresh")    },
    { REST_BTN_HOME,                c_szExplorerKey,    TEXT("Btn_Home")      },
    { REST_BTN_SEARCH,              c_szExplorerKey,    TEXT("Btn_Search")    },
    { REST_BTN_HISTORY,             c_szExplorerKey,    TEXT("Btn_History")   },
    { REST_BTN_FAVORITES,           c_szExplorerKey,    TEXT("Btn_Favorites") },
    { REST_BTN_ALLFOLDERS,          c_szExplorerKey,    TEXT("Btn_Folders")       },
    { REST_BTN_THEATER,             c_szExplorerKey,    TEXT("Btn_Fullscreen") },
    { REST_BTN_TOOLS,               c_szExplorerKey,    TEXT("Btn_Tools")     },
    { REST_BTN_MAIL,                c_szExplorerKey,    TEXT("Btn_MailNews")  },
    { REST_BTN_FONTS,               c_szExplorerKey,    TEXT("Btn_Size")      },
    { REST_BTN_PRINT,               c_szExplorerKey,    TEXT("Btn_Print")     },
    { REST_BTN_EDIT,                c_szExplorerKey,    TEXT("Btn_Edit")          },
    { REST_BTN_DISCUSSIONS,         c_szExplorerKey,    TEXT("Btn_Discussions")   },
    { REST_BTN_CUT,                 c_szExplorerKey,    TEXT("Btn_Cut")           },
    { REST_BTN_COPY,                c_szExplorerKey,    TEXT("Btn_Copy")          },
    { REST_BTN_PASTE,               c_szExplorerKey,    TEXT("Btn_Paste")         },
    { REST_BTN_ENCODING,            c_szExplorerKey,    TEXT("Btn_Encoding")          },
    { REST_BTN_PRINTPREVIEW,        c_szExplorerKey,    TEXT("Btn_PrintPreview")        },
    { REST_NoUserAssist,            c_szExplorerKey,    TEXT("NoInstrumentation"),      },
    { REST_NoWindowsUpdate,         c_szExplorerKey,    TEXT("NoWindowsUpdate"),        },
    { REST_NoExpandedNewMenu,       c_szExplorerKey,    TEXT("NoExpandedNewMenu"),      },
    { REST_BTN_MEDIABAR,            c_szExplorerKey,    TEXT("Btn_Media"),      },
    // ported from SP1
    { REST_NOFILEURL,               c_szExplorerKey,       TEXT("NoFileUrl"),          },
    // infodelivery restrictions
    { REST_NoChannelUI,             c_szInfodeliveryKey,   TEXT("NoChannelUI")        },
    { REST_NoAddingChannels,        c_szInfodeliveryKey,   TEXT("NoAddingChannels") },
    { REST_NoEditingChannels,       c_szInfodeliveryKey,   TEXT("NoEditingChannels") },
    { REST_NoRemovingChannels,      c_szInfodeliveryKey,   TEXT("NoRemovingChannels") },
    { REST_NoAddingSubscriptions,   c_szInfodeliveryKey,   TEXT("NoAddingSubscriptions") },
    { REST_NoEditingSubscriptions,  c_szInfodeliveryKey,   TEXT("NoEditingSubscriptions") },
    { REST_NoRemovingSubscriptions, c_szInfodeliveryKey,   TEXT("NoRemovingSubscriptions") },
    { REST_NoChannelLogging,        c_szInfodeliveryKey,   TEXT("NoChannelLogging")         },
    { REST_NoManualUpdates,         c_szInfodeliveryKey,   TEXT("NoManualUpdates")        },
    { REST_NoScheduledUpdates,      c_szInfodeliveryKey,   TEXT("NoScheduledUpdates")     },
    { REST_NoUnattendedDialing,     c_szInfodeliveryKey,   TEXT("NoUnattendedDialing")    },
    { REST_NoChannelContent,        c_szInfodeliveryKey,   TEXT("NoChannelContent")       },
    { REST_NoSubscriptionContent,   c_szInfodeliveryKey,   TEXT("NoSubscriptionContent")  },
    { REST_NoEditingScheduleGroups, c_szInfodeliveryKey,   TEXT("NoEditingScheduleGroups") },
    { REST_MaxChannelSize,          c_szInfodeliveryKey,   TEXT("MaxChannelSize")         },
    { REST_MaxSubscriptionSize,     c_szInfodeliveryKey,   TEXT("MaxSubscriptionSize")    },
    { REST_MaxChannelCount,         c_szInfodeliveryKey,   TEXT("MaxChannelCount")        },
    { REST_MaxSubscriptionCount,    c_szInfodeliveryKey,   TEXT("MaxSubscriptionCount")   },
    { REST_MinUpdateInterval,       c_szInfodeliveryKey,   TEXT("MinUpdateInterval")      },
    { REST_UpdateExcludeBegin,      c_szInfodeliveryKey,   TEXT("UpdateExcludeBegin")     },
    { REST_UpdateExcludeEnd,        c_szInfodeliveryKey,   TEXT("UpdateExcludeEnd")       },
    { REST_UpdateInNewProcess,      c_szInfodeliveryKey,   TEXT("UpdateInNewProcess")     },
    { REST_MaxWebcrawlLevels,       c_szInfodeliveryKey,   TEXT("MaxWebcrawlLevels")      },
    { REST_MaxChannelLevels,        c_szInfodeliveryKey,   TEXT("MaxChannelLevels")       },
    { REST_NoSubscriptionPasswords, c_szInfodeliveryKey,   TEXT("NoSubscriptionPasswords")},
    { REST_NoBrowserSaveWebComplete,c_szInfodeliveryKey,   TEXT("NoBrowserSaveWebComplete") },
    { REST_NoSearchCustomization,   c_szInfodeliveryKey,   TEXT("NoSearchCustomization"),  },
    { REST_NoSplash,                c_szInfodeliveryKey,   TEXT("NoSplash"),  },

    // browser restrictions ported from SP2
    { REST_NoFileOpen,              c_szBrowserKey,         TEXT("NoFileOpen"),             },
    { REST_NoFileNew,               c_szBrowserKey,         TEXT("NoFileNew"),              },
    { REST_NoBrowserSaveAs ,        c_szBrowserKey,         TEXT("NoBrowserSaveAs"),        },
    { REST_NoBrowserOptions,        c_szBrowserKey,         TEXT("NoBrowserOptions"),       },
    { REST_NoFavorites,             c_szBrowserKey,         TEXT("NoFavorites"),            },
    { REST_NoSelectDownloadDir,     c_szBrowserKey,         TEXT("NoSelectDownloadDir"),    },
    { REST_NoBrowserContextMenu,    c_szBrowserKey,         TEXT("NoBrowserContextMenu"),   },
    { REST_NoBrowserClose,          c_szBrowserKey,         TEXT("NoBrowserClose"),         },
    { REST_NoOpeninNewWnd,          c_szBrowserKey,         TEXT("NoOpeninNewWnd"),         },
    { REST_NoTheaterMode,           c_szBrowserKey,         TEXT("NoTheaterMode"),          },
    { REST_NoFindFiles,             c_szBrowserKey,         TEXT("NoFindFiles"),            },
    { REST_NoViewSource,            c_szBrowserKey,         TEXT("NoViewSource"),           },
    { REST_GoMenu,                  c_szBrowserKey,         TEXT("RestGoMenu"),             },
    { REST_NoToolbarOptions,        c_szToolbarKey,         TEXT("NoToolbarOptions"),       },
    { REST_AlwaysPromptWhenDownload,c_szBrowserKey,         TEXT("AlwaysPromptWhenDownload"),},

    { REST_NoHelpItem_TipOfTheDay,  c_szBrowserKey,         TEXT("NoHelpItemTipOfTheDay"),  },
    { REST_NoHelpItem_NetscapeHelp, c_szBrowserKey,         TEXT("NoHelpItemNetscapeHelp"), },
    { REST_NoHelpItem_Tutorial,     c_szBrowserKey,         TEXT("NoHelpItemTutorial"),     },
    { REST_NoHelpItem_SendFeedback, c_szBrowserKey,         TEXT("NoHelpItemSendFeedback"), },

    { REST_NoNavButtons,            c_szBrowserKey,         TEXT("NoNavButtons"),           },
    { REST_NoHelpMenu,              c_szBrowserKey,         TEXT("NoHelpMenu"),             },
    { REST_NoBrowserBars,           c_szBrowserKey,         TEXT("NoBrowserBars"),          },
    { REST_NoToolBar,               c_szToolbarKey,         TEXT("NoToolBar"),              },
    { REST_NoAddressBar,            c_szToolbarKey,         TEXT("NoAddressBar"),           },
    { REST_NoLinksBar,              c_szToolbarKey,         TEXT("NoLinksBar"),             },
    
    { REST_NoPrinting,              c_szBrowserKey,         TEXT("NoPrinting")              },

    { REST_No_LaunchMediaBar,       c_szBrowserKey,         TEXT("No_LaunchMediaBar")       },
    { REST_No_MediaBarOnlineContent, c_szBrowserKey,        TEXT("No_MediaBarOnlineContent") },

    {0, NULL, NULL},
};

typedef struct {
    BROWSER_RESTRICTIONS rest;
    DWORD dwAction;    
} ACTIONITEM;

// SECURITY WARNING:
//
// Using url-based restrictions is a potential security risk with SHRestricted2W as implemented:
//     you need a site to find the app-provided SID_SInternetSecurityManager
//     implementation, and this API does not take one.
// Fortunately the only restrictions that get this treatment are the channel restrictions
// which are really Policy decisions.  These only affect some explorer-only UI.
//
const ACTIONITEM c_ActionItems[] = {
    { REST_NoAddingChannels,        URLACTION_INFODELIVERY_NO_ADDING_CHANNELS },
    { REST_NoEditingChannels,       URLACTION_INFODELIVERY_NO_EDITING_CHANNELS },
    { REST_NoRemovingChannels,      URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS },
    { REST_NoAddingSubscriptions,   URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS },
    { REST_NoEditingSubscriptions,  URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS },
    { REST_NoRemovingSubscriptions, URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS },
    { REST_NoChannelLogging,        URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING },
};

#define REST_WITHACTION_FIRST   REST_NoAddingChannels
#define REST_WITHACTION_LAST    REST_NoChannelLogging

#define RESTRICTIONMAX (c_rgRestrictionItems[ARRAYSIZE(c_rgRestrictionItems) - 1].rest)

DWORD g_rgRestrictionItemValues[ARRAYSIZE(c_rgRestrictionItems)];

DWORD SHRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    // Validate restriction and dwReserved
    if (dwReserved)
    {
        RIPMSG(0, "SHRestricted2W: Invalid dwReserved");
        return 0;
    }

    if (!(InRange(rest, REST_EXPLORER_FIRST, REST_EXPLORER_LAST))
        && !(InRange(rest, REST_INFO_FIRST, REST_INFO_LAST))
        && !(InRange(rest, REST_BROWSER_FIRST, REST_BROWSER_LAST)))
    {
        RIPMSG(0, "SHRestricted2W: Invalid browser restriction");
        return 0;
    }

    // See if the restriction is in place in the URL zone
    // FEATURE: Should we assert on NULL URLs if the restriction is per zone?
    // It might be reasonable to query the global setting.
    if (pwzUrl && InRange(rest, REST_WITHACTION_FIRST, REST_WITHACTION_LAST))
    {
        // Compute the index into the table
        int index = rest - REST_WITHACTION_FIRST;

        ASSERT(c_ActionItems[index].dwAction);

        IInternetSecurityManager *pism;
        HRESULT hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                            IID_PPV_ARG(IInternetSecurityManager, &pism));
        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;
            hr = pism->ProcessUrlAction(pwzUrl,
                                        c_ActionItems[index].dwAction,
                                        (BYTE *)&dwPolicy,
                                        sizeof(dwPolicy),
                                        (BYTE *)&dwContext,
                                        sizeof(dwContext),
                                        PUAF_NOUI,
                                        0);
            pism->Release();
            if (SUCCEEDED(hr))
            {
                if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
                    return 0;
                else
                    return 1;    // restrict for query and disallow
            }
        }
    }

    // The cache may be invalid. Check first! We have to use
    // a global named semaphore in case this function is called
    // from a process other than the shell process. (And we're
    // sharing the same count between shell32 and shdocvw.)
    static HANDLE hRestrictions = NULL;
    static long lRestrictionCount = -1;
    if (hRestrictions == NULL)
        hRestrictions = SHGlobalCounterCreate(GUID_Restrictions);
    long lGlobalCount = SHGlobalCounterGetValue(hRestrictions);
    if (lGlobalCount != lRestrictionCount)
    {
        memset((LPBYTE)g_rgRestrictionItemValues, (BYTE)-1, SIZEOF(g_rgRestrictionItemValues));

        lRestrictionCount = lGlobalCount;
    }

    LPCWSTR pszBaseKey;
    if (InRange(rest, REST_EXPLORER_FIRST, REST_EXPLORER_LAST))
        pszBaseKey = c_szExplorerBase;
    else
    {
        if (InRange(rest, REST_BROWSER_FIRST, REST_BROWSER_LAST))
            pszBaseKey = c_szBrowserBase;
        else 
            pszBaseKey = c_szInfodeliveryBase;
    }

    return SHRestrictionLookup(rest, pszBaseKey, c_rgRestrictionItems, g_rgRestrictionItemValues);
}

DWORD SHRestricted2A(BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved)
{
    if (pszUrl)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of MAX_URL_STRING or shorter.
        AnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

        return SHRestricted2W(rest, wzUrl, dwReserved);
    }
    else
    {
        return SHRestricted2W(rest, NULL, dwReserved);
    }
}

/**********************************************************************
*
\**********************************************************************/

#define MAX_SUBSTR_SIZE     100
typedef struct tagURLSub
{
    LPCTSTR szTag;
    DWORD dwType;
} URLSUB;

const static URLSUB c_UrlSub[] = {
    {TEXT("{SUB_PRD}"),     URLSUB_PRD},
    {TEXT("{SUB_PVER}"),    URLSUB_PVER},
    {TEXT("{SUB_OS}"),      URLSUB_OS},
    {TEXT("{SUB_OVER}"),    URLSUB_OVER},
    {TEXT("{SUB_OLCID}"),   URLSUB_OLCID},
    {TEXT("{SUB_CLCID}"),   URLSUB_CLCID},
    {TEXT("{SUB_CLSID}"),   URLSUB_CLCID},  // legacy support (do NOT use "SUB_CLSID" in new URLs)
    {TEXT("{SUB_RFC1766}"), URLSUB_RFC1766}
};

void GetWebLocaleAsRFC1766(LPTSTR pszLocale, int cchLocale)
{
    LCID lcid;
    TCHAR szValue[MAX_PATH];

    DWORD cbVal = sizeof(szValue);
    DWORD dwType;

    ASSERT(NULL != pszLocale);

    *pszLocale = TEXT('\0');
    
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL,
                    REGSTR_VAL_ACCEPT_LANGUAGE, 
                    &dwType, szValue, &cbVal) == ERROR_SUCCESS) &&
        (REG_SZ == dwType))
    {
        TCHAR *psz = szValue;

        //  Use the first one we find so terminate at the comma or semicolon
        while (*psz && (*psz != TEXT(',')) && (*psz != TEXT(';')))
        {
            psz = CharNext(psz);
        }
        *psz = TEXT('\0');

        //  If it's user defined, this will fail and we will fall back
        //  to the system default.
        if (SUCCEEDED(Rfc1766ToLcid(&lcid, szValue)))
        {
            StrCpyN(pszLocale, szValue, cchLocale);
        }
    }

    if (TEXT('\0') == *pszLocale)
    {
        //  No entry in the registry or it's a user defined header.
        //  Either way we fall back to the system default.

        LcidToRfc1766(GetUserDefaultLCID(), pszLocale, cchLocale);
    }
}

HRESULT URLSubstitution(LPCWSTR pszUrlIn, LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;
    WCHAR szTempUrl[MAX_URL_STRING];
    ASSERT(cchSize <= ARRAYSIZE(szTempUrl));    // We will truncate anything longer than MAX_URL_STRING

    StrCpyNW(szTempUrl, pszUrlIn, ARRAYSIZE(szTempUrl));

    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_UrlSub); dwIndex++)
    {
        // dsheldon - This will loop indefinitely as long as we keep finding instances of the substitution
        //  string. We break the loop when pszTag == NULL.
        while (IsFlagSet(dwSubstitutions, c_UrlSub[dwIndex].dwType))
        {
            LPWSTR pszTag = StrStr(szTempUrl, c_UrlSub[dwIndex].szTag);

            if (pszTag)
            {
                TCHAR szCopyUrl[MAX_URL_STRING];
                TCHAR szSubStr[MAX_SUBSTR_SIZE];  // The Substitution

                // Copy URL Before Substitution.
                StrCpyN(szCopyUrl, szTempUrl, (int)(pszTag-szTempUrl+1));
                pszTag += lstrlen(c_UrlSub[dwIndex].szTag);

                switch (c_UrlSub[dwIndex].dwType)
                {
                case URLSUB_PRD:
                    MLLoadString(IDS_SUBSTR_PRD, szSubStr, ARRAYSIZE(szSubStr));
                    break;

                case URLSUB_PVER:
                    MLLoadString(IDS_SUBSTR_PVER, szSubStr, ARRAYSIZE(szSubStr));
                    break;

                case URLSUB_OS:
                    {
                        LPCTSTR pszWin95    = _T("95"); // Windows 95
                        LPCTSTR pszWin98    = _T("98"); // Windows 98 (Memphis)
                        LPCTSTR pszWinME    = _T("ME"); // Windows Millenium
                        LPCTSTR pszWinNT4   = _T("N4"); // Windows NT 4
                        LPCTSTR pszWinNT5   = _T("N5"); // Windows 2000
                        LPCTSTR pszWinNT6   = _T("N6"); // Windows XP (Whistler)
                        LPCTSTR pszUnknown  = _T("");   // error
                        LPCTSTR psz         = pszUnknown;

                        if (IsOS(OS_WINDOWS))
                        {
                            if (IsOS(OS_MILLENNIUMORGREATER))
                                psz = pszWinME;
                            else if (IsOS(OS_WIN98ORGREATER))
                                psz = pszWin98;
                            else if (IsOS(OS_WIN95ORGREATER))
                                psz = pszWin95;
                            else
                            {
                                ASSERT(FALSE); // What OS is this?
                            }
                        }
                        else if (IsOS(OS_NT))
                        {
                            if (IsOS(OS_WHISTLERORGREATER))
                                psz = pszWinNT6;
                            else if (IsOS(OS_WIN2000ORGREATER))
                                psz = pszWinNT5;
                            else if (IsOS(OS_NT4ORGREATER))
                                psz = pszWinNT4;
                            else
                            {
                                ASSERT(FALSE); // What OS is this?
                            }
                        }
                        else
                        {
                            ASSERT(FALSE); // What OS is this?
                        }

                        StrCpyN(szSubStr, psz, ARRAYSIZE(szSubStr));
                    }
                    break;

                case URLSUB_OVER:
                    {
                        LPCTSTR pszVersion_5_1  = _T("5.1");    // Version 5.1 (Whistler)
                        LPCTSTR pszUnknown      = _T("");       // error
                        LPCTSTR psz             = pszUnknown;

                        if (IsOS(OS_WINDOWS))
                        {
                            ASSERT(FALSE); // Not supported under Windows Millenium or lesser.
                        }
                        else if (IsOS(OS_NT))
                        {
                            if (IsOS(OS_WHISTLERORGREATER))
                                psz = pszVersion_5_1;
                            else
                            {
                                ASSERT(FALSE);  // Not supported under Windows 2000 or lesser.
                            }
                        }
                        else
                        {
                            ASSERT(FALSE);  // What OS is this?
                        }

                        StrCpyN(szSubStr, psz, ARRAYSIZE(szSubStr));
                    }
                    break;

                case URLSUB_OLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetSystemDefaultLCID());
                    break;

                case URLSUB_CLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetUserDefaultLCID());
                    break;

                case URLSUB_RFC1766:
                    GetWebLocaleAsRFC1766(szSubStr, ARRAYSIZE(szSubStr));
                    break;

                default:
                    szSubStr[0] = TEXT('\0');
                    ASSERT(FALSE);  // Not Impl.
                    hr = E_NOTIMPL;
                    break;
                }
                // Add the Substitution String to the end (will become the middle)
                StrCatBuff(szCopyUrl, szSubStr, ARRAYSIZE(szCopyUrl));
                // Add the rest of the URL after the substitution substring.
                StrCatBuff(szCopyUrl, pszTag, ARRAYSIZE(szCopyUrl));
                StrCpyN(szTempUrl, szCopyUrl, ARRAYSIZE(szTempUrl));
            }
            else
                break;  // This will allow us to replace all the occurances of this string.
        }
    }
    StrCpyN(pszUrlOut, szTempUrl, cchSize);

    return hr;
}


// inetcpl.cpl uses this.
STDAPI URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU,
                           LPSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr;
    TCHAR szKey[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    TCHAR szUrlOut[MAX_URL_STRING];

    AnsiToTChar(pszKey, szKey, ARRAYSIZE(szKey));
    AnsiToTChar(pszValue, szValue, ARRAYSIZE(szValue));
    hr = URLSubRegQueryW(szKey, szValue, fUseHKCU, szUrlOut, ARRAYSIZE(szUrlOut), dwSubstitutions);
    TCharToAnsi(szUrlOut, pszUrlOut, cchSizeOut);

    return hr;
}


HRESULT URLSubRegQueryW(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fUseHKCU,
                           LPWSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr = E_FAIL;
    WCHAR szTempUrl[MAX_URL_STRING];
    DWORD ccbSize = sizeof(szTempUrl);
    if (ERROR_SUCCESS == SHRegGetUSValueW(pszKey, pszValue, NULL, szTempUrl,
                                &ccbSize, !fUseHKCU, NULL, NULL))
    {
        hr = URLSubstitution(szTempUrl, pszUrlOut, cchSizeOut, dwSubstitutions);
    }

    return hr;
}

// note that anyone inside shdocvw should pass hInst==NULL to
// ensure that pluggable UI works correctly. anyone outside of shdocvw
// must pass an hInst for their appropriate resource dll
HRESULT URLSubLoadString(HINSTANCE hInst, UINT idRes, LPWSTR pszUrlOut,
                         DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr = E_FAIL;
    WCHAR   szTempUrl[MAX_URL_STRING];
    int     nStrLen;

    nStrLen = 0;

    if (hInst == NULL)
    {
        // this is for internal users who want pluggable UI to work
        nStrLen = MLLoadStringW(idRes, szTempUrl, ARRAYSIZE(szTempUrl));
    }
    else
    {
        // this is for external users who use us to load some
        // of their own resources but whom we can't change (like shell32)
        nStrLen = LoadStringWrap(hInst, idRes, szTempUrl, ARRAYSIZE(szTempUrl));
    }

    if (nStrLen > 0)
    {
        hr = URLSubstitution(szTempUrl, pszUrlOut, cchSizeOut, dwSubstitutions);
    }

    return hr;
}


/**********************************************************************\
        ILIsUrlChild() will find pidls that exist under "Desktop\The Internet"
    section of the Shell Name Space.  This function includes those items
    and file system items that have a "txt/html.
\**********************************************************************/
BOOL ILIsWeb(LPCITEMIDLIST pidl)
{
    BOOL fIsWeb = FALSE;

    if (pidl)
    {
        if (IsURLChild(pidl, TRUE))
            fIsWeb = TRUE;
        else
        {
            TCHAR szPath[MAX_PATH];

            fIsWeb = (!ILIsRooted(pidl)
            && SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) 
            && (PathIsHTMLFile(szPath) ||
                 PathIsContentType(szPath, TEXT("text/xml"))));
        }
    }

    return fIsWeb;
}

//
// in:
//      pidlTo

STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPCTSTR pszTitle, LPTSTR pszOut, int cchOut)
{
    HRESULT hr = E_FAIL;
    TCHAR szPathDest[MAX_URL_STRING];
    BOOL fCopyLnk;

    if (SHGetNewLinkInfo((LPCTSTR)pidlTo, pszDir, szPathDest, &fCopyLnk, SHGNLI_PIDL))
    {
        IShellLinkA *pslA;  // Use A version for W95.
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &pslA))))
        {
            TCHAR szPathSrc[MAX_URL_STRING];
            DWORD dwAttributes = SFGAO_FILESYSTEM | SFGAO_FOLDER;
            SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPathSrc, ARRAYSIZE(szPathSrc), &dwAttributes);

            if (fCopyLnk) 
            {
                if (((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) && CopyFile(szPathSrc, szPathDest, TRUE))
                {
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                    SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
                    hr = S_OK;
                }
                else
                {
                    // load the source object that will be "copied" below (with the ::Save call)
                    SAFERELEASE(pslA);
                    hr = SHGetUIObjectFromFullPIDL(pidlTo, NULL, IID_PPV_ARG(IShellLinkA, &pslA));
                    // this pslA is released at the end of the topmost if
                    if (SUCCEEDED(hr))
                    {
                        IPersistFile *ppf;
                        hr = pslA->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                        if (SUCCEEDED(hr))
                        {
                            hr = ppf->Save(szPathDest, TRUE);
                            ppf->Release();
                        }
                    }
                }
            } 
            else 
            {
                pslA->SetIDList(pidlTo);

                // make sure the working directory is set to the same
                // directory as the app (or document).
                //
                // dont do this for non-FS pidls (ie control panel)

                if (SFGAO_FILESYSTEM == (dwAttributes & SFGAO_FILESYSTEM | SFGAO_FOLDER)) 
                {
                    ASSERT(!PathIsRelative(szPathSrc));
                    PathRemoveFileSpec(szPathSrc);
                    // Try to get the W version.
                    IShellLinkW* pslW;
                    if (SUCCEEDED(pslA->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW))))
                    {
                        pslW->SetWorkingDirectory(szPathSrc);
                        pslW->Release();
                    }
                    else
                    {
                        CHAR szPathSrcA[MAX_URL_STRING];
                        SHUnicodeToAnsi(szPathSrc, szPathSrcA, ARRAYSIZE(szPathSrcA));
                        pslA->SetWorkingDirectory(szPathSrcA);
                    }
                }

                IPersistFile *ppf;
                hr = pslA->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                if (SUCCEEDED(hr)) 
                {
                    if (pszTitle && pszTitle[0]) 
                    {
                        PathRemoveFileSpec(szPathDest);
                        PathAppend(szPathDest, pszTitle);
                        StrCatBuff(szPathDest, TEXT(".lnk"), ARRAYSIZE(szPathDest));
                    }
                    hr = ppf->Save(szPathDest, TRUE);
                    if (pszOut)
                    {
                        StrCpyN(pszOut, szPathDest, cchOut);
                    }
                    ppf->Release();
                }
            }

            SAFERELEASE(pslA);
        }
    }

    return hr;
}

VOID CleanExploits(PWSTR psz)
{
    while (*psz)
    {
        if (*psz<L' ')
        {
            *psz = L' ';
        }
        psz++;
    }
}

HRESULT FormatUrlForDisplay(LPWSTR pwzURL, LPWSTR pwzFriendly, UINT cchBuf, LPWSTR pwzFrom, UINT cbFrom, BOOL fSeperate, DWORD dwCodePage, PWSTR pwzCachedFileName)
{
    const   DWORD       dwMaxPathLen        = 32;
    const   DWORD       dwMaxHostLen        = 32;
    const   DWORD       dwMaxTemplateLen    = 64;
    const   DWORD       dwElipsisLen        = 3;
    const   CHAR        rgchElipsis[]       = "...";
    const   WCHAR       rgwchElipsis[]       = L"...";

    HRESULT hrRC = E_FAIL;
    HRESULT hr;

    if (pwzURL==NULL || pwzFriendly==NULL)
        return E_POINTER;

    *pwzFriendly = '\0';

    if (!*pwzURL)
        return S_OK;

    if (!cchBuf)
        return E_FAIL;

    // Wininet can't deal with code pages other than CP_ACP so convert the URL ourself and call InterCrackUrlA
    URL_COMPONENTSA urlComp;
    CHAR   rgchScheme[INTERNET_MAX_SCHEME_LENGTH];
    CHAR   rgchHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR   rgchUrlPath[MAX_PATH];
    CHAR   rgchCanonicalUrl[MAX_URL_STRING];
    LPSTR  pszURL;
    DWORD  dwLen;

    dwLen = MAX_URL_STRING * 2;
    if ((pszURL = (LPSTR)LocalAlloc(LPTR, dwLen * sizeof(CHAR))) != NULL)
    {
        SHUnicodeToAnsiCP(dwCodePage, pwzURL, pszURL, dwLen);

        dwLen = ARRAYSIZE(rgchCanonicalUrl);
        hr = UrlCanonicalizeA(pszURL, rgchCanonicalUrl, &dwLen, 0);
        if (SUCCEEDED(hr))
        {
            ZeroMemory(&urlComp, sizeof(urlComp));

            urlComp.dwStructSize = sizeof(urlComp);
            urlComp.lpszHostName = rgchHostName;
            urlComp.dwHostNameLength = ARRAYSIZE(rgchHostName);
            urlComp.lpszUrlPath = rgchUrlPath;
            urlComp.dwUrlPathLength = ARRAYSIZE(rgchUrlPath);
            urlComp.lpszScheme = rgchScheme;
            urlComp.dwSchemeLength = ARRAYSIZE(rgchScheme);

            hr = InternetCrackUrlA(rgchCanonicalUrl, lstrlenA(rgchCanonicalUrl), 0, &urlComp);
            if (SUCCEEDED(hr))
            {
                DWORD dwPathLen = lstrlenA(rgchUrlPath);
                DWORD dwHostLen = lstrlenA(rgchHostName);
                DWORD dwSchemeLen = lstrlenA(rgchScheme);

                CHAR   rgchHostForDisplay[INTERNET_MAX_HOST_NAME_LENGTH];
                CHAR   rgchPathForDisplay[MAX_PATH];

                ZeroMemory(rgchHostForDisplay, sizeof(rgchHostForDisplay));
                ZeroMemory(rgchPathForDisplay, sizeof(rgchPathForDisplay));

                if (dwHostLen>dwMaxHostLen)
                {
                    DWORD   dwOverFlow = dwHostLen - dwMaxHostLen + dwElipsisLen + 1;
                    wnsprintfA(rgchHostForDisplay, ARRAYSIZE(rgchHostForDisplay), "%s%s", rgchElipsis, rgchHostName+dwOverFlow);
                    dwHostLen = dwMaxHostLen;
                }
                else
                    StrCpyNA(rgchHostForDisplay, rgchHostName, ARRAYSIZE(rgchHostForDisplay));

                if (dwPathLen>dwMaxPathLen)
                {
                    DWORD   dwOverFlow = dwPathLen - dwMaxPathLen + dwElipsisLen;
                    wnsprintfA(rgchPathForDisplay, ARRAYSIZE(rgchPathForDisplay), "/%s%s", rgchElipsis, rgchUrlPath+dwOverFlow);
                    dwPathLen = dwMaxPathLen;
                }
                else
                    StrCpyNA(rgchPathForDisplay, rgchUrlPath, ARRAYSIZE(rgchPathForDisplay));

                WCHAR   rgwchScheme[INTERNET_MAX_SCHEME_LENGTH];
                WCHAR   rgwchHostForDisplay[INTERNET_MAX_HOST_NAME_LENGTH];
                WCHAR   rgwchPathForDisplay[MAX_PATH];
                WCHAR   rgwchUrlPath[MAX_PATH];

                SHAnsiToUnicodeCP(dwCodePage, rgchScheme, rgwchScheme, ARRAYSIZE(rgwchScheme));
                SHAnsiToUnicodeCP(dwCodePage, rgchHostForDisplay, rgwchHostForDisplay, ARRAYSIZE(rgwchHostForDisplay));
                SHAnsiToUnicodeCP(dwCodePage, rgchPathForDisplay, rgwchPathForDisplay, ARRAYSIZE(rgwchPathForDisplay));
                SHAnsiToUnicodeCP(dwCodePage, rgchUrlPath, rgwchUrlPath, ARRAYSIZE(rgwchUrlPath));

                if (pwzCachedFileName && *pwzCachedFileName)
                {
                    WCHAR szUrlPath[MAX_PATH];
                    DWORD cc = ARRAYSIZE(rgchUrlPath);
                    if (FAILED(_PrepareURLForDisplayUTF8W(pwzCachedFileName, szUrlPath, &cc, TRUE, dwCodePage)))
                    {
                        StrCpyNW(szUrlPath, pwzCachedFileName, ARRAYSIZE(szUrlPath));
                    }
                    CleanExploits(szUrlPath);

                    dwPathLen = lstrlenW(szUrlPath);
                    if (dwPathLen>dwMaxPathLen)
                    {
                        DWORD   dwOverFlow = dwPathLen - dwMaxPathLen + dwElipsisLen;
                        wnsprintfW(rgwchPathForDisplay, ARRAYSIZE(rgwchPathForDisplay), L"/%s%s", rgwchElipsis, szUrlPath+dwOverFlow);
                        dwPathLen = dwMaxPathLen;
                    }
                    else
                        StrCpyNW(rgwchPathForDisplay, szUrlPath, ARRAYSIZE(rgwchPathForDisplay));
                }
                
                if (fSeperate)
                {
                    // Format string as "X from Y"
                    WCHAR   rgwchTemplate[dwMaxTemplateLen];
                    WCHAR  *pwzFileName = PathFindFileNameW(rgwchPathForDisplay);
                    DWORD   dwCount;

                    //
                    // remove cache decoration goop to map ie5setup[1].exe to ie5setup.exe
                    //
                    PathUndecorateW(pwzFileName);

                    ZeroMemory(rgwchTemplate, sizeof(rgwchTemplate));
                    dwCount = MLLoadString(IDS_TARGETFILE, rgwchTemplate, ARRAYSIZE(rgwchTemplate));
                    if (dwCount > 0)
                    {
                        if (urlComp.nScheme == INTERNET_SCHEME_FILE)
                        {
                            StrCpyNW(rgwchHostForDisplay, rgwchUrlPath, ARRAYSIZE(rgwchHostForDisplay));
                            PathRemoveFileSpecW(rgwchHostForDisplay);
                        }

                        if (dwPathLen+lstrlenW(rgwchTemplate)+dwHostLen <= cchBuf)
                        {
                            //avoid formatting the string as "X from " in the event internetcrackurl fails us
                            if (rgwchHostForDisplay[0] != TEXT('\0'))
                            {
                                // if necessary return host separately
                                if (pwzFrom && cbFrom)
                                {
                                    StrCpyNW(pwzFriendly, pwzFileName, cchBuf);
                                    StrCpyNW(pwzFrom, rgwchHostForDisplay, cbFrom);
                                }
                                else
                                    _FormatMessage(rgwchTemplate, pwzFriendly, cchBuf, pwzFileName, rgwchHostForDisplay);
                            }
                            else  //hostname is blank, just use filename
                                StrCpyNW(pwzFriendly, pwzFileName, cchBuf);
                            hrRC = S_OK;
                        }
                    }
                }
                else    // !fSeperate
                {
                    if (3+dwPathLen+dwHostLen+dwSchemeLen < cchBuf)
                    {
                        wnsprintf(pwzFriendly, cchBuf, TEXT("%ws://%ws%ws"), rgwchScheme, rgwchHostForDisplay, rgwchPathForDisplay);
                        hrRC = S_OK;
                    }
                }
            }

        }

        LocalFree(pszURL);
        pszURL = NULL;
    }
    
    return(hrRC);
}

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}


// Navigate to a given Url (wszUrl) using IE. Returns an error if IE does not exist.
// fNewWindow = TRUE ==> A new window is compulsory
// fNewWindow = FALSE ==> Do not launch a new window if one already is open.
HRESULT NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow)
{
    HRESULT hr = S_OK;

    if (!EVAL(wszUrl))
        return E_INVALIDARG;

    if (IsIEDefaultBrowser() && !fNewWindow)
    {
        // ShellExecute navigates to the Url using the same browser window,
        // if one is already open.

        SHELLEXECUTEINFOW sei = {0};

        sei.cbSize = sizeof(sei);
        sei.lpFile = wszUrl;
        sei.nShow  = SW_SHOWNORMAL;

        ShellExecuteExW(&sei);

    }
    else
    {
        IWebBrowser2 *pwb2;
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
        if (SUCCEEDED(hr))
        {
            BSTR bstrUrl = SysAllocString(wszUrl);
            if (bstrUrl)
            {
                VARIANT varURL;
                varURL.vt = VT_BSTR;
                varURL.bstrVal = bstrUrl;

                VARIANT varFlags;
                varFlags.vt = VT_I4;
                varFlags.lVal = 0;

                hr = pwb2->Navigate2(&varURL, &varFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                ASSERT(SUCCEEDED(hr)); // mikesh sez there's no way for Navigate2 to fail
                hr = pwb2->put_Visible( TRUE );

                SysFreeString(bstrUrl);
            }
            else
                hr = E_OUTOFMEMORY;

            pwb2->Release();
        }
    }
    return hr;
}

HRESULT NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow)
{
    WCHAR   wszUrl[INTERNET_MAX_URL_LENGTH];

    AnsiToUnicode(szUrl, wszUrl, ARRAYSIZE(wszUrl));

    return NavToUrlUsingIEW(wszUrl, fNewWindow);
}

UINT    g_cfURL = 0;
UINT    g_cfURLW = 0;
UINT    g_cfFileDescA = 0;
UINT    g_cfFileContents = 0;
UINT    g_cfPreferredEffect = 0;
UINT    g_cfPerformedEffect = 0;
UINT    g_cfTargetCLSID = 0;

UINT    g_cfHIDA = 0;
UINT    g_cfFileDescW = 0;

void InitClipboardFormats()
{
    if (g_cfURL == 0)
    {
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        g_cfURLW = RegisterClipboardFormat(CFSTR_INETURLW);
        g_cfFileDescA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfPreferredEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_cfPerformedEffect = RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        g_cfTargetCLSID = RegisterClipboardFormat(CFSTR_TARGETCLSID);
        g_cfHIDA = RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfFileDescW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
    }
}


// FEATURE [raymondc] use SHGlobalCounter

// We need to use a cross process browser count.
// We use a named semaphore.
//
EXTERN_C HANDLE g_hSemBrowserCount = NULL;

#define SESSION_COUNT_SEMAPHORE_NAME _T("_ie_sessioncount")

HANDLE GetSessionCountSemaphoreHandle()
{
    if (!g_hSemBrowserCount)
    {
        g_hSemBrowserCount = SHGlobalCounterCreateNamed( SESSION_COUNT_SEMAPHORE_NAME, 0 );
    }

    ASSERT( g_hSemBrowserCount );

    return g_hSemBrowserCount;
}

LONG GetSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();

    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount);
        WaitForSingleObject(hSem, 0);
    }
    return lPrevCount;


}

LONG IncrementSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();

    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount);
    }
    return lPrevCount;
}

LONG DecrementSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();
    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount); // increment first to make sure deadlock
                                                 // never occurs
        ASSERT(lPrevCount > 0);
        if (lPrevCount > 0)
        {
            WaitForSingleObject(hSem, 0);
            WaitForSingleObject(hSem, 0);
            lPrevCount--;
        }
        else
        {
            // Oops - Looks like a bug !
            // Just return it back to normal and leave
            WaitForSingleObject(hSem, 0);
        }
    }
    return lPrevCount;
}




//
// The following is the message that autodial monitors expect to receive
// when it's a good time to hang up
//
#define WM_IEXPLORER_EXITING    (WM_USER + 103)

long SetQueryNetSessionCount(enum SessionOp Op)
{
    long lCount = 0;
    
    switch(Op) {
        case SESSION_QUERY:
            lCount = GetSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (query)", lCount);
            break;

        case SESSION_INCREMENT_NODEFAULTBROWSERCHECK:
        case SESSION_INCREMENT:
            lCount = IncrementSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (incr)", lCount);

            
            if ((PLATFORM_INTEGRATED == WhichPlatform()))
            {
                // Weird name here... But in integrated mode we make every new browser window
                // look like a new session wrt how we use the cache. Basically this is the way things appear to the
                // user. This effects the way we look for new pages vs doing an if modified
                // since.  The ie3/ie4 switch says "look for new pages on each session start"
                // but wininet folks implemented this as a end session name. Woops.
                // Note that things like authentication etc aren't reset by this, but rather
                // only when all browsers are closed via the INTERNET_OPTION_END_BROWSER_SESSION option.
                InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);
            }

            if (!lCount && (Op == SESSION_INCREMENT))
            {
                // this forces a reload of the title
                DetectAndFixAssociations();
            }
            break;

        case SESSION_DECREMENT:
            lCount = DecrementSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (decr)", lCount);

            if (!lCount) {
                // if we've closed all the net browsers, we need to flush the cache
                InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);
                InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);

                // flush the Java VM cache too (if the Java VM is loaded in this process
                // and we're in integrated mode)
                if (WhichPlatform() == PLATFORM_INTEGRATED)
                {
                    HMODULE hmod = GetModuleHandle(TEXT("msjava.dll"));
                    if (hmod)
                    {
                        typedef HRESULT (*PFNNOTIFYBROWSERSHUTDOWN)(void *);
                        FARPROC fp = GetProcAddress(hmod, "NotifyBrowserShutdown");
                        if (fp)
                        {
                            HRESULT hr = ((PFNNOTIFYBROWSERSHUTDOWN)fp)(NULL);
                            ASSERT(SUCCEEDED(hr));
                        }
                    }
                }

                // Inform dial monitor that it's a good time to hang up
                HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
                if (hwndMonitorWnd) {
                    PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
                }
                hwndMonitorWnd = FindWindow(TEXT("MS_WebcheckMonitor"),NULL);
                if (hwndMonitorWnd) {
                    PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
                }

                // reset offline mode on all platforms except Win2K.
                OSVERSIONINFOA vi;
                vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
                GetVersionExA(&vi);
                if ( vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||
                    vi.dwMajorVersion < 5)
                {
                    // wininet is loaded - tell it to go online
                    INTERNET_CONNECTED_INFO ci = {0};
                    ci.dwConnectedState = INTERNET_STATE_CONNECTED;
                    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
                }
            }
            break;
    }

    return lCount;
}


#ifdef DEBUG
//---------------------------------------------------------------------------
// Copy the exception info so we can get debug info for Raised exceptions
// which don't go through the debugger.
void _CopyExceptionInfo(LPEXCEPTION_POINTERS pep)
{
    PEXCEPTION_RECORD per;

    per = pep->ExceptionRecord;
    TraceMsg(DM_ERROR, "Exception %x at %#08x.", per->ExceptionCode, per->ExceptionAddress);

    if (per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
    {
        // If the first param is 1 then this was a write.
        // If the first param is 0 then this was a read.
        if (per->ExceptionInformation[0])
        {
            TraceMsg(DM_ERROR, "Invalid write to %#08x.", per->ExceptionInformation[1]);
        }
        else
        {
            TraceMsg(DM_ERROR, "Invalid read of %#08x.", per->ExceptionInformation[1]);
        }
    }
}
#else
#define _CopyExceptionInfo(x) TRUE
#endif


int WELCallback(void * p, void * pData)
{
    STATURL* pstat = (STATURL*)p;
    if (pstat->pwcsUrl) {
        OleFree(pstat->pwcsUrl);
    }
    return 1;
}

int CALLBACK WELCompare(void * p1, void * p2, LPARAM lParam)
{
    HDSA hdsa = (HDSA)lParam;
    // Sundown: coercion to long because parameter is an index
    STATURL* pstat1 = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(p1));
    STATURL* pstat2 = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(p2));
    if (pstat1 && pstat2) {
        return CompareFileTime(&pstat2->ftLastVisited, &pstat1->ftLastVisited);
    }

    ASSERT(0);
    return 0;
}

#define MACRO_STR(x) #x
#define VERSION_HEADER_STR "Microsoft Internet Explorer 5.0 Error Log -- " \
                           MACRO_STR(VER_MAJOR_PRODUCTVER) "." \
                           MACRO_STR(VER_MINOR_PRODUCTVER) "." \
                           MACRO_STR(VER_PRODUCTBUILD) "." \
                           MACRO_STR(VER_PRODUCTBUILD_QFE) "\r\n"

SHDOCAPI_(void) IEWriteErrorLog(const EXCEPTION_RECORD* pexr)
{
    HANDLE hfile = INVALID_HANDLE_VALUE;
    _try
    {
        TCHAR szWindows[MAX_PATH];
        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathAppend(szWindows, TEXT("IE4 Error Log.txt"));
        HANDLE hfile = CreateFile(szWindows, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hfile != INVALID_HANDLE_VALUE)
        {
            const static CHAR c_szCRLF[] = "\r\n";
            DWORD cbWritten;
            CHAR szBuf[MAX_URL_STRING];

            // Write the title and product version.
            WriteFile(hfile, VERSION_HEADER_STR, lstrlenA(VERSION_HEADER_STR), &cbWritten, NULL);

            // Write the current time.
            SYSTEMTIME st;
            FILETIME ft;
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ft);
            SHFormatDateTimeA(&ft, NULL, szBuf, SIZECHARS(szBuf));
            const static CHAR c_szCurrentTime[] = "CurrentTime: ";
            WriteFile(hfile, c_szCurrentTime, SIZEOF(c_szCurrentTime)-1, &cbWritten, NULL);
            WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
            WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);

            if (pexr) {
                const static CHAR c_szExcCode[] = "Exception Info: Code=%x Flags=%x Address=%x\r\n";
                const static CHAR c_szExcParam[] = "Exception Param:";
                wnsprintfA(szBuf, ARRAYSIZE(szBuf), c_szExcCode, pexr->ExceptionCode, pexr->ExceptionFlags, pexr->ExceptionAddress);
                WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);

                if (pexr->NumberParameters) {
                    WriteFile(hfile, c_szExcParam, SIZEOF(c_szExcParam)-1, &cbWritten, NULL);
                    for (UINT iParam=0; iParam<pexr->NumberParameters; iParam++) {
                        wnsprintfA(szBuf, ARRAYSIZE(szBuf), " %x", pexr->ExceptionInformation[iParam]);
                        WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
                    }
                }

                WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
                WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
            }

            IUrlHistoryStg* pUrlHistStg;
            HRESULT hres = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUrlHistoryStg, &pUrlHistStg));
            if (SUCCEEDED(hres)) 
            {
                IEnumSTATURL* penum;
                hres = pUrlHistStg->EnumUrls(&penum);
                if (SUCCEEDED(hres)) 
                {
                    // Allocate DSA for an array of STATURL
                    HDSA hdsa = DSA_Create(SIZEOF(STATURL), 32);
                    if (hdsa) 
                    {
                        // Allocate DPA for sorting
                        HDPA hdpa = DPA_Create(32);
                        if (hdpa) 
                        {
                            STATURL stat;
                            stat.cbSize = SIZEOF(stat.cbSize);
                            while(penum->Next(1, &stat, NULL)==S_OK && stat.pwcsUrl) 
                            {
                                DSA_AppendItem(hdsa, &stat);
                                DPA_AppendPtr(hdpa, IntToPtr(DSA_GetItemCount(hdsa)-1));
                            }

                            DPA_Sort(hdpa, WELCompare, (LPARAM)hdsa);
                            for (int i=0; i<10 && i<DPA_GetPtrCount(hdpa) ; i++) 
                            {
                                // Sundown: typecast to long is OK
                                STATURL* pstat = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(DPA_GetPtr(hdpa, i)));
                                if (pstat && pstat->pwcsUrl) 
                                {
                                    SHFormatDateTimeA(&pstat->ftLastVisited, NULL, szBuf, SIZECHARS(szBuf));
                                    WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
                                    const static TCHAR c_szColumn[] = TEXT(" -- ");
                                    WriteFile(hfile, c_szColumn, SIZEOF(c_szColumn)-1, &cbWritten, NULL);

                                    WideCharToMultiByte(CP_ACP, 0, pstat->pwcsUrl, -1,
                                                        szBuf, ARRAYSIZE(szBuf), NULL, NULL);
                                    WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);

                                    WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
                                } 
                                else 
                                {
                                    ASSERT(0);
                                }
                            }

                            DPA_Destroy(hdpa);
                            hdpa = NULL;
                        }

                        DSA_DestroyCallback(hdsa, WELCallback, NULL);
                        hdsa = NULL;
                    }
                    penum->Release();
                }
                else
                {
                    ASSERT(0);
                }
                pUrlHistStg->Release();
            }
            else 
            {
                ASSERT(0);
            }

            CloseHandle( hfile );
            hfile = INVALID_HANDLE_VALUE;
        }
    }
    _except((SetErrorMode(SEM_NOGPFAULTERRORBOX),
            _CopyExceptionInfo(GetExceptionInformation()),
            UnhandledExceptionFilter(GetExceptionInformation())
            ))
    {
        // We hit an exception while handling an exception.
        // Do nothing; we have already displayed the error dialog box.
        if (hfile != INVALID_HANDLE_VALUE) {
            CloseHandle(hfile);
        }
    }
    __endexcept
}

IStream* SHGetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams)
{
    IStream *pstm = NULL;
    static DWORD s_dwMRUSize = 0;
    DWORD dwSize = sizeof(s_dwMRUSize);

    if ((0 == s_dwMRUSize) &&
        (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszStreamMRU, TEXT("MRU Size"), NULL, (void *) &s_dwMRUSize, &dwSize)))
    {
        s_dwMRUSize = 200;          // The default.
    }

    ASSERT(pidl);

    // should be checked by caller - if this is not true we'll flush the
    // MRU cache with internet pidls!  FTP and other URL Shell Extension PIDLs
    // that act like a folder and need similar persistence and fine.  This
    // is especially true because recently the cache size was increased from
    // 30 or so to 200.
    ASSERT(ILIsEqual(pidl, c_pidlURLRoot) || !IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS));

    // Now lets try to save away the other information associated with view.
    IMruDataList *pmru;
    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MruLongList, NULL, IID_PPV_ARG(IMruDataList, &pmru))))
    {
        if (SUCCEEDED(pmru->InitData(s_dwMRUSize, MRULISTF_USE_ILISEQUAL, HKEY_CURRENT_USER, pszStreamMRU, NULL)))
        {
            DWORD cbPidl = ILGetSize(pidl);
            //  need to walk the list
            //  and find this guy
            int iIndex;
            BOOL fFoundPidl = SUCCEEDED(pmru->FindData((const BYTE *)pidl, cbPidl, &iIndex));

            // Did we find the item?
            if (!fFoundPidl && ((grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ))
            {
                // Do not  create the stream if it does not exist and we are
                // only reading
            }
            else
            {
                // Note that we always create the key here, since we have
                // already checked whether we are just reading and the MRU
                // thing does not exist
                HKEY hkCabStreams = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, pszStreams, TRUE);
                if (hkCabStreams )
                {
                    DWORD dwSlot;
                    if (SUCCEEDED(pmru->AddData((const BYTE *)pidl, cbPidl, &dwSlot)))
                    {
                        HKEY hkValues;
                        TCHAR szValue[32], szSubVal[64];
                        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwSlot);

                        if (!fFoundPidl && RegOpenKey(hkCabStreams, szValue, &hkValues) == ERROR_SUCCESS)
                        {
                            // This means that we have created a new MRU
                            // item for this PIDL, so clear out any
                            // information residing at this slot
                            // Note that we do not just delete the key,
                            // since that could fail if it has any sub-keys
                            DWORD dwType, dwSize = ARRAYSIZE(szSubVal);

                            while (RegEnumValue(hkValues, 0, szSubVal, &dwSize, NULL, &dwType, NULL, NULL) == ERROR_SUCCESS)
                            {
                                if (RegDeleteValue(hkValues, szSubVal) != ERROR_SUCCESS)
                                {
                                    break;
                                }
                            }

                            RegCloseKey(hkValues);
                        }
                        pstm = OpenRegStream(hkCabStreams, szValue, pszName, grfMode);
                    }

                    RegCloseKey(hkCabStreams);
                }
            }
        }

        pmru->Release();
    }


    return pstm;
}


#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif


BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return StrCmp(szClass, pszClass) == 0;
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (StrCmp(szClass, c_szCabinetClass) == 0) || (StrCmp(szClass, c_szIExploreClass) == 0);
}

HRESULT _SendOrPostDispatchMessage(HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fPostMessage, BOOL fCheckFirst)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    DWORD idProcess;

    // in case of wParam = DSID_NAVIGATEIEBROWSER, lParam is LocalAlloced structure
    // so we better make sure we are in process 'coz otherwise will fault
    GetWindowThreadProcessId(hwnd, &idProcess);
    if (idProcess == GetCurrentProcessId() && IsWindowEnabled(hwnd) && IsWindowVisible(hwnd))
    {
        if (!fPostMessage || fCheckFirst)
        {
            //  sync or we are querying the windows readiness
            ULONG_PTR result;
            if (SendMessageTimeoutA(hwnd, WMC_DISPATCH, (fCheckFirst ? DSID_NOACTION : wParam),
                lParam, SMTO_ABORTIFHUNG, 400, &result))
                hr = (HRESULT) result;
        }

        //  handle the post only if the window was ready
        if (fPostMessage && (!fCheckFirst || SUCCEEDED(hr)))
            hr = (PostMessage(hwnd, WMC_DISPATCH, wParam, lParam) ? S_OK : E_FAIL);
    }

    return hr;
}

//---------------------------------------------------------------------------

HRESULT FindBrowserWindowOfClass(LPCTSTR pszClass, WPARAM wParam, LPARAM lParam, BOOL fPostMessage, HWND* phwnd)
{
    //If there is no window, assume the user is in the process of shutting down IE, and return E_FAIL

    //Otherwise, if there is at least one window, start cycling through the windows until you find
    //one that's not busy, and give it our message.  If all are busy, return
    //HRESULT_FROM_WIN32(ERROR_BUSY)
    HWND hwnd = NULL;
    HRESULT hr = E_FAIL;

    while (FAILED(hr)
        && (hwnd = FindWindowEx(NULL, hwnd, pszClass, NULL)) != NULL)
    {
        hr = _SendOrPostDispatchMessage(hwnd, wParam, lParam, fPostMessage, fPostMessage);
    }

    *phwnd = hwnd;
    return hr;
}

//This common function gets called when the DDE engine doesn't seem to care in which window something
//happens.  It returns in which window that something happened.  0 means all windows are busy.
//
//phwnd: a pointer the hwnd to which to send the message.  <= 0 means any window will do.
//       this is also an out parameter that specifies in which window it happened.
//fPostMessage: when doing navigations, we have to do a PostMessage instead of a SendMessageTimeout
//       or a CoCreateInstance later on in CDocObjectHost::_BindFileMoniker will fail.  So when
//       this function is called from CDDEAuto_Navigate, we make this flag TRUE
HRESULT CDDEAuto_Common(WPARAM wParam, LPARAM lParam, HWND *phwnd, BOOL fPostMessage)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    HWND hwnd;

    //if we're told to go to a specific window
    if (phwnd && (*phwnd != (HWND)-1))
    {
        hr = _SendOrPostDispatchMessage(*phwnd, wParam, lParam, fPostMessage, FALSE);
    }

    if (HRESULT_FROM_WIN32(ERROR_BUSY) == hr)
    {
        hr = FindBrowserWindowOfClass(c_szIExploreClass, wParam, lParam, fPostMessage, &hwnd);
        if (!hwnd)
            hr = FindBrowserWindowOfClass(c_szCabinetClass, wParam, lParam, fPostMessage, &hwnd);

        if (phwnd)
            *phwnd = hwnd;
    }
    return hr;
}

//
//  Before changing the behavior of this function look at itemmenu.cpp in
//  cdfview.
//
HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow) // the long used to be for lTransID, but it was always ignored...
{                                                                       // so I am using it to tell us if we want to absolutely create an new window or not...
    DDENAVIGATESTRUCT *pddens = NULL;
    HRESULT hres = E_FAIL;

    if (phwnd == NULL)
        return E_INVALIDARG;

    pddens = new DDENAVIGATESTRUCT;
    if (!pddens)
        hres = E_OUTOFMEMORY;
    else
    {
        pddens->wszUrl = StrDupW(str);
        if (!pddens->wszUrl)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            // Don't do the navigate if *phwnd == 0, in that case we want to either
            // create a new window or activate an existing one that already is viewing
            // this URL.
            
            if ((*phwnd != NULL) && !lLaunchNewWindow)
            {
                BOOL fForceWindowReuse = FALSE;
                BSTR bstrUrl = NULL;
                // If there is even a single window with a location 
                // you are basically assured that you cannot force a 
                // reuse of windows. essentially

               // case 1 : only iexplore -nohome windows implies we want to force reuse
               // case 2 : only windows that have a location - we don't want to force reuse
               //          just follow user's preference
               // case 3: mix of iexplore -nohome windows and windows with location. we don't
               //         know what state we are in - don't force reuse
                hres = CDDEAuto_get_LocationURL(&bstrUrl, *phwnd);

                if (FAILED(hres) ||
                   (!bstrUrl)   ||
                   (SUCCEEDED(hres) && (*bstrUrl == L'\0')))
                {
                    fForceWindowReuse = TRUE;
                }
                if (bstrUrl)
                    SysFreeString(bstrUrl);
                    
                if ( !(GetAsyncKeyState(VK_SHIFT) < 0)
                    && (fForceWindowReuse || SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("AllowWindowReuse"), FALSE, TRUE)))
                {
                    hres = CDDEAuto_Common(DSID_NAVIGATEIEBROWSER, (LPARAM)pddens, phwnd, FALSE);
                }
            }

            if (SUCCEEDED(hres) && (*phwnd != 0) && (*phwnd != (HWND)-1))
            {
                // We found an existing browser window and successfully sent the
                // navigate message to it. Make the window foreground.
                SetForegroundWindow(*phwnd);

                if (IsIconic(*phwnd))
                    ShowWindowAsync(*phwnd, SW_RESTORE);
            }

            //
            // If we are using whatever window and all the browser windows are busy
            // (*phwnd == 0), or if there's no browser window opened (*phwnd == -1)
            // or we are asked to create a new one, then take the official OLE automation
            // route to start a new window.
            //
            if ((*phwnd == 0) ||
                (*phwnd == (HWND)-1))
            {
                //WARNING: this route doesn't give us the ability to return the hwnd of the window
                //in which the navigation took place (while we could - it's too hard and not worth it)
                LPITEMIDLIST pidlNew;
                hres = IECreateFromPathW(str, &pidlNew);
                if (SUCCEEDED(hres))
                {
                    if (!lLaunchNewWindow)
                    {
                        // See if there is already a browser viewing this URL, if so just
                        // make him foreground otherwise create a new browser.
                        hres = WinList_FindFolderWindow(pidlNew, NULL, phwnd, NULL);
                    }
                    else
                    {
                        // we don't look in the winlist if the caller explicitly wants a new window
                        hres = S_FALSE;
                    }

                    if (S_OK == hres)
                    {
                        ILFree(pidlNew);
                        SetForegroundWindow(*phwnd);
                        ShowWindow(*phwnd, SW_SHOWNORMAL);
                    }
                    else
                    {
                        SHOpenNewFrame(pidlNew, NULL, 0, COF_IEXPLORE);
                    }
                }
            }
        }

        // It will be set to NULL if we don't need to free it.
        if (pddens)
        {
            if (pddens->wszUrl)
            {
                LocalFree(pddens->wszUrl);
                pddens->wszUrl = NULL;
            }

            delete pddens;
        }    
    }

    return hres;
}

HRESULT CDDEAuto_get_LocationURL(BSTR * pstr, HWND hwnd)
{
    return CDDEAuto_Common(DSID_GETLOCATIONURL, (LPARAM)pstr, &hwnd, FALSE);
}

HRESULT CDDEAuto_get_LocationTitle(BSTR * pstr, HWND hwnd)
{
    return CDDEAuto_Common(DSID_GETLOCATIONTITLE, (LPARAM)pstr, &hwnd, FALSE);
}

HRESULT CDDEAuto_get_HWND(long * phwnd)
{
    return CDDEAuto_Common(DSID_GETHWND, (LPARAM)phwnd, NULL, FALSE);
}

HRESULT CDDEAuto_Exit()
{
    return CDDEAuto_Common(DSID_EXIT, (LPARAM)NULL, NULL, FALSE);
}

class CDelagateMalloc : public IMalloc
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID,void **);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IMalloc
    virtual STDMETHODIMP_(void *)   Alloc(SIZE_T cb);
    virtual STDMETHODIMP_(void *)   Realloc(void *pv, SIZE_T cb);
    virtual STDMETHODIMP_(void)     Free(void *pv);
    virtual STDMETHODIMP_(SIZE_T)    GetSize(void *pv);
    virtual STDMETHODIMP_(int)      DidAlloc(void *pv);
    virtual STDMETHODIMP_(void)     HeapMinimize();

private:
    CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter);
    ~CDelagateMalloc() {}
    void* operator new(size_t cbClass, SIZE_T cbSize)
    {
        return ::operator new(cbClass + cbSize);
    }


    friend HRESULT CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

protected:
    LONG _cRef;
    WORD _wOuter;           // delegate item outer signature
    WORD _wUnused;          // to allign
#ifdef DEBUG
    UINT _cAllocs;
#endif
    SIZE_T _cb;
    BYTE _data[EMPTY_SIZE];
};

CDelagateMalloc::CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter)
{
    _cRef = 1;
    _wOuter = wOuter;
    _cb = cbSize;

    memcpy(_data, pv, _cb);
}

HRESULT CDelagateMalloc::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDelagateMalloc, IMalloc),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDelagateMalloc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDelagateMalloc::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

void *CDelagateMalloc::Alloc(SIZE_T cb)
{
    WORD cbActualSize = (WORD)(
                        SIZEOF(DELEGATEITEMID) - 1 +    // header (-1 sizeof(rgb[0])
                        cb +                            // inner
                        _cb);                           // outer data

    PDELEGATEITEMID pidl = (PDELEGATEITEMID)SHAlloc(cbActualSize + 2);  // +2 for pidl term
    if (pidl)
    {
        pidl->cbSize = cbActualSize;
        pidl->wOuter = _wOuter;
        pidl->cbInner = (WORD)cb;
        memcpy(&pidl->rgb[cb], _data, _cb);
        *(UNALIGNED WORD *)&(((BYTE *)pidl)[cbActualSize]) = 0;
#ifdef DEBUG
        _cAllocs++;
#endif
    }
    return pidl;
}

void *CDelagateMalloc::Realloc(void *pv, SIZE_T cb)
{
    return NULL;
}

void CDelagateMalloc::Free(void *pv)
{
    SHFree(pv);
}

SIZE_T CDelagateMalloc::GetSize(void *pv)
{
    return (SIZE_T)-1;
}

int CDelagateMalloc::DidAlloc(void *pv)
{
    return -1;
}

void CDelagateMalloc::HeapMinimize()
{
}

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc)
{
    CDelagateMalloc *pdm = new(cbSize) CDelagateMalloc(pv, cbSize, wOuter);
    if (pdm)
    {
        HRESULT hres = pdm->QueryInterface(IID_PPV_ARG(IMalloc, ppmalloc));
        pdm->Release();
        return hres;
    }
    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
// This function scans the head of an html document for the desired element
// with a particular attribute.  If a match is found, the first occurance
// of that element is returned in punkDesired and S_OK is returned.
// Otherwise, E_FAIL is returned.
//
// Example:  Find the first meta element with name="ProgID":
//
//   SearchForElementInHead(pHTMLDoc, OLESTR("Name"), OLESTR("ProgId"),
//           IID_IHTMLMetaElement, (IUnknown**)&pMetaElement);
//
//--------------------------------------------------------------------------
HRESULT SearchForElementInHead
(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface
)
{
    ASSERT(NULL != pHTMLDocument);
    ASSERT(NULL != pszAttribName);
    ASSERT(NULL != pszAttrib);
    ASSERT(NULL != ppunkDesired);

    HRESULT hr = E_FAIL;
    *ppunkDesired = NULL;

    BSTR bstrAttribName = SysAllocString(pszAttribName);
    if (NULL == bstrAttribName)
    {
        return E_OUTOFMEMORY;
    }

    //
    // First get all document elements.  Note that this is very fast in
    // ie5 because the collection directly accesses the internal tree.
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(pHTMLDocument->get_all(&pAllCollection)))
    {
        IUnknown* punk;
        IHTMLBodyElement* pBodyElement;
        IHTMLFrameSetElement* pFrameSetElement;
        IDispatch* pDispItem;

        //
        // Now we scan the document for the desired tags.  Since we're only
        // searching the head, and since Trident always creates a body tag
        // (unless there is a frameset), we can stop looking when we hit the
        // body or frameset.
        //
        // Note, the alternative of using pAllCollection->tags to return the
        // collection of desired tags is likely more expensive because it will
        // walk the whole tree (unless Trident optimizes this).
        //
        long lItemCnt;
        VARIANT vEmpty;
        V_VT(&vEmpty) = VT_EMPTY;

        VARIANT vIndex;
        V_VT(&vIndex) = VT_I4;

        EVAL(SUCCEEDED(pAllCollection->get_length(&lItemCnt)));

        for (long lItem = 0; lItem < lItemCnt; lItem++)
        {
            V_I4(&vIndex) = lItem;

            if (S_OK == pAllCollection->item(vIndex, vEmpty, &pDispItem))
            {
                //
                // First see if it's the desired element type
                //
                if (SUCCEEDED(pDispItem->QueryInterface(iidDesired, (void **)&punk)))
                {
                    //
                    // Next see if it has the desired attribute
                    //
                    IHTMLElement* pElement;

                    if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLElement, &pElement))))
                    {
                        VARIANT varAttrib;
                        V_VT(&varAttrib) = VT_EMPTY;

                        if (SUCCEEDED(pElement->getAttribute(bstrAttribName, FALSE, &varAttrib)) &&
                            (V_VT(&varAttrib) == VT_BSTR) && varAttrib.bstrVal &&
                            (StrCmpIW(varAttrib.bstrVal, pszAttrib) == 0) )
                        {
                            // Found it!
                            *ppunkDesired = punk;
                            punk = NULL;
                            hr = S_OK;

                            // Terminate the search;
                            lItem = lItemCnt;
                        }
                        pElement->Release();

                        VariantClear(&varAttrib);
                    }

                    if (punk)
                        punk->Release();
                }
                //
                // Next check for the body tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLBodyElement,&pBodyElement))))
                {
                    // Found a body tag, so terminate the search
                    lItem = lItemCnt;
                    pBodyElement->Release();
                }
                //
                // Finally, check for a frameset tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLFrameSetElement, &pFrameSetElement))))
                {
                    // Found a frameset tag, so terminate the search
                    lItem = lItemCnt;
                    pFrameSetElement->Release();
                }

                pDispItem->Release();
            }
        }
        // Make sure that these don't have to be cleared (should not have been modified)
        ASSERT(vEmpty.vt == VT_EMPTY);
        ASSERT(vIndex.vt == VT_I4);

        pAllCollection->Release();
    }

    SysFreeString(bstrAttribName);

    return hr;
}


//+-------------------------------------------------------------------
//     JITCoCreateInstance
//
//  This function makes sure that the Option pack which
//  has this class id is installed.
//  It attempts to make sure that the Option pack corresponding
//  to the current IE Build.
//  If the feature does get installed correctly, it will
//  attempt to CoCreate the specified CLSID
//
//+------------------------------------------------------------------
HRESULT JITCoCreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, void ** ppv, HWND hwndParent, DWORD dwJitFlags)
{
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = rclsid;

    ASSERT((dwJitFlags & ~(FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK)) == 0);

    HRESULT hr = FaultInIEFeature(hwndParent, &ucs, &qc, dwJitFlags);
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
    }

    return hr;
}

BOOL IsFeaturePotentiallyAvailable(REFCLSID rclsid)
{
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = rclsid;

    return (FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK) != E_ACCESSDENIED);
}

BOOL CreateFromDesktop(PNEWFOLDERINFO pfi)
{
    //
    //  APPCOMPAT:HACKHACK - we need to handle differences in the way we parse the command line
    //  on IE4 integrated.  we should not be called by anybody but IE4's Explorer.exe
    //
    ASSERT(GetUIVersion() == 4);
    if (!pfi->pidl) 
    {
        if ((pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)) || pfi->pidlRoot)
        {
            pfi->pidl = ILRootedCreateIDList(pfi->uFlags & COF_ROOTCLASS ? &pfi->clsid : NULL, pfi->pidlRoot);
            pfi->uFlags &= ~(COF_ROOTCLASS | COF_NEWROOT);
            ILFree(pfi->pidlRoot);
            pfi->pidlRoot = NULL;
            pfi->clsid = CLSID_NULL;
        }
        else if (!PathIsURLA(pfi->pszPath))
        {
           CHAR szTemp[MAX_PATH];
           GetCurrentDirectoryA(ARRAYSIZE(szTemp), szTemp);
           PathCombineA(szTemp, szTemp, pfi->pszPath);
           Str_SetPtrA(&(pfi->pszPath), szTemp);
        } 
    }

    ASSERT(!(pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)));
    
    return SHCreateFromDesktop(pfi);
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

    return (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;
}

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}

STDAPI_(IBindCtx *) CreateBindCtxForUI(IUnknown * punkSite)
{
    IBindCtx * pbc = NULL;

    if (EVAL(punkSite && SUCCEEDED(CreateBindCtx(0, &pbc))))
    {
        if (FAILED(pbc->RegisterObjectParam(STR_DISPLAY_UI_DURING_BINDING, punkSite)))
        {
            // It failed
            ATOMICRELEASE(pbc);
        }
    }

    return pbc;
}

//
// Return the location of the internet cache
// HRESULT GetCacheLocation(
// dwSize          no. of chars in pszCacheLocation

STDAPI GetCacheLocation(LPTSTR pszCacheLocation, DWORD cchCacheLocation)
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = NULL;  // init to suppress bogus C4701 warning
    DWORD dwCCISize = sizeof(INTERNET_CACHE_CONFIG_INFO);
    BOOL fOnceErrored = FALSE;

    while (TRUE)
    {
        if ((lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) LocalAlloc(LPTR,
                                                        dwCCISize)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        if (!GetUrlCacheConfigInfo(lpCCI, &dwCCISize,
                                            CACHE_CONFIG_CONTENT_PATHS_FC))
        {
            if ((dwLastErr = GetLastError()) != ERROR_INSUFFICIENT_BUFFER  ||
                fOnceErrored)
            {
                hr = HRESULT_FROM_WIN32(dwLastErr);
                goto cleanup;
            }

            //
            // We have insufficient buffer size; reallocate a buffer with the
            //      new dwCCISize set by GetUrlCacheConfigInfo
            // Set fOnceErrored to TRUE so that we don't loop indefinitely
            //
            fOnceErrored = TRUE;
        }
        else
        {
            LPTSTR pszPath = lpCCI->CachePaths[0].CachePath;
            INT iLen;

            PathRemoveBackslash(pszPath);
            iLen = lstrlen(pszPath) + 1;        // + 1 is for the null char

            if ((DWORD) iLen < cchCacheLocation)
            {
                StrCpyN(pszCacheLocation, pszPath, cchCacheLocation);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }

            break;
        }

        LocalFree(lpCCI);
        lpCCI = NULL;
    }

cleanup:
    if (lpCCI != NULL)
    {
        LocalFree(lpCCI);
        lpCCI = NULL;
    }

    return hr;
}

STDAPI_(UINT) GetWheelMsg()
{
    static UINT s_msgMSWheel = 0;
    if (s_msgMSWheel == 0)
        s_msgMSWheel = RegisterWindowMessage(TEXT("MSWHEEL_ROLLMSG"));
    return s_msgMSWheel;
}

STDAPI StringToStrRet(LPCTSTR pString, STRRET *pstrret)
{
    HRESULT hr = SHStrDup(pString, &pstrret->pOleStr);
    if (SUCCEEDED(hr))
    {
        pstrret->uType = STRRET_WSTR;
    }
    return hr;
}

// these two functions are duplicated from browseui
HINSTANCE GetComctl32Hinst()
{
    static HINSTANCE s_hinst = NULL;
    if (!s_hinst)
        s_hinst = GetModuleHandle(TEXT("comctl32.dll"));
    return s_hinst;
}

// since we don't define the proper WINVER we do this ourselves
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }
    return LoadCursor(GetComctl32Hinst(), IDC_HAND_INTERNAL);
}



//+-------------------------------------------------------------------------
// Returns true if this type of url may not be available when offline unless
// it is cached by wininet
//--------------------------------------------------------------------------
BOOL MayBeUnavailableOffline(LPTSTR pszUrl)
{
    BOOL fRet = FALSE;
    URL_COMPONENTS uc = {0};
    uc.dwStructSize = sizeof(uc);

    if (SUCCEEDED(InternetCrackUrl(pszUrl, 0, 0, &uc)))
    {
        fRet = uc.nScheme == INTERNET_SCHEME_HTTP ||
            uc.nScheme == INTERNET_SCHEME_HTTPS ||
            uc.nScheme == INTERNET_SCHEME_FTP ||
            uc.nScheme == INTERNET_SCHEME_GOPHER;
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// If the folder is a link, the associated URL is returned.
//--------------------------------------------------------------------------
HRESULT GetNavTargetName(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHGetNavigateTarget(psf, pidl, &pidlTarget, NULL);
    if (SUCCEEDED(hr))
    {
        // Get the URL
        // NOTE (andrewgu): ie5.5 b#109391 - if SHGDN_FORPARSING is used the result will be
        // consitently the fully qualified path regardless of the protocol
        hr = IEGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, pszUrl, cMaxChars, NULL);
        ILFree(pidlTarget);
    }
    else
        *pszUrl = 0;
    return hr;
}

//+-------------------------------------------------------------------------
// Returns info about whether this item is available offline. Returns E_FAIL
// if the item is not a link.
// if we navigate to this item
//  (true if we're online, items in the cache or otherwise available)
// if item is a sticky cache entry
//--------------------------------------------------------------------------
// FEATURE: this should use an interface to bind to this information abstractly
// psf->GetUIObjectOf(IID_IAvailablility, ...);
HRESULT GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky)
{
    if (pfAvailable)
        *pfAvailable = TRUE;

    if (pfSticky)
        *pfSticky = FALSE;
    //
    // See if it is a link. If it is not, then it can't be in the wininet cache and can't
    // be pinned (sticky cache entry) or greyed (unavailable when offline)
    //
    WCHAR szUrl[MAX_URL_STRING];
    DWORD dwFlags = 0;

    HRESULT hr = GetNavTargetName(psf, pidlItem, szUrl, ARRAYSIZE(szUrl));

    if (SUCCEEDED(hr))
    {
        CHAR szUrlAnsi[MAX_URL_STRING];

        //
        // Get the cache info for this item.  Note that we use GetUrlCacheEntryInfoEx instead
        // of GetUrlCacheEntryInfo because it follows any redirects that occured.  This wacky
        // api uses a variable length buffer, so we have to guess the size and retry if the
        // call fails.
        //
        BOOL fInCache = FALSE;
        WCHAR szBuf[512];
        LPINTERNET_CACHE_ENTRY_INFOA pCE = (LPINTERNET_CACHE_ENTRY_INFOA)szBuf;
        DWORD cbEntry = sizeof (szBuf);

        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));
        if (!(fInCache = GetUrlCacheEntryInfoExA(szUrlAnsi, pCE, &cbEntry, NULL, NULL, NULL, 0)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // We guessed too small for the buffer so allocate the correct size & retry
                pCE = (LPINTERNET_CACHE_ENTRY_INFOA)LocalAlloc(LPTR, cbEntry);
                if (pCE)
                {
                    fInCache = GetUrlCacheEntryInfoExA(szUrlAnsi, pCE, &cbEntry, NULL, NULL, NULL, 0);
                }
            }
        }

        //
        // If we are offline, see if the item is in the cache.
        //
        if (pfAvailable && SHIsGlobalOffline() && MayBeUnavailableOffline(szUrl) && !fInCache)
        {
            // Not available
            *pfAvailable = FALSE;
        }

        //
        // See if it's a sticky cache entry
        //
        if (pCE)
        {
            if (pfSticky && fInCache && (pCE->CacheEntryType & STICKY_CACHE_ENTRY))
            {
                *pfSticky = TRUE;
            }

            if ((TCHAR*)pCE != szBuf)
            {
                LocalFree(pCE);
                pCE = NULL;
            }
        }
    }

    // 
    // Somebody is obviously interested in in the offline availability so listen
    // to wininet for changes to the cache and rebroadcast as a SHChangeNotify
    //
    CWinInetNotify::GlobalEnable();

    return hr;
}

//
// Converts all "&" into "&&" so that they show up
// in menus
//
void FixAmpersands(LPWSTR pszToFix, UINT cchMax)
{
    ASSERT(pszToFix && cchMax > 0);

    WCHAR szBuf[MAX_URL_STRING];
    LPWSTR pszBuf = szBuf;
    LPWSTR pszSrc = pszToFix;
    UINT cch = 0;

    while (*pszSrc && cch < ARRAYSIZE(szBuf)-2)
    {
        if (*pszSrc == '&')
        {
            *pszBuf++ = '&';
            ++cch;
        }
        *pszBuf++ = *pszSrc++;
        ++cch;
    }
    *pszBuf = 0;

    StrCpyN(pszToFix, szBuf, cchMax);
}

BOOL IsInetcplRestricted(LPCWSTR pszCommand)
{
    BOOL fDisabled = FALSE;
    DWORD dwData, dwType;
    DWORD dwSize = sizeof(dwData);

    if (ERROR_SUCCESS == SHRegGetUSValue(TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel"),
        pszCommand, &dwType, (void *)&dwData, &dwSize, FALSE, NULL, 0))
    {
        fDisabled = dwData;
    }
    return fDisabled;
}

BOOL HasExtendedChar(LPCWSTR pszQuery)
{
    BOOL fNonAscii = FALSE;
    for (LPCWSTR psz = pszQuery; *psz; psz++)
    {
        if (*psz > 0x7f)
        {
            fNonAscii = TRUE;
            break;
        }
    }
    return fNonAscii;
}

void ConvertToUtf8Escaped(LPWSTR pszUrl, int cch)
{
    // Convert to utf8
    char szBuf[MAX_URL_STRING];
    SHUnicodeToAnsiCP(CP_UTF8, pszUrl, szBuf, ARRAYSIZE(szBuf));

    // Escape the string into the original buffer
    LPSTR pchIn; 
    LPWSTR pchOut = pszUrl;
    WCHAR ch;
    static const WCHAR hex[] = L"0123456789ABCDEF";

    for (pchIn = szBuf; *pchIn && cch > 3; pchIn++)
    {
        ch = *pchIn;

        if (ch > 0x7f)
        {
            cch -= 3;
            *pchOut++ = L'%';
            *pchOut++ = hex[(ch >> 4) & 15];
            *pchOut++ = hex[ch & 15];
        }
        else
        {
            --cch;
            *pchOut++ = *pchIn;
        }
    }

    *pchOut = L'\0';
}




HRESULT IExtractIcon_GetIconLocation(
    IUnknown *punk,
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    ASSERT(punk);
    HRESULT hr;
    
    if (g_fRunningOnNT)
    {
        IExtractIcon *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIcon, &pxi));

        if (SUCCEEDED(hr))
        {
            hr = pxi->GetIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon, puOutFlags);

            pxi->Release();
        }
    }
    else
    {
        IExtractIconA *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIconA, &pxi));

        if (SUCCEEDED(hr))
        {
            CHAR sz[MAX_PATH];
            hr = pxi->GetIconLocation(uInFlags, sz, SIZECHARS(sz), pniIcon, puOutFlags);

            if (SUCCEEDED(hr))
                SHAnsiToTChar(sz, pszIconFile, cchIconFile);

            pxi->Release();
        }
    }

    return hr;
}
        

HRESULT IExtractIcon_Extract(
    IUnknown *punk,
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    ASSERT(punk);
    HRESULT hr;
    
    if (g_fRunningOnNT)
    {
        IExtractIcon *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIcon, &pxi));

        if (SUCCEEDED(hr))
        {
            hr = pxi->Extract(pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);

            pxi->Release();
        }
    }
    else
    {
        IExtractIconA *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIconA, &pxi));

        if (SUCCEEDED(hr))
        {
            CHAR sz[MAX_PATH];
            SHTCharToAnsi(pszIconFile, sz, SIZECHARS(sz));
            hr = pxi->Extract(sz, iIcon, phiconLarge, phiconSmall, ucIconSize);

            pxi->Release();
        }
    }

    return hr;
}


typedef EXECUTION_STATE (__stdcall *PFNSTES) (EXECUTION_STATE);

EXECUTION_STATE _SetThreadExecutionState(EXECUTION_STATE esFlags)
{
    static PFNSTES _pfnSetThreadExecutionState = (PFNSTES)-1;
    
    if (_pfnSetThreadExecutionState == (PFNSTES)-1)
        _pfnSetThreadExecutionState = (PFNSTES)GetProcAddress(GetModuleHandleA("kernel32.dll"), "SetThreadExecutionState");

    if (_pfnSetThreadExecutionState != (PFNSTES)NULL)
        return(_pfnSetThreadExecutionState(esFlags));
    else
        return((EXECUTION_STATE)NULL);
}


HRESULT SHPathPrepareForWriteWrap(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, UINT wFunc, DWORD dwFlags)
{
    HRESULT hr;

    if (g_bRunOnNT5)
    {
        // NT5's version of the API is better.
        hr = SHPathPrepareForWriteW(hwnd, punkEnableModless, pszPath, dwFlags);
    }
    else
    {
        hr = SHCheckDiskForMedia(hwnd, punkEnableModless, pszPath, wFunc);
    }

    return hr;
}
void GetPathOtherFormA(LPSTR lpszPath, LPSTR lpszNewPath, DWORD dwSize)
{
    BOOL bQuotes = FALSE;
    LPSTR szStart = lpszPath;
    LPSTR szEnd = NULL;
    LPSTR szNewStart = lpszNewPath;

    ZeroMemory(lpszNewPath, dwSize);

    // Cull out the starting and ending " because GetShortPathName does not
    // like it.
    if (*lpszPath == '"')
    {
        bQuotes = TRUE;

        szStart = lpszPath + 1;
        szEnd   = lpszPath + lstrlenA(lpszPath) - 1; // Point to the last "
        *szEnd  = '\0';

        szNewStart = lpszNewPath + 1;  // So that we can insert the " in it.
        dwSize = dwSize - 2;  // for the two double quotes to be added.
    }

    if (GetShortPathNameA(szStart, szNewStart, dwSize) != 0)
    {
        if (StrCmpIA(szStart, szNewStart) == 0)
        {   // The original Path is a SFN. So NewPath needs to be LFN.
            GetLongPathNameA((LPCSTR)szStart, szNewStart, dwSize);
        }
    }
                                             
    // Now add the " to the NewPath so that it is in the expected form
    if (bQuotes)
    {
        int len = 0;

        // Fix the Original path.
        *szEnd = '"';

        // Fix the New path.
        *lpszNewPath = '"';        // Insert " in the beginning.
        len = lstrlenA(lpszNewPath);
        *(lpszNewPath + len) = '"'; // Add the " in the end.
        *(lpszNewPath + len + 1) = '\0'; // Terminate the string.
    }

    return;
}

int GetUrlSchemeFromPidl(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);
    ASSERT(IsURLChild(pidl, FALSE));

    int nRet = URL_SCHEME_INVALID;

    WCHAR szUrl[MAX_URL_STRING];

    if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl,
                                    ARRAYSIZE(szUrl), NULL)))
    {
        nRet = GetUrlScheme(szUrl);
    }

    return nRet;
}

//
// Check if it is safe to create a shortcut for the given url.  Used by add
// to favorites code.
//
BOOL IEIsLinkSafe(HWND hwnd, LPCITEMIDLIST pidl, ILS_ACTION ilsFlag)
{
    ASSERT(pidl);

    BOOL fRet = TRUE;

    if (IsURLChild(pidl, FALSE))
    {
        int nScheme = GetUrlSchemeFromPidl(pidl);

        if (URL_SCHEME_JAVASCRIPT == nScheme || URL_SCHEME_VBSCRIPT == nScheme)
        {
            WCHAR szTitle[MAX_PATH];
            WCHAR szText[MAX_PATH];

            MLLoadString(IDS_SECURITYALERT, szTitle, ARRAYSIZE(szTitle));
            MLLoadString(IDS_ADDTOFAV_WARNING + ilsFlag, szText,
                         ARRAYSIZE(szText));

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            fRet = (IDYES == MLShellMessageBox(hwnd, szText, szTitle, MB_YESNO |
                                               MB_ICONWARNING | MB_APPLMODAL |
                                               MB_DEFBUTTON2));
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
    }

    return fRet;
}

HRESULT GetSearchStyle(IServiceProvider * psp, LPDWORD pdwSearchStyle)
{
    RIP(pdwSearchStyle != NULL);

    HRESULT hr = E_FAIL;

    // first see if there is an ISearchContext to get this information from
    if (psp != NULL)
    {
        ISearchContext * pSC = NULL;
        hr = psp->QueryService(SID_STopWindow, IID_PPV_ARG(ISearchContext, &pSC));
        if (SUCCEEDED(hr))
        {
            RIP(pSC != NULL);

            hr = pSC->GetSearchStyle(pdwSearchStyle);
            pSC->Release();
        }
    }

    // there wasn't a viable search context, so try the reg key
    if (FAILED(hr))
    {
        DWORD dwType;
        DWORD dwAutoSearch;
        DWORD cb = sizeof(dwAutoSearch);

        if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN, L"AutoSearch", &dwType, &dwAutoSearch, &cb, FALSE, NULL, 0))
        {
            *pdwSearchStyle = dwAutoSearch;
            hr = S_OK;
        }
    }

    // return a default value
    if (FAILED(hr))
    {
        hr = S_FALSE;

        // Default to "display results in search pane and go to most likely site"
        *pdwSearchStyle = 3;
    }

    return hr;
}

BOOL AccessAllowed(IUnknown* punkSite, LPCWSTR pwszURL1, LPCWSTR pwszURL2)
{
    BOOL fRet = FALSE;

    if (pwszURL1 && pwszURL2)
    {
        IInternetSecurityManager *pSecMgr;
        HRESULT hr = IUnknown_QueryService(punkSite, SID_SInternetSecurityManager, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
        }
        if (SUCCEEDED(hr))
        {
            BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
            DWORD cbReqSid = ARRAYSIZE(reqSid);
            DWORD cbDocSid = ARRAYSIZE(docSid);

            if (   SUCCEEDED(pSecMgr->GetSecurityId(pwszURL1, reqSid, &cbReqSid, 0))
                && SUCCEEDED(pSecMgr->GetSecurityId(pwszURL2, docSid, &cbDocSid, 0))
                && (cbReqSid == cbDocSid)
                && (memcmp(reqSid, docSid, cbReqSid) == 0))                    
            {
                fRet = TRUE;
            }
            pSecMgr->Release();
        }
    }
    return fRet;
}

BOOL IsFrameWindow(IHTMLWindow2 * pHTMLWindow)
{
    BOOL fIsFrame = FALSE;

    HRESULT hr = E_FAIL;

    IHTMLWindow2 * pParentWindow = NULL;
    IHTMLWindow2 * pSelfWindow   = NULL;
    
    ASSERT(pHTMLWindow);

    hr = pHTMLWindow->get_self(&pSelfWindow);

    if (FAILED(hr) || (pSelfWindow == NULL))
    {
        goto cleanup;
    }

    hr = pHTMLWindow->get_parent(&pParentWindow);

    if (FAILED(hr) || (pParentWindow == NULL))
    {
        goto cleanup;
    }
    
    if (!IsSameObject(pSelfWindow, pParentWindow))
    {
        fIsFrame = TRUE;
    }

cleanup:

    if (pSelfWindow)
    {
        pSelfWindow->Release();
    }

    if (pParentWindow)
    {
        pParentWindow->Release();
    }

    return fIsFrame;
}


// For compatability with the Win2k debug SHELL32.DLL, this function needs to exist at ordinal 161.
// It's fine for it to return FALSE.
STDAPI_(BOOL) GetLeakDetectionFunctionTable(void *pTable)
{
    return FALSE;
}

STDAPI_(BOOL) IsCSIDLFolder(UINT csidl, LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathD(NULL, csidl, NULL, 0, szPath)))
    {
        PathRemoveBackslash(szPath);    // some platforms return version with slash on the end
        TCHAR szFolder[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szFolder, ARRAYSIZE(szFolder), NULL)))
        {
            bRet = (StrCmpI(szFolder, szPath) == 0);
        }
    }
    return bRet;
}

// Determines if the classic toolbar strips should be used, or the new
// Whistler toolbar strips.
//
// To use the new Whistler strips, the user must be running Whistler or later
// and have a display with greater than 256 colors.

STDAPI_(BOOL) SHUseClassicToolbarGlyphs (void)
{
    BOOL bRet = TRUE;

    if (SHGetCurColorRes() > 8)
    {
        if (GetUIVersion() > 5)
        {
            bRet = FALSE;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\winlist.h ===
//--------------------------------------------------------------------------
// Manage the windows list, such that we can get the IDispatch for each of 
// the shell windows to be marshalled to different processes
//---------------------------------------------------------------------------

HRESULT VariantClearLazy(VARIANTARG *pvarg);




extern DWORD g_dwWinListCFRegister;     // CoRegisterClassObject Registration DWORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\winlist.cpp ===
//--------------------------------------------------------------------------
// Manage the windows list, such that we can get the IDispatch for each of
// the shell windows to be marshalled to different processes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Includes...
#include "priv.h"
#include "sccls.h"
#include <varutil.h>
#include "winlist.h"
#include "iedde.h"

#define DM_WINLIST  0

void IEInitializeClassFactoryObject(IUnknown* punkAuto);
void IERevokeClassFactoryObject(void);

class CShellWindowListCF : public IClassFactory
{
public:
    // IUnKnown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    // constructor
    CShellWindowListCF();
    BOOL Init(void);

protected:
    ~CShellWindowListCF();

    // locals

    LONG            _cRef;
    IShellWindows    *_pswWinList;
};

DWORD g_dwWinListCFRegister = 0;
DWORD g_fWinListRegistered = FALSE;     // Only used in browser only mode...
IShellWindows *g_pswWinList = NULL;

// Function to get called by the tray to create the global window list and register
// it with the system

//=================================== Class Factory implemention ========================
CShellWindowListCF::CShellWindowListCF()
{
    _cRef = 1;
    DllAddRef();
}

BOOL CShellWindowListCF::Init()
{
    HRESULT hr = CSDWindows_CreateInstance(&_pswWinList);
    g_pswWinList = _pswWinList;

    // First see if there already is one defined...

    if (FAILED(hr))
    {
        TraceMsg(DM_WINLIST, "WinList_Init CoCreateInstance Failed: %x", hr);
        return FALSE;
    }

    // And register our class factory with the system...
    hr = CoRegisterClassObject(CLSID_ShellWindows, this,
                                 CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 REGCLS_MULTIPLEUSE, &g_dwWinListCFRegister);

    //  this call governs when we will call CoRevoke on the CF
    if (SUCCEEDED(hr) && g_pswWinList)
    {
        g_pswWinList->ProcessAttachDetach(TRUE);
    }

    // Create an instance of the underlying window list class...
    TraceMsg(DM_WINLIST, "WinList_Init CoRegisterClass: %x", hr);

    return SUCCEEDED(hr);
}

CShellWindowListCF::~CShellWindowListCF()
{
    if (_pswWinList)
    {
        g_pswWinList = NULL;
        _pswWinList->Release();
    }
    DllRelease();
}

STDMETHODIMP CShellWindowListCF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CShellWindowListCF, IClassFactory), // IID_IClassFactory
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellWindowListCF::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellWindowListCF::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShellWindowListCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // aggregation checking is done in class factory
    // For now simply use our QueryService to get the dispatch.
    // this will do all of the things to create it and the like.
    if (!_pswWinList) 
    {
        ASSERT(0);
        return E_FAIL;
    }
    return _pswWinList->QueryInterface(riid, ppvObj);
}

STDMETHODIMP CShellWindowListCF::LockServer(BOOL fLock)
{
    return S_OK;    // we don't do anything with this...
}

// As this is marshalled over to the main shell process hopefully this will take care of
// most of the serialization problems.  Probably still need a way to handle the case better
// where a window is coming up at the same time the last one is going down...
STDAPI CWinListShellProc_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;
    if (g_dwWinListCFRegister)
    {
        return CO_E_OBJISREG;
    }

    CShellWindowListCF *pswWinList = new CShellWindowListCF;
    if (pswWinList)
    {
        pswWinList->Init(); // tell it to initialize
        //
        //  TODO:   gpease  20-MAR-2002
        //          Shouldn't we fail if the Init() return FALSE?
        //
        *ppunk = SAFECAST(pswWinList, IUnknown *);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


BOOL WinList_Init(void)
{
    // Create our clas factory to register out there...
    TraceMsg(DM_WINLIST, "WinList_Init called");

    //
    //  If this is not a browser-only install. Register the class factory
    // object now with no instance. Otherwise, do it when the first instance
    // is created (see shbrowse.cpp).
    //
    if (!g_fBrowserOnlyProcess)
    {
        //
        //  First, register the class factory object for CLSID_InternetExplorer.
        // Note that we pass NULL indicating that subsequent CreateInstance
        // should simply create a new instance.
        //
        IEInitializeClassFactoryObject(NULL);

        CShellWindowListCF *pswWinList = new CShellWindowListCF;
        if (pswWinList)
        {
            BOOL fRetVal = pswWinList->Init(); // tell it to initialize
            pswWinList->Release(); // Release our handle hopefully init registered

            //
            // Initialize IEDDE.
            //
            if (!IsBrowseNewProcessAndExplorer())
            {
                IEDDE_Initialize();
            }

            return fRetVal;
        }
    }
    else
    {
        //
        // Initialize IEDDE. - Done before cocreate below for timing issues
        //
        IEDDE_Initialize();

        // All of the main processing moved to first call to WinList_GetShellWindows
        // as the creating of OLE object across processes messed up DDE timing.

        return TRUE;
    }

    return FALSE;
}

// Helper function to get the ShellWindows Object

IShellWindows* WinList_GetShellWindows(BOOL fForceMarshalled)
{
    IShellWindows *psw;

    if (fForceMarshalled)
    {
        psw = NULL;
    }
    else
    {
        psw = g_pswWinList;
    }

    if (psw) 
    {
        // Optimize the inter-thread case by using the global WinList,
        // this makes opening folders much faster.
        psw->AddRef();
    } 
    else 
    {
        SHCheckRegistry();

        HRESULT hr = CoCreateInstance(CLSID_ShellWindows, NULL,
                         CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                         IID_PPV_ARG(IShellWindows,  &psw));

        if ( (g_fBrowserOnlyProcess || !IsInternetExplorerApp()) && !g_fWinListRegistered)
        {
            // If it failed and we are not funning in integrated mode, and this is the
            // first time for this process, we should then register the Window List with
            // the shell process.  We moved that from WinList_Init as that caused us to
            // do interprocess send/post messages to early which caused DDE to break...
            g_fWinListRegistered = TRUE;    // only call once
            if (FAILED(hr))
            {
                SHLoadInProc(CLSID_WinListShellProc);

                hr = CoCreateInstance(CLSID_ShellWindows, NULL,
                                 CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARG(IShellWindows,  &psw));
            }

            if (psw)
            {
                psw->ProcessAttachDetach(TRUE);
            }
        }

        // hr == REGDB_E_CLASSNOTREG when the shell process isn't running.
        // hr == RPC_E_CANTCALLOUT_ININPUTSYNCCALL happens durring DDE launch of IE.
        // should investigate, but removing assert for IE5 ship.
        if (!(SUCCEEDED(hr) || hr == REGDB_E_CLASSNOTREG || hr == RPC_E_CANTCALLOUT_ININPUTSYNCCALL))
        {
            TraceMsg(TF_WARNING, 
                     "WinList_GetShellWindows CoCreateInst(CLSID_ShellWindows) failed %x", hr);
        }
    }

    return psw;
}


// Function to terminate our use of the window list.
void WinList_Terminate(void)
{
    // Lets release everything in a thread safe way...
    TraceMsg(DM_WINLIST, "WinList_Terminate called");

    IEDDE_Uninitialize();

    // Release our usage of the object to allow the system to clean it up
    if (!g_fBrowserOnlyProcess)
    {
        //  this is the explorer process, and we control the vertical

        if (g_dwWinListCFRegister) {
            IShellWindows* psw = WinList_GetShellWindows(FALSE);
            if (psw)
            {
#ifdef DEBUG
                long cwindow = -1;
                psw->get_Count(&cwindow);
                if (cwindow != 0)
                {
                    TraceMsg(DM_ERROR, "wl_t: cwindow=%d (!=0)", cwindow);
                }
#endif
                psw->ProcessAttachDetach(FALSE);
                psw->Release();
            }

            //  the processattachdetach() should kill the CF in our process
            if (g_dwWinListCFRegister != 0)
            {
                TraceMsg(DM_ERROR, "wl_t: g_dwWinListCFRegister=%d (!=0)", g_dwWinListCFRegister);
            }

        }

        IERevokeClassFactoryObject();
        CUrlHistory_CleanUp();
    }
    else
    {
        if (g_fWinListRegistered)
        {
            // only do this if we actually registered...
            IShellWindows* psw = WinList_GetShellWindows(TRUE);
            if (psw)
            {
                psw->ProcessAttachDetach(FALSE);    // Tell it we are going away...
                psw->Release();
            }
        }
    }
}

STDAPI WinList_Revoke(long dwRegister)
{
    IShellWindows* psw = WinList_GetShellWindows(TRUE);

    HRESULT hr = E_FAIL;
    TraceMsg(DM_WINLIST, "WinList_Reevoke called on %x", dwRegister);
    if (psw)
    {
        hr = psw->Revoke((long)dwRegister);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "WinList_Revoke(%x) failed. hresult = %x", dwRegister, hr);
        }
        psw->Release();
    }

    return hr;
}

STDAPI WinList_NotifyNewLocation(IShellWindows* psw, long dwRegister, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_UNEXPECTED;
    if (pidl) 
    {
        VARIANT var;
        hr = InitVariantFromIDList(&var, pidl);
        if (SUCCEEDED(hr)) 
        {
            hr = psw->OnNavigate(dwRegister, &var);
            VariantClearLazy(&var);
        } 
    }
    return hr;
}

// Register with the window list that we have a pidl that we are starting up.

STDAPI WinList_RegisterPending(DWORD dwThread, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, long *pdwRegister)
{
    HRESULT hr = E_UNEXPECTED;
    ASSERT(!pidlRoot);
    if (pidl)
    {
        IShellWindows* psw = WinList_GetShellWindows(FALSE);
        if (psw)
        {
            VARIANT var;
            hr = InitVariantFromIDList(&var, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psw->RegisterPending(dwThread, &var, PVAREMPTY, SWC_BROWSER, pdwRegister);
                VariantClearLazy(&var);
            }
        }
    }
    return hr;
}

/*
 * PERFORMANCE note - getting back the automation object (ppauto) is really
 * expensive due to the marshalling overhead.  Don't query for it unless you
 * absolutely need it!
 */

STDAPI WinList_FindFolderWindow(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, HWND *phwnd, IWebBrowserApp **ppauto)
{
    HRESULT hr = E_UNEXPECTED;
    ASSERT(!pidlRoot);

    if (ppauto)
    {
        *ppauto = NULL;
    }

    if (phwnd)
    {
        *phwnd = NULL;
    }

    if (pidl) 
    {
        // Try a cached psw if we don't need ppauto
        IShellWindows* psw = WinList_GetShellWindows(ppauto != NULL);
        if (psw)
        {
            VARIANT var;
            hr = InitVariantFromIDList(&var, pidl);
            if (SUCCEEDED(hr)) 
            {
                IDispatch* pdisp = NULL;
                hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, (long *)phwnd,
                        ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                        &pdisp);
                if (pdisp) 
                {
                    // if this fails it's because we are inside SendMessage loop and ole doesn't like it
                    if (ppauto)
                    {
                        hr = pdisp->QueryInterface(IID_PPV_ARG(IWebBrowserApp, ppauto));
                    }

                    pdisp->Release();
                }
                VariantClearLazy(&var);
            }
            psw->Release();
        }
    }
    return hr;
}

// Support for Being able to open a folder and get it's idispatch...
//
class CWaitForWindow
{
public:
    ULONG AddRef(void);
    ULONG Release(void);

    BOOL Init(IShellWindows *psw, LPCITEMIDLIST pidl, DWORD dwPending);
    void CleanUp(void);
    HRESULT WaitForWindowToOpen(DWORD dwTimeout);

    CWaitForWindow(void);

private:
    ~CWaitForWindow(void);
    // internal class to watch for events...
    class CWindowEvents : public DShellWindowsEvents
    {
    public:

        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHOD(GetTypeInfoCount)(THIS_ UINT * pctinfo);
        STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
        STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR * * rgszNames,
            UINT cNames, LCID lcid, DISPID * rgdispid);
        STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult,
            EXCEPINFO * pexcepinfo, UINT * puArgErr);

    } m_EventHandler;

    friend class CWindowEvents;

    LONG m_cRef;
    DWORD m_dwCookie;
    IShellWindows *m_psw;
    IConnectionPoint *m_picp;
    DWORD m_dwPending;
    LPITEMIDLIST m_pidl;
    HANDLE m_hevent;
    BOOL m_fAdvised;
};


ULONG CWaitForWindow::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CWaitForWindow::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CWaitForWindow::CWaitForWindow(void) : m_cRef(1)
{
    ASSERT(m_psw == NULL);
    ASSERT(m_picp == NULL);
    ASSERT(m_hevent == NULL);
    ASSERT(m_dwCookie == 0);
    ASSERT(m_fAdvised == FALSE);
}

CWaitForWindow::~CWaitForWindow(void)
{
    ATOMICRELEASE(m_psw);

    CleanUp();

    if (m_hevent)
    {
        CloseHandle(m_hevent);
    }

    if (m_pidl)
    {
        ILFree(m_pidl);
    }
}

BOOL CWaitForWindow::Init(IShellWindows *psw, LPCITEMIDLIST pidl, DWORD dwPending)
{
    // First try to create an event object
    m_hevent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hevent)
        return FALSE;

    // We do not have a window or it is pending...
    // first lets setup that we want to be notified of new windows.
    if (FAILED(ConnectToConnectionPoint(SAFECAST(&m_EventHandler, IDispatch*), DIID_DShellWindowsEvents, TRUE, psw, &m_dwCookie, &m_picp)))
        return FALSE;

    // Save away passed in stuff that we care about.
    m_psw = psw;
    psw->AddRef();
    m_pidl = ILClone(pidl);
    m_dwPending = dwPending;

    return TRUE;
}

void CWaitForWindow::CleanUp(void)
{
    // Don't need to listen anmore.
    if (m_dwCookie)
    {
        m_picp->Unadvise(m_dwCookie);
        m_dwCookie = 0;
    }

    ATOMICRELEASE(m_picp);
}

HRESULT CWaitForWindow::WaitForWindowToOpen(DWORD dwTimeOut)
{
    if (!m_hevent || !m_dwCookie)
        return E_FAIL;

    ENTERCRITICAL;

    if (!m_fAdvised)
    {
        ResetEvent(m_hevent);
    }

    LEAVECRITICAL;

    DWORD dwStart = GetTickCount();
    DWORD dwWait = dwTimeOut;
    DWORD dwWaitResult;

    do
    {
        dwWaitResult = MsgWaitForMultipleObjects(1, &m_hevent, FALSE, // fWaitAll, wait for any one
                                                 dwWait, QS_ALLINPUT);

        // Check if we are signaled for a send message.
        if (dwWaitResult != WAIT_OBJECT_0 + 1)
        {
            break;  // No. Break out of the loop.
        }

        // We may need to dispatch stuff here.
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        // than MSEC_MAXWAIT if we wait more than that.
        dwWait = dwStart+dwTimeOut - GetTickCount();

    } while (dwWait <= dwTimeOut);

    BOOL fAdvised;
    {
        ENTERCRITICAL;
    
        fAdvised = m_fAdvised;
        m_fAdvised = FALSE;
    
        LEAVECRITICAL;
    }

    return fAdvised ? S_OK : E_FAIL;
}

STDMETHODIMP CWaitForWindow::CWindowEvents::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENTMULTI2(CWaitForWindow::CWindowEvents, DIID_DShellWindowsEvents, DShellWindowsEvents),
        QITABENTMULTI(CWaitForWindow::CWindowEvents, IDispatch, DShellWindowsEvents),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CWaitForWindow::CWindowEvents::AddRef(void)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);
    return pdfwait->AddRef();
}

ULONG CWaitForWindow::CWindowEvents::Release(void)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);
    return pdfwait->Release();
}

HRESULT CWaitForWindow::CWindowEvents::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CWaitForWindow::CWindowEvents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CWaitForWindow::CWindowEvents::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}


HRESULT CWaitForWindow::CWindowEvents::Invoke(DISPID dispid, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);

    if (dispid == DISPID_WINDOWREGISTERED)
    {
        ENTERCRITICAL;
        
        // Signal the event
        pdfwait->m_fAdvised = TRUE;
        ::SetEvent(pdfwait->m_hevent);
        
        LEAVECRITICAL;
    }

    return S_OK;
}

// WARNING:: this assumes not rooted
STDAPI SHGetIDispatchForFolder(LPCITEMIDLIST pidl, IWebBrowserApp **ppauto)
{
    HRESULT hr = E_UNEXPECTED;

    if (ppauto)
    {
        *ppauto = NULL;
    }

    if (!pidl)
        return E_POINTER;

    // Try a cached psw if we don't need ppauto
    IShellWindows* psw = WinList_GetShellWindows(ppauto != NULL);
    if (psw)
    {
        VARIANT var;
        hr = InitVariantFromIDList(&var, pidl);
        if (SUCCEEDED(hr)) 
        {
            LONG lhwnd;
            IDispatch* pdisp;
            hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, &lhwnd,
                    ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                    &pdisp);
            if ((hr == E_PENDING) || (hr == S_FALSE))
            {
                HRESULT hrOld = hr;
                hr = E_FAIL;
                CWaitForWindow *pdfwait = new CWaitForWindow();   // Setup a wait object...
                if (pdfwait)
                {
                    if (pdfwait->Init(psw, pidl, 0))
                    {
                        if (hrOld == S_FALSE)
                        {
                            // Startup opening a new window
                            SHELLEXECUTEINFO sei = {sizeof(sei)};

                            sei.lpIDList = (void *)pidl;

                            //
                            //  WARNING - old versions of ShellExec() didnt pay attention - ZekeL - 30-DEC-98
                            //  to whether the hwnd is in the same process or not, 
                            //  and so could fault in TryDDEShortcut().
                            //  only pass the hwnd if the shell window shares 
                            //  the same process.
                            //
                            sei.hwnd = GetShellWindow();
                            DWORD idProcess;
                            GetWindowThreadProcessId(sei.hwnd, &idProcess);
                            if (idProcess != GetCurrentProcessId())
                            {
                                sei.hwnd = NULL;
                            }

                            // Everything should have been initialize to NULL(0)
                            sei.fMask = SEE_MASK_IDLIST | SEE_MASK_FLAG_DDEWAIT;
                            sei.nShow = SW_SHOWNORMAL;

                            hr = ShellExecuteEx(&sei) ? S_OK : S_FALSE;
                        }

                        while ((hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, &lhwnd,
                                ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                                &pdisp)) != S_OK)
                        {
                            if (FAILED(pdfwait->WaitForWindowToOpen(20 * 1000)))
                            {
                                hr = E_ABORT;
                                break;
                            }
                        }
                    }
                    pdfwait->CleanUp();   // No need to watch things any more...
                    pdfwait->Release(); // release our use of this object...
                }
            }

            if (hr == S_OK && ppauto) 
            {
                // if this fails this is because we are inside SendMessage loop
                hr = pdisp->QueryInterface(IID_PPV_ARG(IWebBrowserApp, ppauto));
            }

            if (pdisp)
            {
                pdisp->Release();
            }

            VariantClear(&var);
        }
        psw->Release();
    }
    return hr;
}

#undef VariantCopy

WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    VariantClearLazy(pvargDest);

    switch(pvargSrc->vt) {
    case VT_I4:
    case VT_UI4:
    case VT_BOOL:
        // we can add more
        *pvargDest = *pvargSrc;
        return S_OK;

    case VT_UNKNOWN:
        if (pvargDest) {
            *pvargDest = *pvargSrc;
            if (pvargDest->punkVal)
                pvargDest->punkVal->AddRef();
            return S_OK;
        }
        ASSERT(0);
        return E_INVALIDARG;
    }

    return VariantCopy(pvargDest, pvargSrc);
}

//
// WARNING: This function must be placed at the end because we #undef
// VariantClear
//
#undef VariantClear

HRESULT VariantClearLazy(VARIANTARG *pvarg)
{
    switch(pvarg->vt) 
    {
        case VT_I4:
        case VT_UI4:
        case VT_EMPTY:
        case VT_BOOL:
            // No operation
            break;

        case VT_UNKNOWN:
            if(V_UNKNOWN(pvarg) != NULL)
              V_UNKNOWN(pvarg)->Release();
            break;

        case VT_DISPATCH:
            if(V_DISPATCH(pvarg) != NULL)
              V_DISPATCH(pvarg)->Release();
            break;

        case VT_SAFEARRAY:
            THR(SafeArrayDestroy(V_ARRAY(pvarg)));
            break;

        default:
            return VariantClear(pvarg);
    }

    V_VT(pvarg) = VT_EMPTY;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\wvt.cpp ===
#include "priv.h"
#include <wintrust.h>
#include "wvtp.h"

#define WINTRUST TEXT("wintrust.dll")

#ifdef DELAY_LOAD_WVT

#ifndef _WVTP_NOCODE_
Cwvt::Cwvt()
{
    m_fInited = FALSE;
}

Cwvt::~Cwvt()
{
    if (m_fInited) {
        FreeLibrary(m_hMod);
    }
}

HRESULT 
Cwvt::Init(void)
{

    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary( WINTRUST );

    if (NULL == m_hMod) {
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
    }


#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) { \
        FreeLibrary(m_hMod); \
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)); \
    }

    CHECKAPI(WinVerifyTrust);

    m_fInited = TRUE;
    return S_OK;
}


#endif // _WVTP_NOCODE_
#endif // DELAY_LOAD_WVT

#define REGSTR_PATH_INFODEL_REST     TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions")
#define REGSTR_PATH_DOWNLOAD  TEXT("Software\\Microsoft\\Internet Explorer\\Download")
#define REGVAL_UI_REST        TEXT("NoWinVerifyTrustUI")

BOOL
IsUIRestricted()
{

    HKEY hkeyRest = 0;
    BOOL bUIRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);

    // per-machine UI off policy
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_READ, &hkeyRest) == ERROR_SUCCESS) {

        if (RegQueryValueEx( hkeyRest, REGVAL_UI_REST, NULL, NULL,
                      (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
            bUIRest = TRUE;

        RegCloseKey(hkeyRest);
    }

    return bUIRest;
}

// FEATURE: move these to corpolicy.h in iedev\inc!!!
// {D41E4F1F-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_LOCKDOWN_CHECK \
{ 0xd41e4f1f, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

//--------------------------------------------------------------------
// For COR_POLICY_LOCKDOWN_CHECK:
// -----------------------------

// Structure to pass into WVT
typedef struct _COR_LOCKDOWN {
    DWORD                 cbSize;          // Size of policy provider
    DWORD                 flag;            // reserved
    BOOL                  fAllPublishers;  // Trust all publishers or just ones in the trusted data base
} COR_LOCKDOWN, *PCOR_LOCKDOWN;


HRESULT Cwvt::VerifyTrust(HANDLE hFile, HWND hWnd, LPCWSTR szStatusText) 
{
    WINTRUST_DATA           sWTD = {0};
    WINTRUST_FILE_INFO      sWTFI = {0};

    GUID gV2 = COR_POLICY_LOCKDOWN_CHECK;
    COR_LOCKDOWN  sCorPolicy;

    HRESULT hr = S_OK;

    ZeroMemory(&sCorPolicy, sizeof(sCorPolicy));
    
    sCorPolicy.cbSize = sizeof(COR_LOCKDOWN);

    if ( (hWnd == INVALID_HANDLE_VALUE) || IsUIRestricted())
        sCorPolicy.fAllPublishers = FALSE; // lockdown to only trusted pubs
    else
        sCorPolicy.fAllPublishers = TRUE; // regular behavior
    
    // Set up the winverify provider structures
       
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = hFile;
    sWTFI.pcwszFilePath = szStatusText;

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.pPolicyCallbackData = &sCorPolicy; // Add in the cor trust information!!

    //check policy to find out if we should display UI 

    if (SHRegGetBoolUSValue(REGSTR_PATH_DOWNLOAD, TEXT("CheckExeSignatures"),FALSE, FALSE))
    {
        sWTD.dwUIChoice     = WTD_UI_ALL;        // No bad UI is overridden in COR TRUST provider
        sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
        sWTD.pFile          = &sWTFI;
        
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);

        hr = WinVerifyTrust(hWnd, &gV2, &sWTD);
        
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }

        // APPCOMPAT: this works around a wvt bug that returns 0x57 (success) when
        // you hit No to an usigned control
        if (SUCCEEDED(hr) && hr != S_OK) {
            hr = TRUST_E_FAIL;
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include "mshtmdid.h"
#include "shlwapi.h"
#include <htmlhelp.h>
#include "mshtml.h"     // for IHTMLElement

#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif
#include "shui.h"

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


extern HICON g_hiconSplat;
extern HICON g_hiconSplatSm;


void    LoadCommonIcons(void);
BOOL    ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);
void    SaveDefaultFolderSettings();
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState);

//
// Automation support.
//
HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);
HRESULT CDDEAuto_get_LocationURL(BSTR * pstr, HWND hwnd);
HRESULT CDDEAuto_get_LocationTitle(BSTR * pstr, HWND hwnd);
HRESULT CDDEAuto_get_HWND(long * phwnd);
HRESULT CDDEAuto_Exit(void);

BOOL    _InitComCtl32();

// 
//  Menu utility functions
//

void    Menu_Replace(HMENU hmenuDst, HMENU hmenuSrc);
#define  LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)
void    Menu_AppendMenu(HMENU hmenuDst, HMENU hmenuSrc);
TCHAR   StripMneumonic(LPTSTR szMenu);


DWORD   CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt);

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault);

DWORD SHRandom(void);

STDAPI_(BOOL) UrlIsInCache(LPCTSTR pszURL);
STDAPI_(BOOL) UrlIsMappedOrInCache(LPCTSTR pszURL);

#ifdef UNICODE
#define IsSubscribable IsSubscribableW
#endif // UNICODE

BOOL IsFileUrl(LPCSTR psz);
BOOL IsFileUrlW(LPCWSTR pcwzUrl);
BOOL IsEmptyStream(IStream* pstm);
BOOL IsInternetExplorerApp();
BOOL IsTopFrameBrowser(IServiceProvider *psp, IUnknown *punk);
BOOL IsSubscribableW(LPCWSTR psz);

#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE

HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, 
                           LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
HRESULT URLSubRegQueryW(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fUseHKCU, 
                           LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
#ifdef UNICODE
#define URLSubRegQuery URLSubRegQueryW
#else
#define URLSubRegQuery URLSubRegQueryA
#endif

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

void    _DeletePidlDPA(HDPA hdpa);

STDAPI_(BOOL) GetShortcutFileName(LPCTSTR pszTarget, LPCTSTR pszTitle, LPCTSTR pszDir, LPTSTR pszOut, int cchOut);
    

//-----------------------------------------------------------------------------
#define PropagateMessage SHPropagateMessage

//-----------------------------------------------------------------------------

BOOL PrepareURLForExternalApp(LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut);


#define PrepareURLForDisplayUTF8  PrepareURLForDisplayUTF8W 
#define PrepareURLForDisplay      PrepareURLForDisplayW

STDAPI_(BOOL) PrepareURLForDisplayW(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut);
HRESULT PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut, BOOL fUTF8Enabled);
BOOL ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
BOOL ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
BOOL ParseURLFromOutsideSourceWithContextW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, ISearchContext * pSC);

BOOL UTF8Enabled();


HRESULT         FormatUrlForDisplay(LPWSTR pszURL, LPWSTR pszFriendly, UINT cbBuf, LPWSTR pszFrom, UINT cbFrom, BOOL fSeperate, DWORD dwCodePage, PWSTR pwzCachedFileName);
BOOL    __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...);
EXECUTION_STATE _SetThreadExecutionState(EXECUTION_STATE esFlags);


//=--------------------------------------------------------------------------=
// string helpers.
//

STDAPI_(BSTR) SysAllocStringA(LPCSTR pszAnsiStr);
STDAPI_(BSTR) LoadBSTR(UINT uID);

#ifdef UNICODE
#define SysAllocStringT(psz)    SysAllocString(psz)
#else
#define SysAllocStringT(psz)    SysAllocStringA(psz)
#endif

// FEATURE:: Need to handle two different implementations of SHChangeRegister...
typedef ULONG (* PFNSHCHANGENOTIFYREGISTER)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
typedef BOOL  (* PFNSHCHANGENOTIFYDEREGISTER)(unsigned long ulID);


extern PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister;
extern PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister;
extern BOOL g_fNewNotify;

#define SZ_BINDCTXKEY_SITE         L"Site"

#define MAX_PAGES 16  // limit on the number of pages we can have

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);

ULONG   RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);
void    Cabinet_FlagsToParams(UINT uFlags, LPTSTR pszParams);
HRESULT BindToAncesterFolder(LPCITEMIDLIST pidlAncester, LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);

// logical defines for grfKeyState bits
#define FORCE_COPY (MK_LBUTTON | MK_CONTROL)                // means copy
#define FORCE_LINK (MK_LBUTTON | MK_CONTROL | MK_SHIFT)     // means link

HRESULT IsChildOrSelf(HWND hwndParent, HWND hwnd);

extern HIMAGELIST g_himlSysSmall;
extern HIMAGELIST g_himlSysLarge;

void    _InitSysImageLists();

extern const VARIANT c_vaEmpty;
//
// FEATURE: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

extern UINT g_cfURL;
extern UINT g_cfURLW;
extern UINT g_cfHIDA;
extern UINT g_cfFileDescA;
extern UINT g_cfFileDescW;
extern UINT g_cfFileContents;

#ifdef UNICODE
#define g_cfFileDesc    g_cfFileDescW
#else
#define g_cfFileDesc    g_cfFileDescA
#endif

void InitClipboardFormats();

void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg);

LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);       // dllreg.cpp

//-------------------------------------------------------------------------

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxSmIcon;
extern int g_cySmIcon;

enum TRI_STATE
{
    TRI_UNKNOWN = 2,
    TRI_TRUE = TRUE,
    TRI_FALSE = FALSE
};

BOOL        IsSameObject(IUnknown* punk1, IUnknown* punk2);

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

LPCTSTR     SkipLeadingSlashes(LPCTSTR pszURL);

extern const LARGE_INTEGER c_li0;
extern const DISPPARAMS c_dispparamsNoArgs;
#ifndef UNIX
#define g_dispparamsNoArgs ((DISPPARAMS)c_dispparamsNoArgs) // prototype was incorrect!
#else
#define g_dispparamsNoArgs c_dispparamsNoArgs // prototype was incorrect!
#endif
BOOL IsEmptyStream(IStream* pstm);

void SetParentHwnd(HWND hwnd, HWND hwndParent);
#ifndef UNICODE

#define ADJUST_TO_WCHAR_POS     0
#define ADJUST_TO_TCHAR_POS     1
int AdjustECPosition(char *psz, int iPos, int iType);

HRESULT MapNbspToSp(LPCWSTR lpwszIn, LPTSTR lpszOut, int cbszOut);
HRESULT GetDisplayableTitle(LPTSTR psz, LPCWSTR wszTitle, int cch);
#endif

LPITEMIDLIST GetTravelLogPidl(IBrowserService * pbs);

BOOL ILIsWeb(LPCITEMIDLIST pidl);

#define AnsiToUnicode(pstr, pwstr, cch)     SHAnsiToUnicode(pstr, pwstr, cch)
#define UnicodeToAnsi(pwstr, pstr, cch)     SHUnicodeToAnsi(pwstr, pstr, cch)

#define UnicodeToTChar(pwstr, pstr, cch)    SHUnicodeToTChar(pwstr, pstr, cch)
#define AnsiToTChar(pstr, ptstr, cch)       SHAnsiToTChar(pstr, ptstr, cch)
#define TCharToAnsi(ptstr, pstr, cch)       SHTCharToAnsi(ptstr, pstr, cch)

//Function for doing drag and drop given a pidl
HRESULT DragDrop(HWND hwnd, IShellFolder* psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD* pdwEffect);
HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect);

//Function for getting icon index corresponding to htm files
int _GetIEHTMLImageIndex();
int _GetHTMLImageIndex();
int IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int * piSelectedImage);
void IEInvalidateImageList(void);

extern UINT g_cfURL;
extern UINT g_cfURLW;
extern UINT g_cfFileDescA;
extern UINT g_cfFileContents;
extern UINT g_cfPreferredEffect;
extern UINT g_cfPerformedEffect;
extern UINT g_cfTargetCLSID;
#ifdef UNICODE
#define g_cfFileDesc    g_cfFileDescW
#else
#define g_cfFileDesc    g_cfFileDescA
#endif

void InitClipboardFormats();

BOOL IsExpandableFolder(IShellFolder* psf, LPCITEMIDLIST pidl);

extern BOOL IsGlobalOffline(void);
extern void SetGlobalOffline(BOOL fOffline);

BOOL GetHistoryFolderPath(LPTSTR pszPath, int cchPath);
IStream * OpenPidlOrderStream(LPCITEMIDLIST pidlRoot
                                , LPCITEMIDLIST pidl       
                                , LPCSTR pszKey
                                , DWORD   grfMode);


int SearchMapInt(const int *src, const int *dst, int cnt, int val);

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

// this is for the file menus recently visited list.  
//  it represents the count of entries both back and forward 
//  that should be on the menu.
#define CRECENTMENU_MAXEACH     5

BOOL VerbExists(LPCTSTR pszExtension, LPCTSTR pszVerb, LPTSTR pszCommand);

HRESULT CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPCTSTR pszTitle, LPTSTR pszOut, int cchOut);

//  the shell32 implementation of ILClone is different for win95 an ie4.
//  it doesnt check for NULL in the old version, but it does in the new...
//  so we need to redefine it to always check
STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone      

STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid);

BOOL ExecItemFromFolder(HWND hwnd, LPCSTR pszVerb, IShellFolder* psf, LPCITEMIDLIST pidlItem);

HRESULT NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow);
HRESULT NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow);

#ifdef UNICODE
#define NavToUrlUsingIE             NavToUrlUsingIEW
#else // UNICODE
#define NavToUrlUsingIE             NavToUrlUsingIEA
#endif // UNICODE

DWORD WaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
BOOL  CreateNewFolder(HWND hwndOwner, LPCITEMIDLIST pidlParent, LPTSTR szPathNew, int nSize);

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc);
STDAPI_(IBindCtx *) CreateBindCtxForUI(IUnknown * punkSite);

void GetWebLocaleAsRFC1766(LPTSTR pszLocale, int cchLocale);

BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);
BOOL FindBrowserWindow(void);

BOOL IsVK_TABCycler(MSG * pMsg);

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
void _DragMove(HWND hwndTarget, const POINTL ptStart);


BOOL IsFeaturePotentiallyAvailable(REFCLSID rclsid);

STDAPI_(UINT) GetWheelMsg();

STDAPI GetCacheLocation(LPTSTR pszCacheLocation, DWORD cchCacheLocation);

STDAPI StringToStrRet(LPCTSTR pString, STRRET *pstrret);

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);

HRESULT GetNavTargetName(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars);
STDAPI GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky);

void FixAmpersands(LPWSTR pszToFix, UINT cchMax);

BOOL IsInetcplRestricted(LPCWSTR pszCommand);
BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass);
BOOL HasExtendedChar(LPCWSTR pszQuery);
void ConvertToUtf8Escaped(LPWSTR pszQuery, int cch);
HRESULT SHPathPrepareForWriteWrap(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, UINT wFunc, DWORD dwFlags);

BOOL SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);

HRESULT IExtractIcon_GetIconLocation(
    IUnknown *punk,
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags);

HRESULT IExtractIcon_Extract(
    IUnknown *punk,
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize);
    
// Takes in lpszPath and returns the other form (SFN or LFN).
void GetPathOtherFormA(LPSTR lpszPath, LPSTR lpszNewPath, DWORD dwSize);

STDAPI CoAllowSetForegroundWindow(IUnknown *punk, void *pvReserved);    // in > v5 headers

HRESULT GetSearchStyle(IServiceProvider * psp, LPDWORD pdwSearchStyle);

BOOL AccessAllowed(
    IUnknown* punkSite,
    LPCWSTR pwszURL1,
    LPCWSTR pwszURL2);

BOOL IsFrameWindow(IHTMLWindow2 * pHTMLWindow);

STDAPI SHGetFolderPathD(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

STDAPI_(BOOL) IsCSIDLFolder(UINT csidl, LPCITEMIDLIST pidl);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\cdfview\copyhook.cpp ===
//
// Copy Hook Handler for CDFView shell extension
//
// Description:
//     This object installs an ICopyHook handler that traps all
//     copies/movies/renames in the shell so that we can special 
//     case links to channel objects and unsubscribe them when
//     the link is deleted. The implementation is in shdocvw for
//     speed.
//
// julianj 6/16/97
// 

#include "priv.h"
#include "sccls.h"
#include "chanmgr.h"
#include "channel.h"
#include "../resource.h"

#include <mluisupp.h>

class CCDFCopyHook 
                        : public ICopyHookA
                        , public ICopyHookW
{
public:
    
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** ICopyHookA method ***
    STDMETHODIMP_(UINT) CopyCallback(HWND hwnd, 
        UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs, LPCSTR pszDestFile, DWORD dwDestAttribs);

    // *** ICopyHookW method ***
    STDMETHODIMP_(UINT) CopyCallback(HWND hwnd, 
        UINT wFunc, UINT wFlags, LPCWSTR pwzSrcFile, DWORD dwSrcAttribs, LPCWSTR pwzDestFile, DWORD dwDestAttribs);

private:
    CCDFCopyHook( HRESULT * pHr);
    ~CCDFCopyHook();

    BOOL IsSubscriptionFolder(LPCTSTR pszPath);

    LONG m_cRef;

    friend HRESULT CCDFCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor
};

//The copyhook handler uses this function

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath)
{
    HRESULT hr;
    TCHAR szChannel[MAX_PATH];
    TCHAR szFav[MAX_PATH];
    ULONG cbChannel = sizeof(szChannel);
    
    if (SHGetSpecialFolderPath(NULL, szFav, CSIDL_FAVORITES, TRUE))
    {
        //
        // Get the potentially localized name of the Channel folder from the
        // registry if it is there.  Otherwise just read it from the resource.
        // Then tack this on the favorites path.
        //

        if (ERROR_SUCCESS != SHRegGetUSValue(L"Software\\Microsoft\\Windows\\CurrentVersion",
                                             L"ChannelFolderName", NULL, (void*)szChannel,
                                             &cbChannel, TRUE, NULL, 0))
        {
            MLLoadString(IDS_CHANNEL, szChannel, ARRAYSIZE(szChannel));
        }

        if (PathCombine(pszPath, szFav, szChannel))
        {
            //
            // For IE5+ use the channels dir if it exists - else use favorites
            //
            if (!PathFileExists(pszPath))
                StrCpyN(pszPath, szFav, cchPath);

            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

    }    
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


//
// Basic CreateInstance for this object
//
HRESULT CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    if ( pUnkOuter )
        return CLASS_E_NOAGGREGATION;

    HRESULT hr = NOERROR;
    CCDFCopyHook * pCDFCopyHook = new CCDFCopyHook( & hr );
    if ( !pCDFCopyHook )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pCDFCopyHook;
        return hr;
    }
    
    *ppunk = SAFECAST(pCDFCopyHook, ICopyHookA *);
    return NOERROR;
}

STDMETHODIMP CCDFCopyHook::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IShellCopyHookA))
    {
        *ppvObj = SAFECAST(this, ICopyHookA *);
    }
    else if (IsEqualIID(riid, IID_IShellCopyHookW))
    {
        *ppvObj = SAFECAST(this, ICopyHookW *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

STDMETHODIMP_ (ULONG) CCDFCopyHook::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_ (ULONG) CCDFCopyHook::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CCDFCopyHook::CCDFCopyHook( HRESULT * pHr) : m_cRef(1)
{
    *pHr = S_OK;
    DllAddRef();
}

CCDFCopyHook::~CCDFCopyHook()
{
    DllRelease();
}

////////////////////////////////////////////////////////////////////////////////
//
// ICopyHookA::CopyCallback
//
// Either allows the shell to move, copy, delete, or rename a folder or printer
// object, or disallows the shell from carrying out the operation. The shell 
// calls each copy hook handler registered for a folder or printer object until
// either all the handlers have been called or one of them returns IDCANCEL.
//
// RETURNS:
//
//  IDYES    - Allows the operation.
//  IDNO     - Prevents the operation on this file, but continues with any other
//             operations (for example, a batch copy operation).
//  IDCANCEL - Prevents the current operation and cancels any pending operations
//
////////////////////////////////////////////////////////////////////////////////
UINT CCDFCopyHook::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCSTR pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    WCHAR szSrcFile[MAX_PATH];
    WCHAR szDestFile[MAX_PATH];

    AnsiToUnicode(pszSrcFile, szSrcFile, ARRAYSIZE(szSrcFile));

    if (pszDestFile)    // shell32.dll can call with NULL for pszDestFile
        AnsiToUnicode(pszDestFile, szDestFile, ARRAYSIZE(szDestFile));
    else
        szDestFile[0] = L'\0';

    return CopyCallback(hwnd, wFunc, wFlags, szSrcFile, dwSrcAttribs, szSrcFile, dwDestAttribs);
}


CCDFCopyHook::IsSubscriptionFolder(LPCTSTR pszPath)
{
    TCHAR szSubsPath[MAX_PATH] = {0};
    DWORD dwSize = SIZEOF(szSubsPath);

    if (SHGetValueGoodBoot(HKEY_LOCAL_MACHINE, REGSTR_PATH_SUBSCRIPTION,
                       REGSTR_VAL_DIRECTORY, NULL, (LPBYTE)szSubsPath, &dwSize) != ERROR_SUCCESS)
    {
        TCHAR szWindows[MAX_PATH];

        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathCombine(szSubsPath, szWindows, TEXT("Offline Web Pages"));
    }

    return 0 == StrCmpI(pszPath, szSubsPath);
}

////////////////////////////////////////////////////////////////////////////////
//
// ICopyHookW::CopyCallback
//
// Currently we just thunk to the ansi version.
//
////////////////////////////////////////////////////////////////////////////////
UINT CCDFCopyHook::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCWSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCWSTR pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    HRESULT hr;
    ICopyHookA * pCDFViewCopyHookA;
    TCHAR   szPath[MAX_PATH];

    //
    // Return immediately if this isn't a system folder or if isn't a delete or
    // rename operation
    //
    if (!(wFunc == FO_DELETE || wFunc == FO_RENAME))
    {
        return IDYES;
    }

    // no rename of channels folder allowed.
    if ((wFunc == FO_RENAME) 
            && (Channel_GetFolder(szPath, ARRAYSIZE(szPath)) == S_OK) 
            && (StrCmpI(szPath, pszSrcFile) ==  0))
    {
        MessageBeep(MB_OK);
        return IDNO;
    }

    if (SHRestricted2W(REST_NoRemovingSubscriptions, NULL, 0) &&
        IsSubscriptionFolder(pszSrcFile))
    {
        MessageBeep(MB_OK);
        return IDNO;
    }

    if (!(dwSrcAttribs & FILE_ATTRIBUTE_SYSTEM))
        return IDYES;
    //
    // REVIEW could check for guid in desktop.ini matching CDFVIEW but its 
    // cleaner to have the ChannelMgr know about that
    //

    //
    // Create the channel manager object and ask it for the copy hook iface
    //
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL,  CLSCTX_INPROC_SERVER, 
                          IID_IShellCopyHookA, (void**)&pCDFViewCopyHookA);
    if (SUCCEEDED(hr))
    {
        //
        // Delegate to the Copy hook handler in the channel mgr
        //
        CHAR szSrcFile[MAX_PATH];
        CHAR szDestFile[MAX_PATH] = {'\0'};

        SHUnicodeToAnsi(pszSrcFile, szSrcFile, ARRAYSIZE(szSrcFile));

        if (pszDestFile)
            SHUnicodeToAnsi(pszDestFile, szDestFile, ARRAYSIZE(szDestFile));

        UINT retValue = pCDFViewCopyHookA->CopyCallback(
                hwnd, wFunc, wFlags, szSrcFile, 
                dwSrcAttribs, szDestFile, dwDestAttribs);

        pCDFViewCopyHookA->Release();

        return retValue;
    }
    else
    {
        // Couldn't create ChannelMgr object for some reason 
        TraceMsg(TF_ERROR, "Could not CoCreateInstance CLSID_ChannelMgr");
        return IDYES;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\wvtp.h ===
#ifdef __cplusplus

#include "capi.h"

// WinVerifyTrust delay load modelled on shell's urlmonp.h

#define DELAY_LOAD_WVT

class Cwvt
{
    public:
#ifdef DELAY_LOAD_WVT
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
        HRESULT hres = Init(); \
        if (SUCCEEDED(hres)) { \
            hres = _pfn##_fn _nargs; \
        } \
        return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT     Init(void);
    Cwvt();
    ~Cwvt();

    BOOL    m_fInited;
    HMODULE m_hMod;
#else
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
            HRESULT hr = ::#_fn _nargs; \
            }

#endif

    private:
    DELAYWVTAPI(WinVerifyTrust,
    (HWND hwnd, GUID * ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData));

    public:
    HRESULT VerifyTrust(HANDLE hFile, HWND hWnd, LPCWSTR szStatusText);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\cachesrch.cpp ===
/**********************************************************************
  Cache Search Stuff (simple strstr)

  Marc Miller (t-marcmi) - 1998
 **********************************************************************/
#include "cachesrch.h"

DWORD CacheSearchEngine::CacheStreamWrapper::s_dwPageSize = 0;

BOOL  CacheSearchEngine::CacheStreamWrapper::_ReadNextBlock() {
    if (_fEndOfFile)
        return FALSE;

    if (!s_dwPageSize) {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        s_dwPageSize = sysInfo.dwPageSize;
    }
    BOOL fNewRead = FALSE; // is this our first look at this file?
    if (!_pbBuff) {
        // Allocate a page of memory

        // Note: find out why this returned error code #87
        //_pbBuff  = (LPBYTE)(VirtualAlloc(NULL, s_dwPageSize, MEM_COMMIT, PAGE_READWRITE));
        _pbBuff = (LPBYTE)(LocalAlloc(LPTR, s_dwPageSize));
        if (!_pbBuff) {
            //DWORD dwError = GetLastError();
            return FALSE;
        }
        fNewRead          = TRUE;
        _dwCacheStreamLoc = 0;
    }

    BOOL  fSuccess;
    DWORD dwSizeRead = s_dwPageSize;
    if ((fSuccess = ReadUrlCacheEntryStream(_hCacheStream, _dwCacheStreamLoc,
                                            _pbBuff, &dwSizeRead, 0)) && dwSizeRead)
    {
        _fEndOfFile        = (dwSizeRead < s_dwPageSize);
        
        _dwCacheStreamLoc += dwSizeRead;
        _dwBuffSize        = dwSizeRead;
        _pbBuffPos         = _pbBuff;
        _pbBuffLast        = _pbBuff + dwSizeRead;

        _dataType = ASCII_DATA; // default
        if (fNewRead) {
            // deterine data type
            if (_dwBuffSize >= sizeof(USHORT)) {
                if      (*((USHORT *)_pbBuff) == UNICODE_SIGNATURE)
                    _dataType = UNICODE_DATA;
                else if (*((USHORT *)_pbBuff) == UNICODE_SIGNATURE_BACKWARDS)
                    _dataType = UNICODE_BACKWARDS_DATA;
                
                if (s_IsUnicode(_dataType))
                    _pbBuffPos += s_Charsize(_dataType);
            }
        }
    }
    else {
        fSuccess = FALSE;
        DWORD dwError = GetLastError();
        ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);
    }
    return fSuccess;
}

CacheSearchEngine::CacheStreamWrapper::CacheStreamWrapper(HANDLE hCacheStream) {
    // this class can be allocated on the stack:
    _pbBuff       = NULL;
    _pbBuffPos    = NULL;
    _pbBuffLast   = NULL;
    _dwBuffSize   = 0;
    _hCacheStream = hCacheStream;
    _fEndOfFile   = FALSE;

    // Read in preliminary block of data --
    //  Die on next read to handle failure
    _fEndOfFile   = !(_ReadNextBlock());
}

CacheSearchEngine::CacheStreamWrapper::~CacheStreamWrapper() {
    if (_pbBuff) {
        //VirtualFree(_pbBuff);
        LocalFree(_pbBuff);;
        _pbBuff = NULL;
    }
}

// Read next byte from cache stream, reading in next block if necessary
BOOL CacheSearchEngine::CacheStreamWrapper::_GetNextByte(BYTE &b)
{
    //
    // If the initial read fails _pbBuffPos will be NULL.  Don't
    // allow it to be dereffed.
    //
    BOOL fSuccess = _pbBuffPos ? TRUE : FALSE;

    if (_pbBuffPos == _pbBuffLast)
        fSuccess = _ReadNextBlock();

    if (fSuccess)
        b = *(_pbBuffPos++);

    return fSuccess;
}

BOOL CacheSearchEngine::CacheStreamWrapper::GetNextChar(WCHAR &wc) {
    BOOL fSuccess = TRUE;
    if (s_IsUnicode(_dataType)) {
        BYTE b1, b2;
        LPBYTE bs = (LPBYTE)&wc;
        if (_GetNextByte(b1) && _GetNextByte(b2)) {
            switch (_dataType) {
            case UNICODE_DATA:
                bs[0] = b1;
                bs[1] = b2;
                break;
            case UNICODE_BACKWARDS_DATA:
                bs[0] = b2;
                bs[1] = b1;
                break;
            default: ASSERT(0);
            }
        }
        else
            fSuccess = FALSE;
    }
    else 
    {
       
        BYTE szData[2];

        if (_GetNextByte(szData[0]))
        {
            int cch = 1;
            if (IsDBCSLeadByte(szData[0]))
            {
                if (!_GetNextByte(szData[1]))
                {
                    fSuccess = FALSE;
                }
                cch++;
            }

            if (fSuccess)
            {
                fSuccess = (MultiByteToWideChar(CP_ACP, 0, (LPSTR)szData, cch, &wc, 1) > 0);
            }
        }
        else
        {
            fSuccess = FALSE;
        }

    }
    return fSuccess;
}


// Prepare a search target string for searching --
void CacheSearchEngine::StreamSearcher::_PrepareSearchTarget(LPCWSTR pwszSearchTarget)
{
    UINT uStrLen = lstrlenW(pwszSearchTarget);
    _pwszPreparedSearchTarget = ((LPWSTR)LocalAlloc(LPTR, (uStrLen + 1) * sizeof(WCHAR)));

    if (_pwszPreparedSearchTarget) {
        // Strip leading and trailing whitespace and compress adjacent whitespace characters
        //  into literal spaces
        LPWSTR pwszTemp  = _pwszPreparedSearchTarget;
        pwszSearchTarget = s_SkipWhiteSpace(pwszSearchTarget);
        BOOL   fAddWs    = FALSE;
        while(*pwszSearchTarget) {
            if (s_IsWhiteSpace(*pwszSearchTarget)) {
                fAddWs = TRUE;
                pwszSearchTarget = s_SkipWhiteSpace(pwszSearchTarget);
            }
            else {
                if (fAddWs) {
                    *(pwszTemp++) = L' ';
                    fAddWs = FALSE;
                }
                *(pwszTemp++) = *(pwszSearchTarget++);
            }
        }
        *pwszTemp = L'\0';
    }
}

// Search a character stream for a searchtarget
//  Does a simple strstr, but tries to be smart about whitespace and
//  ignores HTML where possible...
BOOL CacheSearchEngine::StreamSearcher::SearchCharStream(CacheSearchEngine::IWideSequentialReadStream &wsrs,
                                                         BOOL fIsHTML/* = FALSE*/)
{
    BOOL fFound = FALSE;
    
    if (_pwszPreparedSearchTarget && *_pwszPreparedSearchTarget)
    {
        WCHAR   wc;
        LPCWSTR pwszCurrent    = _pwszPreparedSearchTarget;
        BOOL    fMatchedWS     = FALSE;
        
        while(*pwszCurrent && wsrs.GetNextChar(wc)) {

            if (s_IsWhiteSpace(wc)) {
                // matched whitespace in search stream, look for
                //  matching whitespace in target string
                if (!fMatchedWS) {
                    if (s_IsWhiteSpace(*pwszCurrent)) {
                        fMatchedWS = TRUE;
                        ++pwszCurrent;
                    }
                    else
                        pwszCurrent = _pwszPreparedSearchTarget;
                }
            }
            else {
                fMatchedWS = FALSE;
                if (!ChrCmpIW(*pwszCurrent, wc)) {
                    ++pwszCurrent;
                }
                else {
                    pwszCurrent = _pwszPreparedSearchTarget;
                }
            }
        }
        fFound = !*pwszCurrent;
    }
    return fFound;
}

BOOL CacheSearchEngine::SearchCacheStream(CacheSearchEngine::StreamSearcher &cse, HANDLE hCacheStream,
                                          BOOL fIsHTML/* = FALSE*/)
{
    CacheStreamWrapper csw(hCacheStream);
    return cse.SearchCharStream(csw, fIsHTML);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\cachesrch.h ===
/**********************************************************************
  Cache Search Stuff (simple, fast strstr)

  Marc Miller (t-marcmi) - 1998
 **********************************************************************/

#include "priv.h"

#ifndef __HISTORY_CACHE_SEARCH__
#define __HISTORY_CACHE_SEARCH__

#define UNICODE_SIGNATURE           0xFFFE
#define UNICODE_SIGNATURE_BACKWARDS 0xFEFF

namespace CacheSearchEngine {

    class IWideSequentialReadStream {
    public:
        virtual BOOL GetNextChar(WCHAR &wc) = 0;
    };
    
    class StreamSearcher {
    protected:
        LPWSTR _pwszPreparedSearchTarget;
        static inline    BOOL s_IsWhiteSpace(const WCHAR &wc) {
            return ((wc == L' ') || (wc == L'\t') || (wc == L'\n') || (wc == L'\r'));
        }
        static inline LPCWSTR s_SkipWhiteSpace(LPCWSTR pwszStr) {
            LPCWSTR pwszTemp = pwszStr;
            while(s_IsWhiteSpace(*pwszTemp))
                ++pwszTemp;
            return pwszTemp;
        }
        void _PrepareSearchTarget(LPCWSTR pwszSearchTarget);
    public:
        StreamSearcher(LPCWSTR pwszSearchTarget) { _PrepareSearchTarget(pwszSearchTarget); }
        ~StreamSearcher() { if ( _pwszPreparedSearchTarget ) { LocalFree(_pwszPreparedSearchTarget); _pwszPreparedSearchTarget = NULL; } }
        BOOL SearchCharStream(IWideSequentialReadStream &wsrs, BOOL fIsHTML = FALSE);
    };
    
    class StringStream : public IWideSequentialReadStream {
        BOOL    fCleanup; // the string we hold needs to be deallocated by us
        LPCWSTR pwszStr;
        UINT    uCurrentPos;
    public:
        StringStream(LPCWSTR pwszStr, BOOL fDuplicate = FALSE) : uCurrentPos(0), fCleanup(fDuplicate) {
            if (fDuplicate)
                SHStrDupW(pwszStr, const_cast<LPWSTR *>(&(this->pwszStr)));
            else
                this->pwszStr = pwszStr;
        }
        StringStream(LPCSTR  pszStr, BOOL fDuplicate = FALSE)  : uCurrentPos(0), fCleanup(TRUE) {
            SHStrDupA(pszStr, const_cast<LPWSTR *>(&(pwszStr)));
        }
        ~StringStream() {
            if (fCleanup)
                CoTaskMemFree(const_cast<LPWSTR>(pwszStr));
        }
        BOOL GetNextChar(WCHAR &wc) {
            wc = pwszStr[uCurrentPos];
            if (wc)
                ++uCurrentPos;
            return wc;
        }
    };
    
    class CacheStreamWrapper : public IWideSequentialReadStream {
    protected:
        HANDLE  _hCacheStream;
        DWORD   _dwCacheStreamLoc;  // our offset into the actual cache file
        BOOL    _fEndOfFile;
        
        // I can never remember which one is little endian and which is big endian
        enum DATATYPEENUM { UNICODE_DATA = 0, UNICODE_BACKWARDS_DATA, ASCII_DATA } _dataType;
        static inline BOOL s_IsUnicode(DATATYPEENUM dte) { return dte < ASCII_DATA; }
        static inline UINT s_Charsize (DATATYPEENUM dte) { return s_IsUnicode(dte) ? sizeof(USHORT) : sizeof(CHAR); }
        
        static DWORD s_dwPageSize;
        
        LPBYTE _pbBuff;      /* buffer of bytes which are type-neutral
                                _pbBuff is allocated with VirtualAlloc */
        LPBYTE _pbBuffPos;   // current position in buffer
        LPBYTE _pbBuffLast;  // last byte in buffer
        DWORD  _dwBuffSize;  // current valid buffer size (not allocated size)
        
        BOOL   _ReadNextBlock();
        BOOL   _GetNextByte(BYTE &b);
        
    public:
        CacheStreamWrapper(HANDLE hCacheStream);
        ~CacheStreamWrapper();
        BOOL GetNextChar(WCHAR &wc);
    };

    
    BOOL SearchCacheStream(StreamSearcher &cse, HANDLE hCacheStream, BOOL fIsHTML = FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\cafolder.cpp ===
#include "local.h"

#include "resource.h"
#include "cachesrch.h"
#include "sfview.h"
#include <shlwapi.h>
#include <limits.h>
#include "chcommon.h"
#include "cafolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

// these are common flags to ShChangeNotify
#ifndef UNIX
#define CHANGE_FLAGS (0)
#else
#define CHANGE_FLAGS SHCNF_FLUSH
#endif

static void _GetFileTypeInternal(LPCEIPIDL pidl, LPUTSTR pszStr, UINT cchStr);

//
// Column definition for the Cache Folder DefView
//
enum {
    ICOLC_URL_SHORTNAME = 0,
    ICOLC_URL_NAME,
    ICOLC_URL_TYPE,
    ICOLC_URL_SIZE,
    ICOLC_URL_EXPIRES,
    ICOLC_URL_MODIFIED,
    ICOLC_URL_ACCESSED,
    ICOLC_URL_LASTSYNCED,
    ICOLC_URL_MAX         // Make sure this is the last enum item
};


typedef struct _COLSPEC
{
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} COLSPEC;

const COLSPEC s_CacheFolder_cols[] = {
    {ICOLC_URL_SHORTNAME,  IDS_SHORTNAME_COL,  18, LVCFMT_LEFT},
    {ICOLC_URL_NAME,       IDS_NAME_COL,       30, LVCFMT_LEFT},
    {ICOLC_URL_TYPE,       IDS_TYPE_COL,       15, LVCFMT_LEFT},
    {ICOLC_URL_SIZE,       IDS_SIZE_COL,        8, LVCFMT_RIGHT},
    {ICOLC_URL_EXPIRES,    IDS_EXPIRES_COL,    18, LVCFMT_LEFT},
    {ICOLC_URL_MODIFIED,   IDS_MODIFIED_COL,   18, LVCFMT_LEFT},
    {ICOLC_URL_ACCESSED,   IDS_ACCESSED_COL,   18, LVCFMT_LEFT},
    {ICOLC_URL_LASTSYNCED, IDS_LASTSYNCED_COL, 18, LVCFMT_LEFT}
};

//////////////////////////////////////////////////////////////////////

LPCEIPIDL _CreateBuffCacheFolderPidl(DWORD cbSize, LPINTERNET_CACHE_ENTRY_INFO pcei)
{

    DWORD cbTotalSize = sizeof(CEIPIDL) + cbSize - sizeof(INTERNET_CACHE_ENTRY_INFO);

    LPCEIPIDL pceip = (LPCEIPIDL)OleAlloc(cbTotalSize);
    if (pceip)
    {
        ZeroMemory(pceip, cbTotalSize);
        pceip->cb = (USHORT)(cbTotalSize - sizeof(USHORT));
        pceip->usSign = CEIPIDL_SIGN;
        _CopyCEI(&pceip->cei, pcei, cbSize);
    }
    return pceip;
}

HRESULT CacheFolderView_MergeMenu(UINT idMenu, LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(idMenu));
    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return S_OK;
}

HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect)
{
    if (dwEffect & DROPEFFECT_MOVE)
    {
        CCacheItem *pCItem;
        BOOL fBulkDelete;

        if (SUCCEEDED(pdo->QueryInterface(IID_ICache, (void **)&pCItem)))
        {
            fBulkDelete = pCItem->_cItems > LOTS_OF_FILES;
            for (UINT i = 0; i < pCItem->_cItems; i++)
            {
                if (DeleteUrlCacheEntry(CPidlToSourceUrl((LPCEIPIDL)pCItem->_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, pCItem->_pCFolder->_pidl, pCItem->_ppidl[i], NULL);
                    }
                }
            }
            if (fBulkDelete)
            {
                _GenerateEvent(SHCNE_UPDATEDIR, pCItem->_pCFolder->_pidl, NULL, NULL);
            }
            SHChangeNotifyHandleEvents();
            pCItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

// There are copies of exactly this function in SHELL32
// Add the File Type page
HRESULT CacheFolderView_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA * ppagedata)
{
    IShellPropSheetExt * pspse;
    HRESULT hr = CoCreateInstance(CLSID_FileTypes, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellPropSheetExt, &pspse));
    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
        pspse->Release();
    }
    return hr;
}

HRESULT CacheFolderView_OnGetSortDefaults(int * piDirection, int * plParamSort)
{
    *plParamSort = (int)ICOLC_URL_ACCESSED;
    if (piDirection)
        *piDirection = 1;
    return S_OK;
}

HRESULT CALLBACK CCacheFolder::_sViewCallback(IShellView *psv, IShellFolder *psf,
     HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCacheFolder *pfolder = NULL;

    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    {
        TCHAR szText[MAX_PATH];

        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        LPTSTR pszBuf = (LPTSTR)lParam;

        MLLoadString(id + IDS_MH_FIRST, szText, ARRAYSIZE(szText));

        // we know for a fact that this parameter is really a TCHAR
        if ( IsOS( OS_NT ))
        {
            SHTCharToUnicode( szText, (LPWSTR) pszBuf, cchBuf );
        }
        else
        {
            SHTCharToAnsi( szText, (LPSTR) pszBuf, cchBuf );
        }
        break;
    }

    case SFVM_GETNOTIFY:
        hr = psf->QueryInterface(CLSID_CacheFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            *(LPCITEMIDLIST*)wParam = pfolder->_pidl;   // evil alias
            pfolder->Release();
        }
        else
            wParam = 0;
        *(LONG*)lParam = SHCNE_DELETE | SHCNE_UPDATEDIR;
        break;

    case DVM_DIDDRAGDROP:
        hr = CacheFolderView_DidDragDrop((IDataObject *)lParam, (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hr = S_OK;
        break;

    case DVM_INVOKECOMMAND:
        _ArrangeFolder(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        ShellFolderView_ReArrange(hwnd, (UINT)wParam);
        hr = S_OK;
        break;

    case DVM_MERGEMENU:
        hr = CacheFolderView_MergeMenu(MENU_CACHE, (LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = CacheFolderView_OnAddPropertyPages((DWORD)wParam, (SFVM_PROPPAGE_DATA *)lParam);
        break;

    case SFVM_GETSORTDEFAULTS:
        hr = CacheFolderView_OnGetSortDefaults((int *)wParam, (int *)lParam);
        break;

    case SFVM_UPDATESTATUSBAR:
        ResizeStatusBar(hwnd, FALSE);
        // We did not set any text; let defview do it
        hr = E_NOTIMPL;
        break;

    case SFVM_SIZE:
        ResizeStatusBar(hwnd, FALSE);
        break;

    case SFVM_GETPANE:
        if (wParam == PANE_ZONE)
            *(DWORD*)lParam = 1;
        else
            *(DWORD*)lParam = PANE_NONE;

        break;
    case SFVM_WINDOWCREATED:
        ResizeStatusBar(hwnd, TRUE);
        break;

    case SFVM_GETZONE:
        *(DWORD*)lParam = URLZONE_INTERNET; // Internet by default
        break;

    default:
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CacheFolderView_CreateInstance(CCacheFolder *pHCFolder, void **ppv)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pHCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pHCFolder->_pidl;
    csfv.lEvents = SHCNE_DELETE; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = CCacheFolder::_sViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppv);
}

CCacheFolderEnum::CCacheFolderEnum(DWORD grfFlags, CCacheFolder *pHCFolder) : _cRef(1)
{
    DllAddRef();

    _grfFlags = grfFlags,
    _pCFolder = pHCFolder;
    pHCFolder->AddRef();
    ASSERT(_hEnum == NULL);
}

CCacheFolderEnum::~CCacheFolderEnum()
{
    ASSERT(_cRef == 0);         // we should always have a zero ref count here
    TraceMsg(DM_HSFOLDER, "hcfe - ~CCacheFolderEnum() called.");
    _pCFolder->Release();
    if (_pceiWorking)
    {
        LocalFree(_pceiWorking);
        _pceiWorking = NULL;
    }

    if (_hEnum)
    {
        FindCloseUrlCache(_hEnum);
        _hEnum = NULL;
    }
    DllRelease();
}


HRESULT CCacheFolderEnum_CreateInstance(DWORD grfFlags, CCacheFolder *pHCFolder, IEnumIDList **ppeidl)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CreateInstance() called.");

    *ppeidl = NULL;                 // null the out param

    CCacheFolderEnum *pHCFE = new CCacheFolderEnum(grfFlags, pHCFolder);
    if (!pHCFE)
        return E_OUTOFMEMORY;

    *ppeidl = pHCFE;

    return S_OK;
}

HRESULT CCacheFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CCacheFolderEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CCacheFolderEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCacheFolderEnum::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//
// IEnumIDList Methods
//
HRESULT CCacheFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr             = S_FALSE;
    DWORD   dwBuffSize;
    DWORD   dwError;
    LPTSTR  pszSearchPattern = NULL;

    TraceMsg(DM_HSFOLDER, "hcfe - Next() called.");

    if (0 == (SHCONTF_NONFOLDERS & _grfFlags))
    {
        dwError = 0xFFFFFFFF;
        goto exitPoint;
    }

    if (_pceiWorking == NULL)
    {
        _pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
        if (_pceiWorking == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    // Set up things to enumerate history items, if appropriate, otherwise,
    // we'll just pass in NULL and enumerate all items as before.

TryAgain:

    dwBuffSize = MAX_URLCACHE_ENTRY;
    dwError = S_OK;

    if (!_hEnum) // _hEnum maintains our state as we iterate over all the cache entries
    {
       _hEnum = FindFirstUrlCacheEntry(pszSearchPattern, _pceiWorking, &dwBuffSize);
       if (!_hEnum)
           dwError = GetLastError();
    }

    else if (!FindNextUrlCacheEntry(_hEnum, _pceiWorking, &dwBuffSize))
    {
        dwError = GetLastError();
    }

    if (S_OK == dwError)
    {
        LPCEIPIDL pcei = NULL;

        if ((_pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY)
            goto TryAgain;
        pcei = _CreateBuffCacheFolderPidl(dwBuffSize, _pceiWorking);
        if (pcei)
        {
            _GetFileTypeInternal(pcei, pcei->szTypeName, ARRAYSIZE(pcei->szTypeName));
            rgelt[0] = (LPITEMIDLIST)pcei;
           if (pceltFetched)
               *pceltFetched = 1;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

exitPoint:

    if (dwError != S_OK)
    {
        if (_hEnum)
        {
            FindCloseUrlCache(_hEnum);
            _hEnum = NULL;
        }
        if (pceltFetched)
            *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCacheFolderEnum::Skip(ULONG celt)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Skip() called.");
    return E_NOTIMPL;
}

HRESULT CCacheFolderEnum::Reset()
{
    TraceMsg(DM_HSFOLDER, "hcfe - Reset() called.");
    return E_NOTIMPL;
}

HRESULT CCacheFolderEnum::Clone(IEnumIDList **ppenum)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Clone() called.");
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCacheFolder Object
//
//////////////////////////////////////////////////////////////////////////////

CCacheFolder::CCacheFolder() : _cRef(1)
{
    ASSERT(_pidl == NULL);
    DllAddRef();
}

CCacheFolder::~CCacheFolder()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_HSFOLDER, "hcf - ~CCacheFolder() called.");
    if (_pidl)
        ILFree(_pidl);
    if (_pshfSys)
        _pshfSys->Release();
    DllRelease();
}

HRESULT CCacheFolder::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qitCache[] = {
        QITABENT(CCacheFolder, IShellFolder2),
        QITABENTMULTI(CCacheFolder, IShellFolder, IShellFolder2),
        QITABENT(CCacheFolder, IShellIcon),
        QITABENT(CCacheFolder, IPersistFolder2),
        QITABENTMULTI(CCacheFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CCacheFolder, IPersist, IPersistFolder2),
        { 0 },
    };

    if (iid == CLSID_CacheFolder)
    {
        *ppv = (void *)(CCacheFolder *)this;    // unrefed
        AddRef();
        return S_OK;
    }

    HRESULT hr = QISearch(this, qitCache, iid, ppv);

    if (FAILED(hr) && !IsOS(OS_WHISTLERORGREATER))
    {
        if (iid == IID_IShellView)
        {
            // this is a total hack... return our view object from this folder
            //
            // the desktop.ini file for "Temporary Internet Files" has UICLSID={guid of this object}
            // this lets us implment only ths IShellView for this folder, leaving the IShellFolder
            // to the default file system. this enables operations on the pidls that are stored in
            // this folder that would otherwise faile since our IShellFolder is not as complete
            // as the default (this is the same thing the font folder does).
            //
            // to support this with defview we would either have to do a complete wrapper object
            // for the view implemenation, or add this hack that hands out the view object, this
            // assumes we know the order of calls that the shell makes to create this object
            // and get the IShellView implementation
            //
            hr = CacheFolderView_CreateInstance(this, ppv);
        }
    }

    return hr;
}

STDMETHODIMP CCacheFolder::_GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr)
{
    switch (iColumn) {
    case ICOLC_URL_SHORTNAME:
        _GetCacheItemTitle((LPCEIPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLC_URL_NAME:
        StrCpyN(pszStr, CPidlToSourceUrl((LPCEIPIDL)pidl), cchStr);
        break;

    case ICOLC_URL_TYPE:
        ualstrcpyn(pszStr, ((LPCEIPIDL)pidl)->szTypeName, cchStr);
        break;

    case ICOLC_URL_SIZE:
        StrFormatKBSize(((LPCEIPIDL)pidl)->cei.dwSizeLow, pszStr, cchStr);
        break;

    case ICOLC_URL_EXPIRES:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.ExpireTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_ACCESSED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastAccessTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_MODIFIED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastModifiedTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_LASTSYNCED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastSyncTime, pszStr, cchStr, FALSE);
        break;
    }
    return S_OK;
}

HRESULT CCacheFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr = E_FAIL;

    if (pidl == NULL)
    {
        if (iColumn < ICOLC_URL_MAX)
        {
            TCHAR szTemp[128];

            MLLoadString(s_CacheFolder_cols[iColumn].ids, szTemp, ARRAYSIZE(szTemp));
            pdi->fmt = s_CacheFolder_cols[iColumn].iFmt;
            pdi->cxChar = s_CacheFolder_cols[iColumn].cchCol;
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            // enum done
            hr = E_FAIL;
        }
    }
    else if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            // delegate to the filesystem
            hr = _pshfSys->GetDetailsOf(pidl, iColumn, pdi);
        }
    }
    else
    {
        TCHAR szTemp[MAX_URL_STRING];

        hr = _GetDetail(pidl, iColumn, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
        {
            hr = StringToStrRet(szTemp, &pdi->str);
        }
    }
    return hr;
}

HRESULT CCacheFolder::_GetFileSysFolder(IShellFolder2 **ppsf)
{
    *ppsf = NULL;
    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_ShellFSFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Initialize(this->_pidl);
        if (SUCCEEDED(hr))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
        }
        ppf->Release();
    }
    return hr;
}

// IShellFolder
HRESULT CCacheFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            hr = _pshfSys->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        hr = E_NOTIMPL;
        *ppv = NULL;
    }
    return hr;
}

HRESULT CCacheFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
                                       ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_FAIL;
    if (_pshfSys)
    {
        hr = _pshfSys->ParseDisplayName(hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
    }
    else
        *ppidl = NULL;
    return hr;
}

// IPersist
HRESULT CCacheFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_CacheFolder;
    return S_OK;
}

STDAPI CacheFolder_CreateInstance(IUnknown* punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CCacheFolder *pcache = new CCacheFolder();
    if (pcache)
    {
        *ppunk = SAFECAST(pcache, IShellFolder2*);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

ULONG CCacheFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCacheFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellFolder

HRESULT CCacheFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    return CCacheFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}

HRESULT CCacheFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

// unalligned verison

#if defined(UNIX) || !defined(_X86_)

// defined in hsfolder.cpp
extern UINT ULCompareFileTime(UNALIGNED const FILETIME *pft1, UNALIGNED const FILETIME *pft2);

#else

#define ULCompareFileTime(pft1, pft2) CompareFileTime(pft1, pft2)

#endif


HRESULT CCacheFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL fRealigned1;
    HRESULT hr = AlignPidl(&pidl1, &fRealigned1);
    if (SUCCEEDED(hr))
    {
        BOOL fRealigned2;
        hr = AlignPidl(&pidl2, &fRealigned2);

        if (SUCCEEDED(hr))
        {
            hr = _CompareAlignedIDs(lParam, (LPCEIPIDL)pidl1, (LPCEIPIDL)pidl2);

            if (fRealigned2)
                FreeRealignedPidl(pidl2);
        }

        if (fRealigned1)
            FreeRealignedPidl(pidl1);
    }

    return hr;
}

int _CompareSize(LPCEIPIDL pcei1, LPCEIPIDL pcei2)
{
    // check only the low for now
    if (pcei1->cei.dwSizeLow == pcei2->cei.dwSizeLow) 
    {
        return 0;
    } 
    else  if (pcei1->cei.dwSizeLow > pcei2->cei.dwSizeLow) 
    {
        return 1;
    }   
    return -1;
}

HRESULT CCacheFolder::_CompareAlignedIDs(LPARAM lParam, LPCEIPIDL pidl1, LPCEIPIDL pidl2)
{
    int iRet = 0;

    if (NULL == pidl1 || NULL == pidl2)
        return E_INVALIDARG;

    //  At this point, both pidls have resolved to leaf (history or cache)

    if (!IS_VALID_CEIPIDL(pidl1) || !IS_VALID_CEIPIDL(pidl2))
        return E_FAIL;

    switch (lParam & SHCIDS_COLUMNMASK) {
    case ICOLC_URL_SHORTNAME:
        iRet = StrCmpI(_FindURLFileName(CPidlToSourceUrl(pidl1)),
                        _FindURLFileName(CPidlToSourceUrl(pidl2)));
        break;

    case ICOLC_URL_NAME:
        iRet = _CompareCFolderPidl(pidl1, pidl2);
        break;

    case ICOLC_URL_TYPE:
        iRet = ualstrcmp(pidl1->szTypeName, pidl2->szTypeName);
        break;

    case ICOLC_URL_SIZE:
        iRet = _CompareSize(pidl1, pidl2);
        break;

    case ICOLC_URL_MODIFIED:
        iRet = ULCompareFileTime(&pidl1->cei.LastModifiedTime,
                               &pidl2->cei.LastModifiedTime);
        break;

    case ICOLC_URL_ACCESSED:
        iRet = ULCompareFileTime(&pidl1->cei.LastAccessTime,
                               &pidl2->cei.LastAccessTime);
        break;

    case ICOLC_URL_EXPIRES:
        iRet = ULCompareFileTime(&pidl1->cei.ExpireTime,
                               &pidl2->cei.ExpireTime);
        break;

    case ICOLC_URL_LASTSYNCED:
        iRet = ULCompareFileTime(&pidl1->cei.LastSyncTime,
                               &pidl2->cei.LastSyncTime);
        break;

    default:
        iRet = -1;
    }
    return ResultFromShort((SHORT)iRet);
}


HRESULT CCacheFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IShellView)
    {
        hr = CacheFolderView_CreateInstance(this, ppv);
    }
    else if (riid == IID_IContextMenu)
    {
        // this creates the "Arrange Icons" cascased menu in the background of folder view
        CFolderArrangeMenu *p = new CFolderArrangeMenu(MENU_CACHE);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (riid == IID_IShellDetails)
    {
        CDetailsOfFolder *p = new CDetailsOfFolder(hwnd, this);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Right now, we will allow TIF Drag in Browser Only, even though
// it will not be Zone Checked at the Drop.
//#define BROWSERONLY_NOTIFDRAG

HRESULT CCacheFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                        ULONG * prgfInOut)
{
    ULONG rgfInOut;
    HRESULT hr = E_UNEXPECTED;

    // Make sure each pidl in the array is dword aligned.
    if (apidl && IS_VALID_CEIPIDL(apidl[0]))
    {
        BOOL fRealigned;
        hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            rgfInOut = SFGAO_FILESYSTEM | SFGAO_CANDELETE | SFGAO_HASPROPSHEET;

#ifdef BROWSERONLY_NOTIFDRAG
            if (PLATFORM_INTEGRATED == WhichPlatform())
#endif // BROWSERONLY_NOTIFDRAG
            {
                SetFlag(rgfInOut, SFGAO_CANCOPY);
            }

            // all items can be deleted
            if (SUCCEEDED(hr))
                rgfInOut |= SFGAO_CANDELETE;
            *prgfInOut = rgfInOut;

            if (fRealigned)
                FreeRealignedPidlArray(apidl, cidl);
        }
    }
    else if (_pshfSys)
    {
        hr = _pshfSys->GetAttributesOf(cidl, apidl, prgfInOut);
    }

    if (FAILED(hr))
        *prgfInOut = 0;

    return hr;
}

HRESULT CCacheFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;         // null the out param

    // Make sure all pidls in the array are dword aligned.

    if (apidl && IS_VALID_CEIPIDL(apidl[0]))
    {
        BOOL fRealigned;
        hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            if ((riid == IID_IShellLinkA)   ||
                (riid == IID_IShellLinkW)   ||
                (riid == IID_IExtractIconA) ||
                (riid == IID_IExtractIconW) ||
                (riid == IID_IQueryInfo))
            {
                LPCTSTR pszURL = CPidlToSourceUrl((LPCEIPIDL)apidl[0]);

                hr = _GetShortcut(pszURL, riid, ppv);
            }
            else if ((riid == IID_IContextMenu)     ||
                     (riid == IID_IDataObject)      ||
                     (riid == IID_IExtractIconA)    ||
                     (riid == IID_IExtractIconW))
            {
                hr = CCacheItem_CreateInstance(this, hwnd, cidl, apidl, riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }

            if (fRealigned)
                FreeRealignedPidlArray(apidl, cidl);
        }
    }
    else if (_pshfSys)
    {
        // delegate to the filesystem
        hr = _pshfSys->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }

    return hr;
}

HRESULT CCacheFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (pSort)
    {
        *pSort = 0;
    }

    if (pDisplay)
    {
        *pDisplay = 0;
    }
    return S_OK;
}

HRESULT CCacheFolder::_GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip)
{
    *ppwszTip = NULL;
    return E_FAIL;
}

HRESULT CCacheFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    BOOL fRealigned;
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            // delegate to the filesystem
            hr = _pshfSys->GetDisplayNameOf(pidl, uFlags, pstr);
        }
    }
    else if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        hr = GetDisplayNameOfCEI(pidl, uFlags, pstr);
    
        if (fRealigned)
            FreeRealignedPidl(pidl);
    }
    return hr;
}

HRESULT CCacheFolder::GetDisplayNameOfCEI(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    TCHAR szTemp[MAX_URL_STRING];
    szTemp[0] = 0;

    LPCTSTR pszTitle = _FindURLFileName(CEI_SOURCEURLNAME((LPCEIPIDL)pidl));

    // _GetURLTitle could return the real title or just an URL.
    // We use _URLTitleIsURL to make sure we don't unescape any titles.

    if (pszTitle && *pszTitle)
    {
        StrCpyN(szTemp, pszTitle, ARRAYSIZE(szTemp));
    }
    else
    {
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(CPidlToSourceUrl((LPCEIPIDL)pidl));
        if (pszUrl) 
            StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
    }
    
    if (!(uFlags & SHGDN_FORPARSING))
    {
        DWORD cchBuf = ARRAYSIZE(szTemp);
        PrepareURLForDisplayUTF8(szTemp, szTemp, &cchBuf, TRUE);
    
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
    
        if (!ss.fShowExtensions)
            PathRemoveExtension(szTemp);
    }

    return StringToStrRet(szTemp, pstr);
}

HRESULT CCacheFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                        LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;               // null the out param
    return E_FAIL;
}

//
// IShellIcon Methods...
//
HRESULT CCacheFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex)
{
    BOOL fRealigned;
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            IShellIcon* pshi;
            hr = _pshfSys->QueryInterface(IID_PPV_ARG(IShellIcon, &pshi));
            if (SUCCEEDED(hr))
            {
                hr = pshi->GetIconOf(pidl, flags, lpIconIndex);
                pshi->Release();
            }
        }
    }
    else if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        SHFILEINFO shfi;
        LPCTSTR pszIconFile = CEI_LOCALFILENAME((LPCEIPIDL)pidl);

        if (SHGetFileInfo(pszIconFile, 0, &shfi, sizeof(shfi),
                          SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_SMALLICON))
        {
            *lpIconIndex = shfi.iIcon;
            hr = S_OK;
        }

        if (fRealigned)
            FreeRealignedPidl(pidl);
    }
    return hr;
}


// IPersist

HRESULT CCacheFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    ILFree(_pidl);
    if (_pshfSys)
    {
        _pshfSys->Release();
        _pshfSys = NULL;
    }

    HRESULT hr;
    if (IsCSIDLFolder(CSIDL_INTERNET_CACHE, pidlInit))
    {
        hr = SHILClone(pidlInit, &_pidl);
        if (SUCCEEDED(hr))
        {
            hr = _GetFileSysFolder(&_pshfSys);

            // On a pre-Win2k shell, CLSID_ShellFSFolder will not be registered.  However, it does not 
            // impact the operation of the cache folder.  So rather than propogate a failure return value to 
            // the shell, we treat that case as success.
            if (FAILED(hr))
            {
                // This is a pre-Win2k shell.  Return S_OK.
                hr = S_OK;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//
// IPersistFolder2 Methods...
//
HRESULT CCacheFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

void _GetFileTypeInternal(LPCEIPIDL pidl, LPUTSTR pszuStr, UINT cchStr)
{
    SHFILEINFO shInfo;
    LPTSTR pszStr = NULL;

    if (TSTR_ALIGNED(pszuStr) == FALSE) 
    {
        //
        // If pszuStr is in fact unaligned, allocate some scratch
        // space on the heap for the output copy of this string.
        //

        pszStr = (LPTSTR)LocalAlloc(LPTR, cchStr * sizeof(TCHAR));
    }
    else 
    {
        pszStr = (LPTSTR)pszuStr;
    }

    if (pszStr)
    {
        if (SHGetFileInfo(CEI_LOCALFILENAME((LPCEIPIDL)pidl), FILE_ATTRIBUTE_NORMAL,
                        &shInfo, sizeof(shInfo),
                        SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME)
            && shInfo.szTypeName[0])
        {
            StrCpyN(pszStr, shInfo.szTypeName, cchStr);
        }
        else 
        {
            LPTSTR psz = PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)pidl));
            DWORD dw;
            ASSERT((pszStr && (cchStr>0)));
            *pszStr = 0;
            if (psz && *psz)
            {
                psz++;
                StrCpyN(pszStr, psz, cchStr);
                CharUpper(pszStr);
                StrCatBuff(pszStr, TEXT(" "), cchStr);
            }
            dw = lstrlen(pszStr);
            MLLoadString(IDS_FILE_TYPE, pszStr+dw, cchStr-dw);
        }

        if (TSTR_ALIGNED(pszuStr) == FALSE) 
        {
            // If pszuStr was unaligned then copy the output string from
            // the scratch space on the heap to the supplied output buffer

            ualstrcpyn(pszuStr, pszStr, cchStr);
            LocalFree(pszStr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\chcommon.cpp ===
#include "local.h"
#include "resource.h"
#include <limits.h>
#include <mluisupp.h>
#include "chcommon.h"

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

/*********************************************************************
                        StrHash implementation
 *********************************************************************/

//////////////////////////////////////////////////////////////////////
// StrHashNode
StrHash::StrHashNode::StrHashNode(LPCTSTR psz, void* pv, int fCopy,
                                  StrHashNode* next) {
    ASSERT(psz);
    pszKey = (fCopy ? StrDup(psz) : psz);
    pvVal  = pv;  // don't know the size -- you'll have to destroy
    this->fCopy = fCopy;
    this->next  = next;
}

StrHash::StrHashNode::~StrHashNode() {
    if (fCopy)
    {
        LocalFree(const_cast<LPTSTR>(pszKey));
        pszKey = NULL;
    }
}

//////////////////////////////////////////////////////////////////////
// StrHash
const unsigned int StrHash::sc_auPrimes[] = {
    29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593
};

const unsigned int StrHash::c_uNumPrimes     = 11;
const unsigned int StrHash::c_uFirstPrime    =  4;

// load factor is computed as (n * USHRT_MAX / t) where 'n' is #elts in table
//   and 't' is table size
const unsigned int StrHash::c_uMaxLoadFactor = ((USHRT_MAX * 100) / 95); // .95

StrHash::StrHash(int fCaseInsensitive) {
    nCurPrime = c_uFirstPrime;
    nBuckets  = sc_auPrimes[nCurPrime];

    // create an array of buckets and null out each one
    ppshnHashChain = new StrHashNode* [nBuckets];

    if (ppshnHashChain) {
        for (unsigned int i = 0; i < nBuckets; ++i)
            ppshnHashChain[i] = NULL;
    }
    nElements = 0;
    _fCaseInsensitive = fCaseInsensitive;
}

StrHash::~StrHash() {
    if (ppshnHashChain) {
        // delete all nodes first, then delete the chain
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                delete pshnTemp;
                pshnTemp = pshnNext;
            }
        }
        delete [] ppshnHashChain;
    }
}

#ifdef DEBUG
// Needed so that this stuff doesn't show 
// up as a leak when it is freed from someother thread
void
StrHash::_RemoveHashNodesFromMemList() {
    if (ppshnHashChain) {
        // remove all hasnodes from mem list first, then delete the chain
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                pshnTemp = pshnNext;
            }
        }
    }
}

// Needed by the thread to which this object was
// sent to add it on to the mem list to detect leaks

void
StrHash::_AddHashNodesFromMemList() {
    if (ppshnHashChain) {
        // add all nodes into mem list
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                pshnTemp = pshnNext;
            }
        }
    }
}

#endif //DEBUG
// returns the void* value if its there and NULL if its not
void* StrHash::insertUnique(LPCTSTR pszKey, int fCopy, void* pvVal) {
    unsigned int uBucketNum = _hashValue(pszKey, nBuckets);
    StrHashNode* pshnNewElt;
    if ((pshnNewElt = _findKey(pszKey, uBucketNum)))
        return pshnNewElt->pvVal;
    if (_prepareForInsert())
        uBucketNum = _hashValue(pszKey, nBuckets);
    pshnNewElt =
        new StrHashNode(pszKey, pvVal, fCopy,
                        ppshnHashChain[uBucketNum]);
    if (pshnNewElt && ppshnHashChain)
        ppshnHashChain[uBucketNum] = pshnNewElt;
    return NULL;
}

void* StrHash::retrieve(LPCTSTR pszKey) {
    if (!pszKey) return 0;
    unsigned int uBucketNum = _hashValue(pszKey, nBuckets);
    StrHashNode* pshn = _findKey(pszKey, uBucketNum);
    return (pshn ? pshn->pvVal : NULL);
}

// dynamically grow the hash table if necessary
//   return TRUE if rehashing was done
int StrHash::_prepareForInsert() {
    ++nElements; // we'te adding an element
    if ((_loadFactor() >= c_uMaxLoadFactor) &&
        (nCurPrime++   <= c_uNumPrimes)) {
        //--- grow the hashTable by rehashing everything:
        // set up new hashTable
        unsigned int nBucketsOld = nBuckets;
        nBuckets = sc_auPrimes[nCurPrime];
        StrHashNode** ppshnHashChainOld = ppshnHashChain;
        ppshnHashChain = new StrHashNode* [nBuckets];
        if (ppshnHashChain && ppshnHashChainOld) {
            unsigned int u;
            for (u = 0; u < nBuckets; ++u)
                ppshnHashChain[u] = NULL;
            // rehash by traversing all buckets
            for (u = 0; u < nBucketsOld; ++u) {
                StrHashNode* pshnTemp = ppshnHashChainOld[u];
                while (pshnTemp) {
                    unsigned int uBucket  = _hashValue(pshnTemp->pszKey, nBuckets);
                    StrHashNode* pshnNext = pshnTemp->next;
                    pshnTemp->next = ppshnHashChain[uBucket];
                    ppshnHashChain[uBucket] = pshnTemp;
                    pshnTemp = pshnNext;
                }
            }
            delete [] ppshnHashChainOld;
        }
        return 1;
    } // if needs rehashing
    return 0;
}

/*
// this variant of Weinberger's hash algorithm was taken from
//  packager.cpp (ie source)
unsigned int _oldhashValuePJW(const char* c_pszStr, unsigned int nBuckets) {
    unsigned long h = 0L;
    while(*c_pszStr)
        h = ((h << 4) + *(c_pszStr++) + (h >> 28));
    return (h % nBuckets);
}
*/

// this variant of Weinberger's hash algorithm is adapted from
//  Aho/Sethi/Ullman (the Dragon Book) p436
// in an empircal test using hostname data, this one resulted in less
// collisions than the function listed above.
// the two constants (24 and 0xf0000000) should be recalculated for 64-bit
//   when applicable
#define DOWNCASE(x) ( (((x) >= TEXT('A')) && ((x) <= TEXT('Z')) ) ? (((x) - TEXT('A')) + TEXT('a')) : (x) )
unsigned int StrHash::_hashValue(LPCTSTR pszStr, unsigned int nBuckets) {
    if (pszStr) {
        unsigned long h = 0L, g;
        TCHAR c;
        while((c = *(pszStr++))) {
            h = (h << 4) + ((_fCaseInsensitive ? DOWNCASE(c) : c));
            if ( (g = h & 0xf0000000) )
                h ^= (g >> 24) ^ g;
        }
        return (h % nBuckets);
    }
    return 0;
}

StrHash::StrHashNode* StrHash::_findKey(LPCTSTR pszStr, unsigned int uBucketNum) {
    StrHashNode* pshnTemp = ppshnHashChain[uBucketNum];
    while(pshnTemp) {
        if (!((_fCaseInsensitive ? StrCmpI : StrCmp)(pszStr, pshnTemp->pszKey)))
            return pshnTemp;
        pshnTemp = pshnTemp->next;
    }
    return NULL;
}

unsigned int  StrHash::_loadFactor() {
    return ( (nElements * USHRT_MAX) / nBuckets );
}

/* a small driver to test the hash function
   by reading values into stdin and reporting
   if they're duplicates -- run it against this
   perl script:

   while(<>) {
        chomp;
        if ($log{$_}++) {
       ++$dups;
    }
   }

   print "$dups duplicates.\n";

void driver_to_test_strhash_module() {
    StrHash strHash;

    char  s[4096];
    int   dups = 0;

    while(cin >> s) {
        if (strHash.insertUnique(s, 1, ((void*)1)))
            ++dups;
        else
            ;//cout << s << endl;
    }
    cout << dups << " duplicates." << endl;
}
*/

/**********************************************************************
                             OrderedList
 **********************************************************************/

// pass in uSize == 0 if you want no size limit
OrderedList::OrderedList(unsigned int uSize) {
    this->uSize = uSize;
    uCount      = 0;
    peltHead    = NULL;
}

OrderedList::~OrderedList() {
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
        delete peltTemp;
    }
}

#ifdef DEBUG
// Needed to avoid bogus leak detection
void
OrderedList::_RemoveElementsFromMemlist(){
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
    }
}

void
OrderedList::_AddElementsToMemlist(){
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
    }
}


#endif //DEBUG
void OrderedList::insert(OrderedList::Element *pelt) {
    // find insertion point
    OrderedList::Element* peltPrev = NULL;
    OrderedList::Element* peltTemp = peltHead;

    if (pelt)
    {
        while(peltTemp && (peltTemp->compareWith(pelt) < 0)) {
            peltPrev = peltTemp;
            peltTemp = peltTemp->next;
        }
        if (peltPrev) {
            peltPrev->next = pelt;
            pelt->next     = peltTemp;
        }
        else {
            pelt->next = peltHead;
            peltHead   = pelt;
        }

        // is list too full?  erase smallest element
        if ((++uCount > uSize) && (uSize)) {
            ASSERT(peltHead);
            peltTemp = peltHead;
            peltHead = peltHead->next;
            delete peltTemp;
            --uCount;
        }
    }
}

// YOU must delete elements that come from this one
OrderedList::Element *OrderedList::removeFirst() {
    OrderedList::Element *peltRet = peltHead;
    if (peltHead) {
        --uCount;
        peltHead = peltHead->next;
    }
    return peltRet;
}


//
// AlignPidl
//
// Check if the pidl is dword aligned.  If not reallign them by reallocating the
// pidl. If the pidls do get reallocated the caller must free them via
// FreeRealignPidl.
//

HRESULT AlignPidl(LPCITEMIDLIST* ppidl, BOOL* pfRealigned)
{
    ASSERT(ppidl);
    ASSERT(pfRealigned);

    HRESULT hr = S_OK;

    *pfRealigned = (BOOL)((ULONG_PTR)*ppidl & 3);

    if (*pfRealigned)
        hr = (*ppidl = ILClone(*ppidl)) ? S_OK : E_OUTOFMEMORY;

    return hr;
}

//
// AlignPidls
//
// AlignPidls realigns pidls for methonds that receive an array of pidls
// (i.e. GetUIObjectOf).  In this case a new array of pidl pointer needs to get
// reallocated since we don't want to stomp on the callers pointer array.
//

HRESULT AlignPidlArray(LPCITEMIDLIST* apidl, int cidl, LPCITEMIDLIST** papidl,
                   BOOL* pfRealigned)
{
    ASSERT((apidl != NULL) || (cidl==0))
    ASSERT(pfRealigned);
    ASSERT(papidl);

    HRESULT hr = S_OK;

    *pfRealigned = FALSE;

    // Check if any pidl needs to be realigned.  If anyone needs realigning
    // realign all of them.

    for (int i = 0; i < cidl && !*pfRealigned; i++)
        *pfRealigned = (BOOL)((ULONG_PTR)apidl[i] & 3);

    if (*pfRealigned)
    {
        // Use a temp pointer in case apidl and papidl are aliased (the most
        // likely case).

        LPCITEMIDLIST* apidlTemp = (LPCITEMIDLIST*)LocalAlloc(LPTR,
                                                  cidl * sizeof(LPCITEMIDLIST));

        if (apidlTemp)
        {
            for (i = 0; i < cidl && SUCCEEDED(hr); i++)
            {
                apidlTemp[i] = ILClone(apidl[i]);

                if (NULL == apidlTemp[i])
                {
                    for (int j = 0; j < i; j++)
                        ILFree((LPITEMIDLIST)apidlTemp[j]);

                    LocalFree(apidlTemp);
                    apidlTemp = NULL;

                    hr = E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr))
                *papidl = apidlTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

void FreeRealignedPidlArray(LPCITEMIDLIST* apidl, int cidl)
{
    ASSERT(apidl)
    ASSERT(cidl > 0);

    for (int i = 0; i < cidl; i++)
        ILFree((LPITEMIDLIST)apidl[i]);

    LocalFree(apidl);
    apidl = NULL;

    return;
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);
    while (--imi >= 0)
    {
        MENUITEMINFO mii = { sizeof(mii), MIIM_ID | MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0 };

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii))
        {
            UINT idcT = Shell_MergeMenus(GetMenuFromID(hmenuDst, mii.wID),
                    mii.hSubMenu, 0, idcMin, idcMax, MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

#undef ZONES_PANE_WIDTH
#define ZONES_PANE_WIDTH    120

void ResizeStatusBar(HWND hwnd, BOOL fInit)
{
    HWND hwndStatus = NULL;
    RECT rc = {0};
    LPSHELLBROWSER psb = FileCabinet_GetIShellBrowser(hwnd);
    UINT cx;
    int ciParts[] = {-1, -1};

    if (!psb)
        return;

    psb->GetControlWindow(FCW_STATUS, &hwndStatus);


    if (fInit)
    {
        int nParts = 0;

        psb->SendControlMsg(FCW_STATUS, SB_GETPARTS, 0, 0L, (LRESULT*)&nParts);
        for (int n = 0; n < nParts; n ++)
        {
            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, n, (LPARAM)TEXT(""), NULL);
            psb->SendControlMsg(FCW_STATUS, SB_SETICON, n, NULL, NULL);
        }
        psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, 0, 0L, NULL);
    }
    GetClientRect(hwndStatus, &rc);
    cx = rc.right;

    ciParts[0] = cx - ZONES_PANE_WIDTH;

    psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts, NULL);
}

HRESULT _ArrangeFolder(HWND hwnd, UINT uID)
{
    switch (uID) 
    {
    case IDM_SORTBYTITLE:
    case IDM_SORTBYADDRESS:
    case IDM_SORTBYVISITED:
    case IDM_SORTBYUPDATED:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYTITLE);
        break;
        
    case IDM_SORTBYNAME:
    case IDM_SORTBYADDRESS2:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYEXPIRES2:
    case IDM_SORTBYMODIFIED:
    case IDM_SORTBYACCESSED:
    case IDM_SORTBYCHECKED:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYNAME);
        break;
        
    default:
        return E_FAIL;
    }
    return NOERROR;
}

STDMETHODIMP CDetailsOfFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDetailsOfFolder, IShellDetails),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDetailsOfFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDetailsOfFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDetailsOfFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    return _psf->GetDetailsOf(pidl, iColumn, pdi);
}

HRESULT CDetailsOfFolder::ColumnClick(UINT iColumn)
{
    ShellFolderView_ReArrange(_hwnd, iColumn);
    return NOERROR;
}

STDMETHODIMP CFolderArrangeMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderArrangeMenu, IContextMenu),     // IID_IContextMenu
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderArrangeMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderArrangeMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFolderArrangeMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems = 0;
    
    if (uFlags == CMF_NORMAL)
    {
        HMENU hmenuHist = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(_idMenu));
        if (hmenuHist)
        {
            cItems = MergeMenuHierarchy(hmenu, hmenuHist, idCmdFirst, idCmdLast);
            DestroyMenu(hmenuHist);
        }
    }
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
    return ResultFromShort(cItems);    // number of menu items
}

STDMETHODIMP CFolderArrangeMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    if (HIWORD(pici->lpVerb) == 0)
        return _ArrangeFolder(pici->hwnd, LOWORD(pici->lpVerb));
    return E_INVALIDARG;
}

STDMETHODIMP CFolderArrangeMenu::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwRes,
                                                  LPSTR pszName, UINT cchMax)
{
    HRESULT hres = S_OK;
    if (uFlags == GCS_HELPTEXTA)
    {
        MLLoadStringA((UINT)idCmd + IDS_MH_FIRST, pszName, cchMax);
    }
    else if (uFlags == GCS_HELPTEXTW)
    {
        MLLoadStringW((UINT)idCmd + IDS_MH_FIRST, (LPWSTR)pszName, cchMax);
    }
    else
        hres = E_FAIL;
    return hres;
}

HRESULT _GetShortcut(LPCTSTR pszUrl, REFIID riid, void **ppv)
{
    IUniformResourceLocator *purl;
    HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                              IID_IUniformResourceLocator, (void **)&purl);

    if (SUCCEEDED(hr))
    {

        hr = purl->SetURL(pszUrl, TRUE);

        if (SUCCEEDED(hr))
            hr = purl->QueryInterface(riid, ppv);

        purl->Release();
    }

    return hr;
}

BOOL _TitleIsGood(LPCWSTR psz)
{
    DWORD scheme = GetUrlScheme(psz);
    return (!PathIsFilePath(psz) && (URL_SCHEME_INVALID == scheme || URL_SCHEME_UNKNOWN == scheme));
}

//////////////////////////////////////////////////////////////////////////////
//
// CBaseItem Object
//
//////////////////////////////////////////////////////////////////////////////


CBaseItem::CBaseItem() 
{
    DllAddRef();
    InitClipboardFormats();
    _cRef = 1;
}        

CBaseItem::~CBaseItem()
{
    if (_ppidl)
    {
        for (UINT i = 0; i < _cItems; i++) 
        {
            if (_ppidl[i])
                ILFree((LPITEMIDLIST)_ppidl[i]);
        }

        LocalFree((HLOCAL)_ppidl);
        _ppidl = NULL;
    }
    
    DllRelease();
}

HRESULT CBaseItem::Initialize(HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres;
    _ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(LPCITEMIDLIST));
    if (_ppidl)
    {
        _hwndOwner = hwnd;
        _cItems     = cidl;

        hres = S_OK;
        for (UINT i = 0; i < cidl; i++)
        {
            _ppidl[i] = ILClone(ppidl[i]);
            if (!_ppidl[i])
            {
                hres = E_OUTOFMEMORY;
                break;
            }
        }
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}        

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CBaseItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(CBaseItem, IContextMenu),
        QITABENT(CBaseItem, IDataObject),
        QITABENT(CBaseItem, IExtractIconA),
        QITABENT(CBaseItem, IExtractIconW),
        QITABENT(CBaseItem, IQueryInfo),
         { 0 },
    };
    hres = QISearch(this, qit, iid, ppv);

    if (FAILED(hres) && iid == IID_ICache) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

ULONG CBaseItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBaseItem::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//////////////////////////////////
//
// IQueryInfo Methods
//

HRESULT CBaseItem::GetInfoFlags(DWORD *pdwFlags)
{
    LPCITEMIDLIST pidl = _ppidl[0];
    LPCTSTR pszUrl = _PidlToSourceUrl(pidl);

    *pdwFlags = QIF_CACHED; 

    if (pszUrl)
    {
        pszUrl = _StripHistoryUrlToUrl(pszUrl);

        BOOL fCached = TRUE;

        if (UrlHitsNet(pszUrl) && !UrlIsMappedOrInCache(pszUrl))
        {
            fCached = FALSE;
        }
            
        if (!fCached)
            *pdwFlags &= ~QIF_CACHED;
    }

    return S_OK;
}

//////////////////////////////////
//
// IExtractIconA Methods...
//

HRESULT CBaseItem::Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize)
{
    return S_FALSE;
}

//////////////////////////////////
//
// IExtractIconW Methods...
//
HRESULT CBaseItem::GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    CHAR szIconFile[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szIconFile, ARRAYSIZE(szIconFile), pniIcon, puFlags);
    if (SUCCEEDED(hr))
        AnsiToUnicode(szIconFile, pwzIconFile, ucchMax);
    return hr;
}

HRESULT CBaseItem::Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize)
{
    CHAR szFile[MAX_PATH];
    UnicodeToAnsi(pcwzFile, szFile, ARRAYSIZE(szFile));
    return Extract(szFile, uIconIndex, phiconLarge, phiconSmall, ucIconSize);
}

//////////////////////////////////
//
// IContextMenu Methods
//

HRESULT CBaseItem::_AddToFavorites(int nIndex)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlUrl = NULL;
    TCHAR szParsedUrl[MAX_URL_STRING];

    // NOTE: This URL came from the user, so we need to clean it up.
    //       If the user entered "yahoo.com" or "Search Get Rich Quick",
    //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
    DWORD cchParsedUrl = ARRAYSIZE(szParsedUrl);
    LPCTSTR pszUrl = _GetUrl(nIndex);
    if (pszUrl && !ParseURLFromOutsideSource(pszUrl, szParsedUrl, &cchParsedUrl, NULL))
    {
        StrCpyN(szParsedUrl, pszUrl, ARRAYSIZE(szParsedUrl));
    } 

    hr = IEParseDisplayName(CP_ACP, szParsedUrl, &pidlUrl);
    if (SUCCEEDED(hr))
    {
        LPCTSTR pszTitle;
        LPCUTSTR pszuTitle = _GetURLTitle( _ppidl[nIndex]);
        if ((pszuTitle == NULL) || (ualstrlen(pszuTitle) == 0))
            pszuTitle = _GetUrl(nIndex);

	TSTR_ALIGNED_STACK_COPY(&pszTitle,pszuTitle);
        AddToFavorites(_hwndOwner, pidlUrl, pszTitle, TRUE, NULL, NULL);
        ILFree(pidlUrl);
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CBaseItem::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

    TraceMsg(DM_HSFOLDER, "hci - cm - GetCommandString() called.");

    if ((uFlags == GCS_VERBA) || (uFlags == GCS_VERBW))
    {
        LPCSTR pszSrc = NULL;

        switch(idCmd)
        {
            case RSVIDM_OPEN:
                pszSrc = c_szOpen;
                break;

            case RSVIDM_COPY:
                pszSrc = c_szCopy;
                break;

            case RSVIDM_DELCACHE:
                pszSrc = c_szDelcache;
                break;

            case RSVIDM_PROPERTIES:
                pszSrc = c_szProperties;
                break;
        }
        
        if (pszSrc)
        {
            if (uFlags == GCS_VERBA)
                StrCpyNA(pszName, pszSrc, cchMax);
            else if (uFlags == GCS_VERBW) // GCS_VERB === GCS_VERBW
                SHAnsiToUnicode(pszSrc, (LPWSTR)pszName, cchMax);
            else
                ASSERT(0);
            hres = S_OK;
        }
    }
    
    else if (uFlags == GCS_HELPTEXTA || uFlags == GCS_HELPTEXTW)
    {
        switch(idCmd)
        {
            case RSVIDM_OPEN:
            case RSVIDM_COPY:
            case RSVIDM_DELCACHE:
            case RSVIDM_PROPERTIES:
                if (uFlags == GCS_HELPTEXTA)
                {
                    MLLoadStringA(IDS_SB_FIRST+ (UINT)idCmd, pszName, cchMax);
                }
                else
                {
                    MLLoadStringW(IDS_SB_FIRST+ (UINT)idCmd, (LPWSTR)pszName, cchMax);
                }
                hres = NOERROR;
                break;

            default:
                break;
        }
    }
    return hres;
}


//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CBaseItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    TraceMsg(DM_HSFOLDER, "hci - do - GetDataHere() called.");
    return E_NOTIMPL;
}

HRESULT CBaseItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    TraceMsg(DM_HSFOLDER, "hci - do - GetCanonicalFormatEtc() called.");
    return DATA_S_SAMEFORMATETC;
}

HRESULT CBaseItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TraceMsg(DM_HSFOLDER, "hci - do - SetData() called.");
    return E_NOTIMPL;
}

HRESULT CBaseItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CBaseItem::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CBaseItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

LPCTSTR CBaseItem::_GetDisplayUrlForPidl(LPCITEMIDLIST pidl, LPTSTR pszDisplayUrl, DWORD dwDisplayUrl)
{
    LPCTSTR pszUrl = _StripHistoryUrlToUrl(_PidlToSourceUrl(pidl));
    if (pszUrl && PrepareURLForDisplay(pszUrl, pszDisplayUrl, &dwDisplayUrl))
    {
        pszUrl = pszDisplayUrl;
    }
    return pszUrl;
}

HRESULT CBaseItem::_CreateFileDescriptorA(LPSTGMEDIUM pSTM)
{
    TCHAR urlTitleBuf[ MAX_URL_STRING ];
    LPCUTSTR ua_urlTitle;
    LPCTSTR urlTitle;
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;

    FILEGROUPDESCRIPTORA *pfgd = (FILEGROUPDESCRIPTORA*)GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTORA) + (_cItems-1) * sizeof(FILEDESCRIPTORA));
    if (pfgd == NULL)
    {
        TraceMsg(DM_HSFOLDER, "hci -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    
    pfgd->cItems = _cItems;     // set the number of items

    for (UINT i = 0; i < _cItems; i++)
    {

        FILEDESCRIPTORA *pfd = &(pfgd->fgd[i]);
        UINT cchFilename;

	//
	// Derive an aligned copy of the url title
	//

	ua_urlTitle = _GetURLTitle( _ppidl[i] );
	if (TSTR_ALIGNED(ua_urlTitle) == FALSE) {
	    ualstrcpyn( urlTitleBuf, ua_urlTitle, ARRAYSIZE(urlTitleBuf));
	    urlTitle = urlTitleBuf;
	} else {
	    urlTitle = (LPCTSTR)ua_urlTitle;
	}
        
        SHTCharToAnsi(urlTitle, pfd->cFileName, ARRAYSIZE(pfd->cFileName) );
        
        MakeLegalFilenameA(pfd->cFileName, ARRAYSIZE(pfd->cFileName));

        cchFilename = lstrlenA(pfd->cFileName);
        SHTCharToAnsi(L".URL", pfd->cFileName+cchFilename, ARRAYSIZE(pfd->cFileName)-cchFilename);

    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}
    
// this format is explicitly ANSI, hence no TCHAR stuff

HRESULT CBaseItem::_CreateURL(LPSTGMEDIUM pSTM)
{
    DWORD cchSize;
    LPCTSTR pszURL = _StripHistoryUrlToUrl(_PidlToSourceUrl(_ppidl[0]));
    if (!pszURL)
        return E_FAIL;
    
    // render the url
    cchSize = lstrlen(pszURL) + 1;

    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cchSize * sizeof(CHAR));
    if (pSTM->hGlobal)
    {
        TCharToAnsi(pszURL, (LPSTR)pSTM->hGlobal, cchSize);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


HRESULT CBaseItem::_CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = DROPEFFECT_COPY;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}


HRESULT CBaseItem::_CreateFileContents(LPSTGMEDIUM pSTM, LONG lindex)
{
    HRESULT hr;
    
    // make sure the index is in a valid range.
    ASSERT((unsigned)lindex < _cItems);
    ASSERT(lindex >= 0);

    // here's a partial fix for when ole sometimes passes in -1 for lindex
    if (lindex == -1)
    {
        if (_cItems == 1)
            lindex = 0;
        else
            return E_FAIL;
    }
    
    pSTM->tymed = TYMED_ISTREAM;
    pSTM->pUnkForRelease = NULL;
    
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER li = {0L, 0L};
        IUniformResourceLocator *purl;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
            IID_IUniformResourceLocator, (void **)&purl);
        if (SUCCEEDED(hr))
        {
            TCHAR szDecoded[MAX_URL_STRING];

            ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[lindex]), 
                szDecoded, ARRAYSIZE(szDecoded));

            hr = purl->SetURL(szDecoded, TRUE);
            if (SUCCEEDED(hr))
            {
                IPersistStream *pps;
                hr = purl->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
                if (SUCCEEDED(hr))
                {
                    hr = pps->Save(pSTM->pstm, TRUE);
                    pps->Release();
                }
            }
            purl->Release();
        }               
        pSTM->pstm->Seek(li, STREAM_SEEK_SET, NULL);
    }

    return hr;
}


HRESULT CBaseItem::_CreateHTEXT(LPSTGMEDIUM pSTM)
{
    UINT i;
    UINT cbAlloc = sizeof(TCHAR);        // null terminator
    TCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

    for (i = 0; i < _cItems; i++)
    {
        LPCTSTR pszUrl = _GetDisplayUrlForPidl(_ppidl[i], szDisplayUrl, ARRAYSIZE(szDisplayUrl));
        if (!pszUrl)
            return E_FAIL;
        char szAnsiUrl[MAX_URL_STRING];
        TCharToAnsi(pszUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));

        // 2 extra for carriage return and newline
        cbAlloc += sizeof(CHAR) * (lstrlenA(szAnsiUrl) + 2);  
    }

    // render the url
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cbAlloc);

    if (pSTM->hGlobal)
    {
        LPSTR  pszHTEXT = (LPSTR)pSTM->hGlobal;
        int    cchHTEXT = cbAlloc / sizeof(CHAR);

        for (i = 0; i < _cItems; i++)
        {
            if (i && cchHTEXT > 2)
            {
                *pszHTEXT++ = 0xD;
                *pszHTEXT++ = 0xA;
                cchHTEXT -= 2;
            }

            LPCTSTR pszUrl = _GetDisplayUrlForPidl(_ppidl[i], szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            if (pszUrl)
            {
                int     cchUrl = lstrlen(pszUrl);

                TCharToAnsi(pszUrl, pszHTEXT, cchHTEXT);

                pszHTEXT += cchUrl;
                cchHTEXT -= cchUrl;
            }
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT CBaseItem::_CreateUnicodeTEXT(LPSTGMEDIUM pSTM)
{
    UINT i;
    UINT cbAlloc = sizeof(WCHAR);        // null terminator
    WCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

    for (i = 0; i < _cItems; i++)
    {
        ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[i]), 
            szDisplayUrl, ARRAYSIZE(szDisplayUrl));

        if (!*szDisplayUrl)
            return E_FAIL;

        cbAlloc += sizeof(WCHAR) * (lstrlenW(szDisplayUrl) + 2);
    }

    // render the url
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cbAlloc);

    if (pSTM->hGlobal)
    {
        LPTSTR pszHTEXT = (LPTSTR)pSTM->hGlobal;
        int    cchHTEXT = cbAlloc / sizeof(WCHAR);

        for (i = 0; i < _cItems; i++)
        {
            if (i && cchHTEXT > 2)
            {
                *pszHTEXT++ = 0xD;
                *pszHTEXT++ = 0xA;
                cchHTEXT -= 2;
            }

            ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[i]), 
                szDisplayUrl, ARRAYSIZE(szDisplayUrl));

            int     cchUrl = lstrlenW(szDisplayUrl);

            StrCpyN(pszHTEXT, szDisplayUrl, cchHTEXT);

            pszHTEXT += cchUrl;
            cchHTEXT -= cchUrl;
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\cafitem.cpp ===
#include "local.h"
#include "../security.h"
#include "../favorite.h"
#include "resource.h"
#include "chcommon.h"
#include "cafolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

#define MAX_ITEM_OPEN 10

//////////////////////////////////////////////////////////////////////////////
//
// CCacheItem Object
//
//////////////////////////////////////////////////////////////////////////////


CCacheItem::CCacheItem() 
{
    _dwDelCookie = DEL_COOKIE_WARN;
}

CCacheItem::~CCacheItem()
{
    if (_pCFolder)
        _pCFolder->Release();          // release the pointer to the sf
}

HRESULT CCacheItem::Initialize(CCacheFolder *pCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres = CBaseItem::Initialize(hwnd, cidl, ppidl);

    if (SUCCEEDED(hres))
    {
        _pCFolder = pCFolder;
        _pCFolder->AddRef();      // we're going to hold onto this pointer, so
    }

    return hres;
}        

HRESULT CCacheItem_CreateInstance(CCacheFolder *pCFolder, HWND hwnd,
    UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;                 // null the out param

    CCacheItem *pHCItem = new CCacheItem;
    if (pHCItem)
    {
        hr = pHCItem->Initialize(pCFolder, hwnd, cidl, ppidl);
        if (SUCCEEDED(hr))
            hr = pHCItem->QueryInterface(riid, ppv);
        pHCItem->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CCacheItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres = CBaseItem::QueryInterface(iid, ppv);

    if (FAILED(hres) && iid == IID_ICache) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

//////////////////////////////////
//
// IQueryInfo Methods
//
HRESULT CCacheItem::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    return _pCFolder->_GetInfoTip(_ppidl[0], dwFlags, ppwszTip);
}

//////////////////////////////////
//
// IContextMenu Methods
//
HRESULT CCacheItem::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems;

    TraceMsg(DM_HSFOLDER, "hci - cm - QueryContextMenu() called.");
    
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
    {
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_URL_VERBSONLY, 0, indexMenu, 
            idCmdFirst, idCmdLast);
    
    }
    else  // (uFlags & CMF_NORMAL)
    {
        UINT idResource = POPUP_CACHECONTEXT_URL;

        cItems = MergePopupMenu(&hmenu, idResource, 0, indexMenu, idCmdFirst, idCmdLast);

        if (IsInetcplRestricted(L"History"))
        {
            DeleteMenu(hmenu, RSVIDM_DELCACHE + idCmdFirst, MF_BYCOMMAND);
            _SHPrettyMenu(hmenu);
        }
    }
    if (hmenu)
        SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

static BOOL CachevuWarningDlg(LPCEIPIDL pcei, UINT uIDWarning, HWND hwnd)
{
    TCHAR szFormat[MAX_PATH], szBuff[MAX_PATH], szTitle[MAX_PATH];

    _GetCacheItemTitle(pcei, szTitle, ARRAYSIZE(szTitle));
    MLLoadString(uIDWarning, szFormat, ARRAYSIZE(szFormat));
    StringCchPrintf(szBuff, ARRAYSIZE(szBuff), szFormat);

    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_HISTCACHE_WARNING),
                             hwnd, HistoryConfirmDeleteDlgProc, (LPARAM)szBuff) == IDYES;
} 

STDMETHODIMP CCacheItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    DWORD dwAction;
    BOOL fCancelCopyAndOpen = FALSE;
    BOOL fZonesUI = FALSE;
    BOOL fMustFlushNotify = FALSE;
    BOOL fBulkDelete;

    TraceMsg(DM_HSFOLDER, "hci - cm - InvokeCommand() called.");

    // ZONES SECURITY CHECK.
    //
    // We need to cycle through each action and Zone Check the URLs.
    // We pass NOUI when zone checking the URLs because we don't want info
    // displayed to the user.  We will stop when we find the first questionable
    // URL.  We will then 
    for (i = 0; (i < _cItems) && !fZonesUI; i++)
    {
        if (_ppidl[i]) 
        {
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if ((i < MAX_ITEM_OPEN))
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_VERB))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_VERB;
                    }
                }
                break;

            case RSVIDM_COPY:
                if (!_ZoneCheck(i, URLACTION_SHELL_MOVE_OR_COPY))
                {
                    fZonesUI = TRUE;
                    dwAction = URLACTION_SHELL_MOVE_OR_COPY;
                }
                break;
            }
        }
    }

    if (fZonesUI)
    {
        LPCTSTR pszUrl = _GetUrl(i-1);  // Sub 1 because of for loop above.
        if (S_OK != ZoneCheckUrl(pszUrl, dwAction, PUAF_DEFAULT|PUAF_WARN_IF_DENIED, NULL))
        {
            // The user cannot do this or does not want to do this.
            fCancelCopyAndOpen = TRUE;
        }
    }

    i = _cItems;
    fBulkDelete = i > LOTS_OF_FILES;

    // fCancelCopyAndOpen happens if the user cannot or chose not to proceed.
    while (i && !fCancelCopyAndOpen)
    {
        i--;
        if (_ppidl[i]) 
        {

            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY))
                {
                    ASSERT(PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i])) && \
                        !StrCmpI(PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i])),TEXT(".txt")));
                    hres = _LaunchApp(pici->hwnd, CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]));
                }
                else
                {
                    TCHAR szDecoded[MAX_URL_STRING];
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        ConditionallyDecodeUTF8(pszUrl, szDecoded, ARRAYSIZE(szDecoded));
                        hres = _LaunchApp(pici->hwnd, szDecoded);
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
                break;

            case RSVIDM_ADDTOFAVORITES:
                hres = _AddToFavorites(i);
                goto Done;
            case RSVIDM_OPEN_NEWWINDOW:
                {
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        TCHAR szDecoded[MAX_URL_STRING];
                        ConditionallyDecodeUTF8(pszUrl, szDecoded, ARRAYSIZE(szDecoded));
                        LPWSTR pwszTarget;
                    
                        if (SUCCEEDED((hres = SHStrDup(szDecoded, &pwszTarget)))) {
                            hres = NavToUrlUsingIEW(pwszTarget, TRUE);
                            CoTaskMemFree(pwszTarget);
                        }
                    }
                    else
                        hres = E_FAIL;
                    goto Done;
                }
            case RSVIDM_COPY:
                OleSetClipboard((IDataObject *)this);
                goto Done;

            case RSVIDM_DELCACHE:
                // pop warning msg for cookie only once
                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY) &&     
                    (_dwDelCookie == DEL_COOKIE_WARN ))
                {
                    if(CachevuWarningDlg((LPCEIPIDL)_ppidl[i], IDS_WARN_DELETE_CACHE, pici->hwnd))
                        _dwDelCookie = DEL_COOKIE_YES;
                    else
                        _dwDelCookie = DEL_COOKIE_NO;
                }

                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY) &&     
                    (_dwDelCookie == DEL_COOKIE_NO ))
                    continue;
          
                if (DeleteUrlCacheEntry(CPidlToSourceUrl((LPCEIPIDL)_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, _pCFolder->_pidl, _ppidl[i], NULL);
                    }
                    fMustFlushNotify = TRUE;
                }
                else 
                    hres = E_FAIL;
                break;

            case RSVIDM_PROPERTIES:
                // NOTE: We'll probably want to split this into two cases
                // and call a function in each case
                //
                _CreatePropSheet(pici->hwnd, _ppidl[i], DLG_CACHEITEMPROP, _sPropDlgProc,
                    CEI_SOURCEURLNAME((LPCEIPIDL)_ppidl[i]));
                goto Done;

            default:
                hres = E_FAIL;
                break;
            }
            
            ASSERT(SUCCEEDED(hres));
            if (FAILED(hres))
                TraceMsg(DM_HSFOLDER, "Cachevu failed the command at: %s", CPidlToSourceUrl((LPCEIPIDL)_ppidl[i]));
        }
    }
Done:
    if (fMustFlushNotify)
    {
        if (fBulkDelete)
        {
            _GenerateEvent(SHCNE_UPDATEDIR, _pCFolder->_pidl, NULL, NULL);
        }

        SHChangeNotifyHandleEvents();
    }
    return hres;
}

//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CCacheItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if (pFEIn->cfFormat == CF_HDROP && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateHDROP(pSTM);

    else if ((pFEIn->cfFormat == g_cfPreferredEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else
        hres = DATA_E_FORMATETC;
    
    return hres;

}

HRESULT CCacheItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - QueryGetData(%s)", szName);
#endif

    if (pFEIn->cfFormat == CF_HDROP            || 
        pFEIn->cfFormat == g_cfPreferredEffect)
    {
        TraceMsg(DM_HSFOLDER, "		   format supported.");
        return NOERROR;
    }
    return S_FALSE;
}

HRESULT CCacheItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC Cachefmte[] = {
        {CF_HDROP,                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfPreferredEffect,     NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(Cachefmte), Cachefmte, ppEnum);
}

//////////////////////////////////
//
// IExtractIconA Methods...
//
HRESULT CCacheItem::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    if (ucchMax < 2)
        return E_FAIL;
    
    *puFlags = GIL_NOTFILENAME;
    pszIconFile[0] = '*';
    pszIconFile[1] = '\0';
    
    // "*" as the file name means iIndex is already a system icon index.
    return _pCFolder->GetIconOf(_ppidl[0], uFlags, pniIcon);
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

UNALIGNED const TCHAR* CCacheItem::_GetURLTitle(LPCITEMIDLIST pidl)
{
    return ::_GetURLTitle( (LPCEIPIDL) pidl);
}

LPCTSTR CCacheItem::_GetUrl(int nIndex)
{
    LPCTSTR pszUrl = NULL;
    pszUrl = CPidlToSourceUrl((LPCEIPIDL)_ppidl[nIndex]);
    return pszUrl;
}

LPCTSTR CCacheItem::_PidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return CPidlToSourceUrl((LPCEIPIDL) pidl);
}


// Return value:
//               TRUE - URL is Safe.
//               FALSE - URL is questionable and needs to be re-zone checked w/o PUAF_NOUI.
BOOL CCacheItem::_ZoneCheck(int nIndex, DWORD dwUrlAction)
{
    LPCTSTR pszUrl = _GetUrl(nIndex);

    if (S_OK != ZoneCheckUrl(pszUrl, dwUrlAction, PUAF_NOUI, NULL))
        return FALSE;

    return TRUE;
}

INT_PTR CALLBACK CCacheItem::_sPropDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCEIPIDL pcei = lpPropSheet ? (LPCEIPIDL)lpPropSheet->lParam : NULL;

    switch(message) {

        case WM_INITDIALOG: {
            SHFILEINFO sfi;
            TCHAR szBuf[80];
            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            pcei = (LPCEIPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

            // get the icon and file type strings

            SHGetFileInfo(CEI_LOCALFILENAME(pcei), 0, &sfi, SIZEOF(sfi), SHGFI_ICON | SHGFI_TYPENAME);

            SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0);

            // set the info strings
            SetDlgItemText(hDlg, IDD_HSFURL, CPidlToSourceUrl((LPCEIPIDL)pcei));
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);

            SetDlgItemText(hDlg, IDD_FILESIZE, StrFormatByteSize(pcei->cei.dwSizeLow, szBuf, ARRAYSIZE(szBuf)));
            SetDlgItemText(hDlg, IDD_CACHE_NAME, PathFindFileName(CEI_LOCALFILENAME(pcei)));
            FileTimeToDateTimeStringInternal(&pcei->cei.ExpireTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_EXPIRES, szBuf);
            FileTimeToDateTimeStringInternal(&pcei->cei.LastModifiedTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_MODIFIED, szBuf);
            FileTimeToDateTimeStringInternal(&pcei->cei.LastAccessTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_ACCESSED, szBuf);
            
            break;
        }

        case WM_DESTROY:
            {
                HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_GETICON, 0, 0);
                if (hIcon)
                    DestroyIcon(hIcon);
            }
            break;

        case WM_COMMAND:
        case WM_HELP:
        case WM_CONTEXTMENU:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

// use CEI_LOCALFILENAME to get the file name for the HDROP, but map that
// to the final file name (store in the file system) through the "FileNameMap"
// data which uses _GetURLTitle() as the final name of the file.

HRESULT CCacheItem::_CreateHDROP(STGMEDIUM *pmedium)
{
    UINT i;
    UINT cbAlloc = sizeof(DROPFILES) + sizeof(CHAR);        // header + null terminator

    for (i = 0; i < _cItems; i++)
    {
        char szAnsiUrl[MAX_URL_STRING];
        
        SHTCharToAnsi(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]), szAnsiUrl, ARRAYSIZE(szAnsiUrl));
        cbAlloc += sizeof(CHAR) * (lstrlenA(szAnsiUrl) + 1);
    }

    pmedium->tymed = TYMED_HGLOBAL;
    pmedium->pUnkForRelease = NULL;
    pmedium->hGlobal = GlobalAlloc(GPTR, cbAlloc);
    if (pmedium->hGlobal)
    {
        LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;
        LPSTR pszFiles  = (LPSTR)(pdf + 1);
        int   cchFiles  = (cbAlloc - sizeof(DROPFILES) - sizeof(CHAR));
        pdf->pFiles = sizeof(DROPFILES);
        pdf->fWide = FALSE;

        for (i = 0; i < _cItems; i++)
        {
            LPTSTR pszPath = CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]);
            int    cchPath = lstrlen(pszPath);

            SHTCharToAnsi(pszPath, pszFiles, cchFiles);

            pszFiles += cchPath + 1;
            cchFiles -= cchPath + 1;

            ASSERT((UINT)((LPBYTE)pszFiles - (LPBYTE)pdf) < cbAlloc);
        }
        ASSERT((LPSTR)pdf + cbAlloc - 1 == pszFiles);
        ASSERT(*pszFiles == 0); // zero init alloc

        return NOERROR;

    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dll\makefile.inc ===
$(O)\error.dls : ..\error.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\error.dlg > $@

$(O)\error.dlx : $(O)\error.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\error.dls > $@

$(O)\about.dls : ..\about.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\about.dlg > $@

$(O)\about.dlx : $(O)\about.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\about.dls > $@

$(O)\findinc.dls : ..\findinc.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\findinc.dlg > $@

$(O)\findinc.dlx : $(O)\findinc.dls ..\dlg.pl
    echo //^<SCRIPT LANGUAGE="JavaScript"^> > $@
    perl ..\dlg.pl < $(O)\findinc.dls >> $@
    echo //^</SCRIPT^> >> $@

$(O)\find.dls : ..\find.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\find.dlg > $@

$(O)\find.dlx : $(O)\find.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\find.dls > $@

$(O)\privacypolicy.dls : ..\privacypolicy.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\privacypolicy.dlg > $@

$(O)\privacypolicy.dlx : $(O)\privacypolicy.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\privacypolicy.dls > $@


$(O)\bidifind.dls : ..\bidifind.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\bidifind.dlg > $@

$(O)\bidifind.dlx : $(O)\bidifind.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\bidifind.dls > $@

$(O)\orgfav.dls : ..\orgfav.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\orgfav.dlg > $@

$(O)\orgfav.dlx : $(O)\orgfav.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\orgfav.dls > $@

$(O)\ieerror.dls : ..\ieerror.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\ieerror.dlg > $@

$(O)\ieerror.dlx : $(O)\ieerror.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\ieerror.dls > $@

$(O)\anchbrws.pps : ..\anchbrws.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\anchbrws.ppg > $@

$(O)\anchbrws.ppx: $(O)\anchbrws.pps
    perl ..\dlg.pl < $(O)\anchbrws.pps > $@

$(O)\docbrows.pps: ..\docbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\docbrows.ppg > $@

$(O)\docbrows.ppx : $(O)\docbrows.pps
    perl ..\dlg.pl < $(O)\docbrows.pps > $@

$(O)\imgbrows.pps : ..\imgbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\imgbrows.ppg > $@

$(O)\imgbrows.ppx : $(O)\imgbrows.pps
    perl ..\dlg.pl < $(O)\imgbrows.pps > $@

$(O)\analyze.dls : ..\analyze.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\analyze.dlg > $@

$(O)\analyze.dlx : $(O)\analyze.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\analyze.dls > $@

SHDOCLCR_DEP = \
    $(O)\error.dlx      \
    $(O)\about.dlx      \
    $(O)\findinc.dlx    \
    $(O)\find.dlx       \
    $(O)\privacypolicy.dlx  \
    $(O)\bidifind.dlx   \
    $(O)\orgfav.dlx     \
    $(O)\ieerror.dlx    \
    $(O)\anchbrws.ppx   \
    $(O)\docbrows.ppx   \
    $(O)\imgbrows.ppx   \
    $(O)\analyze.dlx

!include $(CCSHELL_DIR)\makefile.inc

..\shdocvw.rc : $(SDK_LIB_PATH)\exdisp.tlb $(SELFREGNAME) $(SHDOCLCR_DEP)

..\shdoclc.rc : $(SHDOCLCR_DEP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\cafolder.h ===
#ifndef CAFOLDER_H__
#define CAFOLDER_H__

#ifdef __cplusplus

#include <debug.h>
#include "iface.h"

// Forward class declarations
class CCacheFolderEnum;
class CCacheFolder;
class CCacheItem;

#define LOTS_OF_FILES (10)

// PIDL format for cache folder...
struct CEIPIDL : public BASEPIDL
{
//    USHORT cb;
//    USHORT usSign;
    TCHAR szTypeName[80];
    INTERNET_CACHE_ENTRY_INFO cei;
};
typedef UNALIGNED CEIPIDL *LPCEIPIDL;

#define IS_VALID_CEIPIDL(pidl)      ((pidl)                                     && \
                                     (((LPCEIPIDL)pidl)->cb >= sizeof(CEIPIDL)) && \
                                     (((LPCEIPIDL)pidl)->usSign == (USHORT)CEIPIDL_SIGN))
#define CEI_SOURCEURLNAME(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszSourceUrlName + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_LOCALFILENAME(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszLocalFileName + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_FILEEXTENSION(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszFileExtension + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_CACHEENTRYTYPE(pcei)   ((DWORD)(pcei)->cei.CacheEntryType)

inline UNALIGNED const TCHAR* _GetURLTitle(LPCEIPIDL pcei)
{
    return _FindURLFileName(CEI_SOURCEURLNAME(pcei));
}    

inline void _GetCacheItemTitle(LPCEIPIDL pcei, LPTSTR pszTitle, DWORD cchBufferSize)
{
    int iLen;
    ualstrcpyn(pszTitle, _GetURLTitle(pcei), cchBufferSize);
    iLen = lstrlen(pszTitle) - 1;       // we want the last char
    if (pszTitle[iLen] == TEXT('/'))
        pszTitle[iLen] = TEXT('\0');
}   

inline LPCTSTR CPidlToSourceUrl(LPCEIPIDL pidl)
{
    return CEI_SOURCEURLNAME(pidl);
}

inline int _CompareCFolderPidl(LPCEIPIDL pidl1, LPCEIPIDL pidl2)
{
    return StrCmpI(CPidlToSourceUrl(pidl1), CPidlToSourceUrl(pidl2));
}

///////////////////////
//
// Warn on Cookie deletion
//
enum {
    DEL_COOKIE_WARN = 0,
    DEL_COOKIE_YES,
    DEL_COOKIE_NO
};

// Forward declarations for create instance functions 
HRESULT CCacheItem_CreateInstance(CCacheFolder *pHCFolder, HWND hwndOwner, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);

//////////////////////////////////////////////////////////////////////////////
//
// CCacheFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class CCacheFolderEnum : public IEnumIDList
{
public:
    CCacheFolderEnum(DWORD grfFlags, CCacheFolder *pHCFolder);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    ~CCacheFolderEnum();

    LONG                _cRef;      // ref count
    CCacheFolder    *_pCFolder;// this is what we enumerate    
    UINT                _grfFlags;  // enumeration flags 
    UINT                _uFlags;    // local flags   
    LPINTERNET_CACHE_ENTRY_INFO _pceiWorking;        
    HANDLE              _hEnum;
};


class CCacheFolder :
    public IShellFolder2, 
    public IShellIcon, 
    public IPersistFolder2
{
    // CCacheFolder interfaces
    friend CCacheFolderEnum;
    friend CCacheItem;
    friend HRESULT CacheFolderView_CreateInstance(CCacheFolder *pHCFolder, void **ppvOut);
    friend HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);
        
public:
    CCacheFolder();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid) { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum) { *ppenum = NULL; return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

protected:
    ~CCacheFolder();
    
    HRESULT GetDisplayNameOfCEI(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    HRESULT _CompareAlignedIDs(LPARAM lParam, LPCEIPIDL pidl1, LPCEIPIDL pidl2);

    HRESULT _GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip);
    
    STDMETHODIMP _GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr);
    HRESULT _GetFileSysFolder(IShellFolder2 **ppsf);
    static HRESULT CALLBACK _sViewCallback(IShellView *psv, IShellFolder *psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG            _cRef;

    UINT            _uFlags;    // copied from CacheFolder struct
    LPITEMIDLIST    _pidl;      // copied from CacheFolder struct
    IShellFolder2*   _pshfSys;   // system IShellFolder
};

class CCacheItem : public CBaseItem
{
    // CCacheItem interfaces
    friend HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);

public:
    CCacheItem();
    HRESULT Initialize(CCacheFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);

    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);

    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);

    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

protected:
    ~CCacheItem();

    virtual LPCTSTR _GetUrl(int nIndex);
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl);
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei);
    BOOL _ZoneCheck(int nIndex, DWORD dwUrlAction);
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);

    CCacheFolder* _pCFolder;   // back pointer to our shell folder
    DWORD   _dwDelCookie;
    static INT_PTR CALLBACK _sPropDlgProc(HWND, UINT, WPARAM, LPARAM);
};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\chcommon.h ===
#ifndef CHCOMMON_H__
#define CHCOMMON_H__

#ifdef __cplusplus

HRESULT _GetShortcut(LPCTSTR pszUrl, REFIID riid, void **ppv);
HRESULT AlignPidl(LPCITEMIDLIST* ppidl, BOOL* pfRealigned);
HRESULT AlignPidlArray(LPCITEMIDLIST* apidl, int cidl, LPCITEMIDLIST** papidl,
                          BOOL* pfRealigned);
void    FreeRealignedPidlArray(LPCITEMIDLIST* apidl, int cidl);

void inline FreeRealignedPidl(LPCITEMIDLIST pidl)
{
    ILFree((LPITEMIDLIST)pidl);
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax);
void ResizeStatusBar(HWND hwnd, BOOL fInit);
HRESULT _ArrangeFolder(HWND hwnd, UINT uID);
BOOL _TitleIsGood(LPCWSTR psz);

//////////////////////////////////////////////////////////////////////
//  StrHash -- A generic string hasher
//             Stores (char*, void*) pairs
//  Marc Miller (t-marcmi), 1998

/*
 * TODO:
 *    provide a way to update/delete entries
 *    provice a way to specify a beginning table size
 *    provide a way to pass in a destructor function
 *      for void* values
 */
class StrHash {
public:
    StrHash(int fCaseInsensitive = 0);
    ~StrHash();
    void* insertUnique(LPCTSTR pszKey, int fCopy, void* pvVal);    
    void* retrieve(LPCTSTR pszKey);
#ifdef DEBUG
    void _RemoveHashNodesFromMemList();
    void _AddHashNodesFromMemList();
#endif // DEBUG
protected:
    class StrHashNode {
        friend class StrHash;
    protected:
        LPCTSTR pszKey;
        void*   pvVal;
        int     fCopy;
        StrHashNode* next;
    public:
        StrHashNode(LPCTSTR psz, void* pv, int fCopy, StrHashNode* next);
        ~StrHashNode();
    };
    // possible hash-table sizes, chosen from primes not close to powers of 2
    static const unsigned int   sc_auPrimes[];
    static const unsigned int   c_uNumPrimes;
    static const unsigned int   c_uFirstPrime;
    static const unsigned int   c_uMaxLoadFactor; // scaled by USHORT_MAX

    unsigned int nCurPrime; // current index into sc_auPrimes
    unsigned int nBuckets;
    unsigned int nElements;
    StrHashNode** ppshnHashChain;

    int _fCaseInsensitive;
    
    unsigned int        _hashValue(LPCTSTR, unsigned int);
    StrHashNode*        _findKey(LPCTSTR pszStr, unsigned int ubucketNum);
    unsigned int        _loadFactor();
    int                 _prepareForInsert();
private:
    // empty private copy constructor to prevent copying
    StrHash(const StrHash& strHash) { }
    // empty private assignment constructor to prevent assignment
    StrHash& operator=(const StrHash& strHash) { return *this; }
};

//////////////////////////////////////////////////////////////////////
/// OrderedList
class OrderedList {
public:
    class Element {
    public:
        friend  class OrderedList;
        virtual int   compareWith(Element *pelt) = 0;

        virtual ~Element() { }
    private:
        Element* next;
    };
    OrderedList(unsigned int uSize);
    ~OrderedList();
#if DEBUG
	void _RemoveElementsFromMemlist();
	void _AddElementsToMemlist();
#endif //DEBUg
    
    void     insert(Element *pelt);
    Element *removeFirst();
    Element *peek() { return peltHead; }

protected:
    Element       *peltHead; // points to smallest in list
    unsigned int   uSize;
    unsigned int   uCount;

public:
    // variable access functions
    unsigned int count() { return uCount; }
    BOOL         full()  { return (uSize && (uCount >= uSize)); }
private:
    OrderedList(const OrderedList& ol) { }
    OrderedList& operator=(const OrderedList& ol) { return *this; }
};

class CDetailsOfFolder : public IShellDetails
{
public:
    CDetailsOfFolder(HWND hwnd, IShellFolder2 *psf) : _cRef(1), _psf(psf), _hwnd(hwnd)
    {
        _psf->AddRef();
    }

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IShellDetails
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi);
    STDMETHOD(ColumnClick)(UINT iColumn);

private:
    virtual ~CDetailsOfFolder() { _psf->Release(); }

    LONG _cRef;
    IShellFolder2 *_psf;
    HWND _hwnd;
};

class CFolderArrangeMenu : public IContextMenu
{
public:
    CFolderArrangeMenu(UINT idMenu) : _cRef(1), _idMenu(idMenu)
    {
    }

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IContextMenu 
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);
private:
    virtual ~CFolderArrangeMenu() { }

    LONG _cRef;
    UINT _idMenu;
};

////////////////////////////////////////////////////////////////////////////
//
// CBaseItem Object
//
////////////////////////////////////////////////////////////////////////////

class CBaseItem :
    public IContextMenu, 
    public IDataObject,
    public IExtractIconA,
    public IExtractIconW,
    public IQueryInfo
{

public:
    CBaseItem();
    HRESULT Initialize(HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu Methods
//    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
//                                  UINT idCmdLast, UINT uFlags);

//    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);
    

    // IQueryInfo Methods
//    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);
    
    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags) = 0;
    STDMETHODIMP Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IExtractIconW Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IDataObject Methods...
//    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
//    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
//    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
    
    // IDataObject helper functions
    HRESULT _CreateHTEXT(STGMEDIUM *pmedium);
    HRESULT _CreateUnicodeTEXT(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptorA(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);

   
protected:

    virtual ~CBaseItem();

    virtual LPCTSTR _GetUrl(int nIndex) = 0;
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl) = 0;
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei) = 0;
    LPCTSTR _GetDisplayUrlForPidl(LPCITEMIDLIST pidl, LPTSTR pszDisplayUrl, DWORD dwDisplayUrl);
    HRESULT _AddToFavorites(int nIndex);    

    LONG              _cRef;        // reference count
    
    UINT    _cItems;                // number of items we represent
    LPCITEMIDLIST*  _ppidl;             // variable size array of items
    HWND    _hwndOwner;     
};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\hsfitem.cpp ===
#include "local.h"
#include "../security.h"
#include "../favorite.h"
#include "resource.h"
#include "chcommon.h"
#include "hsfolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

#define MAX_ITEM_OPEN 10

static LPCTSTR _GetURLTitleForDisplay(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf);

static BOOL _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (!_IsValid_IDPIDL(ppidl[i])  && !_IsValid_HEIPIDL(ppidl[i]))
            return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CHistItem Object
//
//////////////////////////////////////////////////////////////////////////////


CHistItem::CHistItem() 
{
}        

CHistItem::~CHistItem()
{
    if (_pHCFolder)
        _pHCFolder->Release();          // release the pointer to the sf
}

HRESULT CHistItem::Initialize(CHistFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres = CBaseItem::Initialize(hwnd, cidl, ppidl);
    if (SUCCEEDED(hres))
    {
        _pHCFolder = pHCFolder;
        _pHCFolder->AddRef();      // we're going to hold onto this pointer, so
    }
    return hres;
}        

HRESULT CHistItem_CreateInstance(CHistFolder *pHCFolder, HWND hwnd,
    UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;                 // null the out param

    if (!_ValidateIDListArray(cidl, ppidl))
        return E_FAIL;

    CHistItem *pHCItem = new CHistItem;
    if (pHCItem)
    {
        hr = pHCItem->Initialize(pHCFolder, hwnd, cidl, ppidl);
        if (SUCCEEDED(hr))
            hr = pHCItem->QueryInterface(riid, ppv);
        pHCItem->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CHistItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres = CBaseItem::QueryInterface(iid, ppv);

    if (FAILED(hres) && iid == IID_IHist) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

//////////////////////////////////
//
// IQueryInfo Methods
//
HRESULT CHistItem::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    return _pHCFolder->_GetInfoTip(_ppidl[0], dwFlags, ppwszTip);
}

//////////////////////////////////
//
// IContextMenu Methods
//
HRESULT CHistItem::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems;

    TraceMsg(DM_HSFOLDER, "hci - cm - QueryContextMenu() called.");
    
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
    {
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_URL_VERBSONLY, 0, indexMenu, 
            idCmdFirst, idCmdLast);
    
    }
    else  // (uFlags & CMF_NORMAL)
    {
        UINT idResource = POPUP_CACHECONTEXT_URL;

        // always use the cachecontext menu unless:
        if ( ((_pHCFolder->_uViewType == VIEWPIDL_ORDER_SITE) &&
              (_pHCFolder->_uViewDepth == 0))                      ||
             (!IsLeaf(_pHCFolder->_foldertype)) )
            idResource = POPUP_HISTORYCONTEXT_URL;

        cItems = MergePopupMenu(&hmenu, idResource, 0, indexMenu, idCmdFirst, idCmdLast);

        if (IsInetcplRestricted(L"History"))
        {
            DeleteMenu(hmenu, RSVIDM_DELCACHE + idCmdFirst, MF_BYCOMMAND);
            _SHPrettyMenu(hmenu);
        }
    }
    if (hmenu)
        SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

STDMETHODIMP CHistItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    DWORD dwAction;
    BOOL fCancelCopyAndOpen = FALSE;
    BOOL fZonesUI = FALSE;
    BOOL fMustFlushNotify = FALSE;
    BOOL fBulkDelete;

    TraceMsg(DM_HSFOLDER, "hci - cm - InvokeCommand() called.");

    if (idCmd == RSVIDM_DELCACHE)
    {
        TCHAR szBuff[INTERNET_MAX_URL_LENGTH+MAX_PATH];
        TCHAR szFormat[MAX_PATH];
                
        if (_cItems == 1)          
        {
            TCHAR szTitle[MAX_URL_STRING];

            if (_pHCFolder->_foldertype != FOLDER_TYPE_Hist)
            {
                _GetURLDispName((LPBASEPIDL)_ppidl[0], szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                FILETIME ftStart, ftEnd;
                LPCUTSTR pszIntervalName = _GetURLTitle(_ppidl[0]);

                if (SUCCEEDED(_ValueToIntervalW(pszIntervalName, &ftStart, &ftEnd)))
                {
                    GetDisplayNameForTimeInterval(&ftStart, &ftEnd, szTitle, ARRAYSIZE(szTitle));
                }
            }

            MLLoadString(IDS_WARN_DELETE_HISTORYITEM, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuff, ARRAYSIZE(szBuff), szFormat, szTitle);
        }
        else
        {
            MLLoadString(IDS_WARN_DELETE_MULTIHISTORY, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuff, ARRAYSIZE(szBuff), szFormat, _cItems);
        }
        if (DialogBoxParam(MLGetHinst(),
                             MAKEINTRESOURCE(DLG_HISTCACHE_WARNING),
                             pici->hwnd,
                             HistoryConfirmDeleteDlgProc,
                             (LPARAM)szBuff) != IDYES)
        {
            return S_FALSE;
        }
        return _pHCFolder->_DeleteItems(_ppidl, _cItems);
    }

    // ZONES SECURITY CHECK.
    //
    // We need to cycle through each action and Zone Check the URLs.
    // We pass NOUI when zone checking the URLs because we don't want info
    // displayed to the user.  We will stop when we find the first questionable
    // URL.  We will then 
    for (i = 0; (i < _cItems) && !fZonesUI; i++)
    {
        if (_ppidl[i]) 
        {
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if ((i < MAX_ITEM_OPEN) && _pHCFolder->_IsLeaf())
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_VERB))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_VERB;
                    }
                }
                break;

            case RSVIDM_COPY:
                if (_pHCFolder->_IsLeaf())
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_MOVE_OR_COPY))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_MOVE_OR_COPY;
                    }
                }
                break;
            }
        }
    }

    if (fZonesUI)
    {
        LPCTSTR pszUrl = _GetUrl(i-1);  // Sub 1 because of for loop above.
        if (S_OK != ZoneCheckUrl(pszUrl, dwAction, PUAF_DEFAULT|PUAF_WARN_IF_DENIED, NULL))
        {
            // The user cannot do this or does not want to do this.
            fCancelCopyAndOpen = TRUE;
        }
    }

    i = _cItems;

    // NOTE (andrewgu): ie5.5 b#108361
    // 1. on older versions of the shell, first deleting the items and then calling 
    //    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, _pHCFolder->_pidl, NULL) doesn't trigger a refresh;
    // 2. but deleting an item and then calling calling
    //    SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, ILCombine(_pHCFolder->_pidl, (LPITEMIDLIST)(_ppcei[i])), NULL) does;
    // 3. so the fix is to not set fBulkDelete on older versions of the shell.
    if (5 <= GetUIVersion())
        fBulkDelete = i > LOTS_OF_FILES;
    else
        fBulkDelete = FALSE;

    // fCancelCopyAndOpen happens if the user cannot or chose not to proceed.
    while (i && !fCancelCopyAndOpen)
    {
        i--;
        if (_ppidl[i]) 
        {

            switch (idCmd)
            {
            case RSVIDM_OPEN:
                ASSERT(!_pHCFolder->_uViewType);
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                if (!IsLeaf(_pHCFolder->_foldertype))
                {
                    LPITEMIDLIST pidlOpen;
                    
                    hres = S_FALSE;
                    pidlOpen = ILCombine(_pHCFolder->_pidl, _ppidl[i]);
                    if (pidlOpen)
                    {
                        IShellBrowser *psb = FileCabinet_GetIShellBrowser(_hwndOwner);
                        if (psb)
                        {
                            psb->AddRef();
                            psb->BrowseObject(pidlOpen, 
                                        (i==_cItems-1) ? SBSP_DEFBROWSER:SBSP_NEWBROWSER);
                            psb->Release();
                            hres = S_OK;
                        }
                        else
                        {
                            hres = _LaunchAppForPidl(pici->hwnd, pidlOpen);
                        }
                        ILFree(pidlOpen);
                    }
                }
                else
                {
                    TCHAR szDecoded[MAX_URL_STRING];
                    ConditionallyDecodeUTF8(_GetUrl(i), szDecoded, ARRAYSIZE(szDecoded));

                    hres = _LaunchApp(pici->hwnd, szDecoded);
                }
                break;

            case RSVIDM_ADDTOFAVORITES:
                hres = _AddToFavorites(i);
                goto Done;
            case RSVIDM_OPEN_NEWWINDOW:
                {
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        TCHAR szDecoded[MAX_URL_STRING];
                        ConditionallyDecodeUTF8(_GetUrl(i), szDecoded, ARRAYSIZE(szDecoded));
                        LPWSTR pwszTarget;
                    
                        if (SUCCEEDED((hres = SHStrDup(szDecoded, &pwszTarget)))) {
                            hres = NavToUrlUsingIEW(pwszTarget, TRUE);
                            CoTaskMemFree(pwszTarget);
                        }
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                    goto Done;
                }
            case RSVIDM_COPY:
                if (!_pHCFolder->_IsLeaf())
                {
                    hres = E_FAIL;
                }
                else
                {
                    OleSetClipboard((IDataObject *)this);
                }
                goto Done;

            case RSVIDM_DELCACHE:
                ASSERT(!_pHCFolder->_uViewType);                
//                if (IsHistory(_pHCFolder->_foldertype))
                hres = E_FAIL;
                break;

            case RSVIDM_PROPERTIES:
                // NOTE: We'll probably want to split this into two cases
                // and call a function in each case
                //
                if (IsLeaf(_pHCFolder->_foldertype))
                {
                    // this was a bug in IE4, too:
                    //   the pidl is re-created so that it has the most up-to-date information
                    //   possible -- this way we can avoid assuming that the NSC has cached the
                    //   most up-to-date pidl (which, in most cases, it hasn't)
                    LPHEIPIDL pidlTemp =
                        _pHCFolder->_CreateHCacheFolderPidlFromUrl(FALSE,
                            HPidlToSourceUrl( (LPBASEPIDL)_ppidl[i]));
                    if (pidlTemp) {
                        TCHAR szTitle[MAX_URL_STRING];
                        _GetURLTitleForDisplay((LPBASEPIDL)pidlTemp, szTitle, ARRAYSIZE(szTitle));
                        _CreatePropSheet(pici->hwnd, (LPCITEMIDLIST)pidlTemp,
                             DLG_HISTITEMPROP, _sPropDlgProc, szTitle);
                        LocalFree(pidlTemp);
                        pidlTemp = NULL;
                    }
                }
                else
                {
                    hres = E_FAIL;
                }
                goto Done;

            default:
                hres = E_FAIL;
                break;
            }
            
            ASSERT(SUCCEEDED(hres));
            if (FAILED(hres))
                TraceMsg(DM_HSFOLDER, "Cachevu failed the command at: %s", HPidlToSourceUrl((LPBASEPIDL)_ppidl[i]));
        }
    }
Done:
    if (fMustFlushNotify)
    {
        if (fBulkDelete)
        {
            ASSERT(!_pHCFolder->_uViewType);
            _GenerateEvent(SHCNE_UPDATEDIR, _pHCFolder->_pidl, NULL, NULL);
        }

        SHChangeNotifyHandleEvents();
    }
    return hres;
}

//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CHistItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, ARRAYSIZE(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfFileDescW) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptorW(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileDescA) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptorA(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileContents) && (pFEIn->tymed & TYMED_ISTREAM))
        hres = _CreateFileContents(pSTM, pFEIn->lindex);

    else if (pFEIn->cfFormat == CF_UNICODETEXT && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateUnicodeTEXT(pSTM);

    else if (pFEIn->cfFormat == CF_TEXT && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateHTEXT(pSTM);

    else if (pFEIn->cfFormat == g_cfURL && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateURL(pSTM);

    else if ((pFEIn->cfFormat == g_cfPreferredEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else
        hres = DATA_E_FORMATETC;
    return hres;
}

HRESULT CHistItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, ARRAYSIZE(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - QueryGetData(%s)", szName);
#endif

    if (pFEIn->cfFormat == g_cfFileDescW ||
        pFEIn->cfFormat == g_cfFileDescA ||
        pFEIn->cfFormat == g_cfFileContents   ||
        pFEIn->cfFormat == g_cfURL            ||
        pFEIn->cfFormat == CF_UNICODETEXT     ||
        pFEIn->cfFormat == CF_TEXT            ||
        pFEIn->cfFormat == g_cfPreferredEffect)
    {
        TraceMsg(DM_HSFOLDER, "		   format supported.");
        return NOERROR;
    }
    return S_FALSE;
}

HRESULT CHistItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC Histfmte[] = {
        {g_cfFileDescW,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfFileDescA,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfFileContents,    NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
        {g_cfURL,             NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_UNICODETEXT,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_TEXT,             NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfPreferredEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(Histfmte), Histfmte, ppEnum);
}

//////////////////////////////////
//
// IExtractIconA Methods...
//
HRESULT CHistItem::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    int cbIcon;

    if (_pHCFolder->_uViewType) {
        switch (_pHCFolder->_uViewType) {
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ:
        case VIEWPIDL_ORDER_TODAY:
            cbIcon = IDI_HISTURL;
            break;
        case VIEWPIDL_ORDER_SITE:
            switch(_pHCFolder->_uViewDepth) {
            case 0: cbIcon = (uFlags & GIL_OPENICON) ? IDI_HISTOPEN:IDI_HISTFOLDER; break;
            case 1: cbIcon = IDI_HISTURL; break;
            }
            break;
        default:
            return E_FAIL;
        }
    }
    else {
        switch (_pHCFolder->_foldertype)
        {
        case FOLDER_TYPE_Hist:
            cbIcon = IDI_HISTWEEK;
            break;
        case FOLDER_TYPE_HistInterval:
            cbIcon = (uFlags & GIL_OPENICON) ? IDI_HISTOPEN:IDI_HISTFOLDER;
            break;
        case FOLDER_TYPE_HistDomain:
            cbIcon = IDI_HISTURL;
            break;
        default:
            return E_FAIL;
        }
    }
    *puFlags = 0;
    *pniIcon = -cbIcon;
    StrCpyNA(pszIconFile, "shdocvw.dll", ucchMax);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

UNALIGNED const TCHAR* _GetURLTitle(LPBASEPIDL pcei)
{
    if (pcei->usSign == HEIPIDL_SIGN)
    {
        LPHEIPIDL phei = (LPHEIPIDL) pcei;

        if (phei->usTitle == 0)
        {
            const TCHAR* psz = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pcei));

            return psz ? _FindURLFileName(psz) : TEXT("");
        }
        else
        {
            return (LPTSTR)(((BYTE*)phei)+phei->usTitle);
        }
    }
    else if (VALID_IDSIGN(pcei->usSign))
    {
        return ((LPHIDPIDL)pcei)->szID;
    }
    else 
    {
        return TEXT("");
    }
}    

static LPCTSTR _GetURLTitleForDisplay(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf)
{
    TCHAR szTitle[MAX_URL_STRING];
    if (!_URLTitleIsURL(pcei) ||
        FAILED(PrepareURLForDisplayUTF8(_GetURLTitleAlign(pcei, szTitle, ARRAYSIZE(szTitle)), szBuf, &cchBuf, TRUE)))
    {
        ualstrcpyn(szBuf, _GetURLTitle(pcei), cchBuf);
    }
        
    return szBuf;
}

UNALIGNED const TCHAR* CHistItem::_GetURLTitle(LPCITEMIDLIST pidl)
{
    return ::_GetURLTitle( (LPBASEPIDL)pidl);
}

LPCTSTR CHistItem::_GetUrl(int nIndex)
{
    return _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)_ppidl[nIndex]));
}

LPCTSTR CHistItem::_PidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return HPidlToSourceUrl((LPBASEPIDL) pidl);
}


// Return value:
//               TRUE - URL is Safe.
//               FALSE - URL is questionable and needs to be re-zone checked w/o PUAF_NOUI.
BOOL CHistItem::_ZoneCheck(int nIndex, DWORD dwUrlAction)
{
    LPCTSTR pszUrl = _GetUrl(nIndex);

    // Yes, then consider anything that is not
    // a FILE URL safe.

    int nScheme = GetUrlScheme(pszUrl);
    if (URL_SCHEME_FILE != nScheme)
        return TRUE;        // It's safe because it's not a file URL.

    if (S_OK != ZoneCheckUrl(pszUrl, dwUrlAction, PUAF_NOUI, NULL))
        return FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CHistItem::_sPropDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPHEIPIDL phei = lpPropSheet ? (LPHEIPIDL)lpPropSheet->lParam : NULL;

    switch(message) {

        case WM_INITDIALOG:
        {
            SHFILEINFO sfi;
            TCHAR szBuf[80];
            TCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            phei = (LPHEIPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

            SHGetFileInfo(TEXT(".url"), 0, &sfi, SIZEOF(sfi), SHGFI_ICON |
                SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_TYPENAME);

            SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0);

            _GetURLTitleForDisplay((LPBASEPIDL)phei, szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            SetDlgItemText(hDlg, IDD_TITLE, szDisplayUrl);
            
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);
            
            ConditionallyDecodeUTF8(_GetUrlForPidl((LPCITEMIDLIST)phei), szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            SetDlgItemText(hDlg, IDD_INTERNET_ADDRESS, szDisplayUrl);

            FileTimeToDateTimeStringInternal(&phei->ftLastVisited, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_VISITED, szBuf);

            // It looks like the hitcount is double what it is supposed to be
            //  (ie - navigate to a site and hitcount += 2)
            // For now, we'll just half the hitcount before we display it:

            // Above statement is no longer true -- hitcount is correct.  Removed the halving of hitcount.
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d"), (phei->dwNumHits)) ;
            SetDlgItemText(hDlg, IDD_NUMHITS, szBuf);

            break;            
        }
        
        
        case WM_DESTROY:
            {
                HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_GETICON, 0, 0);
                if (hIcon)
                    DestroyIcon(hIcon);
            }
            break;

        case WM_COMMAND:
        case WM_HELP:
        case WM_CONTEXTMENU:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

HRESULT CHistItem::_CreateFileDescriptorW(LPSTGMEDIUM pSTM)
{
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    FILEGROUPDESCRIPTORW *pfgd = (FILEGROUPDESCRIPTORW*)GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTORW) + (_cItems-1) * sizeof(FILEDESCRIPTORW));
    if (pfgd == NULL)
    {
        TraceMsg(DM_HSFOLDER, "hci -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    
    pfgd->cItems = _cItems;     // set the number of items

    for (UINT i = 0; i < _cItems; i++)
    {
        FILEDESCRIPTORW *pfd = &(pfgd->fgd[i]);
        
        _GetURLTitleForDisplay((LPBASEPIDL)_ppidl[i], pfd->cFileName, ARRAYSIZE(pfd->cFileName));
        
        MakeLegalFilenameW(pfd->cFileName);

        UINT cchFilename = lstrlenW(pfd->cFileName);
        SHTCharToUnicode(L".URL", pfd->cFileName+cchFilename, ARRAYSIZE(pfd->cFileName)-cchFilename);
    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\hsfolder.cpp ===
#include "local.h"

#include "resource.h"
#include "cachesrch.h"
#include "sfview.h"
#include <shlwapi.h>
#include <limits.h>
#include "chcommon.h"
#include "hsfolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

#define DM_CACHESEARCH 0x40000000

const TCHAR c_szRegKeyTopNSites[] = TEXT("HistoryTopNSitesView");
#define REGKEYTOPNSITESLEN (ARRAYSIZE(c_szRegKeyTopNSites) - 1)

const TCHAR c_szHistPrefix[] = TEXT("Visited: ");
#define HISTPREFIXLEN (ARRAYSIZE(c_szHistPrefix)-1)
const TCHAR c_szHostPrefix[] = TEXT(":Host: ");
#define HOSTPREFIXLEN (ARRAYSIZE(c_szHostPrefix)-1)
const CHAR c_szIntervalPrefix[] = "MSHist";
#define INTERVALPREFIXLEN (ARRAYSIZE(c_szIntervalPrefix)-1)
const TCHAR c_szTextHeader[] = TEXT("Content-type: text/");
#define TEXTHEADERLEN (ARRAYSIZE(c_szTextHeader) - 1)
const TCHAR c_szHTML[] = TEXT("html");
#define HTMLLEN (ARRAYSIZE(c_szHTML) - 1)
#define TYPICAL_INTERVALS (4+7)


#define ALL_CHANGES (SHCNE_DELETE|SHCNE_MKDIR|SHCNE_RMDIR|SHCNE_CREATE|SHCNE_UPDATEDIR)

#define FORMAT_PARAMS (FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_MAX_WIDTH_MASK)

DWORD     _DaysInInterval(HSFINTERVAL *pInterval);
void      _KeyForInterval(HSFINTERVAL *pInterval, LPTSTR pszInterval, int cchInterval);
void      _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days);

//  BEGIN OF JCORDELL CODE
#define QUANTA_IN_A_SECOND  10000000
#define SECONDS_IN_A_DAY    60 * 60 * 24
#define QUANTA_IN_A_DAY     ((__int64) QUANTA_IN_A_SECOND * SECONDS_IN_A_DAY)
#define INT64_VALUE(pFT)    ((((__int64)(pFT)->dwHighDateTime) << 32) + (__int64) (pFT)->dwLowDateTime)
#define DAYS_DIFF(s,e)      ((int) (( INT64_VALUE(s) - INT64_VALUE(e) ) / QUANTA_IN_A_DAY))

BOOL      GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                         TCHAR *pszBuffer, int cchBuffer);
BOOL      GetTooltipForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                     TCHAR *pszBuffer, int cchBuffer);
//  END OF JCORDELL CODE


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderView Functions and Definitions
//
//////////////////////////////////////////////////////////////////////////////


////////////////////////
//
// Column definition for the Cache Folder DefView
//
enum {
    ICOLC_URL_SHORTNAME = 0,
    ICOLC_URL_NAME,
    ICOLC_URL_TYPE,
    ICOLC_URL_SIZE,
    ICOLC_URL_EXPIRES,
    ICOLC_URL_MODIFIED,
    ICOLC_URL_ACCESSED,
    ICOLC_URL_LASTSYNCED,
    ICOLC_URL_MAX         // Make sure this is the last enum item
};


typedef struct _COLSPEC
{
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} COLSPEC;

const COLSPEC s_HistIntervalFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_TIMEPERIOD_COL,           30, LVCFMT_LEFT},
};

const COLSPEC s_HistHostFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_HOSTNAME_COL,           30, LVCFMT_LEFT},
};

const COLSPEC s_HistFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_NAME_COL,           30, LVCFMT_LEFT},
    {ICOLH_URL_TITLE,         IDS_TITLE_COL,          30, LVCFMT_LEFT},
    {ICOLH_URL_LASTVISITED,   IDS_LASTVISITED_COL,    18, LVCFMT_LEFT},
};

//////////////////////////////////////////////////////////////////////

HRESULT CreateSpecialViewPidl(USHORT usViewType, LPITEMIDLIST* ppidlOut, UINT cbExtra = 0, LPBYTE *ppbExtra = NULL);

HRESULT ConvertStandardHistPidlToSpecialViewPidl(LPCITEMIDLIST pidlStandardHist,
                                                 USHORT        usViewType,
                                                 LPITEMIDLIST *ppidlOut);

#define IS_DIGIT_CHAR(x) (((x) >= '0') && ((x) <= '9'))
#define MIN_MM(x, y)     (((x) < (y)) ? (x) : (y))
// _GetHostImportantPart:
//     IN:   pszHost -- a domain: for example, "www.wisc.edu"
//  IN/      puLen    -- the length of pszHost
//     OUT:  puLen    -- the length of the new string
// RETURNS:  The "important part" of a hostname (e.g. wisc)
//
// Another example:  "www.foo.co.uk" ==> "foo"

LPTSTR _GetHostImportantPart(LPTSTR pszHost, UINT *puLen) 
{
    LPTSTR pszCurEndHostStr = pszHost + (*puLen - 1);
    LPTSTR pszDomainBegin   = pszHost;
    LPTSTR pszSuffix, pszSuffix2;
    UINT  uSuffixLen;
    BOOL  fIsIP = FALSE;
    LPTSTR pszTemp;
    
    ASSERT(((UINT)lstrlen(pszHost)) == *puLen);
    if (*puLen == 0)
        return pszHost;

    // Filter out IP Addresses
    // Heurisitc: Everything after the last "dot"
    //  has to be a number.
    for (pszTemp = (pszHost + *puLen - 1);
         pszTemp >= pszHost; --pszTemp)
    {
        if (*pszTemp == '.')
            break;
        if (IS_DIGIT_CHAR(*pszTemp))
            fIsIP = TRUE;
        else
            break;
    }

    if (!fIsIP) {
        // Now that we have the url we can strip 
        if ( ((StrCmpNI(TEXT("www."), pszHost, 4)) == 0) ||
             ((StrCmpNI(TEXT("ftp."), pszHost, 4)) == 0) )
            pszDomainBegin += 4;
        
        // try to strip out the suffix by finding the last "dot"
        if ((pszSuffix = StrRChr(pszHost, pszCurEndHostStr, '.')) &&
            (pszSuffix > pszDomainBegin)                          &&
            ((uSuffixLen = (UINT)(pszCurEndHostStr - pszSuffix)) <= 3)) {
            // if it is before a two character country code then try
            //  to rip off some more.
            if ( (uSuffixLen <= 2)                                          &&
                 (pszSuffix2 = StrRChr(pszDomainBegin, pszSuffix - 1, '.')) &&
                 (pszSuffix2 > pszDomainBegin)                              &&
                 ((pszSuffix - pszSuffix2) <= 4) )
                pszSuffix = pszSuffix2;
        }
        else
            pszSuffix = pszCurEndHostStr + 1;
        
        *puLen = (UINT)(pszSuffix-pszDomainBegin);
    }
    return pszDomainBegin;
}

// a utility function for CHistFolder::GetDisplayNameOf
void _GetURLDispName(LPBASEPIDL pcei, LPTSTR pszName, UINT cchName) 
{
    TCHAR szStr[MAX_PATH];
    UINT uHostLen, uImportantPartLen;
    static TCHAR szBracketFmt[8] = TEXT("");  // " (%s)" with room for 0253 complex script marker char

    ualstrcpyn(szStr, _GetURLTitle(pcei), ARRAYSIZE(szStr));

    uImportantPartLen = uHostLen = lstrlen(szStr);

    StrCpyN(pszName, _GetHostImportantPart(szStr, &uImportantPartLen), MIN_MM(uImportantPartLen + 1, cchName));

    // don't add extra bit on the end if we haven't modified the string
    if (uImportantPartLen != uHostLen && uImportantPartLen < cchName) 
    {
        if (!szBracketFmt[0]) 
        {
            MLLoadString(IDS_HISTHOST_FMT, szBracketFmt, ARRAYSIZE(szBracketFmt));
        }
        
        wnsprintf(pszName + uImportantPartLen, cchName - uImportantPartLen, szBracketFmt, szStr);
    }
}


HRESULT HistFolderView_MergeMenu(UINT idMenu, LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(idMenu));
    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return S_OK;
}

HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect)
{
    if (dwEffect & DROPEFFECT_MOVE)
    {
        CHistItem *pHCItem;
        BOOL fBulkDelete;

        if (SUCCEEDED(pdo->QueryInterface(IID_IHist, (void **)&pHCItem)))
        {
            fBulkDelete = pHCItem->_cItems > LOTS_OF_FILES;
            for (UINT i = 0; i < pHCItem->_cItems; i++)
            {
                if (DeleteUrlCacheEntry(HPidlToSourceUrl((LPBASEPIDL)pHCItem->_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, pHCItem->_pHCFolder->_pidl, pHCItem->_ppidl[i], NULL);
                    }
                }
            }
            if (fBulkDelete)
            {
                _GenerateEvent(SHCNE_UPDATEDIR, pHCItem->_pHCFolder->_pidl, NULL, NULL);
            }
            SHChangeNotifyHandleEvents();
            pHCItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

// There are copies of exactly this function in SHELL32
// Add the File Type page
HRESULT HistFolderView_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA * ppagedata)
{
    IShellPropSheetExt * pspse;
    HRESULT hr = CoCreateInstance(CLSID_FileTypes, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellPropSheetExt, &pspse));
    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
        pspse->Release();
    }
    return hr;
}

HRESULT HistFolderView_OnGetSortDefaults(FOLDER_TYPE FolderType, int * piDirection, int * plParamSort)
{
    *plParamSort = (int)ICOLH_URL_LASTVISITED;
    *piDirection = 1;
    return S_OK;
}

HRESULT CALLBACK CHistFolder::_sViewCallback(IShellView *psv, IShellFolder *psf,
     HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHistFolder *pfolder = NULL;

    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    {
        TCHAR szText[MAX_PATH];

        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        LPTSTR pszBuf = (LPTSTR)lParam;

        MLLoadString(id + IDS_MH_FIRST, szText, ARRAYSIZE(szText));

        // we know for a fact that this parameter is really a TCHAR
        if ( IsOS( OS_NT ))
        {
            SHTCharToUnicode( szText, (LPWSTR) pszBuf, cchBuf );
        }
        else
        {
            SHTCharToAnsi( szText, (LPSTR) pszBuf, cchBuf );
        }
        break;
    }

    case SFVM_GETNOTIFY:
        hr = psf->QueryInterface(CLSID_HistFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            *(LPCITEMIDLIST*)wParam = pfolder->_pidl;   // evil alias
            pfolder->Release();
        }
        else
            wParam = 0;
        *(LONG*)lParam = ALL_CHANGES;
        break;

    case DVM_DIDDRAGDROP:
        hr = HistFolderView_DidDragDrop((IDataObject *)lParam, (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hr = S_OK;
        break;

    case DVM_INVOKECOMMAND:
        _ArrangeFolder(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        ShellFolderView_ReArrange(hwnd, (UINT)wParam);
        hr = S_OK;
        break;

    case DVM_MERGEMENU:
        hr = HistFolderView_MergeMenu(MENU_HISTORY, (LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = HistFolderView_OnAddPropertyPages((DWORD)wParam, (SFVM_PROPPAGE_DATA *)lParam);
        break;

    case SFVM_GETSORTDEFAULTS:
        hr = psf->QueryInterface(CLSID_HistFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            hr = HistFolderView_OnGetSortDefaults(pfolder->_foldertype, (int *)wParam, (int *)lParam);
            pfolder->Release();
        }
        else
        {
            wParam = 0;
            lParam = 0;
        }
        break;

    case SFVM_UPDATESTATUSBAR:
        ResizeStatusBar(hwnd, FALSE);
        // We did not set any text; let defview do it
        hr = E_NOTIMPL;
        break;

    case SFVM_SIZE:
        ResizeStatusBar(hwnd, FALSE);
        break;

    case SFVM_GETPANE:
        if (wParam == PANE_ZONE)
            *(DWORD*)lParam = 1;
        else
            *(DWORD*)lParam = PANE_NONE;

        break;
    case SFVM_WINDOWCREATED:
        ResizeStatusBar(hwnd, TRUE);
        break;

    case SFVM_GETZONE:
        *(DWORD*)lParam = URLZONE_LOCAL_MACHINE; // Internet by default
        break;

    default:
        hr = E_FAIL;
    }

    return hr;
}

HRESULT HistFolderView_CreateInstance(CHistFolder *pHCFolder, void **ppv)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pHCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pHCFolder->_pidl;
    csfv.lEvents = SHCNE_DELETE; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = CHistFolder::_sViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppv);
}



//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

CHistFolderEnum::CHistFolderEnum(DWORD grfFlags, CHistFolder *pHCFolder)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CHistFolderEnum() called");
    _cRef = 1;
    DllAddRef();

    _grfFlags = grfFlags,
    _pHCFolder = pHCFolder;
    pHCFolder->AddRef();
    ASSERT(_hEnum             == NULL &&
           _cbCurrentInterval == 0    &&
           _cbIntervals       == 0    &&
           _pshHashTable      == NULL &&
           _polFrequentPages  == NULL &&
           _pIntervalCache    == NULL);

}

CHistFolderEnum::~CHistFolderEnum()
{
    ASSERT(_cRef == 0);         // we should always have a zero ref count here
    TraceMsg(DM_HSFOLDER, "hcfe - ~CHistFolderEnum() called.");
    _pHCFolder->Release();
    if (_pceiWorking)
    {
        LocalFree(_pceiWorking);
        _pceiWorking = NULL;
    }
    if (_pIntervalCache)
    {
        LocalFree(_pIntervalCache);
        _pIntervalCache = NULL;
    }

    if (_hEnum)
    {
        FindCloseUrlCache(_hEnum);
        _hEnum = NULL;
    }
    if (_pshHashTable)
        delete _pshHashTable;
    if (_polFrequentPages)
        delete _polFrequentPages;
    if (_pstatenum)
        _pstatenum->Release();
    DllRelease();
}


HRESULT CHistFolderEnum_CreateInstance(DWORD grfFlags, CHistFolder *pHCFolder, IEnumIDList **ppeidl)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CreateInstance() called.");

    *ppeidl = NULL;                 // null the out param

    CHistFolderEnum *pHCFE = new CHistFolderEnum(grfFlags, pHCFolder);
    if (!pHCFE)
        return E_OUTOFMEMORY;

    *ppeidl = pHCFE;

    return S_OK;
}

HRESULT CHistFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CHistFolderEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHistFolderEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistFolderEnum::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CHistFolderEnum::_NextHistInterval(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPBASEPIDL pcei = NULL;
    TCHAR szCurrentInterval[INTERVAL_SIZE+1];

    //  chrisfra 3/27/97 on NT cache files are per user, not so on win95.  how do
    //  we manage containers on win95 if different users are specified different history
    //  intervals

    if (0 == _cbCurrentInterval)
    {
        hr = _pHCFolder->_ValidateIntervalCache();
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            ENTERCRITICAL;
            if (_pIntervalCache)
            {
                LocalFree(_pIntervalCache);
                _pIntervalCache = NULL;
            }
            if (_pHCFolder->_pIntervalCache)
            {
                _pIntervalCache = (HSFINTERVAL *)LocalAlloc(LPTR,
                                                            _pHCFolder->_cbIntervals*sizeof(HSFINTERVAL));
                if (_pIntervalCache == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _cbIntervals = _pHCFolder->_cbIntervals;
                    CopyMemory(_pIntervalCache,
                               _pHCFolder->_pIntervalCache,
                               _cbIntervals*sizeof(HSFINTERVAL));
                }
            }
            LEAVECRITICAL;
        }
    }

    if (_pIntervalCache && _cbCurrentInterval < _cbIntervals)
    {
        _KeyForInterval(&_pIntervalCache[_cbCurrentInterval], szCurrentInterval,
                        ARRAYSIZE(szCurrentInterval));
        pcei = _CreateIdCacheFolderPidl(TRUE,
                                        _pIntervalCache[_cbCurrentInterval].usSign,
                                        szCurrentInterval);
        _cbCurrentInterval++;
    }
    if (pcei)
    {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched) *pceltFetched = 1;
    }
    else
    {
        if (pceltFetched) *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    return hr;
}

// This function dispatches the different "views" on History that are possible
HRESULT CHistFolderEnum::_NextViewPart(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    switch(_pHCFolder->_uViewType) {
    case VIEWPIDL_SEARCH:
        return _NextViewPart_OrderSearch(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_TODAY:
        return _NextViewPart_OrderToday(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_SITE:
        return _NextViewPart_OrderSite(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_FREQ:
        return _NextViewPart_OrderFreq(celt, rgelt, pceltFetched);
    default:
        return E_NOTIMPL;
    }
}

LPITEMIDLIST _Combine_ViewPidl(USHORT usViewType, LPITEMIDLIST pidl);

// This function wraps wininet's Find(First/Next)UrlCacheEntry API
// returns DWERROR code or zero if successful
DWORD _FindURLCacheEntry(IN LPCTSTR                          pszCachePrefix,
                         IN OUT LPINTERNET_CACHE_ENTRY_INFO  pcei,
                         IN OUT HANDLE                      &hEnum,
                         IN OUT LPDWORD                      pdwBuffSize)
{
    if (!hEnum)
    {
        if (! (hEnum = FindFirstUrlCacheEntry(pszCachePrefix, pcei, pdwBuffSize)) )
            return GetLastError();
    }
    else if (!FindNextUrlCacheEntry(hEnum, pcei, pdwBuffSize))
        return GetLastError();
    return S_OK;
}

// Thie function provides an iterator over all entries in all (MSHIST-type) buckets
//   in the cache
DWORD _FindURLFlatCacheEntry(IN HSFINTERVAL *pIntervalCache,
                             IN LPTSTR       pszUserName,       // filter out cache entries owned by user
                             IN BOOL         fHostEntry,        // retrieve host entries only (FALSE), or no host entries (TRUE)
                             IN OUT int     &cbCurrentInterval, // should begin at the maximum number of intervals
                             IN OUT LPINTERNET_CACHE_ENTRY_INFO  pcei,
                             IN OUT HANDLE  &hEnum,
                             IN OUT LPDWORD  pdwBuffSize
                             )
{
    DWORD dwStoreBuffSize = *pdwBuffSize;
    DWORD dwResult        = ERROR_NO_MORE_ITEMS;
    while (cbCurrentInterval >= 0) 
    {
        if ((dwResult = _FindURLCacheEntry(pIntervalCache[cbCurrentInterval].szPrefix,
                                           pcei, hEnum, pdwBuffSize)) != S_OK)
        {
            if (dwResult == ERROR_NO_MORE_ITEMS) 
            {
                // This bucket is done, now go get the next one
                FindCloseUrlCache(hEnum);
                hEnum = NULL;
                --cbCurrentInterval;
            }
            else
                break;
        }
        else
        {
            // Do requested filtering...
            BOOL fIsHost = (StrStr(pcei->lpszSourceUrlName, c_szHostPrefix) == NULL);
            if ( ((!pszUserName) ||  // if requested, filter username
                  _FilterUserName(pcei, pIntervalCache[cbCurrentInterval].szPrefix, pszUserName)) &&
                 ((!fHostEntry && !fIsHost) ||  // filter for host entries
                  (fHostEntry  && fIsHost))    )
            {
                break;
            }
        }
        // reset for next iteration
        *pdwBuffSize = dwStoreBuffSize;
    }
    return dwResult;
}

// This guy will search the flat cache (MSHist buckets) for a particular URL
//  * This function assumes that the Interval cache is good and loaded
// RETURNS: Windows Error code
DWORD CHistFolder::_SearchFlatCacheForUrl(LPCTSTR pszUrl, LPINTERNET_CACHE_ENTRY_INFO pcei, LPDWORD pdwBuffSize)
{
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD dwUserNameLen = ARRAYSIZE(szUserName);

    if (FAILED(_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    UINT   uSuffixLen     = lstrlen(pszUrl) + lstrlen(szUserName) + 1; // extra 1 for '@'
    LPTSTR pszPrefixedUrl = ((LPTSTR)LocalAlloc(LPTR, (PREFIX_SIZE + uSuffixLen + 1) * sizeof(TCHAR)));
    DWORD  dwError        = ERROR_FILE_NOT_FOUND;

    if (pszPrefixedUrl != NULL)
    {
        // pszPrefixedUrl will have the format of "PREFIX username@
        wnsprintf(pszPrefixedUrl + PREFIX_SIZE, uSuffixLen + 1, TEXT("%s@%s"), szUserName, pszUrl);

        for (int i =_cbIntervals - 1; i >= 0; --i) 
        {
            // memcpy doesn't null terminate
            memcpy(pszPrefixedUrl, _pIntervalCache[i].szPrefix, PREFIX_SIZE * sizeof(TCHAR));
            if (GetUrlCacheEntryInfo(pszPrefixedUrl, pcei, pdwBuffSize)) 
            {
                dwError = ERROR_SUCCESS;
                break;
            }
            else if ( ((dwError = GetLastError()) != ERROR_FILE_NOT_FOUND) ) 
            {
                break;
            }
        }

        LocalFree(pszPrefixedUrl);
        pszPrefixedUrl = NULL;
    }
    else
    {
        dwError = ERROR_OUTOFMEMORY;
    }
    
    return dwError;
}

//////////////////////////////////////////////////////////////////////
//  Most Frequently Visited Sites;

// this structure is used by the enumeration of the cache
//   to get the most frequently seen sites
class OrderList_CacheElement : public OrderedList::Element 
{
public:
    LPTSTR    pszUrl;
    DWORD     dwHitRate;
    __int64   llPriority;
    int       nDaysSinceLastHit;
    LPSTATURL lpSTATURL;

    static   FILETIME ftToday;
    static   BOOL     fInited;

    OrderList_CacheElement(LPTSTR pszStr, DWORD dwHR, LPSTATURL lpSU) 
    {
        s_initToday();
        ASSERT(pszStr);
        pszUrl         = (pszStr ? StrDup(pszStr) : StrDup(TEXT("")));
        dwHitRate      = dwHR;
        lpSTATURL      = lpSU;

        nDaysSinceLastHit = DAYS_DIFF(&ftToday, &(lpSTATURL->ftLastVisited));

        // prevent division by zero
        if (nDaysSinceLastHit < 0)
            nDaysSinceLastHit = 0;
        // scale division up by a little less than half of the __int64
        llPriority  = ((((__int64)dwHitRate) * LONG_MAX) /
                       ((__int64)(nDaysSinceLastHit + 1)));
        //dPriority  = ((double)dwHitRate / (double)(nDaysSinceLastHit + 1));
    }

    virtual int compareWith(OrderedList::Element *pelt) 
    {
        OrderList_CacheElement *polce;
        if (pelt) 
        {
            polce = reinterpret_cast<OrderList_CacheElement *>(pelt);
            // we're cheating here a bit by returning 1 instead of testing
            //   for equality, but that's ok...
            //            return ( (dwHitRate < polce->dwHitRate) ? -1 : 1 );
            return ( (llPriority < polce->llPriority) ? -1 : 1 );
        }
        return 0;
    }

    virtual ~OrderList_CacheElement() 
    {
        if (pszUrl)
        {
            LocalFree(pszUrl);
            pszUrl = NULL;
        }

        if (lpSTATURL) 
        {
            if (lpSTATURL->pwcsUrl)
                OleFree(lpSTATURL->pwcsUrl);
            if (lpSTATURL->pwcsTitle)
                OleFree(lpSTATURL->pwcsTitle);
            delete lpSTATURL;
        }
    }

    /*
    friend ostream& operator<<(ostream& os, OrderList_CacheElement& olce) {
        os << " (" << olce.dwHitRate << "; " << olce.nDaysSinceLastHit
           << " days; pri=" << olce.llPriority << ") " << olce.pszUrl;
        return os;
    }
    */

    static void s_initToday() 
    {
        if (!fInited) 
        {
            SYSTEMTIME sysTime;
            GetLocalTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &ftToday);
            fInited = TRUE;
        }
    }
};

FILETIME OrderList_CacheElement::ftToday;
BOOL OrderList_CacheElement::fInited = FALSE;

// caller must delete OrderedList
OrderedList* CHistFolderEnum::_GetMostFrequentPages()
{
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;
    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT       uUserNameLen = lstrlen(szUserName);

    // reinit the current time
    OrderList_CacheElement::fInited = FALSE;
    IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
    OrderedList     *pol         = NULL;

    if (pUrlHistStg)
    {
        IEnumSTATURL *penum = NULL;
        if (SUCCEEDED(pUrlHistStg->EnumUrls(&penum)) && penum)
        {
            DWORD dwSites = -1;
            DWORD dwType  = REG_DWORD;
            DWORD dwSize  = sizeof(DWORD);

            EVAL(SHRegGetUSValue(REGSTR_PATH_MAIN, c_szRegKeyTopNSites, &dwType,
                                 (void *)&dwSites, &dwSize, FALSE,
                                 (void *)&dwSites, dwSize) == ERROR_SUCCESS);

            if ( (dwType != REG_DWORD)     ||
                 (dwSize != sizeof(DWORD)) ||
                 ((int)dwSites < 0) )
            {
                dwSites = NUM_TOP_SITES;
                SHRegSetUSValue(REGSTR_PATH_MAIN, c_szRegKeyTopNSites, REG_DWORD,
                                (void *)&dwSites, dwSize, SHREGSET_HKCU);

                dwSites = NUM_TOP_SITES;
            }

            pol = new OrderedList(dwSites);
            if (pol)
            {
                STATURL *psuThis = new STATURL;
                if (psuThis)
                {
                    penum->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL);

                    while (pol) {
                        psuThis->cbSize    = sizeof(STATURL);
                        psuThis->pwcsUrl   = NULL;
                        psuThis->pwcsTitle = NULL;

                        ULONG   cFetched;

                        if (SUCCEEDED(penum->Next(1, psuThis, &cFetched)) && cFetched)
                        {
                            // test: the url (taken from the VISITED history bucket) is a "top-level"
                            //  url that would be in the MSHIST (displayed to user) history bucket
                            //  things ommitted will be certain error urls and frame children pages etc...
                            if ( (psuThis->dwFlags & STATURLFLAG_ISTOPLEVEL) &&
                                 (psuThis->pwcsUrl)                          &&
                                 (!IsErrorUrl(psuThis->pwcsUrl)) )
                            {
                                UINT   uUrlLen        = lstrlenW(psuThis->pwcsUrl);
                                UINT   uPrefixLen     = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                                LPTSTR pszPrefixedUrl =
                                    ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + uPrefixLen + 1) * sizeof(TCHAR)));
                                if (pszPrefixedUrl)
                                {
                                    wnsprintf(pszPrefixedUrl, uPrefixLen + 1 , TEXT("%s%s@"), c_szHistPrefix, szUserName);

                                    StrCpyN(pszPrefixedUrl + uPrefixLen, psuThis->pwcsUrl, uUrlLen + 1);

                                    PROPVARIANT vProp = {0};
                                    if (SUCCEEDED(pUrlHistStg->GetProperty(pszPrefixedUrl + uPrefixLen,
                                                                           PID_INTSITE_VISITCOUNT, &vProp)) &&
                                        (vProp.vt == VT_UI4))
                                    {
                                        pol->insert(new OrderList_CacheElement(pszPrefixedUrl,
                                                                               vProp.lVal,
                                                                               psuThis));
                                        // OrderList now owns this -- he'll free it
                                        psuThis = new STATURL;
                                        if (psuThis)
                                        {
                                            psuThis->cbSize    = sizeof(STATURL);
                                            psuThis->pwcsUrl   = NULL;
                                            psuThis->pwcsTitle = NULL;
                                        }
                                        else if (pol) {
                                            delete pol;
                                            pol = NULL;
                                        }
                                    }

                                    LocalFree(pszPrefixedUrl);
                                    pszPrefixedUrl = NULL;
                                }
                                else if (pol)
                                { // couldn't allocate
                                    delete pol;
                                    pol = NULL;
                                }
                            }
                            if (psuThis && psuThis->pwcsUrl)
                                OleFree(psuThis->pwcsUrl);

                            if (psuThis && psuThis->pwcsTitle)
                                OleFree(psuThis->pwcsTitle);
                        }
                        else // nothing more from the enumeration...
                            break;
                    } //while
                    if (psuThis)
                        delete psuThis;
                }
                else if (pol) { //allocation failed
                    delete pol;
                    pol = NULL;
                }
            }
            penum->Release();
        }
        /*    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;
              DWORD dwError; */

        // This commented-out code does the same thing WITHOUT going through
        //  the IUrlHistoryPriv interface, but, instead going directly
        //  to wininet
        /*
          while ((dwError = _FindURLCacheEntry(c_szHistPrefix, _pceiWorking,
          _hEnum, &dwBuffSize)) == S_OK) {
          // if its a top-level history guy && is cache entry to valid username
          if ( (((HISTDATA *)_pceiWorking->lpHeaderInfo)->dwFlags & PIDISF_HISTORY) && //top-level
          (_FilterUserName(_pceiWorking, c_szHistPrefix, szUserName)) ) // username is good
          {
          // perf:  we can avoid needlessly creating new cache elements if we're less lazy
          pol->insert(new OrderList_CacheElement(_pceiWorking->lpszSourceUrlName,
          _pceiWorking->dwHitRate,
          _pceiWorking->LastModifiedTime));
          }
          dwBuffSize = MAX_URLCACHE_ENTRY;
          }
          ASSERT(dwError == ERROR_NO_MORE_ITEMS);
          */
        pUrlHistStg->Release();
    } // no storage

    return pol;
}

HRESULT CHistFolderEnum::_NextViewPart_OrderFreq(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = E_INVALIDARG;

    if ( (!_polFrequentPages) && (!(_polFrequentPages = _GetMostFrequentPages())) )
        return E_FAIL;

    if (rgelt && pceltFetched) {
        // loop to fetch as many elements as requested.
        for (*pceltFetched = 0; *pceltFetched < celt;) {
            // contruct a pidl out of the first element in the orderedlist cache
            OrderList_CacheElement *polce = reinterpret_cast<OrderList_CacheElement *>
                (_polFrequentPages->removeFirst());
            if (polce) {
                if (!(rgelt[*pceltFetched] =
                      reinterpret_cast<LPITEMIDLIST>
                      (_CreateHCacheFolderPidl(TRUE,
                                               polce->pszUrl, polce->lpSTATURL->ftLastVisited,
                                               polce->lpSTATURL,
                                               polce->llPriority,
                                               polce->dwHitRate))))
                {
                    delete polce;
                    hr = E_OUTOFMEMORY;
                    break;
                }
                ++(*pceltFetched);
                delete polce;
                hr = S_OK;
            }
            else {
                hr = S_FALSE; // no more...
                break;
            }
        }
    }
    return hr;
}

// The Next method for view -- Order by Site
HRESULT CHistFolderEnum::_NextViewPart_OrderSite(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    DWORD      dwError         = S_OK;
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen   = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    LPCTSTR    pszStrippedUrl, pszHost, pszCachePrefix = NULL;
    LPITEMIDLIST  pcei         = NULL;
    LPCTSTR    pszHostToMatch  = NULL;
    UINT       nHostToMatchLen = 0;

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    if ((!_pceiWorking) &&
        (!(_pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY))))
        return E_OUTOFMEMORY;

    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;

    // load all the intervals and do some cache maintenance:
    if (FAILED(_pHCFolder->_ValidateIntervalCache()))
        return E_OUTOFMEMORY;

    /* To get all sites, we will search all the history buckets
       for "Host"-type entries.  These entries will be put into
       a hash table as we enumerate so that redundant results are
       not returned.                                               */

    if (!_pshHashTable)
    {
        // start a new case-insensitive hash table
        _pshHashTable = new StrHash(TRUE);
        if (_pshHashTable == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    // if we are looking for individual pages within a host,
    //  then we must find which host to match...
    if (_pHCFolder->_uViewDepth == 1) {
        LPCITEMIDLIST pidlHost = ILFindLastID(_pHCFolder->_pidl);
        ASSERT(_IsValid_IDPIDL(pidlHost) &&
               EQUIV_IDSIGN(((LPBASEPIDL)pidlHost)->usSign, IDDPIDL_SIGN));
        ua_GetURLTitle( &pszHostToMatch, (LPBASEPIDL)pidlHost );
        nHostToMatchLen = (pszHostToMatch ? lstrlen(pszHostToMatch) : 0);

    }

    // iterate backwards through containers so most recent
    //  information gets put into the final pidl
    if (!_hEnum)
        _cbCurrentInterval = (_pHCFolder->_cbIntervals - 1);

    while((dwError = _FindURLFlatCacheEntry(_pHCFolder->_pIntervalCache, szUserName,
                                            (_pHCFolder->_uViewDepth == 1),
                                            _cbCurrentInterval,
                                            _pceiWorking, _hEnum, &dwBuffSize)) == S_OK)
    {
        // reset for next iteration
        dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

        // this guy takes out the "t-marcmi@" part of the URL
        pszStrippedUrl = _StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName);
        if (_pHCFolder->_uViewDepth == 0) {
            if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN) {
                pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
                // insertUnique returns non-NULL if this key already exists
                if (_pshHashTable->insertUnique(pszHost, TRUE, reinterpret_cast<void *>(1)))
                    continue; // already given out
                pcei = (LPITEMIDLIST)_CreateIdCacheFolderPidl(TRUE, IDDPIDL_SIGN, pszHost);
            }
            break;
        }
        else if (_pHCFolder->_uViewDepth == 1) {
            TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
            // is this entry a doc from the host we're looking for?
            _GetURLHost(_pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, _GetLocalHost());

            if ( (!StrCmpI(szHost, pszHostToMatch)) &&
                 (!_pshHashTable->insertUnique(pszStrippedUrl,
                                               TRUE, reinterpret_cast<void *>(1))) )
            {
                STATURL suThis;
                HRESULT hrLocal            = E_FAIL;
                IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();

                if (pUrlHistStg) {
                    hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                    pUrlHistStg->Release();
                }

                pcei = (LPITEMIDLIST)
                    _CreateHCacheFolderPidl(TRUE, _pceiWorking->lpszSourceUrlName,
                                            _pceiWorking->LastModifiedTime,
                                            (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                            _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName)));
                if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                    OleFree(suThis.pwcsTitle);
                break;
            }
        }
    }

    if (pcei && rgelt) {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched)
            *pceltFetched = 1;
    }
    else {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (dwError != S_OK) {
        if (pceltFetched)
            *pceltFetched = 0;
        if (_hEnum)
            FindCloseUrlCache(_hEnum);
        return S_FALSE;
    }
    return S_OK;
}

// "Next" method for View by "Order seen today"
HRESULT CHistFolderEnum::_NextViewPart_OrderToday(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    DWORD      dwError    = S_OK;
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    LPCTSTR    pszStrippedUrl, pszHost;
    LPBASEPIDL  pcei = NULL;

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    if ((!_pceiWorking) &&
        (!(_pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY))))
        return E_OUTOFMEMORY;

    if (!_hEnum) {
        // load all the intervals and do some cache maintenance:
        if (FAILED(_pHCFolder->_ValidateIntervalCache()))
            return E_OUTOFMEMORY;
        // get only entries for TODAY (important part)
        SYSTEMTIME   sysTime;
        FILETIME     fileTime;
        GetLocalTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &fileTime);
        if (FAILED(_pHCFolder->_GetInterval(&fileTime, FALSE, &_pIntervalCur)))
            return E_FAIL; // couldn't get interval for Today
    }

    DWORD dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

    while ( (dwError = _FindURLCacheEntry(_pIntervalCur->szPrefix, _pceiWorking, _hEnum,
                                          &dwBuffSize)) == S_OK )
    {
        dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

        // Make sure that his cache entry belongs to szUserName
        if (_FilterUserName(_pceiWorking, _pIntervalCur->szPrefix, szUserName)) {
            // this guy takes out the "t-marcmi@" part of the URL
            pszStrippedUrl = _StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName);
            if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN) {
                pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
                if (StrCmpNI(c_szHostPrefix, pszStrippedUrl, HOSTPREFIXLEN) == 0)
                    continue; // this is a HOST placeholder, not a real doc
            }

            IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
            STATURL suThis;
            HRESULT hrLocal = E_FAIL;

            if (pUrlHistStg) {
                hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                pUrlHistStg->Release();
            }
            pcei = (LPBASEPIDL) _CreateHCacheFolderPidl(TRUE, _pceiWorking->lpszSourceUrlName,
                                                       _pceiWorking->LastModifiedTime,
                                                       (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                                       _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName)));
            if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                OleFree(suThis.pwcsTitle);
            break;
        }
    }

    if (pcei && rgelt) {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    if (dwError == ERROR_NO_MORE_ITEMS) {
        if (pceltFetched)
            *pceltFetched = 0;
        if (_hEnum)
            FindCloseUrlCache(_hEnum);
        return S_FALSE;
    }
    else if (dwError == S_OK)
        return S_OK;
    else
        return E_FAIL;
}

/***********************************************************************
  Search Mamagement Stuff:

  In order to maintian state between binds to the IShellFolder from
  the desktop, we base our state information for the searches off a
  global database (linked list) that is keyed by a timestamp generated
  when the search begins.

  This FILETIME is in the pidl for the search.
  ********************************************************************/

class _CurrentSearches {
public:
    LONG      _cRef;
    FILETIME  _ftSearchKey;
    LPWSTR    _pwszSearchTarget;
    IShellFolderSearchableCallback *_psfscOnAsyncSearch;

    CacheSearchEngine::StreamSearcher _streamsearcher;

    // Currently doing async search
    BOOL      _fSearchingAsync;

    // On next pass, kill this search
    BOOL      _fKillSwitch;

    // WARNING: DO NOT access these elements without a critical section!
    _CurrentSearches  *_pcsNext;
    _CurrentSearches  *_pcsPrev;

    static _CurrentSearches* s_pcsCurrentCacheSearchThreads;

    _CurrentSearches(FILETIME &ftSearchKey, LPCWSTR pwszSrch,
                     IShellFolderSearchableCallback *psfsc,
                     _CurrentSearches *pcsNext = s_pcsCurrentCacheSearchThreads) :
        _streamsearcher(pwszSrch),
        _fSearchingAsync(FALSE), _fKillSwitch(FALSE), _cRef(1)
    {
        _ftSearchKey      = ftSearchKey;
        _pcsNext          = pcsNext;
        _pcsPrev          = NULL;

        if (psfsc)
            psfsc->AddRef();

        _psfscOnAsyncSearch = psfsc;
        SHStrDupW(pwszSrch, &_pwszSearchTarget);
    }

    ULONG AddRef() {
        return InterlockedIncrement(&_cRef);
    }

    ULONG Release() {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

    // this will increment the refcount to be decremented by s_RemoveSearch
    static void s_NewSearch(_CurrentSearches *pcsNew,
                            _CurrentSearches *&pcsHead = s_pcsCurrentCacheSearchThreads)
    {
        ENTERCRITICAL;
        // make sure we're inserting at the front of the list
        ASSERT(pcsNew->_pcsNext == pcsHead);
        ASSERT(pcsNew->_pcsPrev == NULL);

        pcsNew->AddRef();
        if (pcsHead)
            pcsHead->_pcsPrev = pcsNew;
        pcsHead = pcsNew;
        LEAVECRITICAL;
    }

    static void s_RemoveSearch(_CurrentSearches *pcsRemove,
                               _CurrentSearches *&pcsHead = s_pcsCurrentCacheSearchThreads);

    // This searches for the search.
    // To find this search searcher, use the search searcher searcher :)
    static _CurrentSearches *s_FindSearch(const FILETIME &ftSearchKey,
                                          _CurrentSearches *pcsHead = s_pcsCurrentCacheSearchThreads);

protected:
    ~_CurrentSearches() {
        if (_psfscOnAsyncSearch)
            _psfscOnAsyncSearch->Release();
        CoTaskMemFree(_pwszSearchTarget);
    }
};

// A linked list of current cache searchers:
//  For multiple entries to occur in this list, the user would have to be
//  searching the cache on two or more separate queries simultaneously
_CurrentSearches *_CurrentSearches::s_pcsCurrentCacheSearchThreads = NULL;

void _CurrentSearches::s_RemoveSearch(_CurrentSearches *pcsRemove, _CurrentSearches *&pcsHead)
{
    ENTERCRITICAL;
    if (pcsRemove->_pcsPrev)
        pcsRemove->_pcsPrev->_pcsNext = pcsRemove->_pcsNext;
    else
        pcsHead = pcsRemove->_pcsNext;

    if (pcsRemove->_pcsNext)
        pcsRemove->_pcsNext->_pcsPrev = pcsRemove->_pcsPrev;

    pcsRemove->Release();
    LEAVECRITICAL;
}

// Caller: Remember to Release() the returned data!!
_CurrentSearches *_CurrentSearches::s_FindSearch(const FILETIME &ftSearchKey,
                                                 _CurrentSearches *pcsHead)
{
    ENTERCRITICAL;
    _CurrentSearches *pcsTemp = pcsHead;
    _CurrentSearches *pcsRet  = NULL;
    while (pcsTemp) {
        if (((pcsTemp->_ftSearchKey).dwLowDateTime  == ftSearchKey.dwLowDateTime) &&
            ((pcsTemp->_ftSearchKey).dwHighDateTime == ftSearchKey.dwHighDateTime))
        {
            pcsRet = pcsTemp;
            break;
        }
        pcsTemp = pcsTemp->_pcsNext;
    }
    if (pcsRet)
        pcsRet->AddRef();
    LEAVECRITICAL;
    return pcsRet;
}
/**********************************************************************/

HRESULT CHistFolderEnum::_NextViewPart_OrderSearch(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched) {
    HRESULT hr      = E_FAIL;
    ULONG   uFetched  = 0;

    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;
    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT    uUserNameLen = lstrlen(szUserName);

    if (_pstatenum == NULL) {
        // This hashtable will eventually be passed off to the background
        //  cache search thread so that it doesn't return duplicates.
        ASSERT(NULL == _pshHashTable)  // don't leak a _pshHashTable
        _pshHashTable = new StrHash(TRUE);
        if (_pshHashTable) {
            IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
            if (pUrlHistStg) {
                if (SUCCEEDED((hr = pUrlHistStg->EnumUrls(&_pstatenum))))
                    _pstatenum->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL);
                pUrlHistStg->Release();
            }
        }
    }
    else
        hr = S_OK;

    if (SUCCEEDED(hr)) {
        ASSERT(_pstatenum && _pshHashTable);

        for (uFetched; uFetched < celt;) {
            STATURL staturl = { 0 };
            staturl.cbSize = sizeof(staturl);
            ULONG   celtFetched = 0;
            if (SUCCEEDED((hr = _pstatenum->Next(1, &staturl, &celtFetched)))) {
                if (celtFetched) {
                    ASSERT(celtFetched == 1);
                    if (staturl.pwcsUrl && (staturl.dwFlags & STATURLFLAG_ISTOPLEVEL)) {
                        BOOL fMatch = FALSE;

                        // all this streamsearcher stuff is just like a 'smart' StrStr
                        CacheSearchEngine::StringStream ssUrl(staturl.pwcsUrl);
                        if ((!(fMatch =
                               (_pHCFolder->_pcsCurrentSearch->_streamsearcher).SearchCharStream(ssUrl))) &&
                            staturl.pwcsTitle)
                        {
                            CacheSearchEngine::StringStream ssTitle(staturl.pwcsTitle);
                            fMatch = (_pHCFolder->_pcsCurrentSearch->_streamsearcher).SearchCharStream(ssTitle);
                        }

                        if (fMatch){ // MATCH!
                            // Now, we have to convert the url to a prefixed (ansi, if necessary) url
                            UINT   uUrlLen        = lstrlenW(staturl.pwcsUrl);
                            UINT   uPrefixLen     = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                            LPTSTR pszPrefixedUrl =
                                ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + uPrefixLen + 1) * sizeof(TCHAR)));
                            if (pszPrefixedUrl){
                                wnsprintf(pszPrefixedUrl, uPrefixLen + uUrlLen + 1,
                                          TEXT("%s%s@%ls"), c_szHistPrefix, szUserName,
                                          staturl.pwcsUrl);
                                LPHEIPIDL pheiTemp =
                                    _CreateHCacheFolderPidl(TRUE,
                                                            pszPrefixedUrl, staturl.ftLastVisited,
                                                            &staturl, 0,
                                                            _pHCFolder->_GetHitCount(pszPrefixedUrl + uPrefixLen));
                                if (pheiTemp) {
                                    _pshHashTable->insertUnique(pszPrefixedUrl + uPrefixLen, TRUE,
                                                                reinterpret_cast<void *>(1));
                                    rgelt[uFetched++] = (LPITEMIDLIST)pheiTemp;
                                    hr = S_OK;
                                }

                                LocalFree(pszPrefixedUrl);
                                pszPrefixedUrl = NULL;
                            }
                        }
                    }
                    if (staturl.pwcsUrl)
                        OleFree(staturl.pwcsUrl);

                    if (staturl.pwcsTitle)
                        OleFree(staturl.pwcsTitle);
                }
                else {
                    hr = S_FALSE;
                    // Addref this for the ThreadProc who then frees it...
                    AddRef();
                    SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)s_CacheSearchThreadProc,
                                        (void *)this,
                                        0,
                                        (DWORD_PTR)NULL,
                                        (DWORD_PTR *)NULL,
                                        "shdocvw.dll",
                                        0
                                        );
                    break;
                }
            } // succeeded getnext url
        } //for

        if (pceltFetched)
            *pceltFetched = uFetched;
    } // succeeded initalising
    return hr;
}

// helper function for s_CacheSearchThreadProc
BOOL_PTR CHistFolderEnum::s_DoCacheSearch(LPINTERNET_CACHE_ENTRY_INFO pcei,
                                           LPTSTR pszUserName, UINT uUserNameLen,
                                           CHistFolderEnum *penum,
                                           _CurrentSearches *pcsThisThread, IUrlHistoryPriv *pUrlHistStg)
{
    BOOL_PTR   fFound = FALSE;
    LPTSTR pszTextHeader;

    // The header contains "Content-type: text/*"
    if (pcei->lpHeaderInfo && (pszTextHeader = StrStrI(pcei->lpHeaderInfo, c_szTextHeader)))
    {
        // in some cases, urls in the cache differ from urls in the history
        //  by only the trailing slash -- we strip it out and test both
        UINT uUrlLen = lstrlen(pcei->lpszSourceUrlName);
        if (uUrlLen && (pcei->lpszSourceUrlName[uUrlLen - 1] == TEXT('/')))
        {
            pcei->lpszSourceUrlName[uUrlLen - 1] = TEXT('\0');
            fFound = (BOOL_PTR)(penum->_pshHashTable->retrieve(pcei->lpszSourceUrlName));
            pcei->lpszSourceUrlName[uUrlLen - 1] = TEXT('/');
        }

        DWORD dwSize = MAX_URLCACHE_ENTRY;
        // see if its already been found and added...
        if ((!fFound) && !(penum->_pshHashTable->retrieve(pcei->lpszSourceUrlName)))
        {
            BOOL fIsHTML = !StrCmpNI(pszTextHeader + TEXTHEADERLEN, c_szHTML, HTMLLEN);
            // Now, try to find the url in history...

            STATURL staturl;
            HRESULT hrLocal;
            hrLocal = pUrlHistStg->QueryUrl(pcei->lpszSourceUrlName, STATFLAG_NONAME, &staturl);
            if (hrLocal == S_OK)
            {
                HANDLE hCacheStream;

                hCacheStream = RetrieveUrlCacheEntryStream(pcei->lpszSourceUrlName, pcei, &dwSize, FALSE, 0);
                if (hCacheStream)
                {
                    if (CacheSearchEngine::SearchCacheStream(pcsThisThread->_streamsearcher,
                                                             hCacheStream, fIsHTML)) {
                        EVAL(UnlockUrlCacheEntryStream(hCacheStream, 0));

                        // Prefix the url so that we can create a pidl out of it -- for now, we will
                        //  prefix it with "Visited: ", but "Bogus: " may be more appropriate.
                        UINT uUrlLen    = lstrlen(pcei->lpszSourceUrlName);
                        UINT uPrefixLen = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                        UINT uBuffSize  = uUrlLen + uPrefixLen + 1;
                        LPTSTR pszPrefixedUrl =
                            ((LPTSTR)LocalAlloc(LPTR, uBuffSize * sizeof(TCHAR)));
                        if (pszPrefixedUrl)
                        {
                            wnsprintf(pszPrefixedUrl, uBuffSize, TEXT("%s%s@%s"), c_szHistPrefix, pszUserName,
                                      pcei->lpszSourceUrlName);

                            // Create a pidl for this url
                            LPITEMIDLIST pidlFound = (LPITEMIDLIST) 
                                penum->_pHCFolder->_CreateHCacheFolderPidlFromUrl(FALSE, pszPrefixedUrl);
                            if (pidlFound)
                            {
                                LPITEMIDLIST pidlNotify = ILCombine(penum->_pHCFolder->_pidl, pidlFound);
                                if (pidlNotify) 
                                {
                                    // add the item to the results list...
                                    /* without the flush, the shell will coalesce these and turn
                                       them info SHChangeNotify(SHCNE_UPDATEDIR,..), which will cause nsc
                                       to do an EnumObjects(), which will start the search up again and again...
                                       */
                                    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST | SHCNF_FLUSH, pidlNotify, NULL);
                                    ILFree(pidlNotify);
                                    fFound = TRUE;
                                }

                                LocalFree(pidlFound);
                                pidlFound = NULL;
                            }

                            LocalFree(pszPrefixedUrl);
                            pszPrefixedUrl = NULL;
                        }
                    }
                    else
                        EVAL(UnlockUrlCacheEntryStream(hCacheStream, 0));
                }
            }
            else
                TraceMsg(DM_CACHESEARCH, "In Cache -- Not In History: %s", pcei->lpszSourceUrlName);
        }
    }
    return fFound;
}

DWORD WINAPI CHistFolderEnum::s_CacheSearchThreadProc(CHistFolderEnum *penum)
{
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;

    if (FAILED(penum->_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT    uUserNameLen = lstrlen(szUserName);

    BOOL    fNoConflictingSearch = TRUE;

    _CurrentSearches *pcsThisThread = NULL;

    IUrlHistoryPriv *pUrlHistStg = penum->_pHCFolder->_GetHistStg();

    if (pUrlHistStg)
    {

        pcsThisThread = _CurrentSearches::s_FindSearch(penum->_pHCFolder->_pcsCurrentSearch->_ftSearchKey);

        if (pcsThisThread)
        {
            // if no one else is doing the same search
            if (FALSE == InterlockedExchange((LONG *)&(pcsThisThread->_fSearchingAsync), TRUE))
            {
                if (pcsThisThread->_psfscOnAsyncSearch)
                    pcsThisThread->_psfscOnAsyncSearch->RunBegin(0);

                BYTE ab[MAX_URLCACHE_ENTRY];
                LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)(&ab);

                DWORD dwSize = MAX_URLCACHE_ENTRY;
                HANDLE hCacheEnum = FindFirstUrlCacheEntry(NULL, pcei, &dwSize);
                if (hCacheEnum)
                {
                    while(!(pcsThisThread->_fKillSwitch))
                    {
                        s_DoCacheSearch(pcei, szUserName, uUserNameLen, penum, pcsThisThread, pUrlHistStg);
                        dwSize = MAX_URLCACHE_ENTRY;
                        if (!FindNextUrlCacheEntry(hCacheEnum, pcei, &dwSize))
                        {
                            ASSERT(GetLastError() == ERROR_NO_MORE_ITEMS);
                            break;
                        }
                    }
                    FindCloseUrlCache(hCacheEnum);
                }

                if (pcsThisThread->_psfscOnAsyncSearch)
                    pcsThisThread->_psfscOnAsyncSearch->RunEnd(0);

                pcsThisThread->_fSearchingAsync = FALSE; // It's been removed - no chance of
                                                         // a race condition
            }
            pcsThisThread->Release();
        }
        ATOMICRELEASE(pUrlHistStg);
    }
    ATOMICRELEASE(penum);
    return 0;
}


//
//  this gets the local host name as known by the shell
//  by default assume "My Computer" or whatever
//
void _GetLocalHost(LPTSTR psz, DWORD cch)
{
    *psz = 0;

    IShellFolder* psf;
    if (SUCCEEDED(SHGetDesktopFolder(&psf)))
    {
        WCHAR sz[GUIDSTR_MAX + 3];

        sz[0] = sz[1] = TEXT(':');
        SHStringFromGUIDW(CLSID_MyComputer, sz+2, SIZECHARS(sz)-2);

        LPITEMIDLIST pidl;
        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, sz, NULL, &pidl, NULL)))
        {
            STRRET sr;
            if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_NORMAL, &sr)))
                StrRetToBuf(&sr, pidl, psz, cch);
            ILFree(pidl);
        }

        psf->Release();
    }

    if (!*psz)
        MLLoadString(IDS_NOTNETHOST, psz, cch);
}

LPCTSTR CHistFolderEnum::_GetLocalHost(void)
{
    if (!*_szLocalHost)
        ::_GetLocalHost(_szLocalHost, SIZECHARS(_szLocalHost));

    return _szLocalHost;
}

//////////////////////////////////
//
// IEnumIDList Methods
//
HRESULT CHistFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr             = S_FALSE;
    DWORD   dwBuffSize;
    DWORD   dwError;
    LPTSTR  pszSearchPattern = NULL;
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    TCHAR   szHistSearchPattern[PREFIX_SIZE + 1];               // search pattern for history items
    TCHAR   szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];

    TraceMsg(DM_HSFOLDER, "hcfe - Next() called.");

    if (_pHCFolder->_uViewType)
        return _NextViewPart(celt, rgelt, pceltFetched);

    if ((IsLeaf(_pHCFolder->_foldertype) && 0 == (SHCONTF_NONFOLDERS & _grfFlags)) ||
        (!IsLeaf(_pHCFolder->_foldertype) && 0 == (SHCONTF_FOLDERS & _grfFlags)))
    {
        dwError = 0xFFFFFFFF;
        goto exitPoint;
    }

    if (FOLDER_TYPE_Hist == _pHCFolder->_foldertype)
    {
        return _NextHistInterval(celt, rgelt, pceltFetched);
    }

    if (_pceiWorking == NULL)
    {
        _pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
        if (_pceiWorking == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    // Set up things to enumerate history items, if appropriate, otherwise,
    // we'll just pass in NULL and enumerate all items as before.

    if (!_hEnum)
    {
        if (FAILED(_pHCFolder->_ValidateIntervalCache()))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    StrCpyN(szHistSearchPattern, _pHCFolder->_pszCachePrefix, ARRAYSIZE(szHistSearchPattern));

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

TryAgain:

    dwBuffSize = MAX_URLCACHE_ENTRY;
    dwError = S_OK;

    if (!_hEnum) // _hEnum maintains our state as we iterate over all the cache entries
    {
       _hEnum = FindFirstUrlCacheEntry(pszSearchPattern, _pceiWorking, &dwBuffSize);
       if (!_hEnum)
           dwError = GetLastError();
    }

    else if (!FindNextUrlCacheEntry(_hEnum, _pceiWorking, &dwBuffSize))
    {
        dwError = GetLastError();
    }

    if (S_OK == dwError)
    {
        LPBASEPIDL pcei = NULL;

        TCHAR szTempStrippedUrl[MAX_URL_STRING];
        LPCTSTR pszStrippedUrl;
        BOOL fIsHost;
        LPCTSTR pszHost;

    //mm:  Make sure that this cache entry belongs to szUserName (relevant to Win95)
        if (!_FilterUserName(_pceiWorking, _pHCFolder->_pszCachePrefix, szUserName))
            goto TryAgain;

        StrCpyN(szTempStrippedUrl, _pceiWorking->lpszSourceUrlName, ARRAYSIZE(szTempStrippedUrl));
        pszStrippedUrl = _StripHistoryUrlToUrl(szTempStrippedUrl);
        if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN)
        {
            pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
            fIsHost = !StrCmpNI(c_szHostPrefix, pszStrippedUrl, HOSTPREFIXLEN);
        }
        else
        {
            fIsHost = FALSE;
        }
    //mm:  this is most likely domains:
        if (FOLDER_TYPE_HistInterval == _pHCFolder->_foldertype) // return unique domains
        {
            if (!fIsHost)
                goto TryAgain;

            pcei = _CreateIdCacheFolderPidl(TRUE, IDDPIDL_SIGN, pszHost);
        }
        else if (NULL != _pHCFolder->_pszDomain) //mm: this must be docs
        {
            TCHAR szSourceUrl[MAX_URL_STRING];
            STATURL suThis;
            HRESULT hrLocal = E_FAIL;
            IUrlHistoryPriv *pUrlHistStg = NULL;

            if (fIsHost)
                goto TryAgain;

            //  Filter domain in history view!
            _GetURLHost(_pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, _GetLocalHost());

            if (StrCmpI(szHost, _pHCFolder->_pszDomain)) //mm: is this in our domain?!
                goto TryAgain;

            pUrlHistStg = _pHCFolder->_GetHistStg();
            if (pUrlHistStg)
            {
                CHAR szTempUrl[MAX_URL_STRING];

                SHTCharToAnsi(pszStrippedUrl, szTempUrl, ARRAYSIZE(szTempUrl));
                hrLocal = pUrlHistStg->QueryUrlA(szTempUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                pUrlHistStg->Release();
            }

            StrCpyN(szSourceUrl, _pceiWorking->lpszSourceUrlName, ARRAYSIZE(szSourceUrl));
            pcei = (LPBASEPIDL) _CreateHCacheFolderPidl(TRUE,
                                                       szSourceUrl,
                                                       _pceiWorking->LastModifiedTime,
                                                       (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                                       _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(szSourceUrl)));

            if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                OleFree(suThis.pwcsTitle);
        }
        if (pcei)
        {
            rgelt[0] = (LPITEMIDLIST)pcei;
           if (pceltFetched)
               *pceltFetched = 1;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

exitPoint:

    if (dwError != S_OK)
    {
        if (_hEnum)
        {
            FindCloseUrlCache(_hEnum);
            _hEnum = NULL;
        }
        if (pceltFetched)
            *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CHistFolderEnum::Skip(ULONG celt)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Skip() called.");
    return E_NOTIMPL;
}

HRESULT CHistFolderEnum::Reset()
{
    TraceMsg(DM_HSFOLDER, "hcfe - Reset() called.");
    return E_NOTIMPL;
}

HRESULT CHistFolderEnum::Clone(IEnumIDList **ppenum)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Clone() called.");
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolder Object
//
//////////////////////////////////////////////////////////////////////////////

CHistFolder::CHistFolder(FOLDER_TYPE FolderType)
{
    TraceMsg(DM_HSFOLDER, "hcf - CHistFolder() called.");
    _cRef = 1;
    _foldertype = FolderType;
    ASSERT( _uViewType  == 0 &&
            _uViewDepth  == 0 &&
            _pszCachePrefix == NULL &&
            _pszDomain == NULL &&
            _cbIntervals == 0 &&
            _pIntervalCache == NULL &&
            _fValidatingCache == FALSE &&
            _dwIntervalCached == 0 &&
            _ftDayCached.dwHighDateTime == 0 &&
            _ftDayCached.dwLowDateTime == 0 &&
            _pidl == NULL );
    DllAddRef();
}

CHistFolder::~CHistFolder()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_HSFOLDER, "hcf - ~CHistFolder() called.");
    if (_pIntervalCache)
    {
        LocalFree(_pIntervalCache);
        _pIntervalCache = NULL;
    }
    if (_pszCachePrefix)
    {
        LocalFree(_pszCachePrefix);
        _pszCachePrefix = NULL;
    }
    if (_pszDomain)
    {
        LocalFree(_pszDomain);
        _pszDomain = NULL;
    }
    if (_pidl)
        ILFree(_pidl);
    if (_pUrlHistStg)
    {
        _pUrlHistStg->Release();
        _pUrlHistStg = NULL;
    }
    if (_pcsCurrentSearch)
        _pcsCurrentSearch->Release();

    DllRelease();
}

LPITEMIDLIST _Combine_ViewPidl(USHORT usViewType, LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlResult = NULL;
    LPVIEWPIDL pviewpidl = (LPVIEWPIDL)SHAlloc(sizeof(VIEWPIDL) + sizeof(USHORT));
    if (pviewpidl)
    {
        ZeroMemory(pviewpidl, sizeof(VIEWPIDL) + sizeof(USHORT));
        pviewpidl->cb         = sizeof(VIEWPIDL);
        pviewpidl->usSign     = VIEWPIDL_SIGN;
        pviewpidl->usViewType = usViewType;
        ASSERT(pviewpidl->usExtra == 0);//pcei->usSign;
        if (pidl) 
        {
            pidlResult = ILCombine((LPITEMIDLIST)pviewpidl, pidl);
            SHFree(pviewpidl);
        }
        else
            pidlResult = (LPITEMIDLIST)pviewpidl;
    }
    return pidlResult;
}

STDMETHODIMP CHistFolder::_GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr)
{
    *pszStr = 0;

    switch (iColumn)
    {
    case ICOLH_URL_NAME:
        if (_IsLeaf())
            StrCpyN(pszStr, _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl)), cchStr);
        else
            _GetURLDispName((LPBASEPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLH_URL_TITLE:
        _GetHistURLDispName((LPHEIPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLH_URL_LASTVISITED:
        FileTimeToDateTimeStringInternal(&((LPHEIPIDL)pidl)->ftModified, pszStr, cchStr, TRUE);
        break;
    }
    return S_OK;
}

HRESULT CHistFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;

    const COLSPEC *pcol;
    UINT nCols;

    if (_foldertype == FOLDER_TYPE_Hist)
    {
        pcol = s_HistIntervalFolder_cols;
        nCols = ARRAYSIZE(s_HistIntervalFolder_cols);
    }
    else if (_foldertype == FOLDER_TYPE_HistInterval)
    {
        pcol = s_HistHostFolder_cols;
        nCols = ARRAYSIZE(s_HistHostFolder_cols);
    }
    else
    {
        pcol = s_HistFolder_cols;
        nCols = ARRAYSIZE(s_HistFolder_cols);
    }

    if (pidl == NULL)
    {
        if (iColumn < nCols)
        {
            TCHAR szTemp[128];
            pdi->fmt = pcol[iColumn].iFmt;
            pdi->cxChar = pcol[iColumn].cchCol;
            MLLoadString(pcol[iColumn].ids, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
            hr = E_FAIL;  // enum done
    }
    else
    {
        // Make sure the pidl is dword aligned.

        if(iColumn >= nCols)
            hr = E_FAIL;
        else
        {
            BOOL fRealigned;
            hr = AlignPidl(&pidl, &fRealigned);

            if (SUCCEEDED(hr) )
            {
                TCHAR szTemp[MAX_URL_STRING];
                hr = _GetDetail(pidl, iColumn, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                    hr = StringToStrRet(szTemp, &pdi->str);

            }
            if (fRealigned)
                FreeRealignedPidl(pidl);
        }
    }
    return hr;
}

STDAPI HistFolder_CreateInstance(IUnknown* punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CHistFolder *phist = new CHistFolder(FOLDER_TYPE_Hist);
    if (!phist)
        return E_OUTOFMEMORY;

    *ppunk = SAFECAST(phist, IShellFolder2*);
    return S_OK;
}

HRESULT CHistFolder::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qitHist[] = {
        QITABENT(CHistFolder, IShellFolder2),
        QITABENTMULTI(CHistFolder, IShellFolder, IShellFolder2),
        QITABENT(CHistFolder, IShellIcon),
        QITABENT(CHistFolder, IPersistFolder2),
        QITABENTMULTI(CHistFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CHistFolder, IPersist, IPersistFolder2),
        QITABENT(CHistFolder, IHistSFPrivate),
        QITABENT(CHistFolder, IShellFolderViewType),
        QITABENT(CHistFolder, IShellFolderSearchable),
        { 0 },
    };

    if (iid == IID_IPersistFolder)
    {
        if (FOLDER_TYPE_Hist != _foldertype)
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (iid == CLSID_HistFolder)
    {
        *ppv = (void *)(CHistFolder *)this;
        AddRef();
        return S_OK;
    }

    return QISearch(this, qitHist, iid, ppv);
}

ULONG CHistFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CHistFolder::_ExtractInfoFromPidl()
{
    LPITEMIDLIST pidlThis;
    LPITEMIDLIST pidlLast = NULL;
    LPITEMIDLIST pidlSecondLast = NULL;

    ASSERT(!_uViewType);

    pidlThis = _pidl;
    while (pidlThis->mkid.cb)
    {
        pidlSecondLast = pidlLast;
        pidlLast = pidlThis;
        pidlThis = _ILNext(pidlThis);
    }
    switch (_foldertype)
    {
    case FOLDER_TYPE_Hist:
        _pidlRest = pidlThis;
        break;
    case FOLDER_TYPE_HistInterval:
        _pidlRest = pidlLast;
        break;
    case FOLDER_TYPE_HistDomain:
        _pidlRest = pidlSecondLast;
        break;
    default:
        _pidlRest = NULL;
    }

    HRESULT hr = NULL == _pidlRest ? E_FAIL : S_OK;

    pidlThis = _pidlRest;
    while (SUCCEEDED(hr) && pidlThis->mkid.cb)
    {
        if (_IsValid_IDPIDL(pidlThis))
        {
            LPBASEPIDL pcei = (LPBASEPIDL)pidlThis;
            TCHAR szUrlTitle[MAX_URL_STRING];
            PCTSTR pszUrlTitle = _GetURLTitleAlign((LPBASEPIDL)pidlThis, szUrlTitle, ARRAYSIZE(szUrlTitle));

            if (EQUIV_IDSIGN(pcei->usSign, IDIPIDL_SIGN)) // This is our interval, it implies prefix
            {
                LPCTSTR pszCachePrefix;

                if (_foldertype == FOLDER_TYPE_Hist) 
                    _foldertype = FOLDER_TYPE_HistInterval;

                hr = _LoadIntervalCache();
                if (SUCCEEDED(hr))
                {
                    hr = _GetPrefixForInterval(pszUrlTitle, &pszCachePrefix);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetCachePrefix(pszCachePrefix);
                    }
                }
            }
            else                              // This is our domain
            {
                if (_foldertype == FOLDER_TYPE_HistInterval)
                    _foldertype = FOLDER_TYPE_HistDomain;
                SetDomain(pszUrlTitle);
            }
        }
        pidlThis = _ILNext(pidlThis);
    }

    if (SUCCEEDED(hr))
    {
        switch (_foldertype)
        {
        case FOLDER_TYPE_HistDomain:
            if (_pszDomain == NULL)
                hr = E_FAIL;
            //FALL THROUGH INTENDED
        case FOLDER_TYPE_HistInterval:
            if (_pszCachePrefix == NULL)
                hr = E_FAIL;
            break;
        }
    }
    return hr;
}

void _SetValueSign(HSFINTERVAL *pInterval, FILETIME ftNow)
{
    if (_DaysInInterval(pInterval) == 1 && !CompareFileTime(&(pInterval->ftStart), &ftNow))
    {
        pInterval->usSign = IDTPIDL_SIGN;
    }
    else
    {
        pInterval->usSign = IDIPIDL_SIGN;
    }
}

void _SetVersion(HSFINTERVAL *pInterval, LPCSTR szInterval)
{
    USHORT usVers = 0;
    int i;
    DWORD dwIntervalLen = lstrlenA(szInterval);

    //  Unknown versions are 0
    if (dwIntervalLen == INTERVAL_SIZE)
    {
        for (i = INTERVAL_PREFIX_LEN; i < INTERVAL_PREFIX_LEN+INTERVAL_VERS_LEN; i++)
        {
            if ('0' > szInterval[i] || '9' < szInterval[i])
            {
                usVers = UNK_INTERVAL_VERS;
                break;
            }
            usVers = usVers * 10 + (szInterval[i] - '0');
        }
    }
    pInterval->usVers = usVers;
}

#ifdef UNICODE
#define _ValueToInterval           _ValueToIntervalW
#else // UNICODE
#define _ValueToInterval           _ValueToIntervalA
#endif // UNICODE

HRESULT _ValueToIntervalA(LPCSTR szInterval, FILETIME *pftStart, FILETIME *pftEnd)
{
    int i;
    int iBase;
    HRESULT hr = E_FAIL;
    SYSTEMTIME sysTime;
    unsigned int digits[RANGE_LEN];

    iBase = lstrlenA(szInterval)-RANGE_LEN;
    for (i = 0; i < RANGE_LEN; i++)
    {
        digits[i] = szInterval[i+iBase] - '0';
        if (digits[i] > 9) goto exitPoint;
    }

    ZeroMemory(&sysTime, sizeof(sysTime));
    sysTime.wYear = digits[0]*1000 + digits[1]*100 + digits[2] * 10 + digits[3];
    sysTime.wMonth = digits[4] * 10 + digits[5];
    sysTime.wDay = digits[6] * 10 + digits[7];
    if (!SystemTimeToFileTime(&sysTime, pftStart)) goto exitPoint;

    ZeroMemory(&sysTime, sizeof(sysTime));
    sysTime.wYear = digits[8]*1000 + digits[9]*100 + digits[10] * 10 + digits[11];
    sysTime.wMonth = digits[12] * 10 + digits[13];
    sysTime.wDay = digits[14] * 10 + digits[15];
    if (!SystemTimeToFileTime(&sysTime, pftEnd)) goto exitPoint;

    //  Intervals are open on the end, so end should be strictly > start
    if (CompareFileTime(pftStart, pftEnd) >= 0) goto exitPoint;

    hr = S_OK;

exitPoint:
    return hr;
}

HRESULT _ValueToIntervalW(LPCUWSTR wzInterval, FILETIME *pftStart, FILETIME *pftEnd)
{
    CHAR szInterval[MAX_PATH];
    LPCWSTR wzAlignedInterval;

    WSTR_ALIGNED_STACK_COPY( &wzAlignedInterval,
                             wzInterval );

    ASSERT(lstrlenW(wzAlignedInterval) < ARRAYSIZE(szInterval));
    UnicodeToAnsi(wzAlignedInterval, szInterval, ARRAYSIZE(szInterval));
    return _ValueToIntervalA((LPCSTR) szInterval, pftStart, pftEnd);
}

HRESULT CHistFolder::_LoadIntervalCache()
{
    HRESULT hr;
    DWORD dwLastModified;
    DWORD dwValueIndex;
    DWORD dwPrefixIndex;
    HSFINTERVAL     *pIntervalCache = NULL;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        char szBuffer[MAX_PATH+MAX_PATH];
    } ContainerInfo;
    DWORD dwContainerInfoSize;
    CHAR chSave;
    HANDLE hContainerEnum;
    BOOL fContinue = TRUE;
    FILETIME ftNow;
    SYSTEMTIME st;
    DWORD dwOptions;

    GetLocalTime (&st);
    SystemTimeToFileTime(&st, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);

    dwLastModified = _dwIntervalCached;
    dwContainerInfoSize = sizeof(ContainerInfo);
    if (_pIntervalCache == NULL || CompareFileTime(&ftNow, &_ftDayCached))
    {
        dwOptions = 0;
    }
    else
    {
        dwOptions = CACHE_FIND_CONTAINER_RETURN_NOCHANGE;
    }
    hContainerEnum = FindFirstUrlCacheContainerA(&dwLastModified,
                            &ContainerInfo.cInfo,
                            &dwContainerInfoSize,
                            dwOptions);
    if (hContainerEnum == NULL)
    {
        DWORD err = GetLastError();

        if (err == ERROR_NO_MORE_ITEMS)
        {
            fContinue = FALSE;
        }
        else if (err == ERROR_INTERNET_NO_NEW_CONTAINERS)
        {
            hr = S_OK;
            goto exitPoint;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(err);
            goto exitPoint;
        }
    }

    //  Guarantee we return S_OK we have _pIntervalCache even if we haven't
    //  yet created the interval registry keys.
    dwPrefixIndex = 0;
    dwValueIndex = TYPICAL_INTERVALS;
    pIntervalCache = (HSFINTERVAL *) LocalAlloc(LPTR, dwValueIndex*sizeof(HSFINTERVAL));
    if (!pIntervalCache)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    //  All of our intervals map to cache containers starting with
    //  c_szIntervalPrefix followed by YYYYMMDDYYYYMMDD
    while (fContinue)
    {
        chSave = ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN];
        ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN] = '\0';
        if (!StrCmpIA(ContainerInfo.cInfo.lpszName, c_szIntervalPrefix))
        {
            ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN] = chSave;
            DWORD dwCNameLen;

            if (dwPrefixIndex >= dwValueIndex)
            {
                HSFINTERVAL     *pIntervalCacheNew;

                pIntervalCacheNew = (HSFINTERVAL *) LocalReAlloc(pIntervalCache,
                    (dwValueIndex*2)*sizeof(HSFINTERVAL),
                    LMEM_ZEROINIT|LMEM_MOVEABLE);
                if (pIntervalCacheNew == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exitPoint;
                }
                pIntervalCache = pIntervalCacheNew;
                dwValueIndex *= 2;
            }

            dwCNameLen = lstrlenA(ContainerInfo.cInfo.lpszName);
            if (dwCNameLen <= INTERVAL_SIZE && dwCNameLen >= INTERVAL_MIN_SIZE &&
                lstrlenA(ContainerInfo.cInfo.lpszCachePrefix) == PREFIX_SIZE)
            {
                _SetVersion(&pIntervalCache[dwPrefixIndex], ContainerInfo.cInfo.lpszName);
                if (pIntervalCache[dwPrefixIndex].usVers != UNK_INTERVAL_VERS)
                {
                    AnsiToTChar(ContainerInfo.cInfo.lpszCachePrefix, pIntervalCache[dwPrefixIndex].szPrefix, ARRAYSIZE(pIntervalCache[dwPrefixIndex].szPrefix));
                    hr = _ValueToIntervalA( ContainerInfo.cInfo.lpszName,
                                             &pIntervalCache[dwPrefixIndex].ftStart,
                                             &pIntervalCache[dwPrefixIndex].ftEnd);
                    if (FAILED(hr)) 
                        goto exitPoint;
                    _SetValueSign(&pIntervalCache[dwPrefixIndex], ftNow);
                    dwPrefixIndex++;
                }
                else
                {
                    pIntervalCache[dwPrefixIndex].usVers = 0;
                }
            }
            //
            // HACK! IE5 bld 807 created containers with prefix length PREFIX_SIZE - 1.
            // Delete these entries so history shows up for anyone upgrading over this
            // build.  Delete this code!  (edwardp 8/8/98)
            //
            else if (dwCNameLen <= INTERVAL_SIZE && dwCNameLen >= INTERVAL_MIN_SIZE &&
                     lstrlenA(ContainerInfo.cInfo.lpszCachePrefix) == PREFIX_SIZE - 1)
            {
                DeleteUrlCacheContainerA(ContainerInfo.cInfo.lpszName, 0);
            }
        }
        dwContainerInfoSize = sizeof(ContainerInfo);
        fContinue = FindNextUrlCacheContainerA(hContainerEnum,
                            &ContainerInfo.cInfo,
                            &dwContainerInfoSize);
    }

    hr = S_OK;
    _dwIntervalCached = dwLastModified;
    _ftDayCached = ftNow;

    {
        ENTERCRITICAL;
        if (_pIntervalCache)
        {
            LocalFree(_pIntervalCache);
            _pIntervalCache = NULL;
        }
        _pIntervalCache = pIntervalCache;
        LEAVECRITICAL;
    }
    _cbIntervals = dwPrefixIndex;
    // because it will be freed by our destructor
    pIntervalCache  = NULL;

exitPoint:
    if (hContainerEnum) FindCloseUrlCache(hContainerEnum);
    if (pIntervalCache)
    {
        LocalFree(pIntervalCache);
        pIntervalCache = NULL;
    }

    return hr;
}

//  Returns true if *pftItem falls in the days *pftStart..*pftEnd inclusive
BOOL _InInterval(FILETIME *pftStart, FILETIME *pftEnd, FILETIME *pftItem)
{
    return (CompareFileTime(pftStart,pftItem) <= 0 && CompareFileTime(pftItem,pftEnd) < 0);
}

//  Truncates filetime increments beyond the day and then deltas by Days and converts back
//  to FILETIME increments
void _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days)
{
    _int64 i64Base;

    i64Base = (((_int64)pftBase->dwHighDateTime) << 32) | pftBase->dwLowDateTime;
    i64Base /= FILE_SEC_TICKS;
    i64Base /= DAY_SECS;
    i64Base += Days;
    i64Base *= FILE_SEC_TICKS;
    i64Base *= DAY_SECS;
    pftNew->dwHighDateTime = (DWORD) ((i64Base >> 32) & 0xFFFFFFFF);
    pftNew->dwLowDateTime = (DWORD) (i64Base & 0xFFFFFFFF);
}

DWORD _DaysInInterval(HSFINTERVAL *pInterval)
{
    _int64 i64Start;
    _int64 i64End;

    i64Start = (((_int64)pInterval->ftStart.dwHighDateTime) << 32) | pInterval->ftStart.dwLowDateTime;
    i64Start /= FILE_SEC_TICKS;
    i64Start /= DAY_SECS;
    i64End = (((_int64)pInterval->ftEnd.dwHighDateTime) << 32) | pInterval->ftEnd.dwLowDateTime;
    i64End /= FILE_SEC_TICKS;
    i64End /= DAY_SECS;
    // NOTE: the lower bound is closed, upper is open (ie first tick of next day)
    return (DWORD) (i64End - i64Start);
}

//  Returns S_OK if found, S_FALSE if not, error on error
//  finds weekly interval in preference to daily if both exist
HRESULT CHistFolder::_GetInterval(FILETIME *pftItem, BOOL fWeekOnly, HSFINTERVAL **ppInterval)
{
    HRESULT hr = E_FAIL;
    HSFINTERVAL *pReturn = NULL;
    int i;
    HSFINTERVAL *pDailyInterval = NULL;

    if (NULL == _pIntervalCache) goto exitPoint;

    for (i = 0; i < _cbIntervals; i ++)
    {
        if (_pIntervalCache[i].usVers == OUR_VERS)
        {
            if (_InInterval(&_pIntervalCache[i].ftStart,
                            &_pIntervalCache[i].ftEnd,
                            pftItem))
            {
                if (7 != _DaysInInterval(&_pIntervalCache[i]))
                {
                    if (!fWeekOnly)
                    {
                        pDailyInterval = &_pIntervalCache[i];
                    }
                    continue;
                }
                else
                {
                    pReturn = &_pIntervalCache[i];
                    hr = S_OK;
                    goto exitPoint;
                }
            }
        }
    }

    pReturn = pDailyInterval;
    hr = pReturn ? S_OK : S_FALSE;

exitPoint:
    if (ppInterval) *ppInterval = pReturn;
    return hr;
}

HRESULT CHistFolder::_GetPrefixForInterval(LPCTSTR pszInterval, LPCTSTR *ppszCachePrefix)
{
    HRESULT hr = E_FAIL;
    int i;
    LPCTSTR pszReturn = NULL;
    FILETIME ftStart;
    FILETIME ftEnd;

    if (NULL == _pIntervalCache) goto exitPoint;

    hr = _ValueToInterval(pszInterval, &ftStart, &ftEnd);
    if (FAILED(hr)) 
        goto exitPoint;

    for (i = 0; i < _cbIntervals; i ++)
    {
        if(_pIntervalCache[i].usVers == OUR_VERS)
        {
            if (CompareFileTime(&_pIntervalCache[i].ftStart,&ftStart) == 0 &&
                CompareFileTime(&_pIntervalCache[i].ftEnd,&ftEnd) == 0)
            {
                pszReturn = _pIntervalCache[i].szPrefix;
                hr = S_OK;
                break;
            }
        }
    }

    hr = pszReturn ? S_OK : S_FALSE;

exitPoint:
    if (ppszCachePrefix) *ppszCachePrefix = pszReturn;
    return hr;
}

void _KeyForInterval(HSFINTERVAL *pInterval, LPTSTR pszInterval, int cchInterval)
{
    SYSTEMTIME stStart;
    SYSTEMTIME stEnd;
    CHAR szVers[3];
#ifndef UNIX
    CHAR szTempBuff[MAX_PATH];
#else
    CHAR szTempBuff[INTERVAL_SIZE+1];
#endif

    ASSERT(pInterval->usVers!=UNK_INTERVAL_VERS && pInterval->usVers < 100);

    if (pInterval->usVers)
    {
        wnsprintfA(szVers, ARRAYSIZE(szVers), "%02lu", (ULONG) (pInterval->usVers));
    }
    else
    {
        szVers[0] = '\0';
    }
    FileTimeToSystemTime(&pInterval->ftStart, &stStart);
    FileTimeToSystemTime(&pInterval->ftEnd, &stEnd);
    wnsprintfA(szTempBuff, ARRAYSIZE(szTempBuff),
             "%s%s%04lu%02lu%02lu%04lu%02lu%02lu",
             c_szIntervalPrefix,
             szVers,
             (ULONG) stStart.wYear,
             (ULONG) stStart.wMonth,
             (ULONG) stStart.wDay,
             (ULONG) stEnd.wYear,
             (ULONG) stEnd.wMonth,
             (ULONG) stEnd.wDay);

    AnsiToTChar(szTempBuff, pszInterval, cchInterval);
}

LPITEMIDLIST CHistFolder::_HostPidl(LPCTSTR pszHostUrl, HSFINTERVAL *pInterval)
{
    ASSERT(!_uViewType)
    LPITEMIDLIST pidlReturn;
    LPITEMIDLIST pidl;
    struct _HOSTIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
    } HostIDL;
    struct _INTERVALIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szInterval[INTERVAL_SIZE+1];
        struct _HOSTIDL hostIDL;
        USHORT cbTrail;
    } IntervalIDL;
    LPBYTE pb;
    USHORT cbSave;

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ZeroMemory(&IntervalIDL, sizeof(IntervalIDL));
    IntervalIDL.usSign = pInterval->usSign;
    _KeyForInterval(pInterval, IntervalIDL.szInterval, ARRAYSIZE(IntervalIDL.szInterval));
    IntervalIDL.cb = (USHORT)(2*sizeof(USHORT)+ (lstrlen(IntervalIDL.szInterval) + 1) * sizeof(TCHAR));

    pb = ((LPBYTE) (&IntervalIDL)) + IntervalIDL.cb;
    StrCpyN((LPTSTR)(pb+2*sizeof(USHORT)), pszHostUrl,
            (sizeof(IntervalIDL) - (IntervalIDL.cb + (3 * sizeof(USHORT)))) / sizeof(TCHAR));

    HostIDL.usSign = (USHORT)IDDPIDL_SIGN;
    HostIDL.cb = (USHORT)(2*sizeof(USHORT)+(lstrlen((LPTSTR)(pb+2*sizeof(USHORT))) + 1) * sizeof(TCHAR));

    memcpy(pb, &HostIDL, 2*sizeof(USHORT));
    *(USHORT *)(&pb[HostIDL.cb]) = 0;  // terminate the HostIDL ItemID

    pidlReturn = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
    pidl->mkid.cb = cbSave;
    return pidlReturn;
}

// Notify that an event has occured that affects a specific element in
//  history for special viewtypes
HRESULT CHistFolder::_ViewType_NotifyEvent(IN LPITEMIDLIST pidlRoot,
                                                IN LPITEMIDLIST pidlHost,
                                                IN LPITEMIDLIST pidlPage,
                                                IN LONG         wEventId)
{
    HRESULT hr = S_OK;

    ASSERT(pidlRoot && pidlHost && pidlPage);

    // VIEPWIDL_ORDER_TODAY
    LPITEMIDLIST pidlToday = _Combine_ViewPidl(VIEWPIDL_ORDER_TODAY, pidlPage);
    if (pidlToday) 
    {
        LPITEMIDLIST pidlNotify = ILCombine(pidlRoot, pidlToday);
        if (pidlNotify) 
        {
            SHChangeNotify(wEventId, SHCNF_IDLIST, pidlNotify, NULL);
            ILFree(pidlNotify);
        }
        ILFree(pidlToday);
    }

    // VIEWPIDL_ORDER_SITE
    LPITEMIDLIST pidlSite = _Combine_ViewPidl(VIEWPIDL_ORDER_SITE, pidlHost);
    if (pidlSite) 
    {
        LPITEMIDLIST pidlSitePage = ILCombine(pidlSite, pidlPage);
        if (pidlSitePage) 
        {
            LPITEMIDLIST pidlNotify = ILCombine(pidlRoot, pidlSitePage);
            if (pidlNotify) 
            {
                SHChangeNotify(wEventId, SHCNF_IDLIST, pidlNotify, NULL);
                ILFree(pidlNotify);
            }
            ILFree(pidlSitePage);
        }
        ILFree(pidlSite);
    }

    return hr;
}

LPCTSTR CHistFolder::_GetLocalHost(void)
{
    if (!*_szLocalHost)
        ::_GetLocalHost(_szLocalHost, SIZECHARS(_szLocalHost));

    return _szLocalHost;
}

//  NOTE: modifies pszUrl.
HRESULT CHistFolder::_NotifyWrite(LPTSTR pszUrl, int cchUrl, FILETIME *pftModified,  LPITEMIDLIST * ppidlSelect)
{
    HRESULT hr = S_OK;
    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;
    USHORT cbSave;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNotify;
    LPITEMIDLIST pidlTemp;
    LPITEMIDLIST pidlHost;
    LPHEIPIDL    phei = NULL;
    HSFINTERVAL *pInterval;
    FILETIME ftExpires = {0,0};
    BOOL fNewHost;
    LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszUrl);
    LPCTSTR pszHostUrl = pszStrippedUrl + HOSTPREFIXLEN;
    DWORD cchFree = cchUrl - (DWORD)(pszStrippedUrl-pszUrl);
    CHAR szAnsiUrl[MAX_URL_STRING];

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ///  Should also be able to get hitcount
    STATURL suThis;
    HRESULT hrLocal = E_FAIL;
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
    if (pUrlHistStg) 
    {
        hrLocal = pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(pszUrl),
                                          STATURL_QUERYFLAG_NOURL, &suThis);
        pUrlHistStg->Release();
    }

    phei = _CreateHCacheFolderPidl(FALSE, pszUrl, *pftModified,
                                   (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                   _GetHitCount(_StripHistoryUrlToUrl(pszUrl)));

    if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
        OleFree(suThis.pwcsTitle);

    if (phei == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    if (cchFree <= HOSTPREFIXLEN)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    StrCpyN((LPTSTR)pszStrippedUrl, c_szHostPrefix, cchFree);    // whack on the PIDL!
    cchFree -= HOSTPREFIXLEN;

    _GetURLHostFromUrl(HPidlToSourceUrl((LPBASEPIDL)phei),
                       (LPTSTR)pszHostUrl, cchFree, _GetLocalHost());

    //  chrisfra 4/9/97 we could take a small performance hit here and always
    //  update host entry.  this would allow us to efficiently sort domains by most
    //  recent access.

    fNewHost = FALSE;
    dwBuffSize = MAX_URLCACHE_ENTRY;
    SHTCharToAnsi(pszUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));

    if (!GetUrlCacheEntryInfoA(szAnsiUrl, NULL, 0))
    {
        fNewHost = TRUE;
        if (!CommitUrlCacheEntryA(szAnsiUrl, NULL, ftExpires, *pftModified,
                          URLHISTORY_CACHE_ENTRY|STICKY_CACHE_ENTRY,
                          NULL, 0, NULL, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if (FAILED(hr))
            goto exitPoint;
    }


    hr = _GetInterval(pftModified, FALSE, &pInterval);
    if (FAILED(hr))
        goto exitPoint;

    pidlTemp = _HostPidl(pszHostUrl, pInterval);
    if (pidlTemp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    // Get just the host part of the pidl
    pidlHost = ILFindLastID(pidlTemp);
    ASSERT(pidlHost);

    if (fNewHost)
    {
        SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlTemp, NULL);

        // We also need to notify special history views if they are listening:
        // For now, just "View by Site" is relevant...
        LPITEMIDLIST pidlViewSuffix = _Combine_ViewPidl(VIEWPIDL_ORDER_SITE, pidlHost);
        if (pidlViewSuffix) 
        {
            LPITEMIDLIST pidlNotify = ILCombine(_pidl, pidlViewSuffix);
            if (pidlNotify) 
            {
                SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlNotify, NULL);
                ILFree(pidlNotify);
            }
            ILFree(pidlViewSuffix);
        }
    }

    pidlNotify = ILCombine(pidlTemp, (LPITEMIDLIST) phei);
    if (pidlNotify == NULL)
    {
        ILFree(pidlTemp);
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    // Create (if its not there already) and Rename (if its there)
    //  Sending both notifys will be faster than trying to figure out
    //  which one is appropriate
    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pidlNotify, NULL);

    // Also notify events for specail viewpidls!
    _ViewType_NotifyEvent(_pidl, pidlHost, (LPITEMIDLIST)phei, SHCNE_CREATE);

    if (ppidlSelect)
    {
        *ppidlSelect = pidlNotify;
    }
    else
    {
        ILFree(pidlNotify);
    }

    ILFree(pidlTemp);
exitPoint:
    if (phei)
    {
        LocalFree(phei);
        phei = NULL;
    }

    pidl->mkid.cb = cbSave;
    return hr;
}

HRESULT CHistFolder::_NotifyInterval(HSFINTERVAL *pInterval, LONG lEventID)
{
    // special history views are not relevant here...
    if (_uViewType)
        return S_FALSE;

    USHORT cbSave = 0;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNotify = NULL;
    LPITEMIDLIST pidlNotify2 = NULL;
    LPITEMIDLIST pidlNotify3 = NULL;
    HRESULT hr = S_OK;
    struct _INTERVALIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szInterval[INTERVAL_SIZE+1];
        USHORT cbTrail;
    } IntervalIDL,IntervalIDL2;

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ZeroMemory(&IntervalIDL, sizeof(IntervalIDL));
    IntervalIDL.usSign = pInterval->usSign;
    _KeyForInterval(pInterval, IntervalIDL.szInterval, ARRAYSIZE(IntervalIDL.szInterval));
    IntervalIDL.cb = (USHORT)(2*sizeof(USHORT) + (lstrlen(IntervalIDL.szInterval) + 1)*sizeof(TCHAR));

    if (lEventID&SHCNE_RENAMEFOLDER ||  // was TODAY, now is a weekday
        (lEventID&SHCNE_RMDIR && 1 == _DaysInInterval(pInterval)) ) // one day, maybe TODAY
    {
        memcpy(&IntervalIDL2, &IntervalIDL, sizeof(IntervalIDL));
        IntervalIDL2.usSign = (USHORT)IDTPIDL_SIGN;
        pidlNotify2 = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
        pidlNotify = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL2));
        if (pidlNotify2 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exitPoint;
        }
        if (lEventID&SHCNE_RMDIR)
        {
            pidlNotify3 = pidlNotify2;
            pidlNotify2 = NULL;
        }
    }
    else
    {
        pidlNotify = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
    }
    if (pidlNotify == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    SHChangeNotify(lEventID, SHCNF_IDLIST, pidlNotify, pidlNotify2);
    if (pidlNotify3) SHChangeNotify(lEventID, SHCNF_IDLIST, pidlNotify3, NULL);

exitPoint:
    ILFree(pidlNotify);
    ILFree(pidlNotify2);
    ILFree(pidlNotify3);
    if (cbSave) pidl->mkid.cb = cbSave;
    return hr;
}

HRESULT CHistFolder::_CreateInterval(FILETIME *pftStart, DWORD dwDays)
{
    HSFINTERVAL interval;
    TCHAR szInterval[INTERVAL_SIZE+1];
    UINT err;
    FILETIME ftNow;
    SYSTEMTIME stNow;
    CHAR szIntervalAnsi[INTERVAL_SIZE+1], szCachePrefixAnsi[INTERVAL_SIZE+1];

#define CREATE_OPTIONS (INTERNET_CACHE_CONTAINER_AUTODELETE |  \
                        INTERNET_CACHE_CONTAINER_NOSUBDIRS  |  \
                        INTERNET_CACHE_CONTAINER_NODESKTOPINIT)

    //  _FileTimeDeltaDays guarantees times just at the 0th tick of the day
    _FileTimeDeltaDays(pftStart, &interval.ftStart, 0);
    _FileTimeDeltaDays(pftStart, &interval.ftEnd, dwDays);
    interval.usVers = OUR_VERS;
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);
    _SetValueSign(&interval, ftNow);

    _KeyForInterval(&interval, szInterval, ARRAYSIZE(szInterval));

    interval.szPrefix[0] = ':';
    StrCpyN(&interval.szPrefix[1], &szInterval[INTERVAL_PREFIX_LEN+INTERVAL_VERS_LEN],
            ARRAYSIZE(interval.szPrefix) - 1);
    StrCatBuff(interval.szPrefix, TEXT(": "), ARRAYSIZE(interval.szPrefix));

    SHTCharToAnsi(szInterval, szIntervalAnsi, ARRAYSIZE(szIntervalAnsi));
    SHTCharToAnsi(interval.szPrefix, szCachePrefixAnsi, ARRAYSIZE(szCachePrefixAnsi));

    if (CreateUrlCacheContainerA(szIntervalAnsi,   // Name
                                szCachePrefixAnsi, // CachePrefix
                                NULL,              // Path
                                0,                 // Cache Limit
                                0,                 // Container Type
                                CREATE_OPTIONS,    // Create Options
                                NULL,              // Create Buffer
                                0))                // Create Buffer size
    {
        _NotifyInterval(&interval, SHCNE_MKDIR);
        err = ERROR_SUCCESS;
    }
    else
    {
        err = GetLastError();
    }
    return ERROR_SUCCESS == err ? S_OK : HRESULT_FROM_WIN32(err);
}

HRESULT CHistFolder::_PrefixUrl(LPCTSTR pszStrippedUrl,
                                     FILETIME *pftLastModifiedTime,
                                     LPTSTR pszPrefixedUrl,
                                     DWORD cchPrefixedUrl)
{
    HRESULT hr;
    HSFINTERVAL *pInterval;

    hr = _GetInterval(pftLastModifiedTime, FALSE, &pInterval);
    if (S_OK == hr)
    {
        if ((DWORD)((lstrlen(pszStrippedUrl) + lstrlen(pInterval->szPrefix) + 1) * sizeof(TCHAR)) > cchPrefixedUrl)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            StrCpyN(pszPrefixedUrl, pInterval->szPrefix, cchPrefixedUrl);
            StrCatBuff(pszPrefixedUrl, pszStrippedUrl, cchPrefixedUrl);
        }
    }
    return hr;
}


HRESULT CHistFolder::_WriteHistory(LPCTSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, 
                                        BOOL fSendNotify, LPITEMIDLIST * ppidlSelect)
{
    TCHAR szNewPrefixedUrl[INTERNET_MAX_URL_LENGTH+1];
    HRESULT hr = E_INVALIDARG;
    LPCTSTR pszUrlMinusContainer;

    pszUrlMinusContainer = _StripContainerUrlUrl(pszPrefixedUrl);

    if (pszUrlMinusContainer)
    {
        hr = _PrefixUrl(pszUrlMinusContainer,
                          &ftModified,
                          szNewPrefixedUrl,
                          ARRAYSIZE(szNewPrefixedUrl));
        if (S_OK == hr)
        {
            CHAR szAnsiUrl[MAX_URL_STRING+1];

            SHTCharToAnsi(szNewPrefixedUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));
            if (!CommitUrlCacheEntryA(
                          szAnsiUrl,
                          NULL,
                          ftExpires,
                          ftModified,
                          URLHISTORY_CACHE_ENTRY|STICKY_CACHE_ENTRY,
                          NULL,
                          0,
                          NULL,
                          0))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                if (fSendNotify) 
                    _NotifyWrite(szNewPrefixedUrl, ARRAYSIZE(szNewPrefixedUrl),
                                 &ftModified, ppidlSelect);
            }
        }
    }
    return hr;
}

// This function will update any shell that might be listening to us
//  to redraw the directory.
// It will do this by generating a SHCNE_UPDATE for all possible pidl roots
//  that the shell could have.  Hopefully, this should be sufficient...
// Specifically, this is meant to be called by ClearHistory.
HRESULT CHistFolder::_ViewType_NotifyUpdateAll() 
{
    LPITEMIDLIST pidlHistory;
    if (SUCCEEDED(SHGetHistoryPIDL(&pidlHistory)))
    {
        for (USHORT us = 1; us <= VIEWPIDL_ORDER_MAX; ++us) 
        {
            LPITEMIDLIST pidlView;
            if (SUCCEEDED(CreateSpecialViewPidl(us, &pidlView))) 
            {
                LPITEMIDLIST pidlTemp = ILCombine(pidlHistory, pidlView);
                if (pidlTemp) 
                {
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlTemp, NULL);
                    ILFree(pidlTemp);
                }
                ILFree(pidlView);
            }
        }
        ILFree(pidlHistory);
        SHChangeNotifyHandleEvents();
    }
    return S_OK;
}

//  On a per user basis.
//  chrisfra 6/11/97. _DeleteItems of a Time Interval deletes the entire interval.
//  ClearHistory should probably work the same. Pros of _DeleteEntries is on non-profile,
//  multi-user machine, other user's history is preserved.  Cons is that on profile based
//  machine, empty intervals are created.
HRESULT CHistFolder::ClearHistory()
{
    HRESULT hr = S_OK;
    int i;

    hr = _ValidateIntervalCache();
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < _cbIntervals; i++)
        {
            _DeleteInterval(&_pIntervalCache[i]);
        }
    }
#ifndef UNIX
    _ViewType_NotifyUpdateAll();
#endif
    return hr;
}


//  ftModified is in "User Perceived", ie local time
//  stuffed into FILETIME as if it were UNC.  ftExpires is in normal UNC time.
HRESULT CHistFolder::WriteHistory(LPCTSTR pszPrefixedUrl,
                                  FILETIME ftExpires, FILETIME ftModified,
                                  LPITEMIDLIST * ppidlSelect)
{
    HRESULT hr;

    hr = _ValidateIntervalCache();
    if (SUCCEEDED(hr))
    {
        hr = _WriteHistory(pszPrefixedUrl, ftExpires, ftModified, TRUE, ppidlSelect);
    }
    return hr;
}

//  Makes best efforts attempt to copy old style history items into new containers
HRESULT CHistFolder::_CopyEntries(LPCTSTR pszHistPrefix)
{
    HANDLE              hEnum = NULL;
    HRESULT             hr;
    BOOL                fNotCopied = FALSE;
    LPINTERNET_CACHE_ENTRY_INFO pceiWorking;
    DWORD               dwBuffSize;
    LPTSTR              pszSearchPattern = NULL;
    TCHAR               szHistSearchPattern[65];    // search pattern for history items


    StrCpyN(szHistSearchPattern, pszHistPrefix, ARRAYSIZE(szHistSearchPattern));

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

    pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
    if (NULL == pceiWorking)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    hr = _ValidateIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    while (SUCCEEDED(hr))
    {
        dwBuffSize = MAX_URLCACHE_ENTRY;
        if (!hEnum)
        {
            hEnum = FindFirstUrlCacheEntry(pszSearchPattern, pceiWorking, &dwBuffSize);
            if (!hEnum)
            {
                goto exitPoint;
            }
        }
        else if (!FindNextUrlCacheEntry(hEnum, pceiWorking, &dwBuffSize))
        {
            //  chrisfra 4/3/97 should we distinquish eod vs hard errors?
            //  old code for cachevu doesn't (see above in enum code)
            hr = S_OK;
            goto exitPoint;
        }

        if (SUCCEEDED(hr) &&
            ((pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY) &&
            _FilterPrefix(pceiWorking, (LPTSTR) pszHistPrefix))
        {
            hr = _WriteHistory(pceiWorking->lpszSourceUrlName,
                                 pceiWorking->ExpireTime,
                                 pceiWorking->LastModifiedTime,
                                 FALSE,
                                 NULL);
            if (S_FALSE == hr) fNotCopied = TRUE;
        }
    }
exitPoint:
    if (pceiWorking)
    {
        LocalFree(pceiWorking);
        pceiWorking = NULL;
    }

    if (hEnum)
    {
        FindCloseUrlCache(hEnum);
    }
    return SUCCEEDED(hr) ? (fNotCopied ? S_FALSE : S_OK) : hr;
}

HRESULT CHistFolder::_GetUserName(LPTSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = _EnsureHistStg();
    if (SUCCEEDED(hr))
    {
        hr = _pUrlHistStg->GetUserName(pszUserName, cchUserName);
    }
    return hr;
}


//  Makes best efforts attempt to delete old history items in container on a per
//  user basis.  if we get rid of per user - can just empty whole container
HRESULT CHistFolder::_DeleteEntries(LPCTSTR pszHistPrefix, PFNDELETECALLBACK pfnDeleteFilter, void * pDelData)
{
    HANDLE              hEnum = NULL;
    HRESULT             hr = S_OK;
    BOOL                fNotDeleted = FALSE;
    LPINTERNET_CACHE_ENTRY_INFO pceiWorking;
    DWORD               dwBuffSize;
    LPTSTR   pszSearchPattern = NULL;
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;   // len of this buffer
    TCHAR    szHistSearchPattern[PREFIX_SIZE+1];                 // search pattern for history items
    LPITEMIDLIST pidlNotify;

    StrCpyN(szHistSearchPattern, pszHistPrefix, ARRAYSIZE(szHistSearchPattern));
    if (FAILED(_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

    pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
    if (NULL == pceiWorking)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    while (SUCCEEDED(hr))
    {
        dwBuffSize = MAX_URLCACHE_ENTRY;
        if (!hEnum)
        {
            hEnum = FindFirstUrlCacheEntry(pszSearchPattern, pceiWorking, &dwBuffSize);
            if (!hEnum)
            {
                goto exitPoint;
            }
        }
        else if (!FindNextUrlCacheEntry(hEnum, pceiWorking, &dwBuffSize))
        {
            //  chrisfra 4/3/97 should we distinquish eod vs hard errors?
            //  old code for cachevu doesn't (see above in enum code)
            hr = S_OK;
            goto exitPoint;
        }

        pidlNotify = NULL;
        if (SUCCEEDED(hr) &&
            ((pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY) &&
            _FilterUserName(pceiWorking, pszHistPrefix, szUserName) &&
            (NULL == pfnDeleteFilter || pfnDeleteFilter(pceiWorking, pDelData, &pidlNotify)))
        {
            //if (!DeleteUrlCacheEntryA(pceiWorking->lpszSourceUrlName))
            if (FAILED(_DeleteUrlFromBucket(pceiWorking->lpszSourceUrlName)))
            {
                fNotDeleted = TRUE;
            }
            else if (pidlNotify)
            {
                SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlNotify, NULL);
            }
        }
        ILFree(pidlNotify);
    }
exitPoint:
    if (pceiWorking)
    {
        LocalFree(pceiWorking);
        pceiWorking = NULL;
    }

    if (hEnum)
    {
        FindCloseUrlCache(hEnum);
    }
    return SUCCEEDED(hr) ? (fNotDeleted ? S_FALSE : S_OK) : hr;
}

HRESULT CHistFolder::_DeleteInterval(HSFINTERVAL *pInterval)
{
    UINT err = S_OK;
    TCHAR szInterval[INTERVAL_SIZE+1];
    CHAR szAnsiInterval[INTERVAL_SIZE+1];

    _KeyForInterval(pInterval, szInterval, ARRAYSIZE(szInterval));

    SHTCharToAnsi(szInterval, szAnsiInterval, ARRAYSIZE(szAnsiInterval));
    if (!DeleteUrlCacheContainerA(szAnsiInterval, 0))
    {
        err = GetLastError();
    }
    else
    {
        _NotifyInterval(pInterval, SHCNE_RMDIR);
    }
    return S_OK == err ? S_OK : HRESULT_FROM_WIN32(err);
}

//  Returns S_OK if no intervals we're deleted, S_FALSE if at least
//  one interval was deleted.
HRESULT CHistFolder::_CleanUpHistory(FILETIME ftLimit, FILETIME ftTommorrow)
{
    HRESULT hr;
    BOOL fChangedRegistry = FALSE;
    int i;

    //  _CleanUpHistory does two things:
    //
    //  If we have any stale weeks destroy them and flag the change
    //
    //  If we have any days that should be in cache but not in dailies
    //  copy them to the relevant week then destroy those days
    //  and flag the change

    hr = _LoadIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    for (i = 0; i < _cbIntervals; i++)
    {
        //  Delete old intervals or ones which start at a day in the future
        //  (due to fooling with the clock)
        if (CompareFileTime(&_pIntervalCache[i].ftEnd, &ftLimit) < 0 ||
            CompareFileTime(&_pIntervalCache[i].ftStart, &ftTommorrow) >= 0)
        {
            fChangedRegistry = TRUE;
            hr = _DeleteInterval(&_pIntervalCache[i]);
            if (FAILED(hr)) 
                goto exitPoint;
        }
        else if (1 == _DaysInInterval(&_pIntervalCache[i]))
        {
            HSFINTERVAL *pWeek;

            //  NOTE: at this point we have guaranteed, we've built weeks
            //  for all days outside of current week
            if (S_OK == _GetInterval(&_pIntervalCache[i].ftStart, TRUE, &pWeek))
            {
                fChangedRegistry = TRUE;
                hr = _CopyEntries(_pIntervalCache[i].szPrefix);
                if (FAILED(hr)) 
                    goto exitPoint;
                _NotifyInterval(pWeek, SHCNE_UPDATEDIR);

                hr = _DeleteInterval(&_pIntervalCache[i]);
                if (FAILED(hr)) 
                    goto exitPoint;
            }
        }
    }

exitPoint:
    if (S_OK == hr && fChangedRegistry) hr = S_FALSE;
    return hr;
}

typedef struct _HSFDELETEDATA
{
    UINT cidl;
    LPCITEMIDLIST *ppidl;
    LPCITEMIDLIST pidlParent;
} HSFDELETEDATA,*LPHSFDELETEDATA;

//  delete if matches any host on list
BOOL fDeleteInHostList(LPINTERNET_CACHE_ENTRY_INFO pceiWorking, void * pDelData, LPITEMIDLIST *ppidlNotify)
{
    LPHSFDELETEDATA phsfd = (LPHSFDELETEDATA)pDelData;
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
    TCHAR szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH+1];

    UINT i;

    _GetLocalHost(szLocalHost, SIZECHARS(szLocalHost));
    _GetURLHost(pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, szLocalHost);
    for (i = 0; i < phsfd->cidl; i++)
    {
        if (!ualstrcmpi(szHost, _GetURLTitle((LPBASEPIDL)(phsfd->ppidl[i]))))
        {
            return TRUE;
        }
    }
    return FALSE;
}


// Will attempt to hunt down all occurrances of this url in any of the
//   various history buckets...
// This is a utility function for _ViewType_DeleteItems -- it may
//  be used in other contexts providing these preconditions
//  are kept in mind:
//
//   *The URL passed in should be prefixed ONLY with the username portion
//    such that this function can prepend prefixes to these urls
//   *WARNING: This function ASSUMES that _ValidateIntervalCache
//    has been called recently!!!!  DANGER DANGER!
//
// RETURNS: S_OK if at least one entry was found and deleted
//
HRESULT CHistFolder::_DeleteUrlHistoryGlobal(LPCTSTR pszUrl) {
    HRESULT hr = E_FAIL;
    if (pszUrl) {
        IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
        if (pUrlHistStg) {
            LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszUrl);
            if (pszStrippedUrl)
            {
                UINT   cchwTempUrl  = lstrlen(pszStrippedUrl) + 1;
                LPWSTR pwszTempUrl = ((LPWSTR)LocalAlloc(LPTR, cchwTempUrl * sizeof(WCHAR)));
                if (pwszTempUrl)
                {
                    SHTCharToUnicode(pszStrippedUrl, pwszTempUrl, cchwTempUrl);
                    hr = pUrlHistStg->DeleteUrl(pwszTempUrl, URLFLAG_DONT_DELETE_SUBSCRIBED);
                    for (int i = 0; i < _cbIntervals; ++i) {
                        // should this length be constant? (bucket sizes shouldn't vary)
                        UINT   cchTempUrl   = (PREFIX_SIZE +
                                                lstrlen(pszUrl) + 1);
                        LPTSTR pszTempUrl = ((LPTSTR)LocalAlloc(LPTR, cchTempUrl * sizeof(TCHAR)));
                        if (pszTempUrl) {
                            // StrCpy null terminates
                            StrCpyN(pszTempUrl, _pIntervalCache[i].szPrefix, cchTempUrl);
                            StrCpyN(pszTempUrl + PREFIX_SIZE, pszUrl, cchTempUrl - PREFIX_SIZE);
                            if (DeleteUrlCacheEntry(pszTempUrl))
                                hr = S_OK;

                            LocalFree(pszTempUrl);
                            pszTempUrl = NULL;
                        }
                        else {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }

                    LocalFree(pwszTempUrl);
                    pwszTempUrl = NULL;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
            pUrlHistStg->Release();
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// WARNING: assumes ppidl
HRESULT CHistFolder::_ViewBySite_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    if (FAILED(_GetUserName(szUserName, ARRAYSIZE(szUserName))))
        szUserName[0] = TEXT('\0');

    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();

    if (pUrlHistStg)
    {
        IEnumSTATURL *penum;
        if (SUCCEEDED(pUrlHistStg->EnumUrls(&penum)) &&
            penum) {

            for (UINT i = 0; i < cidl; ++i)
            {
                LPCUTSTR pszHostName  = _GetURLTitle((LPBASEPIDL)ppidl[i]);
                UINT    uUserNameLen = lstrlen(szUserName);
                UINT    uBuffLen     = (USHORT)((HOSTPREFIXLEN + uUserNameLen +
                                        ualstrlen(pszHostName) + 2)); // insert '@' and '\0'
                LPTSTR  pszUrl =
                    ((LPTSTR)LocalAlloc(LPTR, (uBuffLen) * sizeof(TCHAR)));
                if (pszUrl) {
                    // get rid of ":Host: " prefixed entires in the cache
                    // Generates "username@:Host: hostname" -- wnsprintf null terminates
                    wnsprintf(pszUrl, uBuffLen, TEXT("%s@%s%s"), szUserName,
                              c_szHostPrefix, pszHostName);
                    hr = _DeleteUrlHistoryGlobal(pszUrl);

                    // enumerate over all urls in history

                    ULONG cFetched;
                    // don't retrieve TITLE information (too much overhead)
                    penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);
                    STATURL statUrl;
                    statUrl.cbSize = sizeof(STATURL);
                    while(SUCCEEDED(penum->Next(1, &statUrl, &cFetched)) && cFetched) {
                        if (statUrl.pwcsUrl) {
                            // these next few lines painfully constructs a string
                            //  that is of the form "username@url"
                            LPTSTR pszStatUrlUrl;
                            UINT uStatUrlUrlLen = lstrlenW(statUrl.pwcsUrl);
                            pszStatUrlUrl = statUrl.pwcsUrl;
                            TCHAR  szHost[INTERNET_MAX_HOST_NAME_LENGTH + 1];
                            _GetURLHostFromUrl_NoStrip(pszStatUrlUrl, szHost, INTERNET_MAX_HOST_NAME_LENGTH + 1, _GetLocalHost());

                            if (!ualstrcmpi(szHost, pszHostName)) {
                                LPTSTR pszDelUrl; // url to be deleted
                                UINT uUrlLen = uUserNameLen + 1 + uStatUrlUrlLen; // +1 for '@'
                                pszDelUrl = ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + 1) * sizeof(TCHAR)));
                                if (pszDelUrl) {
                                    wnsprintf(pszDelUrl, uUrlLen + 1, TEXT("%s@%s"), szUserName, pszStatUrlUrl);
                                    // finally, delete all all occurrances of that URL in all history buckets
                                    hr =  _DeleteUrlHistoryGlobal(pszDelUrl);

                                    // 
                                    //  Is is really safe to delete *during* an enumeration like this, or should
                                    //  we cache all of the URLS and delete at the end?  I'd rather do it this
                                    //  way if possible -- anyhoo, no docs say its bad to do -- 'course there are no docs ;)
                                    //  Also, there is an example of code later that deletes during an enumeration
                                    //  and seems to work...
                                    LocalFree(pszDelUrl);
                                    pszDelUrl = NULL;
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                            OleFree(statUrl.pwcsUrl);
                        }
                    }
                    penum->Reset();
                    LocalFree(pszUrl);
                    pszUrl = NULL;
                }
                else
                    hr = E_OUTOFMEMORY;

                LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                if (pidlTemp) {
                    SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST, pidlTemp, NULL);
                    ILFree(pidlTemp);
                }
                else
                    hr = E_OUTOFMEMORY;

                if (hr == E_OUTOFMEMORY)
                    break;
            } // for
            penum->Release();
        } // if penum
        else
            hr = E_FAIL;
        pUrlHistStg->Release();
    } // if purlHistStg
    else
        hr = E_FAIL;

    return hr;
}


// This guy will delete an URL from one history (MSHIST-type) bucket
//  and then try to find it in other (MSHIST-type) buckets.
//  If it can't be found, then the URL will be removed from the main
//  history (Visited-type) bucket.
// NOTE: Only the url will be deleted and not any of its "frame-children"
//       This is probably not the a great thing...
// ASSUMES that _ValidateIntervalCache has been called recently
HRESULT CHistFolder::_DeleteUrlFromBucket(LPCTSTR pszPrefixedUrl) {
    HRESULT hr = E_FAIL;
    if (DeleteUrlCacheEntry(pszPrefixedUrl)) {
        //   check if we need to delete this url from the main Visited container, too
        //   we make sure that url exists in at least one other bucket
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(pszPrefixedUrl);
        if (pszUrl)
        {
            DWORD  dwError = _SearchFlatCacheForUrl(pszUrl, NULL, NULL);
            if (dwError == ERROR_FILE_NOT_FOUND)
            {
                IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
                if (pUrlHistStg)
                {
                    pUrlHistStg->DeleteUrl(pszUrl, 0);
                    pUrlHistStg->Release();
                    hr = S_OK;
                }
            }
            else
                hr = S_OK;
        }
    }
    return hr;
}

// Tries to delete as many as possible, and returns E_FAIL if the last one could not
//   be deleted.
// <RATIONALIZATION>not usually called with more than one pidl</RATIONALIZATION>
// ASSUMES that _ValidateIntervalCache has been called recently
HRESULT CHistFolder::_ViewType_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    ASSERT(_uViewType);

    HRESULT hr = E_INVALIDARG;

    if (ppidl) {
        switch(_uViewType) {
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0) {
                hr = _ViewBySite_DeleteItems(ppidl, cidl);
                break;
            }
            ASSERT(_uViewDepth == 1);
            // FALLTHROUGH INTENTIONAL!!
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ: {
            for (UINT i = 0; i < cidl; ++i) {
                LPCTSTR pszPrefixedUrl = HPidlToSourceUrl(ppidl[i]);
                if (pszPrefixedUrl) {
                    if (SUCCEEDED((hr =
                        _DeleteUrlHistoryGlobal(_StripContainerUrlUrl(pszPrefixedUrl)))))
                    {
                        LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                        if (pidlTemp) {
                            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                            ILFree(pidlTemp);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;
        }
        case VIEWPIDL_ORDER_TODAY: {
            // find the entry in the cache and delete it:
            for (UINT i = 0; i < cidl; ++i)
            {
                if (_IsValid_HEIPIDL(ppidl[i]))
                {
                    hr = _DeleteUrlFromBucket(HPidlToSourceUrl(ppidl[i]));
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                        if (pidlTemp)
                        {
                            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                            ILFree(pidlTemp);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;
        }
        default:
            hr = E_NOTIMPL;
            ASSERT(0);
            break;
        }
    }
    return hr;
}


HRESULT CHistFolder::_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    UINT i;
    HSFDELETEDATA hsfDeleteData = {cidl, ppidl, _pidl};
    HSFINTERVAL *pDelInterval;
    FILETIME ftStart;
    FILETIME ftEnd;
    LPCUTSTR pszIntervalName;

    HRESULT hr = _ValidateIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    if (_uViewType) 
    {
        hr = _ViewType_DeleteItems(ppidl, cidl);
        goto exitPoint; // when in rome...
    }

    switch(_foldertype)
    {
    case FOLDER_TYPE_Hist:
        for (i = 0; i < cidl; i++)
        {
            pszIntervalName = _GetURLTitle((LPBASEPIDL)ppidl[i]);

            hr = _ValueToInterval(pszIntervalName, &ftStart, &ftEnd);
            if (FAILED(hr)) 
                goto exitPoint;

            if (S_OK == _GetInterval(&ftStart, FALSE, &pDelInterval))
            {
                hr = _DeleteInterval(pDelInterval);
                if (FAILED(hr)) 
                    goto exitPoint;
            }
        }
        break;
    case FOLDER_TYPE_HistInterval:
        //  last id of of _pidl is name of interval, which implies start and end
        pszIntervalName = _GetURLTitle((LPBASEPIDL)ILFindLastID(_pidl));
        hr = _ValueToInterval(pszIntervalName, &ftStart, &ftEnd);
        if (FAILED(hr)) 
            goto exitPoint;
        if (S_OK == _GetInterval(&ftStart, FALSE, &pDelInterval))
        {
            //  It's important to delete the host: <HOSTNAME> url's first so that
            //  an interleaved _NotityWrite() will not leave us inserting a pidl
            //  but the the host: directory.  it is a conscious performance tradeoff
            //  we're making here to not MUTEX this operation (rare) with _NotifyWrite
            for (i = 0; i < cidl; i++)
            {
                LPCTSTR pszHost;
                LPITEMIDLIST pidlTemp;
                TCHAR szNewPrefixedUrl[INTERNET_MAX_URL_LENGTH+1];
                TCHAR szUrlMinusContainer[INTERNET_MAX_URL_LENGTH+1];

                ua_GetURLTitle( &pszHost, (LPBASEPIDL)ppidl[i] );
                DWORD cbHost = lstrlen(pszHost);

                //  Compose the prefixed URL for the host cache entry, then
                //  use it to delete host entry
                hr = _GetUserName(szUrlMinusContainer, ARRAYSIZE(szUrlMinusContainer));
                if (FAILED(hr)) 
                    goto exitPoint;
                DWORD cbUserName = lstrlen(szUrlMinusContainer);

                if ((cbHost + cbUserName + 1)*sizeof(TCHAR) + HOSTPREFIXLEN > INTERNET_MAX_URL_LENGTH)
                {
                    hr = E_FAIL;
                    goto exitPoint;
                }
                StrCatBuff(szUrlMinusContainer, TEXT("@"), ARRAYSIZE(szUrlMinusContainer));
                StrCatBuff(szUrlMinusContainer, c_szHostPrefix, ARRAYSIZE(szUrlMinusContainer));
                StrCatBuff(szUrlMinusContainer, pszHost, ARRAYSIZE(szUrlMinusContainer));
                hr = _PrefixUrl(szUrlMinusContainer,
                      &ftStart,
                      szNewPrefixedUrl,
                      ARRAYSIZE(szNewPrefixedUrl));
                if (FAILED(hr))
                    goto exitPoint;

                if (!DeleteUrlCacheEntry(szNewPrefixedUrl))
                {
                    hr = E_FAIL;
                    goto exitPoint;
                }
                pidlTemp = _HostPidl(pszHost, pDelInterval);
                if (pidlTemp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exitPoint;
                }
                SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST, pidlTemp, NULL);
                ILFree(pidlTemp);
            }
            hr = _DeleteEntries(_pszCachePrefix , fDeleteInHostList, &hsfDeleteData);
        }
        break;
    case FOLDER_TYPE_HistDomain:
        for (i = 0; i < cidl; ++i)
        {
            if (_IsValid_HEIPIDL(ppidl[i]))
            {
                hr = _DeleteUrlFromBucket(HPidlToSourceUrl(ppidl[i]));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                    if (pidlTemp)
                    {
                        SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                        ILFree(pidlTemp);
                    }
                }
            }
            else
                hr = E_FAIL;
        }
        break;
    }
exitPoint:

    if (SUCCEEDED(hr))
        SHChangeNotifyHandleEvents();

    return hr;
}

IUrlHistoryPriv *CHistFolder::_GetHistStg()
{
    _EnsureHistStg();
    if (_pUrlHistStg)
    {
        _pUrlHistStg->AddRef();
    }
    return _pUrlHistStg;
}

HRESULT CHistFolder::_EnsureHistStg()
{
    HRESULT hr = S_OK;

    if (_pUrlHistStg == NULL)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryPriv, (void **)&_pUrlHistStg);
    }
    return hr;
}

HRESULT CHistFolder::_ValidateIntervalCache()
{
    HRESULT hr = S_OK;
    SYSTEMTIME stNow;
    SYSTEMTIME stThen;
    FILETIME ftNow;
    FILETIME ftTommorrow;
    FILETIME ftMonday;
    FILETIME ftDayOfWeek;
    FILETIME ftLimit;
    BOOL fChangedRegistry = FALSE;
    DWORD dwWaitResult = WAIT_TIMEOUT;
    HSFINTERVAL *pWeirdWeek;
    HSFINTERVAL *pPrevDay;
    long compareResult;
    BOOL fCleanupVisitedDB = FALSE;
    int i;
    int daysToKeep;

    //  Check for reentrancy
    if (_fValidatingCache) return S_OK;

    _fValidatingCache = TRUE;

    // IE6 RAID 2031
    // Is this mutex necessary?
    // In IE4 days, this mutex was named _!MSFTHISTORY!_, the same as that in wininet.
    // As a consequence, sometimes you got into one-minute timeouts that caused the entire
    // browser to hang. (Since one thread could be cleaning up the history while another thread is
    // trying to access the cache for non-history purposes.)

    // I've changed the name of the mutex to prevent shdocvw from locking wininet, but we need 
    // to understand exactly what purpose this mutex serves, and if none, remove it.

    if (g_hMutexHistory == NULL)
    {
        ENTERCRITICAL;

        if (g_hMutexHistory == NULL)
        {
            //
            // Use the "A" version for W95 compatability.
            //
            g_hMutexHistory = OpenMutexA(SYNCHRONIZE, FALSE, "_!SHMSFTHISTORY!_");
            if (g_hMutexHistory  == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND 
                || GetLastError() == ERROR_INVALID_NAME))
            {
                SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
                if (psa)
                {
                    g_hMutexHistory = CreateMutexA(psa, FALSE, "_!SHMSFTHISTORY!_");
                }
            }
        }
        LEAVECRITICAL;
    }

    // Note that if multiple processes are trying to clean up the history, we're still going to 
    // hang the other processes for a minute. Oops.

    if (g_hMutexHistory) 
        dwWaitResult = WaitForSingleObject(g_hMutexHistory, FAILSAFE_TIMEOUT);

    if ((dwWaitResult!=WAIT_OBJECT_0) && (dwWaitResult!=WAIT_ABANDONED))
    {
        ASSERT(FALSE);
        goto exitPoint;
    }

    hr = _LoadIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    //  All history is maintained using "User Perceived Time", which is the
    //  local time when navigate was made.
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);
    _FileTimeDeltaDays(&ftNow, &ftTommorrow, 1);

    hr = _EnsureHistStg();
    if (FAILED(hr))
        goto exitPoint;

    //  Compute ftLimit as first instant of first day to keep in history
    //  _FileTimeDeltaDays truncates to first FILETIME incr of day before computing
    //  earlier/later, day.
    daysToKeep = (int)_pUrlHistStg->GetDaysToKeep();
    if (daysToKeep < 0) daysToKeep = 0;
    _FileTimeDeltaDays(&ftNow, &ftLimit, 1-daysToKeep);

    FileTimeToSystemTime(&ftNow, &stThen);
    //  We take monday as day 0 of week, and adjust it for file time
    //  tics per day (100ns per tick
    _FileTimeDeltaDays(&ftNow, &ftMonday, stThen.wDayOfWeek ? 1-stThen.wDayOfWeek: -6);

    //  Delete old version intervals so prefix matching in wininet isn't hosed

    for (i = 0; i < _cbIntervals; i++)
    {
        if (_pIntervalCache[i].usVers < OUR_VERS)
        {
            fChangedRegistry = TRUE;
            hr = _DeleteInterval(&_pIntervalCache[i]);
            if (FAILED(hr)) 
                goto exitPoint;
        }
    }

    //  If someone set their clock forward and then back, we could have
    //  a week that shouldn't be there.  delete it.  they will lose that week
    //  of history, c'est la guerre! quel domage!
    if (S_OK == _GetInterval(&ftMonday, TRUE, &pWeirdWeek))
    {
        hr = _DeleteInterval(pWeirdWeek);
        fCleanupVisitedDB = TRUE;
        if (FAILED(hr)) 
            goto exitPoint;
        fChangedRegistry = TRUE;
    }

    //  Create weeks as needed to house days that are within "days to keep" limit
    //  but are not in the same week at today
    for (i = 0; i < _cbIntervals; i++)
    {
        FILETIME ftThisDay = _pIntervalCache[i].ftStart;
        if (_pIntervalCache[i].usVers >= OUR_VERS &&
            1 == _DaysInInterval(&_pIntervalCache[i]) &&
            CompareFileTime(&ftThisDay, &ftLimit) >= 0 &&
            CompareFileTime(&ftThisDay, &ftMonday) < 0)
        {
            if (S_OK != _GetInterval(&ftThisDay, TRUE, NULL))
            {
                int j;
                BOOL fProcessed = FALSE;
                FILETIME ftThisMonday;
                FILETIME ftNextMonday;

                FileTimeToSystemTime(&ftThisDay, &stThen);
                //  We take monday as day 0 of week, and adjust it for file time
                //  tics per day (100ns per tick
                _FileTimeDeltaDays(&ftThisDay, &ftThisMonday, stThen.wDayOfWeek ? 1-stThen.wDayOfWeek: -6);
                _FileTimeDeltaDays(&ftThisMonday, &ftNextMonday, 7);

                //  Make sure we haven't already done this week
                for (j = 0; j < i; j++)
                {
                     if (_pIntervalCache[j].usVers >= OUR_VERS &&
                         CompareFileTime(&_pIntervalCache[j].ftStart, &ftLimit) >= 0 &&
                        _InInterval(&ftThisMonday,
                                    &ftNextMonday,
                                    &_pIntervalCache[j].ftStart))
                    {
                         fProcessed = TRUE;
                         break;
                    }
                }
                if (!fProcessed)
                {
                    hr = _CreateInterval(&ftThisMonday, 7);
                    if (FAILED(hr)) 
                        goto exitPoint;
                    fChangedRegistry = TRUE;
                }
            }
        }
    }

    //  Guarantee today is created and old TODAY is renamed to Day of Week
    ftDayOfWeek = ftMonday;
    pPrevDay = NULL;
    while ((compareResult = CompareFileTime(&ftDayOfWeek, &ftNow)) <= 0)
    {
        HSFINTERVAL *pFound;

        if (S_OK != _GetInterval(&ftDayOfWeek, FALSE, &pFound))
        {
            if (0 == compareResult)
            {
                if (pPrevDay) // old today's name changes
                {
                    _NotifyInterval(pPrevDay, SHCNE_RENAMEFOLDER);
                }
                hr = _CreateInterval(&ftDayOfWeek, 1);
                if (FAILED(hr)) 
                    goto exitPoint;
                fChangedRegistry = TRUE;
            }
        }
        else
        {
            pPrevDay = pFound;
        }
        _FileTimeDeltaDays(&ftDayOfWeek, &ftDayOfWeek, 1);
    }

    //  On the first time through, we do not migrate history, wininet
    //  changed cache file format so users going to 4.0B2 from 3.0 or B1
    //  will lose their history anyway

    //  _CleanUpHistory does two things:
    //
    //  If we have any stale weeks destroy them and flag the change
    //
    //  If we have any days that should be in cache but not in dailies
    //  copy them to the relevant week then destroy those days
    //  and flag the change

    hr = _CleanUpHistory(ftLimit, ftTommorrow);

    if (S_FALSE == hr)
    {
        hr = S_OK;
        fChangedRegistry = TRUE;
        fCleanupVisitedDB = TRUE;
    }

    if (fChangedRegistry)
        hr = _LoadIntervalCache();

exitPoint:
    if ((dwWaitResult == WAIT_OBJECT_0)
        || (dwWaitResult == WAIT_ABANDONED))
        ReleaseMutex(g_hMutexHistory);

    if (fCleanupVisitedDB)
    {
        if (SUCCEEDED(_EnsureHistStg()))
        {
            HRESULT hrLocal = _pUrlHistStg->CleanupHistory();
            ASSERT(SUCCEEDED(hrLocal));
        }
    }
    _fValidatingCache = FALSE;
    return hr;
}

HRESULT CHistFolder::_CopyTSTRField(LPTSTR *ppszField, LPCTSTR pszValue)
{
    if (*ppszField)
    {
        LocalFree(*ppszField);
        *ppszField = NULL;
    }
    if (pszValue)
    {
        int cchField = lstrlen(pszValue) + 1;
        *ppszField = (LPTSTR)LocalAlloc(LPTR, cchField * sizeof(TCHAR));
        if (*ppszField)
        {
            StrCpyN(*ppszField, pszValue, cchField);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//
// IHistSFPrivate methods...
//
HRESULT CHistFolder::SetCachePrefix(LPCTSTR pszCachePrefix)
{
    return _CopyTSTRField(&_pszCachePrefix, pszCachePrefix);
}

HRESULT CHistFolder::SetDomain(LPCTSTR pszDomain)
{
    return _CopyTSTRField(&_pszDomain, pszDomain);
}


//
// IShellFolder
//
HRESULT CHistFolder::ParseDisplayName(HWND hwnd, LPBC pbc,
                        LPOLESTR pszDisplayName, ULONG *pchEaten,
                        LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    *ppidl = NULL; 
    return E_FAIL;
}

HRESULT CHistFolder::EnumObjects(HWND hwnd, DWORD grfFlags,
                                      IEnumIDList **ppenumIDList)
{
    return CHistFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}

HRESULT CHistFolder::_ViewPidl_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    switch(((LPVIEWPIDL)pidl)->usViewType) 
    {
    case VIEWPIDL_SEARCH:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_ORDER_SITE:
    case VIEWPIDL_ORDER_FREQ:

        CHistFolder *phsf = new CHistFolder(FOLDER_TYPE_HistDomain);
        if (phsf)
        {
            // initialize?
            phsf->_uViewType = ((LPVIEWPIDL)pidl)->usViewType;

            LPITEMIDLIST pidlLeft = ILCloneFirst(pidl);
            if (pidlLeft)
            {
                hr = S_OK;
                if (((LPVIEWPIDL)pidl)->usViewType == VIEWPIDL_SEARCH) 
                {
                    // find this search in the global database
                    phsf->_pcsCurrentSearch =
                        _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidl)->ftSearchKey);

                    // search not found -- do not proceed
                    if (!phsf->_pcsCurrentSearch)
                        hr = E_FAIL;
                }

                if (SUCCEEDED(hr)) 
                {
                    if (phsf->_pidl)
                        ILFree(phsf->_pidl);
                    phsf->_pidl = ILCombine(_pidl, pidlLeft);

                    LPCITEMIDLIST pidlNext = _ILNext(pidl);
                    if (pidlNext->mkid.cb) 
                    {
                        CHistFolder *phsf2;
                        hr = phsf->BindToObject(pidlNext, pbc, riid, (void **)&phsf2);
                        if (SUCCEEDED(hr))
                        {
                            phsf->Release();
                            phsf = phsf2;
                        }
                        else 
                        {
                            phsf->Release();
                            phsf = NULL;
                            break;
                        }
                    }
                    hr = phsf->QueryInterface(riid, ppv);
                }

                ILFree(pidlLeft);
            }
            ASSERT(phsf);
            phsf->Release();
        }
        else
            hr = E_OUTOFMEMORY;
        break;
    }
    return hr;
}

HRESULT CHistFolder::_ViewType_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    switch (_uViewType) 
    {
    case VIEWPIDL_ORDER_SITE:
        if (_uViewDepth++ < 1)
        {
            LPITEMIDLIST pidlNext = _ILNext(pidl);
            if (!(ILIsEmpty(pidlNext))) 
            {
                hr = BindToObject(pidlNext, pbc, riid, ppv);
            }
            else 
            {
                *ppv = (void *)this;
                LPITEMIDLIST pidlOld = _pidl;
                if (pidlOld) 
                {
                    _pidl = ILCombine(_pidl, pidl);
                    ILFree(pidlOld);
                }
                else 
                {
                    _pidl = ILClone(pidl);
                }
                AddRef();
                hr = S_OK;
            }
        }
        break;

    case VIEWPIDL_ORDER_FREQ:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_SEARCH:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

HRESULT CHistFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    BOOL fRealignedPidl;
    HRESULT hr = AlignPidl(&pidl, &fRealignedPidl);

    if (SUCCEEDED(hr))
    {
        if (IS_VALID_VIEWPIDL(pidl)) 
        {
            hr = _ViewPidl_BindToObject(pidl, pbc, riid, ppv);
        }
        else if (_uViewType)
        {
            hr = _ViewType_BindToObject(pidl, pbc, riid, ppv);
        }
        else
        {
            FOLDER_TYPE ftNew = _foldertype;
            LPCITEMIDLIST pidlNext = pidl;

            while (pidlNext->mkid.cb && SUCCEEDED(hr))
            {
                LPHIDPIDL phid = (LPHIDPIDL)pidlNext;
                switch (ftNew)
                {
                case FOLDER_TYPE_Hist:
                    if (phid->usSign != IDIPIDL_SIGN && phid->usSign != IDTPIDL_SIGN)
                        hr = E_FAIL;
                    else
                        ftNew = FOLDER_TYPE_HistInterval;
                    break;

                case FOLDER_TYPE_HistDomain:
                    if (phid->usSign != HEIPIDL_SIGN)
                        hr = E_FAIL;
                    break;

                case FOLDER_TYPE_HistInterval:
                    if (phid->usSign != IDDPIDL_SIGN)
                        hr = E_FAIL;
                    else
                        ftNew = FOLDER_TYPE_HistDomain;
                    break;

                default:
                    hr = E_FAIL;
                }

                if (SUCCEEDED(hr))
                    pidlNext = _ILNext(pidlNext);
            }

            if (SUCCEEDED(hr))
            {
                CHistFolder *phsf = new CHistFolder(ftNew);
                if (phsf)
                {
                    //  If we're binding to a Domain from an Interval, pidl will not contain the
                    //  interval, so we've got to do a SetCachePrefix.
                    hr = phsf->SetCachePrefix(_pszCachePrefix);
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlNew;
                        hr = SHILCombine(_pidl, pidl, &pidlNew);
                        if (SUCCEEDED(hr))
                        {
                            hr = phsf->Initialize(pidlNew);
                            if (SUCCEEDED(hr))
                            {
                                hr = phsf->QueryInterface(riid, ppv);
                            }
                            ILFree(pidlNew);
                        }
                    }
                    phsf->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (fRealignedPidl)
            FreeRealignedPidl(pidl);
    }

    return hr;
}

HRESULT CHistFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

// A Successor to the IsLeaf
BOOL CHistFolder::_IsLeaf()
{
    BOOL fRet = FALSE;

    switch(_uViewType) {
    case 0:
        fRet = IsLeaf(_foldertype);
        break;
    case VIEWPIDL_ORDER_FREQ:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_SEARCH:
        fRet = TRUE;
        break;
    case VIEWPIDL_ORDER_SITE:
        fRet = (_uViewDepth == 1);
        break;
    }
    return fRet;
}

// coroutine for CompaireIDs -- makes recursive call
int CHistFolder::_View_ContinueCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) 
{
    int iRet = 0;
    if ( (pidl1 = _ILNext(pidl1)) && (pidl2 = _ILNext(pidl2)) ) 
    {
        BOOL fEmpty1 = ILIsEmpty(pidl1);
        BOOL fEmpty2 = ILIsEmpty(pidl2);
        if (fEmpty1 || fEmpty2) 
        {
            if (fEmpty1 && fEmpty2)
                iRet = 0;
            else
                iRet = (fEmpty1 ? -1 : 1);
        }
        else 
        {
            IShellFolder *psf;
            if (SUCCEEDED(BindToObject(pidl1, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                iRet = psf->CompareIDs(0, pidl1, pidl2);
                psf->Release();
            }
        }
    }
    return iRet;
}

int _CompareTitles(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = 0;
    LPCTSTR pszTitle1;
    LPCTSTR pszTitle2;
    LPCTSTR pszUrl1   = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl1));
    LPCTSTR pszUrl2   = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl2));

    ua_GetURLTitle( &pszTitle1, (LPBASEPIDL)pidl1 );
    ua_GetURLTitle( &pszTitle2, (LPBASEPIDL)pidl2 );

    // CompareIDs has to check for equality, also -- two URLs are only equal when
    //   they have the same URL (not title)
    int iUrlCmp;
    if (!(iUrlCmp = StrCmpI(pszUrl1, pszUrl2)))
        iRet = 0;
    else 
    {
        iRet = StrCmpI( (pszTitle1 ? pszTitle1 : pszUrl1),
                        (pszTitle2 ? pszTitle2 : pszUrl2) );

        // this says:  if two docs have the same Title, but different URL
        //             we then sort by url -- the last thing we want to do
        //             is return that they're equal!!  Ay Caramba!
        if (iRet == 0)
            iRet = iUrlCmp;
    }
    return iRet;
}


// unalligned verison

#if defined(UNIX) || !defined(_X86_)

UINT ULCompareFileTime(UNALIGNED const FILETIME *pft1, UNALIGNED const FILETIME *pft2)
{
    FILETIME tmpFT1, tmpFT2;
    CopyMemory(&tmpFT1, pft1, sizeof(tmpFT1));
    CopyMemory(&tmpFT2, pft2, sizeof(tmpFT2));
    return CompareFileTime( &tmpFT1, &tmpFT2 );
}

#else

#define ULCompareFileTime(pft1, pft2) CompareFileTime(pft1, pft2)

#endif


HRESULT CHistFolder::_ViewType_CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ASSERT(_uViewType);

    int iRet = -1;

    if (pidl1 && pidl2)
    {
        switch (_uViewType) {
        case VIEWPIDL_ORDER_FREQ:
            ASSERT(_IsValid_HEIPIDL(pidl1) && _IsValid_HEIPIDL(pidl2));
            // need to strip because freq pidls are "Visited: " and
            //  all others come from our special bucket
            if (!_CompareHCURLs(pidl1, pidl2))
                iRet = 0;
            else
                iRet = ((((LPHEIPIDL)pidl2)->llPriority < ((LPHEIPIDL)pidl1)->llPriority) ? -1 : +1);
            break;
        case VIEWPIDL_SEARCH:
            iRet = _CompareTitles(pidl1, pidl2);
            break;
        case VIEWPIDL_ORDER_TODAY:  // view by order visited today
            {
                int iNameDiff;
                ASSERT(_IsValid_HEIPIDL(pidl1) && _IsValid_HEIPIDL(pidl2));
                // must do this comparison because CompareIDs is not only called for Sorting
                //  but to see if some pidls are equal

                if ((iNameDiff = _CompareHCURLs(pidl1, pidl2)) == 0)
                    iRet = 0;
                else
                {
                    iRet = ULCompareFileTime(&(((LPHEIPIDL)pidl2)->ftModified), &(((LPHEIPIDL)pidl1)->ftModified));
                    // if the file times are equal, they're still not the same url -- so
                    //   they have to be ordered on url
                    if (iRet == 0)
                        iRet = iNameDiff;
                }
                break;
            }
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0)
            {
                TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

                _GetURLDispName((LPBASEPIDL)pidl1, szName1, ARRAYSIZE(szName1));
                _GetURLDispName((LPBASEPIDL)pidl2, szName2, ARRAYSIZE(szName2));

                iRet = StrCmpI(szName1, szName2);
            }
            else if (_uViewDepth == 1) {
                iRet = _CompareTitles(pidl1, pidl2);
            }
            break;
        }
        if (iRet == 0)
            iRet = _View_ContinueCompare(pidl1, pidl2);
    }
    else {
        iRet = -1;
    }

    return ResultFromShort((SHORT)iRet);
}

HRESULT CHistFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL fRealigned1;
    HRESULT hr = AlignPidl(&pidl1, &fRealigned1);
    if (SUCCEEDED(hr))
    {
        BOOL fRealigned2;
        hr = AlignPidl(&pidl2, &fRealigned2);
        if (SUCCEEDED(hr))
        {
            hr = _CompareAlignedIDs(lParam, pidl1, pidl2);

            if (fRealigned2)
                FreeRealignedPidl(pidl2);
        }

        if (fRealigned1)
            FreeRealignedPidl(pidl1);
    }

    return hr;
}

HRESULT CHistFolder::_CompareAlignedIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = 0;
    USHORT usSign;
    FOLDER_TYPE FolderType = _foldertype;
    LPHEIPIDL phei1 = NULL;
    LPHEIPIDL phei2 = NULL;

    if (NULL == pidl1 || NULL == pidl2)
        return E_INVALIDARG;

    if (_uViewType)
    {
        return _ViewType_CompareIDs(lParam, pidl1, pidl2);
    }

    if (IS_VALID_VIEWPIDL(pidl1) && IS_VALID_VIEWPIDL(pidl2))
    {
        if ((((LPVIEWPIDL)pidl1)->usViewType == ((LPVIEWPIDL)pidl2)->usViewType) &&
            (((LPVIEWPIDL)pidl1)->usExtra    == ((LPVIEWPIDL)pidl2)->usExtra))
        {
            iRet = _View_ContinueCompare(pidl1, pidl2);
        }
        else
        {
            iRet = ((((LPVIEWPIDL)pidl1)->usViewType < ((LPVIEWPIDL)pidl2)->usViewType) ? -1 : 1);
        }
        goto exitPoint;
    }

    if (!IsLeaf(_foldertype))
    {
        //  We try to avoid unneccessary BindToObjs to compare partial paths
        usSign = FOLDER_TYPE_Hist == FolderType  ? IDIPIDL_SIGN : IDDPIDL_SIGN;
        while (TRUE)
        {
            LPBASEPIDL pceip1 = (LPBASEPIDL) pidl1;
            LPBASEPIDL pceip2 = (LPBASEPIDL) pidl2;

            if (pidl1->mkid.cb == 0 || pidl2->mkid.cb == 0)
            {
                iRet = pidl1->mkid.cb == pidl2->mkid.cb ? 0 : 1;
                goto exitPoint;
            }

            if (!_IsValid_IDPIDL(pidl1) || !_IsValid_IDPIDL(pidl2))
                return E_FAIL;

            if (!EQUIV_IDSIGN(pceip1->usSign,usSign) || !EQUIV_IDSIGN(pceip2->usSign,usSign))
                return E_FAIL;

            if (_foldertype == FOLDER_TYPE_HistInterval)
            {
                TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

                _GetURLDispName((LPBASEPIDL)pidl1, szName1, ARRAYSIZE(szName1));
                _GetURLDispName((LPBASEPIDL)pidl2, szName2, ARRAYSIZE(szName2));

                iRet = StrCmpI(szName1, szName2);
                goto exitPoint;
            }
            else
            {
                iRet = ualstrcmpi(_GetURLTitle((LPBASEPIDL)pidl1), _GetURLTitle((LPBASEPIDL)pidl2));
                if (iRet != 0)
                    goto exitPoint;
            }

            if (pceip1->usSign != pceip2->usSign)
            {
                iRet = -1;
                goto exitPoint;
            }

            pidl1 = _ILNext(pidl1);
            pidl2 = _ILNext(pidl2);
            if (IDIPIDL_SIGN == usSign)
            {
                usSign = IDDPIDL_SIGN;
            }
        }
    }

    //  At this point, both pidls have resolved to leaf (history or cache)

    phei1 = _IsValid_HEIPIDL(pidl1);
    phei2 = _IsValid_HEIPIDL(pidl2);
    if (!phei1 || !phei2)
        return E_FAIL;

    switch (lParam & SHCIDS_COLUMNMASK) 
    {
    case ICOLH_URL_TITLE:
        {
            TCHAR szStr1[MAX_PATH], szStr2[MAX_PATH];
            _GetHistURLDispName(phei1, szStr1, ARRAYSIZE(szStr1));
            _GetHistURLDispName(phei2, szStr2, ARRAYSIZE(szStr2));

            iRet = StrCmpI(szStr1, szStr2);
        }
        break;

    case ICOLH_URL_NAME:
        iRet = _CompareHFolderPidl(pidl1, pidl2);
        break;

    case ICOLH_URL_LASTVISITED:
        iRet = ULCompareFileTime(&((LPHEIPIDL)pidl2)->ftModified, &((LPHEIPIDL)pidl1)->ftModified);
        break;

    default:
        // The high bit on means to compare absolutely, ie: even if only filetimes
        // are different, we rule file pidls to be different

        if (lParam & SHCIDS_ALLFIELDS)
        {
            iRet = CompareIDs(ICOLH_URL_NAME, pidl1, pidl2);
            if (iRet == 0)
            {
                iRet = CompareIDs(ICOLH_URL_TITLE, pidl1, pidl2);
                if (iRet == 0)
                {
                    iRet = CompareIDs(ICOLH_URL_LASTVISITED, pidl1, pidl2);
                }
            }
        }
        else
        {
            iRet = -1;
        }
        break;
    }
exitPoint:

    return ResultFromShort((SHORT)iRet);
}


HRESULT CHistFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IShellView)
    {
        ASSERT(!_uViewType);
        hr = HistFolderView_CreateInstance(this, ppv);
    }
    else if (riid == IID_IContextMenu)
    {
        // this creates the "Arrange Icons" cascased menu in the background of folder view
        if (IsLeaf(_foldertype))
        {
            CFolderArrangeMenu *p = new CFolderArrangeMenu(MENU_HISTORY);
            if (p)
            {
                hr = p->QueryInterface(riid, ppv);
                p->Release();
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellDetails)
    {
        CDetailsOfFolder *p = new CDetailsOfFolder(hwnd, this);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CHistFolder::_ViewType_GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    ASSERT(_uViewType);

    if (!prgfInOut || !apidl)
        return E_INVALIDARG;

    HRESULT hr       = S_OK;
    int     cGoodPidls = 0;

    if (*prgfInOut & SFGAO_VALIDATE) 
    {
        for (UINT u = 0; SUCCEEDED(hr) && (u < cidl); ++u) 
        {
            switch(_uViewType) 
            {
            case VIEWPIDL_ORDER_TODAY: 
                _EnsureHistStg();
                if (_IsValid_HEIPIDL(apidl[u]) &&
                    SUCCEEDED(_pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[u])),
                               STATURL_QUERYFLAG_NOURL, NULL)))
                {
                    ++cGoodPidls;
                }
                else
                    hr = E_FAIL;
                break;

            case VIEWPIDL_SEARCH:
            case VIEWPIDL_ORDER_FREQ:
                // this is a temporary fix to get the behaviour of the namespace
                //  control correct -- the long-term fix involves cacheing a
                //  generated list of these items and validating that list
                break;

            case VIEWPIDL_ORDER_SITE:
                {
                    ASSERT(_uViewDepth == 1);
                    _ValidateIntervalCache();
                    LPCWSTR psz = _StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[u]));
                    if (psz && _SearchFlatCacheForUrl(psz, NULL, NULL) == ERROR_SUCCESS)
                    {
                        ++cGoodPidls;
                    }
                    else
                        hr = E_FAIL;
                }
                break;

            default:
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr)) 
    {
        if (_IsLeaf())
            *prgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET;
        else
            *prgfInOut = SFGAO_FOLDER;
    }

    return hr;
}

// Right now, we will allow TIF Drag in Browser Only, even though
// it will not be Zone Checked at the Drop.
//#define BROWSERONLY_NOTIFDRAG

HRESULT CHistFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * prgfInOut)
{
    ULONG rgfInOut;
    FOLDER_TYPE FolderType = _foldertype;

    // Make sure each pidl in the array is dword aligned.

    BOOL fRealigned;
    HRESULT hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);
    if (SUCCEEDED(hr))
    {
        // For view types, we'll map FolderType to do the right thing...
        if (_uViewType)
        {
            hr = _ViewType_GetAttributesOf(cidl, apidl, prgfInOut);
        }
        else
        {
            switch (FolderType)
            {
            case FOLDER_TYPE_Hist:
                rgfInOut = SFGAO_FOLDER | SFGAO_HASSUBFOLDER;
                break;

            case FOLDER_TYPE_HistInterval:
                rgfInOut = SFGAO_FOLDER;
                break;

            case FOLDER_TYPE_HistDomain:
                {
                    UINT cGoodPidls;

                    if (SFGAO_VALIDATE & *prgfInOut)
                    {
                        cGoodPidls = 0;
                        if (SUCCEEDED(_EnsureHistStg()))
                        {
                            for (UINT i = 0; i < cidl; i++)
                            {
                                //  NOTE: QueryUrlA checks for NULL URL and returns E_INVALIDARG
                                if (!_IsValid_HEIPIDL(apidl[i]) ||
                                    FAILED(_pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[i])),
                                                STATURL_QUERYFLAG_NOURL, NULL)))
                                {
                                    break;
                                }
                                cGoodPidls++;
                            }
                        }
                    }
                    else
                        cGoodPidls = cidl;

                    if (cidl == cGoodPidls)
                    {
                        rgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET;
                        break;
                    }
                    // FALL THROUGH INTENDED!
                }

            default:
                rgfInOut = 0;
                hr = E_FAIL;
                break;
            }

            // all items can be deleted
            if (SUCCEEDED(hr))
                rgfInOut |= SFGAO_CANDELETE;
            *prgfInOut = rgfInOut;
        }

        if (fRealigned)
            FreeRealignedPidlArray(apidl, cidl);
    }

    return hr;
}

HRESULT CHistFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    *ppv = NULL;         // null the out param

    // Make sure all pidls in the array are dword aligned.

    BOOL fRealigned;
    HRESULT hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);
    if (SUCCEEDED(hr))
    {
        if ((riid == IID_IShellLinkA ||
             riid == IID_IShellLinkW ||
             riid == IID_IExtractIconA ||
             riid == IID_IExtractIconW) &&
             _IsLeaf())
        {
            LPCTSTR pszURL = HPidlToSourceUrl(apidl[0]);

            pszURL = _StripHistoryUrlToUrl(pszURL);

            hr = _GetShortcut(pszURL, riid, ppv);
       }
        else if ((riid == IID_IContextMenu) ||
                 (riid == IID_IDataObject) ||
                 (riid == IID_IExtractIconA) ||
                 (riid == IID_IExtractIconW) ||
                 (riid == IID_IQueryInfo))
        {
            hr = CHistItem_CreateInstance(this, hwnd, cidl, apidl, riid, ppv);
        }
        else
        {
            hr = E_FAIL;
        }

        if (fRealigned)
            FreeRealignedPidlArray(apidl, cidl);
    }

    return hr;
}

HRESULT CHistFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (pSort)
    {
        if (_uViewType == 0 && _foldertype == FOLDER_TYPE_HistDomain)
            *pSort = ICOLH_URL_TITLE;
        else
            *pSort = 0;
    }

    if (pDisplay)
    {
        if (_uViewType == 0 && _foldertype == FOLDER_TYPE_HistDomain)
            *pDisplay = ICOLH_URL_TITLE;
        else
            *pDisplay = 0;
    }
    return S_OK;
}

LPCTSTR _GetUrlForPidl(LPCITEMIDLIST pidl)
{
    LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl));
    
    return pszUrl ? pszUrl : TEXT("");
}

HRESULT CHistFolder::_GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip)
{
    HRESULT hr;
    TCHAR szTip[MAX_URL_STRING + 100], szPart2[MAX_URL_STRING];

    szTip[0] = szPart2[0] = 0;

    FOLDER_TYPE FolderType = _foldertype;

    // For special views, map FolderType to do the right thing
    if (_uViewType)
    {
        switch(_uViewType) {
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ:
        case VIEWPIDL_ORDER_TODAY:
            FolderType = FOLDER_TYPE_HistDomain;
            break;
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0)
                FolderType = FOLDER_TYPE_HistInterval;
            else
                FolderType = FOLDER_TYPE_HistDomain;
            break;
        }
    }

    switch (FolderType)
    {
    case FOLDER_TYPE_HistDomain:
        {
            _GetHistURLDispName((LPHEIPIDL)pidl, szTip, ARRAYSIZE(szTip));
            DWORD cchPart2 = ARRAYSIZE(szPart2);
            PrepareURLForDisplayUTF8(_GetUrlForPidl(pidl), szPart2, &cchPart2, TRUE);
        }
        break;


    case FOLDER_TYPE_Hist:
        {
            FILETIME ftStart, ftEnd;
            LPCTSTR pszIntervalName;
            
            ua_GetURLTitle(&pszIntervalName, (LPBASEPIDL)pidl);

            if (SUCCEEDED(_ValueToInterval(pszIntervalName, &ftStart, &ftEnd)))
            {
                GetTooltipForTimeInterval(&ftStart, &ftEnd, szTip, ARRAYSIZE(szTip));
            }
            break;
        }

    case FOLDER_TYPE_HistInterval:
        {
            TCHAR szFmt[64];

            MLLoadString(IDS_SITETOOLTIP, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(szTip, ARRAYSIZE(szTip), szFmt, _GetURLTitle((LPBASEPIDL)pidl));
            break;
        }
    }

    if (szTip[0])
    {
        // Only combine the 2 parts if the second part exists, and if
        // the 2 parts are not equal.
        if (szPart2[0] && StrCmpI(szTip, szPart2) != 0)
        {
            StrCatBuff(szTip, TEXT("\r\n"), ARRAYSIZE(szTip));
            StrCatBuff(szTip, szPart2, ARRAYSIZE(szTip));
        }
        hr = SHStrDup(szTip, ppwszTip);
    }
    else
    {
        hr = E_FAIL;
        *ppwszTip = NULL;
    }

    return hr;
}

//
// _GetFriendlyUrlDispName -- compute the "friendly name" of an URL
//
// in:  A UTF8 encoded URL.  For example, ftp://ftp.nsca.uiuc.edu/foo.bar
//
// out: A "friendly name" for the URL with the path stripped if necessary
//      (ie   ftp://ftp.ncsa.uiuc.edu   ==> ftp.ncsa.uiuc.edu
//        and ftp://www.foo.bar/foo.bar ==> foo -or- foo.bar depeneding on
//                                whether file xtnsn hiding is on or off
//
// NOTE: pszUrl and pszOut may be the same buffer -- this is allowed
//
HRESULT _GetFriendlyUrlDispName(LPCTSTR pszUrl, LPTSTR pszOut, DWORD cchBuf)
{
    HRESULT hr = E_FAIL;

    PrepareURLForDisplayUTF8(pszUrl, pszOut, &cchBuf, TRUE);

    TCHAR szUrlPath[MAX_PATH];
    TCHAR szUrlHost[MAX_PATH];

    // Set up InternetCrackUrl parameter block
    SHURL_COMPONENTSW urlcomponents  = { 0 };
    urlcomponents.dwStructSize    = sizeof(URL_COMPONENTS);
    urlcomponents.lpszUrlPath     = szUrlPath;
    urlcomponents.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlcomponents.lpszHostName    = szUrlHost;
    urlcomponents.dwHostNameLength = ARRAYSIZE(szUrlHost);
                        
    if (UrlCrackW(pszOut, cchBuf, ICU_DECODE, &urlcomponents))
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);

        // eliminate trailing slash
        if ((urlcomponents.dwUrlPathLength > 0) &&
            (urlcomponents.lpszUrlPath[urlcomponents.dwUrlPathLength - 1] == TEXT('/')))
        {
            urlcomponents.lpszUrlPath[urlcomponents.dwUrlPathLength - 1] = TEXT('\0');
            --urlcomponents.dwUrlPathLength;
        }
        
        if (urlcomponents.dwUrlPathLength > 0)
        {
            // LPCTSTR _FindURLFileName(LPCTSTR) --> const_cast is OK
            LPTSTR pszFileName = const_cast<LPTSTR>(_FindURLFileName(urlcomponents.lpszUrlPath));
            
            if (!ss.fShowExtensions)
            {
                PathRemoveExtension(pszFileName);
            }
            StrCpyN(pszOut, pszFileName, cchBuf);
        }
        else
        {
            StrCpyN(pszOut, urlcomponents.lpszHostName, cchBuf);
        }

        hr = S_OK;
    }

    return hr;
}


void CHistFolder::_GetHistURLDispName(LPHEIPIDL phei, LPTSTR pszStr, UINT cchStr)
{
    *pszStr = 0;

    if ((phei->usFlags & HISTPIDL_VALIDINFO) && phei->usTitle)
    {
        StrCpyN(pszStr, (LPTSTR)((BYTE*)phei + phei->usTitle), cchStr);
    }
    else if (SUCCEEDED(_EnsureHistStg()))
    {
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPCITEMIDLIST)phei));
        if (pszUrl)
        {
            STATURL suThis;
            if (SUCCEEDED(_pUrlHistStg->QueryUrl(pszUrl, STATURL_QUERYFLAG_NOURL, &suThis)) && suThis.pwcsTitle)
            {
                // sometimes the URL is stored in the title
                // avoid using those titles.
                if (_TitleIsGood(suThis.pwcsTitle))
                    SHUnicodeToTChar(suThis.pwcsTitle, pszStr, cchStr);

                OleFree(suThis.pwcsTitle);
            }

            //  if we havent got anything yet
            if (!*pszStr) 
            {
                if (FAILED(_GetFriendlyUrlDispName(pszUrl, pszStr, cchStr)))
                {
                    // last resort: display the whole URL
                    StrCpyN(pszStr, pszUrl, cchStr);
                }
            }
        }
    }
}

HRESULT CHistFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *lpName)
{
    TCHAR szTemp[MAX_URL_STRING];

    szTemp[0] = 0;

    // Make sure the pidl is dword aligned.

    BOOL fRealigned;

    if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        if (IS_VALID_VIEWPIDL(pidl))
        {
            UINT idRsrc;
            switch(((LPVIEWPIDL)pidl)->usViewType) {
            case VIEWPIDL_ORDER_SITE:  idRsrc = IDS_HISTVIEW_SITE;      break;
            case VIEWPIDL_ORDER_TODAY: idRsrc = IDS_HISTVIEW_TODAY;     break;
            case VIEWPIDL_ORDER_FREQ:
            default:
                idRsrc = IDS_HISTVIEW_FREQUENCY; break;
            }

            MLLoadString(idRsrc, szTemp, ARRAYSIZE(szTemp));
        }
        else
        {
            if (_uViewType  == VIEWPIDL_ORDER_SITE &&
                _uViewDepth  == 0)
            {
                _GetURLDispName((LPBASEPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
            }
            else if (_IsLeaf())
            {
                LPCTSTR pszTitle;
                BOOL fDoUnescape;  

                ua_GetURLTitle(&pszTitle, (LPBASEPIDL)pidl);
                // _GetURLTitle could return the real title or just an URL.
                // We use _URLTitleIsURL to make sure we don't unescape any titles.

                if (pszTitle && *pszTitle)
                {
                    StrCpyN(szTemp, pszTitle, ARRAYSIZE(szTemp));
                    fDoUnescape = _URLTitleIsURL((LPBASEPIDL)pidl);
                }
                else
                {
                    LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl));
                    if (pszUrl) 
                        StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
                    fDoUnescape = TRUE;
                }
                
                if (fDoUnescape)
                {
                    // at this point, szTemp contains part of an URL
                    //  we will crack (smoke) the URL
                    LPCTSTR pszUrl = HPidlToSourceUrl(pidl);

                    // Is this pidl a history entry?
                    if (((LPBASEPIDL)pidl)->usSign == (USHORT)HEIPIDL_SIGN)
                    {
                        pszUrl = _StripHistoryUrlToUrl(pszUrl);
                    }                  

                    if (pszUrl)
                    {
                        if (FAILED(_GetFriendlyUrlDispName(pszUrl, szTemp, ARRAYSIZE(szTemp))))
                        {
                            StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
                        }
                    }
                }
            }
            else
            {
                // for the history, we'll use the title if we have one, otherwise we'll use
                // the url filename.
                switch (_foldertype)
                {
                case FOLDER_TYPE_HistDomain:
                    _GetHistURLDispName((LPHEIPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
                    break;

                case FOLDER_TYPE_Hist:
                    {
                        FILETIME ftStart, ftEnd;

                        _ValueToInterval(_GetURLTitle((LPBASEPIDL)pidl), &ftStart, &ftEnd);
                        GetDisplayNameForTimeInterval(&ftStart, &ftEnd, szTemp, ARRAYSIZE(szTemp));
                    }
                    break;

                case FOLDER_TYPE_HistInterval:
                    _GetURLDispName((LPBASEPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
                    break;
                }
            }
        }

        if (fRealigned)
            FreeRealignedPidl(pidl);
    }

    return StringToStrRet(szTemp, lpName);
}

HRESULT CHistFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                        LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;               // null the out param
    return E_FAIL;
}

//////////////////////////////////
//
// IShellIcon Methods...
//
HRESULT CHistFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex)
{
    return S_FALSE;
}

// IPersist
HRESULT CHistFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_HistFolder;
    return S_OK;
}

HRESULT CHistFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    HRESULT hr = S_OK;
    ILFree(_pidl);

    if ((FOLDER_TYPE_Hist == _foldertype) && !IsCSIDLFolder(CSIDL_HISTORY, pidlInit))
        hr = E_FAIL;
    else
    {
        hr = SHILClone(pidlInit, &_pidl);
        if (SUCCEEDED(hr))
            hr = _ExtractInfoFromPidl();
    }
    return hr;
}

//////////////////////////////////
//
// IPersistFolder2 Methods...
//
HRESULT CHistFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

//////////////////////////////////////////////////
// IShellFolderViewType Methods
//
// but first, the enumerator class...
class CHistViewTypeEnum : public IEnumIDList
{
    friend class CHistFolder;
public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { _uCurViewType += celt; return S_OK; }
    STDMETHODIMP Reset()          { _uCurViewType =     1; return S_OK; }
    STDMETHODIMP Clone(IEnumIDList **ppenum);

private:
    ~CHistViewTypeEnum() {}
    CHistViewTypeEnum() : _cRef(1), _uCurViewType(1) {}

    LONG  _cRef;
    UINT  _uCurViewType;
};

STDMETHODIMP CHistViewTypeEnum::QueryInterface(REFIID riid, void **ppv) 
{
    static const QITAB qit[] = {
        QITABENT(CHistViewTypeEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHistViewTypeEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistViewTypeEnum::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CHistViewTypeEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;

    if (rgelt && (pceltFetched || 1 == celt))
    {
        ULONG i = 0;

        while (i < celt)
        {
            if (_uCurViewType <= VIEWPIDL_ORDER_MAX)
            {
                hr = CreateSpecialViewPidl(_uCurViewType, &(rgelt[i]));

                if (SUCCEEDED(hr))
                {
                    ++i;
                    ++_uCurViewType;
                }
                else
                {
                    while (i)
                        ILFree(rgelt[--i]);

                    break;
                }
            }
            else
            {
                break;
            }
        }

        if (pceltFetched)
            *pceltFetched = i;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHistViewTypeEnum::Clone(IEnumIDList **ppenum)
{
    CHistViewTypeEnum* phvte = new CHistViewTypeEnum();
    if (phvte) 
    {
        phvte->_uCurViewType = _uCurViewType;
        *ppenum = phvte;
        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}

// Continuing with the CHistFolder::IShellFolderViewType
STDMETHODIMP CHistFolder::EnumViews(ULONG grfFlags, IEnumIDList **ppenum) 
{
    *ppenum = new CHistViewTypeEnum();
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CHistFolder::GetDefaultViewName(DWORD uFlags, LPWSTR *ppwszName) 
{
    TCHAR szName[MAX_PATH];

    MLLoadString(IDS_HISTVIEW_DEFAULT, szName, ARRAYSIZE(szName));
    return SHStrDup(szName, ppwszName);
}

// Remember that these *MUST* be in order so that
//  the array can be accessed by VIEWPIDL type
const DWORD CHistFolder::_rdwFlagsTable[] = {
    SFVTFLAG_NOTIFY_CREATE,                          // Date
    SFVTFLAG_NOTIFY_CREATE,                          // site
    0,                                               // freq
    SFVTFLAG_NOTIFY_CREATE | SFVTFLAG_NOTIFY_RESORT  // today
};

STDMETHODIMP CHistFolder::GetViewTypeProperties(LPCITEMIDLIST pidl, DWORD *pdwFlags) 
{
    HRESULT hr = S_OK;
    UINT uFlagTableIndex = 0;

    if ((pidl != NULL) && !ILIsEmpty(pidl)) // default view
    {
        // Make sure the pidl is dword aligned.

        BOOL fRealigned;
        hr = AlignPidl(&pidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            if (IS_VALID_VIEWPIDL(pidl))
            {
                uFlagTableIndex = ((LPVIEWPIDL)pidl)->usViewType;
                ASSERT(uFlagTableIndex <= VIEWPIDL_ORDER_MAX);
            }
            else
            {
                hr =  E_INVALIDARG;
            }

            if (fRealigned)
                FreeRealignedPidl(pidl);
        }
    }

    *pdwFlags = _rdwFlagsTable[uFlagTableIndex];

    return hr;
}

HRESULT CHistFolder::TranslateViewPidl(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView,
                                            LPITEMIDLIST *ppidlOut)
{
    HRESULT hr;

    if (pidl && IS_VALID_VIEWPIDL(pidlView))
    {
        if (!IS_VALID_VIEWPIDL(pidl))
        {
            hr = ConvertStandardHistPidlToSpecialViewPidl(pidl,
                                 ((LPVIEWPIDL)pidlView)->usViewType,
                                 ppidlOut);
        }
        else
        {
            hr = E_NOTIMPL;
        }

    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//////////////////////////////////////////////////
//
// IShellFolderSearchable Methods
//
// For more information about how this search stuff works,
//  please see the comments for _CurrentSearches above
STDMETHODIMP CHistFolder::FindString(LPCWSTR pwszTarget, LPDWORD pdwFlags,
                                          IUnknown *punkOnAsyncSearch,
                                          LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = E_INVALIDARG;
    if (ppidlOut)
    {
        *ppidlOut = NULL;
        if (pwszTarget)
        {
            LPITEMIDLIST pidlView;

            SYSTEMTIME systime;
            FILETIME   ftNow;
            GetLocalTime(&systime);
            SystemTimeToFileTime(&systime, &ftNow);

            hr = CreateSpecialViewPidl(VIEWPIDL_SEARCH, &pidlView, sizeof(SEARCHVIEWPIDL) - sizeof(VIEWPIDL));
            if (SUCCEEDED(hr))
            {
                ((LPSEARCHVIEWPIDL)pidlView)->ftSearchKey = ftNow;

                IShellFolderSearchableCallback *psfscOnAsyncSearch = NULL;
                if (punkOnAsyncSearch)
                    punkOnAsyncSearch->QueryInterface(IID_PPV_ARG(IShellFolderSearchableCallback, &psfscOnAsyncSearch));

                // Insert this search into the global database
                //  This constructor will AddRef psfscOnAsyncSearch
                _CurrentSearches *pcsNew = new _CurrentSearches(ftNow, pwszTarget, psfscOnAsyncSearch);

                if (pcsNew) 
                {
                    if (psfscOnAsyncSearch)
                        psfscOnAsyncSearch->Release();  // _CurrentSearches now holds the ref

                    // This will AddRef pcsNew 'cause its going in the list
                    _CurrentSearches::s_NewSearch(pcsNew);
                    pcsNew->Release();
                    *ppidlOut = pidlView;
                    hr = S_OK;
                }
                else 
                {
                    ILFree(pidlView);
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CHistFolder::CancelAsyncSearch(LPCITEMIDLIST pidlSearch, LPDWORD pdwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_VIEWPIDL(pidlSearch) &&
        (((LPVIEWPIDL)pidlSearch)->usViewType == VIEWPIDL_SEARCH))
    {
        hr = S_FALSE;
        _CurrentSearches *pcs = _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidlSearch)->ftSearchKey);
        if (pcs) {
            pcs->_fKillSwitch = TRUE;
            hr = S_OK;
            pcs->Release();
        }
    }
    return hr;
}

STDMETHODIMP CHistFolder::InvalidateSearch(LPCITEMIDLIST pidlSearch, LPDWORD pdwFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (IS_VALID_VIEWPIDL(pidlSearch) &&
        (((LPVIEWPIDL)pidlSearch)->usViewType == VIEWPIDL_SEARCH))
    {
        hr = S_FALSE;
        _CurrentSearches *pcs = _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidlSearch)->ftSearchKey);
        if (pcs) {
            _CurrentSearches::s_RemoveSearch(pcs);
            pcs->Release();
        }
    }
    return hr;
}

//////////////////////////////////////////////////

DWORD CHistFolder::_GetHitCount(LPCTSTR pszUrl)
{
    DWORD dwHitCount = 0;
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();

    if (pUrlHistStg)
    {
        PROPVARIANT vProp = {0};
        if (SUCCEEDED(pUrlHistStg->GetProperty(pszUrl, PID_INTSITE_VISITCOUNT, &vProp)) &&
            (vProp.vt == VT_UI4))
        {
            dwHitCount = vProp.lVal;
        }
        pUrlHistStg->Release();
    }
    return dwHitCount;
}

// pidl should be freed by caller
// URL must have some sort of cache container prefix
LPHEIPIDL CHistFolder::_CreateHCacheFolderPidlFromUrl(BOOL fOleMalloc, LPCTSTR pszPrefixedUrl)
{
    LPHEIPIDL pheiRet;
    HRESULT   hrLocal = E_FAIL;
    STATURL   suThis;
    LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszPrefixedUrl);
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
    if (pUrlHistStg)
    {
        hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
        pUrlHistStg->Release();
    }

    FILETIME ftLastVisit = { 0 };
    DWORD    dwNumHits   = 0;

    if (FAILED(hrLocal)) { // maybe the cache knows...
        BYTE ab[MAX_URLCACHE_ENTRY];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)(&ab);
        DWORD dwSize = MAX_URLCACHE_ENTRY;
        if (GetUrlCacheEntryInfo(_StripHistoryUrlToUrl(pszPrefixedUrl), pcei, &dwSize)) {
            ftLastVisit = pcei->LastAccessTime;
            dwNumHits   = pcei->dwHitRate;
        }
    }

    pheiRet = _CreateHCacheFolderPidl(fOleMalloc, pszPrefixedUrl,
                                      SUCCEEDED(hrLocal) ? suThis.ftLastVisited : ftLastVisit,
                                      SUCCEEDED(hrLocal) ? &suThis : NULL, 0,
                                      SUCCEEDED(hrLocal) ? _GetHitCount(pszStrippedUrl) : dwNumHits);
    if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
        OleFree(suThis.pwcsTitle);
    return pheiRet;
}


UINT _CountPidlParts(LPCITEMIDLIST pidl) {
    LPCITEMIDLIST pidlTemp = pidl;
    UINT          uParts   = 0;

    if (pidl)
    {
        for (uParts = 0; pidlTemp->mkid.cb; pidlTemp = _ILNext(pidlTemp))
            ++uParts;
    }
    return uParts;
}

// you must dealloc (LocalFree) the ppidl returned
LPITEMIDLIST* _SplitPidl(LPCITEMIDLIST pidl, UINT& uSizeInOut) {
    LPCITEMIDLIST  pidlTemp  = pidl;
    LPITEMIDLIST*  ppidlList =
        reinterpret_cast<LPITEMIDLIST *>(LocalAlloc(LPTR,
                                                    sizeof(LPITEMIDLIST) * uSizeInOut));
    if (pidlTemp && ppidlList) {
        UINT uCount;
        for (uCount = 0; ( (uCount < uSizeInOut) && (pidlTemp->mkid.cb) );
             ++uCount, pidlTemp = _ILNext(pidlTemp))
            ppidlList[uCount] = const_cast<LPITEMIDLIST>(pidlTemp);
    }
    return ppidlList;
}

LPITEMIDLIST* _SplitPidlEasy(LPCITEMIDLIST pidl, UINT& uSizeOut) {
    uSizeOut = _CountPidlParts(pidl);
    return _SplitPidl(pidl, uSizeOut);
}

// caller LocalFree's *ppidlOut
//  returned pidl should be combined with the history folder location
HRESULT _ConvertStdPidlToViewPidl_OrderSite(LPCITEMIDLIST pidlSecondLast,
                                            LPCITEMIDLIST pidlLast,
                                            LPITEMIDLIST *ppidlOut) {
    HRESULT hr = E_FAIL;

    // painfully construct the final pidl by concatenating the little
    //   peices  [special_viewpidl, iddpidl, heipidl]
    if ( _IsValid_IDPIDL(pidlSecondLast)                                     &&
         EQUIV_IDSIGN(IDDPIDL_SIGN,
                      (reinterpret_cast<LPBASEPIDL>
                       (const_cast<LPITEMIDLIST>(pidlSecondLast)))->usSign)  &&
         (_IsValid_HEIPIDL(pidlLast)) )
    {
        LPITEMIDLIST pidlViewTemp = NULL;
        hr = CreateSpecialViewPidl(VIEWPIDL_ORDER_SITE, &pidlViewTemp);
        if (SUCCEEDED(hr) && pidlViewTemp) 
        {
            hr = SHILCombine(pidlViewTemp, pidlSecondLast, ppidlOut);
            ILFree(pidlViewTemp);
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// caller LocalFree's *ppidlOut
//  returned pidl should be combined with the history folder location
HRESULT _ConvertStdPidlToViewPidl_OrderToday(LPITEMIDLIST pidlLast,
                                             LPITEMIDLIST *ppidlOut,
                                             USHORT usViewType = VIEWPIDL_ORDER_TODAY)
{
    HRESULT hr = E_FAIL;

    // painfully construct the final pidl by concatenating the little
    //   peices  [special_viewpidl, heipidl]
    if (_IsValid_HEIPIDL(pidlLast)) 
    {
        LPHEIPIDL    phei         = reinterpret_cast<LPHEIPIDL>(pidlLast);
        LPITEMIDLIST pidlViewTemp = NULL;
        hr = CreateSpecialViewPidl(usViewType, &pidlViewTemp);
        if (SUCCEEDED(hr) && pidlViewTemp) 
        {
            hr = SHILCombine(pidlViewTemp, reinterpret_cast<LPITEMIDLIST>(phei), ppidlOut);
            ILFree(pidlViewTemp);
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// remember to ILFree pidl
HRESULT ConvertStandardHistPidlToSpecialViewPidl(LPCITEMIDLIST pidlStandardHist,
                                                 USHORT        usViewType,
                                                 LPITEMIDLIST *ppidlOut) {
    if (!pidlStandardHist || !ppidlOut) 
    {
        return E_FAIL;
    }
    HRESULT hr = E_FAIL;

    UINT          uPidlCount;
    LPITEMIDLIST *ppidlSplit = _SplitPidlEasy(pidlStandardHist, uPidlCount);
    /* Standard Hist Pidl should be in this form:
     *          [IDIPIDL, IDDPIDL, HEIPIDL]
     *  ex:     [Today,   foo.com, http://foo.com/bar.html]
     */
    if (ppidlSplit) 
    {
        if (uPidlCount >= 3) 
        {
            LPITEMIDLIST pidlTemp = NULL;
            switch(usViewType) 
            {
            case VIEWPIDL_ORDER_FREQ:
            case VIEWPIDL_ORDER_TODAY:
                hr = _ConvertStdPidlToViewPidl_OrderToday(ppidlSplit[uPidlCount - 1],
                                                            &pidlTemp, usViewType);
                break;
            case VIEWPIDL_ORDER_SITE:
                hr = _ConvertStdPidlToViewPidl_OrderSite(ppidlSplit[uPidlCount - 2],
                                                           ppidlSplit[uPidlCount - 1],
                                                           &pidlTemp);
                break;
            default:
                hr = E_INVALIDARG;
            }
            if (SUCCEEDED(hr) && pidlTemp) 
            {
                *ppidlOut = pidlTemp;
                hr      = (*ppidlOut ? S_OK : E_OUTOFMEMORY);
            }
        }
        else {
            hr = E_INVALIDARG;
        }

        LocalFree(ppidlSplit);
        ppidlSplit = NULL;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// START OF JCORDELL CODE

#ifdef DEBUG
BOOL ValidBeginningOfDay( const SYSTEMTIME *pTime )
{
    return pTime->wHour == 0 && pTime->wMinute == 0 && pTime->wSecond == 0 && pTime->wMilliseconds == 0;
}

BOOL ValidBeginningOfDay( const FILETIME *pTime )
{
    SYSTEMTIME sysTime;

    FileTimeToSystemTime( pTime, &sysTime );
    return ValidBeginningOfDay( &sysTime);
}
#endif

void _CommonTimeFormatProcessing(const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    int *pdays_delta,
                                    int *pdays_delta_from_today,
                                    TCHAR *szStartDateBuffer,
                                    DWORD dwStartDateBuffer,
                                    SYSTEMTIME *pSysStartTime,
                                    SYSTEMTIME *pSysEndTime,
                                    LCID lcidUI)
{
    SYSTEMTIME sysStartTime, sysEndTime, sysLocalTime;
    FILETIME fileLocalTime;

    // ASSERTS
    ASSERT(ValidBeginningOfDay( pStartTime ));
    ASSERT(ValidBeginningOfDay( pEndTime ));

    // Get times in SYSTEMTIME format
    FileTimeToSystemTime( pStartTime, &sysStartTime );
    FileTimeToSystemTime( pEndTime, &sysEndTime );

    // Get string date of start time
    GetDateFormat(lcidUI, DATE_SHORTDATE, &sysStartTime, NULL, szStartDateBuffer, dwStartDateBuffer);

    // Get FILETIME of the first instant of today
    GetLocalTime( &sysLocalTime );
    sysLocalTime.wHour = sysLocalTime.wMinute = sysLocalTime.wSecond = sysLocalTime.wMilliseconds = 0;
    SystemTimeToFileTime( &sysLocalTime, &fileLocalTime );

    *pdays_delta = DAYS_DIFF(pEndTime, pStartTime);
    *pdays_delta_from_today = DAYS_DIFF(&fileLocalTime, pStartTime);
    *pSysEndTime = sysEndTime;
    *pSysStartTime = sysStartTime;
}

// this wrapper allows the FormatMessage wrapper to make use of FormatMessageLite, which
// does not require a code page for correct operation on Win9x.  The original FormatMessage calls
// used the FORMAT_MESSAGE_MAX_WIDTH_MASK (which is not relevant to our strings), and used an array
// of arguments.  Now we make the call compatible with FormatMessageLite.

DWORD FormatMessageLiteWrapperW(LPCWSTR lpSource, LPWSTR lpBuffer, DWORD cchBuffer, ...)
{
    va_list arguments;
    va_start(arguments, cchBuffer);
    WCHAR* pszTemp;
    DWORD dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING, lpSource, 0, 0, (LPWSTR)&pszTemp, 0, &arguments);
    if (dwRet)
    {
        StringCchCopy(lpBuffer, cchBuffer, pszTemp);
        LocalFree(pszTemp);
        pszTemp = NULL;
    }
    else
    {
        *lpBuffer = L'\0';
    }
    va_end(arguments);
    return dwRet;
}

BOOL GetTooltipForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    TCHAR *pszBuffer, int cchBuffer)
{
    SYSTEMTIME sysStartTime, sysEndTime;
    int days_delta;                     // number of days between start and end time
    int days_delta_from_today;          // number of days between today and start time
    TCHAR szStartDateBuffer[64];
    TCHAR szDayBuffer[64];
    TCHAR szEndDateBuffer[64];
    TCHAR *args[2];
    TCHAR szFmt[64];
    int idFormat;
    LANGID  lidUI;
    LCID    lcidUI;

    lidUI = MLGetUILanguage();
    lcidUI = MAKELCID(lidUI, SORT_DEFAULT);

    _CommonTimeFormatProcessing(pStartTime,
                                pEndTime,
                                &days_delta,
                                &days_delta_from_today,
                                szStartDateBuffer,
                                ARRAYSIZE(szStartDateBuffer),
                                &sysStartTime,
                                &sysEndTime,
                                lcidUI);
    if ( days_delta == 1 ) {
        args[0] = &szDayBuffer[0];
        idFormat = IDS_DAYTOOLTIP;

        // day sized bucket
        if ( days_delta_from_today == 0 ) {
            // today
            szDayBuffer[0] = 0;
            idFormat = IDS_TODAYTOOLTIP;
        }
        else if  ( days_delta_from_today > 0 && days_delta_from_today < 7 )
        {
            // within the last week, put day of week
            GetDateFormat(lcidUI, 0, &sysStartTime, TEXT("dddd"), szDayBuffer, ARRAYSIZE(szDayBuffer));
        }
        else {
            // just a plain day bucket
            StrCpyN( szDayBuffer, szStartDateBuffer, ARRAYSIZE(szDayBuffer) );
        }
    }
    else if ( days_delta == 7 && sysStartTime.wDayOfWeek == 1 ) {
        // week-size bucket starting on a Monday
        args[0] = &szStartDateBuffer[0];

        // make is point to the first string for safety sake. This will be ignored by wsprintf
        args[1] = args[0];
        idFormat = IDS_WEEKTOOLTIP;
    }
    else {
        // non-standard bucket (not exactly a week and not exactly a day)

        args[0] = &szStartDateBuffer[0];
        args[1] = &szEndDateBuffer[0];
        idFormat = IDS_MISCTOOLTIP;

        GetDateFormat(lcidUI, DATE_SHORTDATE, &sysEndTime, NULL, szEndDateBuffer, ARRAYSIZE(szEndDateBuffer) );
    }

    MLLoadString(idFormat, szFmt, ARRAYSIZE(szFmt));

    // NOTE, if the second parameter is not needed by the szFMt, then it will be ignored by wnsprintf
    if (idFormat == IDS_DAYTOOLTIP)
        wnsprintf(pszBuffer, cchBuffer, szFmt, args[0]);
    else
        FormatMessageLiteWrapperW(szFmt, pszBuffer, cchBuffer, args[0], args[1]);
    return TRUE;
}

BOOL GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    LPTSTR pszBuffer, int cchBuffer)
{
    SYSTEMTIME sysStartTime, sysEndTime;
    int days_delta;                     // number of days between start and end time
    int days_delta_from_today;          // number of days between today and start time
    TCHAR szStartDateBuffer[64];
    LANGID lidUI;
    LCID lcidUI;

    lidUI = MLGetUILanguage();
    lcidUI = MAKELCID(lidUI, SORT_DEFAULT);

    _CommonTimeFormatProcessing(pStartTime,
                                pEndTime,
                                &days_delta,
                                &days_delta_from_today,
                                szStartDateBuffer,
                                ARRAYSIZE(szStartDateBuffer),
                                &sysStartTime,
                                &sysEndTime,
                                lcidUI);
    if ( days_delta == 1 ) {
        // day sized bucket
        if ( days_delta_from_today == 0 ) {
            // today
            MLLoadString(IDS_TODAY, pszBuffer, cchBuffer);
        }
        else if  ( days_delta_from_today > 0 && days_delta_from_today < 7 )
        {
            // within the last week, put day of week
            int nResult = GetDateFormat(lcidUI, 0, &sysStartTime, TEXT("dddd"), pszBuffer, cchBuffer);


            ASSERT(nResult);
        }
        else {
            // just a plain day bucket
            StrCpyN( pszBuffer, szStartDateBuffer, cchBuffer );
        }
    }
    else if ( days_delta == 7 && sysStartTime.wDayOfWeek == 1 ) {
        // week-size bucket starting on a Monday
        TCHAR szFmt[64];

        int nWeeksAgo = days_delta_from_today / 7;

        if (nWeeksAgo == 1) {
            // print "Last Week"
            MLLoadString(IDS_LASTWEEK, pszBuffer, cchBuffer);
        }
        else {
            // print "n Weeks Ago"
            MLLoadString(IDS_WEEKSAGO, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(pszBuffer, cchBuffer, szFmt, nWeeksAgo);
        }
    }
    else {
        // non-standard bucket (not exactly a week and not exactly a day)
        TCHAR szFmt[64];
        TCHAR szEndDateBuffer[64];
        TCHAR *args[2];

        args[0] = &szStartDateBuffer[0];
        args[1] = &szEndDateBuffer[0];


        GetDateFormat(lcidUI, DATE_SHORTDATE, &sysEndTime, NULL, szEndDateBuffer, ARRAYSIZE(szEndDateBuffer) );

        MLLoadString(IDS_FROMTO, szFmt, ARRAYSIZE(szFmt));
        FormatMessageLiteWrapperW(szFmt, pszBuffer, cchBuffer, args[0], args[1]);
    }

    return TRUE;
}

//  END OF JCORDELL CODE

//  if !fOleMalloc, use LocalAlloc for speed  // ok to pass in NULL for lpStatURL
LPHEIPIDL _CreateHCacheFolderPidl(BOOL fOleMalloc, LPCTSTR pszUrl, FILETIME ftModified, LPSTATURL lpStatURL,
                                  __int64 llPriority/* = 0*/, DWORD dwNumHits/* = 0*/) // used in freqnecy view
{
    USHORT usUrlSize = (USHORT)((lstrlen(pszUrl) + 1) * sizeof(TCHAR));
    DWORD  dwSize = sizeof(HEIPIDL) + usUrlSize;
    USHORT usTitleSize = 0;
    BOOL fUseTitle = (lpStatURL && lpStatURL->pwcsTitle && _TitleIsGood(lpStatURL->pwcsTitle));
    if (fUseTitle)
        usTitleSize = (USHORT)((lstrlen(lpStatURL->pwcsTitle) + 1) * sizeof(WCHAR));

    dwSize += usTitleSize;

    LPHEIPIDL pheip = (LPHEIPIDL)_CreateBaseFolderPidl(fOleMalloc, dwSize, HEIPIDL_SIGN);

    if (pheip)
    {
        pheip->usUrl      = sizeof(HEIPIDL);
        pheip->usFlags    = lpStatURL ? HISTPIDL_VALIDINFO : 0;
        pheip->usTitle    = fUseTitle ? pheip->usUrl+usUrlSize :0;
        pheip->ftModified = ftModified;
        pheip->llPriority = llPriority;
        pheip->dwNumHits  = dwNumHits;
        if (lpStatURL)
        {
            pheip->ftLastVisited = lpStatURL->ftLastVisited;
            if (fUseTitle)
                StrCpyN((LPTSTR)(((BYTE*)pheip)+pheip->usTitle), lpStatURL->pwcsTitle, usTitleSize / sizeof(TCHAR));
        }
        else {
            //mm98: not so sure about the semantics on this one -- but this call
            //  with lpstaturl NULL (called from _NotifyWrite<--_WriteHistory<--WriteHistory<--CUrlHistory::_WriteToHistory
            //  makes for an uninitialised "Last Visited Member" which wreaks havoc
            //  when we want to order URLs by last visited
            pheip->ftLastVisited = ftModified;
        }
        StrCpyN((LPTSTR)(((BYTE*)pheip)+pheip->usUrl), pszUrl, usUrlSize / sizeof(TCHAR));
    }
    return pheip;
}

//  if !fOleMalloc, use LocalAlloc for speed
LPBASEPIDL _CreateIdCacheFolderPidl(BOOL fOleMalloc, USHORT usSign, LPCTSTR szId)
{
    DWORD  cch = lstrlen(szId) + 1;
    DWORD  dwSize = cch * sizeof(TCHAR);
    dwSize += sizeof(BASEPIDL);
    LPBASEPIDL pceip = _CreateBaseFolderPidl(fOleMalloc, dwSize, usSign);
    if (pceip)
    {
        // dst <- src
        // since pcei is ID type sign, _GetURLTitle points into correct place in pcei
        StrCpyN((LPTSTR)_GetURLTitle(pceip), szId, cch);
    }
    return pceip;
}

//  if !fOleAlloc, use LocalAlloc for speed
LPBASEPIDL _CreateBaseFolderPidl(BOOL fOleAlloc, DWORD cbSize, USHORT usSign)
{
    LPBASEPIDL pcei;
    DWORD cbTotalSize;

    //  Note: the buffer size returned by wininet includes INTERNET_CACHE_ENTRY_INFO
    cbTotalSize = sizeof(BASEPIDL) + cbSize;

    if (fOleAlloc)
    {
        pcei = (LPBASEPIDL)OleAlloc(cbTotalSize);
        if (pcei != NULL)
        {
            ZeroMemory(pcei, cbTotalSize);
        }
    }
    else
    {
        pcei = (LPBASEPIDL) LocalAlloc(GPTR, cbTotalSize);
        //  LocalAlloc zero inits
    }
    if (pcei)
    {
        pcei->cb = (USHORT)(cbTotalSize - sizeof(USHORT));
        pcei->usSign = usSign;
    }
    return pcei;
}

// returns a pidl (viewpidl)
//  You must free the pidl with ILFree

// cbExtra   -  count of how much to allocate at the end of the pidl
// ppbExtra  -  pointer to buffer at end of pidl that is cbExtra big
HRESULT CreateSpecialViewPidl(USHORT usViewType, LPITEMIDLIST* ppidlOut, UINT cbExtra /* = 0*/, LPBYTE *ppbExtra /* = NULL*/)
{
    HRESULT hr;

    if (ppidlOut) {
        *ppidlOut = NULL;

        ASSERT((usViewType > 0) &&
               ((usViewType <= VIEWPIDL_ORDER_MAX) ||
                (usViewType  == VIEWPIDL_SEARCH)));

        //   Tack another ITEMIDLIST on the end to be the empty "null terminating" pidl
        USHORT cbSize = sizeof(VIEWPIDL) + cbExtra + sizeof(ITEMIDLIST);
        // use the shell's allocator because folks will want to free it with ILFree
        VIEWPIDL *viewpidl = ((VIEWPIDL *)SHAlloc(cbSize));
        if (viewpidl) 
        {
            // this should also make the "next" pidl empty
            ZeroMemory(viewpidl, cbSize);
            viewpidl->cb         = (USHORT)(sizeof(VIEWPIDL) + cbExtra);
            viewpidl->usSign     = VIEWPIDL_SIGN;
            viewpidl->usViewType = usViewType;
            viewpidl->usExtra    = 0;  // currently unused

            if (ppbExtra)
                *ppbExtra = ((LPBYTE)viewpidl) + sizeof(VIEWPIDL);

            *ppidlOut = (LPITEMIDLIST)viewpidl;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\hsfolder.h ===
#ifndef HSFOLDER_H__
#define HSFOLDER_H__

#ifdef __cplusplus

#include <debug.h>
#include "iface.h"
#include <stralign.h>

// Forward class declarations
class CHistFolderEnum;
class CHistFolder;
class CHistItem;

#define LOTS_OF_FILES (10)

// The number of "top" sites displayed in the "Most Frequently Viewed..." history view
#define NUM_TOP_SITES  20

void _GetURLDispName(LPBASEPIDL pcei, LPTSTR pszName, UINT cchName) ;
UNALIGNED const TCHAR* _GetURLTitle(LPBASEPIDL pcei);
LPBASEPIDL _CreateBaseFolderPidl(BOOL fOleAlloc, DWORD cbSize, USHORT usSign);
LPBASEPIDL _CreateIdCacheFolderPidl(BOOL fOleAlloc, USHORT usSign, LPCTSTR szId);
LPHEIPIDL _CreateHCacheFolderPidl(BOOL fOleMalloc, LPCTSTR pszUrl, FILETIME ftModified, LPSTATURL lpStatURL,
                                  __int64 llPriority = 0, DWORD dwNumHits = 0);

#define ua_GetURLTitle(d,p) TSTR_ALIGNED_STACK_COPY(d,_GetURLTitle(p))

__inline LPCWSTR _GetURLTitleAlign(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf)
{
    LPCUTSTR urlTitle;

    urlTitle = _GetURLTitle(pcei);
#if defined(UNICODE) && defined(ALIGNMENT_MACHINE)
    if (TSTR_ALIGNED(urlTitle)) {
        return (LPCTSTR)urlTitle;
    } else {
        ualstrcpyn(szBuf, _GetURLTitle(pcei), cchBuf);
        return szBuf;
    }
#else
    return urlTitle;
#endif
}

// returns TRUE if _GetURLTitle would retrieve an URL when given this PIDL
inline BOOL _URLTitleIsURL(LPBASEPIDL pcei)
{
    return ((pcei->usSign == HEIPIDL_SIGN) && (((LPHEIPIDL) pcei)->usTitle == 0));
}

inline LPCTSTR HPidlToSourceUrl(LPBASEPIDL pidl)
{
    if (pidl->usSign == (USHORT)HEIPIDL_SIGN)
    {
        LPHEIPIDL pheipidl = (LPHEIPIDL) pidl;

        return (LPCTSTR)(((BYTE*)pheipidl) + pheipidl->usUrl);
    }
    return NULL;
}

inline LPCTSTR HPidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return HPidlToSourceUrl((LPBASEPIDL) pidl);
}

inline int _CompareHCURLs(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) 
{
    LPCTSTR url1     = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl1));
    LPCTSTR url2     = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl2));

    ASSERT(url1 && url2);
    
    return StrCmpI(url1, url2);
}

inline int _CompareHFolderPidl(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return StrCmpI(HPidlToSourceUrl((LPBASEPIDL)pidl1), HPidlToSourceUrl((LPBASEPIDL)pidl2));
}

///////////////////////
//
// Column definition for the History Folder Defview
//
enum {
    ICOLH_URL_NAME = 0,
    ICOLH_URL_TITLE,
    ICOLH_URL_LASTVISITED,
    ICOLH_URL_MAX         // Make sure this is the last enum item
};

#define INTERVAL_PREFIX_LEN (6)
#define INTERVAL_VERS_LEN (2)
#define INTERVAL_VERS (TEXT("01"))
#define OUR_VERS (1)
#define UNK_INTERVAL_VERS (0xFFFF)
#define RANGE_LEN (16)
#define INTERVAL_MIN_SIZE (RANGE_LEN+INTERVAL_PREFIX_LEN)
#define INTERVAL_SIZE (RANGE_LEN+INTERVAL_VERS_LEN+INTERVAL_PREFIX_LEN)
#define PREFIX_SIZE (RANGE_LEN+3)

//  NOTE: the interval is closed at the start but open at the end, that
//  is inclusion is time >= start and time < end
typedef struct _HSFINTERVAL
{
    FILETIME ftStart;
    FILETIME ftEnd;
    TCHAR  szPrefix[PREFIX_SIZE+1];
    USHORT usSign;
    USHORT usVers;
} HSFINTERVAL;


BOOL GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    LPTSTR pszBuffer, int cchBufferLength);
HRESULT _ValueToIntervalW(LPCUWSTR wzInterval, FILETIME *pftStart, FILETIME *pftEnd);

//  DeleteEntries filter callback
typedef BOOL (*PFNDELETECALLBACK)(LPINTERNET_CACHE_ENTRY_INFO pceiWorking, LPVOID pDelData, LPITEMIDLIST *ppidlNotify);

// Forward declarations for create instance functions 
HRESULT CHistItem_CreateInstance(CHistFolder *pHCFolder, HWND hwndOwner, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);

//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class CHistFolderEnum : public IEnumIDList
{
public:
    CHistFolderEnum(DWORD grfFlags, CHistFolder *pHCFolder);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    ~CHistFolderEnum();
    HRESULT _NextHistInterval(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderToday(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderSite(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderFreq(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderSearch(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    class OrderedList* _GetMostFrequentPages();
    LPCTSTR _GetLocalHost(void);

    LONG                _cRef;      // ref count
    CHistFolder    *_pHCFolder;// this is what we enumerate    
    UINT                _grfFlags;  // enumeration flags 
    UINT                _uFlags;    // local flags   
    LPINTERNET_CACHE_ENTRY_INFO _pceiWorking;        
    HANDLE              _hEnum;
    int              _cbCurrentInterval;     //  position in enum of time intervals
    int              _cbIntervals;
    HSFINTERVAL     *_pIntervalCache;

    HSFINTERVAL       *_pIntervalCur;
    class StrHash     *_pshHashTable;     // used to keep track of what I gave out
    class OrderedList *_polFrequentPages; // used to store most frequently viewed pgs
    IEnumSTATURL      *_pstatenum;        // used in search enumerator
    TCHAR   _szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH]; //  "My Computer"  cached...

    static BOOL_PTR s_DoCacheSearch(LPINTERNET_CACHE_ENTRY_INFO pcei,
                                LPTSTR pszUserName, UINT uUserNameLen, CHistFolderEnum *penum,
                                class _CurrentSearches *pcsThisThread, IUrlHistoryPriv *pUrlHistStg);
    static DWORD WINAPI s_CacheSearchThreadProc(CHistFolderEnum *penum);
};


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolder Object
//
//////////////////////////////////////////////////////////////////////////////

class CHistFolder : 
    public IShellFolder2, 
    public IShellIcon, 
    public IShellFolderViewType,
    public IShellFolderSearchable,
    public IHistSFPrivate,
    public IPersistFolder2
{
    friend CHistFolderEnum;
    friend CHistItem;
    friend HRESULT HistFolderView_CreateInstance(CHistFolder *pHCFolder, void **ppvOut);
    friend HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);
        
public:
    CHistFolder(FOLDER_TYPE FolderType);

public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid) { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum) { *ppenum = NULL; return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IShellFolderViewType Methods
    STDMETHODIMP EnumViews(ULONG grfFlags, IEnumIDList ** ppenum);
    STDMETHODIMP GetDefaultViewName(DWORD uFlags, LPWSTR *ppwszName);
    STDMETHODIMP GetViewTypeProperties(LPCITEMIDLIST pidl, DWORD *pdwFlags);
    STDMETHODIMP TranslateViewPidl(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView,
                                   LPITEMIDLIST *pidlOut);

    // IShellFolderSearchable Methods
    STDMETHODIMP FindString(LPCWSTR pwszTarget, DWORD *pdwFlags,
                            IUnknown *punkOnAsyncSearch, LPITEMIDLIST *ppidlOut);
    STDMETHODIMP CancelAsyncSearch(LPCITEMIDLIST pidlSearch, DWORD *pdwFlags);
    STDMETHODIMP InvalidateSearch(LPCITEMIDLIST pidlSearch, DWORD *pdwFlags);
    
    // IHistSFPrivate
    STDMETHODIMP SetCachePrefix(LPCWSTR pszCachePrefix);
    STDMETHODIMP SetDomain(LPCWSTR pszDomain);
    STDMETHODIMP WriteHistory(LPCWSTR pszPrefixedUrl, FILETIME ftExpires, 
                              FILETIME ftModified, LPITEMIDLIST * ppidlSelect);
    STDMETHODIMP ClearHistory();
    
    HRESULT _ExtractInfoFromPidl();

protected:
    ~CHistFolder();
    
    STDMETHODIMP _GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr);

    void _GetHistURLDispName(LPHEIPIDL phei, LPTSTR pszStr, UINT cchStr);

    HRESULT _CompareAlignedIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    HRESULT _CopyTSTRField(LPTSTR *ppszField, LPCTSTR pszValue);
    HRESULT _LoadIntervalCache();
    HRESULT _GetInterval(FILETIME *pftItem, BOOL fWeekOnly, HSFINTERVAL **pInterval);
    HRESULT _CreateInterval(FILETIME *pftStart, DWORD dwDays);
    HRESULT _PrefixUrl(LPCTSTR pszStrippedUrl,
                     FILETIME *pftLastModifiedTime,
                     LPTSTR pszPrefixedUrl,
                     DWORD cbPrefixedUrl);
    HRESULT _CopyEntries(LPCTSTR pszHistPrefix);
    HRESULT _DeleteEntries(LPCTSTR pszHistPrefix, PFNDELETECALLBACK pfnDeleteFilter, LPVOID pdcbData);
    HRESULT _DeleteInterval(HSFINTERVAL *pInterval);
    HRESULT _CleanUpHistory(FILETIME ftLimit, FILETIME ftTommorrow);
    HRESULT _ValidateIntervalCache();
    HRESULT _GetPrefixForInterval(LPCTSTR pszInterval, LPCTSTR *ppszCachePrefix);
    HRESULT _ViewType_NotifyEvent(LPITEMIDLIST pidlRoot,
                                  LPITEMIDLIST pidlHost,
                                  LPITEMIDLIST pidlPage,
                                  LONG         wEventId);

    HRESULT _WriteHistory(LPCTSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, 
                          BOOL fSendNotify, LPITEMIDLIST * ppidlSelect);
    HRESULT _NotifyWrite(LPTSTR pszUrl, int cchUrl, FILETIME *pftModified, LPITEMIDLIST * ppidlSelect);
    HRESULT _NotifyInterval(HSFINTERVAL *pInterval, LONG lEventID);
    IUrlHistoryPriv *_GetHistStg();
    HRESULT _EnsureHistStg();
    HRESULT _GetUserName(LPTSTR pszUserName, DWORD cchUserName);
    HRESULT _GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip);
    HRESULT _DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    LPITEMIDLIST _HostPidl(LPCTSTR pszHostUrl, HSFINTERVAL *pInterval);
    DWORD    _SearchFlatCacheForUrl(LPCTSTR pszUrl, LPINTERNET_CACHE_ENTRY_INFO pcei, DWORD *pdwBuffSize);
    
    HRESULT _ViewPidl_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _ViewType_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _ViewType_CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int     _View_ContinueCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    HRESULT _DeleteUrlFromBucket(LPCTSTR pszPrefixedUrl);
    HRESULT _ViewType_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    HRESULT _ViewBySite_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    HRESULT _ViewType_NotifyUpdateAll();
    HRESULT _ViewType_GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut);
    HRESULT _DeleteUrlHistoryGlobal(LPCTSTR pszUrl);
    DWORD   _GetHitCount(LPCTSTR pszUrl);
    LPHEIPIDL _CreateHCacheFolderPidlFromUrl(BOOL fOleMalloc, LPCTSTR pszPrefixedUrl);

    BOOL _IsLeaf();    
    
    LPCTSTR _GetLocalHost(void);

    LONG            _cRef;
    FOLDER_TYPE     _foldertype;
    TCHAR           *_pszCachePrefix;
    TCHAR           *_pszDomain;

    DWORD           _dwIntervalCached;
    FILETIME        _ftDayCached;
    int             _cbIntervals;
    HSFINTERVAL     *_pIntervalCache;
    BOOL            _fValidatingCache;

    UINT            _uFlags;    // copied from CacheFolder struct
    LPITEMIDLIST    _pidl;      // copied from CacheFolder struct
    LPITEMIDLIST    _pidlRest;  // suffix of _pidl
    IUrlHistoryPriv *_pUrlHistStg;  // used to get extended properties of history leafs

    UINT            _uViewType; // if this shell folder is implementing a special view
    UINT            _uViewDepth; // depth of the pidl

    const static DWORD    _rdwFlagsTable[];

    TCHAR   _szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH]; //  "My Computer"  cached...

    class _CurrentSearches *_pcsCurrentSearch; // for CacheSearches
    static HRESULT CALLBACK _sViewCallback(IShellView *psv, IShellFolder *psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

////////////////////////////////////////////////////////////////////////////
//
// CHistItem Object
//
////////////////////////////////////////////////////////////////////////////

class CHistItem : public CBaseItem
{
    // CHistItem interfaces
    friend HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);

public:
    CHistItem();
    HRESULT Initialize(CHistFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);

    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);

    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);

    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

protected:
    ~CHistItem();

    virtual LPCTSTR _GetUrl(int nIndex);
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei);
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl);
    BOOL _ZoneCheck(int nIndex, DWORD dwUrlAction);

    FOLDER_TYPE       _foldertype;  // are we a history item or cache item
    CHistFolder* _pHCFolder;   // back pointer to our shell folder
    static INT_PTR CALLBACK _sPropDlgProc(HWND, UINT, WPARAM, LPARAM);
    HRESULT _CreateFileDescriptorW(STGMEDIUM *pSTM);

};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\hsfutils.h ===
#ifndef HSFUTILS_H__
#define HSFUTILS_H__

#ifdef __cplusplus
extern "C" {
#endif

UINT    MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);

void    _StringFromStatus(LPTSTR lpszBuff, unsigned cbSize, unsigned uStatus, DWORD dwAttributes);

void    _CopyCEI(UNALIGNED INTERNET_CACHE_ENTRY_INFO * pdst, LPINTERNET_CACHE_ENTRY_INFO psrc, DWORD dwBuffSize);

LPCTSTR _StripContainerUrlUrl(LPCTSTR pszHistoryUrl);
LPCTSTR _StripHistoryUrlToUrl(LPCTSTR pszHistoryUrl);
LPCTSTR _FindURLFileName(LPCTSTR pszURL);
LPBASEPIDL _IsValid_IDPIDL(LPCITEMIDLIST pidl);
LPHEIPIDL _IsValid_HEIPIDL(LPCITEMIDLIST pidl);
LPCTSTR _GetUrlForPidl(LPCITEMIDLIST pidl);
LPCTSTR _FindURLFileName(LPCTSTR pszURL);

void _GetURLHostFromUrl_NoStrip(LPCTSTR lpszUrl, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost);
void _GetURLHost(LPINTERNET_CACHE_ENTRY_INFO pcei, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost);
#define _GetURLHostFromUrl(lpszUrl, szHost, dwHostSize, pszLocalHost) \
        _GetURLHostFromUrl_NoStrip(_StripHistoryUrlToUrl(lpszUrl), szHost, dwHostSize, pszLocalHost)

// Forward declarations IContextMenu of helper functions
void    _GenerateEvent(LONG lEventId, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew);
int     _LaunchApp(HWND hwnd, LPCTSTR lpszPath);
int     _LaunchAppForPidl(HWND hwnd, LPITEMIDLIST pidl);
int     _GetCmdID(LPCSTR pszCmd);
HRESULT _CreatePropSheet(HWND hwnd, LPCITEMIDLIST pidl, int iDlg, DLGPROC pfnDlgProc, LPCTSTR pszTitle);

// Forward declarations of IDataObject helper functions
LPCTSTR _FindURLFileName(LPCTSTR pszURL);
BOOL    _FilterUserName(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix, LPTSTR pszUserName);
BOOL    _FilterPrefix(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix);

LPCTSTR ConditionallyDecodeUTF8(LPCTSTR pszUrl, LPTSTR pszBuf, DWORD cchBuf);

INT_PTR CALLBACK HistoryConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

void    FileTimeToDateTimeStringInternal(UNALIGNED FILETIME * lpft, LPTSTR pszText, int cchText, BOOL fUsePerceivedTime);

void MakeLegalFilenameA(LPSTR pszFilename, int cchFilename);
void MakeLegalFilenameW(LPWSTR pszFilename);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\util\local.h ===
//
// Local private header file

#include "priv.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\local.h ===
//
// Local private header file

#ifndef _LOCAL_H_
#define _LOCAL_H_

#include "priv.h"

#define CONST_VTABLE

// Max urlcache entry we will deal with.

//#define MAX_URLCACHE_ENTRY  4096
#define MAX_URLCACHE_ENTRY  MAX_CACHE_ENTRY_INFO_SIZE  // from wininet.h

// PIDL format for cache folder...
typedef struct
{
    USHORT cb;
    USHORT usSign;
} BASEPIDL;
typedef UNALIGNED BASEPIDL *LPBASEPIDL;

// If TITLE, etc in LPHEIPIDL is good, vs we have to QueryUrl for it
#define HISTPIDL_VALIDINFO    (0x1)

// PIDL format for history leaf folder...
typedef struct
{
    USHORT cb;
    USHORT usSign;
    USHORT usUrl;
    USHORT usFlags;
    USHORT usTitle;
    FILETIME ftModified;
    FILETIME ftLastVisited;
    DWORD    dwNumHits;
    __int64  llPriority;
} HEIPIDL;
typedef UNALIGNED HEIPIDL *LPHEIPIDL;

// PIDL format for history non leaf items...
typedef struct
{
    USHORT cb;
    USHORT usSign;
    TCHAR szID[MAX_PATH];
} HIDPIDL;
typedef UNALIGNED HIDPIDL *LPHIDPIDL;

// PIDL format for "views"
typedef struct
{
    USHORT cb;
    USHORT usSign;
    USHORT usViewType;
    USHORT usExtra; // reserved for later use.
} VIEWPIDL;
typedef UNALIGNED VIEWPIDL *LPVIEWPIDL;

typedef struct /* : VIEWPIDL*/
{
    // histpidl
    USHORT   cb;
    USHORT   usSign; /* must be == VIEWPIDL_SEARCH */
    // viewpidl
    USHORT   usViewType;
    USHORT   usExtra;
    // viewpidl_search
    FILETIME ftSearchKey;
} SEARCHVIEWPIDL;
typedef UNALIGNED SEARCHVIEWPIDL *LPSEARCHVIEWPIDL;

// VIEWPIDL types
#define VIEWPIDL_ORDER_SITE   1//0x2
#define VIEWPIDL_ORDER_FREQ   2//0x3
#define VIEWPIDL_ORDER_TODAY  3//0x1
#define VIEWPIDL_ORDER_MAX    3 // highest VIEWPIDL

// Search View > VIEWPIDL_ORDER_MAX because its
//   not enumerated with the rest of the views
//   (esentially its not a "view" to the caller,
//    but this is how its implemented under the hood)
#define VIEWPIDL_SEARCH 0x4C44

// FILETIME secticks
#define FILE_SEC_TICKS (10000000)
// SECS PER DAY
#define DAY_SECS (24*60*60)

// Due hack used in shdocvw for recognizing LOCATION pidl, make sure neither byte
// has 4's and 1's bit set (ie 0x50 & value == 0 for both bytes)
#define CEIPIDL_SIGN        0x6360  //cP
#define IDIPIDL_SIGN         0x6369  //ci interval id
#define IDTPIDL_SIGN         0x6364  //cd interval id (TODAY)
#define IDDPIDL_SIGN         0x6365  //ce domain id
#define HEIPIDL_SIGN         0x6368  //ch history leaf pidl
#define VIEWPIDL_SIGN        0x6366  /*mm: this is a "history view" pidl to allow
                                           multiple 'views' on the history        */
#define FSWPIDL_SIGN         0x6367

#define VALID_IDSIGN(usSign) ((usSign) == IDIPIDL_SIGN || (usSign) == IDTPIDL_SIGN || (usSign) == IDDPIDL_SIGN)
#define EQUIV_IDSIGN(usSign1,usSign2) ((usSign1)==(usSign2)|| \
((usSign1)==IDIPIDL_SIGN && (usSign2)==IDTPIDL_SIGN)|| \
((usSign2)==IDIPIDL_SIGN && (usSign1)==IDTPIDL_SIGN))

#define IS_VALID_VIEWPIDL(pidl)     ( (((LPBASEPIDL)pidl)->cb >= sizeof(VIEWPIDL)) && \
                                      (((LPBASEPIDL)pidl)->usSign == (USHORT)VIEWPIDL_SIGN) )
#define IS_EQUAL_VIEWPIDL(pidl1,pidl2)  ((IS_VALID_VIEWPIDL(pidl1)) && (IS_VALID_VIEWPIDL(pidl2)) && \
                                         (((LPVIEWPIDL)pidl1)->usViewType == ((LPVIEWPIDL)pidl2)->usViewType) && \
                                         (((LPVIEWPIDL)pidl1)->usExtra    == ((LPVIEWPIDL)pidl2)->usExtra))
    
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#ifdef __cplusplus
extern "C" {
#endif

    //  Abandon mutex after 2 minutes of waiting
#define FAILSAFE_TIMEOUT (120000)

extern HANDLE g_hMutexHistory;
extern const CHAR c_szOpen[];
extern const CHAR c_szDelcache[];
extern const CHAR c_szProperties[];
extern const CHAR c_szCopy[];
extern const TCHAR c_szHistPrefix[];



#ifdef __cplusplus
};
#endif

    
typedef enum
{
    FOLDER_TYPE_Hist = 1,
    FOLDER_TYPE_HistInterval,
    FOLDER_TYPE_HistDomain,
    FOLDER_TYPE_HistItem
} FOLDER_TYPE;

#define IsLeaf(x) (x == FOLDER_TYPE_HistDomain)
#define IsHistoryFolder(x) (x==FOLDER_TYPE_Hist||x==FOLDER_TYPE_HistInterval||x==FOLDER_TYPE_HistDomain)

//IE64 compatible pointer difference
#define PtrDifference(x,y)      ((LPBYTE)(x)-(LPBYTE)(y))

//BOOL DeleteUrlCacheEntry(LPCSTR lpszUrlName);

#include "hsfutils.h"  // NOTE: must come at end to get all the definitions

#endif // _LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hist\hsfutils.c ===
#include "local.h"

#include "resource.h"

#include <mluisupp.h>

#ifdef _HSFOLDER
#define LODWORD(_qw)    (DWORD)(_qw)

// Invoke Command verb strings
const CHAR c_szOpen[]       = "open";
const CHAR c_szDelcache[]   = "delete";
const CHAR c_szProperties[] = "properties";
const CHAR c_szCopy[]       = "copy";


void FileTimeToDateTimeStringInternal(FILETIME UNALIGNED *ulpft, LPTSTR pszText, int cchText, BOOL fUsePerceivedTime)
{
    FILETIME ft;
    FILETIME aft;
    LPFILETIME lpft;

    aft = *ulpft;
    lpft = &aft;

    if (!fUsePerceivedTime && (FILETIMEtoInt64(*lpft) != FT_NTFS_UNKNOWNGMT))
        FileTimeToLocalFileTime(lpft, &ft);
    else
        ft = *lpft;

    if (FILETIMEtoInt64(ft) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ft) == FT_FAT_UNKNOWNLOCAL)
    {
        static TCHAR szNone[40] = {0};
        if (szNone[0] == 0)
            MLLoadString(IDS_HSFNONE, szNone, ARRAYSIZE(szNone));

        StrCpyN(pszText, szNone, cchText);
    }
    else
    {
        TCHAR szTempStr[MAX_PATH];
        LPTSTR pszTempStr = szTempStr;
        SYSTEMTIME st;
    
        FileTimeToSystemTime(&ft, &st);

        if (GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szTempStr, ARRAYSIZE(szTempStr)) > 0)
        {
            int iLen = lstrlen(szTempStr);
            ASSERT(TEXT('\0') == szTempStr[iLen]);  // Make sure multi-byte isn't biting us.
            pszTempStr = (LPTSTR)(pszTempStr + iLen);
            *pszTempStr++ = ' ';
            GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszTempStr, ARRAYSIZE(szTempStr)-(iLen+1));
            StrCpyN(pszText, szTempStr, cchText);
        }
    }
}


HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    HINSTANCE hinst = MLLoadShellLangResources();
    hmParent = LoadMenu_PrivateNoMungeW(hinst, MAKEINTRESOURCEW(id));
    if (!hmParent)
    {
        long error = GetLastError();
        return NULL;
    }

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    MLFreeLibrary(hinst);

    return hmPopup;
}

UINT MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu,  UINT idCmdFirst, UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    
    DestroyMenu(hmMerge);
    return idCmdLast;
}

///////////////////////////////////////////////////////////////////////////////
//
// Helper Fuctions for item.cpp and folder.cpp
//
///////////////////////////////////////////////////////////////////////////////

// copy and flatten the CACHE_ENTRY_INFO data

void _CopyCEI(UNALIGNED INTERNET_CACHE_ENTRY_INFO *pdst, LPINTERNET_CACHE_ENTRY_INFO psrc, DWORD dwBuffSize)
{
    // This assumes how urlcache does allocation
    memcpy(pdst, psrc, dwBuffSize);

    // convert pointers to offsets
    pdst->lpszSourceUrlName = (LPTSTR) PtrDifference(psrc->lpszSourceUrlName, psrc);
    pdst->lpszLocalFileName = (LPTSTR) PtrDifference(psrc->lpszLocalFileName, psrc);
    pdst->lpszFileExtension = (LPTSTR) PtrDifference(psrc->lpszFileExtension, psrc);
    pdst->lpHeaderInfo      = psrc->lpHeaderInfo ? (TCHAR*) PtrDifference(psrc->lpHeaderInfo, psrc) : NULL;
}

INT g_fProfilesEnabled = -1;

BOOL IsProfilesEnabled();

BOOL _FilterUserName(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix, LPTSTR pszUserName)
{
    TCHAR szTemp[MAX_URL_STRING];
    LPCTSTR pszTemp = szTemp;
    
    // chrisfra 3/27/97, more constant crapola.  this all needs to be fixed.
    TCHAR szPrefix[80];
    BOOL fRet = 0;
    
    if (g_fProfilesEnabled==-1)
    {
        g_fProfilesEnabled = IsProfilesEnabled();
    }

    if (g_fProfilesEnabled)
    {
        return TRUE;
    }

    StrCpyN(szTemp, pcei->lpszSourceUrlName, ARRAYSIZE(szTemp));
    StrCpyN(szPrefix, pszCachePrefix, ARRAYSIZE(szPrefix));
    StrCatBuff(szPrefix, pszUserName, ARRAYSIZE(szPrefix));

    // find the '@' character if it exists
    pszTemp = StrChr(pszTemp, TEXT('@'));
    
    if ( (pszTemp) && (*pszTemp == TEXT('@')) )
    {
        fRet = (StrCmpNI(szTemp, szPrefix, lstrlen(szPrefix)) == 0);
    }
    else
    {
        fRet = (*pszUserName == TEXT('\0'));
    }

    return fRet;
}


BOOL _FilterPrefix(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix)
{
#define MAX_PREFIX (80)
    TCHAR szTemp[MAX_URL_STRING];
    LPCTSTR pszStripped;
    BOOL fRet = 0;
    
    StrCpyN(szTemp, pcei->lpszSourceUrlName, ARRAYSIZE(szTemp));
    pszStripped = _StripContainerUrlUrl(szTemp);

    if (pszStripped && pszStripped-szTemp < MAX_PREFIX)
    {
        fRet = (StrCmpNI(szTemp, pszCachePrefix, ((int) (pszStripped-szTemp))/sizeof(TCHAR)) == 0);
    }
    return fRet;
}

LPCTSTR _StripContainerUrlUrl(LPCTSTR pszHistoryUrl)
{
    //  NOTE: for our purposes, we don't want a history URL if we can't detect our
    //  prefix, so we return NULL.

    LPCTSTR pszTemp = pszHistoryUrl;
    LPCTSTR pszCPrefix;
    LPCTSTR pszReturn = NULL;
    
    //  Check for "Visited: "
    pszCPrefix = c_szHistPrefix;
    while (*pszTemp == *pszCPrefix && *pszTemp != TEXT('\0'))
    {
         pszTemp = CharNext(pszTemp); 
         pszCPrefix = CharNext(pszCPrefix);
    }
        
    if (*pszCPrefix == TEXT('\0'))
    {
        //  Found "Visited: "
        pszReturn = pszTemp;
    }
    else if (pszTemp == (LPTSTR) pszHistoryUrl)
    {
        //  Check for ":YYYYMMDDYYYYMMDD: "
        pszCPrefix = TEXT(":nnnnnnnnnnnnnnnn: ");
        while (*pszTemp != TEXT('\0'))
        {
            if (*pszCPrefix == TEXT('n'))
            {
                if (*pszTemp < TEXT('0') || *pszTemp > TEXT('9')) break;
            }
            else if (*pszCPrefix != *pszTemp) break;
            pszTemp = CharNext(pszTemp); 
            pszCPrefix = CharNext(pszCPrefix);
        }
    }
    return (*pszCPrefix == TEXT('\0')) ? pszTemp : pszReturn;
}

LPCTSTR _StripHistoryUrlToUrl(LPCTSTR pszHistoryUrl)
{
    LPCTSTR pszTemp = pszHistoryUrl;

    if (!pszHistoryUrl)
        return NULL;

    pszTemp = StrChr(pszHistoryUrl, TEXT('@'));
    if (pszTemp && *pszTemp)
        return CharNext(pszTemp);
    
    pszTemp = StrChr(pszHistoryUrl, TEXT(' '));
    if (pszTemp && *pszTemp)
        return CharNext(pszTemp);
    else
        return NULL;    // error, the URL passed in wasn't a history url
}

// assumes this is a real URL and not a "history" url
void _GetURLHostFromUrl_NoStrip(LPCTSTR lpszUrl, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost)
{
    DWORD cch = dwHostSize;
    if (S_OK != UrlGetPart(lpszUrl, szHost, &cch, URL_PART_HOSTNAME, 0) 
        || !*szHost)
    {
        //  default to the local host name.
        StrCpyN(szHost, pszLocalHost, dwHostSize);
    }
}

void _GetURLHost(LPINTERNET_CACHE_ENTRY_INFO pcei, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost)
{  
    TCHAR szSourceUrl[MAX_URL_STRING];

    ASSERT(ARRAYSIZE(szSourceUrl) > lstrlen(pcei->lpszSourceUrlName))
    StrCpyN(szSourceUrl, pcei->lpszSourceUrlName, ARRAYSIZE(szSourceUrl));

    _GetURLHostFromUrl(szSourceUrl, szHost, dwHostSize, pszLocalHost);
}

LPHEIPIDL _IsValid_HEIPIDL(LPCITEMIDLIST pidl)
{
    LPHEIPIDL phei = (LPHEIPIDL)pidl;

    if (phei && ((phei->cb > sizeof(HEIPIDL)) && (phei->usSign == (USHORT)HEIPIDL_SIGN)) &&
        (phei->usUrl == 0 || phei->usUrl < phei->cb) &&
        (phei->usTitle == 0 || (phei->usTitle + sizeof(WCHAR)) <= phei->cb))
    {
        return phei;
    }
    return NULL;
}

LPBASEPIDL _IsValid_IDPIDL(LPCITEMIDLIST pidl)
{
    LPBASEPIDL pcei = (LPBASEPIDL)pidl;

    if (pcei && VALID_IDSIGN(pcei->usSign) && pcei->cb > 0)
    {
        return pcei;
    }
    return NULL;
}

LPCTSTR _FindURLFileName(LPCTSTR pszURL)
{
    LPCTSTR psz, pszRet = pszURL;   // need to set to pszURL in case no '/'
    LPCTSTR pszNextToLast = NULL;
    
    for (psz = pszURL; *psz; psz = CharNext(psz))
    {
        if ((*psz == TEXT('\\') || *psz == TEXT('/')))
        {
            pszNextToLast = pszRet;
            pszRet = CharNext(psz);
        }
    }
    return *pszRet ? pszRet : pszNextToLast;   
}

int _LaunchApp(HWND hwnd, LPCTSTR pszPath)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.hwnd             = hwnd;
    ei.lpFile           = pszPath;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}


int _LaunchAppForPidl(HWND hwnd, LPITEMIDLIST pidl)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.fMask            = SEE_MASK_IDLIST;
    ei.hwnd             = hwnd;
    ei.lpIDList         = pidl;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}

void _GenerateEvent(LONG lEventId, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlIn, LPCITEMIDLIST pidlNewIn)
{
    LPITEMIDLIST pidl;
    if (pidlIn)
    {
        pidl = ILCombine(pidlFolder, pidlIn);
    }
    else
    {   
        pidl = ILClone(pidlFolder);
    }
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        ILFree(pidl);
    }
}

const struct {
    LPCSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    { c_szOpen,         RSVIDM_OPEN },
    { c_szCopy,         RSVIDM_COPY },
    { c_szDelcache,     RSVIDM_DELCACHE },
    { c_szProperties,   RSVIDM_PROPERTIES }
};

int _GetCmdID(LPCSTR pszCmd)
{
    if (HIWORD(pszCmd))
    {
        int i;

        for (i = 0; i < ARRAYSIZE(rgcmds); i++)
        {
            if (StrCmpIA(rgcmds[i].pszVerb, pszCmd) == 0)
            {
                return rgcmds[i].idCmd;
            }
        }

        return -1;  // unknown
    }
    return (int)LOWORD(pszCmd);
}

HRESULT _CreatePropSheet(HWND hwnd, LPCITEMIDLIST pidl, int iDlg, DLGPROC pfnDlgProc, LPCTSTR pszTitle)
{
    PROPSHEETPAGE psp = { 0 };
    PROPSHEETHEADER psh = { 0 } ;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = 0;
    psp.hInstance       = MLGetHinst();
    psp.DUMMYUNION_MEMBER(pszTemplate)     = MAKEINTRESOURCE(iDlg);
    psp.DUMMYUNION2_MEMBER(pszIcon)        = NULL;
    psp.pfnDlgProc      = pfnDlgProc;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)pidl; // send it the cache entry struct

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_PROPTITLE;
    psh.hwndParent  = hwnd;
    psh.pszCaption  = pszTitle;
    psh.nPages      = 1;
    psh.DUMMYUNION2_MEMBER(nStartPage)  = 0;
    psh.DUMMYUNION3_MEMBER(ppsp)        = (LPCPROPSHEETPAGE)&psp;

    // invoke the property sheet
    PropertySheet(&psh);
    
    return NOERROR;
}

INT_PTR CALLBACK HistoryConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message) {
        
    case WM_INITDIALOG:
        SetDlgItemText(hDlg, IDD_TEXT4, (LPCTSTR)lParam);
        break;            
        
    case WM_DESTROY:
        break;
        
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDYES:
        case IDNO:
        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;
}

// This function restores the Unicode characters from file system URLs
//
// If the URL isn't a file URL, it is copied directly to pszBuf.  Otherwise, any 
// UTF8-escaped parts of the URL are converted into Unicode, and the result is 
// stored in pszBuf.  This should be the same as the string we received in 
// History in the first place
//
// The return value is always pszBuf.  
// The input and output buffers may be the same.


LPCTSTR ConditionallyDecodeUTF8(LPCTSTR pszUrl, LPTSTR pszBuf, DWORD cchBuf)
{
    BOOL fDecoded  = FALSE;

    if (PathIsFilePath(pszUrl))
    {
        TCHAR szDisplayUrl[MAX_URL_STRING];
        DWORD cchDisplayUrl = ARRAYSIZE(szDisplayUrl);
        DWORD cchBuf2 = cchBuf; // we may need the old cchBuf later

        // After PrepareUrlForDisplayUTF8, we have a fully unescaped URL.  If we 
        // ShellExec this, then Shell will unescape it again, so we need to re-escape
        // it to preserve any real %dd sequences that might be in the string. 

        if (SUCCEEDED(PrepareURLForDisplayUTF8(pszUrl, szDisplayUrl, &cchDisplayUrl, TRUE)) &&
            SUCCEEDED(UrlCanonicalize(szDisplayUrl, pszBuf, &cchBuf2, URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT)))
        {
            fDecoded = TRUE;
        }
    }

    if (!fDecoded && (pszUrl != pszBuf))
    {
        StrCpyN(pszBuf, pszUrl, cchBuf);
    }

    return pszBuf;
}

//
// These routines make a string into a legal filename by replacing
// all invalid characters with spaces.
//
// The list of invalid characters was obtained from the NT error
// message you get when you try to rename a file to an invalid name.
//

#ifndef UNICODE
#error The MakeLegalFilename code only works when it's part of a UNICODE build
#endif

//
// This function takes a string and makes it into a
// valid filename (by calling PathCleanupSpec).
//
// The PathCleanupSpec function wants to know what
// directory the file will live in.  But it's going
// on the clipboard, so we don't know.  We just
// guess the desktop.
//
// It only uses this path to decide if the filesystem
// supports long filenames or not, and to check for
// MAX_PATH overflow.
//
void MakeLegalFilenameW(LPWSTR pszFilename)
{
    WCHAR szDesktopPath[MAX_PATH];

    GetWindowsDirectoryW(szDesktopPath, ARRAYSIZE(szDesktopPath));
    PathCleanupSpec(szDesktopPath, pszFilename);

}

//
// ANSI wrapper for above function
//
void MakeLegalFilenameA(LPSTR pszFilename, int cchFilename)
{
    WCHAR szFilenameW[MAX_PATH];

    SHAnsiToUnicode(pszFilename, szFilenameW, ARRAYSIZE(szFilenameW));

    MakeLegalFilenameW(szFilenameW);

    SHUnicodeToAnsi(szFilenameW, pszFilename, cchFilename);

}

#endif  // _HSFOLDER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\about.c ===
//
// about.c
//
//
// common about dialog for File Manager, Program Manager, Control Panel
//

#include "shellprv.h"
#pragma  hdrstop

#include <common.ver>   // for VER_LEGALCOPYRIGHT_YEARS
#include "ids.h"        // for IDD_EULA
#include <winbrand.h>   // for special Windows branding DLL resource IDs

#define STRING_SEPARATOR TEXT('#')
#define MAX_REG_VALUE   256

#define BytesToK(pDW)   (*(pDW) = (*(pDW) + 512) / 1024)        // round up

typedef struct {
        HICON   hIcon;
        LPCTSTR szApp;
        LPCTSTR szOtherStuff;
} ABOUT_PARAMS, *LPABOUT_PARAMS;

#define REG_SETUP   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

BOOL_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

int WINAPI ShellAboutW(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon)
{
    ABOUT_PARAMS ap;

    ap.hIcon = hIcon;
    ap.szApp = (LPWSTR)szApp;
    ap.szOtherStuff = szOtherStuff;

    return (int)DialogBoxParam(HINST_THISDLL, (LPTSTR)MAKEINTRESOURCE(DLG_ABOUT),
                          hWnd, AboutDlgProc, (LPARAM)&ap);
}

INT  APIENTRY ShellAboutA( HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon)
{
   DWORD cchLen;
   DWORD dwRet = 0;
   LPWSTR lpszAppW = NULL;
   LPWSTR lpszOtherStuffW = NULL;

   if (szApp)
   {
      cchLen = lstrlenA(szApp)+1;
      if (!(lpszAppW = (LPWSTR)LocalAlloc(LMEM_FIXED, (cchLen * sizeof(WCHAR)))))
      {
          goto Cleanup;
      }
      else
      {
         if (!MultiByteToWideChar(CP_ACP, 0, szApp, -1,
            lpszAppW, cchLen))
         {
            // Failed to convert
            goto Cleanup;
         }
      }
   }

   if (szOtherStuff)
   {
      cchLen = lstrlenA(szOtherStuff)+1;
      if (!(lpszOtherStuffW = (LPWSTR)LocalAlloc(LMEM_FIXED,
            (cchLen * sizeof(WCHAR)))))
      {
         goto Cleanup;
      }
      else
      {
         if (!MultiByteToWideChar(CP_ACP, 0, (LPSTR)szOtherStuff, -1,
            lpszOtherStuffW, cchLen))
         {
            // Failed to convert
            goto Cleanup;
         }
      }
   }

   dwRet = ShellAboutW(hWnd, lpszAppW, lpszOtherStuffW, hIcon);

Cleanup:
   if (lpszAppW)
   {
      LocalFree(lpszAppW);
   }

   if (lpszOtherStuffW)
   {
      LocalFree(lpszOtherStuffW);
   }

   return(dwRet);
}

DWORD RegGetStringAndRealloc( HKEY hkey, LPCTSTR lpszValue, LPTSTR *lplpsz, LPDWORD lpSize )
{
    DWORD       err;
    DWORD       dwSize;
    DWORD       dwType;
    LPTSTR      lpszNew;

    *lplpsz[0] = TEXT('\0');        // In case of error

    dwSize = *lpSize;
    err = SHQueryValueEx(hkey, (LPTSTR)lpszValue, 0, &dwType,
                          (LPBYTE)*lplpsz, &dwSize);

    if (err == ERROR_MORE_DATA)
    {
        lpszNew = (LPTSTR)LocalReAlloc((HLOCAL)*lplpsz, dwSize, LMEM_MOVEABLE);

        if (lpszNew)
        {
            *lplpsz = lpszNew;
            *lpSize = dwSize;
            err = SHQueryValueEx(hkey, (LPTSTR)lpszValue, 0, &dwType,
                                  (LPBYTE)*lplpsz, &dwSize);
        }
    }
    return err;
}


// Some Static strings that we use to read from the registry
// const char c_szAboutCurrentBuild[] = "CurrentBuild";
const TCHAR c_szAboutRegisteredUser[] = TEXT("RegisteredOwner");
const TCHAR c_szAboutRegisteredOrganization[] = TEXT("RegisteredOrganization");
const TCHAR c_szAboutProductID[] = TEXT("ProductID");
const TCHAR c_szAboutOEMID[] = TEXT("OEMID");


void _InitAboutDlg(HWND hDlg, LPABOUT_PARAMS lpap)
{
    HKEY        hkey;
    TCHAR       szldK[16];
    TCHAR       szBuffer[64];
    TCHAR       szTemp[64];
    TCHAR       szTitle[64];
    TCHAR       szMessage[200];
    TCHAR       szNumBuf1[32];
    LPTSTR      lpTemp;
    LPTSTR      lpszValue = NULL;
    DWORD       cb;
    DWORD       err;

    /*
     * Display app title
     */

    // REVIEW Note the const ->nonconst cast here

    for (lpTemp = (LPTSTR)lpap->szApp; 1 ; lpTemp = CharNext(lpTemp))
    {
        if (*lpTemp == TEXT('\0'))
        {
            GetWindowText(hDlg, szBuffer, ARRAYSIZE(szBuffer));
            wnsprintf(szTitle, ARRAYSIZE(szTitle), szBuffer, (LPTSTR)lpap->szApp);
            SetWindowText(hDlg, szTitle);
            break;
        }
        if (*lpTemp == STRING_SEPARATOR)
        {
            *lpTemp++ = TEXT('\0');
            SetWindowText(hDlg, lpap->szApp);
            lpap->szApp = lpTemp;
            break;
        }
    }

    GetDlgItemText(hDlg, IDD_APPNAME, szBuffer, ARRAYSIZE(szBuffer));
    wnsprintf(szTitle, ARRAYSIZE(szTitle), szBuffer, lpap->szApp);
    SetDlgItemText(hDlg, IDD_APPNAME, szTitle);

    // other stuff goes here...

    SetDlgItemText(hDlg, IDD_OTHERSTUFF, lpap->szOtherStuff);

    SendDlgItemMessage(hDlg, IDD_ICON, STM_SETICON, (WPARAM)lpap->hIcon, 0L);
    if (!lpap->hIcon)
        ShowWindow(GetDlgItem(hDlg, IDD_ICON), SW_HIDE);

    GetDlgItemText(hDlg, IDD_COPYRIGHTSTRING, szTemp, ARRAYSIZE(szTemp));
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szTemp, TEXT(VER_LEGALCOPYRIGHT_YEARS));
    SetDlgItemText(hDlg, IDD_COPYRIGHTSTRING, szBuffer);

    /*
     * Display memory statistics
     */
    {
        MEMORYSTATUSEX MemoryStatus;
        DWORDLONG ullTotalPhys;

        MemoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
        GlobalMemoryStatusEx(&MemoryStatus);
        ullTotalPhys = MemoryStatus.ullTotalPhys;

        BytesToK(&ullTotalPhys);

        LoadString(HINST_THISDLL, IDS_LDK, szldK, ARRAYSIZE(szldK));
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szldK, AddCommas64(ullTotalPhys, szNumBuf1, ARRAYSIZE(szNumBuf1)));
        SetDlgItemText(hDlg, IDD_CONVENTIONAL, szBuffer);
    }

    // Lets get the version and user information from the registry
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_SETUP, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        cb = MAX_REG_VALUE;

        if (NULL != (lpszValue = (LPTSTR)LocalAlloc(LPTR, cb)))
        {
            /*
             * Determine version information
             */
            OSVERSIONINFO Win32VersionInformation;

            Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);
            if (!GetVersionEx(&Win32VersionInformation))
            {
                Win32VersionInformation.dwMajorVersion = 0;
                Win32VersionInformation.dwMinorVersion = 0;
                Win32VersionInformation.dwBuildNumber  = 0;
                Win32VersionInformation.szCSDVersion[0] = TEXT('\0');
            }

            LoadString(HINST_THISDLL, IDS_VERSIONMSG, szBuffer, ARRAYSIZE(szBuffer));

            szTitle[0] = TEXT('\0');
            if (Win32VersionInformation.szCSDVersion[0] != TEXT('\0'))
            {
                wnsprintf(szTitle, ARRAYSIZE(szTitle), TEXT(": %s"), Win32VersionInformation.szCSDVersion);
            }

            // Extra Whistler code to get the VBL version info
            {
                DWORD dwSize;
                DWORD dwType;

                // save off the current szTitle string
                StrCpyN(szTemp, szTitle, ARRAYSIZE(szTemp));

                dwSize = sizeof(szTitle);
                if ((SHGetValue(HKEY_LOCAL_MACHINE,
                                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                                TEXT("BuildLab"),
                                &dwType,
                                szTitle,
                                &dwSize) == ERROR_SUCCESS) && (dwType == REG_SZ) && (lstrlen(szTitle) > 4))
                {
                    // Now szTitle contains the buildnumber in the format: "2204.reinerf.010700"
                    // Since we are sprintf'ing the buildnumber again below, we remove it first
                    memmove((void*)szTitle, (void*)&szTitle[4], (lstrlen(&szTitle[4]) + 1) * sizeof(TCHAR));
                    
                    if (szTemp[0] != TEXT('\0'))
                    {
                        // add back on the Service Pack version string
                        lstrcatn(szTitle, TEXT(" "), ARRAYSIZE(szTitle));
                        lstrcatn(szTitle, szTemp, ARRAYSIZE(szTitle));
                    }
                }
            }

            szNumBuf1[0] = TEXT('\0');
            if (GetSystemMetrics(SM_DEBUG))
            {
                szNumBuf1[0] = TEXT(' ');
                LoadString(HINST_THISDLL, IDS_DEBUG, &szNumBuf1[1], ARRAYSIZE(szNumBuf1) - 1);
            }
            wnsprintf(szMessage,
                      ARRAYSIZE(szMessage),
                      szBuffer,
                      Win32VersionInformation.dwMajorVersion,
                      Win32VersionInformation.dwMinorVersion,
                      Win32VersionInformation.dwBuildNumber,
                      (LPTSTR)szTitle,
                      (LPTSTR)szNumBuf1);
            SetDlgItemText(hDlg, IDD_VERSION, szMessage);

            /*
             * Display the User name.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutRegisteredUser, &lpszValue, &cb);
            if (!err)
                SetDlgItemText(hDlg, IDD_USERNAME, lpszValue);

            /*
             * Display the Organization name.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutRegisteredOrganization, &lpszValue, &cb);
            if (!err)
                SetDlgItemText(hDlg, IDD_COMPANYNAME, lpszValue);

            /*
             * Display the OEM or Product ID.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutOEMID, &lpszValue, &cb);
            if (!err)
            {
                /*
                 * We have an OEM ID, so hide the product ID controls,
                 * and display the text.
                 */
                ShowWindow (GetDlgItem(hDlg, IDD_PRODUCTID), SW_HIDE);
                ShowWindow (GetDlgItem(hDlg, IDD_SERIALNUM), SW_HIDE);
                SetDlgItemText(hDlg, IDD_OEMID, lpszValue);
            }
            else if (err == ERROR_FILE_NOT_FOUND)
            {
                /*
                 * OEM ID didn't exist, so look for the Product ID
                 */
                ShowWindow (GetDlgItem(hDlg, IDD_OEMID), SW_HIDE);
                err = RegGetStringAndRealloc(hkey, c_szAboutProductID, &lpszValue, &cb);
                if (!err)
                {
                    SetDlgItemText(hDlg, IDD_SERIALNUM, lpszValue);
                }
            }

            LocalFree(lpszValue);
        }

        RegCloseKey(hkey);
    }
}

typedef struct 
{
    DWORD  dwOS;
    UINT   idb256;
    UINT   idb16;
    BOOL   fWinBrandDll;
} ABOUTINFO;

ABOUTINFO rgAbout[] =  
{{OS_PERSONAL,              IDB_ABOUTPERSONAL256,                   IDB_ABOUTPERSONAL16,                FALSE},
{OS_EMBEDDED,               IDB_ABOUTEMBEDDED256,                   IDB_ABOUTEMBEDDED16,                FALSE},
{OS_MEDIACENTER,            IDB_ABOUTMEDIACENTER256_SHELL32_DLL,    IDB_ABOUTMEDIACENTER16_SHELL32_DLL, FALSE},
{OS_TABLETPC,               IDB_ABOUTTABLETPC256_SHELL32_DLL,       IDB_ABOUTTABLETPC16_SHELL32_DLL,    FALSE},
{OS_BLADE,                  IDB_ABOUTBLADE256,                      IDB_ABOUTBLADE16,                   FALSE},
{OS_APPLIANCE,              IDB_ABOUTAPPLIANCE256_SHELL32_DLL,      IDB_ABOUTAPPLIANCE16_SHELL32_DLL,   TRUE},
{OS_SMALLBUSINESSSERVER,    IDB_ABOUTSBS256,                        IDB_ABOUTSBS16,                     FALSE},
{OS_SERVER,                 IDB_ABOUTSRV256,                        IDB_ABOUTSRV16,                     FALSE},
{OS_ADVSERVER,              IDB_ABOUTENT256,                        IDB_ABOUTENT16,                     FALSE},
{OS_DATACENTER,             IDB_ABOUTDCS256,                        IDB_ABOUTDCS16,                     FALSE},
{OS_PROFESSIONAL,           IDB_ABOUT256,                           IDB_ABOUT16,                        FALSE}}; // last entry is default if no match is found


    
BOOL_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR bReturn = TRUE;

    switch (wMsg)
    {
    case WM_INITDIALOG:
        _InitAboutDlg(hDlg, (LPABOUT_PARAMS)lParam);
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hDlg, &ps);

            // We draw the product banner and a blue strip.  In order to support high DPI monitors
            // and scaled fonts we must scale the image and the strip to the proportions of the dialog.
            //
            // +-----------------------------+
            // | Product Banner (413x72)     |
            // |                             |
            // +-----------------------------+
            // | Blue Strip (413x5)          |
            // +-----------------------------+

            HDC hdcMem = CreateCompatibleDC(hdc);
            int cxDlg;

            {
                RECT rc;
                GetClientRect(hDlg, &rc);
                cxDlg = rc.right;
            }

            if (hdcMem)
            {
                BOOL fDeep = (SHGetCurColorRes() > 8);
                HBITMAP hbmBand, hbmAbout;
                HMODULE hInst = NULL;
                int cxDest = MulDiv(413,cxDlg,413);
                int cyDest = MulDiv(72,cxDlg,413);
                UINT uID;
                BOOL fFound = FALSE;
                int i;

                for (i = 0; i < ARRAYSIZE(rgAbout); i++)
                {
                    if (IsOS(rgAbout[i].dwOS))
                    {
                        uID = fDeep ? rgAbout[i].idb256 : rgAbout[i].idb16;
                        fFound = TRUE;

                        // If this resource is in the special Windows branding
                        // DLL, attempt to load the DLL now. If it fails, it
                        // will be handled as if not found.

                        if (rgAbout[i].fWinBrandDll)
                        {
                            hInst = LoadLibraryEx(L"winbrand.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);

                            if (hInst == NULL)
                            {
                                fFound = FALSE;
                            }
                        }
                        break;
                    }
                }
                if (!fFound) // if not found, default to last entry
                {
                    uID = fDeep ? rgAbout[ARRAYSIZE(rgAbout) - 1].idb256 : rgAbout[ARRAYSIZE(rgAbout) - 1].idb16;
                }
                            
                // paint the bitmap for the windows product
                hbmAbout = NULL;
                if (hInst == NULL)
                {
                    hInst = LoadLibraryEx(L"moricons.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
                }
                if (hInst)
                {
                    hbmAbout = LoadImage(hInst,  
                                         MAKEINTRESOURCE(uID),
                                         IMAGE_BITMAP, 
                                         0, 0, 
                                         LR_LOADMAP3DCOLORS);
                    if ( hbmAbout )
                    {
                        HBITMAP hbmOld = SelectObject(hdcMem, hbmAbout);
                        if (hbmOld)
                        {
                            StretchBlt(hdc, 0, 0, cxDest, cyDest, hdcMem, 0,0,413,72, SRCCOPY);
                            SelectObject(hdcMem, hbmOld);
                        }
                        DeleteObject(hbmAbout);
                    }
                    FreeLibrary(hInst);
                }
                            
                // paint the blue band below it

                hbmBand = LoadImage(HINST_THISDLL,  
                                    MAKEINTRESOURCE(fDeep ? IDB_ABOUTBAND256:IDB_ABOUTBAND16),
                                    IMAGE_BITMAP, 
                                    0, 0, 
                                    LR_LOADMAP3DCOLORS);
                if ( hbmBand )
                {
                    HBITMAP hbmOld = SelectObject(hdcMem, hbmBand);
                    if (hbmOld)
                    {
                        StretchBlt(hdc, 0, cyDest, cxDest, MulDiv(5,cxDlg,413), hdcMem, 0,0,413,5, SRCCOPY);
                        SelectObject(hdcMem, hbmOld);
                    }
                    DeleteObject(hbmBand);
                }

                DeleteDC(hdcMem);
            }

            EndPaint(hDlg, &ps);
            break;
        }

    case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        break;

    case WM_NOTIFY:
        if ((IDD_EULA == (int)wParam) &&
            (NM_CLICK == ((LPNMHDR)lParam)->code))
        {
            SHELLEXECUTEINFO sei = { 0 };
            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = SEE_MASK_DOENVSUBST;
            sei.hwnd = hDlg;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = TEXT("%windir%\\system32\\eula.txt");

            ShellExecuteEx(&sei);
        }
        else
        {
            // WM_NOTIFY not handled.
            bReturn = FALSE;
        }
        break;

    default:
        // Not handled.
        bReturn = FALSE;
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\actdesk.h ===
/*
 * actdesk.h - active desktop prop sheet extension
 */

#ifndef _ACTDESK_H_
#define _ACTDESK_H_

#ifdef __cplusplus


#define REGSTR_ACTIVEDESKTOP   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ActiveDesktop")
#define REGVAL_NOTICKERDISPLAY TEXT("NoTickerDisplay")
#define REGVAL_TICKERINTERVAL  TEXT("TickerInterval")
#define REGVAL_TICKERSPEED     TEXT("TickerSpeed")
#define REGVAL_NONEWSDISPLAY   TEXT("NoNewsDisplay")
#define REGVAL_NEWSINTERVAL    TEXT("NewsInterval")
#define REGVAL_NEWSUPDATE      TEXT("NewsUpdate")
#define REGVAL_NEWSSPEED       TEXT("NewsSpeed")

#define MAX_NEWS_INTERVAL     120
#define MAX_TICKER_INTERVAL   120
#define MAX_NEWS_UPDATE       120

typedef struct _ActiveDesktopInfo
{
    BOOL fTicker;
    int  iTickerInterval;       // 30sec, e.g.
    int  iTickerSpeed;          // Stop -- Fast

    BOOL fNews;
    int  iNewsInterval;         // 30sec, e.g.
    int  iNewsUpdate;           // 30min, e.
    int  iNewsSpeed;            // Stop -- Fast
} ACTIVEDESKTOPINFO, *LPACTIVEDESKTOPINFO;

BOOL_PTR CALLBACK CActDesktopExt_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


class CActDesktopExt : IShellPropSheetExt
{    
public:

    CActDesktopExt();
   ~CActDesktopExt();
   
    // IUnknon methods...
    STDMETHODIMP            QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IShellPropSheetExt methods...
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

protected:
    HRESULT _CreateActiveDesktopPage(HPROPSHEETPAGE* phpsp, LPVOID pvReserved);    
    UINT _cRef;    
};


#endif  // __cplusplus


//
// Prototypes for all modules
//
#ifdef __cplusplus
extern "C" {
#endif
    
STDAPI CActDesktopExt_CreateInstance(LPUNKNOWN punkOuter, REFIID riid,  OUT void **ppvOut);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\util\menu.cpp ===
//
//  Menu- and menuband- related utility functions
//

#include "local.h"
#include "dochost.h"

// this goes away when the split is done **and** dochost goes away


/*----------------------------------------------------------
Purpose: Replace the contents of hmenuDst with hmenuSrc.  Note any
         submenus in hmenuDst will be deleted.  

         Call Menu_RemoveAllSubMenus if you don't want this to 
         happen.
*/
void Menu_Replace(HMENU hmenuDst, HMENU hmenuSrc)
{
    int cItems = GetMenuItemCount(hmenuDst);
    int i;

    for (i=0; i<cItems; i++)
        DeleteMenu(hmenuDst, 0, MF_BYPOSITION);

    cItems = GetMenuItemCount(hmenuSrc);
    for (i=0; i<cItems; i++)
    {
        MENUITEMINFO mii;
        TCHAR szText[MAX_PATH];
        mii.cbSize = SIZEOF(MENUITEMINFO);
        mii.dwTypeData = szText;
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_DATA | MIIM_STATE;
        mii.cch = ARRAYSIZE(szText);
        mii.fType = MFT_SEPARATOR;
        mii.hSubMenu = NULL;
        mii.dwItemData = 0;
        if (GetMenuItemInfo(hmenuSrc, i, TRUE, &mii))
        {
            HMENU hMenuOldSub = NULL;
            if (mii.hSubMenu != NULL)
            {
                hMenuOldSub = mii.hSubMenu;
                mii.hSubMenu = CreateMenu();
                Menu_Replace(mii.hSubMenu, hMenuOldSub);
            }
            InsertMenuItem(hmenuDst, i, TRUE, &mii);
        }
    }
}


#ifndef POSTPOSTSPLIT
//----------------------------------------------------------------------
//
// CMenuList
//
//----------------------------------------------------------------------


typedef struct
{
    HMENU   hmenu;
    BITBOOL bObject:1;              // TRUE: menu belongs to object
} MLITEM;       // CMenuList item


CMenuList::CMenuList(void)
{
    ASSERT(NULL == _hdsa);
}


CMenuList::~CMenuList(void)
{
    if (_hdsa)
    {
        DSA_Destroy(_hdsa);
        _hdsa = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Set the menu list (comparable to HOLEMENU) so we can
         dispatch commands to the frame or the object correctly.
         We do this since menu bands bypass OLE's FrameFilterWndProc.

         We build the menu list by comparing the given hmenuShared
         with hmenuFrame.  Anything in hmenuShared that is not
         in hmenuFrame belongs to the object.

*/
void CMenuList::Set(HMENU hmenuShared, HMENU hmenuFrame)
{
    ASSERT(NULL == hmenuShared || IS_VALID_HANDLE(hmenuShared, MENU));
    ASSERT(NULL == hmenuFrame || IS_VALID_HANDLE(hmenuFrame, MENU));

    if (_hdsa)
    {
        ASSERT(IS_VALID_HANDLE(_hdsa, DSA));

        DSA_DeleteAllItems(_hdsa);
    }
    else
        _hdsa = DSA_Create(sizeof(MLITEM), 10);

    if (_hdsa && hmenuShared && hmenuFrame)
    {
        int i;
        int iFrame = 0;
        int cmenu = GetMenuItemCount(hmenuShared);
        int cmenuFrame = GetMenuItemCount(hmenuFrame);
        BOOL bMatched;
        int iSaveFrame;
        int iHaveFrame = -1;

        TCHAR sz[64];
        TCHAR szFrame[64];
        MENUITEMINFO miiFrame;
        MENUITEMINFO mii;
        MLITEM mlitem;

        miiFrame.cbSize = sizeof(miiFrame);
        mii.cbSize = sizeof(mii);

        for (i = 0; i < cmenu; i++)
        {

            mii.cch = SIZECHARS(sz);
            mii.fMask  = MIIM_SUBMENU | MIIM_TYPE;
            mii.dwTypeData = sz;
            EVAL(GetMenuItemInfo(hmenuShared, i, TRUE, &mii));

            ASSERT(IS_VALID_HANDLE(mii.hSubMenu, MENU));
            
            mlitem.hmenu = mii.hSubMenu;

            iSaveFrame = iFrame;
            bMatched = FALSE;

            //  DocObject might have dropped some of our menus, like edit and view
            //  Need to be able to skip over dropped frame menus
            while (1)
            {
                if (iHaveFrame != iFrame)
                {
                    iHaveFrame = iFrame;
                    if (iFrame < cmenuFrame)
                    {
                        miiFrame.cch = SIZECHARS(szFrame);
                        miiFrame.fMask  = MIIM_SUBMENU | MIIM_TYPE;
                        miiFrame.dwTypeData = szFrame;
                        EVAL(GetMenuItemInfo(hmenuFrame, iFrame, TRUE, &miiFrame));
                    }
                    else
                    {
                        // Make it so it won't compare
                        miiFrame.hSubMenu = NULL;
                        *szFrame = 0;
                    }

                }
                ASSERT(iFrame >= cmenuFrame || IS_VALID_HANDLE(miiFrame.hSubMenu, MENU));
                
                // The browser may have a menu that was not merged into
                // the shared menu because the object put one in with 
                // the same name.  Have we hit this case? Check by comparing
                // sz and szFrame

                if (mii.hSubMenu == miiFrame.hSubMenu || 0 == StrCmp(sz, szFrame))
                {
                    bMatched = TRUE;
                    break;
                }
                else
                {
                    if (iFrame >= cmenuFrame) 
                    {
                        break;
                    }
                    iFrame++;
                }
            }

            // Is this one of our menus?
            mlitem.bObject = (mii.hSubMenu == miiFrame.hSubMenu) ? FALSE:TRUE;
            if (bMatched)
            {
                iFrame++;
            }
            else
            {
                iFrame = iSaveFrame;
            }
            DSA_SetItem(_hdsa, i, &mlitem);
        }
    }
}   


/*----------------------------------------------------------
Purpose: Adds the given hmenu to the list.

*/
void CMenuList::AddMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        MLITEM mlitem;

        mlitem.hmenu = hmenu;
        mlitem.bObject = TRUE;
        
        DSA_AppendItem(_hdsa, &mlitem);
    }
}     


/*----------------------------------------------------------
Purpose: Removes the given hmenu from the list.

*/
void CMenuList::RemoveMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i = DSA_GetItemCount(_hdsa) - 1;

        for (; i >= 0; i--)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                DSA_DeleteItem(_hdsa, i);
                break;
            }
        }
    }
}     


/*----------------------------------------------------------
Purpose: Returns TRUE if the given hmenu belongs to the object.

*/
BOOL CMenuList::IsObjectMenu(HMENU hmenu)
{
    BOOL bRet = FALSE;

    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i;

        for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                bRet = pmlitem->bObject;
                break;
            }
        }
    }
    return bRet;
}     


#ifdef DEBUG

void CMenuList::Dump(LPCTSTR pszMsg)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "CMenuList: Dumping menus for %#08x %s", (LPVOID)this, pszMsg);
        
        if (_hdsa)
        {
            int i;

            for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
            {
                MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
                ASSERT(pmlitem);

                TraceMsg(TF_ALWAYS, "   [%d] = %x", i, pmlitem->hmenu);
            }
        }
    }
}

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "apdlg.h"
#include "hwcmmn.h"

#include "mtpt.h"

static const DWORD s_rgdwHelpIDsArray[] =
{
    IDC_AP_TOPTEXT,               IDH_SELECT_CONTENT_TYPE,
    IDC_AP_LIST,                  IDH_SELECT_CONTENT_TYPE,
    IDC_AP_DEFAULTHANDLER,        IDH_SELECT_ACTION,
    IDC_AP_LIST_ACTIONS,          IDH_SELECT_ACTION,
    IDC_AP_PROMPTEACHTIME,        IDH_PROMPT_ME_EACH_TIME,
    IDC_AP_NOACTION,              IDH_TAKE_NO_ACTION,
    0, 0
};

static const DWORD g_rgdwContentTypes[] =
{
    CT_AUTOPLAYMUSIC   ,
    CT_AUTOPLAYPIX     ,
    CT_AUTOPLAYMOVIE   ,
    CT_AUTOPLAYMIXEDCONTENT ,
    CT_CDAUDIO         ,
    CT_DVDMOVIE        ,
    CT_BLANKCDR        , // could also have been: CT_BLANKCDRW
};

#define COL_ACTION      0
#define COL_PROVIDER    1

const UINT c_auTileColumns[] = {COL_ACTION, COL_PROVIDER};
const UINT c_auTileSubItems[] = {COL_PROVIDER};

HRESULT CAutoPlayDlg::_InitListViewActions()
{
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

    HRESULT hr = _uilListViewActions.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        hr = _uilListViewActions.InitTileInfo(c_auTileSubItems, ARRAYSIZE(c_auTileSubItems));

        if (SUCCEEDED(hr))
        {
            RECT rc = {0};
            LVTILEVIEWINFO lvtvi = {0};
            HIMAGELIST himagelist;

            ListView_SetView(hwndList, LV_VIEW_TILE);

            for (int i = 0; i < ARRAYSIZE(c_auTileColumns); ++i)
            {
                LVCOLUMN lvcolumn = {0};

                lvcolumn.mask = LVCF_SUBITEM;
                lvcolumn.iSubItem = c_auTileColumns[i];
                ListView_InsertColumn(hwndList, i, &lvcolumn);
            }

            GetClientRect(hwndList, &rc);

            lvtvi.cbSize = sizeof(lvtvi);
            lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
            lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
            // Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
            lvtvi.sizeTile.cx = ((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL));
            lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
            ListView_SetTileViewInfo(hwndList, &lvtvi);

            Shell_GetImageLists(&himagelist, NULL);

            if (himagelist)
            {
                ListView_SetImageList(hwndList, himagelist, LVSIL_NORMAL);
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_FillListViewActions(CContentTypeData* pdata)
{
    HRESULT hr = _uilListViewActions.ResetContent();
    if (SUCCEEDED(hr))
    {
        int c = pdata->GetHandlerCount();
        if (c)
        {
            for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
            {
                CHandlerData* phandlerdata = pdata->GetHandlerData(i);

                if (phandlerdata)
                {
                    CHandlerLVItem* puidata = new CHandlerLVItem();

                    if (puidata)
                    {
                        hr = puidata->InitData(phandlerdata);

                        if (SUCCEEDED(hr))
                        {
                            hr = _uilListViewActions.AddItem(puidata);

                            if (FAILED(hr))
                            {
                                delete puidata;
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    phandlerdata->Release();
                }
            }

            _fAtLeastOneAction = TRUE;
        }
        else
        {
            // disable the listview and its radio button
            _fAtLeastOneAction = FALSE;
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_UpdateRestoreButton(BOOL fPromptEachTime)
{
    BOOL fEnable;

    if (fPromptEachTime)
    {
        fEnable = FALSE;
    }
    else
    {
        fEnable = TRUE;
    }

    EnableWindow(GetDlgItem(_hwnd, IDC_AP_RESTOREDEFAULTS), fEnable);

    return fEnable;
}

HRESULT CAutoPlayDlg::_UpdateLowerPane()
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    _fIgnoreListViewItemStateChanges = TRUE;

    if (SUCCEEDED(hr))
    {
        BOOL fPromptEachTime = !lstrcmpi(pdata->_pszHandlerDefault, TEXT("MSPromptEachTime"));

        if (!fPromptEachTime)
        {
            if (!(pdata->_dwHandlerDefaultFlags & HANDLERDEFAULT_USERCHOSENDEFAULT))
            {
                // There *NO* User Chosen Default
                fPromptEachTime = TRUE;
            }
            else
            {
                // There is a User Chosen Default
                if (pdata->_dwHandlerDefaultFlags &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // But there's also more recent apps
                    fPromptEachTime = TRUE;
                }
            }
        }

        hr = _FillListViewActions(pdata);

        if (SUCCEEDED(hr))
        {
            hr = _SelectListViewActionsItem(pdata->_pszHandlerDefault);
        }

        if (SUCCEEDED(hr))
        {
            hr = _SelectRadioButton(fPromptEachTime);
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdateRestoreButton(fPromptEachTime);
        }

        pdata->Release();
    }

    _fIgnoreListViewItemStateChanges = FALSE;

    return hr;
}

HRESULT CAutoPlayDlg::_UpdateApplyButton()
{
    if (_dlmanager.IsDirty())
    {
        PropSheet_Changed(GetParent(_hwnd), _hwnd);
    }
    else
    {
        PropSheet_UnChanged(GetParent(_hwnd), _hwnd);
    }

    return S_OK;
}

HRESULT _SetHandlerDefault(LPWSTR* ppszHandlerDefault, LPCWSTR pszHandler)
{
    LPWSTR pszHandlerNew;
    HRESULT hr = SHStrDup(pszHandler, &pszHandlerNew);

    if (SUCCEEDED(hr))
    {
        if (*ppszHandlerDefault)
        {
            CoTaskMemFree(*ppszHandlerDefault);
        }

        *ppszHandlerDefault = pszHandlerNew;
    }

    return hr;
}

HRESULT CAutoPlayDlg::_SelectRadioButton(BOOL fPromptEachTime)
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        int iCtrl;
        BOOL fEnableListView = FALSE;

        if (fPromptEachTime)
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

            iCtrl = IDC_AP_PROMPTEACHTIME;
        }
        else
        {
            fEnableListView = TRUE;

            CHandlerData* phandlerdata;
            hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

                phandlerdata->Release();
            }

            iCtrl = IDC_AP_DEFAULTHANDLER;
        }

        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_DEFAULTHANDLER), (IDC_AP_DEFAULTHANDLER == iCtrl));
        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_PROMPTEACHTIME), (IDC_AP_PROMPTEACHTIME == iCtrl));

        EnableWindow(GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS), fEnableListView);

        pdata->Release();

        hr = _UpdateApplyButton();
    }

    return hr;
}

HRESULT CAutoPlayDlg::_SelectListViewActionsItem(LPCWSTR pszHandlerDefault)
{
    HRESULT hr = S_FALSE;
    LVITEM lvitem = {0};
    int iItemToSelect = 0;
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

    if (pszHandlerDefault)
    {
        int c = ListView_GetItemCount(hwndList);

        if (c)
        {
            int i;

            for (i = 0; i < c; ++i)
            {
                lvitem.mask = LVIF_PARAM;
                lvitem.iItem = i;
        
                if (ListView_GetItem(hwndList, &lvitem))
                {
                    CHandlerLVItem* phandleruidata = (CHandlerLVItem*)lvitem.lParam;

                    if (phandleruidata)
                    {
                        CHandlerData* phandlerdata = phandleruidata->GetData();

                        if (phandlerdata)
                        {
                            if (!lstrcmp(phandlerdata->_pszHandler,
                                pszHandlerDefault))
                            {
                                break;                
                            }

                            phandlerdata->Release();
                        }
                    }
                }
            }

            if (i == c)
            {
                i = 0;
            }
            else
            {
                hr = S_OK;
            }

            iItemToSelect = i;
        }
    }
    else
    {
        // Select first one
        hr = S_OK;
    }

    lvitem.mask = LVIF_STATE;
    lvitem.iItem = iItemToSelect;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(hwndList, &lvitem);
    ListView_EnsureVisible(hwndList, lvitem.iItem, FALSE);

    return hr;
}

LRESULT CAutoPlayDlg::_OnApply()
{
    if (_dlmanager.IsDirty())
    {
        // Should we get the return value, and if so, why?
        _dlmanager.Commit();
    }

    return PSNRET_NOERROR;
}

// Listview Actions
HRESULT CAutoPlayDlg::_OnListViewActionsSelChange()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        CContentTypeData* pdata;
        hr = _uilListView.GetSelectedItemData(&pdata);

        if (SUCCEEDED(hr))
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

            pdata->Release();
        }

        phandlerdata->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = _UpdateApplyButton();
    }

    return hr;
}

// Radio buttons
HRESULT CAutoPlayDlg::_OnRestoreDefault()
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

        _SelectRadioButton(TRUE);

        hr = _UpdateApplyButton();

        if (SUCCEEDED(hr))
        {
            _UpdateRestoreButton(TRUE);
        }

        pdata->Release();

        SetFocus(GetNextDlgTabItem(_hwnd, GetDlgItem(_hwnd, IDC_AP_RESTOREDEFAULTS), FALSE /*next ctrl*/));
    }
    
    return hr;
}

HRESULT CAutoPlayDlg::_OnRadio(int iButton)
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

        if (IDC_AP_DEFAULTHANDLER == iButton)
        {
            CHandlerData* phandlerdata;

            EnableWindow(hwndList, TRUE);

            hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

                phandlerdata->Release();
            }
        }
        else
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

            EnableWindow(hwndList, FALSE);
        }

        hr = _UpdateApplyButton();

        if (SUCCEEDED(hr))
        {
            _UpdateRestoreButton(!lstrcmpi(pdata->_pszHandlerDefault, TEXT("MSPromptEachTime")));
        }

        pdata->Release();
    }
    
    return hr;
}

LRESULT CAutoPlayDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = _InitDataObjects();

    _fIgnoreListViewItemStateChanges = TRUE;

    if (SUCCEEDED(hr))
    {
        hr = _InitListView();

        if (SUCCEEDED(hr))
        {
            hr = _FillListView();

            if (SUCCEEDED(hr))
            {
                hr = _InitListViewActions();

                if (SUCCEEDED(hr))
                {
                    hr = _uilListView.SelectFirstItem();

                    if (SUCCEEDED(hr))
                    {
                        hr = _UpdateLowerPane();
                    }
                }
            }
        }
    }

    _fIgnoreListViewItemStateChanges = FALSE;

    return TRUE;
}

LRESULT CAutoPlayDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;
    
    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;
    
    switch (uCode) 
    {
    case PSN_APPLY:
        lRes = _OnApply();
        
        CBaseDlg::OnNotify(wParam, lParam);
        break;
        
    default:
        switch (idFrom)
        {
        case IDC_AP_LIST_ACTIONS:
            
            if (!_fIgnoreListViewItemStateChanges)
            {
                NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;
                
                if (LVN_ITEMCHANGED == uCode)
                {
                    // Is a new item being selected?
                    if ((pNMLV->uChanged & LVIF_STATE) &&
                        pNMLV->uNewState & LVIS_SELECTED)
                    {
                        _OnListViewActionsSelChange();
                    }
                }
            }
            
            lRes = CBaseDlg::OnNotify(wParam, lParam);
            break;
            
        default:
            lRes = CBaseDlg::OnNotify(wParam, lParam);
            break;
        }
        break;
    }
    
    return lRes;    
}

LRESULT CAutoPlayDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int iCtl = LOWORD(wParam);
    int iNot = HIWORD(wParam);
    
    switch (iCtl)
    {
    case IDC_AP_DEFAULTHANDLER:
    case IDC_AP_PROMPTEACHTIME:
        if (BN_CLICKED == iNot)
        {
            _OnRadio(iCtl);
        }
        break;
        
    case IDC_AP_LIST:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            _UpdateLowerPane();
        }
        
        break;
        
    case IDC_AP_RESTOREDEFAULTS:
        if (BN_CLICKED == iNot)
        {
            _OnRestoreDefault();
        }
        break;
    }
    
    return CBaseDlg::OnCommand(wParam, lParam);
}

LRESULT CAutoPlayDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _uilListView.ResetContent();
    _uilListViewActions.ResetContent();

    return CBaseDlg::OnDestroy(wParam, lParam);
}

LRESULT CAutoPlayDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
    HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
    BOOL ret = WinHelp(hwndItem, TEXT("filefold.hlp"), HELP_WM_HELP, (ULONG_PTR)(LPTSTR)s_rgdwHelpIDsArray);
    if (!ret)
    {
        return CBaseDlg::OnHelp(wParam, lParam);
    }

    return ret;
}

LRESULT CAutoPlayDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL lRes=FALSE;
    
    if (HTCLIENT == (int)SendMessage(_hwnd, WM_NCHITTEST, 0, lParam))
    {
        POINT pt;
        HWND hwndItem = NULL;
        int iCtrlID = 0;
        
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwnd, &pt);
        
        hwndItem = ChildWindowFromPoint(_hwnd, pt);
        iCtrlID = GetDlgCtrlID(hwndItem);

        lRes = WinHelp((HWND)wParam, TEXT("filefold.hlp"), HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)s_rgdwHelpIDsArray);
        if (!lRes)
        {
          return CBaseDlg::OnContextMenu(wParam, lParam);
        }
    }
    else
    {
        lRes = FALSE;
    }

    return lRes;
}

CAutoPlayDlg::CAutoPlayDlg() : CBaseDlg((ULONG_PTR)s_rgdwHelpIDsArray)
{
    ASSERT(ARRAYSIZE(_rgpContentTypeData) >= ARRAYSIZE(g_rgdwContentTypes));
}
      
HRESULT CAutoPlayDlg::Init(LPWSTR pszDrive, int iDriveType)
{
    _iDriveType = iDriveType;

    return StringCchCopy(_szDrive, ARRAYSIZE(_szDrive), pszDrive);
}

HRESULT CAutoPlayDlg::_InitDataObjects()
{
    HRESULT hr = S_FALSE;
    BOOL fIsCDDrive = FALSE;
    DWORD dwDriveCapabilities = HWDDC_CDROM;
    DWORD dwMediaCapabilities = HWDMC_CDROM;

    CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDrive);

    if (pmtpt)
    {
        fIsCDDrive = pmtpt->IsCDROM();

        if (fIsCDDrive)
        {
            hr = pmtpt->GetCDInfo(&dwDriveCapabilities, &dwMediaCapabilities);
        }

        pmtpt->Release();
    }

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < ARRAYSIZE(g_rgdwContentTypes));
        ++dw)
    {   
        BOOL fAddOption = TRUE;

        if (fIsCDDrive)
        {
            if ((g_rgdwContentTypes[dw] & CT_DVDMOVIE) &&
                !(dwDriveCapabilities & (HWDDC_DVDROM | HWDDC_DVDRECORDABLE | HWDDC_DVDREWRITABLE)))
            {
                fAddOption = FALSE;
            }
            else if ((g_rgdwContentTypes[dw] & CT_BLANKCDR) &&
                !(dwDriveCapabilities & (HWDDC_CDRECORDABLE | HWDDC_CDREWRITABLE)))
            {
                fAddOption = FALSE;
            }
        }
        else
        {
            if (g_rgdwContentTypes[dw] &
                (CT_CDAUDIO | CT_DVDMOVIE | CT_BLANKCDR))
            {
                fAddOption = FALSE;
            }
        }

        if (fAddOption)
        {
            _rgpContentTypeData[dw] = new CContentTypeData();

            if (_rgpContentTypeData[dw])
            {
                hr = (_rgpContentTypeData[dw])->Init(_szDrive, g_rgdwContentTypes[dw]);
                if (SUCCEEDED(hr))
                {
                    hr = _dlmanager.AddDataObject(_rgpContentTypeData[dw]);
                }
                else
                {
                    // Let's just skip this one, do not go out of the loop and
                    // abort the whole initialization.
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_InitListView()
{    
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST);
    HRESULT hr = _uilListView.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        Shell_GetImageLists(NULL, &_himagelist);

        if (_himagelist)
        {
            SendMessage(hwndList, CBEM_SETIMAGELIST, 0, (LPARAM)_himagelist);

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_FillListView()
{
    HRESULT hr = S_FALSE;

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < ARRAYSIZE(_rgpContentTypeData));
        ++dw)
    {
        if (_rgpContentTypeData[dw])
        {
            CContentTypeCBItem* pctlvitem = new CContentTypeCBItem();

            if (pctlvitem)
            {
                hr = pctlvitem->InitData(_rgpContentTypeData[dw]);

                if (SUCCEEDED(hr))
                {
                    hr = _uilListView.AddItem(pctlvitem);
                }

                if (FAILED(hr))
                {
                    delete pctlvitem;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

CAutoPlayDlg::~CAutoPlayDlg()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpContentTypeData); ++dw)
    {
        if (_rgpContentTypeData[dw])
        {
            (_rgpContentTypeData[dw])->Release();
        }
    }
    
#ifdef AUTOPLAYDLG_LEAKPARANOIA
    // If this is on, you cannot open two Autoplay dialogs (e.g.: Autoplay
    // proppage and Autoplay prompt) at the same time and then close one.
    // It will assert for sure when you close the first one.
    ASSERT(!_DbgLocalAllocCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apdlglog.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "hwcmmn.h"
#include "apdlglog.h"
#include "mtptl.h"

BOOL _AreHandlersDifferent(LPCWSTR /*pszOriginal*/, LPCWSTR /*pszNew*/)
{
    return TRUE;
}

CHandlerDataArray::~CHandlerDataArray()
{
    if (IsDPASet())
    {
        DestroyCallback(_ReleaseHandler, NULL);
    }
}

BOOL CHandlerDataArray::_IsDemotedHandler(PCWSTR pszHandler)
{
    return ((0 == StrCmpIW(pszHandler, L"MSTakeNoAction"))
        ||  (0 == StrCmpIW(pszHandler, L"MSOpenFolder")));
}
    
HRESULT CHandlerDataArray::AddHandler(CHandlerData *pdata)
{
    //  always insert ahead of TakeNoAction and OpenFolder
    int iInsert;
    if (!_IsDemotedHandler(pdata->_pszHandler))
    {
        int c = GetPtrCount();
        for (iInsert = 0; iInsert < c; iInsert++)
        {
            if (_IsDemotedHandler(GetPtr(iInsert)->_pszHandler))
            {
                //  insert here
                break;
            }
        }
        iInsert = InsertPtr(iInsert, pdata);
    }
    else
    {
        iInsert = AppendPtr(pdata);
    }

    return DPA_ERR != iInsert ? S_OK : E_OUTOFMEMORY;
}

BOOL CHandlerDataArray::IsDuplicateCommand(PCWSTR pszCommand)
{
    WCHAR sz[MAX_PATH * 2];
    BOOL fRet = FALSE;
    int c = GetPtrCount();
    for (int i = 0; i < c; i++)
    {
        CHandlerData *pdata = GetPtr(i);
        if (SUCCEEDED(pdata->_GetCommand(sz, ARRAYSIZE(sz))))
        {
            fRet = (0 == StrCmpIW(pszCommand, sz));
            if (fRet)
                break;
        }
    }
    return fRet;
}

// We are erring on the side of safety here by giving FALSE positives
// sometimes.  This could be optimized to consider if we have diff handler
// just because one is missing.
void CContentTypeData::UpdateDirty()
{
    BOOL fDirty = _AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags);

    _SetDirty(fDirty);
}

#define SOFTPREFIX TEXT("[soft]")

HRESULT CContentTypeData::CommitChangesToStorage()
{
    HRESULT hr = S_OK;

    if (_AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags))
    {
        // Yep, changed
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandler(_szDrive, TEXT("ContentArrival"), _szContentTypeHandler, &piah);
        if (SUCCEEDED(hr))
        {
            if (!_fSoftCommit)
            {
                hr = piah->SetDefaultHandler(_pszHandlerDefault);
            }
            else
            {
                WCHAR szHandler[MAX_HANDLER + ARRAYSIZE(SOFTPREFIX)];

                lstrcpyn(szHandler, SOFTPREFIX, ARRAYSIZE(szHandler));
                StrCatBuff(szHandler, _pszHandlerDefault, ARRAYSIZE(szHandler));

                hr = piah->SetDefaultHandler(szHandler);
            }

            piah->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&_pszHandlerDefaultOriginal, _pszHandlerDefault);
    }

    return hr;
}

CContentTypeData::~CContentTypeData()
{
    if (_pszHandlerDefaultOriginal)
    {
        CoTaskMemFree(_pszHandlerDefaultOriginal);
    }

    if (_pszHandlerDefault)
    {
        CoTaskMemFree(_pszHandlerDefault);
    }
}

HRESULT _MakeActionString(LPCWSTR pszAction, LPWSTR* ppszAction2)
{
    *ppszAction2 = NULL;

    WCHAR szAction[250];
    HRESULT hr = SHLoadIndirectString(pszAction, szAction, ARRAYSIZE(szAction), NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(szAction, ppszAction2);
    }

    return hr;
}

HRESULT _MakeProviderString(LPCWSTR pszProvider, LPWSTR* ppszProvider2)
{
    WCHAR szProviderNonMUI[250];
    HRESULT hr = SHLoadIndirectString(pszProvider, szProviderNonMUI, ARRAYSIZE(szProviderNonMUI), NULL);

    if (SUCCEEDED(hr))
    {
        WCHAR szUsing[50];

        if (LoadString(g_hinst, IDS_AP_USING, szUsing, ARRAYSIZE(szUsing)))
        {
            WCHAR szProvider2[250];

            hr = StringCchPrintf(szProvider2, ARRAYSIZE(szProvider2), szUsing, szProviderNonMUI);
            
            if (SUCCEEDED(hr))
            {
                hr = SHStrDup(szProvider2, ppszProvider2);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

inline void _CoTaskMemFree(void* pv)
{
    if (pv)
    {
        CoTaskMemFree(pv);
    }
}

HRESULT _CreateHandlerData( PCWSTR pszAction, 
                            PCWSTR pszProvider, 
                            PWSTR *ppszHandler, //  IN/OUT
                            PWSTR *ppszIcon, //  IN/OUT
                            CHandlerData **ppdata)
{
    *ppdata = 0;
    LPWSTR pszAction2 = NULL;
    HRESULT hr = _MakeActionString(pszAction, &pszAction2);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszProvider2 = NULL;
        // Special case this guy, we don't want to say:
        // "Take no action, using Microsoft Windows"
        if (lstrcmp(*ppszHandler, TEXT("MSTakeNoAction")))
        {
            hr = _MakeProviderString(pszProvider, &pszProvider2);
        }
        //  else this is NULL, and ignored

        if (SUCCEEDED(hr))
        {
            *ppdata = new CHandlerData();
            if (*ppdata)
            {
                //  give away ownership of these allocations
                (*ppdata)->Init(*ppszHandler, pszAction2,
                    *ppszIcon, pszProvider2);

                *ppszHandler = NULL;
                *ppszIcon = NULL;
                pszAction2 = NULL;
                pszProvider2 = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                CoTaskMemFree(pszProvider2);
            }
            
        }
        CoTaskMemFree(pszAction2);
    }

    return hr;
}

HRESULT CContentBase::_EnumHandlerHelper(IAutoplayHandler* piah)
{
    IEnumAutoplayHandler* penum;
    if (S_OK == piah->EnumHandlers(&penum))
    {
        LPWSTR pszHandler;
        LPWSTR pszAction;
        LPWSTR pszProvider;
        LPWSTR pszIconLocation;
        while (S_OK == penum->Next(&pszHandler, &pszAction, &pszProvider,
            &pszIconLocation))
        {
            // Do not free the strings from EnumHandlers
            // CHandlerData will free them in its destructor
            CHandlerData *pdata;
            HRESULT hr = _CreateHandlerData(pszAction, pszProvider, &pszHandler, &pszIconLocation, &pdata);
            if (SUCCEEDED(hr))
            {
                hr = _dpaHandlerData.AddHandler(pdata);
                if (FAILED(hr))
                {
                    pdata->Release();
                }
            }
            else
            {
                CoTaskMemFree(pszHandler);
                CoTaskMemFree(pszIconLocation);
            }
            CoTaskMemFree(pszProvider);
            CoTaskMemFree(pszAction);
        }

        penum->Release();
    }

    return S_OK;
}

HRESULT _CreateLegacyHandler(IAssociationElement *pae, PCWSTR pszAction, CHandlerData **ppdata)
{
    *ppdata = 0;
    PWSTR pszIcon;
    HRESULT hr = pae->QueryString(AQVS_APPLICATION_PATH, NULL, &pszIcon);
    if(SUCCEEDED(hr))
    {
        PWSTR pszFriendly;
        hr = pae->QueryString(AQVS_APPLICATION_FRIENDLYNAME, NULL, &pszFriendly);
        if(SUCCEEDED(hr))
        {
            PWSTR pszHandler;
            hr = SHStrDup(TEXT("AutoplayLegacyHandler"), &pszHandler);
            if (SUCCEEDED(hr))
            {
                hr = _CreateHandlerData(pszAction, pszFriendly, &pszHandler, &pszIcon, ppdata);
                CoTaskMemFree(pszHandler);
            }
            CoTaskMemFree(pszFriendly);
        }
        CoTaskMemFree(pszIcon);
    }

    return hr;
}

CHandlerData* CContentBase::GetHandlerData(int i)
{
    CHandlerData* phandlerdata = _dpaHandlerData.GetPtr(i);

    if (phandlerdata)
    {
        phandlerdata->AddRef();
    }

    return phandlerdata;
}

HRESULT CContentBase::_AddLegacyHandler(DWORD dwContentType)
{
    HRESULT hr = S_FALSE;

    if (dwContentType & (CT_CDAUDIO | CT_DVDMOVIE))
    {
        LPCWSTR pszProgID;
        LPCWSTR pszAction;

        if (dwContentType & CT_CDAUDIO)
        {
            pszProgID = TEXT("AudioCD");
            pszAction = TEXT("@%SystemRoot%\\system32\\shell32.dll,-17171");
        }
        else
        {
            ASSERT(dwContentType & CT_DVDMOVIE);
            pszProgID = TEXT("DVD");
            pszAction = TEXT("@%SystemRoot%\\system32\\shell32.dll,-17172");
        }

        IAssociationElement * pae;
        hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, pszProgID, &pae);
        if (SUCCEEDED(hr))
        {
            PWSTR pszCommand;
            hr = pae->QueryString(AQVS_COMMAND, NULL, &pszCommand);
            if (SUCCEEDED(hr))
            {
                //  legacy guys have a command or we dont add them
                //  we expect new guys to be responsible and add themselves 
                //  to the autoplay handlers key
                if (!_dpaHandlerData.IsDuplicateCommand(pszCommand))
                {
                    CHandlerData* pdata;
                    hr = _CreateLegacyHandler(pae, pszAction, &pdata);
                    if (SUCCEEDED(hr))
                    {
                        hr = _dpaHandlerData.AddHandler(pdata);
                        if (FAILED(hr))
                        {
                            pdata->Release();
                        }
                    }
                }
                
                CoTaskMemFree(pszCommand);
            }
            pae->Release();
        }

    }

    return hr;
}

HRESULT CContentTypeData::Init(LPCWSTR pszDrive, DWORD dwContentType)
{
    HRESULT hr;

    _dwContentType = dwContentType;

    hr = _GetContentTypeHandler(_dwContentType, _szContentTypeHandler,
        ARRAYSIZE(_szContentTypeHandler));

    if (SUCCEEDED(hr))
    {
        hr = _GetContentTypeInfo(_dwContentType, _szIconLabel, ARRAYSIZE(_szIconLabel),
                _szIconLocation, ARRAYSIZE(_szIconLocation));

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy(_szDrive, ARRAYSIZE(_szDrive), pszDrive);

            if (SUCCEEDED(hr))
            {
                IAutoplayHandler* piah;

                hr = _GetAutoplayHandler(_szDrive, TEXT("ContentArrival"),
                        _szContentTypeHandler, &piah);

                if (SUCCEEDED(hr))
                {
                    hr = piah->GetDefaultHandler(&_pszHandlerDefaultOriginal);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            _dwHandlerDefaultFlags = HANDLERDEFAULT_GETFLAGS(hr);
                        }

                        // SHStrDup (we want CoTaskMemAlloc)
                        hr = SHStrDup(_pszHandlerDefaultOriginal, &_pszHandlerDefault);
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (_dpaHandlerData.Create(4))
                        {
                            hr = _EnumHandlerHelper(piah);
                            if (SUCCEEDED(hr))
                            {
                                _AddLegacyHandler(dwContentType);
                            }
                        }
                    }

                    piah->Release();
                }
            }
        }
    }

    return hr;
}

HRESULT CContentTypeCBItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        hr = StringCchCopy(pszText, cchText, pdata->_szIconLabel);
        pdata->Release();
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CContentTypeCBItem::GetIconLocation(LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        hr = StringCchCopy(pszIconLocation, cchIconLocation, pdata->_szIconLocation);
        pdata->Release();
    }
    else
    {
        *pszIconLocation = NULL;
        hr = S_FALSE;
    }

    return hr;
}

CHandlerData::~CHandlerData()
{
    if (_pszHandler)
    {
        CoTaskMemFree((void*)_pszHandler);
    }
    if (_pszHandlerFriendlyName)
    {
        CoTaskMemFree((void*)_pszHandlerFriendlyName);
    }
    if (_pszIconLocation)
    {
        CoTaskMemFree((void*)_pszIconLocation);
    }
    if (_pszTileText)
    {
        CoTaskMemFree(_pszTileText);
    }
}

void CHandlerData::Init(PWSTR pszHandler, PWSTR pszHandlerFriendlyName,
    PWSTR pszIconLocation, PWSTR pszTileText)
{
    _pszHandler = pszHandler;
    _pszHandlerFriendlyName = pszHandlerFriendlyName;
    _pszIconLocation = pszIconLocation;
    _pszTileText = pszTileText;
    //  WE CANT FAIL
}

void CHandlerData::UpdateDirty()
{
    // nothing to do
}
    
HRESULT CHandlerLVItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CHandlerData* pdata = GetData();
    if (pdata)
    {
        hr = StringCchCopy(pszText, cchText, pdata->_pszHandlerFriendlyName);
        pdata->Release();
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHandlerLVItem::GetIconLocation(LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    HRESULT hr;
    CHandlerData* pdata = GetData();
    if (pdata)
    {
        hr = StringCchCopy(pszIconLocation, cchIconLocation, pdata->_pszIconLocation);
        pdata->Release();
    }
    else
    {
        *pszIconLocation = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHandlerLVItem::GetTileText(int i, LPWSTR pszTileText, DWORD cchTileText)
{
    HRESULT hr = S_FALSE;
    CHandlerData* pdata = GetData();

    *pszTileText = NULL;
    hr = S_FALSE;

    // we dont support anything but zero
    ASSERT(0 == i);
    if (pdata)
    {
        if (pdata->_pszTileText)
        {
            hr = StringCchCopy(pszTileText, cchTileText, pdata->_pszTileText);
        }
        pdata->Release();
    }

    return hr;
}

// We are erring on the side of safety here by giving FALSE positives
// sometimes.  This could be optimized to consider if we have diff handler
// just because one is missing.
void CNoContentData::UpdateDirty()
{
    BOOL fDirty = _AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags);

    _SetDirty(fDirty);
}

HRESULT CNoContentData::CommitChangesToStorage()
{
    HRESULT hr = S_OK;

    if (_AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags))
    {
        // Yep, changed
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandlerNoContent(_szDeviceID, TEXT("DeviceArrival"), &piah);
        if (SUCCEEDED(hr))
        {
            if (!_fSoftCommit)
            {
                hr = piah->SetDefaultHandler(_pszHandlerDefault);
            }
            else
            {
                WCHAR szHandler[MAX_HANDLER + ARRAYSIZE(SOFTPREFIX)];

                lstrcpyn(szHandler, SOFTPREFIX, ARRAYSIZE(szHandler));
                StrCatBuff(szHandler, _pszHandlerDefault, ARRAYSIZE(szHandler));

                hr = piah->SetDefaultHandler(szHandler);
            }

            piah->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&_pszHandlerDefaultOriginal, _pszHandlerDefault);
    }

    return hr;
}

CNoContentData::~CNoContentData()
{
    if (_pszHandlerDefaultOriginal)
    {
        CoTaskMemFree(_pszHandlerDefaultOriginal);
    }

    if (_pszHandlerDefault)
    {
        CoTaskMemFree(_pszHandlerDefault);
    }

    if (_pszIconLabel)
    {
        CoTaskMemFree((void*)_pszIconLabel);
    }

    if (_pszIconLocation)
    {
        CoTaskMemFree((void*)_pszIconLocation);
    }
}

HRESULT _MakeDeviceLabel(LPCWSTR pszSource, LPWSTR* ppszDest)
{
    WCHAR szDeviceName[250];

    HRESULT hr = SHLoadIndirectString(pszSource, szDeviceName, ARRAYSIZE(szDeviceName), NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(szDeviceName, ppszDest);
    }

    return hr;
}

HRESULT CNoContentData::Init(LPCWSTR pszDeviceID)
{
    HRESULT hr = StringCchCopy(_szDeviceID, ARRAYSIZE(_szDeviceID), pszDeviceID);

    if (SUCCEEDED(hr))
    {
        IAutoplayHandler* piah;
        hr = _GetAutoplayHandlerNoContent(_szDeviceID, TEXT("DeviceArrival"), &piah);
        if (SUCCEEDED(hr))
        {
            hr = piah->GetDefaultHandler(&_pszHandlerDefaultOriginal);

            if (SUCCEEDED(hr))
            {
                if (S_FALSE != hr)
                {
                    _dwHandlerDefaultFlags = HANDLERDEFAULT_GETFLAGS(hr);
                }

                // SHStrDup (we want CoTaskMemAlloc)
                hr = SHStrDup(_pszHandlerDefaultOriginal, &_pszHandlerDefault);
            }

            if (SUCCEEDED(hr))
            {
                if (_dpaHandlerData.Create(4))
                {
                    hr = _EnumHandlerHelper(piah);
                }
            }

            piah->Release();
        }

        if (SUCCEEDED(hr))
        {
            IHWDeviceCustomProperties* pihwdevcp;
            hr = GetDeviceProperties(_szDeviceID, &pihwdevcp);
            if (SUCCEEDED(hr))
            {
                LPWSTR pszIconLabel;
                hr = pihwdevcp->GetStringProperty(TEXT("Label"), &pszIconLabel);
                if (SUCCEEDED(hr))
                {
                    hr = _MakeDeviceLabel(pszIconLabel, &_pszIconLabel);
                    if (SUCCEEDED(hr))
                    {
                        WORD_BLOB* pblob;

                        hr = pihwdevcp->GetMultiStringProperty(TEXT("Icons"), TRUE, &pblob);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHStrDup(pblob->asData, &_pszIconLocation);

                            CoTaskMemFree(pblob);
                        }

                        CoTaskMemFree(pszIconLabel);
                    }
                }

                pihwdevcp->Release();
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apdlg.h ===
#ifndef APDLG_H
#define APDLG_H

#include "basedlg.h"
#include "ctllogic.h"

#include "apdlglog.h"

#define SETTINGSCURRENTPAGECOUNT    5

#define IDH_SELECT_CONTENT_TYPE 10110
#define IDH_SELECT_ACTION       10111
#define IDH_PROMPT_ME_EACH_TIME 10112
#define IDH_TAKE_NO_ACTION      10113

class CAutoPlayDlg : public CBaseDlg
{
public:
    CAutoPlayDlg();
    ~CAutoPlayDlg();

    HRESULT Init(LPWSTR pszDrive, int iDriveType);

protected:
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    LRESULT OnHelp(WPARAM wParam, LPARAM lParam);
    LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

private:
    LRESULT _OnApply();

private:

    HRESULT _UpdateLowerPane();
    HRESULT _UpdateRestoreButton(BOOL fPromptEachTime);
    HRESULT _SelectRadioButton(BOOL fPromptEachTime);
    HRESULT _SelectListViewActionsItem(LPCWSTR pszHandlerDefault);

    HRESULT _OnListViewActionsSelChange();

    HRESULT _UpdateApplyButton();

    HRESULT _OnRadio(int i);
    HRESULT _OnRestoreDefault();

    HRESULT _InitDataObjects();
    HRESULT _InitListView();
    HRESULT _FillListView();

    HRESULT _InitListViewActions();
    HRESULT _FillListViewActions(CContentTypeData* pdata);

private:
    CContentTypeData*                   _rgpContentTypeData[7];

    int                                 _iDriveType;
    WCHAR                               _szDrive[MAX_PATH];

    HIMAGELIST                          _himagelist;
    BOOL                                _fAtLeastOneAction;
    BOOL                                _fIgnoreListViewItemStateChanges;

    CUILComboBoxEx<CContentTypeData>    _uilListView;
    CUILListView<CHandlerData>          _uilListViewActions;
    
    CDLManager<CContentTypeData>        _dlmanager;
};

#endif //APDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\resdll\makefile.inc ===
$(O)\error.dls : ..\error.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\error.dlg > $@

$(O)\error.dlx : $(O)\error.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\error.dls > $@

$(O)\about.dls : ..\about.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\about.dlg > $@

$(O)\about.dlx : $(O)\about.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\about.dls > $@

$(O)\findinc.dls : ..\findinc.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\findinc.dlg > $@

$(O)\findinc.dlx : $(O)\findinc.dls ..\dlg.pl
    echo //^<SCRIPT LANGUAGE="JavaScript"^> > $@
    perl ..\dlg.pl < $(O)\findinc.dls >> $@
    echo //^</SCRIPT^> >> $@

$(O)\find.dls : ..\find.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\find.dlg > $@

$(O)\find.dlx : $(O)\find.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\find.dls > $@

$(O)\privacypolicy.dls : ..\privacypolicy.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\privacypolicy.dlg > $@

$(O)\privacypolicy.dlx : $(O)\privacypolicy.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\privacypolicy.dls > $@

$(O)\bidifind.dls : ..\bidifind.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\bidifind.dlg > $@

$(O)\bidifind.dlx : $(O)\bidifind.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\bidifind.dls > $@

$(O)\orgfav.dls : ..\orgfav.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\orgfav.dlg > $@

$(O)\ieerror.dls : ..\ieerror.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\ieerror.dlg > $@

$(O)\ieerror.dlx : $(O)\ieerror.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\ieerror.dls > $@

$(O)\anchbrws.pps : ..\anchbrws.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\anchbrws.ppg > $@

$(O)\anchbrws.ppx: $(O)\anchbrws.pps
    perl ..\dlg.pl < $(O)\anchbrws.pps > $@

$(O)\docbrows.pps: ..\docbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\docbrows.ppg > $@

$(O)\docbrows.ppx : $(O)\docbrows.pps
    perl ..\dlg.pl < $(O)\docbrows.pps > $@

$(O)\imgbrows.pps : ..\imgbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\imgbrows.ppg > $@

$(O)\imgbrows.ppx : $(O)\imgbrows.pps
    perl ..\dlg.pl < $(O)\imgbrows.pps > $@

$(O)\analyze.dls : ..\analyze.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\analyze.dlg > $@

$(O)\analyze.dlx : $(O)\analyze.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\analyze.dls > $@

$(O)\preview.dls : ..\preview.dlg ..\preview.h
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\preview.dlg > $@

$(O)\preview.dlx : $(O)\preview.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\preview.dls > $@

$(O)\pstemplate.dls : ..\pstemplate.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\pstemplate.dlg > $@

$(0)\PrivacyPolicyTransform.xsl : ..\PrivacyPolicyTransform.xsl

$(0)\PolicyLooking.htm : ..\PolicyLooking.htm

$(0)\PolicyNone.htm : ..\PolicyNone.htm

$(0)\PolicyError.htm : ..\PolicyError.htm

$(0)\PolicySyntaxError.htm : ..\PolicySyntaxError.htm

$(O)\pstemplate.dlx : $(O)\pstemplate.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\pstemplate.dls > $@

SHDOCLCR_DEP = \
    $(O)\error.dlx      \
    $(O)\about.dlx      \
    $(O)\findinc.dlx    \
    $(O)\find.dlx       \
    $(O)\privacypolicy.dlx  \
    $(O)\bidifind.dlx   \
    $(O)\orgfav.dls     \
    $(O)\ieerror.dlx    \
    $(O)\anchbrws.ppx   \
    $(O)\docbrows.ppx   \
    $(O)\imgbrows.ppx   \
    $(O)\analyze.dlx    \
    $(O)\preview.dlx    \
    $(0)\PrivacyPolicyTransform.xsl \
    $(0)\PolicyLooking.htm \
    $(0)\PolicyNone.htm \
    $(0)\PolicyError.htm \
    $(0)\PolicySyntaxError.htm \
    $(O)\pstemplate.dlx \
    ..\hardAdmin.htm \
    ..\softAdmin.htm \
    ..\hardUser.htm  \
    ..\IESecHelp.htm \
    ..\coUA.css      \
    ..\coUAPrint.css \
    ..\IELock.jpg


..\shdoclc.rc : $(SHDOCLCR_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apithk.c ===
// this file should not be needed anymore as we now compile for versions of NT > 500

#include "shellprv.h"
#include <appmgmt.h>
#include <userenv.h>
#include <devguid.h>
#include <dbt.h>

LPTSTR GetEnvBlock(HANDLE hUserToken)
{
    LPTSTR pszRet = NULL;
    if (hUserToken)
        CreateEnvironmentBlock(&pszRet, hUserToken, TRUE);
    else
        pszRet = (LPTSTR) GetEnvironmentStrings();
    return pszRet;
}

void FreeEnvBlock(HANDLE hUserToken, LPTSTR pszEnv)
{
    if (pszEnv)
    {
        if (hUserToken)
            DestroyEnvironmentBlock(pszEnv);
        else
            FreeEnvironmentStrings(pszEnv);
    }
}

STDAPI_(BOOL) GetAllUsersDirectory(LPTSTR pszPath)
{
    DWORD cbData = MAX_PATH;
    BOOL fRet = FALSE;

    // This is delay loaded. It can fail.
    __try 
    {
        fRet = GetAllUsersProfileDirectoryW(pszPath, &cbData);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    { 
        pszPath[0] = 0;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apdlglog.h ===
#ifndef APDLGLOG_H
#define APDLGLOG_H

#include "dlglogic.h"
#include "ctllogic.h"

#include <dpa.h>

#define MAX_CONTENTTYPEHANDLER                  64
#define MAX_CONTENTTYPEHANDLERFRIENDLYNAME      128

#define MAX_DEVICENAME                          50
#define MAX_HANDLER                             64

class CHandlerData : public CDataImpl
{
public:
    // from CDataImpl
    void UpdateDirty();

    // from CHandlerData
    void Init(PWSTR pszHandler, PWSTR pszHandlerFriendlyName, 
        PWSTR pszIconLocation, PWSTR pszTileText);

    HRESULT _GetCommand(PWSTR pszCommand, DWORD cchCommand)
    {
        WCHAR szProgid[260];
        WCHAR szVerb[CCH_KEYMAX];
        HRESULT hr = _GetHandlerInvokeProgIDAndVerb(_pszHandler, 
                            szProgid, ARRAYSIZE(szProgid),
                            szVerb, ARRAYSIZE(szVerb));
        if (SUCCEEDED(hr))
        {
            hr = AssocQueryStringW(0, ASSOCSTR_COMMAND, szProgid, szVerb, pszCommand, &cchCommand);
        }
        return hr;
    }

    HRESULT Compare(LPCWSTR pszHandler, int* piResult)
    {
        (*piResult) = StrCmpW(pszHandler, _pszHandler);

        return S_OK;
    };

    ~CHandlerData();

public:
    PWSTR          _pszHandler;
    PWSTR          _pszHandlerFriendlyName;
    PWSTR          _pszIconLocation;
    PWSTR          _pszTileText;
};

class CHandlerDataArray : public CDPA<CHandlerData>
{
public:
    static int CALLBACK _ReleaseHandler(CHandlerData *pdata, void *)
    {
        pdata->Release();
        return 1;
    }
    
    ~CHandlerDataArray();

    HRESULT AddHandler(CHandlerData *pdata);
    BOOL IsDuplicateCommand(PCWSTR pszCommand);

protected:
    BOOL _IsDemotedHandler(PCWSTR pszHandler);
    
};

class CContentBase : public CDataImpl
{
public:
    CHandlerData* GetHandlerData(int i);
    int GetHandlerCount() { return _dpaHandlerData.IsDPASet() ? _dpaHandlerData.GetPtrCount() : 0; }
    void RemoveHandler(int i)
    {
        CHandlerData *pdata = _dpaHandlerData.DeletePtr(i);
        if (pdata)
            pdata->Release();
    }

            
protected:
    HRESULT _AddLegacyHandler(DWORD dwContentType);
    HRESULT _EnumHandlerHelper(IAutoplayHandler* piah);

public:  // members
    CHandlerDataArray     _dpaHandlerData;
};

class CNoContentData : public CContentBase
{
public:
    // from CDataImpl
    void UpdateDirty();
    HRESULT CommitChangesToStorage();

    // from CNoContentData
    HRESULT Init(LPCWSTR pszDeviceID);

public:
    CNoContentData() : _dwHandlerDefaultFlags(0) {}
    ~CNoContentData();

    // MAX_DEVICE_ID_LEN == 200
    WCHAR                   _szDeviceID[200];

    LPWSTR                  _pszIconLabel; // e.g.: "Compaq iPaq"
    LPWSTR                  _pszIconLocation;

    // Latest settings (potentially modified by user)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefault;

    // Original settings (unmodified)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefaultOriginal;

    DWORD                   _dwHandlerDefaultFlags;
    BOOL                    _fSoftCommit;
};

class CContentTypeData : public CContentBase
{
public:
    // from CDataImpl
    void UpdateDirty();
    HRESULT CommitChangesToStorage();

    // from CContentTypeData
    HRESULT Init(LPCWSTR pszDrive, DWORD dwContentType);

public:
    CContentTypeData() : _dwHandlerDefaultFlags(0) {}
    ~CContentTypeData();

    DWORD                   _dwContentType;

    WCHAR                   _szContentTypeHandler[MAX_CONTENTTYPEHANDLER];
    WCHAR                   _szDrive[MAX_PATH];

    // For ListView
    WCHAR                   _szIconLabel[MAX_CONTENTTYPEHANDLERFRIENDLYNAME]; // e.g.: "Pictures"
    WCHAR                   _szIconLocation[MAX_ICONLOCATION];

    // Latest settings (potentially modified by user)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefault;

    // Original settings (unmodified)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefaultOriginal;

    DWORD                   _dwHandlerDefaultFlags;
    BOOL                    _fSoftCommit;
};

class CContentTypeCBItem : public CDLUIDataCBItem<CContentTypeData>
{
public:
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
    HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation);
};

class CHandlerLVItem : public CDLUIDataLVItem<CHandlerData>
{
public:
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
    HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation);
    HRESULT GetTileText(int i, LPWSTR pszTileText,
        DWORD cchTileText);
};

HRESULT _SetHandlerDefault(LPWSTR* ppszHandlerDefault, LPCWSTR pszHandler);

#endif // APDLGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apithk.h ===
#ifndef _APITHK_H_
#define _APITHK_H_

#include <appmgmt.h>
#include <aclapi.h>
#include <userenv.h>

LPTSTR GetEnvBlock(HANDLE hUserToken);
void FreeEnvBlock(HANDLE hUserToken, LPTSTR pszEnv);
STDAPI_(BOOL) GetAllUsersDirectory(LPTSTR pszPath);

#define PrivateVOLUME_UPGRADE_SCHEDULED         (0x00000002)

#define KEYBOARDCUES
#ifdef KEYBOARDCUES
#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129
#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3
#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2
#endif //KEYBOARDCUES

#define PrivateULW_COLORKEY            0x00000001
#define PrivateULW_ALPHA               0x00000002
#define PrivateULW_OPAQUE              0x00000004
#define PrivateWS_EX_LAYERED           0x00080000

#if (_WIN32_WINNT >= 0x0500)

// for files in nt5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if WS_EX_LAYERED != PrivateWS_EX_LAYERED
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#else   // (_WIN32_WINNT >= 0x0500)

#define WS_EX_LAYERED           PrivateWS_EX_LAYERED
#define UpdateLayeredWindow     NT5_UpdateLayeredWindow 
#define ULW_COLORKEY            PrivateULW_COLORKEY
#define ULW_ALPHA               PrivateULW_ALPHA
#define ULW_OPAQUE              PrivateULW_OPAQUE
#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE 
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE 
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE  
#define UIS_SET                 PrivateUIS_SET          
#define UIS_CLEAR               PrivateUIS_CLEAR        
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE   
#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL   

#endif  // (_WIN32_WINNT >= 0x0500)

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\argvw.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

/***
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPWSTR cmdstart,
    LPWSTR*argv,
    LPWSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPWSTR p;
    WCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (WCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPWSTR * CommandLineToArgvW (LPCWSTR lpCmdLine, int*pNumArgs)
{
    LPWSTR*argv_U;
    LPWSTR  cmdstart;                 /* start of command line to parse */
    INT     numbytes;
    WCHAR   pgmname[MAX_PATH];

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    /* Get the program name pointer from Win32 Base */

    GetModuleFileName (NULL, pgmname, sizeof(pgmname) / sizeof(WCHAR));

    /* if there's no command line at all (won't happen from cmd.exe, but
       possibly another program), then we use pgmname as the command line
       to parse, so that argv[0] is initialized to the program name */
    cmdstart = (*lpCmdLine == TEXT('\0')) ? pgmname : (LPWSTR) lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_Cmdline (cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPWSTR*) LocalAlloc( LMEM_ZEROINIT,
                                   (*pNumArgs+1) * sizeof(LPWSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_Cmdline (cmdstart, argv_U,
                   (LPWSTR) (((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                   pNumArgs, &numbytes);

    return (argv_U);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\apprmdlg.h ===
#ifndef HWPROMPT_H
#define HWPROMPT_H

#include "basedlg.h"
#include "apdlglog.h"

#include <dpa.h>

class CBaseContentDlg : public CBaseDlg
{
public:
    CBaseContentDlg();
    HRESULT Init(LPCWSTR pszDeviceID, LPCWSTR pszDeviceIDAlt,
        DWORD dwContentType, BOOL fCheckAlwaysDoThis);

    LPWSTR                          _pszDeviceID;
    WCHAR                           _szDeviceIDAlt[MAX_PATH];
    BOOL                            _fCheckAlwaysDoThis;

    WCHAR                           _szHandler[MAX_HANDLER];
    WCHAR                           _szContentTypeHandler[MAX_CONTENTTYPEHANDLER];
    HINSTANCE                       _hinst;
    int                             _iResource;
    HWND                            _hwndParent;
    DWORD                           _dwContentType;

protected:
    virtual ~CBaseContentDlg();
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    virtual LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

    virtual HRESULT _FillListView() PURE;
    virtual HRESULT _InitStatics() PURE;
    virtual HRESULT _InitSelections() PURE;
    virtual HRESULT _OnListSelChange() PURE;

    HRESULT _InitDeviceName();
    HRESULT _SetHandler();

    CUILListViewSelect<CHandlerData, LPCWSTR>   _uilListView;

    WCHAR                                       _szDeviceName[MAX_DEVICENAME];
    HICON                                       _hiconInfo;
    HICON                                       _hiconTop;

private:
    HRESULT _InitListView();
    HRESULT _InitStaticsCommon();

    HIMAGELIST                                  _himagelist;
};

///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is a dominant content and current setting is
// "prompt each time"
class CHWContentPromptDlg : public CBaseContentDlg
{
public:
    CHWContentPromptDlg();
    virtual ~CHWCont