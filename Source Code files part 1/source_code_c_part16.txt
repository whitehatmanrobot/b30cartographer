es     di,DWORD PTR cs:[RHPtr] ;load Request Header pointer into es:di
	mov     bl,es:[di+2]            ;get command code from RHPtr into bl

	or      bl,bl                   ;We only handle command zero (Init)
	jnz     error_out

	push    es
	push    di
	call    init_safedsk
	pop     di
	pop     es
	jnc     short dont_load
	

Return_To_Dos:
	pop     dx
	pop     bx
	pop     di
	pop     es
	pop     ds
	ret

dont_load:
	mov     WORD PTR es:[di+0Eh],offset Header ;return pointer to header
	mov     WORD PTR es:[di+10h],cs            ;to indicate don't load
	mov     word ptr es:[di+3],8100h           ;inform kernel of error

	mov     ax,7FFFh                           ;also clear high bit
	and     WORD PTR cs:DevAttr,ax             ;of attribute word
						   ;so next driver will load
						   ;on top of us

	xor     ax,ax                              ;return no error
	jmp     short return_to_dos

error_out:
	mov     word ptr es:[di+3],8003h ;bad command code in request header
	jmp     short return_to_dos

Interrupt       endp


vseg ends


end 

endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\sdvxd\shell.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELL.Inc - Public services for SHELL
;
;   Version:	1.00
;
;   Date:	30-Nov-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 RAL Original
;   12-Oct-1988 RAL Converted to use VxD_Service macros
;   29-Nov-1988 ARR Redo split from VMCTRL
;
;==============================================================================

Begin_Service_Table SHELL

SHELL_Service  SHELL_Get_Version, LOCAL
SHELL_Service  SHELL_Resolve_Contention
SHELL_Service  SHELL_Event,LOCAL
SHELL_Service  SHELL_SYSMODAL_Message,LOCAL
SHELL_Service  SHELL_Message,LOCAL

End_Service_Table SHELL

;
;   Windows Message Box Flags used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
MB_OK			 EQU	    00H
MB_OKCANCEL		 EQU	    01H
MB_ABORTRETRYIGNORE	 EQU	    02H
MB_YESNOCANCEL		 EQU	    03H
MB_YESNO		 EQU	    04H
MB_RETRYCANCEL		 EQU	    05H
MB_ICONHAND		 EQU	    010H
MB_ICONEXCLAMATION	 EQU	    030H
MB_ICONASTERISK 	 EQU	    040H
MB_DEFBUTTON1		 EQU	    00H
MB_DEFBUTTON2		 EQU	    0100H
MB_DEFBUTTON3		 EQU	    0200H
MB_APPLMODAL		 EQU	    00H
MB_SYSTEMMODAL		 EQU	    01000H
MB_NOFOCUS		 EQU	    08000H
;
; Following bits are WIN386 SHELL extensions
;
MB_ASAP 		 EQU	    080000000H	; Message is timely, put
						;   up as soon as possible
;
;   Windows Message Box Return codes used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
IDOK                     EQU	1
IDCANCEL                 EQU	2
IDABORT                  EQU	3
IDRETRY                  EQU	4
IDIGNORE                 EQU	5
IDYES                    EQU	6
IDNO                     EQU	7

;
; On SHELL_Event, the wParam in EAX occupies the low 16 bits of EAX. The High 16
;	bits contain extra flags
;
SE_WP_SetFocusBoost	equ	00000000000000010000000000000000b
SE_WP_SetFocusBoostBit	equ	16		; Boost the SYS VM till a
						; Set_Focus call
SE_WP_SwitcherBoost	equ	00000000000000100000000000000000b
SE_WP_SwitcherBoostBit	equ	17		; Boost the SYS VM on Switcher
						;  screen
SE_WP_FilSysChgBoost	equ	00000000000001000000000000000000b
SE_WP_FilSysChgBoostBit equ	18		; Boost the SYS VM till response
						;  to VDA_FileSysChange
SE_WP_ClipAPIBoost	equ	00000000000010000000000000000000b
SE_WP_ClipAPIBoostBit	equ	19		; Boost the SYS VM during clipbrd
						;  API
SE_WP_PrtScBoost	equ	00000000000100000000000000000000b
SE_WP_PrtScBoostBit	equ	20		; Boost the SYS VM during Print screen

include shellfsc.inc
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\sdvxd\sdvxd.asm ===
PAGE 58,132
;******************************************************************************
TITLE SDVxD.ASM - VxD to display error message for SmartDrv.Exe
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1991
;
;   Title:	SDVxD.ASM - VxD to display error message for SmartDrv.Exe
;
;   Version:	1.00
;
;   Date:	22-Nov-1991
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-Nov-1991 RAL Original
;
;==============================================================================

	.386p


;******************************************************************************
;			      I N C L U D E S
;******************************************************************************

	.XLIST
	INCLUDE VMM.Inc
	INCLUDE Debug.Inc
	INCLUDE SHELL.Inc
	.LIST

;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device SDVXD, 3, 0, SDVxD_Control


;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************


;******************************************************************************
;		   I N I T I A L I Z A T I O N	 D A T A
;******************************************************************************


;******************************************************************************
;			    L O C A L	D A T A
;******************************************************************************

VxD_DATA_SEG

EXTRN SDVxD_Error_Title_Msg:BYTE
EXTRN SDVxD_Write_Error_Msg:BYTE
EXTRN SDVxD_Write_Drive_Letter:BYTE


SD_Ref_Data_Ptr 	dd	?
SD_Orig_Msg_CSIP	dd	0	    ; 0 indicates not initialized

VxD_DATA_ENDS


;******************************************************************************
;	       D E V I C E   C O N T R O L   P R O C E D U R E
;******************************************************************************

VxD_CODE_SEG

;******************************************************************************
;
;   SDVxD_Control
;
;   DESCRIPTION:
;	This is SDVxD's control procedure.
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc SDVxD_Control

	Control_Dispatch Init_Complete, SDVxD_Init_Complete
	Control_Dispatch System_Exit, <SHORT SDVxD_System_Exit>

	clc					; Ignore other control calls
	ret

EndProc SDVxD_Control

VxD_CODE_ENDS


;******************************************************************************
;		    I N I T I A L I Z A T I O N   C O D E
;******************************************************************************

VxD_ICODE_SEG


;******************************************************************************
;
;   SDVxD_Init_Complete
;
;   DESCRIPTION:
;	Initializes real mode SDVxD's error call-back to point to a V86
;	call-back address.
;
;   ENTRY:
;	EDX = Reference data (ptr to dword to patch to call-back break point)
;
;   EXIT:
;	Carry clear
;
;   USES:
;
;
;==============================================================================

BeginProc SDVxD_Init_Complete

	movzx	eax, dx
	shr	edx, 16
	shl	edx, 4
	add	edx, eax

	mov	[SD_Ref_Data_Ptr], edx

	mov	esi, OFFSET32 SDVxD_Error_Msg_Call_Back
	VMMcall Allocate_V86_Call_Back
IFDEF DEBUG
	jnc	SHORT SD_IC_Got_CB
	Debug_Out "WARNING:  Unable to allocate call-back address for SDVxD.  VxD not loading."
	stc
	jmp	SHORT SDVxD_IC_Exit
SD_IC_Got_CB:
ELSE
	jc	SHORT SDVxD_IC_Exit
ENDIF

	xchg	eax, DWORD PTR [edx]
	mov	[SD_Orig_Msg_CSIP], eax

	clc
SDVxD_IC_Exit:
	ret

EndProc SDVxD_Init_Complete



VxD_ICODE_ENDS

;******************************************************************************
;	       D E V I C E   C O N T R O L   H A N D L E R S
;******************************************************************************

VxD_CODE_SEG

;******************************************************************************
;
;   SDVxD_System_Exit
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

BeginProc SDVxD_System_Exit

	xor	ecx, ecx
	xchg	[SD_Orig_Msg_CSIP], ecx
	jecxz	SD_SE_Done
	mov	edi, [SD_Ref_Data_Ptr]
	mov	DWORD PTR [edi], ecx

SD_SE_Done:
	clc
	ret

EndProc SDVxD_System_Exit


;******************************************************************************
;			L O C A L   P R O C E D U R E S
;******************************************************************************

;******************************************************************************
;
;   SDVxD_Error_Msg_Call_Back
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

BeginProc SDVxD_Error_Msg_Call_Back

	mov	ecx, (Block_Svc_Ints OR Block_Enable_Ints)
	VMMcall Begin_Critical_Section

	mov	al, [ebp.Client_AL]
	add	al, "A"
	mov	[SDVxD_Write_Drive_Letter], al

	mov	edi, OFFSET32 SDVxD_Error_Title_Msg
	mov	eax, MB_SYSTEMMODAL OR MB_ASAP OR MB_ICONEXCLAMATION OR MB_OK
	mov	ecx, OFFSET32 SDVxD_Write_Error_Msg

	VxDcall SHELL_SYSMODAL_Message

	VMMcall End_Critical_Section
	VMMjmp	Simulate_Far_Ret

EndProc SDVxD_Error_Msg_Call_Back


;******************************************************************************
;		       D E B U G G I N G   C O D E
;******************************************************************************

VxD_CODE_ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\sdvxd\vmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMM.INC - Include file for Virtual Machine Manager
;
;   Version:	1.00
;
;   Date:	05-May-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   05-May-1988 RAL Original
;
;==============================================================================


; NON Windows/386 Virtual Device sources can include this file to get some
; useful equates by declaring the symbol "Not_VxD"  If this symbol is defined,
; then everything that has to do with the specifics of the 32 bit environment
; for virtual devices is removed.  Useful equates include:  device ID's, pushad
; structure, BeginDoc/EndDoc/BeginMsg/EndMsg equates, page table equates, etc.



False	EQU	0
True	EQU	NOT False

;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>


BeginDoc
;******************************************************************************
;
;			EQUATES FOR REQUIRED DEVICES
;
;   Device ID formulation note:
;
;	Device ID's are a combination of OEM # and device # in the form:
;
;		xOOOOOOOOOODDDDD
;
;	The high bit of the device ID is reserved for future use.  The next
;	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
;	are the device #.  This allows each OEM to create 32 unique devices.
;	If an OEM is creating a replacement for a standard device, then it
;	should re-use the standard ID listed below.  Microsoft reserves the
;	first 16 OEM #'s (0 thru 0Fh)
;
;==============================================================================

Undefined_Device_ID		EQU	00000h
VMM_Device_ID			EQU	00001h	; Used for dynalink table
Debug_Device_ID 		EQU	00002h
VPICD_Device_ID 		EQU	00003h
VDMAD_Device_ID 		EQU	00004h
VTD_Device_ID			EQU	00005h
V86MMGR_Device_ID		EQU	00006h
PageSwap_Device_ID		EQU	00007h
Parity_Device_ID		EQU	00008h
Reboot_Device_ID		EQU	00009h
VDD_Device_ID			EQU	0000Ah
VSD_Device_ID			EQU	0000Bh
VMD_Device_ID			EQU	0000Ch
VKD_Device_ID			EQU	0000Dh
VCD_Device_ID			EQU	0000Eh
VPD_Device_ID			EQU	0000Fh
VHD_Device_ID			EQU	00010h
VMCPD_Device_ID 		EQU	00011h
EBIOS_Device_ID 		EQU	00012h
BIOSXlat_Device_ID		EQU	00013h
VNETBIOS_Device_ID		EQU	00014h
DOSMGR_Device_ID		EQU	00015h
WINLOAD_Device_ID		EQU	00016h
SHELL_Device_ID 		EQU	00017h
VMPoll_Device_ID		EQU	00018h
VPROD_Device_ID 		EQU	00019h
DOSNET_Device_ID		EQU	0001Ah
VFD_Device_ID			EQU	0001Bh
VDD2_Device_ID			EQU	0001Ch	; Secondary display adapter
WINDEBUG_Device_ID		EQU	0001Dh
TSRLoad_Device_ID		EQU	0001Eh	; TSR instance utility ID

;
;   Initialization order equates.  Devices are initialized in order from
;   LOWEST to HIGHEST.	If 2 or more devices have the same initialization
;   order value, then they are initialized in order of occurance, so a
;   specific order is not guaranteed.  Holes have been left to allow maximum
;   flexibility in ordering devices.
;

VMM_Init_Order			EQU	000000000h
Debug_Init_Order		EQU	004000000h
VPROD_Init_Order		EQU	008000000h
VPICD_Init_Order		EQU	00C000000h
VTD_Init_Order			EQU	014000000h
PageSwap_Init_Order		EQU	01C000000h
Parity_Init_Order		EQU	020000000h
Reboot_Init_Order		EQU	024000000h
EBIOS_Init_Order		EQU	026000000h
VDD_Init_Order			EQU	028000000h
VSD_Init_Order			EQU	02C000000h
VCD_Init_Order			EQU	030000000h
VMD_Init_Order			EQU	034000000h
VKD_Init_Order			EQU	038000000h
VPD_Init_Order			EQU	03C000000h
VHD_Init_Order			EQU	040000000h
VFD_Init_Order			EQU	044000000h
VMCPD_Init_Order		EQU	048000000h
BIOSXlat_Init_Order		EQU	050000000h
VNETBIOS_Init_Order		EQU	054000000h
DOSMGR_Init_Order		EQU	058000000h
DOSNET_Init_Order		EQU	05C000000h
WINLOAD_Init_Order		EQU	060000000h
VMPoll_Init_Order		EQU	064000000h

Undefined_Init_Order		EQU	080000000h

WINDEBUG_Init_Order		EQU	081000000h
VDMAD_Init_Order		EQU	090000000h
V86MMGR_Init_Order		EQU	0A0000000h
SHELL_Init_Order		EQU	0B0000000h
EndDoc

;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM

Pushad_Struc	STRUC
Pushad_EDI	dd	?		; Client's EDI
Pushad_ESI	dd	?		; Client's ESI
Pushad_EBP	dd	?		; Client's EBP
Pushad_ESP	dd	?		; ESP at pushall
Pushad_EBX	dd	?		; Client's EBX
Pushad_EDX	dd	?		; Client's EDX
Pushad_ECX	dd	?		; Client's ECX
Pushad_EAX	dd	?		; Client's EAX
Pushad_Struc	ENDS



IFNDEF Not_VxD

??_CUR_CODE_SEG = 0


??_CODE  = 1
??_ICODE = 2
??_LCODE = 3
??_RCODE = 4

?_CODE	equ <(??_CUR_CODE_SEG MOD 8) - ??_CODE>
?_ICODE equ <(??_CUR_CODE_SEG MOD 8) - ??_ICODE>
?_LCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_LCODE>
?_RCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_RCODE>

;
;  SEGMENT definitions and order
;

;*	32 Bit locked code
_LTEXT		SEGMENT DWORD USE32 PUBLIC 'CODE'
_LTEXT		ENDS

;*	32 Bit code
_TEXT		SEGMENT DWORD USE32 PUBLIC 'PCODE'
_TEXT		ENDS

;*	32 Bit initialization code
_ITEXT		SEGMENT DWORD USE32 PUBLIC 'ICODE'
_ITEXT		ENDS

;*	Contains 32 Bit locked data
_LDATA		SEGMENT DWORD PUBLIC 'CODE'
_LDATA		ENDS

;*	Contains 32 Bit data
_DATA		SEGMENT DWORD PUBLIC 'PCODE'
_DATA		ENDS

;*	Contains 32 Bit initialization data
_IDATA		SEGMENT DWORD PUBLIC 'ICODE'
_IDATA		ENDS

;*	Real Mode initialization code/data for devices
_RCODE		SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE		ENDS


_LGROUP GROUP _LTEXT, _LDATA
_PGROUP GROUP _TEXT, _DATA
_IGROUP GROUP _ITEXT, _IDATA

	ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT


OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;	with an appropriate name describing the function of the routine.
;
;	Begin_Service_Table VxD[,<segname>]
;	VxD_Service <function_name>[,<local segname>]
;	VxD_Service <function_name>[,<local segname>]
;		. . .
;	VxD_Service <function_name>[,<local segname>]
;	End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;	table is put in the segment defined by the macro "yyy_Data_Seg",
;	where yyy=segname. Otherwise the segment is defined by the
;	"VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;	the procedure's segment is defined by the macro "zzz_Code_Seg",
;	where zzz=segname. Otherwise the segment is defined by the
;	"VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1			; Only in module where table is
;	INCLUDE     VxD.INC			; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment
IFB <Def_Segment>
	BST2 Device_Name, VxD
ELSE
	BST2 Device_Name, Def_Segment
ENDIF
	ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table
Def_Segment&_LOCKED_DATA_SEG
Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg
    PUBLIC $&&Procedure
    IF1
    $&&Procedure LABEL DWORD
    ENDIF
    IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
	ELSE
Def_Segment&_CODE_SEG
	ENDIF
	EXTRN	@&&Procedure:NEAR
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
    ENDIF
	dd	OFFSET32 @&&Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ELSE

Device_Name&_Service MACRO Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ENDIF

	ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

	PURGE	Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table
IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF
ENDIF

	ENDM


;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
	LOCAL segn
IFNB <Seg_Name>
	segn equ Seg_Name
ELSE
IFE ?_CODE
	segn equ <_TEXT>
ELSE
IFE ?_ICODE
	segn equ <_ITEXT>
ELSE
IFE ?_LCODE
	segn equ <_LTEXT>
ELSE
.err Dword_Align not supported
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
	    ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;	This macro is used to crash Windows/386 when an unrecoverable error
;	is detected.  If Msg_Ptr is ommitted then no error message will be
;	displayed, otherwise Msg_Ptr is the address
;	when the
;
;   PARAMETERS:
;	Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;	To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
	pushad
IFB <Msg_Ptr>
	xor	esi, esi
ELSE
	mov	esi, Msg_Ptr
IFB <Exit_Flags>
	xor	eax, eax
ELSE
	mov	eax, Exit_Flags
ENDIF
ENDIF
	VMMcall Fatal_Error_Handler
	ENDM

EF_Hang_On_Exit     EQU     1h


;******************************************************************************
;==============================================================================
;------------------------------------------------------------------------------

BeginDoc
;******************************************************************************
;   The following are control block offsets of items that can be of interest
;	to VxDs.
;*******
; VM status indicates globally interesting VM states
CB_VM_Status		EQU	DWORD PTR 00h

VMStat_Exclusive	EQU	000000000000000000001b	; VM is exclusive mode
VMStat_Exclusive_Bit	EQU	0
VMStat_Background	EQU	000000000000000000010b	; VM runs in background
VMStat_Background_Bit	EQU	1
VMStat_Creating 	EQU	000000000000000000100b	; In process of creating
VMStat_Creating_Bit	EQU	2
VMStat_Suspended	EQU	000000000000000001000b	; VM not scheduled
VMStat_Suspended_Bit	EQU	3
VMStat_Not_Executeable	EQU	000000000000000010000b	; VM partially destroyed
VMStat_Not_Executeable_Bit  EQU 4
VMStat_PM_Exec		EQU	000000000000000100000b	; Currently in PM app
VMStat_PM_Exec_Bit	EQU	5
VMStat_PM_App		EQU	000000000000001000000b	; PM app present in VM
VMStat_PM_App_Bit	EQU	6
VMStat_PM_Use32 	EQU	000000000000010000000b	; PM app is 32-bit
VMStat_PM_Use32_Bit	EQU	7
VMStat_VxD_Exec 	EQU	000000000000100000000b	; Call from VxD
VMStat_VxD_Exec_Bit	EQU	8
VMStat_High_Pri_Back	EQU	000000000001000000000b	; High pri background
VMStat_High_Pri_Back_Bit    EQU 9
VMStat_Blocked		EQU	000000000010000000000b	; Blocked on semaphore
VMStat_Blocked_Bit	EQU	0Ah
VMStat_Awakening	EQU	000000000100000000000b	; Woke up after blocked
VMStat_Awakening_Bit	EQU	0Bh
VMStat_PageableV86	EQU	000000001000000000000b	; part of V86 is pageable (PM app)
VMStat_PageableV86Bit	EQU	0Ch
VMStat_V86IntsLocked	EQU	000000010000000000000b	; Rest of V86 is locked
VMStat_V86IntsLockedBit EQU	0Dh			;  regardless of pager type
VMStat_TS_Sched 	EQU	000000100000000000000b	; Scheduled by time-slicer
VMStat_TS_Sched_Bit	EQU	0Eh
VMStat_Idle		EQU	000001000000000000000b	; VM has released time
VMStat_Idle_Bit 	EQU	0Fh			; slice

VMStat_Use32_Mask	EQU	VMStat_PM_Use32 OR VMStat_VxD_Exec


;*******
; Add this value to a V86 linear address to get address of VM's memory in
;	the VMM linear address space
CB_High_Linear		EQU	DWORD PTR 04h

;*******
CB_Client_Pointer	EQU	DWORD PTR 08h

CB_VMID 		EQU	DWORD PTR 0Ch

;
;   Equates for protected mode application control blocks
;
PMCB_Flags		EQU	DWORD PTR 00h
PMCB_Parent		EQU	DWORD PTR 04h
EndDoc

;******************************************************************************
;			    V M M   S E R V I C E S
;******************************************************************************

Begin_Service_Table VMM, VMM

VMM_Service	Get_VMM_Version, LOCAL		; MUST REMAIN SERVICE 0!

VMM_Service	Get_Cur_VM_Handle
VMM_Service	Test_Cur_VM_Handle
VMM_Service	Get_Sys_VM_Handle
VMM_Service	Test_Sys_VM_Handle
VMM_Service	Validate_VM_Handle

VMM_Service	Get_VMM_Reenter_Count, LOCAL
VMM_Service	Begin_Reentrant_Execution, LOCAL
VMM_Service	End_Reentrant_Execution, LOCAL

VMM_Service	Install_V86_Break_Point
VMM_Service	Remove_V86_Break_Point
VMM_Service	Allocate_V86_Call_Back
VMM_Service	Allocate_PM_Call_Back

VMM_Service	Call_When_VM_Returns


VMM_Service	Schedule_Global_Event
VMM_Service	Schedule_VM_Event
VMM_Service	Call_Global_Event
VMM_Service	Call_VM_Event
VMM_Service	Cancel_Global_Event
VMM_Service	Cancel_VM_Event
VMM_Service	Call_Priority_VM_Event
VMM_Service	Cancel_Priority_VM_Event

VMM_Service	Get_NMI_Handler_Addr, LOCAL
VMM_Service	Set_NMI_Handler_Addr, LOCAL
VMM_Service	Hook_NMI_Event

VMM_Service	Call_When_VM_Ints_Enabled
VMM_Service	Enable_VM_Ints
VMM_Service	Disable_VM_Ints

VMM_Service	Map_Flat
VMM_Service	Map_Lin_To_VM_Addr

;
;   Scheduler services
;
VMM_Service	Adjust_Exec_Priority
VMM_Service	Begin_Critical_Section
VMM_Service	End_Critical_Section
VMM_Service	End_Crit_And_Suspend
VMM_Service	Claim_Critical_Section
VMM_Service	Release_Critical_Section
VMM_Service	Call_When_Not_Critical
VMM_Service	Create_Semaphore
VMM_Service	Destroy_Semaphore
VMM_Service	Wait_Semaphore
VMM_Service	Signal_Semaphore
VMM_Service	Get_Crit_Section_Status
VMM_Service	Call_When_Task_Switched
VMM_Service	Suspend_VM
VMM_Service	Resume_VM
VMM_Service	No_Fail_Resume_VM
VMM_Service	Nuke_VM
VMM_Service	Crash_Cur_VM

VMM_Service	Get_Execution_Focus
VMM_Service	Set_Execution_Focus
VMM_Service	Get_Time_Slice_Priority
VMM_Service	Set_Time_Slice_Priority
VMM_Service	Get_Time_Slice_Granularity
VMM_Service	Set_Time_Slice_Granularity
VMM_Service	Get_Time_Slice_Info
VMM_Service	Adjust_Execution_Time
VMM_Service	Release_Time_Slice
VMM_Service	Wake_Up_VM
VMM_Service	Call_When_Idle

VMM_Service	Get_Next_VM_Handle

;
;   Time-out and system timer services
;
VMM_Service	Set_Global_Time_Out
VMM_Service	Set_VM_Time_Out
VMM_Service	Cancel_Time_Out
VMM_Service	Get_System_Time
VMM_Service	Get_VM_Exec_Time

VMM_Service	Hook_V86_Int_Chain
VMM_Service	Get_V86_Int_Vector
VMM_Service	Set_V86_Int_Vector
VMM_Service	Get_PM_Int_Vector
VMM_Service	Set_PM_Int_Vector

VMM_Service	Simulate_Int
VMM_Service	Simulate_Iret
VMM_Service	Simulate_Far_Call
VMM_Service	Simulate_Far_Jmp
VMM_Service	Simulate_Far_Ret
VMM_Service	Simulate_Far_Ret_N
VMM_Service	Build_Int_Stack_Frame

VMM_Service	Simulate_Push
VMM_Service	Simulate_Pop

;
; Heap Manager
;
VMM_Service	_HeapAllocate
VMM_Service	_HeapReAllocate
VMM_Service	_HeapFree
VMM_Service	_HeapGetSize

; ---------------------------------------------------
;
;	 Flags for heap allocator calls
;
; ---------------------------------------------------


HeapZeroInit	equ	00000000000000000000000000000001B
HeapZeroReInit	equ	00000000000000000000000000000010B
HeapNoCopy	equ	00000000000000000000000000000100B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved


;
; Page Manager
;
VMM_Service	_PageAllocate
VMM_Service	_PageReAllocate
VMM_Service	_PageFree
VMM_Service	_PageLock
VMM_Service	_PageUnLock
VMM_Service	_PageGetSizeAddr
VMM_Service	_PageGetAllocInfo
VMM_Service	_GetFreePageCount
VMM_Service	_GetSysPageCount
VMM_Service	_GetVMPgCount
VMM_Service	_MapIntoV86
VMM_Service	_PhysIntoV86
VMM_Service	_TestGlobalV86Mem
VMM_Service	_ModifyPageBits
VMM_Service	_CopyPageTable
VMM_Service	_LinMapIntoV86
VMM_Service	_LinPageLock
VMM_Service	_LinPageUnLock
VMM_Service	_SetResetV86Pageable
VMM_Service	_GetV86PageableArray
VMM_Service	_PageCheckLinRange
VMM_Service	_PageOutDirtyPages
VMM_Service	_PageDiscardPages

; ---------------------------------------------------
;
;	 Flags for other page allocator calls
;
; ---------------------------------------------------
PageZeroInit		equ	00000000000000000000000000000001B
PageUseAlign		equ	00000000000000000000000000000010B
PageContig		equ	00000000000000000000000000000100B
PageFixed		equ	00000000000000000000000000001000B
PageDEBUGNulFault	equ	00000000000000000000000000010000B
PageZeroReInit		equ	00000000000000000000000000100000B
PageNoCopy		equ	00000000000000000000000001000000B
PageLocked		equ	00000000000000000000000010000000B
PageLockedIfDP		equ	00000000000000000000000100000000B
PageSetV86Pageable	equ	00000000000000000000001000000000B
PageClearV86Pageable	equ	00000000000000000000010000000000B
PageSetV86IntsLocked	equ	00000000000000000000100000000000B
PageClearV86IntsLocked	equ	00000000000000000001000000000000B
PageMarkPageOut 	equ	00000000000000000010000000000000B
PagePDPSetBase		equ	00000000000000000100000000000000B
PagePDPClearBase	equ	00000000000000001000000000000000B
PageDiscard		equ	00000000000000010000000000000000B
PagePDPQueryDirty	equ	00000000000000100000000000000000B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved

;
; Informational services
;
VMM_Service	_GetNulPageHandle
VMM_Service	_GetFirstV86Page
VMM_Service	_MapPhysToLinear
VMM_Service	_GetAppFlatDSAlias
VMM_Service	_SelectorMapFlat
VMM_Service	_GetDemandPageInfo
;
; Data structure for _GetDemandPageInfo
;
DemandInfoStruc struc
DILin_Total_Count     dd	      ?       ; # pages in linear address space
DIPhys_Count	      dd	      ?       ; Count of phys pages
DIFree_Count	      dd	      ?       ; Count of free phys pages
DIUnlock_Count	      dd	      ?       ; Count of unlocked Phys Pages
DILinear_Base_Addr    dd	      ?       ; Base of pageable address space
DILin_Total_Free      dd	      ?       ; Total Count of free linear pages
DIReserved	      dd      10 dup (?)      ; Resvd for expansion
DemandInfoStruc ends

VMM_Service	_GetSetPageOutCount
;
; Flags bits for _GetSetPageOutCount
;
GSPOC_F_Get	equ	00000000000000000000000000000001B

;
; Device VM page manager
;
VMM_Service	Hook_V86_Page
VMM_Service	_Assign_Device_V86_Pages
VMM_Service	_DeAssign_Device_V86_Pages
VMM_Service	_Get_Device_V86_Pages_Array
VMM_Service	MMGR_SetNULPageAddr

;
; GDT/LDT management
;
VMM_Service	_Allocate_GDT_Selector
VMM_Service	_Free_GDT_Selector
VMM_Service	_Allocate_LDT_Selector
VMM_Service	_Free_LDT_Selector
VMM_Service	_BuildDescriptorDWORDs
;
; Flag equates for _BuildDescriptorDWORDs
;
BDDExplicitDPL	EQU	00000000000000000000000000000001B
;
; Flag equates for _Allocate_LDT_Selector
;
ALDTSpecSel	EQU	00000000000000000000000000000001B

VMM_Service	_GetDescriptor
VMM_Service	_SetDescriptor


VMM_Service	_MMGR_Toggle_HMA
;
; Flag equates for _MMGR_Toggle_HMA
;
MMGRHMAPhysical EQU	00000000000000000000000000000001B
MMGRHMAEnable	EQU	00000000000000000000000000000010B
MMGRHMADisable	EQU	00000000000000000000000000000100B
MMGRHMAQuery	EQU	00000000000000000000000000001000B


VMM_Service	Get_Fault_Hook_Addrs, LOCAL
VMM_Service	Hook_V86_Fault, LOCAL
VMM_Service	Hook_PM_Fault, LOCAL
VMM_Service	Hook_VMM_Fault, LOCAL

VMM_Service	Begin_Nest_V86_Exec
VMM_Service	Begin_Nest_Exec
VMM_Service	Exec_Int
VMM_Service	Resume_Exec
VMM_Service	End_Nest_Exec

VMM_Service	Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service	Get_Cur_PM_App_CB

VMM_Service	Set_V86_Exec_Mode
VMM_Service	Set_PM_Exec_Mode

VMM_Service	Begin_Use_Locked_PM_Stack
VMM_Service	End_Use_Locked_PM_Stack

VMM_Service	Save_Client_State
VMM_Service	Restore_Client_State

VMM_Service	Exec_VxD_Int

VMM_Service	Hook_Device_Service, LOCAL

VMM_Service	Hook_Device_V86_API
VMM_Service	Hook_Device_PM_API

VMM_Service	System_Control

;
;   I/O and software interrupt hooks
;
VMM_Service	Simulate_IO
VMM_Service	Install_Mult_IO_Handlers
VMM_Service	Install_IO_Handler
VMM_Service	Enable_Global_Trapping
VMM_Service	Enable_Local_Trapping
VMM_Service	Disable_Global_Trapping
VMM_Service	Disable_Local_Trapping


;
;   Linked List Abstract Data Type Services
;
VMM_Service	List_Create
VMM_Service	List_Destroy
VMM_Service	List_Allocate
VMM_Service	List_Attach
VMM_Service	List_Attach_Tail
VMM_Service	List_Insert
VMM_Service	List_Remove
VMM_Service	List_Deallocate
VMM_Service	List_Get_First
VMM_Service	List_Get_Next
VMM_Service	List_Remove_First

;
;   Flags used by List_Create
;
LF_Async		EQU	00000001b
LF_Async_Bit		EQU	0
LF_Use_Heap		EQU	00000010b
LF_Use_Heap_Bit 	EQU	1
LF_Alloc_Error		EQU	00000100b
LF_Alloc_Error_Bit	EQU	2


;==============================================================================
;	I N I T I A L I Z A T I O N   P R O C E D U R E S
;------------------------------------------------------------------------------


;
; Instance data manager
;
VMM_Service	_AddInstanceItem
;
; Data structure for _AddInstanceItem
;
InstDataStruc struc
InstLinkF	      dd	      0       ; RESERVED SET TO 0
InstLinkB	      dd	      0       ; RESERVED SET TO 0
InstLinAddr	      dd	      ?       ; Linear address of start of block
InstSize	      dd	      ?       ; Size of block in bytes
InstType	      dd	      ?       ; Type of block
InstDataStruc ends
;
; Values for InstType
;
INDOS_Field	equ	100h	; Bit indicating INDOS switch requirements
ALWAYS_Field	equ	200h	; Bit indicating ALWAYS switch requirements

;
; System structure data manager
;
VMM_Service	_Allocate_Device_CB_Area, VMM_ICODE
VMM_Service	_Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service	_Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service	_Free_Temp_V86_Data_Area, VMM_ICODE

;
; Flag bits for _Allocate_Global_VM_Data_Area
;
GVDAWordAlign		EQU		00000000000000000000000000000001B
GVDADWordAlign		EQU		00000000000000000000000000000010B
GVDAParaAlign		EQU		00000000000000000000000000000100B
GVDAPageAlign		EQU		00000000000000000000000000001000B
GVDAInstance		EQU		00000000000000000000000100000000B
GVDAZeroInit		EQU		00000000000000000000001000000000B
GVDAReclaim		EQU		00000000000000000000010000000000B

;
; Initialization information calls (win.ini and environment parameters)
;
VMM_Service	Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service	Convert_Decimal_String, VMM_ICODE
VMM_Service	Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service	Convert_Fixed_Point_String, VMM_ICODE
VMM_Service	Get_Profile_Hex_Int, VMM_ICODE
VMM_Service	Convert_Hex_String, VMM_ICODE
VMM_Service	Get_Profile_Boolean, VMM_ICODE
VMM_Service	Convert_Boolean_String, VMM_ICODE
VMM_Service	Get_Profile_String, VMM_ICODE
VMM_Service	Get_Next_Profile_String, VMM_ICODE
VMM_Service	Get_Environment_String, VMM_ICODE
VMM_Service	Get_Exec_Path, VMM_ICODE
VMM_Service	Get_Config_Directory, VMM_ICODE
VMM_Service	OpenFile, VMM_ICODE
VMM_Service	Get_PSP_Segment, VMM_ICODE
VMM_Service	GetDOSVectors, VMM_ICODE
VMM_Service	Get_Machine_Info

GMIF_80486	EQU	00010000h
GMIF_80486_Bit	EQU	10h
GMIF_PCXT	EQU	00020000h
GMIF_PCXT_Bit	EQU	11h
GMIF_MCA	EQU	00040000h
GMIF_MCA_Bit	EQU	12h
GMIF_EISA	EQU	00080000h
GMIF_EISA_Bit	EQU	13h


;
; Following service is not restricted to initialization
;
VMM_Service	GetSet_HMA_Info
VMM_Service	Set_System_Exit_Code

VMM_Service	Fatal_Error_Handler
VMM_Service	Fatal_Memory_Error

;
;   Called by VTD only
;
VMM_Service	Update_System_Clock

;==============================================================================
;		    D E B U G G I N G	E X T E R N S
;==============================================================================

VMM_Service	Test_Debug_Installed		; Valid call in retail also

VMM_Service	Out_Debug_String		; Valid in DEBLEVEL=1
VMM_Service	Out_Debug_Chr
VMM_Service	In_Debug_Chr
VMM_Service	Debug_Convert_Hex_Binary
VMM_Service	Debug_Convert_Hex_Decimal

VMM_Service	Debug_Test_Valid_Handle
VMM_Service	Validate_Client_Ptr
VMM_Service	Test_Reenter
VMM_Service	Queue_Debug_String
VMM_Service	Log_Proc_Call
VMM_Service	Debug_Test_Cur_VM

.errnz Debug_Test_Cur_VM - 100CCh   ; VMM service table changed above this service

VMM_Service	Get_PM_Int_Type
VMM_Service	Set_PM_Int_Type

VMM_Service	Get_Last_Updated_System_Time
VMM_Service	Get_Last_Updated_VM_Exec_Time

End_Service_Table VMM, VMM



;******************************************************************************

IFDEF DEBUG
DebFar	EQU	NEAR PTR
ELSE
DebFar	EQU	SHORT
ENDIF

BeginDoc

;******************************************************************************
;
;		     EQUATES FOR SYSTEM_CONTROL CALLS
;
;==============================================================================

;
; Sys_Critical_Init is a device init call. Devices that have a critical
;   function that needs initializing before interrupts are enabled should
;   do it at Sys_Critical_Init. Devices which REQUIRE a certain range of
;   V86 pages to operate (such as the VDD video memory) should claim them
;   at Sys_Critical_Init. SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT
;   ALLOWED. Returning carry aborts device load only.
;
Sys_Critical_Init	EQU	0000h		; Devices required for virt mode
;
; Device init is where most devices do the bulk of their initialization.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Device_Init		EQU	0001h		; All other devices init
;
; Init_Complete is the final phase of device init called just before the
;   WIN386 INIT pages are released and the Instance snapshot is taken.
;   Devices which wish to search for a region of V86 pages >= A0h to use
;   should do it at Init_Complete.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Init_Complete		EQU	0002h		; All devices have initialized

;----------------- INITIALIZATION CODE AND DATA DISCARDED ---------------------

;
; Same as VM_Init, except for SYS VM.
;
Sys_VM_Init		EQU	0003h		; Execute the system VM (Win86)
;
; Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
;   exit this call is not made). SYS VM Simulate_Int, Exec_Int activity is
;   allowed.
;
Sys_VM_Terminate	EQU	0004h		; System VM terminted (exiting)

;------------------------------------------------------------------------------

;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE ENABLED. Instance snapshot has been restored.
;   SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
;
System_Exit		EQU	0005h		; Devices prepare to exit
;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE DISABLED. SYS VM Simulate_Int, Exec_Int ACTIVITY
;   IS NOT ALLOWED.
;
Sys_Critical_Exit	EQU	0006h		; System critical devices reset

;
; Create_VM creates a new VM. EBX = VM handle of new VM. Returning Carry will
;   fail the Create_VM.
;
Create_VM		EQU	0007h
;
; Second phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Critical_Init	EQU	0008h
;
; Third phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is allowed.
;
VM_Init 		EQU	0009h

;
; NORMAL (First phase) of Destroy_VM. EBX = VM Hanlde. This occurs on normal
;   termination of the VM. Call cannot be failed. VM Simulate_Int, Exec_Int
;   activity is allowed.
;
VM_Terminate		EQU	000Ah		; Still in VM -- About to die
;
; Second phase of Destroy_VM. EBX = VM Handle, EDX = Flags (see below). Note
;   that in the case of destroying a running VM, this is the first call made
;   (VM_Terminate call does not occur). Call cannot be failed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Not_Executeable	EQU	000Bh		; Most devices die (except VDD)
;
; Final phase of Destroy_VM. EBX = VM Handle. Note that considerable time
;   can elaps between the VM_Not_Executeable call and this call. Call cannot
;   be failed. VM Simulate_Int, Exec_Int activity is NOT allowed.
;
Destroy_VM		EQU	000Ch		; VM's control block about to go

;
;   Flags for VM_Not_Executeable control call (passed in EDX)
;
VNE_Crashed		EQU	0000000000000000000000001b
VNE_Crashed_Bit 	EQU	0		; VM was crashed
VNE_Nuked		EQU	0000000000000000000000010b
VNE_Nuked_Bit		EQU	1		; VM was destroyed while active
VNE_CreateFail		EQU	0000000000000000000000100b
VNE_CreateFail_Bit	EQU	2		; Some device failed Create_VM
VNE_CrInitFail		EQU	0000000000000000000001000b
VNE_CrInitFail_Bit	EQU	3		; Some device failed VM_Critical_Init
VNE_InitFail		EQU	0000000000000000000010000b
VNE_InitFail_Bit	EQU	4		; Some device failed VM_Init

;------------------------------------------------------------------------------

;
; EBX = VM Handle. Call cannot be failed.
;
VM_Suspend		EQU	000Dh		; VM not runnable until resume
;
; EBX = VM Handle. Returning carry fails and backs out the resume.
;
VM_Resume		EQU	000Eh		; VM is leaving suspended state

;------------------------------------------------------------------------------

;
; EBX = VM Handle to set device focus to. EDX = Device ID if device specific
;   setfocus. == 0 if device critical setfocus (all devices). THIS CALL CANNOT
;   BE FAILED.
;
;   NOTE: In case where EDX == 0, ESI is a FLAG word that indicates special
;	  functions. Currently Bit 0 being set indicates that this Device
;	  critical set focus is also "VM critical". It means that we do not
;	  want some other VM to take the focus from this app now. This is
;	  primarily used when doing a device critical set focus to Windows
;	  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
;	  currently has the Windows activation, set the activation to the
;	  Windows Shell, not back to the old app". ALSO in the case where
;	  Bit 0 is set, EDI = The VM handle of the VM that is "having trouble".
;	  Set this to 0 if there is no specific VM associated with the problem.
;
Set_Device_Focus	EQU	000Fh

;------------------------------------------------------------------------------

;
; EBX = VM Handle going into message mode. THIS CALL CANNOT BE FAILED.
;
Begin_Message_Mode	EQU	0010h
;
; EBX = VM Handle leaving message mode. THIS CALL CANNOT BE FAILED.
;
End_Message_Mode	EQU	0011h

;------------------------- SPECIAL CONTROL CALLS ------------------------------

;
; Request for reboot. Call cannot be failed.
;
Reboot_Processor	EQU	0012h		; Request a machine reboot
;
; Query_Destroy is an information call made by the SHELL device before an
;   attempt is made to initiate a destroy VM sequence on a running VM which
;   has not exited normally. EBX = VM Handle. Returning carry indicates that
;   a device "has a problem" with allowing this. THE DESTROY SEQUENCE CANNOT
;   BE ABORTED HOWEVER, this decision is up to the user. All this does is
;   indicate that there is a "problem" with allowing the destroy. The device
;   which returns carry should call the SHELL_Message service to post an
;   informational dialog about the reason for the problem.
;
Query_Destroy		EQU	0013h		; OK to destroy running VM?

;------------------------- DEBUGGING CONTROL CALL -----------------------------

;
; Special call for device specific DEBUG information display and activity.
;
Debug_Query		EQU	0014h

;---------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ----------------

;
;   About to run a protected mode application.
;   EBX = Current VM handle.
;   EDX = Flags
;   EDI -> Application Control Block
;   Returning with carry set fails the call.
;
Begin_PM_App		EQU	0015h

;
;   Flags for Begin_PM_App (passed in EDX)
;
BPA_32_Bit		EQU	00000001b
BPA_32_Bit_Flag 	EQU	1

;
;   Protected mode application is terminating.
;   EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
;   EDI -> Application Control Block
;
End_PM_App		EQU	0016h

EndDoc

BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services(it prepends
;   a "@" to the procedure name), DWORD aligns the procedure, takes care of
;   public declaration and does some calling verification for debug versions
;   of the software. EndProc is a macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;	PUBLIC				; Routine used outside this module
;	HIGH_FREQ			; DWORD align procedure
;	SERVICE 			; Routine is called via VxDCall
;	ASYNC_SERVICE			; Same as "SERVICE" plus routine can
;					;	be called under interrupt.
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, ASYNC_SERVICE
;
;	<code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc

BeginProc MACRO Name, P1, P2, P3, P4
	LOCAL	Profile_Data, Skip_Data

IF ?_RCODE

Process_Param MACRO P
IFNB <P>
IFIDNI <P>, <HIGH_FREQ>
Dword_Align
ELSE
IFIDNI <P>, <SERVICE>
??_SERVICE = 1
ELSE
IFIDNI <P>, <ASYNC_SERVICE>
??_ASYNC_SERVICE = 1
IF ?_LCODE
%OUT ERROR:  ASYNC_SERVICE's must be in LOCKED code
;;.err
ENDIF
ELSE
IFIDNI <P>, <NO_LOG>
??_NO_LOG = 1
ELSE
IFDIFI <P>, <PUBLIC>
%OUT ERROR:  Bad para "&P" to BeginProc
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM


??_SERVICE = 0
??_ASYNC_SERVICE = 0
??_NO_LOG = 0

Process_Param P1
Process_Param P2
Process_Param P3
Process_Param P4


IFE ??_SERVICE + ??_ASYNC_SERVICE

PUBLIC Name
Name PROC NEAR
IFDEF DEBUG
IFE ??_NO_LOG
IFNDEF VMMSYS
	VMMcall Log_Proc_Call
ENDIF
ENDIF
ENDIF

ELSE

IFDEF DEBUG
	jmp	SHORT Skip_Data
Profile_Data LABEL DWORD
	dd	0
Skip_Data:
ENDIF

PUBLIC @&Name
@&Name PROC NEAR

IFDEF DEBUG
IFE ??_NO_LOG
;;;;IFNDEF VMMSYS
	VMMcall Log_Proc_Call
;;;;ENDIF
ENDIF
	pushfd
	inc	[Profile_Data]
IFE ??_ASYNC_SERVICE
	VMMcall Test_Reenter
ENDIF
	popfd
ENDIF
ENDIF

ELSE
IFIDNI <P1>, <PUBLIC>
PUBLIC Name
ENDIF
Name PROC NEAR
ENDIF


	ENDM



EndProc MACRO Name
IFDEF @&Name
@&Name ENDP
ELSE
IFDEF Name
Name ENDP
ELSE
.ERR
%OUT EndProc for &Name does not match BeginProc
ENDIF
ENDIF
	ENDM


;******************************************************************************
;	       S C H E D U L E R   B O O S T   V A L U E S
;==============================================================================

Reserved_Low_Boost	EQU	00000000000000000000000000000001b
Cur_Run_VM_Boost	EQU	00000000000000000000000000000100b
Low_Pri_Device_Boost	EQU	00000000000000000000000000010000b
High_Pri_Device_Boost	EQU	00000000000000000001000000000000b
Critical_Section_Boost	EQU	00000000000100000000000000000000b
Time_Critical_Boost	EQU	00000000010000000000000000000000b
Reserved_High_Boost	EQU	01000000000000000000000000000000b


;******************************************************************************
;	 F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
;==============================================================================

PEF_Wait_For_STI	EQU	0000001b
PEF_Wait_For_STI_Bit	EQU	0
PEF_Wait_Not_Crit	EQU	0000010b
PEF_Wait_Not_Crit_Bit	EQU	1
PEF_Dont_Unboost	EQU	0000100b
PEF_Dont_Unboost_Bit	EQU	2
PEF_Always_Sched	EQU	0001000b
PEF_Always_Sched_Bit	EQU	3


;******************************************************************************
;	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N
;		       A N D   W A I T _ S E M A P H O R E
;==============================================================================

Block_Svc_Ints			EQU	0000001b
Block_Svc_Ints_Bit		EQU	0
Block_Svc_If_Ints_Locked	EQU	0000010b
Block_Svc_If_Ints_Locked_Bit	EQU	1
Block_Enable_Ints		EQU	0000100b
Block_Enable_Ints_Bit		EQU	2



BeginDoc
;******************************************************************************
; The following structures are pointed to by EBP when VxD routines are entered,
;   both for VxD control calls and traps(I/O traps, software INT traps, etc.).
;   The first structure as DWORD values, the second WORD values and the last
;   has BYTE values.
;
Client_Reg_Struc   struc
Client_EDI	dd	?		; Client's EDI
Client_ESI	dd	?		; Client's ESI
Client_EBP	dd	?		; Client's EBP
		dd	?		; ESP at pushall
Client_EBX	dd	?		; Client's EBX
Client_EDX	dd	?		; Client's EDX
Client_ECX	dd	?		; Client's ECX
Client_EAX	dd	?		; Client's EAX
Client_Error	dd	?		; Dword error code
Client_EIP	dd	?		; EIP
Client_CS	dw	?		; CS
		dw	?		;   (padding)
Client_EFlags	dd	?		; EFLAGS
Client_ESP	dd	?		; ESP
Client_SS	dw	?		; SS
		dw	?		;   (padding)
Client_ES	dw	?		; ES
		dw	?		;   (padding)
Client_DS	dw	?		; DS
		dw	?		;   (padding)
Client_FS	dw	?		; FS
		dw	?		;   (padding)
Client_GS	dw	?		; GS
		dw	?		;   (padding)
Client_Alt_EIP	dd	?
Client_Alt_CS	dw	?
		dw	?
Client_Alt_EFlags  dd	?
Client_Alt_ESP	dd	?
Client_Alt_SS	dw	?
		dw	?
Client_Alt_ES	dw	?
		dw	?
Client_Alt_DS	dw	?
		dw	?
Client_Alt_FS	dw	?
		dw	?
Client_Alt_GS	dw	?
		dw	?
Client_Reg_Struc   ends


Client_Word_Reg_Struc	struc
Client_DI	dw	?		; Client's DI
		dw	?		;   (padding)
Client_SI	dw	?		; Client's SI
		dw	?		;   (padding)
Client_BP	dw	?		; Client's BP
		dw	?		;   (padding)
		dd	?		; ESP at pushall
Client_BX	dw	?		; Client's BX
		dw	?		;   (padding)
Client_DX	dw	?		; Client's DX
		dw	?		;   (padding)
Client_CX	dw	?		; Client's CX
		dw	?		;   (padding)
Client_AX	dw	?		; Client's AX
		dw	?		;   (padding)
		dd	?		; Dword error code
Client_IP	dw	?		; Client's IP
		dw	?		;   (padding)
		dd	?		; CS
Client_Flags	dw	?		; Client's flags (low)
		dw	?		;   (padding)
Client_SP	dw	?		; SP
		dw	?
		dd	5 dup (?)
Client_Alt_IP	dw	?
		dw	?
		dd	?
Client_Alt_Flags    dw	?
		dw	?
Client_Alt_SP	dw	?
Client_Word_Reg_Struc	ends



Client_Byte_Reg_Struc	struc
		dd	4 dup (?)	; EDI, ESI, EBP, ESP at pushall
Client_BL	db	?		; Client's BL
Client_BH	db	?		; Client's BH
		dw	?		;   (padding)
Client_DL	db	?		; Client's DL
Client_DH	db	?		; Client's DH
		dw	?		;   (padding)
Client_CL	db	?		; Client's CL
Client_CH	db	?		; Client's CH
		dw	?		;   (padding)
Client_AL	db	?		; Client's AL
Client_AH	db	?		; Client's AH
Client_Byte_Reg_Struc	ends

;==============================================================================
EndDoc

.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX



PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
	IFNB <Param>
	push	Param
	ENDIF
	ENDM
	ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
	ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
	add	esp, Count*4
ENDIF
ENDIF
	ENDM



Dyna_Link_Int	EQU 20h

;
;
BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints		; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request	; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;	defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
EndDoc
VxDcall MACRO P, Param
	PushCParams Param
	int	Dyna_Link_Int
	dd	P
	ClearCParams 0, Param
	ENDM

VxDjmp	MACRO P, Param
IFNB <Param>
%OUT ERROR:  Parameters may not be passed to VxDjmp or VMMjmp macros
.ERR
ENDIF
	int	Dyna_Link_Int
IFDEF DEBUG
	dd	P
	ret
ELSE
	dd	P OR DL_Jmp_Mask
ENDIF
	ENDM

DL_Jmp_Mask	EQU	8000h
DL_Jmp_Bit	EQU	0Fh


VMMcall MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDcall <P>, <Param>
	ENDM

VMMjmp MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDjmp <P>, <Param>
	ENDM

cCall MACRO P, Param
	PushCParams Param
	call	P
	ClearCParams 0, Param
	ENDM


BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;	segments used by the device driver. They are:
;VxD_ICODE_SEG	 defines start of initialization code segment
;VxD_ICODE_ENDS  defines end of initialization code segment
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;==============================================================================
EndDoc


;   Protected mode code
VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_LCODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_LTEXT	 ENDS
		ENDM



;   Protected mode initialization code
VxD_ICODE_SEG	MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_ICODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_ICODE_ENDS	MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_ITEXT	ENDS
		ENDM


;   Protected mode data
VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>



VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
	ALIGN 4
ENDIF
		ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
		ENDM




;   Protected mode initialization data
VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
		ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
		ENDM

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_RCODE
		  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_RCODE ENDS
		   ENDM

ENDIF

DDK_Version equ 300h

VxD_Desc_Block STRUC
DDB_Next		dd  ?			; VMM RESERVED FIELD
DDB_SDK_Version 	dw  DDK_Version 	; VMM RESERVED FIELD
DDB_Req_Device_Number	dw  Undefined_Device_ID ; Required device number
DDB_Dev_Major_Version	db  0			; Major device number
DDB_Dev_Minor_Version	db  0			; Minor device number
DDB_Flags		dw  0			; Flags for init calls complete
DDB_Name		db  "        "		; Device name
DDB_Init_Order		dd  Undefined_Init_Order; Initialization Order
DDB_Control_Proc	dd  ?			; Offset of control procedure
DDB_V86_API_Proc	dd  0			; Offset of API procedure (or 0)
DDB_PM_API_Proc 	dd  0			; Offset of API procedure (or 0)
DDB_V86_API_CSIP	dd  0			; CS:IP of API entry point
DDB_PM_API_CSIP 	dd  0			; CS:IP of API entry point
DDB_Reference_Data	dd  ?			; Reference data from real mode
DDB_Service_Table_Ptr	dd  0			; Pointer to service table
DDB_Service_Table_Size	dd  0			; Number of services
VxD_Desc_Block ENDS


IFNDEF Not_VxD

; flag values for DDB_Flags

DDB_Sys_Crit_Init_Done	    EQU 00000001b
DDB_Sys_Crit_Init_Done_Bit  EQU        0
DDB_Device_Init_Done	    EQU 00000010b
DDB_Device_Init_Done_Bit    EQU       1

BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc
	LOCAL	V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len

dev_id_err MACRO
%OUT Device ID required when providing services
.ERR
	ENDM

IFB <V86_Proc>
	V86_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF
IFB <PM_Proc>
	PM_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF
IFDEF Name&_Service_Table
IFB <Device_Num>
	dev_id_err
ELSE
IFE Device_Num - Undefined_Device_ID
	dev_id_err
ENDIF
ENDIF
	Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
	Serv_Tab_Len	EQU Num_&Name&_Services
ELSE
	Serv_Tab_Offset EQU 0
	Serv_Tab_Len	EQU 0
ENDIF


VxD_LOCKED_DATA_SEG
PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
			 OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
			 ,,,Serv_Tab_Offset, Serv_Tab_Len>
VxD_LOCKED_DATA_ENDS
	ENDM


BeginDoc
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;	 then it is the programmer's responsibility for declaring a procedure
;	 in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;	 any messages not processed.  The advantage in using
;	 Begin_Control_Dispatch is when a large # of messages are processed by
;	 a device, because a jump table is built which will usually require
;	 less code space then the compares and jumps that are done when
;	 Control_Dispatch is used alone.
;
;==============================================================================
EndDoc
Begin_Control_Dispatch MACRO VxD_Name
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control
ENDM

End_Control_Dispatch   MACRO VxD_Name
	LOCAL ignore, table

jmpproc MACRO num
	jmp	??_cd_&&num
ENDM

procoff MACRO num
IFDEF ??_cd_&&num
	dd	OFFSET32 ??_cd_&&num
ELSE
	dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
	cmp	eax, ??_cd_low
	jne	short ignore
	jmpproc %(??_cd_low)
ignore:
	clc
	ret
ELSE
	cmp	eax, ??_cd_high
	ja	short ignore
	sub	eax, ??_cd_low
	jb	short ignore
	jmp	cs:[eax*4+table]
ignore:
	clc
	ret

table label dword
	REPT   ??_cd_high - ??_cd_low + 1
	procoff %(??_cd_low)
	??_cd_low = ??_cd_low + 1
	ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE jmpproc
PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;	passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;	 End_Control_Dispatch to create a jump table for dispatching messages,
;	 when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure
	LOCAL Skip_Interseg_Jump

IFE ?_lcode
IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
	cmp	eax, Service
	jne	SHORT Skip_Interseg_Jump
	jmp	Procedure
Skip_Interseg_Jump:
ENDIF
ELSE
%OUT ERROR:  The Control proc should be in LOCKED code.
%OUT	     Control_Dispatch can only be used inside of VxD_LOCKED_CODE_SEG.
.err
ENDIF
	ENDM


BeginDoc
;******************************************************************************
; The following are the definitions for the "type of I/O" parameter passed
;   to a I/O trap routine
Byte_Input	EQU	000h
Byte_Output	EQU	004h
Word_Input	EQU	008h
Word_Output	EQU	00Ch
Dword_Input	EQU	010h
Dword_Output	EQU	014h

Output		EQU	0000000000000100b
Output_Bit	EQU	2
Word_IO 	EQU	0000000000001000b
Word_IO_Bit	EQU	3
Dword_IO	EQU	0000000000010000b
Dword_IO_Bit	EQU	4

String_IO	EQU	00000020h
String_IO_Bit	EQU	5
Rep_IO		EQU	00000040h
Rep_IO_Bit	EQU	6
Addr_32_IO	EQU	00000080h
Addr_32_IO_Bit	EQU	7
Reverse_IO	EQU	00000100h
Reverse_IO_Bit	EQU	8

IO_Seg_Mask	EQU	0FFFF0000h		; Use these bits to get segment
IO_Seg_Shift	EQU	10h			; Must shift right this many

;==============================================================================
EndDoc

BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
	je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
	jb	In_Proc
ELSE
	je	Out_Proc
	jmp	In_Proc
ENDIF
ENDIF
	ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
	ENDM


VxD_IOT_Hdr STRUC
VxD_IO_Ports	dw  ?
VxD_IOT_Hdr ENDS

VxD_IO_Struc STRUC
VxD_IO_Port	dw  ?
VxD_IO_Proc	dd  ?
VxD_IO_Struc ENDS


BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
.ERRNZ SIZE VxD_IOT_Hdr - 2	; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD
IF2
IFNDEF Table_Name&_Entries
%OUT ERROR:  No End_VxD_IO_Table for &Table_Name
.ERR
ENDIF
	dw	Table_Name&_Entries
ELSE
	dw	?
ENDIF

	ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
	dw	Port
	dd	OFFSET32 Proc_Name
	ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
%OUT ERROR:  No Begin_VxD_IO_Table for &Table_Name
.ERR
ELSE
	Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
%OUT ERROR:  Invalid number of port traps in &Table_Name
.ERR
ENDIF
ENDIF
	    ENDM


;******************************************************************************
;******************************************************************************

Push_Client_State MACRO
	sub	esp, SIZE Client_Reg_Struc
	push	edi
	lea	edi, [esp+4]
	VMMcall Save_Client_State
	pop	edi
	ENDM

Pop_Client_State MACRO
	push	esi
	lea	esi, [esp+4]
	VMMcall Restore_Client_State
	pop	esi
	add	esp, SIZE Client_Reg_Struc
	ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	       If compiled with debugging then this will generate a call
;	       followed by a return.  If non-debugging version then the
;	       specified label will be jumped to.
;
;   PARAMETERS:
;	Label_Name = Procedure to be called
;
;   EXIT:
;	Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
	call	P2
ELSE
	call	P1
ENDIF
	ret
ELSE
	jmp	P1 P2
ENDIF
	ENDM


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off

IFDIFI <Reg_32>, <EAX>
	push	eax
ENDIF
IFB <Cli_Off>
	mov	ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
	mov	ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
	VMMcall Map_Flat

IFDIFI <Reg_32>, <EAX>
	mov	Reg_32, eax
	pop	eax
ENDIF

	ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
	push	DWORD PTR Int_Number
	VMMcall Exec_VxD_Int
	ENDM


ENDIF	; Not_VxD


BeginDoc
;******************************************************************************
;
;   The following equates are for flags sent to the real mode
;   initialization portion of a device driver:
;
Duplicate_Device_ID	    equ 0000000000000001b   ; duplicate device ID already
Duplicate_Device_ID_Bit     equ 	       0    ; loaded
Duplicate_From_INT2F	    equ 0000000000000010b   ; duplicate device ID already
Duplicate_From_INT2F_Bit    equ 	      1     ; loaded as part of INT 2F
						    ; device list
Loading_From_INT2F	    equ 0000000000000100b   ; this device was specified
Loading_From_INT2F_Bit	    equ 	     2	    ; in the INT 2F device list

EndDoc

BeginDoc
;******************************************************************************
;
;   The following equates are used to indicate the result of the real mode
;   initialization portion of a device driver:
;

Device_Load_Ok	    equ 0		; protected mode portion of device
					; should be loaded
Abort_Device_Load   equ 1		; don't load any protected mode portion
					; of this device, but continue loading
					; the rest of the devices
Abort_Win386_Load   equ 2		; fatal-error: abort the load of Win386

No_Fail_Message     equ 8000h		; The high bit is set in the return
No_Fail_Message_Bit equ 15		; code, if the loader should not print
					; any message for results
					; Abort_Device_Load or Abort_Win386_Load
;==============================================================================
EndDoc


;==============================================================================

; CR0 bit assignments
PE_Mask 	EQU	0001h	; 1 = Protected Mode
PE_Bit		EQU	0
MP_Mask 	EQU	0002h	; 1 = Monitor Coprocessor
MP_Bit		EQU	1
EM_Mask 	EQU	0004h	; 1 = Emulate Math Coprocessor
EM_Bit		EQU	2
TS_Mask 	EQU	0008h	; 1 = Task Switch occured
TS_Bit		EQU	3
ET_Mask 	EQU	0010h	; 1 = 387 present, 0 = 287 present
ET_Bit		EQU	4
PG_Mask 	EQU 80000000h	; 1 = paging enabled, 0 = paging disabled
PG_Bit		EQU	31

; EFLAGs bit assignments
CF_Mask 	EQU	000000000000000001b	; Carry flag
CF_Bit		EQU	0
PF_Mask 	EQU	000000000000000100b	; Parity flag
PF_Bit		EQU	2
AF_Mask 	EQU	000000000000010000b	; Aux flag
AF_Bit		EQU	4
ZF_Mask 	EQU	000000000001000000b	; Zero flag
ZF_Bit		EQU	6
SF_Mask 	EQU	000000000010000000b	; Sign flag
SF_Bit		EQU	7
TF_Mask 	EQU	000000000100000000b	; Trace flag
TF_Bit		EQU	8
IF_Mask 	EQU	000000001000000000b	; Int flag
IF_Bit		EQU	9
DF_Mask 	EQU	000000010000000000b	; Direction flag
DB_Bit		EQU	10
OF_Mask 	EQU	000000100000000000b	; Overflow flag
OF_Bit		EQU	11
IOPL_Mask	EQU	000011000000000000b	; IOPL flags
IOPL_Bit0	EQU	12
IOPL_Bit1	EQU	13
NT_Mask 	EQU	000100000000000000b	; Nested task flag
NT_Bit		EQU	14
RF_Mask 	EQU	010000000000000000b	; Resume flag
RF_Bit		EQU	16
VM_Mask 	EQU	100000000000000000b	; Virtual Mode flag
VM_Bit		EQU	17


;------------------------------------------------------------------------------
;
;	  Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>


;******************************************************************************
; PAGE TABLE EQUATES
;******************************************************************************


P_SIZE		equ	1000h		; page size

; ---------------------------------------------------
;
;	Page table entry bits
;
; ---------------------------------------------------

P_PRES		equ	01h		; page present bit
P_WRITE 	equ	02h		; write access bit
P_USER		equ	04h		; access bit for User mode
P_ACC		equ	20h		; page accessed bit
P_DIRTY 	equ	40h		; page dirty bit

P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER) ; avail to everyone & present

; ---------------------------------------------------
;
;  Page types - definition of the OS reserved bits in the page table
;		entry.
; ---------------------------------------------------

PG_TYPE 	equ	0E00h		; TYPE bits in PTE

; ---------------------------------------------------
;
;	 Page types for page allocator calls
;
; ---------------------------------------------------
PG_VM		equ	0
PG_SYS		equ	1
PG_RESERVED1	equ	2
PG_PRIVATE	equ	3
PG_RESERVED2	equ	4
PG_RELOCK	equ	5		; PRIVATE to MMGR
PG_INSTANCE	equ	6
PG_HOOKED	equ	7
PG_IGNORE	equ	0FFFFFFFFh


; ---------------------------------------------------
;
;	 Types for page table entries
;
; ---------------------------------------------------
PgT_VM		equ	PG_VM SHL 9
PgT_SYS 	equ	PG_SYS SHL 9
PgT_RESERVED1	equ	PG_RESERVED1 SHL 9
PgT_PRIVATE	equ	PG_PRIVATE SHL 9
PgT_RESERVED2	equ	PG_RESERVED2 SHL 9
PgT_RELOCK	equ	PG_RELOCK SHL 9
PgT_INSTANCE	equ	PG_INSTANCE SHL 9
PgT_HOOKED	equ	PG_HOOKED SHL 9



;******************************************************************************

; ---------------------------------------------------
;
; Definitions for the access byte in a descriptor
;
; ---------------------------------------------------


; Following fields are common to segment and control descriptors

D_PRES		equ	080h		; present in memory
D_NOTPRES	equ	0		; not present in memory

D_DPL0		equ	0		; Ring 0
D_DPL1		equ	020h		; Ring 1
D_DPL2		equ	040h		; Ring 2
D_DPL3		equ	060h		; Ring 3

D_SEG		equ	010h		; Segment descriptor
D_CTRL		equ	0		; Control descriptor

D_GRAN_BYTE	equ	000h		; Segment length is byte granular
D_GRAN_PAGE	equ	080h		; Segment length is page granular
D_DEF16 	equ	000h		; Default operation size is 16 bits
D_DEF32 	equ	040h		; Default operation size is 32 bits


; Following fields are specific to segment descriptors

D_CODE		equ	08h		; code
D_DATA		equ	0		; data

D_RX		equ	02h		; if code, readable
D_X		equ	0		; if code, exec only
D_W		equ	02h		; if data, writable
D_R		equ	0		; if data, read only

D_ACCESSED	equ	1		; segment accessed bit


; Useful combination access rights bytes

RW_Data_Type equ (D_PRES+D_SEG+D_DATA+D_W)
R_Data_Type  equ (D_PRES+D_SEG+D_DATA+D_R)
Code_Type    equ (D_PRES+D_SEG+D_CODE+D_RX)

D_PAGE32	equ	(D_GRAN_PAGE+D_DEF32)		  ; 32 bit Page granular

; Masks for selector fields

SELECTOR_MASK	equ	0fff8h		; selector index
SEL_LOW_MASK	equ	0f8h		; mask for low byte of sel indx
TABLE_MASK	equ	04h		; table bit
RPL_MASK	equ	03h		; privilige bits
RPL_CLR 	equ	not 03h 	; clear ring bits
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\alloc.asm ===
TITLE ALLOC.ASM - memory arena manager	NAME Alloc

;**
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	Memory related system calls and low level routines for MSDOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$ALLOC
;	$SETBLOCK
;	$DEALLOC
;	$AllocOper
;	arena_free_process
;	arena_next
;	check_signature
;	Coalesce
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	    Revision: M000 - added support for allocing UMBs. 7/9/90
;		      M003 - added support for link/unlink UMBs from
;			     DOS arena chain. 7/18/90
;		      M009 - Added error returns invalid function and 
;			     arena trashed in set link state call.
;		      M010 - Release UMB arenas allocated to current PDB
;			     if UMB_HEAD is initialized.
;
;		      M016 - MACE utilities mkeyrate.com version 1.0 
;			     support. Please see under M009 in 
;			     ..\inc\dossym.inc. 8/31/90.
;
;		      M061 - In GetLastArena, if linking in UMBs check to make
;			     sure that umb_head arena is valid and also make
;			     sure that the previous arena is pointing to 
;			     umb_head.
;
;		      M064 - allow HIGH_ONLY bit to be set by a call to 
;			     set allloc strategy.
;			     use STRAT_MASK to mask out bits 6 & 7 of 
;			     bx in AllocSetStrat.
;
;		      M068 - use a count value (A20OFF_COUNT) rather than
;			     a bit to indicate to dos dispatcher to turn
;			     a20 off before iret. See M016.
;
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include arena.inc

	.cref
	.list

	BREAK	<memory allocation utility routines>

	i_need  arena_head,WORD         ; seg address of start of arena
	i_need  CurrentPDB,WORD         ; current process data block addr
	i_need  FirstArena,WORD         ; first free block found
	i_need  BestArena,WORD          ; best free block found
	i_need  LastArena,WORD          ; last free block found
	i_need  AllocMethod,BYTE        ; how to alloc first(best)last
	I_need  EXTERR_LOCUS,BYTE       ; Extended Error Locus


	I_need	umb_head,WORD		; seg address of start of umb arenas
	I_need	start_arena,WORD	; seg address of arena from which to 
					; start alloc scan
	I_need 	umbflag,BYTE		; bit 0 indicates link state

	I_need  A20OFF_COUNT,BYTE	; M016, M068
	I_need	DOS_FLAG, BYTE		; M068

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

	BREAK	<Arena_Free_Process - Free a processes memory>


;**	Arena_Free_Process
;
;	Free all arena blocks allocated to a pricess
;
;	ENTRY	(bx) = PID of process
;	EXIT	none
;	USES	????? BUGBUG

procedure   arena_free_process,NEAR

	MOV     AX,[arena_head]

arena_free_process_start:
	MOV     DI,arena_signature
	CALL    Check_Signature         ; ES <- AX, check for valid block

arena_free_process_loop:
	jc	ret_label		; return if carry set

	PUSH    ES
	POP     DS
	CMP     DS:[arena_owner],BX     ; is block owned by pid?
	JNZ     arena_free_next         ; no, skip to next
	MOV     DS:[arena_owner],DI     ; yes... free him

arena_free_next:
	CMP     BYTE PTR DS:[DI],arena_signature_end
					; end of road, Jack?

	jz	arena_chk_umbs		; M010: let's check umb arenas

	CALL    arena_next              ; next item in ES/AX carry set if trash
	JMP     arena_free_process_loop

arena_chk_umbs:				; M010 - Start
	mov	ax, [umb_head]		; ax = umb_head
	cmp	ax, 0ffffh		; Q: is umb_head initialized
	je	ret_label		; N: we're done

	mov	di, ds			; di = last arena
	cmp	di, ax			; Q: is last arena above umb_head
	jae	ret_label		; Y: we've scanned umbs also. done.
	jmp	short arena_free_process_start
					; M010 - End

EndProc arena_free_process

	BREAK	<Arena Helper Routines>

;**	Arena_Next - Find Next item in Arena
;
;	ENTRY	DS - pointer to block head
;		(di) = 0
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged

procedure   arena_next,NEAR

	MOV     AX,DS                   ; AX <- current block
	ADD     AX,DS:[arena_size]      ; AX <- AX + current block length
	INC     AX                      ; remember that header!

;       fall into check_signature and return
;
;       CALL    check_signature         ; ES <- AX, carry set if error
;       RET
;	BUGBUG - put fallthru here

EndProc arena_next




;**	Check_Signature - Check Memory Block Signature
;
;	ENTRY	(AX) = address of block header
;		(di) = 0
;	EXIT	 ES = AX
;		'C' clear if signature good
;		'C' set if signature bad
;	USES	ES, Flags

;align	2		BUGBUG - put me in
procedure   check_signature,NEAR

	MOV     ES,AX                   ; ES <- AX
	CMP     BYTE PTR ES:[DI],arena_signature_normal
					; IF next signature = not_end THEN
	jz	ret_label		;   GOTO OK (ret if Z)

	CMP     BYTE PTR ES:[DI],arena_signature_end
					; IF next signature = end then
	jz	ret_label		;   GOTO ok (ret if Z)
	STC                             ; set error

ret_label:
	return

EndProc Check_signature



;**	Coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	ENTRY	(ds) = pointer to the head of a free block
;		(di) = 0
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	(cx)

procedure   Coalesce,NEAR

	CMP     BYTE PTR DS:[DI],arena_signature_end
					; IF current signature = END THEN
	retz                            ;   GOTO ok
	CALL    arena_next              ; ES, AX <- next block, Carry set if error
	retc                            ; IF no error THEN GOTO check

coalesce_check:
	CMP     ES:[arena_owner],DI
	retnz                           ; IF next block isnt free THEN return
	MOV     CX,ES:[arena_size]      ; CX <- next block size
	INC     CX                      ; CX <- CX + 1 (for header size)
	ADD     DS:[arena_size],CX      ; current size <- current size + CX
	MOV     CL,ES:[DI]              ; move up signature
	MOV     DS:[DI],CL
	JMP     coalesce                ; try again

EndProc Coalesce

	BREAK  <$Alloc - allocate space in memory>

;**	$Alloc - Allocate Memory Space
;
;	$Alloc services the INT21 that allocates memory space to a program.
;	Alloc returns	a  pointer  to	a  free  block of
;       memory that has the requested  size  in  paragraphs.
;
;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
;	scanned from umb_head if not from arena_head. If the strategy is
; 	HIGH_FIRST the scan is continued from arena_head if a block of 
;	appropriate size is not found in the UMBs. If the strategy is 
;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
;
;	In either case if bit 0 of UmbFlag is not initialized then the scan
;	starts from arena_head.
;
;	Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;
;	BUGBUG - a lot can be done to improve performance.  We can set marks
;	so that we start searching the arena at it's first non-trivial free
;	block, we can peephole the code, etc.  (We can move some subr calls
;	inline, etc.)  I assume that this is called rarely and that the arena
;	doesn't have too many memory objects in it beyond the first free one.
;	verify that this is true; if so, this can stay as is
;
;	ENTRY	(bx) = requested size, in bytes
;		(DS) = (ES) = DOSGROUP
;	EXIT	'C' clear if memory allocated
;		  (ax:0) = address of requested memory
;		'C' set if request failed
;		  (AX) = error_not_enough_memory
;		    (bx) = max size we could have allocated
;		  (ax) = error_arena_trashed
;	USES	All

procedure   $ALLOC,NEAR

	EnterCrit   critMem

					; M000 - start
	mov	ax, [arena_head]
	mov	[start_arena], ax	; assume LOW_FIRST
				
	test	byte ptr [AllocMethod], HIGH_FIRST+HIGH_ONLY
					; Q: should we start scanning from 
					;    UMB's
	jz	norm_alloc		; N: scan from arena_head

;	cmp	[umb_head], -1		; Q: Has umb_head been initialized
;	je	norm_alloc		; N: scan from arena_head
	test	[UmbFlag], LINKSTATE	; Q: are umb's linked
	jz	norm_alloc		; N: scan from arena_head

	mov	ax, [umb_head]
	mov	[start_arena], ax	; start_arena = umb_head
	
					; M000 - end

norm_alloc:

	XOR     AX,AX
	MOV     DI,AX

					; SS override for next First/Best/Last 
					; Arena
	MOV     [FirstArena],AX         ; init the options
	MOV     [BestArena],AX
	MOV     [LastArena],AX

	PUSH    AX                      ; alloc_max <- 0

start_scan:
	MOV     AX,[start_arena]        ; M000: AX <- beginning of arena
;	MOV     AX,[arena_head]         ; M000: AX <- beginning of arena


	CALL    Check_signature         ; ES <- AX, carry set if error
	JC      alloc_err               ; IF error THEN GOTO err

alloc_scan:
	PUSH    ES
	POP     DS                      ; DS <- ES
	CMP     DS:[arena_owner],DI
	JZ      alloc_free              ; IF current block is free THEN examine

alloc_next:
					; M000 - start 

	test	[UmbFlag], LINKSTATE	; Q: are umb's linked
	jz	norm_strat		; N: see if we reached last arena

	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is alloc strategy high_first
	jz	norm_strat		; N: see if we reached last arena
	mov	ax, [start_arena]
	cmp	ax, [arena_head]	; Q: did we start scan from 
					;    arena_head
	jne	norm_strat		; N: see if we reached last arena
	mov	ax, ds			; ax = current block
	cmp	ax, [umb_head]		; Q: check against umb_head 
	jmp	short alloc_chk_end
	
norm_strat:				; M000 - end
					; check against last sig '5A'
	CMP     BYTE PTR DS:[DI],arena_signature_end

alloc_chk_end:				; M000
					; IF current block is last THEN
	JZ      alloc_end               ;   GOTO end
	CALL    arena_next              ; AX, ES <- next block, Carry set if error
	JNC     alloc_scan              ; IF no error THEN GOTO scan

alloc_err:
	POP     AX

alloc_trashed:
	LeaveCrit   critMem
	error   error_arena_trashed

alloc_end:
	CMP     [FirstArena],0
	LJNZ    alloc_do_split
					; M000 - start
	mov	ax, [arena_head]
	cmp	ax, [start_arena]	; Q: started scanning from arena_head
	je	alloc_fail		; Y: not enough memory
					; N:
					; Q: is the alloc strat HIGH_ONLY
	test 	byte ptr [AllocMethod], HIGH_ONLY
	jnz	alloc_fail		; Y: return size of largest UMB

	mov	[start_arena], ax	; N: start scanning from arena_head
	jmp	short start_scan
					; M000 - end
					
alloc_fail:
	invoke  get_user_stack
	POP     BX
	MOV     [SI].user_BX,BX
	LeaveCrit   critMem
	error   error_not_enough_memory

alloc_free:
	CALL    coalesce                ; add following free block to current
	JC      alloc_err               ; IF error THEN GOTO err
	MOV     CX,DS:[arena_size]

	POP     DX                      ; check for max found size
	CMP     CX,DX
	JNA     alloc_test
	MOV     DX,CX

alloc_test:
	PUSH    DX
	CMP     BX,CX                   ; IF BX > size of current block THEN
	JA      alloc_next              ;   GOTO next
	CMP     [FirstArena],0
	JNZ     alloc_best
	MOV     [FirstArena],DS         ; save first one found
alloc_best:
	CMP     [BestArena],0
	JZ      alloc_make_best         ; initial best
	PUSH    ES
	MOV     ES,[BestArena]
	CMP     ES:[arena_size],CX      ; is size of best larger than found?
	POP     ES
	JBE     alloc_last
alloc_make_best:
	MOV     [BestArena],DS          ; assign best
alloc_last:
	MOV     [LastArena],DS          ; assign last
	JMP     alloc_next

;
; split the block high
;
alloc_do_split_high:
	MOV     DS,[LastArena]
	MOV     CX,DS:[arena_size]
	SUB     CX,BX
	MOV     DX,DS
	JE      alloc_set_owner         ; sizes are equal, no split
	ADD     DX,CX                   ; point to next block
	MOV     ES,DX                   ; no decrement!
	DEC     CX
	XCHG    BX,CX                   ; bx has size of lower block
	JMP     short alloc_set_sizes   ; cx has upper (requested) size

;
; we have scanned memory and have found all appropriate blocks
; check for the type of allocation desired; first and best are identical
; last must be split high
;
alloc_do_split:
					; M000 - start
	xor	cx, cx
	mov	cl, byte ptr [AllocMethod]
	and	cx, STRAT_MASK		; mask off bit 7
	cmp	cx, BEST_FIT		; Q; is the alloc strategy best_fit

;	CMP     BYTE PTR [AllocMethod], BEST_FIT
					; M000 - end	

					; Q: is the alloc strategy best_fit
	JA      alloc_do_split_high	; N: it is last fit
	MOV     DS,[FirstArena]		; assume first_fit
	JB      alloc_get_size		; it is first_fit
	MOV     DS,[BestArena]		; it is last_fit
alloc_get_size:
	MOV     CX,DS:[arena_size]
	SUB     CX,BX                   ; get room left over
	MOV     AX,DS
	MOV     DX,AX                   ; save for owner setting
	JE      alloc_set_owner         ; IF BX = size THEN (don't split)
	ADD     AX,BX
	INC     AX                      ; remember the header
	MOV     ES,AX                   ; ES <- DS + BX (new header location)
	DEC     CX                      ; CX <- size of split block
alloc_set_sizes:
	MOV     DS:[arena_size],BX      ; current size <- BX
	MOV     ES:[arena_size],CX      ; split size <- CX
	MOV     BL,arena_signature_normal
	XCHG    BL,DS:[DI]              ; current signature <- 4D
	MOV     ES:[DI],BL              ; new block sig <- old block sig
	MOV     ES:[arena_owner],DI

alloc_set_owner:
	MOV     DS,DX

					
	MOV     AX,[CurrentPDB]		; SS override
	MOV     DS:[arena_owner],AX
	MOV     AX,DS
	INC     AX
	POP     BX
	LeaveCrit   critMem
	transfer    SYS_RET_OK

EndProc $alloc

	BREAK $SETBLOCK - change size of an allocated block (if possible)

;**	$SETBLOCK - Change size of an Alocated Block
;
;	Setblock changes the size of an allocated block.  First, we coalesce
;	any following free space onto this block; then we try to trim the
;	block down to the size requested.
;
;	Note that if the guy wants to grow the block but that growth fails,
;	we still go ahead and coalesce any trailing free blocks onto it.
;	Thus the maximum-size-possible value that we return has already
;	been allocated!  This is a bug, dare we fix it?  BUGBUG
;
;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
;		finish it's work.  FOr this reason we build the allocsf
;		structure on the frame, to make us compatible with $ALLOCs
;		code.
;
;	ENTRY	(es) = segment of old block
;		(bx) = newsize
;		(ah) = SETBLOCK
;
;	EXIT	'C' clear if OK
;		'C' set if error
;		  (ax) = error_invalid_block
;		       = error_arena_trashed
;		       = error_not_enough_memory
;		       = error_invalid_function
;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
;	USES	???? BUGBUG

procedure   $SETBLOCK,NEAR

	EnterCrit   critMem
	MOV     DI,arena_signature
	MOV     AX,ES
	DEC     AX
	CALL    check_signature
	JNC     setblock_grab

setblock_bad:
	JMP     alloc_trashed

setblock_grab:
	MOV     DS,AX
	CALL    coalesce
	JC      setblock_bad
	MOV     CX,DS:[arena_size]
	PUSH    CX
	CMP     BX,CX
	JBE     alloc_get_size
	JMP     alloc_fail

EndProc $setblock

	BREAK $DEALLOC - free previously allocated piece of memory

;**	$DEALLOC - Free Heap Memory
;
;	ENTRY	(es) = address of item
;
;	EXIT	'C' clear of OK
;		'C' set if error
;		  (AX) = error_invalid_block
;	USES	???? BUGBUG

procedure   $DEALLOC,NEAR

	EnterCrit   critMem

					; M016, M068 - Start
	test	[DOS_FLAG], EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	jz	@f			; N: continue
	cmp	[A20OFF_COUNT], 0	; Q: is count 0
	jne	@f			; N: continue
	mov	[A20OFF_COUNT], 1	; Y: set count to 1
@@:					; M016, M068 - End
	

	MOV     DI,arena_signature
	MOV     AX,ES
	DEC     AX
	CALL    check_signature
	JC      dealloc_err
	MOV     ES:[arena_owner],DI
	LeaveCrit   critMem
	transfer    SYS_RET_OK

dealloc_err:
	LeaveCrit   critMem
	error   error_invalid_block

EndProc $DEALLOC

	BREAK $AllocOper - get/set allocation mechanism

;**	$AllocOper - Get/Set Allocation Mechanism
;
;	Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;	ENTRY	
;		(al) = 0
;		  Get allocation Strategy in (ax)
;
;		(al) = 1, (bx) = method = zw0000xy
;		  Set allocation strategy.
;		   w  = 1  => HIGH_ONLY
;		   z  = 1  => HIGH_FIRST
;		   xy = 00 => FIRST_FIT
;		      = 01 => BEST_FIT
;		      = 10 => LAST_FIT
;
;		(al) = 2
;		  Get UMB link state in (al)
;
;		(al) = 3
;		  Set UMB link state
;		   (bx) = 0 => Unlink UMBs
;		   (bx) = 1 => Link UMBs
;
;
;	EXIT	'C' clear if OK
;
;		 if (al) = 0
;		  (ax) = existing method
;		 if (al) = 1
;		  Sets allocation strategy
;		 if (al) = 2
;		  (al) = 0 => UMBs not linked
;		  (al) = 1 => UMBs linked in
;		 if (al) = 3
;		  Links/Unlinks the UMBs into DOS chain
;
;		'C' set if error
;		  AX = error_invalid_function
;
;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
;		    umbhead has'nt been initialized by sysinit and 'trashed
;		    arena' if an arena sig is damaged.
;


procedure   $AllocOper,NEAR

	or	al, al
	jz	AllocGetStrat
	cmp	al, 1
	jz	AllocSetStrat
	cmp	al, 2
	jz	AllocGetLink
	cmp	al, 3
	jz	AllocSetLink
	     
AllocOperError:
					; SS override
	MOV     EXTERR_LOCUS,errLoc_mem ; Extended Error Locus
	error   error_invalid_function

AllocArenaError:

	MOV     EXTERR_LOCUS,errLoc_mem ; M009: Extended Error Locus
	error   error_arena_trashed	; M009:


AllocGetStrat:
					; SS override
	MOV     AL,BYTE PTR [AllocMethod]
	XOR     AH,AH
	transfer SYS_RET_OK

AllocSetStrat:

	push	bx			; M000 - start
	and	bx, STRAT_MASK 		; M064: mask off bit 6 & 7
	cmp	bx,2			; BX must be 0-2
	pop	bx			; M000 - end
	ja	AllocOperError

	MOV     [AllocMethod],BL
	transfer    SYS_RET_OK

AllocGetLink:

	mov	al, [UmbFlag]		; return link state in al
	and 	al, LINKSTATE		
	transfer SYS_RET_OK

AllocSetLink:

					; M009 - start
	mov	cx, [umb_head]		; cx = umb_head
	cmp	cx, 0ffffh		; Q: has umb_head been initialized
	je	AllocOperError		; N: error
					; Y: continue
					; M009 - end

	cmp	bx, 1			
	jb	UnlinkUmbs
	jz	LinkUmbs

	jmp	short AllocOperError

UnlinkUmbs:
	
	test	[UmbFlag], LINKSTATE	; Q: umbs unlinked?
	jz	unlinked		; Y: return 

	call	GetLastArena		; get arena before umb_head in DS
	jc	AllocArenaError		; M009: arena trashed

					; make it last
	mov	byte ptr ds:[0], arena_signature_end

	and	[UmbFlag], NOT LINKSTATE; indicate unlink'd state in umbflag

unlinked:
	transfer SYS_RET_OK

LinkUmbs:

	test	[UmbFlag], LINKSTATE	; Q: umbs linked?
	jnz	linked			; Y: return

	call	GetLastArena		; get arena before umb_head
	jc	AllocArenaError		; M009: arena trashed

					; make it normal. M061: ds points to
					; arena before umb_head
	mov	byte ptr ds:[0], arena_signature_normal

	or	[UmbFlag], LINKSTATE	; indicate link'd state in umbflag
linked:
	transfer SYS_RET_OK

EndProc $AllocOper


;--------------------------------------------------------------------------
;
; Procedure Name : GetLastArena		-  M003
;
; Inputs	 : cx = umb_head
;
;
; Outputs	 : If UMBs are linked
;			ES = umb_head
;			DS = arena before umb_head
;		   else
;			DS = last arena
;			ES = next arena. will be umb_head if NC.
;
;		   CY if error
;
; Uses		 : DS, ES, DI, BX
;
;--------------------------------------------------------------------------
	
Procedure	GetLastArena, NEAR


	push	ax			; save ax

	mov	ax, [arena_head]
	mov	es, ax			; es = arena_head
	xor	di, di

	cmp     byte ptr es:[di],arena_signature_end
					; Q: is this the last arena
	je	GLA_done		; Y: return last arena in ES		
					

GLA_next:
	mov	ds, ax
	call	arena_next		; ax, es -> next arena
	jc	GLA_err

	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
	jnz	GLA_chkumb		; Y: terminating condition is 
					;    umb_head
					; N: terminating condition is 05Ah

	cmp     byte ptr es:[di],arena_signature_end
					; Q: is this the last arena
	jmp	short @f
GLA_chkumb:
	cmp	ax, cx			; Q: is this umb_head
@@:
	jne	GLA_next		; N: get next arena

GLA_done:
					; M061 - Start
	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
	jnz	GLA_ret			; Y: we're done
					; N: let us confirm that the next 
					;    arena is umb_head
	mov	ds, ax
	call	arena_next		; ax, es -> next arena
	jc	GLA_err
	cmp	ax, cx			; Q: is this umb_head
	jne	GLA_err			; N: error
					; M061 - End

GLA_ret:				
	clc
	pop	ax			; M061
	ret				; M061

GLA_err:
	stc				; M061
	pop	ax
	ret

EndProc GetLastArena

DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\buf.asm ===
TITLE	BUF - MSDOS buffer management
	NAME	BUF
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	BUF.ASM - Low level routines for buffer cache management
;
;	GETCURHEAD
;	ScanPlace
;	PLACEBUF
;	PLACEHEAD
;	PointComp
;	GETBUFFR
;	GETBUFFRB
;	FlushBuf
;	BufWrite
;	SET_RQ_SC_PARMS
;
;	Revision history:
;
;		AN000  version 4.00  Jan. 1988
;		A004   PTM 3765 -- Disk reset failed
;		M039 DB 10/17/90 - Disk write optimization
;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA


	.xlist
	.xcref
	include version.inc
	INCLUDE dosseg.inc
	INCLUDE DOSSYM.INC
	include dpb.inc
	INCLUDE DEVSYM.INC
	.cref
	.list

Installed = TRUE

	i_need	PreRead,WORD
	i_need	LastBuffer,DWORD
	i_need	CurBuf,DWORD
	i_need	WPErr,BYTE
	i_need	ALLOWED,BYTE
	i_need	FAILERR,BYTE
	i_need	HIGH_SECTOR,WORD	     ; DOS 4.00 >32mb			;AN000;
	i_need	BufferQueue,DWORD
	i_need	DirtyBufferCount,WORD
	i_need	SC_CACHE_PTR,DWORD	     ; DOS 4.00 seconadary cache table	;AN000;
	i_need	SC_CACHE_COUNT,WORD	     ; DOS 4.00 secondary cache entries	;AN000;
	i_need	SC_SECTOR_SIZE,WORD	     ; DOS 4.00 sector size		;AN000;
	i_need	SC_DRIVE,BYTE		     ; DOS 4.00 drive			;AN000;
	i_need	DOS34_FLAG,WORD 	     ; DOS 4.00 common flag		;AN000;
	i_need	FIRST_BUFF_ADDR,WORD	     ; DOS 4.00 beginning of the chain	;AN000;

	i_need	BuffInHMA,byte
	i_need	LoMemBuff,dword

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<GETCURHEAD -- Get current buffer header>

;----------------------------------------------------------------------------
; Procedure Name : GetCurHead
; Inputs:
;	 No Inputs
; Function:
;	Returns the pointer to the first buffer in Queue
;	and updates FIRST_BUFF_ADDR
;       and invalidates LASTBUFFER (recency pointer)
; Outputs:
;	DS:DI = pointer to the first buffer in Queue
;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
;       LASTBUFFER = -1
; No other registers altered
;----------------------------------------------------------------------------


procedure   GETCURHEAD,NEAR

	lds	di, BufferQueue		; Pointer to the first buffer;smr;SS Override
	mov	word ptr [LASTBUFFER],-1; invalidate last buffer;smr;SS Override
	mov	[FIRST_BUFF_ADDR],di	;save first buffer addr;smr;SS Override
	ret

EndProc GETCURHEAD

Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>

;----------------------------------------------------------------------------
; Procedure Name : ScanPlace
; Inputs:
;	Same as PLACEBUF
; Function:
;	Save scan location and call PLACEBUF
; Outputs:
;	DS:DI Points to saved scan location
; All registers, except DS:DI, preserved.
;----------------------------------------------------------------------------
;M039: Rewritten to preserve registers.

procedure   ScanPlace,near

	push	[di].buf_next		;Save scan location
	call	PLACEBUF
	pop     di
	ret

EndProc ScanPlace

;----------------------------------------------------------------------------
; Procedure Name : PlaceBuf
; Input:
;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
; Function:
;	Remove buffer from queue and re-insert it in proper place.
; NO registers altered
;----------------------------------------------------------------------------

procedure   PLACEBUF,NEAR
	push	AX			;Save only regs we modify	;AN000;
	push	BX							;AN000;
	push	SI							;AN000;
	mov	ax, [di].BUF_NEXT
	mov	bx, word ptr[BufferQueue]	; bx = offset of head of list;smr;SS Override

	cmp	ax,bx				;Buf = last?		;AN000;
	je	nret				;Yes, special case	;AN000;
	cmp	di,bx				;Buf = first?		;AN000;
	jne	not_first 			;Yes, special case	;AN000;
	mov	word ptr [BufferQueue],ax	;smr;SS Override
	jmp	short nret 			;Continue with repositioning;AN000;
not_first:
	mov	SI,[DI].BUF_PREV		;No, SI = prior Buf	;AN000;
	mov	[SI].BUF_NEXT,AX		; ax has di->buf_next	;AN000;
	xchg	si, ax
	mov	[SI].BUF_PREV,AX		;			;AN000;

	mov	SI,[BX].BUF_PREV		;SI-> last buffer	;AN000;
	mov	[SI].BUF_NEXT,DI		;Add Buf to end of list ;AN000;
	mov	[BX].BUF_PREV,DI					;AN000;
	mov	[DI].BUF_PREV,SI		;Update link in Buf too	;AN000;
	mov	[DI].BUF_NEXT,BX					;AN000;
nret:									;AN000;
	pop	SI							;AN000;
	pop	BX							;AN000;
	pop	AX							;AN000;
									;AN000;
	cmp	[di.buf_ID],-1			; Buffer FREE?		;AN000;
        jne     pbx                             ; M039: -no, jump.
	mov	WORD PTR [BufferQueue],di	; M039: -yes, make it LRU.
pbx:	ret								;AN000;

EndProc PLACEBUF

;M039 - Removed PLACEHEAD.
;----------------------------------------------------------------------------
; places buffer at head
;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
;	ONE IN THE LIST!!!!!!!
; BUGBUG ---- this routine can be removed because it has only
; BUGBUG ---- one instruction. This routine is called from
; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
; BUGBUG ---- But kept as it is for modularity
;----------------------------------------------------------------------------
;procedure   PLACEHEAD,NEAR
;	mov	word ptr [BufferQueue], di
;	ret
;EndProc PLACEHEAD
;M039

Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
;----------------------------------------------------------------------------
;
; Procedure Name : PointComp
; Inputs:
;         DS:SI & ES:DI
; Function:
;          Checks for ((SI==DI) && (ES==DS))
;	   Assumes that pointers are normalized for the
;	   same segment
;
; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
; DO NOT USE FOR < or >
; No Registers altered
;
;----------------------------------------------------------------------------

procedure   PointComp,NEAR

	CMP	SI,DI
	jnz	ret_label	; return if nz
	PUSH	CX
	PUSH	DX
	MOV	CX,DS
	MOV	DX,ES
	CMP	CX,DX
	POP	DX
	POP	CX

ret_label:
	return

EndProc PointComp

	Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>


;**	GetBuffr - Get a non-FAT Sector into a Buffer
;
;	GetBuffr does normal ( non-FAT ) sector buffering
;	It gets the specified local sector into one of the I/O buffers
;	and shuffles the queue
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	      (LOW)
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CURBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags


;**	GetBuffrb - Get a FAT Sector into a Buffer
;
;	GetBuffr reads a sector from the FAT file system's FAT table.
;	It gets the specified sector into one of the I/O buffers
;	and shuffles the queue.  We need a special entry point so that
;	we can read the alternate FAT sector if the first read fails, also
;	so we can mark the buffer as a FAT sector.
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	      (LOW)
;		(SI) != 0
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CURBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags


procedure   GETBUFFR,NEAR
	DOSAssume   <DS>,"GetBuffr"

	XOR	SI,SI

;	This entry point is called for FAT buffering with SI != 0

entry	GETBUFFRB

	Assert	ISDPB,<ES,BP>,"GetBuffr"
	MOV	PREREAD,AX			; save pre-read flag
	MOV	AL,ES:[BP].DPB_DRIVE
	LDS	DI,LASTBUFFER			; Get the recency pointer
ASSUME	DS:NOTHING

;hkn; SS override
	MOV	CX,HIGH_SECTOR			; F.C. >32mb		;AN000;

;	See if this is the buffer that was most recently returned.
;	A big performance win if it is.

	CMP	DI,-1				; Recency pointer valid?
	je	getb5				; No
	CMP	DX,WORD PTR [DI].BUF_SECTOR
	JNZ	getb5				; Wrong sector
	CMP	CX,WORD PTR [DI].BUF_SECTOR+2	; F.C. >32mb		;AN000;
	JNZ	getb5				; F.C. >32mb		;AN000;
	CMP	AL,[DI.buf_ID]
	LJZ	getb35				; Just asked for same buffer

;	It's not the buffer most recently returned.  See if it's in the
;	cache.
;
;	(cx:dx) = sector #
;	(al) = drive #
;	(si) = 0 iff non fat sector, != 0 if FAT sector read
;	??? list may be incomplete ???

getb5:	CALL	GETCURHEAD			; get Q Head
getb10:	CMP	DX,WORD PTR [DI].BUF_SECTOR
	jne	getb12				; wrong sector lo
	CMP	CX,WORD PTR [DI].BUF_SECTOR+2
	jne	getb12				; wrong sector hi
	CMP	AL,[DI.buf_ID]
	jne	@f
	jmp	getb25				; Found the requested sector
@@:
getb12:	mov	DI,[DI].BUF_NEXT
	cmp	DI,FIRST_BUFF_ADDR		; back at the front again?
	jne	getb10				; no, continue looking

;	The requested sector is not available in the buffers. DS:DI now points
;	to the first buffer in the Queue. Flush the first buffer & read in the
;	new sector into it.
;
;	BUGBUG - what goes on here?  Isn't the first guy the most recently
;	used guy?  Shuld be for fast lookup.  If he is, we shouldn't take
;	him, we should take LRU.  And the above lookup shouldn't be
;	down a chain, but should be hashed.
;
;	(DS:DI) = first buffer in the queue
;	(CX:DX) = sector # we want
;	(si) = 0 iff non fat sector, != 0 if FAT sector read

;hkn; SS override
	PUSH	cx
	SAVE	<si, dx, bp, es>
	CALL	BUFWRITE			; Write out the dirty buffer
	RESTORE <es, bp, dx, si>
	POP	HIGH_SECTOR
	jnc	@f
	jmp	getbx				; if got hard error
@@:
	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache

;	We're ready to read in the buffer, if need be.  If the caller
;	wanted to just *write* the buffer then we'll skip reading it in.

	XOR	AH,AH				; initial flags
;hkn; SS override
	CMP	BYTE PTR PREREAD,ah		; am to Read in the new sector?
	JNZ	getb20				; no, we're done
	LEA	BX,[DI].BufInSiz		; (ds:bx) = data address
	MOV	CX,1
	SAVE	<si, di, dx, es>
; Note:  As far as I can tell, all disk reads into buffers go through
;	 this point.  -mrw 10/88
	cmp	BuffInHMA, 0		; is buffers in HMA?
	jz	@f
	push	ds
	push	bx
	lds	bx, dword ptr LoMemBuff	; Then let's read it into scratch buff
@@:
;M039: Eliminated redundant HMA code.
	OR	SI,SI			; FAT sector ?
	JZ	getb15

	invoke	FATSECRD
	MOV	AH,buf_isFAT		; Set buf_flags
	JMP	SHORT getb17		; Buffer is marked free if read barfs

getb15:
	invoke	DREAD			; Buffer is marked free if read barfs
	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
getb17:									  ;I001
	pushf								  ;I001
	cmp	BuffInHMA, 0		; did we read into scratch buff ? ;I001
	jz	not_in_hma		; no				  ;I001
	mov	cx, es:[bp].DPB_SECTOR_SIZE				  ;I001
	shr	cx, 1							  ;I001
	popf				; Retreive possible CY from DREAD ;I001
	mov	si, bx							  ;I001
	pop	di							  ;I001
	pop	es							  ;I001
	cld								  ;I001
	pushf				; Preserve possible CY from DREAD ;I001
	rep	movsw			; move the contents of scratch buf;I001
	push	es							  ;I001
	pop	ds							  ;I001
not_in_hma:								  ;I001
	popf								  ;I001
	RESTORE <es, dx, di, si>
	JC	getbx

;	The buffer has the data setup in it (if we were to read)
;	Setup the various buffer fields
;
;	(ds:di) = buffer address
;	(es:bp) = DPB address
;	(HIGH_SECTOR:DX) = sector #
;	(ah) = BUF_FLAGS value
;	(si) = 0 iff non fat sector, != 0 if FAT sector read

;hkn; SS override
getb20:	MOV	CX,HIGH_SECTOR
	MOV	WORD PTR [DI].BUF_SECTOR+2,CX
	MOV	WORD PTR [DI].BUF_SECTOR,DX
	MOV	WORD PTR [DI].buf_DPB,BP
	MOV	WORD PTR [DI].buf_DPB+2,ES
	MOV	AL,ES:[BP].DPB_DRIVE
	FOLLOWS	BUF_FLAGS, BUF_ID, 1
	MOV	WORD PTR [DI].BUF_ID,AX		; Set ID and Flags
getb25:	MOV	[DI].BUF_WRTCNT,1		; Default to not a FAT sector	;AC000;
	XOR	AX,AX
	OR	SI,SI				; FAT sector ?
	JZ	getb30
	MOV	AL,ES:[BP].DPB_FAT_COUNT	; update number of copies of
	MOV	[DI.buf_WRTCNT],AL		;  this sector present on disk
	MOV	AX,ES:[BP].DPB_FAT_SIZE		; offset of identical FAT
						;  sectors
;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
;		is set

getb30:	MOV	[DI.buf_wrtcntinc],AX
	CALL	PLACEBUF

;hkn; SS override for next 4
getb35: MOV	WORD PTR CURBUF+2,DS
	MOV	WORD PTR LASTBUFFER+2,DS
	MOV	WORD PTR CURBUF,DI
	MOV	WORD PTR LASTBUFFER,DI
	CLC

;	Return with 'C' set appropriately
;
;	(dx) = caller's original value

getbx:	Context DS
	return

EndProc GETBUFFR

Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>

;----------------------------------------------------------------------------
; Input:
;	DS = DOSGROUP
;	AL = Physical unit number local buffers only
;	   = -1 for all units and all remote buffers
; Function:
;	Write out all dirty buffers for unit, and flag them as clean
;	Carry set if error (user FAILed to I 24)
;	    Flush operation completed.
; DS Preserved, all others destroyed (ES too)
;----------------------------------------------------------------------------

procedure   FlushBuf,NEAR
	DOSAssume   <DS>,"FlushBuf"

	call	GetCurHead
	ASSUME	DS:NOTHING
	TESTB	[DOS34_FLAG], FROM_DISK_RESET	; from disk reset ? ;hkn;
	jnz	scan_buf_queue
	cmp	[DirtyBufferCount], 0				;hkn;
	je	end_scan
scan_buf_queue:
	call	CheckFlush
	mov	ah, [di].buf_ID
	cmp	byte ptr [wperr], ah				;hkn;
	je	free_the_buf
	TESTB	[DOS34_FLAG], FROM_DISK_RESET	; from disk reset ? ;hkn;
	jz	dont_free_the_buf
free_the_buf:
	mov	word ptr [di].buf_ID, 00ffh
dont_free_the_buf:
	mov	di, [di].buf_next
	cmp	di, [FIRST_BUFF_ADDR]				;hkn;
	jne	scan_buf_queue
end_scan:
	Context	DS
	cmp	[FAILERR], 0
	jne	bad_flush
	ret
bad_flush:
	stc
	ret

EndProc	FlushBuf

;----------------------------------------------------------------------------
;
; Procedure Name : CHECKFLUSH
;
; Inputs : AL - Drive number, -1 means do not check for drive
;	   DS:DI - pointer to buffer
;
; Function : Write out a buffer if it is dirty
;
; Carry set if problem (currently user FAILed to I 24)
;
;----------------------------------------------------------------------------

	procedure CHECKFLUSH,NEAR

	Assert	ISBUF,<DS,DI>,"CheckFlush"
	mov	ah, -1
	CMP	[DI.buf_ID],AH
	retz				; Skip free buffer, carry clear
	CMP	AH,AL			; 
	JZ	DOBUFFER		; do this buffer
	CMP	AL,[DI.buf_ID]
	CLC
	retnz				; Buffer not for this unit or SFT
DOBUFFER:
	TESTB	[DI.buf_flags],buf_dirty
	retz				; Buffer not dirty, carry clear by TEST
	PUSH	AX
	PUSH	WORD PTR [DI.buf_ID]
	CALL	BUFWRITE
	POP	AX
	JC	LEAVE_BUF		; Leave buffer marked free (lost).
	AND	AH,NOT buf_dirty	; Buffer is clean, clears carry
	MOV	WORD PTR [DI.buf_ID],AX
LEAVE_BUF:
	POP	AX			; Search info
	return
EndProc CHECKFLUSH

	Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>


;**	BufWrite - Write out Dirty Buffer
;
;	BufWrite writes a buffer to the disk, iff it's dirty.
;
;	ENTRY	DS:DI Points to the buffer
;
;	EXIT	Buffer marked free
;		Carry set if error (currently user FAILed to I 24)
;
;	USES	All buf DS:DI
;		HIGH_SECTOR


procedure   BufWrite,NEAR

	Assert	ISBUF,<DS,DI>,"BufWrite"
	MOV	AX,00FFH
	XCHG	AX,WORD PTR [DI.buf_ID] ; Free, in case write barfs
	CMP	AL,0FFH
	retz				; Buffer is free, carry clear.
	test	AH,buf_dirty
	retz				; Buffer is clean, carry clear.
	invoke	DEC_DIRTY_COUNT 	; LB. decrement dirty count

;hkn; SS override
	CMP	AL,BYTE PTR [WPERR]
	retz				; If in WP error zap buffer

;hkn; SS override
	MOV	[SC_DRIVE],AL		;LB. set it for invalidation	;AN000;
	LES	BP,[DI.buf_DPB]
	LEA	BX,[DI.BufInSiz]	; Point at buffer
	MOV	DX,WORD PTR [DI].BUF_SECTOR	;F.C. >32mb		;AN000;
	MOV	CX,WORD PTR [DI].BUF_SECTOR+2	;F.C. >32mb		;AN000;

;hkn; SS override
	MOV	[HIGH_SECTOR],CX		;F.C. >32mb		;AN000;
	MOV	CL,[DI.buf_wrtcnt]		;>32mb				;AC000;
;	MOV	AL,CH			; [DI.buf_wrtcntinc]
	XOR	CH,CH

;hkn; SS override for ALLOWED
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL
	test	AH, buf_isDATA

	JZ	NO_IGNORE
	OR	[ALLOWED],allowed_IGNORE
NO_IGNORE:

	MOV	AX,[DI.buf_wrtcntinc]		;>32mb				;AC000;

	PUSH	DI		; Save buffer pointer
	XOR	DI,DI		; Indicate failure

	push	ds
	push	bx
WRTAGAIN:
	SAVE	<DI,CX,AX>
	MOV	CX,1
	SAVE	<BX,DX,DS>
; Note:  As far as I can tell, all disk reads into buffers go through this point.  -mrw 10/88

	cmp	BuffInHMA, 0
	jz	@f
	push	cx
	push	es
	mov	si, bx
	mov	cx, es:[bp].DPB_SECTOR_SIZE
	shr	cx, 1
	les	di, dword ptr LoMemBuff
	mov	bx, di
	cld
	rep	movsw
	push	es
	pop	ds
	pop	es
	pop	cx
@@:
	invoke	DWRITE		; Write out the dirty buffer
	RESTORE <DS,DX,BX>
	RESTORE <AX,CX,DI>
	JC	NOSET
	INC	DI		; If at least ONE write succeedes, the operation
NOSET:				;	succeedes.
	ADD	DX,AX
	LOOP	WRTAGAIN
	pop	bx
	pop	ds
	OR	DI,DI		; Clears carry
	JNZ	BWROK		; At least one write worked
	STC			; DI never got INCed, all writes failed.
BWROK:	POP	DI
	return

EndProc BufWrite

Break	<SET_RQ_SC_PARMS-set requesting drive for SC>

;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
;
;	Set_RQ_SC_Parms sets the sector size and drive number value
;	for the secondary cache. This updates SC_SECTOR_SIZE &
;	SC_DRIVE even if SC is disabled to save the testing
;	code and time
;
;	ENTRY	ES:BP = drive parameter block
;
;	EXIT	[SC_SECTOR_SIZE]= drive sector size
;		[SC_DRIVE]= drive #
;
;	USES	Flags

procedure   SET_RQ_SC_PARMS,NEAR

;hkn; SS override for all variables used in this procedure.

	SAVE	<ax>

	MOV	ax,ES:[BP].DPB_SECTOR_SIZE	; save sector size
	MOV	SC_SECTOR_SIZE,ax

	MOV	al,ES:[BP].DPB_DRIVE		; save drive #
	MOV	SC_DRIVE,al

	RESTORE <ax>

srspx:	return

EndProc SET_RQ_SC_PARMS 			;LB. return

Break	<INC_DIRTY_COUNT-increment dirty count>

;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	increment dirty buffers count
; Output:
;	dirty buffers count is incremented
;
; All registers preserved
;----------------------------------------------------------------------------

procedure   INC_DIRTY_COUNT,NEAR

; BUGBUG  ---- remove this routine
; BUGBUG ---- only one instruction is needed   (speed win, space loose)
	inc	[DirtyBufferCount]			;hkn;
	ret
EndProc INC_DIRTY_COUNT

Break	<DEC_DIRTY_COUNT-decrement dirty count>

;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	decrement dirty buffers count
; Output:
;	dirty buffers count is decremented
;
; All registers preserved
;----------------------------------------------------------------------------

procedure   DEC_DIRTY_COUNT,NEAR
	cmp	[DirtyBufferCount], 0			;hkn;
	jz	ddcx			; BUGBUG - shouldn't it be an
	dec	[DirtyBufferCount]	; error condition to underflow here?	;hkn;
ddcx:	ret

EndProc DEC_DIRTY_COUNT


DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\close.asm ===
TITLE	DOS_CLOSE/COMMIT - Internal SFT close and commit call for MSDOS
	NAME	DOS_CLOSE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Internal Close and Commit calls to close a local or NET SFT.
;
;	DOS_CLOSE
;	DOS_COMMIT
;	FREE_SFT
;	SetSFTTimes
;
;	Revision history:
;
;	   AN000  version 4.00	Jan. 1988
;	   A005   PTM 3718 --- lost clusters when fastopen installed
;	   A011   PTM 4766 --- C2 fastopen problem

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include mult.inc
	include bugtyp.inc
	.cref
	.list

Installed = TRUE

	I_need	Attrib,BYTE
	i_need	THISSFT,DWORD
	i_need	CURBUF,DWORD
	i_need	THISDRV,BYTE
	i_need	ALLOWED,BYTE
	i_need	EXTERR_LOCUS,BYTE
	I_need	FailErr,BYTE
	I_Need	PROC_ID,WORD
	I_Need	USER_ID,WORD
	i_need	JShare,DWORD
	i_need	HIGH_SECTOR,WORD	 ;F.C. >32mb
	i_need	OLD_FIRSTCLUS,WORD	  ;F.O. >32mb

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


Break <DOS_CLOSE -- CLOSE FILE from SFT>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_CLOSE
;
; Inputs:
;	[THISSFT] set to the SFT for the file being used
; Function:
;	Close the indicated file via the SFT
; Returns:
;	sf_ref_count decremented otherwise
;	ES:DI point to SFT
;	Carry set if error
;	    AX has error code
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.

procedure   DOS_CLOSE,NEAR
	DOSAssume   <DS>,"DOS_Close"

	LES	DI,[THISSFT]
	Assert	ISSFT,<ES,DI>,<"DOS_CLOSE">
	fmt	TypAccess,LevBUSY,<"$p: CLOSE SFT: $x:$x\n">,<ES,DI>
	MOV	BX,ES:[DI.sf_flags]

;	Network closes are handled entirely by the net code.

	TEST	BX,sf_isnet
	JZ	LocalClose
	CallInstall Net_Close,multnet,6
	return

;
; All closes release the sharing information.
; No commit releases sharing information
;
; All closes decrement the ref count.
; No commit decrements the ref count.
;
LocalClose:
	EnterCrit   critDisk
	CALL	SetSFTTimes
	CALL	Free_SFT		; dec ref count or mark as busy

;hkn; SS is DOSDATA
	Context DS

	SAVE	<AX,BX>
	invoke	ShareEnd
	RESTORE <BX,AX>
;
; Commit enters here.  AX from commit MUST be <> 1, BX is flags word
;
CloseEntry:
	PUSH	AX
;
; File clean or device does not get stamped nor disk looked at.
;
	TEST	BX,devid_file_clean + devid_device
	JZ	rdir
	JMP	Free_SFT_OK		; either clean or device
;
; Retrieve the directory entry for the file
;
rdir:
	CALL	DirFromSFT
ASSUME	DS:NOTHING
	MOV	AL,error_access_denied
	JNC	clook
	JMP	CloseFinish		; pretend the close worked.
clook:
;
; ES:DI points to entry
; DS:SI points to SFT
; ES:BX points to buffer header
;
	SAVE	<DI,SI>
	LEA	SI,[SI].sf_name
;
; ES:DI point to directory entry
; DS:SI point to unpacked name
;
	invoke	XCHGP
;
; ES:DI point to unpacked name
; DS:SI point to directory entry
;
	invoke	MetaCompare
	invoke	XCHGP
	RESTORE <SI,DI>
	JZ	CLOSE_GO		; Name OK
Bye:	MOV	DI,SI
	PUSH	DS
	POP	ES			; ES:DI points to SFT
	PUSH	SS
	POP	DS
	STC
	MOV	AL,error_file_not_found
	JMP	CloseFinish

CLOSE_GO:
	TEST	[SI].sf_mode,sf_isfcb	; FCB ?
	JZ	nofcb			; no, set dir attr, sf_attr
	MOV	CH,ES:[DI].dir_attr
	MOV	AL,[SI].sf_attr

;hkn; SS override
	MOV	Attrib,AL
;;	invoke	MatchAttributes
;;	JNZ	Bye			; attributes do not match
	JMP	SHORT setattr		;FT.
nofcb:
	MOV	AL,[SI].sf_attr 	;FT.					;AN000;
	MOV	ES:[DI].dir_attr,AL	;FT.					;AN000;
setattr:
	OR	BYTE PTR ES:[DI.dir_attr],attr_archive	;Set archive
	MOV	AX,ES:[DI.dir_first]	;AN011;F.O. save old first clusetr

;hkn; SS override
	MOV	[OLD_FIRSTCLUS],AX	;AN011;F.O. save old first clusetr

	MOV	AX,[SI.sf_firclus]
	MOV	ES:[DI.dir_first],AX	;Set firclus pointer
	MOV	AX,WORD PTR [SI.sf_size]
	MOV	ES:[DI.dir_size_l],AX	;Set size
	MOV	AX,WORD PTR [SI.sf_size+2]
	MOV	ES:[DI.dir_size_h],AX
	MOV	AX,[SI.sf_date]
	MOV	ES:[DI.dir_date],AX	;Set date
	MOV	AX,[SI.sf_time]
	MOV	ES:[DI.dir_time],AX	;Set time
;; File Tagging

;	MOV	AX,[SI.sf_codepage]	   ;AN000;
;	MOV	ES:[DI.dir_codepg],AX	   ;AN000;Set code page
;	MOV	AX,[SI.sf_extcluster]	   ;AN000;
;	MOV	ES:[DI.dir_extcluster],AX  ;AN000;   ;Set XA cluster
;	MOV	AL,[SI.sf_attr_hi]	   ;AN000;
;	MOV	ES:[DI.dir_attr2],AL	   ;AN000;   ;Set high attr

;; File Tagging
	TEST	ES:[BX.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	ES:[BX.buf_flags],buf_dirty ;Buffer dirty
yesdirty:
	SAVE	<DS,SI>
	MOV	CX,[SI.sf_firclus]	; do this for Fastopen

;hkn; SS override
	MOV	AL,[THISDRV]
;;; 10/1/86  update fastopen cache
	PUSH	DX
	MOV	AH,0			; dir entry update
	MOV	DL,AL			; drive number A=0, B=1,,,
	OR	CX,CX			  ;AN005; first cluster 0; may be truncated
	JNZ	do_update2		  ;AN005; no, do update
	MOV	AH,3			  ;AN005; do a delete cache entry
	MOV	DI,WORD PTR [SI.sf_dirsec]   ;AN005; cx:di = dir sector
	MOV	CX,WORD PTR [SI.sf_dirsec+2] ;AN005;
	MOV	DH,[SI.sf_dirpos]	     ;AN005; dh= dir pos
	JMP	SHORT do_update 	;AN011;F.O.
do_update2:				;AN011;F.O.

;hkn; SS override fort OLD_FIRSTCLUS
	CMP	CX,[OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
	JZ	do_update		;AN011;F.O. yes
	MOV	AH,2			;AN011;F.O. delete the old entry
	MOV	CX,[OLD_FIRSTCLUS]	;AN011;F.O.
do_update:				  ;AN005;

;hkn; SS is DOSDATA
	Context DS
	invoke	FastOpen_Update 	; invoke fastopen
	POP	DX

;;; 10/1/86  update fastopen cache
	invoke	FLUSHBUF		; flush all relevant buffers
	RESTORE <DI,ES>
	MOV	AL,error_access_denied
	JC	CloseFinish
FREE_SFT_OK:
	CLC				; signal no error.
CloseFinish:
;
; Indicate to the device that the SFT is being closed.
;
;;;; 7/21/86
	PUSHF				; save flag from DirFromSFT
	invoke	Dev_Close_SFT
	POPF
;;;; 7/21/86
;
; See if the ref count indicates that we have busied the SFT.  If so, mark the
; SFT as being free.  Note that we do NOT need to be in critSFT as we are ONLY
; going to be moving from busy to free.
;
	POP	CX			; get old ref count
	PUSHF
	fmt	TypAccess,LevBUSY,<"$p: DOSFreeSFT: $x:$x from $x\n">,<ES,DI,AX>
	DEC	CX			; if cx != 1
	JNZ	NoFree			; then do NOT free SFT
	Assert	ISSFT,<ES,DI>,"DOS_FREE_SFT"
	MOV	ES:[DI].sf_ref_Count,CX
NoFree:
	LeaveCrit   critDisk
	POPF
	return
EndProc DOS_Close

;---------------------------------------------------------------------------
;
; Procedure Name : FREE_SFT
;
; ES:DI -> SFT. Decs sft_ref_count.  If the count goes to 0, mark it as busy.
; Flags preserved.  Return old ref count in AX
;
; Note that busy is indicated by the SFT ref count being -1.
;
;---------------------------------------------------------------------------

Procedure   FREE_SFT,NEAR
	DOSAssume   <DS>,"Free_SFT"

	PUSHF		; Save carry state
	MOV	AX,ES:[DI.sf_ref_count]
	DEC	AX
	JNZ	SetCount
	DEC	AX
SetCount:
	XCHG	AX,ES:[DI.sf_ref_count]
	POPF
	return

EndProc Free_SFT

;----------------------------------------------------------------------------
;
; Procedure Name : DirFromSFT
;
;   DirFromSFT - locate a directory entry given an SFT.
;
;   Inputs:	ES:DI point to SFT
;		DS = DOSDATA
;   Outputs:
;		EXTERR_LOCUS = errLOC_Disk
;		CurBuf points to buffer
;		Carry Clear -> operation OK
;		    ES:DI point to entry
;		    ES:BX point to buffer
;		    DS:SI point to SFT
;		Carry SET   -> operation failed
;		    registers trashified
;   Registers modified: ALL
;----------------------------------------------------------------------------

Procedure   DirFromSFT,NEAR
	DOSAssume   <DS>,"DOS_Close"

	; BUGBUG - assert SFT
	MOV	[EXTERR_LOCUS],errLOC_Disk
	SAVE	<ES,DI>
	MOV	DX,WORD PTR ES:[DI.sf_dirsec+2]  ;F.C. >32mb
	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
	MOV	DX,WORD PTR ES:[DI.sf_dirsec]

	PUSH	[HIGH_SECTOR]			 ;F.C. >32mb
	PUSH	DX
	invoke	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
					; [THISDPB] set
	POP	DX
	POP	[HIGH_SECTOR]			 ;F.C. >32mb
	JC	PopDone
	XOR	AL,AL			; Pre read
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	invoke	GETBUFFR
	JC	PopDone
	RESTORE <SI,DS>		; Get back SFT pointer
	ASSUME	DS:NOTHING

;hkn; SS override
	LES	DI,Curbuf
	OR	ES:[DI.buf_flags],buf_isDIR
	MOV	BX,DI			; ES:BX point to buffer header
	LEA	DI,[DI].BUFINSIZ	; Point to buffer
	MOV	AL,SIZE dir_entry
	MUL	[SI].sf_DirPos
	ADD	DI,AX			; Point at the entry

	return				; carry is clear
PopDone:
	RESTORE <DI,ES>
	return
EndProc DirFromSFT,NoCheck

	Break	<DOS_Commit - update directory entries>
;
;----------------------------------------------------------------------------
;
;**	DOS_Commit - UPdate Directory Entries
;
;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
;		(DS) = DOSGROUP
;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
;	USES	all but DS
;
;----------------------------------------------------------------------------
;

procedure   DOS_COMMIT,NEAR
	DOSAssume   <DS>,"DOS_Commit"	 ;hkn; called from srvcall. DS already set up.

	LES	DI,[THISSFT]
	MOV	BX,ES:[DI.sf_flags]
	TEST	BX,devid_file_clean + devid_device	;Clears carry
	retnz
	TEST	BX,sf_isnet
	JZ	LOCAL_COMMIT
IF NOT Installed
	transfer NET_COMMIT
ELSE
	MOV	AX,(multNET SHL 8) OR 7
	INT	2FH
	return
ENDIF

;
; Perform local commit operation by doing a close but not releaseing the SFT.
; There are three ways we can do this.	One is to enter a critical section to
; protect a potential free.  The second is to increment the ref count to mask
; the close decrementing.
;
; The proper way is to let the caller's of close decide if a decrement should
; be done.  We do this by providing another entry into close after the
; decrement and after the share information release.
;
LOCAL_COMMIT:
	EnterCrit   critDisk
	EnterCrit   critDisk		;PTM.					;AN000;
	call	SetSFTTimes
	MOV	AX,-1
	call	CloseEntry
	PUSHF				;PTM.					;AN000;
	invoke	DEV_OPEN_SFT		;PTM.  increment device count		;AN000;
	POPF				;PTM.					;AN000;
	LeaveCrit CritDisk		;PTM.					;AN000;
	return

EndProc DOS_COMMIT

Break	<SetSFTTimes - signal a change in the times for an SFT>
;----------------------------------------------------------------------------
;
; Procedure Name : SetSFTTimes
;
;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
;   Reflect these times in other SFT's for the same file.
;
;   Inputs:	ES:DI point to SFT
;		BX = sf_flags set apprpriately
;   Outputs:	Set sft times to current time iff File & dirty & !nodate
;   Registers modified: All except ES:DI, BX, AX
;
;----------------------------------------------------------------------------

Procedure   SetSFTTimes,NEAR
	Assert	ISSFT,<ES,DI>,"SetSFTTimes"

;	File clean or device does not get stamped nor disk looked at.

	TEST	BX,devid_file_clean + devid_device
	retnz				; clean or device => no timestamp

;	file and dirty.  See if date is good

	TEST	BX,sf_close_nodate
	retnz				; nodate => no timestamp
	SAVE	<AX,BX>
	invoke	DATE16			; Date/Time to AX/DX
    ASSUME DS:DOSDATA
	MOV	ES:[DI.sf_date],AX
	MOV	ES:[DI.sf_time],DX
	XOR	AX,AX
if installed
	call	JShare + 14 * 4
else
	call	ShSU
endif
	RESTORE <BX,AX>
	return
EndProc SetSFTTimes

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\abort.asm ===
TITLE   DOS_ABORT - Internal SFT close all files for proc call for MSDOS
NAME    DOS_ABORT

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**
;
; Internal Abort call closes all handles and FCBs associated with a process.
;  If process has NET resources a close all is sent out over the net.
;
;   DOS_ABORT
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;
;	M038	SR	10/16/90	Free SFT with the PSP of the process
;				being terminated only if it is busy.
;


;
; get the appropriate segment definitions
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include pdb.inc
	include mult.inc
	.cref
	.list

Installed = TRUE

	I_Need  PROC_ID,WORD            ; current process ID
	I_Need  USER_ID,WORD            ; current user ID
	i_need  CurrentPDB,WORD
	i_need  sft_addr,DWORD
	i_need  THISSFT,DWORD
	i_need  JSHARE,DWORD
	I_need  sftFCB,DWORD            ; pointer to SFTs for FCB cache

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE


Break   <DOS_ABORT -- CLOSE all files for process>
;--------------------------------------------------------------------------
;
; Procedure Name : DOS_ABORT
;
; Inputs:
;       [CurrentPDB] set to PID of process aborting
; Function:
;       Close all files and free all SFTs for this PID
; Returns:
;       None
; All destroyed except stack
;---------------------------------------------------------------------------

	Procedure   DOS_ABORT,NEAR
	ASSUME  DS:NOTHING,ES:NOTHING

	MOV     ES,[CurrentPDB]		; SS override
	MOV     CX,ES:[PDB_JFN_Length]  ; Number of JFNs
reset_free_jfn:
	MOV     BX,CX
	PUSH    CX
	DEC     BX                      ; get jfn (start with last one)

	invoke  $close
	POP     CX
	LOOP    reset_free_jfn          ; and do 'em all
;
; Note:  We do need to explicitly close FCBs.  Reasons are as follows:  If we
; are running in the no-sharing no-network environment, we are simulating the
; 2.0 world and thus if the user doesn't close the file, that is his problem
; BUT...  the cache remains in a state with garbage that may be reused by the
; next process.  We scan the set and blast the ref counts of the FCBs we own.
;
; If sharing is loaded, then the following call to close process will
; correctly close all FCBs.  We will then need to walk the list AFTER here.
;
; Finally, the following call to NET_Abort will cause an EOP to be sent to all
; known network resources.  These resources are then responsible for cleaning
; up after this process.
;
; Sleazy, eh?
;

	context DS			; SS is DOSDATA
	CallInstall Net_Abort, multNet, 29
if installed
	call    JShare + 4 * 4
else
	call    mftCloseP
endif
	assume  ds:nothing
;
; Scan the FCB cache for guys that belong to this process and zap their ref
; counts.
;

					; SS override
	les     di,sftFCB               ; grab the pointer to the table
	mov     cx,es:[di].sfCount
	jcxz    FCBScanDone
	LEA     DI,[DI].sfTable         ; point at table
	mov     ax,proc_id		; SS override
FCBTest:
	cmp     es:[di].sf_PID,ax       ; is this one of ours
	jnz     FCBNext                 ; no, skip it
	mov     es:[di].sf_ref_count,0  ; yes, blast ref count
FCBNext:
	add     di,size sf_Entry
	loop    FCBTest
FCBScanDone:

;
; Walk the SFT to eliminate all busy SFT's for this process.
;
	XOR     BX,BX
Scan:
	push    bx
	invoke  SFFromSFN
	pop     bx
	retc
;M038
; Do what the comment above says, check for busy state
;
	cmp     es:[di].sf_ref_count,sf_busy	; Is Sft busy? ;M038
	jnz      next
;
; we have a SFT that is busy.  See if it is for the current process
;

	mov     ax,proc_id		; SS override
	cmp     es:[di].sf_pid,ax
	jnz     next
	mov     ax,user_id		; SS override
	cmp     es:[di].sf_uid,ax
	jnz     next
;
; This SFT is labelled as ours.
;
	mov     es:[di].sf_ref_count,0
next:
	inc     bx
	jmp     scan

EndProc DOS_Abort

DOSCODE    ENDS
    END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\sdvxd\shellfsc.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELLFSC.Inc - EQUATES related to the File Sys Change stuff
;
;   Version:	1.00
;
;   Date:	19-Sep-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 ARR Original
;
;==============================================================================

VDA_FileSysChange	EQU	0400H+20+11

;
; On VDA_FileSysChange, wParam is not used
;   Particular VMDOSAPP instance which gets the message is the VM that has
;   changed the file system
;
; NOTE THERE MUST BE A CALL BACK ON THIS EVENT.
;
; The reference data MUST BE A pointer to a structure of the following type:
;
; It is the responsibility of the caller to "FREE" this structure (if needed)
;   on the call back.
;
; Caller can extend this structure if needed by tacking extra info on the end.
;
MAXFSCINFOSIZE		EQU	256

VMDA_FileSysChng  STRUC
VMDA_FSC_Func		dw	?
VMDA_FSC_Buffer 	db	MAXFSCINFOSIZE DUP(?)
VMDA_FileSysChng  ENDS

;
; equates for VMDA_FSC_Func
;
VMDA_FSC_CREATE 	EQU	0
VMDA_FSC_DELETE 	EQU	1
VMDA_FSC_RENAME 	EQU	2
VMDA_FSC_ATTRIBUTES	EQU	3
VMDA_FSC_NETCONNECT	EQU	4
VMDA_FSC_NETDISCONNECT	EQU	5
VMDA_FSC_REFRESH	EQU	6
VMDA_FSC_MKDIR		EQU	7
VMDA_FSC_RMDIR		EQU	8
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\cpmio2.asm ===
TITLE	CPMIO2 - device IO for MSDOS
	NAME	CPMIO2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input
;	$Std_Con_Output
;	OUTT
;	TAB
;	BUFOUT
;	$Std_Aux_Input
;	$Std_Aux_Output
;	$Std_Printer_Output
;	$Std_Con_Input_Status
;	$Std_Con_Input_Flush
;
;	Revision History:
;
;	  AN000	 version 4.00 - Jan. 1988

	.xcref
	.xlist
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	.list
	.cref

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

    i_need  CARPOS,BYTE
    i_need  CHARCO,BYTE
    i_need  PFLAG,BYTE
    i_need  CurrentPDB,WORD			 ;AN000;
    i_need  InterCon,BYTE			 ;AN000;
    i_need  SaveCurFlg,BYTE			 ;AN000;


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 


	BREAK	<$STD_CON_INPUT - System Call 1>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT - System Call 1
;
;	Input character from console, echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	ALL
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT,NEAR   ;System call 1
 IFDEF  DBCS					;AN000;
	push	word ptr [InterCon]		;AN000;
	mov	[InterCon],01H			;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO 	;AN000;
	pop	word ptr [InterCon]		;AN000;
	pushf					;AN000;
	push	AX				;AN000;
	mov	[SaveCurFlg],0			;AN000;
	jnz	sj0				;AN000;
	mov	[SaveCurFlg],1			;AN000;
sj0:						;AN000;
	invoke	OUTT				;AN000;
	mov	[SaveCurFLg],0			;AN000;
	pop	AX				;AN000;
	popf					;AN000;
	jz	$STD_CON_INPUT			;AN000;
 ELSE						;AN000;
	invoke	$STD_CON_INPUT_NO_ECHO
	PUSH	AX
	invoke	OUTT
	POP	AX
 ENDIF						;AN000;
	return
EndProc $STD_CON_INPUT


	BREAK	<$STD_CON_OUTPUT - System Call 2>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_OUTPUT - System Call 2
;
;	Output character to console
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

	public	OUTCHA			       ;AN000;
procedure   $STD_CON_OUTPUT,NEAR   ;System call 2

	MOV	AL,DL

	entry	OUTT
	CMP	AL,20H
	JB	CTRLOUT
	CMP	AL,c_DEL
	JZ	OUTCH
OUTCHA: 				   ;AN000;
	INC	BYTE PTR [CARPOS]
OUTCH:
	PUSH	DS
	PUSH	SI
	INC	BYTE PTR [CHARCO]		;invoke  statchk...
	AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
	JNZ	OUTSKIP
	PUSH	AX
	invoke	STATCHK
	POP	AX
OUTSKIP:
	invoke	RAWOUT				;output the character
	POP	SI
	POP	DS
 IFDEF  DBCS				;AN000;
	TESTB	[SaveCurFlg],01H	;AN000;print but no cursor adv? 2/13/KK
	retnz				;AN000;if so then do not send to prt2/13/KK
 ENDIF
	TEST	BYTE PTR [PFLAG],-1
	retz
	PUSH	BX
	PUSH	DS
	PUSH	SI
	MOV	BX,1
	invoke	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
					;hkn; to sft entry
	JC	TRIPOPJ
	MOV	BX,[SI].SF_FLAGS
	TESTB	BX,sf_isnet			; output to NET?
	JNZ	TRIPOPJ 			; if so, no echo
	TESTB	BX,devid_device 		; output to file?
	JZ	TRIPOPJ 			; if so, no echo
	MOV	BX,4
	invoke	GET_IO_SFT
	JC	TRIPOPJ
	TESTB	[SI].SF_FLAGS,sf_net_spool	; StdPrn redirected?
	JZ	LISSTRT2J			; No, OK to echo
	MOV	BYTE PTR [PFLAG],0		; If a spool, NEVER echo
TRIPOPJ:
	JMP	TRIPOP

LISSTRT2J:
	JMP	LISSTRT2

CTRLOUT:
	CMP	AL,c_CR
	JZ	ZERPOS
	CMP	AL,c_BS
	JZ	BACKPOS
	CMP	AL,c_HT
	JNZ	OUTCH
	MOV	AL,[CARPOS]
	OR	AL,0F8H
	NEG	AL

	entry	TAB

	PUSH	CX
	MOV	CL,AL
	MOV	CH,0
	JCXZ	POPTAB
TABLP:
	MOV	AL," "
	invoke	OUTT
	LOOP	TABLP
POPTAB:
	POP	CX
	return

ZERPOS:
	MOV	BYTE PTR [CARPOS],0
	JMP	OUTCH
OUTJ:	JMP	OUTT

BACKPOS:
	DEC	BYTE PTR [CARPOS]
	JMP	OUTCH

	entry	BUFOUT
	CMP	AL," "
	JAE	OUTJ		;Normal char
	CMP	AL,9
	JZ	OUTJ		;OUT knows how to expand tabs

ifdef	DBCS				; MSKK01 07/14/89
ifdef	JAPAN				; MSKK01 07/14/89

; convert CONTROL-U and CONTROL-T to ^U ^T in KANJI DOS

else

;DOS 3.3  7/14/86
	CMP	AL,"U"-"@"      ; turn ^U to section symbol
	JZ	CTRLU
	CMP	AL,"T"-"@"      ; turn ^T to paragraph symbol
	JZ	CTRLU
endif
else
;DOS 3.3  7/14/86
	CMP	AL,"U"-"@"      ; turn ^U to section symbol
	JZ	CTRLU
	CMP	AL,"T"-"@"      ; turn ^T to paragraph symbol
	JZ	CTRLU
endif
NOT_CTRLU:
;DOS 3.3  7/14/86

	PUSH	AX
	MOV	AL,"^"
	invoke	OUTT		;Print '^' before control chars
	POP	AX
	OR	AL,40H		;Turn it into Upper case mate
CTRLU:
	invoke	OUTT
	return
EndProc $STD_CON_OUTPUT

	BREAK	<$STD_AUX_INPUT - System Call 3>

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_INPUT - System Call 3
;
;	$STD_AUX_INPUT returns a character from Aux Input
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_AUX_INPUT,NEAR   ;System call 3

	invoke	STATCHK
	MOV	BX,3
	invoke	GET_IO_SFT
	retc
	JMP	SHORT TAISTRT
AUXILP:
	invoke	SPOOLINT
TAISTRT:
	MOV	AH,1
	invoke	IOFUNC
	JZ	AUXILP
	XOR	AH,AH
	invoke	IOFUNC
	return
EndProc $STD_AUX_INPUT


	BREAK	<$STD_AUX_OUTPUT, $STD_PRINTER_OUTPUT, fcn 4,5>
;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_OUTPUT - Output character to AUX
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_AUX_OUTPUT,NEAR   ;System call 4

	PUSH	BX
	MOV	BX,3
	JMP	SHORT SENDOUT

EndProc $STD_AUX_OUTPUT


;
;----------------------------------------------------------------------------
;
;**	$STD_PRINTER_OUTPUT - Output character to printer
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_PRINTER_OUTPUT,NEAR   ;System call 5

	PUSH	BX
	MOV	BX,4

SENDOUT:
	MOV	AL,DL
	PUSH	AX
	invoke	STATCHK
	POP	AX
	PUSH	DS
	PUSH	SI
LISSTRT2:
	invoke	RAWOUT2
TRIPOP:
	POP	SI
	POP	DS
	POP	BX
	return
EndProc $STD_PRINTER_OUTPUT

	BREAK	<$STD_CON_INPUT_STATUS - System Call 11>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_STATUS - System Call 11
;
;	Check console input status
;
;	ENTRY	none
;	EXIT	AL = -1 character available, = 0 no character
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT_STATUS,NEAR	 ;System call 11

	invoke	STATCHK
	MOV	AL,0			; no xor!!
	retz
	OR	AL,-1
	return
EndProc $STD_CON_INPUT_STATUS

	BREAK	<$STD_CON_INPUT_FLUSH - System call 12>
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_FLUSH - System Call 12
;
;	Flush console input buffer and perform call in AL
;
;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
;		return arguments for the fcn supplied in (AL)
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_INPUT_FLUSH,NEAR	;System call 12

	PUSH	AX
	PUSH	DX
	XOR	BX,BX
	invoke	GET_IO_SFT
	JC	BADJFNCON
	MOV	AH,4
	invoke	IOFUNC

BADJFNCON:
	POP	DX
	POP	AX
	MOV	AH,AL
	CMP	AL,1
	JZ	REDISPJ
	CMP	AL,6
	JZ	REDISPJ
	CMP	AL,7
	JZ	REDISPJ
	CMP	AL,8
	JZ	REDISPJ
	CMP	AL,10
	JZ	REDISPJ
	MOV	AL,0
	return

REDISPJ:
 IFDEF  DBCS			  ;AN000;
	mov	ds,[CurrentPDB]   ;AN000;
				  ;AN000; set DS same as one from COMMAND entry
 ENDIF
	CLI
	transfer    REDISP
EndProc $STD_CON_INPUT_FLUSH

DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\cpmio.asm ===
;**	Standard device IO for MSDOS (first 12 function calls)
;

	TITLE	IBMCPMIO - device IO for MSDOS
	NAME	IBMCPMIO

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	CPMIO.ASM - Standard device IO for MSDOS (first 12 function calls)
;
;
;	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input_No_Echo
;	$Std_Con_String_Output
;	$Std_Con_String_Input
;	$RawConIO
;	$RawConInput
;	RAWOUT
;	RAWOUT2
;
;	Revision history:
;
;	    A000     version 4.00 - Jan 1988
;	    A002     PTM    -- dir >lpt3 hangs

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	include sf.inc
	include vector.inc
	INCLUDE DEVSYM.INC
	include doscntry.inc
	.list
	.cref


; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

    i_need  CARPOS,BYTE
    i_need  STARTPOS,BYTE
    i_need  INBUF,128
    i_need  INSMODE,BYTE
    i_need  user_SP,WORD
    EXTRN   OUTCHA:NEAR 		;AN000 char out with status check 2/11/KK
    i_need  Printer_Flag,BYTE
    i_need  SCAN_FLAG,BYTE
    i_need  DATE_FLAG,WORD
    i_need  Packet_Temp,WORD		; temporary packet used by readtime
    i_need  DEVCALL,DWORD
    i_need  InterChar,BYTE		;AN000;interim char flag ( 0 = regular char)
    i_need  InterCon,BYTE		;AN000;console flag ( 1 = in interim mode )
    i_need  SaveCurFlg,BYTE		;AN000;console out ( 1 = print and do not advance)
    i_need  COUNTRY_CDPG,byte		;AN000; 	2/12/KK
    i_need  TEMP_VAR,WORD		;AN000; 	2/12/KK
    i_need  DOS34_FLAG,WORD		;AN000; 	2/12/KK

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	Get_IO_SFT:Near
	EXTRN	IOFunc:near

	EXTRN	EscChar:BYTE		; lead byte for function keys
	EXTRN	CanChar:BYTE		; Cancel character


Break
IFDEF  DBCS							  ;AN000;
;
;----------------------------------------------------------------------------
;
; Procedure : $Std_Con_Input_No_Echo
;
;----------------------------------------------------------------------------
;

;--- Start of Korean Support 2/11/KK
procedure   $STD_CON_INPUT_NO_ECHO,NEAR   ;System call 8  ;AN000;

StdCILop:							  ;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO 			  ;AN000;
	jmp	InterApRet		; go to return fuction	  ;AN000;

EndProc $STD_CON_INPUT_NO_ECHO					  ;AN000;
;
;----------------------------------------------------------------------------
;
; Procedure : Inter_Con_Input_No_Echo
;
;
;----------------------------------------------------------------------------
;
procedure   INTER_CON_INPUT_NO_ECHO,NEAR		  ;AN000;
;--- End of Korean Support 2/11/KK

; Inputs:
;	None
; Function:
;	Same as $STD_CON_INPUT_NO_ECHO but uses interim character read from
;	the device.
; Returns:
;	AL = character
;	Zero flag SET if interim character, RESET otherwise
ELSE								  ;AN000;
;
; Inputs:
;	None
; Function:
;	Input character from console, no echo
; Returns:
;	AL = character

procedure   $STD_CON_INPUT_NO_ECHO,NEAR   ;System call 8

ENDIF
	PUSH	DS
	PUSH	SI
INTEST:
	invoke	STATCHK
	JNZ	Get
;*************************************************************************

;hkn; SS override
	cmp	[Printer_Flag],0	; is printer idle?
	jnz	no_sys_wait
	mov	ah,5			; get input status with system wait
	call	IOFUNC
no_sys_wait:
;**************************************************************************
	MOV	AH,84h
	INT	int_IBM

;;; 7/15/86  update the date in the idle loop
;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
;;;;		 to shorten loop in consideration of the PC Convertible

;hkn; SS override
	CMP	byte ptr [DATE_FLAG],-1 ; date is updated may be every
	JNZ	NoUpdate		; 65535 x ? ms if no one calls
	PUSH	AX
	PUSH	BX			; following is tricky,
	PUSH	CX			; it may be called by critical handler
	PUSH	DX			; at that time, DEVCALL is used by
					; other's READ or WRITE
	PUSH	DS			; save DS = SFT's sgement

;hkn; READTIME must use ds = DOSDATA
;hkn;	PUSH	CS			; READTIME must use DS=CS

	push	ss
	POP	DS

	MOV	AX,0			; therefore, we save DEVCALL
	CALL	Save_Restore_Packet	; save DEVCALL packet
	invoke	READTIME		; readtime
	MOV	AX,1
	CALL	Save_Restore_Packet	; restore DEVCALL packet

	POP	DS			; restore DS
	POP	DX
	POP	CX
	POP	BX
	POP	AX
NoUpdate:

;hkn; SS override
	INC	[DATE_FLAG]

;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	JMP	Intest
Get:
	XOR	AH,AH
	call	IOFUNC
	POP	SI
	POP	DS
;;; 7/15/86

;hkn; SS override
	MOV	BYTE PTR [SCAN_FLAG],0
	CMP	AL,0	    ; extended code ( AL )
	JNZ	noscan

;hkn; SS override
	MOV	BYTE PTR [SCAN_FLAG],1	; set this flag for ALT_Q key

noscan:
;;; 7/15/86
 IFDEF  DBCS			    ;AN000;

;hkn; InterChar is in DOSDATA. use SS override.
	cmp	[InterChar],1    ;AN000; set the zero flag if the character3/31/KK ;AN000;
 ENDIF				    ;AN000;
	return
 IFDEF  DBCS			    ;AN000;
EndProc INTER_CON_INPUT_NO_ECHO     ;AN000;  ;2/11/KK				      ;AN000;
 ELSE				    ;AN000;
EndProc $STD_CON_INPUT_NO_ECHO
 ENDIF				    ;AN000;

	BREAK	<$STD_CON_STRING_OUTPUT - Console String Output>

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_OUTPUT - Console String Output
;
;
;	ENTRY	(DS:DX) Point to output string '$' terminated
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------
;

procedure   $STD_CON_STRING_OUTPUT,NEAR   ;System call 9

	MOV	SI,DX
STRING_OUT1:
	LODSB
; IFDEF  DBCS				;AN000;
;	invoke	TESTKANJ		;AN000; 	      2/11/KK		 ;AN000;
;	jz	SBCS00			;AN000; 	      2/11/KK		 ;AN000;
;	invoke	OUTT			;AN000; 	      2/11/KK		 ;AN000;
;	LODSB				;AN000; 	      2/11/KK		 ;AN000;
;	JMP	NEXT_STR1		;AN000; 	      2/11/KK		 ;AN000;
;SBCS00: 				;AN000; 	      2/11/KK		 ;AN000;
; ENDIF					;AN000;
	CMP	AL,'$'
	retz
NEXT_STR1:
	invoke	OUTT
	JMP	STRING_OUT1

EndProc $STD_CON_STRING_OUTPUT

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

IFDEF  DBCS

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

	include kstrin.asm

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ELSE	; Not double byte characters

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;       SCCSID = @(#)strin.asm  1.2 85/04/18

	BREAK	<$STD_CON_STRING_INPUT - Input Line from Console>


;**	$STD_CON_STRING_INPUT - Input Line from Console
;
;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
;
;	ENTRY	(ds:dx) = input buffer
;	EXIT	none
;	USES	ALL

	ASSUME	DS:NOTHING,ES:NOTHING
procedure	 $STD_CON_STRING_INPUT,NEAR	;System call 10

        MOV     AX,SS
        MOV     ES,AX
        MOV     SI,DX
        XOR     CH,CH
        LODSW

;	(AL) = the buffer length
;	(AH) = the template length

        OR      AL,AL
        retz                    ;Buffer is 0 length!!?
        MOV     BL,AH           ;Init template counter
        MOV     BH,CH           ;Init template counter

;	(BL) = the number of bytes in the template

        CMP     AL,BL
        JBE     NOEDIT          ;If length of buffer inconsistent with contents
        CMP     BYTE PTR [BX+SI],c_CR
        JZ      EDITON          ;If CR correctly placed EDIT is OK

; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;

noedit:	MOV	BL,CH		 ;Reset buffer
editon: MOV	DL,AL
        DEC     DX              ;DL is # of bytes we can put in the buffer

;	Top level.  We begin to read a line in.

;hkn; SS override
newlin: MOV	AL,[CARPOS]
        MOV     [STARTPOS],AL   ;Remember position in raw buffer
        PUSH    SI

;hkn; INBUF is in DOSDATA
        MOV     DI,OFFSET DOSDATA:INBUF        ;Build the new line here

;hkn; SS override
        MOV     [INSMODE],CH    ;Insert mode off
        MOV     BH,CH           ;No chars from template yet
        MOV     DH,CH           ;No chars to new line yet
        invoke  $STD_CON_INPUT_NO_ECHO          ;Get first char
        CMP     AL,c_LF         ;Linefeed
        JNZ     GOTCH           ;Filter out LF so < works

;	This is the main loop of reading in a character and processing it.
;
;	(BH) = the index of the next byte in the template
;	(BL) = the length of the template
;	(DH) = the number of bytes in the buffer
;	(DL) = the length of the buffer

entry	GETCH
        invoke  $STD_CON_INPUT_NO_ECHO
GOTCH:
;
; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
; input queue.
;
        CMP     AL,"F"-"@"
        JZ      GETCH

;	If the leading char is the function-key lead byte


;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
        CMP     AL,[ESCCHAR]
        JZ      ESCape          ;change reserved keyword DBM 5-7-87

;	Rubout and ^H are both destructive backspaces.

        CMP     AL,c_DEL
        JZ      BACKSPJ
        CMP     AL,c_BS
        JZ      BACKSPJ

;	^W deletes backward once and then backs up until a letter is before the
;	cursor

        CMP     AL,"W" - "@"

;	The removal of the comment characters before the jump statement will
;	cause ^W to backup a word.

;***    JZ      WordDel
        NOP
        NOP
        CMP     AL,"U" - "@"

;	The removal of the comment characters before the jump statement will
;	cause ^U to clear a line.

;***    JZ      LineDel
        NOP
        NOP


;	CR terminates the line.

        CMP     AL,c_CR
        JZ      ENDLIN

;	LF goes to a new line and keeps on reading.

        CMP     AL,c_LF
        JZ      PHYCRLF

;	^X (or ESC) deletes the line and starts over


;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
        CMP     AL,[CANCHAR]
        JZ      KILNEW

; Otherwise, we save the input character.

savch:	CMP	DH,DL
        JAE     BUFFUL                  ; buffer is full.
        STOSB
        INC     DH                      ; increment count in buffer.
        invoke  BUFOUT                  ;Print control chars nicely

;hkn; SS override
        CMP     BYTE PTR [INSMODE],0
        JNZ     GETCH                   ; insertmode => don't advance template
        CMP     BH,BL
        JAE     GETCH                   ; no more characters in template
        INC     SI                      ; Skip to next char in template
        INC     BH                      ; remember position in template
        JMP     SHORT GETCH

BACKSPJ: JMP    SHORT BACKSP

bufful: MOV	AL,7			; Bell to signal full buffer
        invoke  OUTT
        JMP     SHORT GETCH

ESCape: transfer    OEMFunctionKey	; let the OEM's handle the key dispatch

ENDLIN:
        STOSB                           ; Put the CR in the buffer
        invoke  OUTT                    ; Echo it
        POP     DI                      ; Get start of user buffer
        MOV     [DI-1],DH               ; Tell user how many bytes
        INC     DH                      ; DH is length including CR
COPYNEW:
	SAVE	<DS,ES>
	RESTORE <DS,ES>		    ; XCHG ES,DS

;hkn; INBUF is in DOSDATA
        MOV     SI,OFFSET DOSDATA:INBUF
        MOV     CL,DH                   ; set up count
        REP     MOVSB                   ; Copy final line to user buffer
        return

;	Output a CRLF to the user screen and do NOT store it into the buffer

PHYCRLF:
        invoke  CRLF
        JMP     GETCH

;
; Delete the previous line
;
LineDel:
        OR      DH,DH
        JZ      GetCh
        Call    BackSpace
        JMP     LineDel

;
; delete the previous word.
;
WordDel:
WordLoop:
        Call    BackSpace               ; backspace the one spot
        OR      DH,DH
        JZ      GetChJ
        MOV     AL,ES:[DI-1]
        cmp     al,'0'
        jb      GetChj
        cmp     al,'9'
        jbe     WordLoop
        OR      AL,20h
        CMP     AL,'a'
        JB      GetChJ
        CMP     AL,'z'
        JBE     WordLoop
getchj: JMP	GetCh

; The user wants to throw away what he's typed in and wants to start over.  We
; print the backslash and then go to the next line and tab to the correct spot
; to begin the buffered input.

        entry   KILNEW
        MOV     AL,"\"
        invoke  OUTT            ;Print the CANCEL indicator
        POP     SI              ;Remember start of edit buffer
PUTNEW:
        invoke  CRLF            ;Go to next line on screen

;hkn; SS override
        MOV     AL,[STARTPOS]
        invoke  TAB             ;Tab over
        JMP     NEWLIN          ;Start over again



;	Destructively back up one character position

entry   BackSp
        Call    BackSpace
        JMP     GetCh

BackSpace:
        OR      DH,DH
        JZ      OLDBAK          ;No chars in line, do nothing to line
        CALL    BACKUP          ;Do the backup
        MOV     AL,ES:[DI]      ;Get the deleted char
        CMP     AL," "
        JAE     OLDBAK          ;Was a normal char
        CMP     AL,c_HT
        JZ      BAKTAB          ;Was a tab, fix up users display
;; 9/27/86 fix for ctrl-U backspace
        CMP     AL,"U"-"@"      ; ctrl-U is a section symbol not ^U
        JZ      OLDBAK
        CMP     AL,"T"-"@"      ; ctrl-T is a paragraphs symbol not ^T
        JZ      OLDBAK
;; 9/27/86 fix for ctrl-U backspace
        CALL    BACKMES         ;Was a control char, zap the '^'
OLDBAK:

;hkn; SS override
        CMP     BYTE PTR [INSMODE],0
        retnz                   ;In insert mode, done
        OR      BH,BH
        retz                    ;Not advanced in template, stay where we are
        DEC     BH              ;Go back in template
        DEC     SI
        return

BAKTAB:
        PUSH    DI
        DEC     DI              ;Back up one char
        STD                     ;Go backward
        MOV     CL,DH           ;Number of chars currently in line
        MOV     AL," "
        PUSH    BX
        MOV     BL,7            ;Max
        JCXZ    FIGTAB          ;At start, do nothing
FNDPOS:
        SCASB                   ;Look back
        JNA     CHKCNT
        CMP     BYTE PTR ES:[DI+1],9
        JZ      HAVTAB          ;Found a tab
        DEC     BL              ;Back one char if non tab control char
CHKCNT:
        LOOP    FNDPOS
FIGTAB:
;hkn; SS override
        SUB     BL,[STARTPOS]
HAVTAB:
        SUB     BL,DH
        ADD     CL,BL
        AND     CL,7            ;CX has correct number to erase
        CLD                     ;Back to normal
        POP     BX
        POP     DI
        JZ      OLDBAK          ;Nothing to erase
TABBAK:
        invoke  BACKMES
        LOOP    TABBAK          ;Erase correct number of chars
        JMP     SHORT OLDBAK

BACKUP:
        DEC     DH              ;Back up in line
        DEC     DI
BACKMES:
        MOV     AL,c_BS         ;Backspace
        invoke  OUTT
        MOV     AL," "          ;Erase
        invoke  OUTT
        MOV     AL,c_BS         ;Backspace
        JMP     OUTT            ;Done

;User really wants an ESC character in his line
        entry   TwoEsc

;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
        MOV     AL,[ESCCHAR]
        JMP     SAVCH

;Copy the rest of the template
        entry   COPYLIN
        MOV     CL,BL           ;Total size of template
        SUB     CL,BH           ;Minus position in template, is number to move
        JMP     SHORT COPYEACH

        entry   CopyStr
        invoke  FINDOLD         ;Find the char
        JMP     SHORT COPYEACH  ;Copy up to it

;Copy one char from template to line
        entry   COPYONE
        MOV     CL,1
;Copy CX chars from template to line
COPYEACH:
;hkn; SS override
        MOV     BYTE PTR [INSMODE],0    ;All copies turn off insert mode
        CMP     DH,DL
        JZ      GETCH2                  ;At end of line, can't do anything
        CMP     BH,BL
        JZ      GETCH2                  ;At end of template, can't do anything
        LODSB
        STOSB
        invoke  BUFOUT
        INC     BH                      ;Ahead in template
        INC     DH                      ;Ahead in line
        LOOP    COPYEACH
GETCH2:
        JMP     GETCH

;Skip one char in template
        entry   SKIPONE
        CMP     BH,BL
        JZ      GETCH2                  ;At end of template
        INC     BH                      ;Ahead in template
        INC     SI
        JMP     GETCH

        entry   SKIPSTR
        invoke  FINDOLD                 ;Find out how far to go
        ADD     SI,CX                   ;Go there
        ADD     BH,CL
        JMP     GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;       address is popped off and a jump to GETCH is taken.
;       Make sure nothing extra on stack when this routine
;       is called!!! (no PUSHes before calling it).
FINDOLD:
        invoke  $STD_CON_INPUT_NO_ECHO

;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
        CMP     AL,[ESCCHAR]            ; did he type a function key?
        JNZ     FindSetup               ; no, set up for scan
        invoke  $STD_CON_INPUT_NO_ECHO  ; eat next char
        JMP     short NotFnd            ; go try again
FindSetup:
        MOV     CL,BL
        SUB     CL,BH           ;CX is number of chars to end of template
        JZ      NOTFND          ;At end of template
        DEC     CX              ;Cannot point past end, limit search
        JZ      NOTFND          ;If only one char in template, forget it
        PUSH    ES
        PUSH    DS
        POP     ES
        PUSH    DI
        MOV     DI,SI           ;Template to ES:DI
        INC     DI
        REPNE   SCASB           ;Look
        POP     DI
        POP     ES
        JNZ     NOTFND          ;Didn't find the char
        NOT     CL              ;Turn how far to go into how far we went
        ADD     CL,BL           ;Add size of template
        SUB     CL,BH           ;Subtract current pos, result distance to skip
        return

NOTFND:
        POP     BP              ;Chuck return address
        JMP     GETCH

entry   REEDIT
        MOV     AL,"@"          ;Output re-edit character
        invoke  OUTT
        POP     DI
        PUSH    DI
        PUSH    ES
        PUSH    DS
        invoke  COPYNEW         ;Copy current line into template
        POP     DS
        POP     ES
        POP     SI
        MOV     BL,DH           ;Size of line is new size template
        JMP     PUTNEW          ;Start over again

        entry   EXITINS
        entry   ENTERINS

;hkn; SS override
        NOT     BYTE PTR [INSMODE]
        JMP     GETCH

;Put a real live ^Z in the buffer (embedded)
        entry   CTRLZ
        MOV     AL,"Z"-"@"
        JMP     SAVCH

;Output a CRLF
        entry   CRLF
        MOV     AL,c_CR
        invoke  OUTT
        MOV     AL,c_LF
        JMP     OUTT

EndProc $STD_CON_STRING_INPUT

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ENDIF

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
	BREAK	<$RAW_CON_IO - Do Raw Console I/O>
;
;----------------------------------------------------------------------------
;
;**	$RAW_CON_IO - Do Raw Console I/O
;
;	Input or output raw character from console, no echo
;
;	ENTRY	DL = -1 if input
;		   =  output character if output
;	EXIT	(AL) = input character if input
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $RAW_CON_IO,NEAR   ; System call 6

	MOV	AL,DL
	CMP	AL,-1
	LJNE	RAWOUT			; is output

;hkn; SS override
	LES	DI,DWORD PTR [user_SP]		      ; Get pointer to register save area
	XOR	BX,BX
	call	GET_IO_SFT
	retc
 IFDEF  DBCS				;AN000;

;hkn; SS override
	push	word ptr [Intercon]	;AN000;
	mov	[Intercon],0		;AN000; disable interim characters
 ENDIF					;AN000;
	MOV	AH,1
	call	IOFUNC
	JNZ	RESFLG
 IFDEF  DBCS				;AN000;

;hkn; SS override
	pop	word ptr [InterCon]	;AN000; restore interim flag
 ENDIF					;AN000;
	invoke	SPOOLINT
	OR	BYTE PTR ES:[DI.user_F],40H ; Set user's zero flag
	XOR	AL,AL
	return

RESFLG:
	AND	BYTE PTR ES:[DI.user_F],0FFH-40H    ; Reset user's zero flag
 IFDEF  DBCS				;AN000;
	XOR	AH,AH			;AN000;
	call	IOFUNC			;AN000; get the character

;hkn; SS override
	pop	word ptr [InterCon]	;AN000;
	return				;AN000;
 ENDIF					;AN000; 				;AN000;


;
;----------------------------------------------------------------------------
;
;**	$Raw_CON_INPUT - Raw Console Input
;
;	Input raw character from console, no echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;


rci0:	invoke	SPOOLINT

entry	$RAW_CON_INPUT	      ; System call 7

	PUSH	BX
	XOR	BX,BX
	call	GET_IO_SFT
	POP	BX
	retc
	MOV	AH,1
	call	IOFUNC
	JNZ	rci5
	MOV	AH,84h
	INT	int_IBM
	JMP	rci0

rci5:	XOR	AH,AH
	call	IOFUNC
 IFDEF  DBCS				;AN000;

;hkn; SS override
	cmp	[InterChar],1		;AN000;    2/11/KK
;								2/11/KK
;	Sets the application zero flag depending on the 	2/11/KK
;	zero flag upon entry to this routine. Then returns	2/11/KK
;	from system call.					2/11/KK
;								2/11/KK
entry	InterApRet			;AN000; 		2/11/KK 	;AN000;
	pushf				;AN000; 3/16/KK
;hkn;	push	ds			;AN000; 3/16/KK
	push	bx			;AN000; 3/16/KK

;hkn; SS is DOSDATA
;hkn;	Context DS			;AN000; 3/16/KK

;hkn; COUNTRY_CDPG is in DOSCODE;smr;NO in DOSDATA
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccDosCodePage
	cmp	word ptr ss:[bx],934	;AN000; 3/16/KK       korean code page ?; bug fix. use SS
	pop	bx			;AN000; 3/16/KK
;hkn;	pop	ds			;AN000; 3/16/KK
	je	do_koren		;AN000; 3/16/KK
	popf				;AN000; 3/16/KK
	return				;AN000; 3/16/KK
do_koren:				;AN000; 3/16/KK
	popf				;AN000;

;hkn; SS override
	LES	DI,DWORD PTR [user_SP]	;AN000; Get pointer to register save area KK
	jnz	sj0			;AN000; 		      2/11/KK
	OR	BYTE PTR ES:[DI.user_F],40H	;AN000; Set user's zero flag  2/11/KK
	return				;AN000; 		2/11/KK
sj0:					;AN000; 		2/11/KK
	AND	BYTE PTR ES:[DI.user_F],0FFH-40H ;AN000; Reset user's zero flag 2/KK
 ENDIF						 ;AN000;
	return					 ;AN000;
;
;	Output the character in AL to stdout
;
	entry	RAWOUT

	PUSH	BX
	MOV	BX,1

	call	GET_IO_SFT
	JC	RAWRET1

	MOV	BX,[SI.sf_flags]	;hkn; DS set up by get_io_sft

 ;
 ; If we are a network handle OR if we are not a local device then go do the
 ; output the hard way.
 ;

	AND	BX,sf_isNet + devid_device
	CMP	BX,devid_device
	JNZ	RawNorm
 IFDEF  DBCS					;AN000;

;hkn; SS override
	TEST	[SaveCurFlg],01H		;AN000; print but no cursor adv?
	JNZ	RAWNORM 			;AN000;    2/11/KK
 ENDIF						;AN000;

;	TEST	BX,sf_isnet			; output to NET?
;	JNZ	RAWNORM 			; if so, do normally
;	TEST	BX,devid_device 		; output to file?
;	JZ	RAWNORM 			; if so, do normally

	PUSH	DS
	LDS	BX,[SI.sf_devptr]		; output to special?
	TEST	BYTE PTR [BX+SDEVATT],ISSPEC
	POP	DS
	JZ	RAWNORM 			; if not, do normally
	INT	int_fastcon			; quickly output the char
RAWRET:
	CLC
RAWRET1:
	POP	BX
	return
RAWNORM:
	CALL	RAWOUT3
	JMP	RAWRET

;
;	Output the character in AL to handle in BX
;
	entry	RAWOUT2

	call	GET_IO_SFT
	retc
RAWOUT3:
	PUSH	AX
	JMP	SHORT RAWOSTRT
ROLP:
	invoke	SPOOLINT

;hkn; SS override
	OR	[DOS34_FLAG],CTRL_BREAK_FLAG ;AN002; set control break
	invoke	DSKSTATCHK		     ;AN002; check control break
RAWOSTRT:
	MOV	AH,3
	call	IOFUNC
	JZ	ROLP
;SR;
; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
;the user failed. We do not send a char if this happens. We however return 
;to the caller with carry clear because this DOS call does not return any
;status. 
;
	inc	ax			;fail on I24 if ax = -1
	POP	AX
	jz	nosend			;yes, do not send char

	MOV	AH,2
	call	IOFUNC
nosend:
	CLC			; Clear carry indicating successful
	return
EndProc $RAW_CON_IO

;
;----------------------------------------------------------------------------
;
; Inputs:
;	AX=0 save the DEVCALL request packet
;	  =1 restore the DEVCALL request packet
; Function:
;	save or restore the DEVCALL packet
; Returns:
;	none
;
;----------------------------------------------------------------------------
;

procedure   Save_Restore_Packet,NEAR

	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI
	CMP	AX,0		; save packet
	JZ	save_packet
restore_packet:
	MOV	SI,OFFSET DOSDATA:Packet_Temp	 ;sourec
	MOV	DI,OFFSET DOSDATA:DEVCALL	 ;destination
	JMP	short set_seg
save_packet:
	MOV	DI,OFFSET DOSDATA:Packet_Temp	 ;destination
	MOV	SI,OFFSET DOSDATA:DEVCALL	 ;source
set_seg:
	MOV	AX,SS		; set DS,ES to DOSDATA
	MOV	DS,AX
	MOV	ES,AX
	MOV	CX,11		; 11 words to move
	REP	MOVSW

	POP	DI
	POP	SI
	POP	ES
	POP	DS
	return
EndProc Save_Restore_Packet

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\crit.asm ===
TITLE CRIT - Critical Section Routines
	NAME  CRIT

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	CRIT.ASM - Critical Section Routines
;
;	Critical section handlers
;
;	Modification history:
;
;	    Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	include int2a.inc
	include vector.inc
	include bugtyp.inc
	.cref
	.list

	I_need  User_In_AX,WORD
	i_need  CurrentPDB,WORD

;
;SR; This variable is set when the redir installs itself
;
	I_need 	redir_patch,BYTE

DOSCODE SEGMENT
	ASSUME  SS:NOTHING,CS:DOSCODE

	allow_getdseg

	Break	<Critical section handlers>

;
;   Each handler must leave everything untouched; including flags!
;
;   Sleaze for time savings:  first instruction is a return.  This is patched
;   by the sharer to be a PUSH AX to complete the correct routines.


Procedure   EcritDisk,NEAR
	public  EcritMem
	public  EcritSFT
ECritMEM    LABEL   NEAR
ECritSFT    LABEL   NEAR

;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x entering DISK">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8000h+critDisk
	INT     int_ibm
	POP     AX
	return
@@:
	popff
	ret

EndProc EcritDisk


Procedure   LcritDisk,NEAR
	public  LcritMem
	public  LcritSFT
LCritMEM    LABEL   NEAR
LCritSFT    LABEL   NEAR
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x leaving DISK">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8100h+critDisk
	INT     int_ibm
	POP     AX
	return
@@:
	popff
	ret

EndProc LcritDisk


Procedure   EcritDevice,NEAR
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x entering DEV">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8000h+critDevice
	INT     int_ibm
	POP     AX
	return
@@:
	popff
	ret

EndProc EcritDevice

Procedure   LcritDevice,NEAR
;
;SR; Check if critical section is to be entered
;
	pushf
	cmp	ss:[redir_patch],0
	jz	@f
	popff

        PUSH    AX
if	DEBUG
	SAVE	<ds>
	GETDSEG DS
	fmt	TypSect,LevReq,<"PDB $x leaving DEV">,<CurrentPDB>
	RESTORE <ds>
    ASSUME DS:nothing
endif
	MOV     AX,8100h+critDevice
	INT     int_ibm
	POP     AX
	return
@@:
	popff
	ret

EndProc LcritDevice

DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dinfo.asm ===
TITLE	DISK_INFO - Internal Get Disk Info
	NAME	DISK_INFO

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level routine for returning disk drive information from a local
;	  or NET device
;
;	DISK_INFO
;
;	  Modification history:
;
;		Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include dpb.inc
	include bugtyp.inc
	.cref
	.list

Installed = TRUE

	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	EXTERR_LOCUS,BYTE

DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE


	Break	<DISK_INFO -- Get Disk Drive Information>
;---------------------------------------------------------------------------
; 
; Procedure Name : DISK_INFO
;
; Inputs:
;	[THISCDS] Points to the Macro List Structure of interest
;		(It MAY NOT be NUL, error not detected)
; Function:
;	Get Interesting Drive Information
; Returns:
;	DX = Number of free allocation units
;	BX = Total Number of allocation units on disk
;	CX = Sector size
;	AL = Sectors per allocation unit
;	AH = FAT ID BYTE
;	Carry set if error (currently user FAILed to I 24)
; Segs except ES preserved, others destroyed
;----------------------------------------------------------------------------

;hkn; called from getset.asm and misc.asm. DS has already been set up to 
;hkn; DOSDATA. 

	procedure   DISK_INFO,NEAR
	DOSAssume   <DS>,"Disk_Info"
	ASSUME	ES:NOTHING

	Invoke	TestNet
	JNC	LOCAL_INFO
IF NOT Installed
	transfer NET_DISK_INFO
ELSE
	MOV	AX,(multNET SHL 8) OR 12
	INT	2FH
	return
ENDIF

LOCAL_INFO:
	MOV	[EXTERR_LOCUS],errLOC_Disk
	EnterCrit   critDisk
	invoke	FATREAD_CDS		; perform media check.
	JC	CRIT_LEAVE
	MOV	BX,2
	invoke	UNPACK			; Get first FAT sector into CURBUF
	JC	CRIT_LEAVE
	LDS	SI,[CURBUF]
ASSUME	DS:NOTHING
	MOV	AH,[SI].bufinsiz	; get FAT ID BYTE

;hkn; SS is DOSDATA
	context DS
	MOV	CX,ES:[BP.dpb_max_cluster]
;
; Examine the current free count.  If it indicates that we have an invalid
; count, do the expensive calculation.
;
	MOV	DX,ES:[BP.dpb_free_cnt] ; get free count
	CMP	DX,-1			; is it valid?
	JZ	DoScan
;
; Check to see if it is in a reasonalbe range.	If so, trust it and return.
; Otherwise, we need to blast out an internal error message and then recompute
; the count.
;
	CMP	DX,CX			; is it in a reasonable range?
	JB	GotVal			; yes, trust it.
	fmt	TypInt,LevLog,<"Internal error: MaxClus <= FreeClus\n">
DoScan:
	XOR	DX,DX
	DEC	CX
SCANFREE:
	invoke	UNPACK
	JC	Crit_Leave
	JNZ	NOTFREECLUS
	INC	DX			; A free one
NOTFREECLUS:
	INC	BX			; Next cluster
	LOOP	SCANFREE
	DEC	BX			; BX was next cluster.	Convert to
ReturnVals:
	DEC	BX			; count
	MOV	AL,ES:[BP.dpb_cluster_mask]
	INC	AL			; Sectors/cluster
	MOV	CX,ES:[BP.dpb_sector_size]  ; Bytes/sector
	MOV	ES:[BP.dpb_free_cnt],DX
	CLC
CRIT_LEAVE:
	LeaveCrit   critDisk
	return
;
; We have correctly computed everything previously.  Load up registers for
; return.
;
GotVal: MOV	BX,CX			; get cluster count
	JMP	ReturnVals

EndProc DISK_INFO

DOSCODE	ENDS
    END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dir.asm ===
TITLE	DIR - Directory and path cracking
	NAME	Dir

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Main Path cracking routines, low level search routines
;
;	  FindEntry
;	  SEARCH
;	  Srch
;	  NEXTENT
;	  MetaCompare
;	  NEXTENTRY
;	  GETENTRY
;	  GETENT
;	  SETDIRSRCH
;	  SETROOTSRCH
;
;	  Revision history:
;
;		A000   version 4.00    Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include fastopen.inc
	include dossym.inc
	include dpb.inc
	.cref
	.list


	i_need	EntFree,WORD
	i_need	DirStart,WORD
	i_need	LastEnt,WORD
	i_need	ClusNum,WORD
	i_need	CurBuf,DWORD
	i_need	Attrib,BYTE
	i_need	DelAll,BYTE
	i_need	VolID,BYTE
	i_need	Name1,BYTE
	i_need	ThisDPB,DWORD
	i_need	EntLast,WORD
	i_need	Creating,BYTE
	i_need	SecClusPos,BYTE
	i_need	ClusFac,BYTE
	i_need	NxtClusNum,WORD
	i_need	DirSec,DWORD			;AN000;
	I_need	FastOpenFlg,BYTE		;AN000;
	I_need	HIGH_SECTOR,WORD		;AN000;


DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<FINDENTRY -- LOOK FOR AN ENTRY>
;---------------------------------------------------------------------------
;
; Procedure Name : FINDENTRY,SEARCH
;
; Inputs:
;	[THISDPB] set
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Starting directory sector number
;	[CLUSNUM] = Next cluster of directory
;	[CLUSFAC] = Sectors/Cluster
;	[NAME1] = Name to look for
; Function:
;	Find file name in disk directory.
;	"?" matches any character.
; Outputs:
;	Carry set if name not found
;	ELSE
;	Zero set if attributes match (always except when creating)
;	AH = Device ID (bit 7 set if not disk)
;	[THISDPB] = Base of drive parameters
;	DS = DOSGROUP
;	ES = DOSGROUP
;	[CURBUF+2]:BX = Pointer into directory buffer
;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
;	[CURBUF] has directory record with match
;	[NAME1] has file name
;	[LASTENT] is entry number of the entry
; All other registers destroyed.
;----------------------------------------------------------------------------

;hkn; called from rename.asm and dir2.asm. DS must be already set up at
;hkn; this point.

procedure   SEARCH,near
entry	FindEntry
	DOSAssume   <DS>,"FindEntry"

	invoke	STARTSRCH
	MOV	AL,Attrib
	AND	AL,NOT attr_ignore	; Ignore useless bits
	CMP	AL,attr_volume_id	; Looking for vol ID only ?
	JNZ	NOTVOLSRCH		; No
	CALL	SETROOTSRCH		; Yes force search of root
NOTVOLSRCH:
	CALL	GETENTRY
	JNC	Srch
	JMP	SETESRET

	entry	Srch


	PUSH	DS
	MOV	DS,WORD PTR [CURBUF+2]
ASSUME	DS:NOTHING

;	(DS:bx) = directory entry address

	MOV	AH,DIR_NAME[BX]
	OR	AH,AH			; End of directory?
	JZ	FREE

;hkn; SS override
	CMP	AH,DelAll		; Free entry?
	JZ	FREE
	TEST	DIR_ATTR[BX],attr_volume_id	; Volume ID file?
	JZ	CHKFNAM 		; NO

;hkn; SS override
	INC	BYTE PTR [VOLID]
CHKFNAM:
;	Context ES

;hkn;	ASSUME	ES:DOSGroup
	ASSUME	ES:DOSDATA

	MOV	SI,SS
	MOV	ES,SI
	MOV	SI,BX

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
;;;;; 7/29/86

;hkn; SS override for NAME1
	CMP	BYTE PTR [NAME1],0E5H	 ; special char check
	JNZ	NO_E5
	MOV	BYTE PTR [NAME1],05H
NO_E5:
;;;;; 7/29/86
	CALL	MetaCompare
	JZ	FOUND
	POP	DS

entry	NEXTENT
	DOSAssume   <DS>,"NextEnt"

	Assert	ISDPB,<<WORD PTR THISDPB+2>,<WORD PTR THISDPB>>,"NextEnt"
	LES	BP,[THISDPB]
ASSUME	ES:NOTHING
	CALL	NEXTENTRY
	JNC	SRCH
	JMP	SHORT SETESRET

FREE:
	POP	DS
	DOSAssume   <DS>,"Free"
	MOV	CX,LASTENT
	CMP	CX,ENTFREE
	JAE	TSTALL
	MOV	ENTFREE,CX
TSTALL:
	CMP	AH,DelAll		; At end of directory?
NextEntJ:
	je	NEXTENT 		; No - continue search
	MOV	[ENTLAST],CX
	STC
	JMP	SHORT SETESRET

FOUND:
;
; We have a file with a matching name.	We must now consider the attributes:
; ATTRIB	Action
; ------	------
; Volume_ID	Is Volume_ID in test?
; Otherwise	If no create then Is ATTRIB+extra superset of test?
;		If create then Is ATTRIB equal to test?
;
	MOV	CH,[SI] 		; Attributes of file
	POP	DS
	DOSAssume   <DS>,"found"
	MOV	AH,Attrib		; Attributes of search
	AND	AH,NOT attr_ignore
	LEA	SI,[SI+Dir_First-Dir_Attr]  ; point to firclus field
	TEST	CH,attr_volume_id	; Volume ID file?
	JZ	check_one_volume_id	; Nope check other attributes
	TEST	AH,attr_volume_id	; Can we find Volume ID?
	JZ	NEXTENTJ		; Nope, (not even $FCB_CREATE)
	XOR	AH,AH			; Set zero flag for $FCB_CREATE
	JMP	SHORT RETFF		; Found Volume ID
check_one_volume_id:
	CMP	AH,attr_volume_id	; Looking only for Volume ID?
	JZ	NEXTENTJ		; Yes, continue search
	invoke	MatchAttributes
	JZ	RETFF
	TEST	BYTE PTR [CREATING],-1	; Pass back mismatch if creating
	JZ	NEXTENTJ		; Otherwise continue searching
RETFF:
	LES	BP,[THISDPB]
	MOV	AH,ES:[BP.dpb_drive]
SETESRET:
	PUSH	SS
	POP	ES
	return
EndProc Search

;----------------------------------------------------------------------------
;
; Procedure Name : MetaCompare
;
; Inputs:
;	DS:SI -> 11 character FCB style name NO '?'
;	    Typically this is a directory entry.  It MUST be in upper case
;	ES:DI -> 11 character FCB style name with possible '?'
;	    Typically this is a FCB or SFT.  It MUST be in upper case
; Function:
;	Compare FCB style names allowing for ? match to any char
; Outputs:
;	Zero if match else NZ
; Destroys CX,SI,DI all others preserved
;----------------------------------------------------------------------------

	procedure   MetaCompare,near
	MOV	CX,11
 IFDEF  DBCS				;AN000;
;-------------------- Start of DBCS	;AN000;
	CMP	BYTE PTR DS:[SI],05H	;AN000;; Special case for lead byte of 05h
	JNE	WILDCRD2		;AN000;; Compare as normal if not an 05h
	CMP	BYTE PTR ES:[DI],0E5H	;AN000;; 05h and 0E5h equivalent for lead byte
	JNE	WILDCRD2		;AN000;; Compare as normal if not an 05h
	DEC	CX			;AN000;; One less byte to compare
	INC	SI			;AN000;; Bypass lead byte in source and
	INC	DI			;AN000;;  destination when 05h and 0E5h found.
WILDCRD2:				;AN000;
	PUSH	AX			;AN000;;KK. save ax
cagain: 				;AN000;;KK.
	CMP	CX,0			;AN000;;KK. end of compare ?
	JLE	metaend2		;AN000;;KK. yes
	MOV	AL,[SI] 		;AN000;;KK. is it a Kanji
	invoke	testkanj		;AN000;;KK.
	JZ	notdb			;AN000;;KK. no
	MOV	AX,'??'                 ;AN000;;KK.
	CMP	ES:[DI],AX		;AN000;;KK. is es:di pointing to '??'
	JNZ	metaend3		;AN000;;KK. no
	ADD	SI,2			;AN000;;KK.
	ADD	DI,2			;AN000;;KK. update pointers and count
subcx:					;AN000;
	SUB	CX,2			;AN000;;KK.
	JMP	cagain			;AN000;;KK.
metaend3:				;AN000;;KK.
	CMPSW				;AN000;;KK.
	JNZ	metaend2		;AN000;;KK.
	JMP	subcx			;AN000;;KK.
notdb:					;AN000;
	CMPSB				;AN000;;KK. same code ?
	JZ	sameco			;AN000;;KK. yes
	CMP	BYTE PTR ES:[DI-1],"?"  ;AN000;;KK. ?
	JNZ	metaend2		;AN000;;KK. no
sameco: 				;AN000;
	DEC	CX			;AN000;;KK. decrement count
	JMP	cagain			;AN000;;KK.

metaend2:				;AN000;
	POP	AX			;AN000;;KK.
;-------------------- End of DBCS	;AN000; KK.
 ELSE					;AN000;
WILDCRD:
	REPE	CMPSB
	JZ	MetaRet 		; most of the time we will fail.
CHECK_META:
	CMP	BYTE PTR ES:[DI-1],"?"
	JZ	WildCrd
MetaRet:
 ENDIF					;AN000;
	return				; Zero set, Match
EndProc MetaCompare

Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
;----------------------------------------------------------------------------
;
; Procedure Name : NEXTENTRY
;
; Inputs:
;	Same as outputs of GETENTRY, above
; Function:
;	Update BX, and [LASTENT] for next directory entry.
;	Carry set if no more.
;----------------------------------------------------------------------------

Procedure NextEntry
	DOSAssume   <DS>,"NextEntry"

	MOV	AX,[LASTENT]
	CMP	AX,[ENTLAST]
	JZ	NONE
	INC	AX
	LEA	BX,[BX+32]
	CMP	BX,DX
	JB	HAVIT
	MOV	BL,BYTE PTR [SECCLUSPOS]
	INC	BL
	CMP	BL,BYTE PTR [CLUSFAC]
	JB	SAMECLUS
	MOV	BX,[NXTCLUSNUM]
	Invoke	IsEOF
	JAE	NONE
	CMP	BX,2
	JB	NONE
	JMP	short GETENT

NONE:
	STC
	return

HAVIT:
	MOV	[LASTENT],AX
	CLC
	return

SAMECLUS:
	MOV	BYTE PTR [SECCLUSPOS],BL
	MOV	[LASTENT],AX
	PUSH	DS
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	MOV	DX,WORD PTR [DI.buf_sector+2]	;AN000; >32mb

;hkn; SS override
	MOV	[HIGH_SECTOR],DX		;AN000; >32mb
	MOV	DX,WORD PTR [DI.buf_sector]	;AN000; >32mb

	ADD	DX,1				;AN000; >32mb
	ADC	[HIGH_SECTOR],0 		;AN000; >32mb
	POP	DS
	DOSAssume   <DS>,"SameClus"
	invoke	FIRSTCLUSTER
	XOR	BX,BX
	JMP	short SETENTRY

EndProc NextEntry

;----------------------------------------------------------------------------
;
; Procedure Name : GETENTRY
;
; Inputs:
;	[LASTENT] has directory entry
;	ES:BP points to drive parameters
;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
; Function:
;	Locates directory entry in preparation for search
;	GETENT provides entry for passing desired entry in AX
; Outputs:
;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
;	[LASTENT] = New directory entry number
;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
;	Carry set if error (currently user FAILed to I 24)
;----------------------------------------------------------------------------

Procedure GETENTRY,NEAR
	DOSAssume   <DS>,"GetEntry"

	MOV	AX,[LASTENT]

	entry	GETENT

	Assert	ISDPB,<ES,BP>,"GetEntry/GetEnt"
	MOV	[LASTENT],AX
;
; Convert the entry number in AX into a byte offset from the beginning of the
; directory.
;
	mov	cl,5			; shift left by 5 = mult by 32
	rol	ax,cl			; keep hight order bits
	mov	dx,ax
	and	ax, NOT (32-1)		; mask off high order bits
	and	dx, 32-1		; mask off low order bits
;
; DX:AX contain the byte offset of the required directory entry from the
; beginning of the directory.  Convert this to a sector number.  Round the
; sector size down to a multiple of 32.
;
	MOV	BX,ES:[BP.dpb_sector_size]
	AND	BL,255-31		; Must be multiple of 32
	DIV	BX
	MOV	BX,DX			; Position within sector
	PUSH	BX
	invoke	DIRREAD
	POP	BX
	retc
SETENTRY:
	MOV	DX,WORD PTR [CURBUF]
	ADD	DX,BUFINSIZ
	ADD	BX,DX
	ADD	DX,ES:[BP.dpb_sector_size]  ; Always clears carry
	return
EndProc GetEntry

Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
;----------------------------------------------------------------------------
;
; Procedure Name : SETDIRSRCH,SETROOTSRCH
;
; Inputs:
;	BX cluster number of start of directory
;	ES:BP Points to DPB
;	DI next cluster number from fastopen extended info. DOS 3.3 only
; Function:
;	Set up a directory search
; Outputs:
;	[DIRSTART] = BX
;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
;	Carry set if error (currently user FAILed to I 24)
; destroys AX,DX,BX
;----------------------------------------------------------------------------

procedure SETDIRSRCH
	DOSAssume   <DS>,"SetDirSrch"

	Assert	ISDPB,<ES,BP>,"SetDirSrch"
	OR	BX,BX
	JZ	SETROOTSRCH
	MOV	[DIRSTART],BX
	MOV	AL,ES:[BP.dpb_cluster_mask]
	INC	AL
	MOV	BYTE PTR [CLUSFAC],AL
; DOS 3.3 for FastOPen	F.C. 6/12/86
	SAVE	<SI>
	TEST	[FastOpenFlg],Lookup_Success
	JNZ	UNP_OK

; DOS 3.3 for FastOPen	F.C. 6/12/86
	invoke	UNPACK
	JNC	UNP_OK
	RESTORE <SI>
	return

UNP_OK:
	MOV	[CLUSNUM],DI
	MOV	DX,BX
	XOR	BL,BL
	MOV	BYTE PTR [SECCLUSPOS],BL
	invoke	FIGREC
	RESTORE <SI>
	PUSH	DX			   ;AN000; >32mb
	MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
	MOV	WORD PTR [DIRSEC+2],DX	   ;AN000; >32mb
	POP	DX			   ;AN000; >32mb
	MOV	WORD PTR [DIRSEC],DX
	CLC
	return

entry	SETROOTSRCH
	DOSAssume   <DS>,"SetRootSrch"
	ASSUME	ES:NOTHING
	XOR	AX,AX
	MOV	[DIRSTART],AX
	MOV	BYTE PTR [SECCLUSPOS],AL
	DEC	AX
	MOV	[CLUSNUM],AX
	MOV	AX,ES:[BP.dpb_first_sector]
	MOV	DX,ES:[BP.dpb_dir_sector]
	SUB	AX,DX
	MOV	BYTE PTR [CLUSFAC],AL
	MOV	WORD PTR [DIRSEC],DX		      ;F.C. >32mb
	MOV	WORD PTR [DIRSEC+2],0		      ;F.C. >32mb
	CLC
	return
EndProc SETDIRSRCH,NoCheck

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\delete.asm ===
TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
	NAME	DOS_DELETE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	DELETE.ASM - Low level routine for deleting files
;
;		DOS_DELETE
;		REN_DEL_Check
;		FastOpen_Delete	       ; DOS 3.3
;		FastOpen_Update	       ; DOS 3.3


;   Revision history:
;
;   A000  version 4.00	Jan. 1988
;   A001  Fastopen Rename fix	April 1989

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE FASTOPEN.INC
	include sf.inc
	include filemode.inc
	include mult.inc
	include dpb.inc
	INCLUDE fastxxxx.inc
	.cref
	.list

Installed = TRUE

	i_need	NoSetDir,BYTE
	i_need	Creating,BYTE
	i_need	DELALL,BYTE
	i_need	THISDPB,DWORD
	i_need	THISSFT,DWORD
	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	ATTRIB,BYTE
	i_need	SATTRIB,BYTE
	i_need	WFP_START,WORD
	i_need	REN_WFP,WORD			 ;BN001
	i_need	NAME1,BYTE			 ;BN001
	i_need	FoundDel,BYTE
	i_need	AUXSTACK,BYTE
	i_need	VOLCHNG_FLAG,BYTE
	i_need	JShare,DWORD
	i_need	FastOpenTable,BYTE		  ; DOS 3.3
	i_need	FastTable,BYTE			  ; DOS 4.00



	i_need	Del_ExtCluster,WORD		  ; DOS 4.00

	i_need	SAVE_BX,WORD			  ; DOS 4.00
	i_need	DMAADD,DWORD
	i_need	RENAMEDMA,BYTE

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

;---------------------------------------------------------------------------
;
; Procedure Name : DOS_DELETE
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Delete the specified file(s)
; Outputs:
;	CARRY CLEAR
;		OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to delete device or directory
;		***error_sharing_violation***
;			Deny both access required, generates an INT 24.
;			This error is NOT returned. The INT 24H is generated,
;			  and the file is ignored (not deleted). Delete will
;			  simply continue on looking for more files.
;			  Carry will NOT be set in this case.
; DS preserved, others destroyed
;---------------------------------------------------------------------------

FILEFOUND   = 01h
FILEDELETED = 10h

procedure   DOS_DELETE,NEAR

;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
;hkn; appropriately at this point.

	DOSAssume   <DS>,"DOS_Delete"

	Invoke	TestNet
	JNC	LOCAL_DELETE

IF NOT Installed
	transfer NET_DELETE
ELSE
	MOV	AX,(multNET SHL 8) OR 19
	INT	2FH
	return
ENDIF

LOCAL_DELETE:
	MOV	FoundDel,00	; No files found and no files deleted
	EnterCrit   critDisk
	MOV	WORD PTR [CREATING],DIRFREE*256+0	; Assume not del *.*
	MOV	SI,[WFP_START]
SKPNUL:
	LODSB
	OR	AL,AL
	JNZ	SKPNUL			    ; go to end
	SUB	SI,4			    ; Back over possible "*.*"
	CMP	WORD PTR [SI],("." SHL 8 OR "*")
	JNZ	TEST_QUEST
	CMP	BYTE PTR [SI+2],"*"
	JZ	CHECK_ATTS
TEST_QUEST:
	SUB	SI,9		; Back over possible "????????.???"
	XCHG	DI,SI

;hkn; SS is DOSDATA
	context ES

	MOV	AX,"??"
	MOV	CX,4		; four sets of "??"
	REPE	SCASW
	JNZ	NOT_ALL
	XCHG	DI,SI
	LODSW
	CMP	AX,("?" SHL 8) OR "."
	JNZ	NOT_ALL
	LODSW
	CMP	AX,"??"
	JNZ	NOT_ALL
CHECK_ATTS:
	MOV	AL,BYTE PTR [SATTRIB]
	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; Look only at hidden bits
	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; All must be set
	JNZ	NOT_ALL

; NOTE WARNING DANGER-----
;    This DELALL stuff is not safe. It allows directories to be deleted.
;	It should ONLY be used by FORMAT in the ROOT directory.
;

	MOV	DELALL,0	     ; DEL *.* - flag deleting all
NOT_ALL:
	MOV	[NoSetDir],1
	invoke	GetPathNoSet
	ASSUME	ES:NOTHING
	JNC	Del_found
	JNZ	bad_path
	OR	CL,CL
	JZ	bad_path
No_file:
	MOV	AX,error_file_not_found
ErrorReturn:
	STC
	LeaveCrit   critDisk
	return

bad_path:
	MOV	AX,error_path_not_found
	JMP	ErrorReturn

Del_found:
	JNZ	NOT_DIR 		; Check for dir specified
	CMP	DelAll,0		; DelAll = 0 allows delete of dir.
	JZ	Not_Dir
Del_access_err:
	MOV	AX,error_access_denied
	JMP	ErrorReturn

NOT_DIR:
	OR	AH,AH		; Check if device name
	JS	Del_access_err	; Can't delete I/O devices

; Main delete loop.  CURBUF+2:BX points to a matching directory entry.

DELFILE:
	OR	FoundDel,FILEFOUND	; file found, not deleted yet

; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
; DOS issue a build BPB call the next time this drive is accessed.

	PUSH	DS
	MOV	AH,DelAll
	LDS	DI,CURBUF
	ASSUME	DS:NOTHING

;hkn; SS override
	TEST	Attrib,attr_read_only	; are we deleting RO files too?
	JNZ	DoDelete		; yes

	TEST	DS:[BX.dir_attr],attr_read_only
	JZ	DoDelete		; not read only

	POP	DS
	JMP	SHORT DelNxt		; Skip it (Note ES:BP not set)

DoDelete:
	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
	JNC	DEL_SHARE_OK
	POP	DS
	JMP	SHORT DelNxt		; Skip it

DEL_SHARE_OK:
	Assert	ISBUF,<DS,DI>,"Del_Share_OK"
	TEST	[DI.buf_flags],buf_dirty  ;LB. if already dirty 		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	[DI.buf_flags],buf_dirty
yesdirty:
	MOV	[BX].DIR_NAME,AH	; Put in E5H or 0
	MOV	BX,[SI] 		; Get firclus pointer
	POP	DS
	DOSAssume   <DS>,"Del_Share_OK"
	OR	[FoundDel],FILEDELETED	; Deleted file

	CMP	BX,2
	JB	DELNXT			; File has invalid FIRCLUS (too small)
	CMP	BX,ES:[BP.dpb_max_cluster]
	JA	DELNXT			; File has invalid FIRCLUS (too big)

	invoke	RELEASE 		; Free file data
	JC	No_fileJ

; DOS 3.3  FastOpen

	CALL	FastOpen_Delete 	; delete the dir info in fastopen


; DOS 3.3  FastOpen

DELNXT:
	LES	BP,[THISDPB]		; Possible to get here without this set
	invoke	GETENTRY		; Registers need to be reset
	JC	No_fileJ
	invoke	NEXTENT
	DLJNC	DELFILE
	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
	MOV	AL,ES:[BP.dpb_drive]
	invoke	FLUSHBUF
	JC	No_fileJ
;
; Now we need to test FoundDel for our flags.  The cases to consider are:
;
;   not found not deleted		file not found
;   not found	  deleted		*** impossible ***
;	found not deleted		access denied (read-only)
;	found	  deleted		no error
;
	TEST	FoundDel,FILEDELETED	; did we delete a file?
	JZ	DelError		; no, figure out what's wrong.
; We set VOLCHNG_FLAG to indicate that we have changed the volume label
; and to force the DOS to issue a media check.
	TEST	[Attrib],attr_volume_id
	jz	No_Set_Flag
	PUSH	AX
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
ASSUME	ES:NOTHING
	MOV	AH,BYTE PTR ES:[DI]	; Get drive
	SUB	AH,'A'                  ; Convert to 0-based
	mov	byte ptr [VOLCHNG_FLAG],AH
	XOR	BH,BH			;>32mb delte volume id from boot record ;AN000;
	invoke	Set_Media_ID		;>32mb set voulme id to boot record	;AN000;
	invoke	FATRead_CDS		; force media check
	POP	DI
	POP	ES
	POP	AX
No_Set_Flag:
	LeaveCrit   critDisk		; carry is clear
	return
DelError:
	TEST	FoundDel,FILEFOUND	; not deleted.	Did we find file?
	JNZ	Del_access_errJ 	; yes. Access denied
No_fileJ:
	JMP	No_file 		; Nope
Del_Access_errJ:
	JMP	Del_access_err

EndProc DOS_DELETE

Break	<REN_DEL_Check - check for access for rename and delete>
;-----------------------------------------------------------------------------
; Procedure Name : REN_DEL_Check
;
; Inputs:
;	[THISDPB] set
;	[CURBUF+2]:BX points to entry
;	[CURBUF+2]:SI points to firclus field of entry
;	[WFP_Start] points to name
; Function:
;	Check for Exclusive access on given file.
;	  Used by RENAME, SET_FILE_INFO, and DELETE.
; Outputs:
;	ES:BP = [THISDPB]
;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
;		last element will be loaded from the directory entry.  This is
;		so the name given to the sharer doesn't have any meta chars in
;		it.
;	Carry set if sharing violation, INT 24H generated
;	    NOTE THAT AX IS NOT error_sharing_violation.
;		This is because input AX is preserved.
;		Caller must set the error if needed.
;	Carry clear
;		OK
; AX,DS,BX,SI,DI preserved
;----------------------------------------------------------------------------

procedure  REN_DEL_Check,NEAR

	PUSH	DS
	PUSH	DI
	PUSH	AX
	PUSH	BX
	PUSH	SI		; Save CURBUF pointers
	context ES

;hkn; context ES will assume ES to DOSDATA
;hkn; ASSUME	ES:DOSGROUP

;hkn; SS override
	MOV	DI,[WFP_START]	; ES:DI -> WFP
	MOV	SI,BX

;hkn; SS override
	MOV	DS,WORD PTR [CURBUF+2]	; DS:SI -> entry (FCB style name)
	MOV	BX,DI		; Set backup limit for skipback
	ADD	BX,2		; Skip over d: to point to leading '\'
	invoke	StrLen		; CX is length of ES:DI including NUL
	DEC	CX		; Don't include nul in count
	ADD	DI,CX		; Point to NUL at end of string
	invoke	SkipBack	; Back up one element
	INC	DI		; Point to start of last element

;hkn; SS override
	MOV	[SAVE_BX],DI	;IFS. save for DOS_RENAME			   ;AN000;
	invoke	PackName	; Transfer name from entry to ASCIZ tail.
	POP	SI		; Get back entry pointers
	POP	BX
	PUSH	BX
	PUSH	SI		; Back on stack
	context DS

;hkn; context DS will assume ES to DOSDATA
;hkn; ASSUME	DS:DOSGROUP

;
; Close the file if possible by us.
;
if installed
	Call	JShare + 13 * 4
else
	Call	ShCloseFile
endif
	MOV	WORD PTR [THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	MOV	WORD PTR [THISSFT],OFFSET DOSDATA:AUXSTACK - (SIZE sf_entry)
				; Scratch space
	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
	invoke	DOOPEN		; Fill in SFT for share check
	LES	DI,[THISSFT]
	MOV	ES:[DI.sf_mode],sharing_deny_both   ; requires exclusive access
	MOV	ES:[DI.sf_ref_count],1	; Pretend open
	invoke	ShareEnter
	jc	CheckDone
	LES	DI,[THISSFT]
	MOV	ES:[DI.sf_ref_count],0	; Pretend closed and free
	invoke	SHAREEND		; Tell sharer we're done with THISSFT
	CLC
CheckDone:
	LES	BP,[THISDPB]
	POP	SI
	POP	BX
	POP	AX
	POP	DI
	POP	DS
	return

EndProc REN_DEL_Check

Break	<FastOpen_Delete - delete dir info in fastopen>
;--------------------------------------------------------------------------
; Procedure Name : FastOpen_Delete
; Inputs:
;	None
; Function:
;	Call FastOpen to delete the dir info.
; Outputs:
;	None
;
;---------------------------------------------------------------------------

procedure  FastOpen_Delete,NEAR
	PUSHF			; save flag
	PUSH	SI		; save registers
	PUSH	BX
	PUSH	AX

;hkn; SS override
	MOV	SI,[WFP_Start]			       ; ds:si points to path name
	MOV	AL,FONC_delete			       ; al = 3
fastinvoke:

;hkn; FastTable is in DOSDATA
	MOV	BX,OFFSET DOSDATA:FastTable + 2
	CALL	DWORD PTR [BX]			       ; call fastopen

	POP	AX		; restore registers
	POP	BX
	POP	SI
	POPF			; restore flag
	return
EndProc FastOpen_Delete


Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622

;------------------------------------------------------------------------------
;
; PROCEDURE Name : FastOpen_Rename
;
; Inputs:
;	 REN_WFP   = Path Name
;	 NAME1	   = New Name
; Function:
;	Call FastOpen to rename the dir entry in the cache
; Outputs:
;	None
;------------------------------------------------------------------------------

PROCEDURE FastOpen_Rename,NEAR

	PUSHF			;AN001 save flag
	PUSH	SI		;;AN001  save registers
	PUSH	DI		;AN001
	PUSH	BX		;AN001
	PUSH	AX		;AN001

;hkn; SS override
	MOV	SI,[REN_WFP]	;AN001		     ;;AN001  ds:si-->Path name addrs

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1	     ;;AN001  ds:di-->New name addrs
;	MOV	AL,FONC_Rename			     ;;AN001  al = 3
	MOV	AL,6				     ;;AN001  al = 3

;hkn; FastTable is in DOSDATA
	MOV	BX,OFFSET DOSDATA:FastTable + 2
	CALL	DWORD PTR [BX]			     ;;AN001  call fastopen

	POP	AX		; restore registers  ;AN001
	POP	BX				     ;AN001
	POP	DI				     ;AN001
	POP	SI				     ;AN001
	POPF			; restore flag	     ;AN001
	return					     ;AN001
EndProc FastOpen_Rename


Break	<FastOpen_Update - update dir info in fastopen>
;-----------------------------------------------------------------------------
;
; Procedure Name : FastOpen_Update
;
; Inputs:
;	DL     drive number (A=0,B=1,,,)
;	CX     first cluster #
;	AH     0 updates dir entry
;	       1 updates CLUSNUM  , BP = new CLUSNUM
;	ES:DI  directory entry
; Function:
;	Call FastOpen to update the dir info.
; Outputs:
;	None
;
;----------------------------------------------------------------------------

procedure  FastOpen_Update,NEAR
	PUSHF			; save flag
	PUSH	SI
	PUSH	BX		; save regs
	PUSH	AX

	MOV	AL,FONC_update			       ; al = 4
	JMP	fastinvoke

EndProc FastOpen_Update




ASSUME	DS:NOTHING,ES:NOTHING							;AN000;


entry Fast_Dispatch			      ; future fastxxxx entry		;AN000;

;hkn; FastTable is in DOSDATA
	MOV	SI,OFFSET DOSDATA:FastTable + 2	; index to the		;AN000;


;hkn; use SS override
	CALL	DWORD PTR SS:[SI]			; RMFD call fastopen
	return

;
DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\create.asm ===
TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
NAME	DOS_CREATE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Internal Create and Create new to create a local or NET file and SFT.
;
;	DOS_CREATE
;	DOS_CREATE_NEW
;	SET_MKND_ERR
;	SET_Media_ID
;	SET_EXT_Mode
;
;	Revision history:
;
;	    A000 version 4.00	  Jan. 1988
;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include mult.inc
	include filemode.inc
	include curdir.inc
	.cref
	.list

Installed = TRUE

	i_need	THISSFT,DWORD
	i_need	THISCDS,DWORD
	I_need	EXTERR,WORD
	I_Need	ExtErr_locus,BYTE
	I_need	JShare,DWORD
	I_need	VOLCHNG_FLAG,BYTE
	I_need	SATTRIB,BYTE
	I_need	CALLVIDM,DWORD
	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
	I_need	NAME1,BYTE			  ;AN000;
	I_need	NO_NAME_ID,BYTE 		  ;AN000;
	I_need	Packet_Temp,WORD		  ;AN000;
	I_need	DOS34_FLAG,WORD 		  ;AN000;
	I_need	SAVE_BX,WORD			  ;AN000;


DOSCODE SEGMENT
	ASSUME	CS:DOSCODE


;***	DOS_CREATE - Create a File
;
;	DOS_Create is called to create the specified file, truncating
;	the old one if it exists.
;
;
;	ENTRY	AX is Attribute to create
;		(ds) = DOSDATA
;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;			terminated)
;		[CURR_DIR_END] Points to end of Current dir part of string
;			( = -1 if current dir not involved, else
;			 Points to first char after last "/" of current dir part)
;		[THISCDS] Points to CDS being used
;			(Low word = -1 if NUL CDS (Net direct request))
;		[THISSFT] Points to SFT to fill in if file created
;			(sf_mode field set so that FCB may be detected)
;		[SATTRIB] Is attribute of search, determines what files can be found
;
;	EXIT	sf_ref_count is NOT altered
;		CARRY CLEAR
;		    THISSFT filled in.
;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
;		CARRY SET
;		    AX is error code
;			error_path_not_found
;				Bad path (not in curr dir part if present)
;			error_bad_curr_dir
;				Bad path in current directory part of path
;			error_access_denied
;				Attempt to re-create read only file , or
;				create a second volume id or create a dir
;			error_sharing_violation
;				The sharing mode was correct but not allowed
;				generates an INT 24
;	USES	all but DS

procedure   DOS_Create,NEAR

;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
;hkn; this point.

	DOSAssume   <DS,SS>,"DOS_Create"

	XOR	AH,AH		; Truncate is OK

;	Enter here from Dos_Create_New
;
;	(ah) = 0 iff truncate OK

Create_inter:
	TEST	AL,NOT (attr_all + attr_ignore + attr_volume_id)
				; Mask out any meaningless bits
	JNZ	AttErr
	TEST	AL,attr_volume_id
	JZ	NoReset
	OR	[DOS34_FLAG],DBCS_VOLID      ;AN000;FOR dbcs volid
	MOV	AL,attr_volume_id
NoReset:
	OR	AL,attr_archive ; File changed
	TEST	AL,attr_directory + attr_device
	JZ	ATT_OK
AttErr:
	MOV	AX,5		; Attribute problem
	MOV	Exterr_Locus,errLOC_Unk
	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
				   ;	attr_device to be set.
ATT_OK:
	LES	DI,[THISSFT]
	PUSH	ES
	LES	SI,[THISCDS]
	CMP	SI,-1
	JNE	TEST_RE_NET

;	No CDS, it must be redirected.

	POP	ES

;Extended open hooks
	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extnded open
	JZ	NOEXTOP 		    ;AN000;EO. no, do normal
IFS_extopen:				    ;AN000;EO.
	PUSH	AX			    ;AN000;EO. pass create attr
	MOV	AX,(multNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
	INT	2FH			    ;AN000;EO.
	POP	BX			    ;AN000;EO. trash bx
	MOV	[EXTOPEN_ON],0		    ;AN000;EO.
	return				    ;AN000;EO.
NOEXTOP:				    ;AN000;
;Extended open hooks

IF NOT Installed
	transfer NET_SEQ_CREATE
ELSE
	PUSH	AX
	MOV	AX,(multNET SHL 8) OR 24
	INT	2FH
	POP	BX			; BX is trashed anyway
	return
ENDIF

;	We have a CDS.	See if it's network

TEST_RE_NET:
	TEST	ES:[SI.curdir_flags],curdir_isnet
	POP	ES
	JZ	LOCAL_CREATE

	CALL	Set_EXT_mode		    ;AN000;EO.
	JC	SHORT dochk		    ;AN000;EO.
	OR	ES:[DI.sf_mode],sharing_compat + open_for_both ;IFS.

;Extended open hooks

dochk:
	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extnded open
	JNZ	IFS_extopen		    ;AN000;EO. yes, issue extended open
;Extended open hooks

IF NOT Installed
	transfer NET_CREATE
ELSE
	PUSH	AX
	MOV	AX,(multNET SHL 8) OR 23
	INT	2FH
	POP	BX			; BX is trashed anyway
nomore:
	return
ENDIF


;**	It's a local create.  We have a local CDS for it.

LOCAL_CREATE:
	CALL	Set_EXT_mode	       ;AN000;EO. set mode if from extended open
	JC	setdone 	       ;AN000;EO.
	OR	ES:[DI].sf_mode,sharing_compat+open_for_both
setdone:
	EnterCrit   critDisk
	invoke	MakeNode
	JNC	Create_ok
	mov	[VOLCHNG_FLAG],-1	; indicate no change in volume label
	LeaveCrit   critDisk

entry	SET_MKND_ERR
	DOSAssume   <DS>,"Set_MkNd_Err"
	ASSUME	ES:NOTHING

;	Looks up MakeNode errors and converts them. AL is MakeNode
;	error, SI is GetPath bad spot return if path_not_found error.

;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
	MOV     BX,OFFSET DOSCODE:CRTERRTAB
;hkn;	XLAT
	XLAT	byte ptr CS:[BX]
CreatBadRet:
	STC
	return

Public CREAT001S,CREAT001E
CREAT001S  label  byte
CRTERRTAB LABEL BYTE		; Lookup table for MakeNode returns
	DB	?			; none
	DB	error_access_denied	; MakeNode error 1
	DB	error_cannot_make	; MakeNode error 2
	DB	error_file_exists	; MakeNode error 3
	DB	error_path_not_found	; MakeNode error 4
	DB	error_access_denied	; MakeNode error 5
	DB	error_sharing_violation ; MakeNode error 6
	DB	error_file_not_found	; MakeNode error 7
CREAT001E  label byte

; We have just created a new file.  This results in the truncation of old
; files.  We must inform the sharer to slash all the open SFT's for this
; file to the current size.

; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
; drive number to force a Build BPB after Media Check.

;;; FASTOPEN 8/29/86
Create_ok:
	invoke	FastOpen_Delete
;;; FASTOPEN 8/29/86
	mov	al,SATTRIB
	test	al,attr_volume_id
	jz	NoVolLabel
	LES	DI,THISCDS
	mov	ah,ES:CURDIR_TEXT[DI]	; get drive letter
	sub	ah,'A'                  ; convert to drive letter
	mov	VOLCHNG_FLAG,ah		;Set flag to indicate volid change
	MOV	BH,1			;AN000;>32mb set volume id to boot record
	CALL	Set_Media_ID		;AN000;>32mb
	EnterCrit CritDisk
	invoke	FatRead_CDS		; force a media check
	LeaveCrit CritDisk

NoVolLabel:
	MOV	ax,2
	LES	DI,ThisSFT
if installed
	call	JShare + 14 * 4
else
	Call	ShSU
endif
	LeaveCrit   critDisk
	transfer SET_SFT_MODE

EndProc DOS_Create

;---------------------------------------------------------------------------
;
; Procedure Name : Dos_Create_New
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file created
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Attribute to create
; Function:
;	Try to create the specified file truncating an old one that exists
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
;	CARRY SET
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Create a second volume id or create a dir
;		error_file_exists
;			Already a file by this name
; DS preserved, others destroyed
;---------------------------------------------------------------------------

procedure   DOS_Create_New,NEAR
	DOSAssume   <DS>,"DOS_Create_New"

	MOV	AH,1		; Truncate is NOT OK
	JMP	Create_inter

EndProc DOS_Create_New


;---------------------------------------------------------------------------
;
; Procedure Name : Set_Media_ID
;
; Inputs:
;	NAME1= Volume ID
;	BH= 0, delete volume id
;	    1, set new volume id
;	DS= DOSGROUP
; Function:
;	Set Volume ID to DOS 4.00 Boot record.
; Outputs:
;	CARRY CLEAR
;	    volume id set
;	CARRY SET
;	    AX is error code
;---------------------------------------------------------------------------

procedure   Set_Media_ID,NEAR
	DOSAssume   <DS>,"SetMedID"

	PUSH	AX		;AN000;;>32mb
	PUSH	ES		;AN000;;>32mb
	PUSH	DI		;AN000;;>32mb

	INC	AH		;AN000;;>32mb  bl=drive #
	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
	MOV	CX,0866H	;AN001;;>32mb  get media id

;hkn; PACKET_TEMP is in DOSDATA
	MOV	DX,OFFSET DOSDATA:PACKET_TEMP	;AN000;>32mb

	PUSH	BX		;AN000;;>32mb
	PUSH	DX		;AN000;;>32mb
	XOR	BH,BH		;AN000;;>32mb

	invoke	$IOCTL		;AN000;;>32mb
	POP	DX		;AN000;;>32mb
	POP	BX		;AN000;;>32mb
	JC	geterr		;AN000;;>32mb

	OR	BH,BH		;AN000;;>32mb delete volume id
	JZ	NoName		;AN000;>32mb yes

;hkn; NAME1 is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NAME1   ;AN000;>32mb

	JMP	SHORT doset	;AN000;>32mb yes
Noname: 			;AN000;

;hkn; NO_NAME_ID is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NO_NAME_ID  ;AN000;>32mb

doset:					       ;AN000;
	MOV	DI,DX		;AN000;;>32mb
	ADD	DI,MEDIA_LABEL	;AN000;;>32mb

;hkn; ES & DS must point to SS
;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
	PUSH	SS		;AN000;;>32mb  move new volume id to packet

	POP	DS		;AN000;;>32mb

;hkn;	PUSH	CS		;AN000;;>32mb
	PUSH	SS		;AN000;;>32mb

	POP	ES		;AN000;;>32mb
	MOV	CX,11		;AN000;;>32mb
	REP	MOVSB		;AN000;;>32mb
	MOV	CX,0846H	;AN001;;>32mb
	MOV	AL,0DH		;AN000;;>32mb
	XOR	BH,BH		;AN000;;>32mb
	invoke	$IOCTL		;AN000;;>32mb  set volume id
geterr: 			;AN000;

;hkn;	PUSH	CS		;AN000;>32mb
	PUSH	SS		;AN000;>32mb

	POP	DS		;AN000;>32mb   ds= dosgroup

	POP	DI		;AN000;;>32mb
	POP	ES		;AN000;;>32mb
	POP	AX		;AN000;;>32mb
	return			;AN000;>32mb

EndProc Set_Media_ID		;AN000;

;---------------------------------------------------------------------------
;
; Procedure Name : Sest_EXT_mode
;
; Inputs:
;	[EXTOPEN_ON]= flag for extende open
;	SAVE_BX= mode specified in Extended Open
; Function:
;	Set mode in ThisSFT
; Outputs:
;	carry set,mode is set if from Extended Open
;	carry clear, mode not set yet
;----------------------------------------------------------------------------

procedure   Set_EXT_mode,NEAR

;hkn; SS override
	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extnded open
	JZ	NOTEX			    ;AN000;EO. no, do normal
	PUSH	AX			    ;AN000;EO.

;hkn; SS override
	MOV	AX,[SAVE_BX]		    ;AN000;EO.
	OR	ES:[DI.sf_mode],AX	    ;AN000;EO.
	POP	AX			    ;AN000;EO.
	STC				    ;AN000;EO.
NOTEX:					    ;AN000;
	return				    ;AN000;EO.

EndProc Set_EXT_mode			    ;AN000;

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dev.asm ===
TITLE	DEV - Device call routines
	NAME	Dev

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Misc Routines to do 1-12 low level I/O and call devices
;
;	IOFUNC
;	DEVIOCALL
;	SETREAD
;	SETWRITE
;	DEVIOCALL2
;	DEV_OPEN_SFT
;	DEV_CLOSE_SFT
;	RW_SC
;	IN_SC
;	INVALIDATE_SC
;	VIRREAD
;	SC2BUF
;
;	Revision history:
;
;		A000  version 4.00     Jan. 1988
;		A010  disable change line for SHARE /NC

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include dpb.inc
	include sf.inc
	.cref
	.list

	i_need	IOXAD,DWORD
	i_need	IOSCNT,WORD
	i_need	DEVIOBUF,4
	i_need	IOCALL,BYTE
	i_need	IOMED,BYTE
	i_need	IORCHR,BYTE
	i_need	CALLSCNT,WORD
	i_need	DMAAdd,DWORD
	i_need	CallDevAd,DWORD
	i_need	CallXAD,DWORD
	i_need	DPBHead,DWORD
	i_need	ThisSFT,DWORD
	i_need	ThisDPB,DWORD
	i_need	DevCall,DWORD
	i_need	VerFlg,BYTE
	i_need	HIGH_SECTOR,WORD	       ;AN000;
	i_need	CALLSSEC,WORD		       ;AN000;
	i_need	CALLNEWSC,DWORD 	       ;AN000;
	i_need	SC_CACHE_COUNT,WORD	       ;AN000;
	i_need	SC_CACHE_PTR,DWORD	       ;AN000;
	i_need	CURSC_SECTOR,WORD	       ;AN000;
	i_need	SEQ_SECTOR,DWORD	       ;AN000;
	i_need	SC_SECTOR_SIZE,WORD	       ;AN000;
	i_need	CURSC_DRIVE,BYTE	       ;AN000;
	i_need	SC_DRIVE,BYTE		       ;AN000;
	i_need	SC_STATUS,WORD		       ;AN000;
	i_need	SC_FLAG,BYTE		       ;AN000;
	i_need	TEMP_VAR,WORD		       ;AN000;
	i_need	TEMP_VAR2,WORD		       ;AN000;
	i_need	InterChar,BYTE	;AN000; interim character flag 2/13/KK
	i_need	InterCon,BYTE	;AN000; Console mode flag(1:interim mode) 2/13/KK
	i_need	SaveCurFlg,BYTE ;AN000; Console out mode(1:print & don't adv cursor) 2 /13/KK
	i_need	DDMOVE,BYTE	;AN000; flag for DWORD move
	i_need	DOS34_FLAG,WORD ;AN000;
	i_need	fshare,BYTE	;AN010; share flag

	i_need 	IoStatFail,BYTE	;SR; set if user failed on I24 in IOFUNC


DOSCODE	Segment

	ASSUME	CS:DOSCODE

Public DEV001S, DEV001E 		; Pathgen labels
DEV001s:
;		length of packets
LenTab	DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL

;		Error	Function

CmdTab	DB	86h,	DEVRD		; 0 input
	DB	86h,	DEVRDND 	; 1 input status
	DB	87h,	DEVWRT		; 2 output
	DB	87h,	DEVOST		; 3 output status
	DB	86h,	DEVIFL		; 4 input flush
	DB	86H,	DEVRDND 	; 5 input status with system WAIT
DEV001E:

	ASSUME	CS:DOSCODE, SS:DOSDATA

Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
;----------------------------------------------------------------------------
;
; Procedure Name : IOFUNC
;
; Inputs:
;	DS:SI Points to SFT
;	AH is function code
;		= 0 Input
;		= 1 Input Status
;		= 2 Output
;		= 3 Output Status
;		= 4 Flush
;		= 5 Input Status - System WAIT invoked for K09 if no char
;				   present.
;	AL = character if output
; Function:
;	Perform indicated I/O to device or file
; Outputs:
;	AL is character if input
;	If a status call
;		zero set if not ready
;		zero reset if ready (character in AL for input status)
; For regular files:
;	Input Status
;		Gets character but restores position
;		Zero set on EOF
;	Input
;		Gets character advances position
;		Returns ^Z on EOF
;	Output Status
;		Always ready
; AX altered, all other registers preserved
;----------------------------------------------------------------------------

procedure   IOFUNC,NEAR

	Assert	ISSFT,<DS,SI>,"IOFUNC"

					
	MOV	WORD PTR [IOXAD+2],SS	; SS override for IOXAD, IOSCNT, 
					; DEVIOBUF

					; DEVIOBUF is in DOSDATA
	MOV	WORD PTR [IOXAD],OFFSET DOSDATA:DEVIOBUF
	MOV	WORD PTR [IOSCNT],1
	MOV	WORD PTR [DEVIOBUF],AX
	TESTB	[SI].SF_FLAGS,sf_isnet
	JZ	IOTO22								;AN000;
	JMP	IOTOFILE							;AN000;
IOTO22:
	TESTB	[SI].SF_FLAGS,devid_device
	JNZ	IOTo33								;AN000;
	JMP	IOTOFILE							;AN000;
IOTO33:
	save_world
	MOV	DX,DS
	MOV	BX,SS
	MOV	DS,BX
	MOV	ES,BX

	ASSUME	DS:DOSDATA

	XOR	BX,BX
	cmp	ah,5		    ; system wait enabled?
	jnz	no_sys_wait
	or	bx,0400H	    ; Set bit 10 in status word for driver
				    ; It is up to device driver to carry out
				    ; appropriate action.
no_sys_wait:
	MOV	[IOCALL.REQSTAT],BX
	XOR	BX,BX
	MOV	BYTE PTR [IOMED],BL

; moved out side this DOSCODE segment.
; Table	Segment
; Public DEV001S, DEV001E 		; Pathgen labels
; DEV001s:
; ;		length of packets
; LenTab	DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
; 
; ;		Error	Function
; 
; CmdTab	DB	86h,	DEVRD		; 0 input
; 	DB	86h,	DEVRDND 	; 1 input status
; 	DB	87h,	DEVWRT		; 2 output
; 	DB	87h,	DEVOST		; 3 output status
; 	DB	86h,	DEVIFL		; 4 input flush
; 	DB	86H,	DEVRDND 	; 5 input status with system WAIT
; DEV001E:
; Table	ENDS

	MOV	BL,AH			; get function
	MOV	AH,LenTab[BX]
	SHL	BX,1
	MOV	CX,WORD PTR CmdTab[BX]
	MOV	BX,OFFSET DOSDATA:IOCALL; IOCALL is in DOSDATA
	MOV	[IOCALL.REQLEN],AH
	MOV	[IOCALL.REQFUNC],CH
 IFDEF  DBCS				;AN000;
;----------------------------- Start of DBCS 2/13/KK
	PUSH	CX			;AN000;
	MOV	CL, [InterCon]		;AN000;
	CMP	CH, DEVRD		;AN000; 0 input
	JZ	SETIN			;AN000;
	CMP	CH, DEVRDND		;AN000; 1(5) input status without(with) system WAIT
	JZ	SETIN			;AN000;
	MOV	CL, [SaveCurflg]	;AN000;
	CMP	CH, DEVWRT		;AN000; 2 output
	JZ	CHKERROUT		;AN000;
	XOR	CL,CL			;AN000; else, do normal
SETIN:					;AN000;
	MOV	BYTE PTR [IoMed], CL	;AN000; set interim I/O indication
	POP	CX			;AN000;
;----------------------------- End of DBCS 2/13/KK
 ENDIF					;AN000;
	MOV	DS,DX
ASSUME	DS:NOTHING
	CALL	DEVIOCALL
	MOV	DI,[IOCALL.REQSTAT]	; SS override
	.errnz	STERR-8000h
	and	di,di
	js	DevErr
OkDevIO:
	MOV	AX,SS
	MOV	DS,AX

	ASSUME	DS:DOSDATA

 IFDEF  DBCS			;AN000;
	MOV	[InterChar],0	;AN000; reset interim character flag  2/13/KK
	TEST	DI,Ddkey	;AN000; is this a dead key (interim char)? 2/13/KK
	JZ	NotInterim	;AN000; no, flag already reset...	   2/13/KK
	INC	[InterChar]	;AN000; yes, set flag for future	   2/13/KK
NotInterim:			;AN000; 				   2/13/KK
 ENDIF				;AN000;
	CMP	CH,DEVRDND
	JNZ	DNODRD
	MOV	AL,BYTE PTR [IORCHR]
	MOV	[DEVIOBUF],AL

DNODRD: MOV	AH,BYTE PTR [IOCALL.REQSTAT+1]
	NOT	AH			; Zero = busy, not zero = ready
	AND	AH,STBUI SHR 8

QuickReturn:				;AN000; 2/13/KK
	restore_world
ASSUME	DS:NOTHING

	; SR;
	; We return ax = -1 if the user failed on I24. This is the case if 
	; IoStatFail = -1 (set after return from the I24)
	;

	pushf
	mov	al,ss:IoStatFail	;assume fail error
	cbw				;sign extend to word
	cmp	ax,-1
	jne	not_fail_ret
	inc	ss:IoStatFail
	popf
	ret
not_fail_ret:

	MOV	AX,WORD PTR [DEVIOBUF]	;ss override
	popf
	return

;IOTOFILEJ:
;	JMP	SHORT IOTOFILE
 IFDEF  DBCS				;AN000;
;------------------------------ Start of DBCS 2/13/KK
CHKERROUT:				;AN000;
	MOV	DS, DX			;AN000;
	TESTB	[SI].SF_FLAGS, devid_device_con_out	;AN000; output to console ?
	JNZ	GOOD			;AN000; yes
	CMP	CL, 01			;AN000; write interim ?
	JNZ	GOOD			;AN000; no,
	POP	CX			;AN000;
	JMP	SHORT QuickReturn	;AN000; avoid writting interims to other than
					;AN000; console device
GOOD:					;AN000;
	PUSH	SS			;AN000;
	POP	DS			;AN000;
	JMP	SETIN			;AN000;
;------------------------------ End of DBCS 2/13/KK
 ENDIF					;AN000;
DevErr:
	MOV	AH,CL
	invoke	CHARHARD
	CMP	AL,1
	JNZ	NO_RETRY
	restore_world			;hkn; use macro
	JMP	IOFUNC

NO_RETRY:
	
	;
	; Know user must have wanted Ignore OR Fail.	Make sure device shows ready
	; ready so that DOS doesn't get caught in a status loop when user 
	; simply wants to ignore the error.
	;
	; SR; If fail wanted by user set ax to special value (ax = -1). This 
	; should be checked by the caller on return
	;

					; SS override
	AND	BYTE PTR [IOCALL.REQSTAT+1], NOT (STBUI SHR 8)

	; SR;
	; Check if user failed
	;

	cmp	al,3
	jnz	not_fail
	dec	IoStatFail		;set flag indicating fail on I24
not_fail:
	JMP	OKDevIO

IOTOFILE:
ASSUME	DS:NOTHING
	OR	AH,AH
	JZ	IOIN
	DEC	AH
	JZ	IOIST
	DEC	AH
	JZ	IOUT
	return				; NON ZERO FLAG FOR OUTPUT STATUS

IOIST:
	PUSH	WORD PTR [SI.sf_position]   ; Save position
	PUSH	WORD PTR [SI.sf_position+2]
	CALL	IOIN
	POP	WORD PTR [SI.sf_position+2] ; Restore position
	POP	WORD PTR [SI.sf_position]
	return

IOUT:
	CALL	SETXADDR
	invoke	DOS_WRITE
	CALL	RESTXADDR		; If you change this into a jmp don't
	return				; come crying to me when things don't
					; work ARR

IOIN:
	CALL	SETXADDR

					; SS override for DOS34_FLAG
	OR	[DOS34_FLAG],Disable_EOF_I24   ;AN000;
	invoke	DOS_READ
	AND	[DOS34_FLAG],NO_Disable_EOF_I24   ;AN000;
	OR	CX,CX			; Check EOF
	CALL	RESTXADDR

					; SS override
	MOV	AL,[DEVIOBUF]		; Get byte from trans addr
	retnz
	MOV	AL,1AH			; ^Z if no bytes
	return

SETXADDR:

					; SS override
	POP	WORD PTR [CALLSCNT]	; Return address

	save_world			;hkn; use macro

					; SS override for DMAADD and THISSFT
	PUSH	WORD PTR [DMAADD]	; Save Disk trans addr
	PUSH	WORD PTR [DMAADD+2]
	MOV	WORD PTR [THISSFT+2],DS

	Context DS
	MOV	WORD PTR [THISSFT],SI	; Finish setting SFT pointer
	MOV	CX,WORD PTR [IOXAD+2]
	MOV	WORD PTR [DMAADD+2],CX
	MOV	CX,WORD PTR [IOXAD]
	MOV	WORD PTR [DMAADD],CX	; Set byte trans addr
	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
	JMP	SHORT RESTRET		; RETURN ADDRESS

RESTXADDR:
	DOSAssume   <DS>,"RestXAddr"
	POP	WORD PTR [CALLSCNT]	; Return address
	POP	WORD PTR [DMAADD+2]	; Restore Disk trans addr
	POP	WORD PTR [DMAADD]

	restore_world			; use macro

ASSUME	DS:NOTHING

					; SS override
RESTRET:JMP	WORD PTR [CALLSCNT]	; Return address
EndProc IOFUNC

Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>


;**	Dev_Open_SFT - Open the Device for an SFT
;
;	Dev_Open_SFT issues an open call to the device associated with
;	the SFT.
;
;	ENTRY	(ES:DI) = SFT
;	EXIT	none
;	USES	all

procedure   DEV_OPEN_SFT,NEAR

	Assert	ISSFT,<ES,DI>,"Dev_Open_SFT"

	Save_World			; use macro
	MOV	AL,DEVOPN
	JMP	SHORT DO_OPCLS

EndProc DEV_OPEN_SFT

;---------------------------------------------------------------------------
;
; Procedure Name : DEV_CLOSE_SFT
;
; Inputs:
;	ES:DI Points to SFT
; Function:
;	Issue a CLOSE call to the correct device
; Outputs:
;	None
; ALL preserved
;
;---------------------------------------------------------------------------

procedure   DEV_CLOSE_SFT,NEAR

	Assert	ISSFT,<ES,DI>,"Dev_Close_SFT"

	Save_World			; use macro

	MOV	AL,DEVCLS

	;
	; Main entry for device open and close.  AL contains the function 
	; requested. Subtlety:  if Sharing is NOT loaded then we do NOT issue 
	; open/close to block devices.  This allows networks to function but 
	; does NOT hang up with bogus change-line code.
	;

	entry	DO_OPCLS

	; Is the SFT for the net?  If so, no action necessary.

	TESTB	es:[di].sf_Flags, SF_ISNET
	JNZ	OPCLS_DONE		; NOP on net SFTs
	XOR	AH,AH			; Unit
	TESTB	ES:[DI].SF_FLAGS,devid_device
	LES	DI,ES:[DI.sf_devptr]	; Get DPB or device
	JNZ	Got_Dev_Addr

	; We are about to call device open/close on a block driver.  If no 
	; sharing then just short circuit to done.

;;;;;	invoke	CheckShare

					; SS override
	CMP	fshare,1		;AN010; /NC or no SHARE
	JBE	opCLs_Done		;AN010; yes
	MOV	AH,ES:[DI.dpb_UNIT]	; (ah) = unit
	MOV	CL,ES:[DI.dpb_drive]	; (cl) = drive
	LES	DI,ES:[DI.dpb_driver_addr]  ; Get device
GOT_DEV_ADDR:				; ES:DI -> device
	TESTB	ES:[DI.SDEVATT],DEVOPCL
	JZ	OPCLS_DONE		; Device can't
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> device
OPCLS_RETRY:
	Context ES

					; DEVCALL is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVCALL

	MOV	BX,DI
	PUSH	AX
	MOV	AL,DOPCLHL
	STOSB				; Length
	POP	AX
	XCHG	AH,AL
	STOSB				; Unit
	XCHG	AH,AL
	STOSB				; Command
	MOV	WORD PTR ES:[DI],0	; Status
	PUSH	AX			; Save Unit,Command
	invoke	DEVIOCALL2
	MOV	DI,ES:[BX.REQSTAT]
	.errnz	STERR-8000h
	and	di,di
	Jns	OPCLS_DONEP		; No error
	TESTB	[SI.SDEVATT],DEVTYP
	JZ	BLKDEV
	MOV	AH,86H			; Read error in data, Char dev
	JMP	SHORT HRDERR

BLKDEV:
	MOV	AL,CL			; Drive # in AL
	MOV	AH,6			; Read error in data, Blk dev
HRDERR:
	invoke	CHARHARD
	CMP	AL,1
	JNZ	OPCLS_DONEP		; IGNORE or FAIL
					;  Note that FAIL is essentually IGNORED
	POP	AX			; Get back Unit, Command
	JMP	OPCLS_RETRY

OPCLS_DONEP:
	POP	AX			; Clean stack
OPCLS_DONE:

	Restore_World			;hkn; use macro
	return

EndProc DEV_CLOSE_SFT

Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>


;**	DevIoCall  - Call Device
;
;	ENTRY	DS:SI Points to device SFT
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX

;**	DevIoCall2 - Call Device
;
;	ENTRY	DS:SI Points to DPB
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX

procedure   DEVIOCALL,NEAR

					; SS override for CALLSSEC, 
					; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
	Assert	ISSFT,<DS,SI>,"DevIOCall"
	LDS	SI,[SI.sf_devptr]

entry	DEVIOCALL2

	EnterCrit   critDevice

	TESTB	[SI.SDEVATT],DevTyp    ;AN000; >32mb   block device ?
	JNZ	chardev2	       ;AN000; >32mb   no
	CMP	ES:[BX.REQFUNC],DEVRD  ;AN000; >32mb   read ?
	JZ	chkext		       ;AN000; >32mb   yes
	CMP	ES:[BX.REQFUNC],DEVWRT ;AN000; >32mb   write ?
	JZ	chkext		       ;AN000; >32mb   yes
	CMP	ES:[BX.REQFUNC],DEVWRTV;AN000; >32mb   write/verify ?
	JNZ	chardev2	       ;AN000; >32mb   no
chkext:
	CALL	RW_SC		       ;AN000;LB. use secondary cache if there
	JC	dev_exit	       ;AN000;LB. done

	TESTB	[SI.SDEVATT],EXTDRVR   ;AN000;>32mb   extended driver?
	JZ	chksector	       ;AN000;>32mb   no
	ADD	BYTE PTR ES:[BX],8     ;AN000;>32mb   make length to 30
	MOV	AX,[CALLSSEC]	       ;AN000;>32mb
	MOV	[CALLSSEC],-1	       ;AN000;>32mb   old sector  =-1
	MOV	WORD PTR [CALLNEWSC],AX   ;AN000;>32mb	 new sector  =
	MOV	AX,[HIGH_SECTOR]       ;AN000; >32mb   low sector,high sector
	MOV	WORD PTR [CALLNEWSC+2],AX  ;AN000; >32mb
	JMP	short chardev2	       ;AN000; >32mb
chksector:			       ;AN000; >32mb
	CMP	[HIGH_SECTOR],0        ;AN000; >32mb   if >32mb
	JZ	chardev2	       ;AN000; >32mb   then fake error
	MOV	ES:[BX.REQSTAT],STERR+STDON+ERROR_I24_NOT_DOS_DISK  ;AN000; >32mb
	JMP	SHORT dev_exit	       ;AN000; >32mb

chardev2:			       ;AN000;

	;
	; As above only DS:SI points to device header on entry, and DS:SI is 
	; preserved
	;

	MOV	AX,[SI.SDEVSTRAT]
	MOV	WORD PTR [CALLDEVAD],AX
	MOV	WORD PTR [CALLDEVAD+2],DS
	CALL	DWORD PTR [CALLDEVAD]
	MOV	AX,[SI.SDEVINT]
	MOV	WORD PTR [CALLDEVAD],AX
	CALL	DWORD PTR [CALLDEVAD]
	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
	JC	chardev2		;AN000;LB. bad sector or exceeds max sec
dev_exit:
	LeaveCrit   critDevice
	return
EndProc DEVIOCALL

Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : SETREAD, SETWRITE
;
; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected
;
;---------------------------------------------------------------------------

procedure   SETREAD,NEAR

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVRD
SETCALLHEAD:
	MOV	AL,DRDWRHL
	PUSH	SS
	POP	ES

					; DEVCALL is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVCALL

	STOSB				; length
	POP	AX
	STOSB				; Unit
	PUSH	AX
	MOV	AL,CL
	STOSB				; Command code
	XOR	AX,AX
	STOSW				; Status
	ADD	DI,8			; Skip link fields
	POP	AX
	XCHG	AH,AL
	STOSB				; Media byte
	XCHG	AL,AH
	PUSH	AX
	MOV	AX,BX
	STOSW
	MOV	AX,DS
	STOSW				; Transfer addr
	POP	CX			; Real AX
	POP	AX			; Real CX
	STOSW				; Count
	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
	STOSW				; Start
	XCHG	AX,CX
	XCHG	DX,CX
	POP	DI
					; DEVCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVCALL
	return

	entry	SETWRITE
ASSUME	DS:NOTHING,ES:NOTHING

; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVWRT
	ADD	CL,[VERFLG]		; SS override
	JMP	SHORT SETCALLHEAD
EndProc SETREAD


Break	<RW_SC -- Read Write Secondary Cache>
;---------------------------------------------------------------------------
;
; Procedure Name : RW_SC
;
; Inputs:
;	 [SC_CACHE_COUNT]= secondary cache count
;	 [SC_STATUS]= SC validity status
;	 [SEQ_SECTOR]= last sector read
; Function:
;	Read from or write through secondary cache
; Output:
;	ES:BX Points to DEVCALL
;	carry clear, I/O is not done
;		     [SC_FLAG]=1 if continuos sectors will be read
;	carry set, I/O is done
;
;----------------------------------------------------------------------------


procedure   RW_SC,NEAR		;AN000;

	; SS override for all variables used.

	CMP	[SC_CACHE_COUNT],0	;AN000;LB. secondary cache exists?
	JZ	scexit4 		;AN000;LB. no, do nothing
	CMP	[CALLSCNT],1		;AN000;LB. sector count = 1 (buffer I/O)
	JNZ	scexit4 		;AN000;LB. no, do nothing
	PUSH	CX			    ;AN000;;LB.
	PUSH	DX			    ;AN000;;LB. yes
	PUSH	DS			    ;AN000;;LB. save registers
	PUSH	SI			    ;AN000;;LB.
	PUSH	ES			    ;AN000;;LB.
	PUSH	DI			    ;AN000;;LB.
	MOV	DX,WORD PTR [CALLSSEC]	    ;AN000;;LB.  starting sector
	CMP	BYTE PTR [DEVCALL.REQFUNC],DEVRD ;AN000;LB. read ?		      ;AN000;
	JZ	doread			;AN000;LB. yes				      ;AN000;
	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC		      ;AN000;
	JMP	scexit2 		    ;AN000;LB. back to normal		      ;AN000;
scexit4:				    ;AN000;				       ;AN000;
	CLC				    ;AN000;LB. I/O not done yet 	  ;AN000;
	return				    ;AN000;LB.				  ;AN000;
doread: 				    ;AN000;				       ;AN000;
	CALL	SC2BUF			    ;AN000;LB. check if in SC		      ;AN000;
	JC	readSC			    ;AN000;LB.					  ;AN000;
	MOV	[DEVCALL.REQSTAT],STDON     ;AN000;LB. fake done and ok 	  ;AN000;
	STC				    ;AN000;LB. set carry		  ;AN000;
	JMP	short saveseq 		    ;AN000;LB. save seq. sector #	  ;AN000;
readSC: 				    ;AN000;
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
	MOV	CX,WORD PTR [CALLSSEC]	    ;AN000;;LB. saved sequential sector
	SUB	CX,WORD PTR [SEQ_SECTOR]    ;AN000;;LB. number
	SBB	AX,WORD PTR [SEQ_SECTOR+2]  ;AN000;;LB.
	CMP	AX,0			    ;AN000;;LB. greater than 64K
	JNZ	saveseq2		    ;AN000;;LB. yes,save seq. sector #
chklow: 									;AN000;
	CMP	CX,1			    ;AN000;;LB. <= 1
	JA	saveseq2		    ;AN000;;LB. no, not sequential
	MOV	[SC_STATUS],-1		    ;AN000;;LB. prsume all SC valid
	MOV	AX,[SC_CACHE_COUNT]	    ;AN000;;LB. yes, sequential
	MOV	[CALLSCNT],AX		    ;AN000;;LB. read continuous sectors
readsr:
	MOV	AX,WORD PTR [CALLXAD+2]     ;AN000;;LB. save buffer addr
	MOV	[TEMP_VAR2],AX		    ;AN000;;LB. in temp vars
	MOV	AX,WORD PTR [CALLXAD]	    ;AN000;;LB.
	MOV	[TEMP_VAR],AX		    ;AN000;;LB.
										;AN000;
	MOV	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;LB. use SC cache addr as	      ;AN000;
	MOV	WORD PTR [CALLXAD],AX	    ;AN000;LB. transfer addr		      ;AN000;
	MOV	AX,WORD PTR [SC_CACHE_PTR+2]  ;AN000;LB.			      ;AN000;
	MOV	WORD PTR [CALLXAD+2],AX       ;AN000;LB.			      ;AN000;
	MOV	[SC_FLAG],1		      ;AN000;LB. flag it for later	      ;AN000;
	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
	MOV	[CURSC_DRIVE],AL	    ;AN000;;LB. set current drive
	MOV	AX,WORD PTR [CALLSSEC]	    ;AN000;;LB. current sector
	MOV	[CURSC_SECTOR],AX	    ;AN000;;LB. set current sector
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB.
	MOV	[CURSC_SECTOR+2],AX	    ;AN000;;LB.
saveseq2:				    ;AN000;
	CLC				    ;AN000;LB. clear carry		      ;AN000;
saveseq:				    ;AN000;				       ;AN000;
	MOV	AX,[HIGH_SECTOR]	    ;AN000;LB. save current sector #	  ;AN000;
	MOV	WORD PTR [SEQ_SECTOR+2],AX  ;AN000;LB. for access mode ref.	  ;AN000;
	MOV	AX,[CALLSSEC]		    ;AN000;LB.				  ;AN000;
	MOV	WORD PTR [SEQ_SECTOR],AX    ;AN000;LB.				  ;AN000;
	JMP	short scexit 		    ;AN000;LB.				  ;AN000;
										;AN000;
scexit2:				    ;AN000;LB.				      ;AN000;
	CLC				    ;AN000;LB.	       clear carry	      ;AN000;
scexit: 				    ;AN000;				       ;AN000;
	POP	DI			    ;AN000;;LB.
	POP	ES			    ;AN000;;LB. restore registers
	POP	SI			    ;AN000;;LB.
	POP	DS			    ;AN000;;LB.
	POP	DX			    ;AN000;;LB.
	POP	CX			    ;AN000;;LB.
	return				    ;AN000;;LB.
										;AN000;
EndProc RW_SC				    ;AN000;

Break	<IN_SC -- check if in secondary cache>
;--------------------------------------------------------------------------
;
; Procedure Name : IN_SC
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [HIGH_SECTOR]:DX= sector number
; Function:
;	Check if the sector is in secondary cache
; Output:
;	carry clear, in SC
;	   CX= the index in the secondary cache
;	carry set, not in SC
;
;---------------------------------------------------------------------------

procedure   IN_SC,NEAR		    ;AN000;

	; SS override for all variables used

	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
	CMP	AL,[CURSC_DRIVE]	    ;AN000;;LB. same as SC drive
	JNZ	outrange2		    ;AN000;;LB. no
	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
	SUB	CX,WORD PTR [CURSC_SECTOR]    ;AN000;;LB. number
	SBB	AX,WORD PTR [CURSC_SECTOR+2]  ;AN000;;LB.
	CMP	AX,0			    ;AN000;;LB. greater than 64K
	JNZ	outrange2		    ;AN000;;LB. yes
	CMP	CX,[SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
	JAE	outrange2		    ;AN000;;LB. yes
	CLC				    ;AN000;;LB. clear carry
	JMP	short inexit		    ;AN000;;LB. in SC
outrange2:				    ;AN000;;LB. set carry
	STC				    ;AN000;;LB.
inexit: 				    ;AN000;;LB.
	return				    ;AN000;;LB.

EndProc IN_SC				    ;AN000;

Break	<INVALIDATE_SC - invalide secondary cache>
;---------------------------------------------------------------------------
;
; Procedure Name : Invalidate_Sc
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [SC_STAUS] = SC status word
;	   [HIGH_SECTOR]:DX= sceotor number
;
; Function:
;	invalidate secondary cache if in there
; Output:
;	[SC_STATUS] is updated
;---------------------------------------------------------------------------

procedure   INVALIDATE_SC,NEAR	    ;AN000;

	; SS override for all variables used

	CALL	IN_SC			    ;AN000;;LB. in secondary cache
	JC	outrange		    ;AN000;;LB. no
	MOV	AX,1			    ;AN000;;LB. invalidate the sector
	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
	NOT	AX			    ;AN000;;LB.
	AND	[SC_STATUS],AX		    ;AN000;;LB. save the status
outrange:				    ;AN000;;LB.
	return				    ;AN000;;LB.

EndProc INVALIDATE_SC			    ;AN000;


Break	<VIRREAD- virtually read data into buffer>
;--------------------------------------------------------------------------
;
; Procedure Name : SC_FLAG
;
; Inputs:  SC_FLAG = 0 , no sectors were read into SC
;		     1, continous sectors were read into SC
; Function:
;	   Move data from SC to buffer
; Output:
;	 carry clear, data is moved to buffer
;	 carry set, bad sector or exceeds maximum sector
;	   SC_FLAG =0
;	   CALLSCNT=1
;	   SC_STATUS= -1 if succeeded
;     
;		       0 if failed
;--------------------------------------------------------------------------

procedure   VIRREAD,NEAR	    ;AN000;

	; SS override for all variables used

	CMP	[SC_FLAG],0		    ;AN000;;LB.  from SC fill
	JZ	sc2end			    ;AN000;;LB.  no
	MOV	AX,[TEMP_VAR2]		    ;AN000;;LB. restore buffer addr
	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;;LB.
	MOV	AX,[TEMP_VAR]		    ;AN000;;LB.
	MOV	WORD PTR [CALLXAD],AX	    ;AN000;;LB.
	MOV	[SC_FLAG],0		    ;AN000;;LB.  reset sc_flag
	MOV	[CALLSCNT],1		    ;AN000;;LB.  one sector transferred

	TESTB	[DEVCALL.REQSTAT],STERR     ;AN000;;LB.  error?
	JNZ	scerror 		    ;AN000;;LB. yes
	PUSH	DS			    ;AN000;;LB.
	PUSH	SI			    ;AN000;;LB.
	PUSH	ES			    ;AN000;;LB.
	PUSH	DI			    ;AN000;;LB.
	PUSH	DX			    ;AN000;;LB.
	PUSH	CX			    ;AN000;;LB.
	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buffer
	POP	CX			    ;AN000;;LB.
	POP	DX			    ;AN000;;LB.
	POP	DI			    ;AN000;;LB.
	POP	ES			    ;AN000;;LB.
	POP	SI			    ;AN000;;LB.
	POP	DS			    ;AN000;;LB.
	JMP	SHORT sc2end		    ;AN000;;LB. return

scerror:				    ;AN000;
	MOV	[CALLSCNT],1		    ;AN000;;LB. reset sector count to 1
	MOV	[SC_STATUS],0		    ;AN000;;LB. invalidate all SC sectors
	MOV	[CURSC_DRIVE],-1	    ;AN000;;LB. invalidate drive
	STC				    ;AN000;;LB. carry set
	return				    ;AN000;;LB.

sc2end: 				    ;AN000;
	CLC				    ;AN000;;LB. carry clear
	return				    ;AN000;;LB.

EndProc VIRREAD 			    ;AN000;

Break	<SC2BUF- move data from SC to buffer>
;----------------------------------------------------------------------------
;
; Procedure Name : SC2BUF
;
; Inputs:  [SC_STATUS] = SC validity status
;	   [SC_SECTOR_SIZE] = request sector size
;	   [SC_CACHE_PTR] = pointer to SC
; Function:
;	   Move data from SC to buffer
; Output:
;	   carry clear, in SC  and data is moved
;	   carry set, not in SC and data is not moved
;---------------------------------------------------------------------------

procedure   SC2BUF,NEAR 	    ;AN000;

	; SS override for all variables used

	CALL	IN_SC			    ;AN000;;LB. in secondary cache
	JC	noSC			    ;AN000;;LB. no
	MOV	AX,1			    ;AN000;;LB. check if valid sector
	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
	TEST	[SC_STATUS],AX		    ;AN000;;LB.
	JZ	noSC			    ;AN000;;LB. invalid
entry SC2BUF2				    ;AN000;
	MOV	AX,CX			    ;AN000;;LB. times index with
	MUL	[SC_SECTOR_SIZE]	    ;AN000;;LB. sector size
	ADD	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;;LB. add SC starting addr
	ADC	DX,WORD PTR [SC_CACHE_PTR+2];AN000;;LB.
	MOV	DS,DX			    ;AN000;    ;LB. DS:SI-> SC sector addr
	MOV	SI,AX			    ;AN000;    ;LB.
	MOV	ES,WORD PTR [CALLXAD+2]     ;AN000;    ;LB. ES:DI-> buffer addr
	MOV	DI,WORD PTR [CALLXAD]	    ;AN000;    ;LB.
	MOV	CX,[SC_SECTOR_SIZE]	    ;AN000;    ;LB. count= sector size
	SHR	CX,1			    ;AN000;    ;LB. may use DWORD move for 386
entry MOVWORDS				    ;AN000;
	CMP	[DDMOVE],0		    ;AN000;    ;LB. 386 ?
	JZ	nodd			    ;AN000;    ;LB. no
	SHR	CX,1			    ;AN000;    ;LB. words/2
	DB	66H			    ;AN000;    ;LB. use double word move
nodd:
	REP	MOVSW			    ;AN000;    ;LB. move to buffer
	CLC				    ;AN000;    ;LB. clear carry
	return				    ;AN000;    ;LB. exit
noSC:					    ;AN000;
	STC				    ;AN000;    ;LB. set carry
sexit:					    ;AN000;
	return				    ;AN000;    ;LB.

EndProc SC2BUF
DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dircall.asm ===
TITLE DIRCALL - Directory manipulation internal calls
	NAME  DIRCALL

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level directory manipulation routines for making removing and
;	  verifying local or NET directories
;
;	DOS_MKDIR
;	DOS_CHDIR
;	DOS_RMDIR
;
;	Modification history:
;
;		Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE FASTOPEN.INC
	INCLUDE FASTXXXX.INC
	include sf.inc
	include dpb.inc
	include mult.inc
	include curdir.inc
	.cref
	.list

Installed = TRUE

	i_need	THISSFT,DWORD
	i_need	THISCDS,DWORD
	i_need	NoSetDir,BYTE
	i_need	CURBUF, DWORD
	i_need	DIRSTART,WORD
	i_need	THISDPB,DWORD
	i_need	NAME1,BYTE
	i_need	LASTENT,WORD
	i_need	SATTRIB,BYTE
	i_need	ATTRIB,BYTE
	i_need	ALLOWED,BYTE
	i_need	FAILERR,BYTE
	i_need	RenBuf,BYTE
	i_need	FastOpenFlg,BYTE		  ; DOS 3.3
	i_need	FastOpenTable,BYTE		  ; DOS 3.3
	i_need	WFP_START,WORD			  ; DOS 3.3
	i_need	HIGH_SECTOR,WORD		  ; F.C. >32mb

DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE


BREAK <DOS_MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_MkDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Make a new directory
; Returns:
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Already exists, device name
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

	ASSUME	ES:NOTHING
procedure   DOS_MKDIR,NEAR
	DOSAssume   <DS>,"DOS_MkDir"

	Invoke	TestNet
	JNC	local_mkdir
IF NOT Installed
	transfer NET_MKDIR
ELSE
	MOV	AX,(multNET SHL 8) OR 3
	INT	2FH
	return
ENDIF

NODEACCERRJ:
	MOV	AX,error_access_denied
BadRet:
	STC
	LeaveCrit   critDisk
	return

PATHNFJ:
	LeaveCrit   critDisk
	transfer SET_MKND_ERR		; Map the MakeNode error and return

LOCAL_MKDIR:
	EnterCrit   critDisk
;
; MakeNode requires an SFT to fiddle with.  We Use a temp spot (RENBUF)
;
	MOV	WORD PTR [THISSFT+2],SS

;hkn; DOSDATA
	MOV	WORD PTR [THISSFT],OFFSET DOSDATA:RenBuf
;
;  NOTE: Need WORD PTR because MASM takes type of
;   TempSFT (byte) instead of type of sf_mft (word).
;
	MOV	WORD PTR RenBuf.sf_mft,0    ; make sure SHARER won't complain.
	MOV	AL,attr_directory
	invoke	MAKENODE

	JC	PATHNFJ
	CMP	AX,3
	JZ	NODEACCERRJ	; Can't make a device into a directory
	LES	BP,[THISDPB]	; Makenode zaps this
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	SUB	SI,DI
	PUSH	SI		; Pointer to dir_first
	PUSH	WORD PTR [DI.buf_sector+2]	    ;F.C. >32mb

	PUSH	WORD PTR [DI.buf_sector] ; Sector of new node

;hkn; SS is DOSDATA
	context DS
	PUSH	[DIRSTART]	; Parent for .. entry
	XOR	AX,AX
	MOV	[DIRSTART],AX	; Null directory
	invoke	NEWDIR
	JC	NODEEXISTSPOPDEL    ; No room
	invoke	GETENT		; First entry
	JC	NODEEXISTSPOPDEL    ; Screw up
	LES	DI,[CURBUF]

	TEST	ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	ES:[DI.buf_flags],buf_dirty
yesdirty:
	ADD	DI,BUFINSIZ	; Point at buffer
	MOV	AX,202EH	; ". "
	MOV	DX,[DIRSTART]	; Point at itself
	invoke	SETDOTENT
	MOV	AX,2E2EH	; ".."
	POP	DX		; Parent
	invoke	SETDOTENT
	LES	BP,[THISDPB]
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	POP	DX		; Entry sector
	POP	[HIGH_SECTOR]	;F.C. >32mb

	XOR	AL,AL		; Pre read
	invoke	GETBUFFR
	JC	NODEEXISTSP
	MOV	DX,[DIRSTART]
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	OR	[DI.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	MOV	[SI],DX
	XOR	DX,DX
	MOV	[SI+2],DX	; Zero size
	MOV	[SI+4],DX
DIRUP:
	TEST	[DI.buf_flags],buf_dirty  ;LB. if already dirty 		;AN000;
	JNZ	yesdirty2		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	[DI.buf_flags],buf_dirty	; Dirty buffer
yesdirty2:

;hkn; SS is DOSDATA
	context DS
	MOV	AL,ES:[BP.dpb_drive]
	invoke	FLUSHBUF
	MOV	AX,error_access_denied
	LeaveCrit   critDisk
	return

NODEEXISTSPOPDEL:
	POP	DX		; Parent
	POP	DX		; Entry sector
	POP	[HIGH_SECTOR]	; F.C. >32mb

	LES	BP,[THISDPB]
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	XOR	AL,AL		; Pre read
	invoke	GETBUFFR
	JC	NODEEXISTSP
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	OR	[DI.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	SUB	SI,dir_first	;Point back to start of dir entry
	MOV	BYTE PTR [SI],0E5H    ; Free the entry
	CALL	DIRUP		; Error doesn't matter since erroring anyway
NODEEXISTS:
	JMP	NODEACCERRJ

NODEEXISTSP:
	POP	SI		; Clean stack
	JMP	NODEEXISTS

EndProc DOS_MKDIR

BREAK <DOS_ChDir -- Verify a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_ChDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used May not be NUL
; Function:
;	Validate the path for potential new current directory
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;	    CX is cluster number of the DIR, LOCAL CDS ONLY
;		Caller must NOT set ID fields on a NET CDS.
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path
;		error_access_denied
;			device or file name
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm and dir2.asm. DS already set up.

	ASSUME	ES:NOTHING
procedure   DOS_CHDIR,NEAR
	DOSAssume   <DS>,"DOS_Chdir"

	Invoke	TestNet
	JNC	LOCAL_CHDIR
IF NOT Installed
	transfer NET_CHDIR
ELSE
	MOV	AX,(multNET SHL 8) OR 5
	INT	2FH
	return
ENDIF

LOCAL_CHDIR:
	EnterCrit   critDisk
	TEST	ES:[DI.curdir_flags],curdir_splice ;PTM.
	JZ	nojoin				   ;PTM.
	MOV	ES:[DI.curdir_ID],0FFFFH	   ;PTM.
nojoin:
	MOV	[NoSetDir],FALSE
	MOV	[SATTRIB],attr_directory+attr_system+attr_hidden
				; Dir calls can find these
; DOS 3.3  6/24/86 FastOpen

	OR	[FastOpenFlg],FastOpen_Set	   ; set fastopen flag
	invoke	GetPath
	PUSHF									;AN000;
	AND	[FastOpenFlg],Fast_yes		   ; clear it all		;AC000;
	POPF									;AN000;
; DOS 3.3  6/24/86 FastOpen
	MOV	AX,error_path_not_found
	JC	ChDirDone
	JNZ	NOTDIRPATH	; Path not a DIR
	MOV	CX,[DIRSTART]	; Get cluster number
	CLC
ChDirDone:
	LeaveCrit   critDisk
	return

EndProc DOS_CHDIR

BREAK <DOS_RmDir -- Remove a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RmDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Remove a directory
;	NOTE: Attempt to remove current directory must be detected by caller
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			device or file name, root directory
;			Bad directory ('.' '..' messed up)
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

	ASSUME	ES:NOTHING
procedure   DOS_RMDIR,NEAR
	DOSAssume   <DS>,"DOS_RmDir"

	Invoke	TestNet
	JNC	Local_RmDIR
IF NOT Installed
	transfer NET_RMDIR
ELSE
	MOV	AX,(multNET SHL 8) OR 1
	INT	2FH
	return
ENDIF

LOCAL_RMDIR:
	EnterCrit   critDisk
	MOV	[NoSetDir],0
	MOV	[SATTRIB],attr_directory+attr_system+attr_hidden
				; Dir calls can find these
	invoke	GetPath
	JC	NOPATH		; Path not found
	JNZ	NOTDIRPATH	; Path not a DIR
	MOV	DI,[DIRSTART]
	OR	DI,DI		; Root ?
	JNZ	rmdir_get_buf	; No
	JMP	SHORT NOTDIRPATH

NOPATH:
	MOV	AX,error_path_not_found
	JMP	BadRet

NOTDIRPATHPOP:
	POP	AX			  ;F.C. >32mb
	POP	AX
NOTDIRPATHPOP2:
	POP	AX
NOTDIRPATH:
	JMP	NodeAccErrJ

rmdir_get_buf:
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	SUB	BX,DI		; Compute true offset
	PUSH	BX		; Save entry pointer
	PUSH	WORD PTR [DI.buf_sector+2] ;F.C. >32mb
	PUSH	WORD PTR [DI.buf_sector] ; Save sector number

;hkn; SS is DOSDATA
	context DS
	context ES

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	MOV	AL,'?'
	MOV	CX,11
	REP	STOSB
	XOR	AL,AL
	STOSB			; Nul terminate it
	invoke	STARTSRCH	; Set search
	invoke	GETENTRY	; Get start of directory
	JC	NOTDIRPATHPOP	; Screw up
	MOV	DS,WORD PTR [CURBUF+2]
ASSUME	DS:NOTHING
	MOV	SI,BX
	LODSW
	CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
	JNZ	NOTDIRPATHPOP		; Nope
	ADD	SI,(SIZE dir_entry) - 2 ; Next entry
	LODSW
	CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
	JNZ	NOTDIRPATHPOP		; Nope

;hkn; SS is DOSDATA
	context DS
	MOV	[LASTENT],2		; Skip . and ..
	invoke	GETENTRY		; Get next entry
	JC	NOTDIRPATHPOP		; Screw up
	MOV	[ATTRIB],attr_directory+attr_hidden+attr_system
	invoke	SRCH			; Do a search
	JNC	NOTDIRPATHPOP		; Found another entry!
	CMP	[FAILERR],0
	JNZ	NOTDIRPATHPOP		; Failure of search due to I 24 FAIL
	LES	BP,[THISDPB]
	MOV	BX,[DIRSTART]
	invoke	RELEASE 		; Release data in sub dir
	JC	NOTDIRPATHPOP		; Screw up
	POP	DX			; Sector # of entry
	POP	[HIGH_SECTOR]		; F.C. >32mb

	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	XOR	AL,AL			; Pre read
	invoke	GETBUFFR		; Get sector back
	JC	NOTDIRPATHPOP2		; Screw up
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	OR	[DI.buf_flags],buf_isDIR
	POP	BX			; Pointer to start of entry
	ADD	BX,DI			; Corrected
	MOV	BYTE PTR [BX],0E5H	; Free the entry

;DOS 3.3 FastOpen  6/16/86  F.C.
	PUSH	DS

;hkn; SS is DOSDATA
	context DS
	invoke	FastOpen_Delete 	; call fastopen to delete an entry
	POP	DS
;DOS 3.3 FastOpen  6/16/86  F.C.

	JMP	DIRUP			; In MKDIR, dirty buffer and flush

EndProc DOS_RMDIR

DOSCODE	ENDS
    END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dir2.asm ===
TITLE	DIR2 - Directory and path cracking
	NAME	Dir2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Main Path cracking routines, low level search routines and device
;	  name detection routines
;
;	GETPATH
;	GetPathNoSet
;	CHKDEV
;	ROOTPATH
;	FINDPATH
;	StartSrch
;	MatchAttributes
;	DEVNAME
;	Build_device_ent
;	Validate_CDS
;	CheckThisDevice
;
;	Revision history:
;
;		A000  version 4.00  Jan. 1988
;		A001  PTM 3564 -- search using fastopen
;
; 		M026 - set Attrib before invoking devname. 9/17/90

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include fastopen.inc
	include curdir.inc
	include dpb.inc
	.cref
	.list


	i_need	NoSetDir,BYTE
	i_need	EntFree,WORD
	i_need	DirStart,WORD
	i_need	LastEnt,WORD
	i_need	WFP_START,WORD
	i_need	CURR_DIR_END,WORD
	i_need	CurBuf,DWORD
	i_need	THISCDS,DWORD
	i_need	Attrib,BYTE
	i_need	SAttrib,BYTE
	i_need	VolID,BYTE
	i_need	Name1,BYTE
	i_need	ThisDPB,DWORD
	i_need	EntLast,WORD
	i_need	Creating,BYTE
	i_need	NULDEV,DWORD
	i_need	DEVPT,DWORD
	i_need	DEVFCB,BYTE
	i_need	ALLOWED,BYTE
	i_need	EXTERR_LOCUS,BYTE
	I_need	FastOpenFlg,BYTE	  ;DOS 3.3
	I_need	FastOpenTable,BYTE	  ;DOS 3.3
	I_need	Dir_Info_Buff,BYTE	  ;DOS 3.3
	I_need	FastOpen_Ext_Info,BYTE	  ;DOS 3.3
	I_need	CLUSNUM,WORD		  ;DOS 3.3
	I_need	Next_Element_Start,WORD   ;DOS 3.3
	I_need	HIGH_SECTOR,WORD	  ;AN000;>32mb
	I_need	DOS34_FLAG,WORD 	  ;AN000;>32mb



DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<GETPATH -- PARSE A WFP>

;----------------------------------------------------------------------------
;
; Procedure Name : GETPATH
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
;		terminated; d:/ (note forward slash) indicates a real device).
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[NoSetDir] set
;	[THISDPB] set to DPB if disk otherwise garbage.
; Function:
;	Crack the path
; Outputs:
;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
;	Sets EXTERR_LOCUS = errLOC_Unk if char device
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path or attribute mismatch
;		or path too long or malformed path
;	ELSE
;	   [CurBuf] = -1 if root directory
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   [NAME1] Has name looked for
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it.
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from delete.asm , finfo.asm, mknode.asm and rename.asm. DS
;hkn; already set up at this point.

procedure   GETPATH,near
	DOSAssume   <DS>,"GetPath"

	MOV	WORD PTR CREATING,DIRFREE*256+0	; Not Creating, not DEL *.*

; Same as GetPath only CREATING and DELALL already set

entry	GetPathNoSet
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	WORD PTR CurBuf,-1	; initial setting

; See if the input indicates a device that has already been detected.  If so,
; go build the guy quickly.  Otherwise, let findpath find the device.

	MOV	DI,Wfp_Start		; point to the beginning of the name
	CMP	WORD PTR [DI+1],'\' SHL 8 + ':'
	JZ	CrackIt

; Let ChkDev find it in the device list

	ADD	DI,3
	MOV	SI,DI			; let CHKDEV see the original name
	CALL	CHKDEV
	JC	InternalError
Build_devJ:
	MOV	AL,SAttrib
	MOV	Attrib,AL
	MOV	[EXTERR_LOCUS],errLOC_Unk ; In the particular case of
					; "finding" a char device
					; set LOCUS to Unknown. This makes
					; certain idiotic problems reported
					; by a certain 3 letter OEM go away.

; Take name in name1 and pack it back into where wfp_start points.  This
; guarantees wfp_start pointing to a canonical representation of a device.
; We are allowed to do this as GetPath is *ALWAYS* called before entering a
; wfp into the share set.
;
; We copy chars from name1 to wfp_start remembering the position of the last
; non-space seen +1.  This position is kept in DX.


;hkn; SS is DOSDATA
	Context ES

;hkn; NAME1 is in DOSDATA
	mov	si,offset DOSDATA:Name1

	mov	di,wfp_start
	mov	dx,di
	mov	cx,8			; 8 chars in device name
MoveLoop:
	lodsb
	stosb
	cmp	al," "
	jz	nosave
 IFDEF  DBCS				;AN000;;
;	cmp	al,81h			;AN000;; 2/23/KK
;	jne	notKanji		;AN000;; 2/23/KK
;	cmp	cx,1			;AN000; 2/23/KK
;	je	notKanji		;AN000; 2/23/KK
;	cmp	byte ptr [si],40h	;AN000; 2/23/KK
;	jne	notKanji		;AN000;; 2/23/KK
;	lodsb				;AN000;; 2/23/KK
;	stosb				;AN000;; 2/23/KK
;	dec	cx			;AN000;; 2/23/KK
;	jmp	nosave			;AN000;; 2/23/KK
;notKanji:				;AN000;; 2/23/KK
 ENDIF
	mov	dx,di
NoSave:
	loop	MoveLoop
;
; DX is the position of the last seen non-space + 1.  We terminate the name
; at this point.
;
	mov	di,dx
	mov	byte ptr [di],0 	; end of string
	invoke	Build_device_ent	; Clears carry sets zero
	INC	AL			; reset zero
	return

	assume	es:nothing

InternalError:
	JMP	InternalError		; freeze


; Start off at the correct spot.  Optimize if the current dir part is valid.

CrackIt:
	MOV	SI,[CURR_DIR_END]	; get current directory pointer
	CMP	SI,-1			; valid?
	JNZ	LOOK_SING		; Yes, use it.
	LEA	SI,[DI+3]		; skip D:\
LOOK_SING:
	Assert	ISDPB,<<WORD PTR THISDPB+2>,<WORD PTR THISDPB>>,"Crackit"
	MOV	Attrib,attr_directory+attr_system+attr_hidden
					; Attributes to search through Dirs
	LES	DI,THISCDS
	MOV	AX,-1
	MOV	BX,ES:[DI.curdir_ID]
	MOV	SI,[CURR_DIR_END]

; AX = -1
; BX = cluster number of current directory.  THis number is -1 if the media
;      has been uncertainly changed.
; SI = offset in DOSGroup into path to end of current directory text.  This
;      may be -1 if no current directory part has been used.

	CMP	SI,AX			; if Current directory is not part
	JZ	NO_CURR_D		; then we must crack from root
	CMP	BX,AX			; is the current directory cluster valid

; DOS 3.3  6/25/86
	JZ	NO_CURR_D		; no, crack form the root
	TEST	[FastOpenFlg],FastOpen_Set     ; for fastopen ?
	JZ	GOT_SEARCH_CLUSTER	       ; no
	PUSH	ES			; save registers
	PUSH	DI
	PUSH	CX
	PUSH	[SI-1]			; save \ and 1st char of next element
	PUSH	SI
	PUSH	BX

	MOV	BYTE PTR [SI-1],0	; call fastopen to look up cur dir info
	MOV	SI,[Wfp_Start]

;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
	MOV	BX,OFFSET DOSDATA:FastOpenTable
	MOV	DI,OFFSET DOSDATA:Dir_Info_Buff
	MOV	CX,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV	AL,FONC_look_up
	PUSH	DS
	POP	ES
	CALL	DWORD PTR [BX.FASTOPEN_NAME_CACHING]
	JC	GO_Chk_end1			;fastopen not installed, or wrong drive. Go to Got_Srch_cluster
	CMP	BYTE PTR [SI],0 		;fastopen has current dir info?
	JE	GO_Chk_end			;yes. Go to got_serch_cluster
	stc
	jmp	short GO_Chk_end		;Go to No_Curr_D
GO_Chk_end1:
	clc
GO_Chk_end:					; restore registers
	POP	BX
	POP	SI
	POP	[SI-1]
	POP	CX
	POP	DI
	POP	ES
	JNC	GOT_SEARCH_CLUSTER		; crack based on cur dir

; DOS 3.3  6/25/86
;
; We must cract the path beginning at the root.  Advance pointer to beginning
; of path and go crack from root.

NO_CURR_D:
	MOV	SI,[WFP_START]
	LEA	SI,[SI+3]		; Skip "d:/"
	LES	BP,[THISDPB]		; Get ES:BP
	JMP	short ROOTPATH

; We are able to crack from the current directory part.  Go set up for search
; of specified cluster.

GOT_SEARCH_CLUSTER:
	LES	BP,[THISDPB]		; Get ES:BP
	invoke	SETDIRSRCH
	JC	SETFERR
	JMP	short FINDPATH

SETFERR:
	XOR	CL,CL			; set zero
	STC
	Return

EndProc GETPATH

;---------------------------------------------------------------------------
;
; Procedure Name : ChkDev
;
; Check to see if the name at DS:DI is a device.  Returns carry set if not a
;   device.
; Blasts CX,SI,DI,AX,BX
;---------------------------------------------------------------------------

Procedure   ChkDev,NEAR

	MOV	SI,DI
	MOV	DI,SS
	MOV	ES,DI

;hkn;	ASSUME	ES:DOSGroup		; Now here is where ES is DOSGroup
	ASSUME	ES:DOSDATA		; Now here is where ES is DOSDATA


;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	MOV	CX,9
TESTLOOP:
	invoke	GETLET
 IFDEF  DBCS				;AN000;
	invoke	Testkanj		;AN000;; 2/13/KK
	jz	Notkanja		;AN000;; 2/13/KK
	stosb				;AN000;; Skip second byte   2/13/KK
	dec	cx			;AN000;; 2/13/KK
	jcxz	notdev			;AN000;; 2/13/KK
	lodsb				;AN000;; 2/13/KK
	jmp	short stowit		;AN000;; 2/13/KK
Notkanja:				;AN000;
 ENDIF					;AN000;
	CMP	AL,'.'
	JZ	TESTDEVICE
	invoke	PATHCHRCMP
	JZ	NOTDEV
	OR	AL,AL
	JZ	TESTDEVICE
stowit:
	STOSB
	LOOP	TESTLOOP
NOTDEV:
	STC
	return

TESTDEVICE:
	ADD	CX,2
	MOV	AL,' '
	REP	STOSB
	MOV	AX,SS
	MOV	DS,AX
	invoke	DEVNAME
	return
EndProc ChkDev

Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
;----------------------------------------------------------------------------
;
; Procedure Name : ROOTPATH,FINDPATH
;
; Inputs:
;	Same as FINDPATH but,
;	SI Points to asciz string of path which is assumed to start at
;		the root (no leading '/').
; Function:
;	Search from root for path
; Outputs:
;	Same as FINDPATH but:
;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
;	[NoSetDir] is ignored.
;----------------------------------------------------------------------------

procedure   ROOTPATH,near
	DOSAssume   <DS>,"RootPath"

	invoke	SETROOTSRCH
	CMP	BYTE PTR [SI],0
	JNZ	FINDPATH

; Root dir specified
	MOV	AL,SAttrib
	MOV	Attrib,AL
	XOR	AH,AH			; Sets "device ID" byte, sets zero
					; (dir), clears carry.
	return

; Inputs:
;	[ATTRIB] Set to get through directories
;	[SATTRIB] Set to find last element
;	ES:BP Points to DPB
;	SI Points to asciz string of path (no leading '/').
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Phys sec # of first sector of directory
;	[CLUSNUM] = Cluster # of next cluster
;	[CLUSFAC] = Sectors per cluster
;	[NoSetDir] set
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[CREATING] and [DELALL] set
; Function:
;	Parse path name
; Outputs:
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	[THISDPB] = ES:BP
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path
;		or path too long or malformed path
;	ELSE
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
;	   [NAME1] Has name looked for
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it,
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; Destroys all other registers

    entry   FINDPATH
	DOSAssume   <DS>,"FindPath"
	ASSUME	ES:NOTHING

	Assert	ISDPB,<ES,BP>,"FindPath"
	PUSH	ES			; Save ES:BP
	PUSH	SI
	MOV	DI,SI
	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
	CMP	[CURR_DIR_END],-1
	JZ	NOIDS			; No current dir part
	CMP	DI,[CURR_DIR_END]
	JNZ	NOIDS			; Not to current dir end yet
	LES	DI,THISCDS
	MOV	ES:[DI.curdir_ID],CX	; Set current directory currency
NOIDS:

; Parse the name off of DS:SI into NAME1.  AL = 1 if there was a meta
; character in the string.  CX,DI  may be destroyed.
;
;	invoke	NAMETRANS
;	MOV	CL,AL
;
; The above is the slow method.  The name has *already* been munged by
; TransPath so no special casing needs to be done.  All we do is try to copy
; the name until ., \ or 0 is hit.

	MOV	AX,SS
	MOV	ES,AX

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1
	MOV	AX,'  '
	STOSB
	STOSW
	STOSW
	STOSW
	STOSW
	STOSW

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1
	XOR	AH,AH			; bits for CL
 IFDEF  DBCS				;AN000;
;-------------------------- Start of DBC;AN000;S 2/13/KK
	XOR	CL,CL			;AN000;; clear count for volume id
	LODSB				;AN000;;IBMJ fix 9/04/86
	CMP	AL,05h			;AN000;;IBMJ fix 9/04/86
	JNE	GetNam2 		;AN000;;IBMJ fix 9/04/86
	PUSH	AX			;AN000;        ;IBMJ fix 9/04/86
	MOV	AL,0E5h 		;AN000;;IBMJ fix 9/04/86
	Invoke	TestKanj		;AN000;;IBMJ fix 9/04/86
	POP	AX			;AN000;        ;IBMJ fix 9/04/86
	JZ	Notkanjb		;AN000;        ;IBMJ fix 9/04/86
	JMP	SHORT GetNam3		;AN000;;IBMJ fix 9/04/86
;-------------------------- End of DBCS ;AN000;2/13/KK
 ENDIF
GetNam:
	INC	CL			;AN000; KK incrment volid count
	LODSB
 IFDEF  DBCS				;AN000;
GetNam2:				;AN000;; 2/13/KK
	invoke	Testkanj		;AN000;; 2/13/KK
	jz	Notkanjb		;AN000;; 2/13/KK
GetNam3:				;AN000;; 2/13/KK
	STOSB				;AN000;; 2/13/KK
	INC	CL			;AN000;; KK incrment volid count
	LODSB				;AN000;; 2/13/KK
	TEST	[DOS34_FLAG],DBCS_VOLID ;AN000;; 2/13/KK
	JZ	notvol			;AN000;; 2/13/KK
	CMP	CL,8			;AN000;; 2/13/KK
	JNZ	notvol			;AN000;; 2/13/KK
	CMP	AL,'.'                  ;AN000;; 2/13/KK
	JNZ	notvol			;AN000;; 2/13/KK
	LODSB				;AN000;; 2/13/KK
notvol: 				;AN000;
	jmp	short StoNam		;AN000;; 2/13/KK
Notkanjb:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	CMP	AL,'.'
	JZ	setExt
	OR	AL,AL
	JZ	GetDone
	CMP	AL,'\'
	JZ	GetDone
	CMP	AL,'?'
	JNZ	StoNam
	OR	AH,1
StoNam: STOSB
	JMP	GetNam
SetExt:

;hkn; Name1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:Name1+8
GetExt:
	LODSB
 IFDEF  DBCS				;AN000;
	invoke	TestKanj		;AN000;; 2/13/KK
	jz	Notkanjc		;AN000;; 2/13/KK
	STOSB				;AN000;; 2/13/KK
	LODSB				;AN000;; 2/13/KK
	jmp	short StoExt		;AN000;; 2/13/KK
Notkanjc:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	OR	AL,AL
	JZ	GetDone
	CMP	AL,'\'
	JZ	GetDone
	CMP	AL,'?'
	JNZ	StoExt
	OR	AH,1
StoExt: STOSB
	JMP	GetExt
GetDone:
	DEC	SI
	MOV	CL,AH


	OR	CL,80H
	POP	DI			; Start of this element
	POP	ES			; Restore ES:BP
	CMP	SI,DI
	JNZ	check_device
	JMP	BADPATH 		; NUL parse (two delims most likely)
check_device:
	PUSH	SI			; Start of next element
	MOV	AL,BYTE PTR [SI]
	OR	AL,AL
	JNZ	NOT_LAST


; for last element of the path switch to the correct search attributes

	MOV	BH,SAttrib
	MOV	Attrib,BH
NOT_LAST:


; check name1 to see if we have a device...

	PUSH	ES			; Save ES:BP

;hkn; SS is DOSDATA
	context ES
	invoke	DevName 		; blast BX
	POP	ES			; Restore ES:BP
	ASSUME	ES:NOTHING
	JC	FindFile		; Not a device
	OR	AL,AL			; Test next char again
	JZ	GO_BDEV
	JMP	FileInPath		; Device name in middle of path

GO_BDEV:
	POP	SI			; Points to NUL at end of path
	JMP	Build_devJ

FindFile:
	ASSUME	ES:NOTHING
;;;; 7/28/86
	CMP	BYTE PTR [NAME1],0E5H	; if 1st char = E5
	JNZ	NOE5			; no
	MOV	BYTE PTR [NAME1],05H	; change it to 05
NOE5:

;;;; 7/28/86
	PUSH	DI			; Start of this element
	PUSH	ES			; Save ES:BP
	PUSH	CX			; CL return from NameTrans
;DOS 3.3 FastOPen 6/12/86 F.C.

	CALL	LookupPath		; call fastopen to get dir entry
	JNC	DIR_FOUND		; found dir entry

;DOS 3.3 FastOPen 6/12/86 F.C.
	invoke	FINDENTRY
DIR_FOUND:
	POP	CX
	POP	ES
	POP	DI
	JNC	LOAD_BUF
	JMP	BADPATHPOP

LOAD_BUF:
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	TEST	BYTE PTR [BX+dir_attr],attr_directory
	JNZ	GO_NEXT 		; DOS 3.3
	JMP	FileInPath		; Error or end of path

; if we are not setting the directory, then check for end of string

GO_NEXT:

;hkn; SS override
	CMP	BYTE PTR [NoSetDir],0
	JZ	SetDir
	MOV	DX,DI			; Save pointer to entry
	MOV	CX,DS

;hkn; SS is DOSDATA
	context DS
	POP	DI			; Start of next element
	TEST   [FastOpenFlg],FastOpen_Set     ;only DOSOPEN can take advantage of
	JZ     nofast			      ; the FastOpen
	TEST   [FastOpenFlg],Lookup_Success   ; Lookup just happened
	JZ     nofast			      ; no
	MOV    DI,[Next_Element_Start]	      ; no need to insert it again
nofast:
	CMP	BYTE PTR [DI],0
	JNZ	NEXT_ONE		; DOS 3.3
	JMP	SetRet			; Got it
NEXT_ONE:
	PUSH	DI			; Put start of next element back on stack
	MOV	DI,DX
	MOV	DS,CX			; Get back pointer to entry
ASSUME	DS:NOTHING

SetDir:
	MOV	DX,[SI] 		; Dir_first

;DOS 3.3 FastOPen 6/12/86 F.C.

	PUSH	DS		      ; save [curbuf+2]

;hkn; SS is DOSDATA
	context DS		      ; set DS Dosgroup
	TEST	[FastOpenFlg],Lookup_Success   ;
	JZ	DO_NORMAL	      ; fastopen not in memory or path not
	MOV	BX,DX		      ; not found
	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
	PUSH	AX		      ; save device id (AH)
	invoke	SETDIRSRCH
	POP	AX		      ; restore device id (AH)
	ADD	SP,2		      ; pop ds in stack
	JMP	short FAST_OPEN_SKIP

DO_NORMAL:
ASSUME	DS:NOTHING
	POP	DS			; DS = [curbuf + 2]
;DOS 3.3 FastOPen 6/12/86 F.C.

	SUB	BX,DI			; Offset into sector of start of entry
	SUB	SI,DI			; Offset into sector of dir_first
	PUSH	BX
	PUSH	AX
	PUSH	SI
	PUSH	CX
	PUSH	WORD PTR [DI.buf_sector]     ;AN000;>32mb
	PUSH	WORD PTR [DI.buf_sector+2]   ;AN000;>32mb
	MOV	BX,DX

;hkn; SS is DOSDATA
	context DS
	invoke	SETDIRSRCH		; This uses UNPACK which might blow
					; the entry sector buffer
	POP	[HIGH_SECTOR]
	POP	DX
	JC	SKIP_GETB
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL
	XOR	AL,AL
	invoke	GETBUFFR		; Get the entry buffer back
SKIP_GETB:
	POP	CX
	POP	SI
	POP	AX
	POP	BX
	JNC	SET_THE_BUF
	POP	DI			; Start of next element
	MOV	SI,DI			; Point with SI
	JMP	SHORT BADPATH

SET_THE_BUF:
	invoke	SET_BUF_AS_DIR
	MOV	DI,WORD PTR [CURBUF]
	ADD	SI,DI			; Get the offsets back
	ADD	BX,DI
; DOS 3.3 FasOpen 6/12/86  F.C.

FAST_OPEN_SKIP:

	POP	DI			; Start of next element
	CALL   InsertPath	     ; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.


	MOV	AL,[DI]
	OR	AL,AL
	JZ	SETRET			; At end
	INC	DI			; Skip over "/"
	MOV	SI,DI			; Point with SI
	invoke	PATHCHRCMP
	JNZ	find_bad_name		; oops
	JMP	FINDPATH		; Next element

find_bad_name:
	DEC	SI			; Undo above INC to get failure point
BADPATH:
	XOR	CL,CL			; Set zero
	JMP	SHORT BADPRET

FILEINPATH:
	POP	DI			; Start of next element

;hkn; SS is DOSDATA
	context DS			; Got to from one place with DS gone
; DOS 3.3 FastOpen

	TEST	[FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
	JZ	NO_FAST 		    ; device info to fastopen
	TEST	[FastOpenFlg],Lookup_Success
	JZ	NO_FAST
	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
					 ; success
NO_FAST:

; DOS 3.3 FastOpen

	MOV	AL,[DI]
	OR	AL,AL
	JZ	INCRET
	MOV	SI,DI			; Path too long
	JMP	SHORT BADPRET

INCRET:
; DOS 3.3 FasOpen 6/12/86  F.C.

	CALL   InsertPath	     ; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.
	INC	AL			; Reset zero
SETRET:
	return

BADPATHPOP:
	POP	SI			; Start of next element
	MOV	AL,[SI]
	MOV	SI,DI			; Start of bad element
	OR	AL,AL			; zero if bad element is last, non-zero if path too long
BADPRET:
	MOV	AL,SAttrib
	MOV	Attrib,AL		; Make sure return correct
	STC
	return
EndProc ROOTPATH

Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
;---------------------------------------------------------------------------
;
; Procedure Name : STARTDRCH
;
; Inputs:
;	[THISDPB] Set
; Function:
;	Set up a search for GETENTRY and NEXTENTRY
; Outputs:
;	ES:BP = Drive parameters
;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
; Destroys ES,BP,AX
;--------------------------------------------------------------------------

procedure   StartSrch,NEAR
	DOSAssume   <DS>,"StartSrch"

	Assert	ISDPB,<<WORD PTR THISDPB+2>,<WORD PTR THISDPB>>,"StartSrch"
	LES	BP,[THISDPB]
	XOR	AX,AX
	MOV	[LASTENT],AX
	MOV	BYTE PTR [VOLID],AL	; No volume ID found
	DEC	AX
	MOV	[ENTFREE],AX
	MOV	[ENTLAST],AX
	return
EndProc StartSrch

BREAK <MatchAttributes - the final check for attribute matching>
;----------------------------------------------------------------------------
; Procedure Name : MatchAttributes
;
; Input:    [Attrib] = attribute to search for
;	    CH = found attribute
; Output:   JZ <match>
;	    JNZ <nomatch>
; Registers modified: noneski
;----------------------------------------------------------------------------

procedure MatchAttributes,near
	PUSH	AX

;hkn; SS override
	MOV	AL,Attrib		; AL <- SearchSet
	NOT	AL			; AL <- SearchSet'
	AND	AL,CH			; AL <- SearchSet' and FoundSet
	AND	AL,attr_all		; AL <- SearchSet' and FoundSet and Important
;
; the result is non-zero if an attribute is not in the search set
; and in the found set and in the important set. This means that we do not
; have a match.  Do a JNZ <nomatch> or JZ <match>
;
	POP	AX
	return
EndProc MatchAttributes

Break <DevName - Look for name of device>
;---------------------------------------------------------------------------
;
; Procedure Name : DevName
;
; Inputs:
;	DS,ES:DOSDATA
;	Filename in NAME1
;	ATTRIB set so that we can error out if looking for Volume IDs
; Function:
;	Determine if file is in list of I/O drivers
; Outputs:
;	Carry set if not a device
;	ELSE
;	Zero flag set
;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
;	     bits 0-4 set from low byte of attribute word
;	DEVPT = DWORD pointer to Device header of device
; BX destroyed, others preserved
;---------------------------------------------------------------------------

procedure   DEVNAME,NEAR
	DOSAssume   <ES,DS>,"DevName"

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

; E5 special code
	PUSH	WORD PTR [NAME1]
	CMP	[NAME1],5
	JNZ	NOKTR
	MOV	[NAME1],0E5H
NOKTR:

	TEST	Attrib,attr_volume_id	; If looking for VOL id don't find devs
	JNZ	RET31

;hkn; NULDEV is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NULDEV
LOOKIO:
ASSUME	DS:NOTHING
	TEST	[SI.SDEVATT],DEVTYP
	JZ	SKIPDEV 		; Skip block devices (NET and LOCAL)
	MOV	AX,SI
	ADD	SI,SDEVNAME

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	MOV	CX,4			; All devices are 8 letters
	REPE	CMPSW			; Check for name in list
	MOV	SI,AX
	JZ	IOCHK			; Found it?
SKIPDEV:
	LDS	SI,DWORD PTR [SI]	; Get address of next device
	CMP	SI,-1			; At end of list?
	JNZ	LOOKIO
RET31:	STC				; Not found
RETNV:	MOV	CX,SS
	MOV	DS,CX

;hkn;	ASSUME	DS:DOSGroup
	ASSUME	DS:DOSDATA

	POP	WORD PTR [NAME1]
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	RET

IOCHK:
ASSUME	DS:NOTHING

;hkn; SS override for DEVPT
	MOV	WORD PTR [DEVPT+2],DS	; Save pointer to device
	MOV	BH,BYTE PTR [SI.SDEVATT]
	OR	BH,0C0H
	AND	BH,NOT 020H		; Clears Carry
	MOV	WORD PTR [DEVPT],SI
	JMP	RETNV
EndProc DevName

BREAK <Build_device_ent - Make a Directory entry>
;---------------------------------------------------------------------------
; Procedure Name : Build_device_ent
;
; Inputs:
;	[NAME1] has name
;	BH is attribute field (supplied by DEVNAME)
;	[DEVPT] points to device header (supplied by DEVNAME)
; Function:
;	Build a directory entry for a device at DEVFCB
; Outputs:
;	BX points to DEVFCB
;	SI points to dir_first field
;	AH = input BH
;	AL = 0
;	dir_first = DEVPT
;	Zero Set, Carry Clear
; DS,ES,BP preserved, others destroyed
;--------------------------------------------------------------------------

procedure Build_device_ent,near
	DOSAssume   <ES,DS>,"Build_Device_Ent"

	MOV	AX,"  "

;hkn; DEVFCB is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVFCB+8 ; Point to extent field

;	Fill dir_ext	BUGBUG - use ERRNZs for this stuff!

	STOSW
	STOSB				; Blank out extent field
	MOV	AL,attr_device

;	Fill Dir_attr

	STOSB				; Set attribute field
	XOR	AX,AX
	MOV	CX,10

; Fill dir_pad

	REP	STOSW			; Fill rest with zeros
	invoke	DATE16

;hkn; DEVFCB is in DOSDATA
	MOV	DI,OFFSET DOSDATA:DEVFCB+dir_time
	XCHG	AX,DX

; Fill dir_time

	STOSW
	XCHG	AX,DX

; Fill dir_date

	STOSW
	MOV	SI,DI			; SI points to dir_first field
	MOV	AX,WORD PTR [DEVPT]

; Fill dir_first

	STOSW				; Dir_first points to device
	MOV	AX,WORD PTR [DEVPT+2]
;
; Fill dir_size_l
;
	STOSW
	MOV	AH,BH			; Put device atts in AH

;hkn; DEVFCB is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVFCB
	XOR	AL,AL			; Set zero, clear carry
	return
EndProc Build_device_ent

Break	<ValidateCDS - given a CDS, validate the media and the current directory>
;----------------------------------------------------------------------------
;
;   ValidateCDS - Get current CDS.  Splice it.	Call FatReadCDS to check
;   media.  If media has been changed, do DOS_Chdir to validate path.  If
;   invalid, reset original CDS to root.
;
;   Inputs:	ThisCDS points to CDS of interest
;		SS:DI points to temp buffer
;   Outputs:	The current directory string is validated on the appropriate
;		    drive
;		ThisDPB changed
;		ES:DI point to CDS
;		Carry set if error (currently user FAILed to I 24)
;   Registers modified: all
;----------------------------------------------------------------------------

Procedure   ValidateCDS,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

Public DIR2001S,DIR2001E
DIR2001S:
	LocalVar    Temp,WORD
	LocalVar    SaveCDS,DWORD
DIR2001E:
	Enter
	MOV	Temp,DI

;hkn; SS override
	LDS	SI,ThisCDS
	MOV	SaveCDSL,SI
	MOV	SaveCDSH,DS
	EnterCrit   critDisk
	TEST	[SI].curdir_flags,curdir_isnet	; Clears carry
	JZ	DoSplice
	JMP	FatFail
DoSplice:
	XOR	DL,DL
	XCHG	DL,NoSetDir

;hkn; SS is DOSDATA
	Context ES
	Invoke	FStrcpy
	MOV	SI,Temp

;hkn; SS is DOSDATA
	Context DS
	Invoke	Splice
	ASSUME	DS:NOTHING

 ;hkn; SS is DOSDATA
	Context DS			;   FatReadCDS (ThisCDS);
	MOV	NoSetDir,DL
	LES	DI,ThisCDS
	SAVE	<BP>
	Invoke	FatRead_CDS
	RESTORE <BP>
	JC	FatFail
	LDS	SI,ThisCDS		;   if (ThisCDS->ID == -1) {
	ASSUME	DS:NOTHING
	CMP	[SI].curdir_ID,-1
	JNZ	RestoreCDS

;hkn; SS is DOSDATA
	Context ES

;hkn; SS override
	SAVE	<wfp_Start>		;	t = wfp_Start;
	CMP	SI,SaveCDSL		; if not spliced
	JNZ	DoChdir
	MOV	DI,Temp

;hkn; SS override
	MOV	wfp_Start,DI		;	wfp_start = d;
	Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
DoChdir:

;hkn; SS is DOSDATA
	Context DS
	SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
	Invoke	DOS_ChDir
	RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
	MOV	SAttrib,BL
	LDS	SI,SaveCDS
	ASSUME	DS:NOTHING
	JNC	SetCluster		;	if (c == -1) {

;hkn; SS override for THISCDS
	MOV	WORD PTR ThisCDS,SI	;	    ThisCDS = TmpCDS;
	MOV	WORD PTR ThisCDS+2,DS
	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
	MOV	[SI+3],CL		;	    }
SetCluster:
	MOV	[SI].curdir_ID,-1	;	TmpCDS->ID = -1;
	LDS	SI,ThisCDS		;	ThisCDS->ID = c;
	TEST	[SI].curdir_flags,curdir_splice      ;AN000;;MS.  for Join and Subst
	JZ	setdirclus			     ;AN000;;MS.
	MOV	CX,-1				     ;AN000;;MS.
setdirclus:
	MOV	[SI].curdir_ID,CX	;	}
RestoreCDS:

	LES	DI,SaveCDS
	MOV	WORD PTR ThisCDS,DI
	MOV	WORD PTR ThisCDS+2,ES
	CLC
FatFail:
	LeaveCrit   critDisk

	LES	DI,SaveCDS
	Leave
	return
EndProc ValidateCDS

Break	<CheckThisDevice - Check for being a device>
;---------------------------------------------------------------------------
;
;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
;   device specified.  We will return carry if there is a device present.  The
;   forms of devices we will recognize are:
;
;	[path]device
;
;   Note that the drive letter has *already* been removed.  All other forms
;   are not considered to be devices.  If such a device is found we change the
;   source pointer to point to the device component.
;
;   Inputs:	ES is DOSDATA
;		DS:SI contains name
;   Outputs:	ES is DOSDATA
;		DS:SI point to name or device
;		Carry flag set if device was found
;		Carry flag reset otherwise
;   Registers Modified: all except ES:DI, DS
;----------------------------------------------------------------------------

if FALSE
Procedure   CheckThisDevice,NEAR
	DOSAssume <ES>,"CheckThisDevice"
	SAVE	<DI,SI>
;
; Advance to after the final path character.
;
	MOV	DI,SI			; remember first character
PathSkip:
	LODSB
	OR	AL,AL
	JZ	FoundEnd
 IFDEF  DBCS			;AN000;
	invoke	Testkanj	;AN000;; 2/13/KK
	jz	Notkanje	;AN000;; 2/13/KK
	lodsb			;AN000;; 2/13/KK
	or	al,al		;AN000;; Skip second byte 2/13/KK  removed
	jz	FoundEnd	;AN000;; 2/13/KK		   removed
	jmp	Short Pathskip	;AN000;; Ignore missing second byte for now.
NotKanje:			;AN000;
  ENDIF 			;AN000;
;kanji load of next char too	  2/13/KK
IFDEF DBCS
 kanji load of next char too
ENDIF
	invoke	PathChrCmp		; is it a path char?
	JNZ	PathSkip
	MOV	DI,SI
	JMP	PathSkip
FoundEnd:
	MOV	SI,DI
;
; Parse the name
;
	SAVE	<DS,SI> 		; preserve the source pointer
	invoke	NameTrans		; advance DS:SI
	CMP	BYTE PTR [SI],0 	; parse entire string?
	STC				; simulate a Carry return from DevName
	JNZ	SkipSearch		; no parse.  simulate a file return.

;hkn; SS is DOSDATA
	Context DS
	Invoke	DevName
	ASSUME	DS:NOTHING
SkipSearch:
	RESTORE <SI,DS>
;
; DS:SI points to the beginning of the potential device.  If we have a device
; then we do not change SI.  If we have a file, then we reset SI back to the
; original value.  At this point Carry set indicates FILE.
;
	RESTORE <DI>		; get original SI
	JNC	CheckDone		; if device then do not reset pointer
	MOV	SI,DI
CheckDone:
	RESTORE <DI>
	CMC				; invert carry.  Carry => device
	return
else
Procedure   CheckThisDevice,NEAR
	DOSAssume <ES>,"CheckThisDevice"
	SAVE	<DI,SI>
	MOV	DI,SI
;
; Check for presence of \dev\ (Dam multiplan!)
;
	MOV	AL,[SI]
	Invoke	PathChrCmp		; is it a path char?
	JNZ	ParseDev		; no, go attempt to parse device
	INC	SI			; simulate LODSB
;
; We have the leading path separator.  Look for DEV part.
;
	LODSW
	OR	AX,2020h
	CMP	AX,"e" SHL 8 + "d"
	JNZ	NotDevice		; not "de", assume not device
	LODSB
	OR	AL,20h
	CMP	AL,"v"                  ; Not "v", assume not device
	JNZ	NotDevice
	LODSB
	invoke	PathChrCmp		; do we have the last path separator?
	JNZ	NotDevice		; no. go for it.
;
; DS:SI now points to a potential drive.  Preserve them as NameTrans advances
; SI and DevName may destroy DS.
;
ParseDev:
	SAVE	<DS,SI> 		; preserve the source pointer
	invoke	NameTrans		; advance DS:SI
	CMP	BYTE PTR [SI],0 	; parse entire string?
	STC				; simulate a Carry return from DevName
	JNZ	SkipSearch		; no parse.  simulate a file return.

;hkn; SS is DOSDATA
	Context DS

; M026 - start - fix ported from ROMDOS2 for bug # 2849
;
; SR;
; We have to set Attrib before invoking DevName. Otherwise, the value from
; a previous DOS call is used and DevName thinks it is not a device if the
; old call set the volume attribute bit.
;
	mov	al,SAttrib
	mov	Attrib,al		;set Attrib for DevName

; M026 - end

	Invoke	DevName
	ASSUME	DS:NOTHING
SkipSearch:
	RESTORE <SI,DS>
;
; SI points to the beginning of the potential device.  If we have a device
; then we do not change SI.  If we have a file, then we reset SI back to the
; original value.  At this point Carry set indicates FILE.
;
CheckReturn:
	RESTORE <DI>		; get original SI
	JNC	CheckDone		; if device then do not reset pointer
	MOV	SI,DI
CheckDone:
	RESTORE <DI>
	CMC				; invert carry.  Carry => device
	return
NotDevice:
	STC
	JMP	CheckReturn
endif

EndProc CheckThisDevice

BREAK <LookupPath - call fastopen to get dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : LookupPath
;
; Output  DS:SI -> path name,
;	  ES:DI -> dir entry info buffer
;	  ES:CX -> extended dir info buffer
;
;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
;			     FastOpen, DS:SI points to char just one after
;			     the last char of path name which is fully or
;			     partially found in FastOPen
;	  carry flag set : FastOpen not in memory or path name not found
;
;----------------------------------------------------------------------------

procedure LookupPath,NEAR

;	PUSH	AX

;hkn; SS override
	TEST	[FastOpenFlg],FastOpen_Set	    ; flg is set in DOSPEN
	JNZ	FASTINST			    ; and this routine is
NOLOOK:
	JMP	NOLOOKUP			    ; executed once
FASTINST:

;hkn; SS override
	TEST	[FastOpenFlg],No_Lookup 	    ; no more lookup?
	JNZ	NOLOOK				    ; yes

	MOV	BX,OFFSET DOSDATA:FastOpenTable    ; get fastopen related tab

;hkn; SS override
	MOV	SI,[Wfp_Start]			    ; si points to path name
	MOV	DI,OFFSET DOSDATA:Dir_Info_Buff
	MOV	CX,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV	AL,FONC_look_up 		    ; al = 1
	PUSH	DS
	POP	ES

;hkn; SS override
	CALL	DWORD PTR [BX.FASTOPEN_NAME_CACHING] ;call fastopen
	JC	NOTFOUND			    ; fastopen not in memory

	LEA	BX,[SI-2]

;hkn; SS override
	CMP	BX,[Wfp_Start]			    ; path found ?
	JZ	NOTFOUND			    ; no
						    ; fully or partially found
	CMP	BYTE PTR [SI],0 		    ;AN000;FO.
	JNZ	parfnd				    ;AN000;FO.; partiallyfound
	PUSH	CX				    ;AN000;FO.; is attribute matched ?

;hkn; SS override for attrib/sattrib
	MOV	CL,Attrib			    ;AN000;FO.;
	MOV	CH,Sattrib			    ;AN000;FO.; attrib=sattrib
	MOV	Attrib,CH			    ;AN000;FO.;
	MOV	CH,ES:[DI.dir_attr]		    ;AN000;FO.;
	invoke	Matchattributes 		    ;AN000;FO.;
;;;	MOV	Attrib,CL			    ;AN001;FO.; retore attrib
	POP	CX				    ;AN000;FO.;
	JNZ	NOLOOKUP			    ;AN000;FO.; not matched
parfnd:

;hkn; SS override
	MOV	[Next_Element_Start],SI 		   ; save si
	MOV	BX,CX
	MOV	AX,[BX.FEI_lastent]		    ;AN000;;FO. restore lastentry

;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
	MOV	[LASTENT],AX			    ;AN000;;FO.
	MOV	AX,[BX.FEI_dirstart]		    ;AN001;;FO. restore dirstart
	MOV	[DIRSTART],AX			    ;AN001;;FO.
	MOV	AX,[BX.FEI_clusnum]		    ; restore next cluster num
	MOV	[CLUSNUM],AX			    ;

	PUSH	ES				    ; save ES

;hkn; SS override
	LES	BX,[THISDPB]			    ; put drive id
	MOV	AH,ES:[BX.dpb_drive]		    ; in AH for DOOPEN
	POP	ES				    ; pop ES
;SR;
; We cannot have a root dir if we have come here. So, we zero out CurBuf to
;indicate it is not a root dir
;
	mov	word ptr CurBuf,0			;indicate not root dir

	MOV	WORD PTR [CURBUF+2],ES		    ; [curbuf+2].bx points to
	MOV	BX,DI				    ; start of entry
	LEA	SI,[DI.dir_first]		    ; [curbuf+2]:si points to
						    ; dir_first field in the
						    ; dir entry

;hkn; SS override for FastOpenFlg
	OR	[FastOpenFlg],Lookup_Success + set_for_search
;	POP	AX
	RET
NOTFOUND:
	CMP	AX,-1				    ; not in memory ?
	JNZ	Partial_Success 		    ; yes, in memory
	MOV	[FastOpenFlg],0 		    ; no more fastopen
Partial_Success:
	AND	[FastOpenFlg],Special_Fill_Reset
NOLOOKUP:
;	POP	AX
	STC
	RET
EndProc LookupPath

BREAK <InsertPath - call fastopen to insert dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : InsertPath
; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
;	  Lookup_Success flag set when got dir entry info from FASTOPEN
;	  DS = DOSDATA
; Output: FastOPen_Ext_Info is set and path dir info is inserted
;
;-----------------------------------------------------------------------------
procedure InsertPath,NEAR

	PUSHF

;hkn; SS override for FastOpenFlag
	TEST   [FastOpenFlg],FastOpen_Set     ;only DOSOPEN can take advantage of
	JZ     GET_NEXT_ELEMENT 	      ; the FastOpen
	TEST   [FastOpenFlg],Lookup_Success   ; Lookup just happened
	JZ     INSERT_DIR_INFO		      ; no
	AND    [FastOpenFlg],Lookup_Reset     ; we got dir info from fastopen so
	MOV    DI,[Next_Element_Start]	      ; no need to insert it again
	JMP    short GET_NEXT2
INSERT_DIR_INFO:			      ; save registers
	PUSH   DS
	PUSH   ES
	PUSH   BX
	PUSH   SI
	PUSH   DI
	PUSH   CX
	PUSH   AX

;hkn; SS override
	LDS    DI,[CURBUF]		; DS:DI -> buffer header
ASSUME DS:NOTHING
	MOV    SI,OFFSET DOSDATA:FastOpen_Ext_Info
	MOV    AX,WORD PTR [DI.buf_sector]  ; get directory sector
	MOV    WORD PTR SS:[SI.FEI_dirsec],AX ;AN000; >32mb save dir sector
	MOV    AX,WORD PTR [DI.buf_sector+2]  ;AN000; >32mb

;hkn; SS is DOSDATA
	context DS
	MOV    WORD PTR [SI.FEI_dirsec+2],AX  ;AN000;>32mb save high dir sector
	MOV    AX,[CLUSNUM]		; save next cluster number
	MOV    [SI.FEI_clusnum],AX
	MOV    AX,[LASTENT]		;AN000;FO. save lastentry for search first
	MOV    [SI.FEI_lastent],AX	;AN000;FO.
	MOV    AX,[DIRSTART]		;AN001;FO. save  for search first
	MOV    [SI.FEI_dirstart],AX	;AN001;FO.

	MOV    AX,BX
	ADD    DI,BUFINSIZ		; DS:DI -> start of data in buffer
	SUB    AX,DI			; AX=BX relative to start of sector
	MOV    CL,SIZE dir_entry
;invoke debug_DOS
	DIV    CL
	MOV    [SI.FEI_dirpos],AL	; save directory entry # in buffer

	PUSH   DS
	POP    ES

	MOV    DS,WORD PTR [CURBUF+2]
	MOV    DI,BX			; DS:DI -> dir entry info
ASSUME DS:NOTHING
	CMP    DS:[DI.dir_first],0	; never insert info when file is empty
	JZ     SKIP_INSERT		; e.g. newly created file

	PUSH   SI			; ES:BX -> extended info
	POP    BX

	MOV    AL,FONC_insert		; call fastopen insert operation
	MOV    SI,OFFSET DOSDATA:FastOpenTable
	CALL   DWORD PTR ES:[SI.FASTOPEN_NAME_CACHING]

	CLC
SKIP_INSERT:
	POP    AX
	POP    CX			; restore registers
	POP    DI
	POP    SI
	POP    BX
	POP    ES
	POP    DS
GET_NEXT2:
	OR     [FastOpenFlg],No_Lookup	      ; we got dir info from fastopen so
GET_NEXT_ELEMENT:
	POPF
	RET
EndProc InsertPath

DOSCODE	ENDS
    END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\disk2.asm ===
TITLE	DISK2 - Disk utility routines
	NAME	Disk2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	DskRead
;	DWRITE
;	DSKWRITE
;	HarderrRW
;	SETUP
;	BREAKDOWN
;	READ_LOCK_VIOLATION
;	WRITE_LOCK_VIOLATION
;	DISKREAD
;	SET_ACC_ERR_DS
;	SET_ACC_ERR
;	SETSFT
;	SETCLUS
;	AddRec
;
;	Revision history:
;
;		AN000 version 4.00 Jan. 1988
;		M039 DB 10/17/90 - Disk read/write optimization

	extrn	GetCurHead:near
	extrn	ScanPlace:near

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include dpb.inc
	include filemode.inc
        include dosmac.inc              ;M039
	.cref
	.list

Installed = TRUE

	i_need	THISSFT,DWORD
	i_need	DMAADD,DWORD
	i_need	NEXTADD,WORD
	i_need	ThisDrv,BYTE
	i_need	SecClusPos,BYTE
	i_need	ClusNum,WORD
	i_need	ReadOp,BYTE
	i_need	Trans,BYTE
	i_need	BytPos,4
	i_need	SecPos,DWORD		 ; DOS 4.00 >32mb			;AN000;
	i_need	BytSecPos,WORD
	i_need	BytCnt1,WORD
	i_need	BytCnt2,WORD
	i_need	SecCnt,WORD
	i_need	ThisDPB,DWORD
	i_need	LastPos,WORD
	i_need	EXTERRPT,DWORD
	i_need	CALLVIDRW,DWORD
	i_need	ALLOWED,BYTE
	i_need	DEVCALL,BYTE
	i_need	CALLSCNT,WORD

;**RMFHFE**	i_need	DISK_FULL,BYTE		  ; disk full flag for ran blk wrt

	i_need	HIGH_SECTOR,WORD	  ; F.C. >32mb	  ;AN000;
	i_need	TEMP_VAR2,WORD		  ; LB. 	  ;AN000;
	i_need	TEMP_VAR,WORD		  ; LB. 	  ;AN000;
	i_need	DirtyBufferCount,WORD
	i_need	FIRST_BUFF_ADDR,WORD	     ; first buffer address		;AN000;


DOSCODE	Segment
	ASSUME	SS:DOSDATA, CS:DOSCODE


Break	<DSKREAD -- PHYSICAL DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKREAD
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;---------------------------------------------------------------------------

procedure   DskRead,NEAR

	Assert	ISDPB,<ES,BP>,"DskRead"
	PUSH	CX
	MOV	AH,ES:[BP.dpb_media]
	MOV	AL,ES:[BP.dpb_UNIT]
	PUSH	BX
	PUSH	ES
	invoke	SETREAD
	JMP	short DODSKOP

Break	<DWRITE -- SEE ABOUT WRITING>
;--------------------------------------------------------------------------
;
; Procedure Name : DWRITE
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case HARDERR called
; Function:
;	Calls BIOS to perform disk write. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Output:
;	Carry set if error (currently, user FAILed to I 24)
; BP preserved. All other registers destroyed.
;----------------------------------------------------------------------------


	entry	DWRITE
ASSUME	DS:NOTHING,ES:NOTHING

	Assert	ISDPB,<ES,BP>,"DWrite"
	CALL	DSKWRITE
	jz	ret_label	; Carry clear (retz)

;hkn; SS override
	MOV	BYTE PTR [READOP],1
	invoke	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	DWRITE
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	NO_CAR2 	; Ignore
	STC
NO_CAR2:

ret_label:
	return

Break	<DSKWRITE -- PHYSICAL DISK WRITE>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKWRITE
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	DX = Absolute record number	       (LOW)
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;
;----------------------------------------------------------------------------

	entry	DSKWRITE
ASSUME	DS:NOTHING,ES:NOTHING

	Assert	ISDPB,<ES,BP>,"DskWrite"
	PUSH	CX
	MOV	AH,ES:[BP.dpb_media]
	MOV	AL,ES:[BP.dpb_UNIT]
	PUSH	BX
	PUSH	ES
	invoke	SETWRITE
DODSKOP:
	MOV	CX,DS		; Save DS
	POP	DS		; DS:BP points to DPB
	PUSH	DS
	LDS	SI,DS:[BP.dpb_driver_addr]
	invoke	DEVIOCALL2
	MOV	DS,CX		; Restore DS
	POP	ES		; Restore ES
	POP	BX

;hkn; SS override
	MOV	CX,[CALLSCNT]	; Number of sectors transferred
	POP	DI
	SUB	CX,DI
	NEG	CX		; Number of sectors not transferred

;hkn; SS override
	MOV	AX,[DEVCALL.REQSTAT]
	test	AX,STERR
	return
EndProc DskRead



Break	<HardErrRW - map extended errors and call harderr>
;---------------------------------------------------------------------------
;
; Procedure Name : HardErrRW
;
; Inputs:
;	AX is error code from read or write
;	Other registers set as per HARDERR
; Function:
;	Checks the error code for special extended
;	errors and maps them if needed. Then invokes
;	Harderr
; Outputs:
;	Of HARDERR
; AX may be modified prior to call to HARDERR.
; No other registers altered.
;
;---------------------------------------------------------------------------

procedure   HARDERRRW,near

	CMP	AL,error_I24_wrong_disk
	JNZ	DO_ERR				; Nothing to do

	push	ax
	mov	ax, word ptr callvidrw		; get ptr lo	;smr;SS Override
	mov	word ptr exterrpt, ax		; set ext err ptr lo
	mov	ax, word ptr callvidrw+2	; get ptr hi from dev
	mov	word ptr exterrpt+2, ax		; set ext err ptr hi
	pop	ax

;	PUSH	DS
;	PUSH	SI

;hkn; SS override for CALLVIDRW & EXTERRPT
;	LDS	SI,[CALLVIDRW]			; Get pointer from dev
;	MOV	WORD PTR [EXTERRPT+2],DS	; Set ext err pointer
;	MOV	WORD PTR [EXTERRPT],SI
;	POP	SI
;	POP	DS
DO_ERR:
	invoke	HARDERR
	return

EndProc HARDERRRW

Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
;----------------------------------------------------------------------------
;
; Procedure Name : SETUP
;
; Inputs:
;	ES:DI point to SFT (value also in THISSFT)
;	DMAAdd contains transfer address
;	CX = Byte count
;	DS = DOSDATA
;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
;		2nd of caller of caller.
; Outputs:
;	    CX = byte count
;	    [THISDPB] = Base of drive parameters if file
;		      = Pointer to device header if device or NET
;	    ES:DI Points to SFT
;	    [NEXTADD] = Displacement of disk transfer within segment
;	    [TRANS] = 0 (No transfers yet)
;	    BytPos = Byte position in file
;
;	The following fields are relevant to local files (not devices) only:
;
;	    SecPos = Position of first sector (local files only)
;	    [BYTSECPOS] = Byte position in first sector (local files only)
;	    [CLUSNUM] = First cluster (local files only)
;	    [SECCLUSPOS] = Sector within first cluster (local files only)
;	    [THISDRV] = Physical unit number (local files only)
;
;      RETURNS ONE LEVEL UP WITH:
;	   CX = 0
;	   CARRY = Clear
;	IF AN ERROR IS DETECTED
; All other registers destroyed
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS has been set up to DOSDATA.

procedure   SETUP,NEAR
	DOSAssume   <DS>,"SetUp"

	Assert	    ISSFT,<ES,DI>,"SetUp"
	LDS	SI,ES:[DI.sf_devptr]
ASSUME	DS:NOTHING

;hkn; SS override
	MOV	WORD PTR [THISDPB+2],DS

;hkn; SS is DOSDATA
	context DS

	MOV	WORD PTR [THISDPB],SI
	MOV	BX,WORD PTR DMAAdd
	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
	MOV	BYTE PTR [TRANS],0	;No transferes
	MOV	AX,WORD PTR ES:[DI.sf_Position]
	MOV	DX,WORD PTR ES:[DI.sf_Position+2]
	MOV	WORD PTR [BYTPOS+2],DX	;Set it
	MOV	WORD PTR BytPos,AX
	TESTB	ES:[DI].SF_FLAGS,<sf_isnet + devid_device>
	JNZ	NOSETSTUFF		;Following not done on devs or NET
	PUSH	ES
	LES	BP,[THISDPB]		;Point at the DPB
	Assert	ISDPB,<ES,BP>,"Setup"
	MOV	BL,ES:[BP.dpb_drive]
	MOV	[THISDRV],BL		;Set THISDRV
	MOV	BX,ES:[BP.dpb_sector_size]

;M039: Optimized this section.
        PUSH    CX                            ;SHR32 and DIV32 use CX.
	invoke	DIV32			      ;DX:AX/BX = CX:AX + DX (rem)
	MOV	[BYTSECPOS],DX
	MOV	WORD PTR SecPos,AX
	MOV	WORD PTR SecPos+2,CX
	MOV	DX,CX

	MOV	BX,AX
	AND	BL,ES:[BP.dpb_cluster_mask]
	MOV	[SECCLUSPOS],BL

	invoke	SHR32			     ;(DX:AX SHR dpb_cluster_shift)
	POP	CX			     ;CX = byte count.
	JNZ	EOFERR			     ;cluster number above 64k
	CMP	AX,ES:[BP.dpb_max_cluster]   ;>32mb    if > disk size ;AN000;	;AN000;
	JA	EOFERR			     ;>32mb    then EOF     ;AN000;	;AN000;

	MOV	[CLUSNUM],AX
	POP	ES			     ; ES:DI point to SFT
;M039

NOSETSTUFF:
	MOV	AX,CX		; AX = Byte count.
	ADD	AX,WORD PTR DMAAdd	 ; See if it will fit in one segment
	JNC	OK		; Must be less than 64K
	MOV	AX,WORD PTR DMAAdd
	NEG	AX		; Amount of room left in segment (know
				;    less than 64K since max value of CX
				;    is FFFF).
	JNZ	NoDec
	DEC	AX
NoDec:
	MOV	CX,AX		; Can do this much
	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
OK:
	return

EOFERR:
	POP	ES		; ES:DI point to SFT
	XOR	CX,CX		; No bytes read
;;;;;;;;;;; 7/18/86
;	MOV	BYTE PTR [DISK_FULL],1	    ; set disk full flag
;;;;;;;;;;;
NOROOM:
	POP	BX		; Kill return address
	CLC
	return			; RETURN TO CALLER OF CALLER
EndProc SETUP

Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
;---------------------------------------------------------------------------
;
; Procedure Name : BREAKDOWN
;
; Inputs:
;	CX = Length of disk transfer in bytes
;	ES:BP = Base of drive parameters
;	[BYTSECPOS] = Byte position witin first sector
;	DS = DOSDATA
; Outputs:
;	[BYTCNT1] = Bytes to transfer in first sector
;	[SECCNT] = No. of whole sectors to transfer
;	[BYTCNT2] = Bytes to transfer in last sector
; AX, BX, DX destroyed. No other registers affected.
;---------------------------------------------------------------------------

procedure   BREAKDOWN,near
	DOSAssume   <DS>,"BreakDown"

	Assert	    ISDPB,<ES,BP>,"BreakDown"
	MOV	AX,[BYTSECPOS]
	MOV	BX,CX
	OR	AX,AX
	JZ	SAVFIR		; Partial first sector?
	SUB	AX,ES:[BP.dpb_sector_size]
	NEG	AX		; Max number of bytes left in first sector
	SUB	BX,AX		; Subtract from total length
	JAE	SAVFIR
	ADD	AX,BX		; Don't use all of the rest of the sector
	XOR	BX,BX		; And no bytes are left
SAVFIR:
	MOV	[BYTCNT1],AX
	MOV	AX,BX
	XOR	DX,DX
	DIV	ES:[BP.dpb_sector_size]  ; How many whole sectors?
	MOV	[SECCNT],AX
	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
;	OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
;	retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
;	CMP	AX,1
;	retnz
;	MOV	AX,ES:[BP.dpb_sector_size]	 ; Buffer EXACT one sector I/O
;	MOV	[BYTCNT2],AX
;	MOV	[SECCNT],DX		; DX = 0
;RET45:
	return
EndProc BreakDown

;----------------------------------------------------------------------------
;
; Procedure Name : READ_LOCK_VIOLATION
;
; ES:DI points to SFT. This entry used by NET_READ
; Carry set if to return error (CX=0,AX=error_sharing_violation).
; Else do retrys.
; ES:DI,DS,CX preserved
;
;----------------------------------------------------------------------------

procedure READ_LOCK_VIOLATION,NEAR
	DOSAssume   <DS>,"Read_Lock_Viol"

	Assert	    ISSFT,<ES,DI>,"ReadLockViolation"

	MOV	[READOP],0
ERR_ON_CHECK:
	TESTB	ES:[DI.sf_mode],sf_isfcb
	JNZ	HARD_ERR
	PUSH	CX
	MOV	CL,BYTE PTR ES:[DI.sf_mode]
	AND	CL,sharing_mask
	CMP	CL,sharing_compat
	POP	CX
	JNE	NO_HARD_ERR
HARD_ERR:
	invoke	LOCK_VIOLATION
	retnc				; User wants Retrys
NO_HARD_ERR:
	XOR	CX,CX			;No bytes transferred
	MOV	AX,error_lock_violation
	STC
	return

EndProc READ_LOCK_VIOLATION

;----------------------------------------------------------------------------
;
; Procedure Name : WRITE_LOCK_VIOLATION
;
; Same as READ_LOCK_VIOLATION except for READOP.
; This entry used by NET_WRITE
;
;----------------------------------------------------------------------------

procedure WRITE_LOCK_VIOLATION,NEAR
	DOSAssume   <DS>,"Write_Lock_Viol"
	Assert	    ISSFT,<ES,DI>,"WriteLockViolation"

	MOV	[READOP],1
	JMP	ERR_ON_CHECK

EndProc WRITE_LOCK_VIOLATION


Break	<DISKREAD -- PERFORM USER DISK READ>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKREAD
;
; Inputs:
;	Outputs of SETUP
; Function:
;	Perform disk read
; Outputs:
;    Carry clear
;	CX = No. of bytes read
;	ES:DI point to SFT
;	SFT offset and cluster pointers updated
;    Carry set
;	CX = 0
;	ES:DI point to SFT
;	AX has error code
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS already set up.

procedure   DISKREAD,NEAR
	DOSAssume   <DS>,"DiskRead"

	Assert	ISSFT,<ES,DI>,"DISKREAD"
	MOV	AX,WORD PTR ES:[DI.sf_size]
	MOV	BX,WORD PTR ES:[DI.sf_size+2]
	SUB	AX,WORD PTR BytPos
	SBB	BX,WORD PTR [BYTPOS+2]
	JB	RDERR			;Read starts past EOF
	JNZ	ENUF			;More than 64k to EOF
	OR	AX,AX
	JZ	RDERR			;Read starts at EOF
	CMP	AX,CX
	JAE	ENUF			;I/O fits
	MOV	CX,AX			;Limit read to up til EOF
ENUF:
	invoke	CHECK_READ_LOCK 	;IFS. check read lock			 ;AN000;
	JNC	Read_Ok 		; There are no locks
	return

READ_OK:
	LES	BP,[THISDPB]
	Assert	ISDPB,<ES,BP>,"DISKREAD/ReadOK"


	CALL	BREAKDOWN
	MOV	CX,[CLUSNUM]
	invoke	FNDCLUS
                                        ;M022 conditional removed here
	JC	SET_ACC_ERR_DS		; fix to take care of I24 fail
					; migrated from 330a - HKN
	OR	CX,CX
	JZ	SKIPERR
RDERR:

;**RMFHFE**	MOV	[DISK_FULL],1		;MS. EOF detection  ;AN000;

	MOV	AH,0EH			;MS. read/data/fail ;AN000;
	transfer WRTERR22

;RDLASTJ: JMP	RDLAST                  ;M039

SETSFTJ2: JMP	SETSFT

CANOT_READ:
;	POP	CX		;M039.
	POP	CX              ;Clean stack.
	POP	BX

	entry	SET_ACC_ERR_DS
ASSUME	DS:NOTHING,ES:NOTHING

;hkn; SS is DOSDATA
	Context DS

entry	SET_ACC_ERR
	DOSAssume   <DS>,"SET_ACC_ERR"

	XOR	CX,CX
	MOV	AX,error_access_denied
	STC
	return

SKIPERR:
	MOV	[LASTPOS],DX
	MOV	[CLUSNUM],BX
	CMP	[BYTCNT1],0
	JZ	RDMID
	invoke	BUFRD
	JC	SET_ACC_ERR_DS
RDMID:
	CMP	[SECCNT],0
	JZ	RDLAST
	invoke	NEXTSEC
	JC	SETSFTJ2
	MOV	BYTE PTR [TRANS],1	; A transfer is taking place
ONSEC:
	MOV	DL,[SECCLUSPOS]
	MOV	CX,[SECCNT]
	MOV	BX,[CLUSNUM]
RDLP:
	invoke	OPTIMIZE
	JC	SET_ACC_ERR_DS
	PUSH	DI                      ;DI = Next physical cluster.
	PUSH	AX                      ;AX = # of sectors remaining.
        PUSH	BX			;[DMAADD+2]:BX = Transfer address.
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL + allowed_IGNORE
	MOV	DS,WORD PTR DmaAdd+2
ASSUME	DS:NOTHING
	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
	PUSH	CX                      ;CX = # of contiguous sectors to read.
	invoke	SET_RQ_SC_PARMS 	 ;LB. do this for SC		       ;AN000;

	invoke	DREAD

;M039
        pop     cx
        pop     dx
        pop     WORD PTR [TEMP_VAR]
	jc      CANOT_READ

        mov     WORD PTR [TEMP_VAR2],ds

;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;	The Buffer Queue must now be scanned: the contents of any dirty
;	buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.

        call    DskRdBufScan

	Context DS
        pop     cx
        pop     bx

;       CX = # of sector remaining.
;       BX = Next physical cluster.
;M039

	JCXZ	RDLAST
	invoke	IsEOF			; test for eof on fat size
	JAE	SETSFT
	MOV	DL,0
	INC	[LASTPOS]		; We'll be using next cluster
	JMP	RDLP

RDLAST:
	MOV	AX,[BYTCNT2]
	OR	AX,AX
	JZ	SETSFT
	MOV	[BYTCNT1],AX
	invoke	NEXTSEC
	JC	SETSFT
	MOV	[BYTSECPOS],0
	invoke	BUFRD
	JNC	SETSFT
	JMP	SET_ACC_ERR_DS

;------------------------------------------------------------------------------
;
; Procedure Name : SETSFT
; Inputs:
;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
;		and set cluster fields
; Function:
;	Update [THISSFT] based on the transfer
; Outputs:
;	sf_position, sf_lstclus, and sf_cluspos updated
;	ES:DI points to [THISSFT]
;	CX No. of bytes transferred
;	Carry clear
;
;----------------------------------------------------------------------------

entry	SETSFT
	DOSAssume   <DS>,"SetSFT"
	ASSUME	ES:NOTHING

	LES	DI,[THISSFT]

; Same as SETSFT except ES:DI already points to SFT
	entry	SETCLUS
	DOSAssume   <DS>,"SetClus"
	ASSUME	ES:NOTHING

	Assert	ISSFT,<ES,DI>,"SetClus"
	MOV	CX,[NEXTADD]
	SUB	CX,WORD PTR DMAAdd	 ; Number of bytes transfered
	TESTB	ES:[DI].SF_FLAGS,devid_device
	JNZ	ADDREC			 ; don't set clusters if device
	MOV	AX,[CLUSNUM]
	MOV	ES:[DI.sf_lstclus],AX
	MOV	AX,[LASTPOS]
	MOV	ES:[DI.sf_cluspos],AX

;----------------------------------------------------------------------------
;
; Procedure : AddRec
; Inputs:
;	ES:DI points to SFT
;	CX is No. Bytes transferred
; Function:
;	Update the SFT offset based on the transfer
; Outputs:
;	sf_position updated to point to first byte after transfer
;	ES:DI points to SFT
;	CX No. of bytes transferred
;	Carry clear
;----------------------------------------------------------------------------

	ASSUME	ES:NOTHING
entry	AddRec
	DOSAssume   <DS>,"AddRec"

	Assert	ISSFT,<ES,DI>,"AddRec"
	JCXZ	RET28		; If no records read,  don't change position
	ADD	WORD PTR ES:[DI.sf_position],CX  ; Update current position
	ADC	WORD PTR ES:[DI.sf_position+2],0
RET28:	CLC
	return
EndProc DISKREAD


Break   <DskRdBufScan -- Disk Read Buffer Scan>
;----------------------------------------------------------------------------
;
; Procedure Name : DskWrtBufScan
;
; Inputs:
;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;	The Buffer Queue is scanned: the contents of any dirty buffers are
;	"read" into the transfer memory block, so that the transfer memory
;	reflects the most recent data.
;
; Outputs:
;       Transfer memory updated as required.
;
; Uses:
;       DS,AX,BX,CX,SI,DI destroyed.
;       SS override for all global variables.
;
; Notes:
;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
;	than the FIRST.
;----------------------------------------------------------------------------
;M039: Created

procedure   DskRdBufScan,NEAR

ASSUME  DS:NOTHING

	cmp	[DirtyBufferCount],0	;Any dirty buffers?
	je	bufx			; -no, skip all work.

        mov     bx,[HIGH_SECTOR]
        mov     si,bx
        add     cx,dx
        adc     si,0

	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
        mov     ax,[di].buf_prev
        mov     [FIRST_BUFF_ADDR],ax

        Assert  ISDPB,<ES,BP>,"DISKREAD/bufchk"
	mov	al,es:[bp].dpb_drive

;            BX:DX = Extent start.
;            SI:CX = Extent end + 1.
;               AL = Drive #.
;            DS:DI-> 1st buffer in queue.
;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.

bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
	jne     bufq1        		;  -no, jump.

        Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
        ja	bufq1			;Jump if Extent start > buffer sector.
        Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
        ja	bufq2                   ;Jump if Extent end >= buffer sector.

bufq1:  cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
        mov     di,[di].buf_next        ; Set-up for next buffer.
        jne     bufq                    ; -no, do next buffer

bufx:   return                          ;Exit.

;       Buffer's sector is in Extent: if it is dirty, copy its contents to
;	transfer memory; otherwise, just re-position it in the buffer queue
;       as MRU (Most Recently Used).

bufq2:  SaveReg <ax>
        testb   [di.buf_flags],buf_dirty ;Buffer dirty?
        jz      bufq3                    ; -no, jump.

        SaveReg <cx,dx,si,di,es>

        mov     ax,dx
	sub	ax, word ptr [di].buf_sector
	neg	ax

;       AX = offset (in sectors) of buffer sector within Transfer memory
;            block.  (Note: the upper word of the sector # may be ignored
;	     since no more than 64k bytes will ever be read.  This 64k limit
;            is imposed by the input parameters of the disk read operation.)

	lea	si,[di].BUFINSIZ	;DS:SI -> buffer data.
        mov     cx,es:[bp].dpb_sector_size ;CX = sector size (in bytes).
	mul     cx			;AX = offset (in bytes) of buf. sector
        mov     di,WORD PTR [TEMP_VAR]
	add	di,ax
	mov	es,WORD PTR [TEMP_VAR2]
	shr	cx,1

;	   CX = sector size (in WORDs); CF=1 if odd # of bytes.
;       DS:SI-> Buffer sector data.
;       ES:DI-> Destination within Transfer memory block.

	rep	movsw			;Copy buffer sector to Transfer memory
	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	rep	movsb                   ;Copy last byte.
	RestoreReg <es,di,si,dx,cx>

;       DS:DI -> current buffer.

bufq3:  mov     ax,di			;DS:AX -> Current buffer.
        invoke  SCANPLACE
        cmp	ax,[FIRST_BUFF_ADDR]    ;Last buffer?
        RestoreReg <ax>
        jnz    	bufq                   	; -no, jump.
        jmp     short bufx              ; -yes, exit.

EndProc DskRdBufScan


DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\disk.asm ===
TITLE	DISK - Disk utility routines
	NAME	Disk

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	SWAPCON
;	SWAPBACK
;	DOS_READ
;	DOS_WRITE
;	get_io_sft
;	DirRead
;	FIRSTCLUSTER
;	SET_BUF_AS_DIR
;	FATSecRd
;	DREAD
;	CHECK_WRITE_LOCK
;	CHECK_READ_LOCK
;
;	Revision history:
;
;		A000   version 4.00  Jan. 1988
;
;----------------------------------------------------------------------------
;
; M065 : B#5276. On raw read/write of a block of characters if a critical
;		error happens, DOS retries the entire block assuming that
;		zero characters were transferred. Modified the code to take
;		into account the number of characters transfered before
;		retrying the operation.
;
;----------------------------------------------------------------------------
;
	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include fastxxxx.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include dpb.inc
	include mult.inc
	include filemode.inc
	.cref
	.list

Installed = TRUE

	I_need	DirStart,WORD
	I_Need	CONSft,DWORD		; SFT for swapped console In/Out
	i_need	CONSWAP,BYTE
	i_need	IDLEINT,BYTE
	i_need	THISSFT,DWORD
	i_need	DMAADD,DWORD
	i_need	DEVCALL,BYTE
	i_need	CALLSCNT,WORD
	i_need	CALLXAD,DWORD
	i_need	CONTPOS,WORD
	i_need	NEXTADD,WORD
	i_need	CONBUF,BYTE
	i_need	ClusFac,BYTE
	i_need	SecClusPos,BYTE
	i_need	DirSec,DWORD
	i_need	ClusNum,WORD
	i_need	NxtClusNum,WORD
	i_need	ReadOp,BYTE
	i_need	CURBUF,DWORD
	i_need	ALLOWED,BYTE
	i_need	EXTERR_LOCUS,BYTE


	i_need	HIGH_SECTOR,WORD
	I_need	JShare,DWORD
	i_need	DOS34_FLAG,WORD
;
;Flag to indicate WIN386 presence
;
	I_need	IsWin386,BYTE


DOSCODE	Segment
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	CharHard:near
	EXTRN	DevIoCall:near
	EXTRN	DevIoCall2:near
	EXTRN	Outt:near
	EXTRN	Setup:near


Break	<SwapCon, Swap Back - Old-style I/O to files>
; * * * * Drivers for file input from devices * * * *
;----------------------------------------------------------------------------
;   Indicate that ther is no more I/O occurring through another SFT outside of
;   handles 0 and 1
;
;   Inputs:	DS is DOSDATA
;   Outputs:	CONSWAP is set to false.
;   Registers modified: none
;----------------------------------------------------------------------------

procedure   SWAPBACK,NEAR

	DOSAssume   <DS>,"SwapBack"
	MOV	BYTE PTR [CONSWAP],0	; signal no conswaps
	return

EndProc SWAPBACK

;----------------------------------------------------------------------------
;
; Procedure Name : SWAPCON
;
;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
;
;   Inputs:	ThisSFT as the sft of the desired file
;		DS is DOSDATA
;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
;   Registers modified: none
;--------------------------------------------------------------------------

procedure   SWAPCON,NEAR
	DOSAssume   <DS>,"SwapCon"

	mov	byte ptr [ConSwap], 1		; ConSwap = TRUE

	push	ax
	mov	ax, word ptr ThisSFT
	mov	word ptr ConSFT, ax
	mov	ax, word ptr ThisSFT+2
	mov	word ptr ConSFT+2, ax
	pop	ax

	return

EndProc SWAPCON

Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
;-----------------------------------------------------------------------------
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to read
;	DS = DOSDATA
; Function:
;	Perform read operation
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes read
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;
;-----------------------------------------------------------------------------

;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.

procedure   DOS_READ,NEAR
	DOSAssume   <DS>,"DOS_Read"

	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DOS_Read"

; Verify that the sft has been opened in a mode that allows reading.

	MOV	AL,BYTE PTR ES:[DI.sf_mode]
	AND	AL,access_mask
	CMP	AL,open_for_write
	JNE	READ_NO_MODE		;Is read or both
	transfer   SET_ACC_ERR

READ_NO_MODE:
	call	SETUP
	JCXZ	NoIORet 		; no bytes to read - fast return
	invoke	IsSFTNet
	JZ	LOCAL_READ

IF NOT Installed
	transfer NET_READ
ELSE
	MOV	AX,(multNET SHL 8) OR 8
	INT	2FH
	return
ENDIF


; The user ended up requesting 0 bytes of input.  We do nothing for this case
; except return immediately.

NoIORet:
	CLC
	return

LOCAL_READ:
	TESTB	ES:[DI].SF_FLAGS,devid_device  ; Check for named device I/O
	JNZ	READDEV
	MOV	ExtErr_Locus,errLOC_Disk
	EnterCrit   critDisk

	invoke	DISKREAD

critexit:
	LeaveCrit   critDisk
	return


; We are reading from a device.  Examine the status of the device to see if we
; can short-circuit the I/O.  If the device in the EOF state or if it is the
; null device, we can safely indicate no transfer.

READDEV:
	DOSAssume   <DS>,"ReadDev"
	ASSUME	ES:NOTHING
	MOV	ExtErr_Locus,errLOC_SerDev
	MOV	BL,BYTE PTR ES:[DI].SF_FLAGS
	LES	DI,[DMAADD]
	test	BL,devid_device_EOF	; End of file?
	JZ	ENDRDDEVJ3
	test	BL,devid_device_null	; NUL device?
	JZ	TESTRAW 		; NO
	XOR	AL,AL			; Indicate EOF by setting zero
ENDRDDEVJ3:
	JMP	ENDRDDEVJ2

;
; We need to hit the device.  Figure out if we do a raw read or we do the
; bizarre std_con_string_input.
;
TESTRAW:
	test	BL,devid_device_raw	; Raw mode?
	JNZ	DVRDRAW 		; Yes, let the device do all local editing
	test	BL,devid_device_con_in	; Is it console device?
	JZ	NOTRDCON
	JMP	READCON

DVRDRAW:
	DOSAssume   <DS>,"DvRdRaw"	; BUGBUG - wasted DOSASSUME?
	PUSH	ES
	POP	DS			; Xaddr to DS:DI
    ASSUME DS:NOTHING

;SR;
;Check for win386 presence -- if present, do polled read of characters
;
	test	[IsWIN386],1
	jz	ReadRawRetry		;not present
	test	bl,devid_device_con_in	;is it console device
	jz	ReadRawRetry		;no, do normal read
	jmp	do_polling		;yes, do win386 polling loop

ReadRawRetry:
	MOV	BX,DI			; DS:BX transfer addr
	XOR	AX,AX			; Media Byte, unit = 0
	MOV	DX,AX			; Start at 0
	invoke	SETREAD
	PUSH	DS			; Save Seg part of Xaddr

;hkn; SS override
	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"DvRdRawR"
	call	DEVIOCALL
	MOV	DX,DI			; DS:DX is preserved by INT 24
	MOV	AH,86H			; Read error

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	crdrok			; no errors
	call	CHARHARD
	MOV	DI,DX			; DS:DI is Xaddr

	add	di, callscnt		; update ptr and count to reflect the	M065
	sub	cx, callscnt		; number of chars xferred		M065

	OR	AL,AL
	JZ	CRDROK			; Ignore
	CMP	AL,3
	JZ	CRDFERR 		; fail.
	POP	DS			; Recover saved seg part of Xaddr
	JMP	ReadRawRetry		; Retry

;
; We have encountered a device-driver error.  We have informed the user of it
; and he has said for us to fail the system call.
;
CRDFERR:
	POP	DI			; Clean stack
DEVIOFERR:

;hkn; SS override
	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DEVIOFERR"
	transfer    SET_ACC_ERR_DS

CRDROK:
	POP	DI			; Chuck saved seg of Xaddr
	MOV	DI,DX

;hkn; SS override
	ADD	DI,[CALLSCNT]		; Amount transferred
IF	DEBUG
	JMP	ENDRDDEVJ3
ELSE
	JMP	SHORT ENDRDDEVJ3
ENDIF


; We are going to do a cooked read on some character device.  There is a
; problem here, what does the data look like?  Is it a terminal device, line
; CR line CR line CR, or is it file data, line CR LF line CR LF?  Does it have
; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
; going to do this:  Read in pieces up to CR (CRs included in data) or ^z (^z
; included in data).  this "simulates" the way con works in cooked mode
; reading one line at a time.  With file data, however, the lines will look
; like, LF line CR.  This is a little weird.

NOTRDCON:
	MOV	AX,ES
	MOV	DS,AX
ASSUME	DS:NOTHING
	MOV	BX,DI
	XOR	DX,DX
	MOV	AX,DX
	PUSH	CX
	MOV	CX,1
	invoke	SETREAD
	POP	CX

;hkn; SS override
	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"/NotRdCon"
	LDS	SI,[SI.sf_devptr]
DVRDLP:
	invoke	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI		; Save "count" done
	MOV	AH,86H

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CRDOK
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	[CALLSCNT],1
	CMP	AL,1
	JZ	DVRDLP			;Retry
	CMP	AL,3
	JZ	DEVIOFERR		; FAIL
	XOR	AL,AL			; Ignore, Pick some random character
	JMP	SHORT DVRDIGN

CRDOK:
	POP	DI

;hkn; SS override
	CMP	[CALLSCNT],1
	JNZ	ENDRDDEVJ2
	PUSH	DS

;hkn; SS override
	MOV	DS,WORD PTR [CALLXAD+2]
	MOV	AL,BYTE PTR [DI]	; Get the character we just read
	POP	DS
DVRDIGN:

;hkn; SS override
	INC	WORD PTR [CALLXAD]	; Next character
	MOV	[DEVCALL.REQSTAT],0
	INC	DI			; Next character
	CMP	AL,1AH			; ^Z?
	JZ	ENDRDDEVJ2		; Yes, done zero set (EOF)
	CMP	AL,c_CR 		; CR?
	LOOPNZ	DVRDLP			; Loop if no, else done
	INC	AX			; Resets zero flag so NOT EOF, unless
					;  AX=FFFF which is not likely
ENDRDDEVJ2:
	JMP	ENDRDDEV		;changed short to long for win386

;SR;
;Polling code for raw read on CON when WIN386 is present
;
;At this point -- ds:di is transfer address
;		  cx is count
;

do_polling:
	mov	bx,di			;ds:bx is Xfer address
	xor	ax,ax
	mov	dx,ax
	call	setread			;prepare device packet

do_io:
;
;Change read to a NON-DESTRUCTIVE READ, NO WAIT
;
	mov	byte ptr es:[bx+2],DEVRDND	;Change command code
	push	ds
	lds	si,[THISSFT]		;get device header
	call	deviocall		;call device driver
	pop	ds
	
	test	es:[bx.REQSTAT],STERR	;check if error
	jz	check_busy		;no

	push	ds
	mov	dx,di
	invoke 	charhard		;invoke int 24h handler
	mov	di,dx
	or	al,al
	jz	pop_done_read		;ignore by user, assume read done
	cmp	al,3
	jz	devrderr		;user asked to fail
	pop	ds
	jmp	do_io			;user asked to retry

check_busy:
	test	es:[bx.REQSTAT],0200h	;see if busy bit set
	jnz	no_char			;yes, no character available
;
;Character is available. Read in 1 character at a time until all characters
;are read in or no character is available
;
	mov	byte ptr es:[bx+2],DEVRD	;command code is READ now
	mov	word ptr es:[bx+18],1		;change count to 1 character
	push	ds
	lds	si,[THISSFT]
	call	deviocall

	mov	dx,di
	mov	ah,86h
	mov	di,es:[bx.REQSTAT]	;get returned status
	test	di,STERR		;was there an error during read?
	jz	next_char		;no,read next character

	invoke	charhard		;invoke int 24h handler
	mov	di,dx			;restore di
	or	al,al			;
	jz	pop_done_read		;ignore by user,assume read is done
	cmp	al,3
	jz	devrderr		;user issued a 'fail',indicate error
	pop	ds
	jmp	do_io			;user issued a retry

next_char:
	pop	ds
	mov	di,dx
	dec	cx			;decrement count
	jcxz	done_read		;all characters read in
	inc	word ptr es:[bx+14]	;update transfer address
	jmp	do_io			;read next character in

devrderr:
	pop	di			;discard segment address
	les	di,[THISSFT]
	transfer SET_ACC_ERR_DS		;indicate error

no_char:
;
;Since no character is available, we let win386 switch the VM out
;
	push	ax
	mov	ah,84h
	int	2ah			;indicate idle to WIN386
;
;When control returns  from WIN386, we continue the raw read
;
	pop	ax
	jmp	do_io

pop_done_read:
	pop	ds
done_read:
	add	di,[CALLSCNT]
	jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit



ASSUME	DS:NOTHING,ES:NOTHING

TRANBUF:
	LODSB
	STOSB
	CMP	AL,c_CR 	; Check for carriage return
	JNZ	NORMCH
	MOV	BYTE PTR [SI],c_LF
NORMCH:
	CMP	AL,c_LF
	LOOPNZ	TRANBUF
	JNZ	ENDRDCON
	XOR	SI,SI		; Cause a new buffer to be read
	call	OUTT		; Transmit linefeed
	OR	AL,1		; Clear zero flag--not end of file
ENDRDCON:

;hkn; SS is DOSDATA
	Context DS
	CALL	SWAPBACK
	MOV	[CONTPOS],SI
ENDRDDEV:

;hkn; SS is DOSDATA
	Context DS

	MOV	[NEXTADD],DI
	JNZ	SETSFTC 	; Zero set if Ctrl-Z found in input
	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"EndRdDev"
	AND	BYTE PTR ES:[DI].SF_FLAGS,NOT devid_device_EOF ; Mark as no more data available
SETSFTC:
	invoke	SETSFT
	return

ASSUME	DS:NOTHING,ES:NOTHING

READCON:
	DOSAssume   <DS>,"ReadCon"
	CALL	SWAPCON
	MOV	SI,[CONTPOS]
	OR	SI,SI
	JNZ	TRANBUF
	CMP	BYTE PTR [CONBUF],128
	JZ	GETBUF
	MOV	WORD PTR [CONBUF],0FF80H	; Set up 128-byte buffer with no template
GETBUF:
	PUSH	CX
	PUSH	ES
	PUSH	DI

;hkn; CONBUF is in DOSDATA
	MOV	DX,OFFSET DOSDATA:CONBUF

	invoke	$STD_CON_STRING_INPUT		; Get input buffer
	POP	DI
	POP	ES
	POP	CX

;hkn; CONBUF is in DOSDATA
	MOV	SI,2 + OFFSET DOSDATA:CONBUF

	CMP	BYTE PTR [SI],1AH	; Check for Ctrl-Z in first character
	JNZ	TRANBUF
	MOV	AL,1AH
	STOSB
	DEC	DI
	MOV	AL,c_LF
	call	OUTT		; Send linefeed
	XOR	SI,SI
	JMP	ENDRDCON

EndProc DOS_READ

Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_WRITE
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to write
; Function:
;	Perform write operation
;	NOTE: If CX = 0 on input, file is truncated or grown
;		to current sf_position
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes written
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;---------------------------------------------------------------------------

;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
;hkn; point to DOSDATA.

procedure   DOS_WRITE,NEAR
	DOSAssume   <DS>,"DOS_Write"

	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DosWrite"
	MOV	AL,BYTE PTR ES:[DI.sf_mode]
	AND	AL,access_mask
	CMP	AL,open_for_read
	JNE	Check_FCB_RO		 ;Is write or both
BadMode:
	transfer    SET_ACC_ERR

;
; NOTE: The following check for writting to a Read Only File is performed
;	    ONLY on FCBs!!!!
;	We ALLOW writes to Read Only files via handles to allow a CREATE
;	    of a read only file which can then be written to.
;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
;	    CREATing a NEW RO file, or RE-CREATing an existing file which
;	    is NOT RO to be RO, via handles are the only times we can write
;	    to a read-only file.
;
Check_FCB_RO:
	TESTB	ES:[DI.sf_mode],sf_isfcb
	JZ	WRITE_NO_MODE		; Not an FCB
	TESTB	ES:[DI].sf_attr,attr_read_only
	JNZ	BadMode 		; Can't write to Read_Only files via FCB
WRITE_NO_MODE:
	call	SETUP
	invoke	IsSFTNet
	JZ	LOCAL_WRITE

IF NOT Installed
	transfer NET_WRITE
ELSE
	MOV	AX,(multNET SHL 8) OR 9
	INT	2FH
	return
ENDIF


LOCAL_WRITE:
	TESTB	ES:[DI].SF_FLAGS,devid_device  ; Check for named device I/O
	DLJNZ	WRTDEV
	MOV	ExtErr_Locus,errLOC_Disk
	EnterCrit   critDisk

	invoke	DISKWRITE

;; Extended Open
	JC	nocommit
	LES	DI,ThisSFT
	TESTB	ES:[DI.sf_mode],auto_commit_write
	JZ	nocommit
	PUSH	CX
	invoke	DOS_COMMIT
	POP	CX
nocommit:
;; Extended Open
	LeaveCrit   critDisk
	return

DVWRTRAW:
ASSUME	DS:NOTHING
	XOR	AX,AX			; Media Byte, unit = 0
	invoke	SETWRITE
	PUSH	DS			; Save seg of transfer

;hkn; SS override
	LDS	SI,ThisSFT
	Assert	ISSFT,<DS,SI>,"DosWrite/DvWrtRaw"
	call	DEVIOCALL		; DS:SI -> DEVICE


	MOV	DX,DI			; Offset part of Xaddr saved in DX
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CWRTROK
	call	CHARHARD

	sub	cx, callscnt		; update ptr & count to reflect	M065
	mov	bx, dx			; number of chars xferred	M065
	add	bx, callscnt		;				M065
	mov	di, bx			;				M065

;	MOV	BX,DX			; Recall transfer addr		M065

	OR	AL,AL
	JZ	CWRTROK 		; Ignore
	CMP	AL,3
	JZ	CWRFERR
	POP	DS			; Recover saved seg of transfer
	JMP	DVWRTRAW		; Try again

CWRFERR:
	POP	AX			; Chuck saved seg of transfer
	JMP	CRDFERR 		; Will pop one more stack element

CWRTROK:
	POP	AX			; Chuck saved seg of transfer
	POP	DS
	DOSAssume   <DS>,"DISK/CWrtOK"
	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
ENDWRDEV:
	LES	DI,ThisSFT
	Assert	ISSFT,<ES,DI>,"DosWrite/EndWrDev"
	MOV	CX,AX
	invoke	ADDREC
	return

WRTNUL:
	MOV	DX,CX			;Entire transfer done
WrtCookJ:
	JMP	WRTCOOKDONE

WRTDEV:
	DOSAssume   <DS>,"DISK/WrtDev"
	MOV	ExtErr_Locus,errLOC_SerDev
	OR	BYTE PTR ES:[DI].SF_FLAGS,devid_device_EOF  ; Reset EOF for input
	MOV	BL,BYTE PTR ES:[DI].SF_FLAGS
	XOR	AX,AX
	JCXZ	ENDWRDEV		; problem of creating on a device.
	PUSH	DS
	MOV	AL,BL
	LDS	BX,[DMAADD]		; Xaddr to DS:BX
ASSUME	DS:NOTHING
	MOV	DI,BX			; Xaddr to DS:DI
	XOR	DX,DX			; Set starting point
	test	AL,devid_device_raw	; Raw?
	JZ	TEST_DEV_CON
	JMP	DVWRTRAW

TEST_DEV_CON:
	test	AL,devid_device_con_out ; Console output device?
	DLJNZ	WRITECON
	test	AL,devid_device_null
	JNZ	WRTNUL
	MOV	AX,DX
	CMP	BYTE PTR [BX],1AH	; ^Z?
	JZ	WRTCOOKJ		; Yes, transfer nothing
	PUSH	CX
	MOV	CX,1
	invoke	SETWRITE
	POP	CX

;hkn; SS override
	LDS	SI,ThisSFT
;
;SR; Removed X25 support from here
;
	LDS	SI,[SI.sf_devptr]
DVWRTLP:
	invoke	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	jns	CWROK
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	[CALLSCNT],1
	CMP	AL,1
	JZ	DVWRTLP 	; Retry
	OR	AL,AL
	JZ	DVWRTIGN	; Ignore
	JMP	CRDFERR 	; Fail, pops one stack element

CWROK:
	POP	DI

;hkn; SS override
	CMP	[CALLSCNT],0
	JZ	WRTCOOKDONE
DVWRTIGN:
	INC	DX

;hkn; SS override for CALLXAD
	INC	WORD PTR [CALLXAD]
	INC	DI
	PUSH	DS
	MOV	DS,WORD PTR [CALLXAD+2]
	CMP	BYTE PTR [DI],1AH	; ^Z?
	POP	DS
	JZ	WRTCOOKDONE

;hkn; SS override
	MOV	[DEVCALL.REQSTAT],0
	LOOP	DVWRTLP
WRTCOOKDONE:
	MOV	AX,DX
	POP	DS
	JMP	ENDWRDEV

WRITECON:
	PUSH	DS

;hkn; SS is DOSDATA
	Context DS
	CALL	SWAPCON
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,BX
	PUSH	CX
WRCONLP:
	LODSB
	CMP	AL,1AH		; ^Z?
	JZ	CONEOF
	call	OUTT
	LOOP	WRCONLP
CONEOF:
	POP	AX			; Count
	SUB	AX,CX			; Amount actually written
	POP	DS
	DOSAssume   <DS>,"DISK/ConEOF"
	CALL	SWAPBACK
	JMP	ENDWRDEV

EndProc DOS_WRITE

;---------------------------------------------------------------------------
;
; Procedure Name : get_io_sft
;
;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
;   CONSWAP is FALSE or if the handle desired is 2 or more.  Otherwise, we
;   retrieve the sft from ConSFT which is set by SwapCon.
;
;---------------------------------------------------------------------------

procedure   get_io_sft,near
	cmp	ConSwap,0					;smr;SS Override
	JNZ	GetRedir
GetNormal:

;hkn; SS is DOSDATA
	Context DS

	PUSH	ES
	PUSH	DI
	invoke	SFFromHandle
	JC	RET44P
	MOV	SI,ES
	MOV	DS,SI
ASSUME	DS:NOTHING
	MOV	SI,DI
RET44P:
	POP	DI
	POP	ES
	return
GetRedir:
	CMP	BX,1
	JA	GetNormal

;hkn; SS override
	LDS	SI,ConSFT
	Assert	ISSFT,<DS,SI>,"GetIOSft"
	CLC
	return
EndProc get_io_sft

Break	<DIRREAD -- READ A DIRECTORY SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : DIRREAD
;
; Inputs:
;	AX = Directory block number (relative to first block of directory)
;	ES:BP = Base of drive parameters
;	[DIRSEC] = First sector of first cluster of directory
;	[CLUSNUM] = Next cluster
;	[CLUSFAC] = Sectors/Cluster
; Function:
;	Read the directory block into [CURBUF].
; Outputs:
;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
;	[SECCLUSPOS] Set
;	ES:BP unchanged
;	[CURBUF] Points to Buffer with dir sector
;	Carry set if error (user said FAIL to I 24)
; DS preserved, all other registers destroyed.
;---------------------------------------------------------------------------

;hkn; called from dir.asm. DS already set up to DOSDATA.

procedure   DirRead,NEAR

	DOSAssume   <DS>,"DirRead"
	Assert	    ISDPB,<ES,BP>,"DirRead"

; Note that ClusFac is is the sectors per cluster.  This is NOT necessarily
; the same as what is in the DPB!  In the case of the root directory, we have
; ClusFac = # sectors in the root directory.  The root directory is detected
; by DIRStart = 0.

	XOR	DX,DX
	CMP	DirStart,0
	jnz	SubDir
	XCHG	AX,DX
	JMP	short DoRead

; Convert the sector number in AX into cluster and sector-within-cluster pair

SubDir:
	MOV	DL,AL
	AND	DL,ES:[BP.dpb_cluster_mask]

;	(DX) = sector-in-cluster

	MOV	CL,ES:[BP.dpb_cluster_shift]
	SHR	AX,CL

;	(DX) = position in cluster
;	(AX) = number of clusters to skip

DoRead:
	MOV	[SECCLUSPOS],DL
	MOV	CX,AX
	MOV	AH,DL

;	(CX) = number of clusters to skip.
;	(AH) = remainder

	MOV	DX,WORD PTR [DIRSEC+2]	     ;>32mb
	MOV	[HIGH_SECTOR],DX	     ;>32mb
	MOV	DX,WORD PTR [DIRSEC]
	ADD	DL,AH
	ADC	DH,0
	ADC	[HIGH_SECTOR],0 	     ;>32mb

	MOV	BX,[CLUSNUM]
	MOV	[NXTCLUSNUM],BX
	JCXZ	FIRSTCLUSTER
SKPCLLP:
	invoke	UNPACK
	retc
	XCHG	BX,DI
	invoke	IsEOF			; test for eof based on fat size
	JAE	HAVESKIPPED
	LOOP	SKPCLLP
HAVESKIPPED:
	MOV	[NXTCLUSNUM],BX
	MOV	DX,DI
	MOV	BL,AH
	invoke	FIGREC

	entry	FIRSTCLUSTER

	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL
	XOR	AL,AL		; Indicate pre-read
	invoke	GETBUFFR
	retc

entry	SET_BUF_AS_DIR
	DOSAssume   <DS>,"SET_BUF_AS_DIR"
	ASSUME	ES:NOTHING

;	Set the type of CURBUF to be a directory sector.
;	Only flags are modified.

	PUSH	DS
	PUSH	SI
	LDS	SI,[CURBUF]
	Assert	ISBUF,<DS,SI>,"SetBufAsDir"
	OR	[SI.buf_flags],buf_isDIR	; Clears carry
	POP	SI
	POP	DS
	return
EndProc DirRead

Break	<FATSECRD -- READ A FAT SECTOR>
;----------------------------------------------------------------------------
;
; Procedure Name : FATSECRD
; Inputs:
;	Same as DREAD
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number
;	ES:BP = Base of drive parameters
; Function:
;	Calls BIOS to perform FAT read.
; Outputs:
;	Same as DREAD
;---------------------------------------------------------------------------

procedure   FATSecRd,NEAR

	Assert	    ISDPB,<ES,BP>,"FATSecRd"

;hkn; SS override
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL
	MOV	DI,CX
	MOV	CL,ES:[BP.dpb_FAT_count]
	MOV	AX,ES:[BP.dpb_FAT_size] 	;>32mb
;	XOR	AH,AH
	XOR	CH,CH				;>32mb
	PUSH	DX
NXTFAT:

;hkn; SS override
	MOV	[HIGH_SECTOR],0       ;>32mb FAT sectors cannot exceed
	PUSH	CX		      ;>32mb
	PUSH	AX
	MOV	CX,DI
	invoke	DSKREAD
	POP	AX
	POP	CX
	JZ	RET41P		; Carry clear
	ADD	DX,AX
	LOOP	NXTFAT
	POP	DX
	MOV	CX,DI

; NOTE FALL THROUGH

Break	<DREAD -- DO A DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DREAD
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number	      (LOW)
;	[HIGH_SECTOR]= Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case call to HARDERR needed
; Function:
;	Calls BIOS to perform disk read. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Outputs:
;	Carry set if error (currently user FAILED to INT 24)
; DS,ES:BP preserved. All other registers destroyed.
;---------------------------------------------------------------------------

	entry	DREAD
ASSUME	DS:NOTHING,ES:NOTHING

	Assert	ISDPB,<ES,BP>,"DREAD"
	invoke	DSKREAD
	retz			; Carry clear

;hkn; SS override
	MOV	BYTE PTR [READOP],0
	invoke	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	DREAD
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	NO_CAR		; Ignore
	STC
NO_CAR:
	return

RET41P: POP	DX
	return
EndProc FATSecRd


Break	<CHECK_WRITE_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_WRITE_LOCK
;
; Inputs:
;	output of SETUP
;	ES:DI -> SFT
; Function:
;	check write lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;
;----------------------------------------------------------------------------

procedure   CHECK_WRITE_LOCK,NEAR

	TESTB	ES:[DI].sf_attr,attr_volume_id ;volume id
	JZ	write_cont		       ;no
	invoke	SET_ACC_ERR_DS		       ;
	return

write_cont:				;
	PUSH	CX			;save reg
	OR	CX,CX			;
	JNZ	Not_Truncate		;
	dec	cx			;(cx) = -1; check for lock on whole file
Not_Truncate:				;
	MOV	AL,80H			;check write access
	invoke	LOCK_CHECK		;check lock
	POP	CX			;restore reg
	JNC	WRITE_OK		;lock ok
	invoke	WRITE_LOCK_VIOLATION	;issue I24
	JNC	write_cont		;retry
WRITE_OK:				;
	return				;

EndProc CHECK_WRITE_LOCK		;


Break	<CHECK_READ_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_READ_LOC
;
; Inputs:
;	ES:DI -> SFT
;	output of SETUP
; Function:
;	check read lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;----------------------------------------------------------------------------

procedure   CHECK_READ_LOCK,NEAR

	TESTB	ES:[DI].sf_attr,attr_volume_id ; volume id
	JZ	do_retry		       ; no
	invoke	SET_ACC_ERR		       ;
	return				       ;
do_retry:				;
	xor	al,al			;check read access
	invoke	LOCK_CHECK		;check lock
	JNC	READ_OK 		;lock ok
	invoke	READ_LOCK_VIOLATION	;issue I24
	JNC	do_retry		;retry
READ_OK:				;
	return				;
EndProc CHECK_READ_LOCK 		;

DOSCODE	ENDS
    END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\disk3.asm ===
page	,164
	TITLE   DISK3 - Disk utility routines
	NAME    Disk3

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**     Low level Read and write routines for local SFT I/O on files and devs
;
;       DISKWRITE
;       WRTERR
;
;       Revision history:
;
;           1.  AN000 version 4.00 Jan. 1988
;           2.  SR; 10/12/89; Fixed bug in DISKWRITE that caused incorrect
;               calculation of filesizes when they cross the 32M boundary
;               if the filesize is not a multiple of 512 bytes
;             AN002 - Sept. 1988, PTM#4977 fix (writing cluster bug)  Bill Lawton
;		M017 MD 8/30/90 - Rewrite SHR32 for better speed
;        	M039 DB 10/17/90 - Disk write optimization

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include dpb.inc
	include sf.inc
        include dosmac.inc              ;M039
	.cref
	.list

Installed = TRUE

	i_need	READOP,BYTE
	i_need	DISK_FULL,BYTE
	i_need  THISSFT,DWORD
	i_need  DMAADD,DWORD
	i_need  SecClusPos,BYTE
	i_need  ClusNum,WORD
	i_need  Trans,BYTE
	i_need  BytPos,4
	i_need  SecPos,DWORD              ;F.C. >32mb   ;AN000;
	i_need  BytSecPos,WORD
	i_need  BytCnt1,WORD
	i_need  BytCnt2,WORD
	i_need  SecCnt,WORD
	i_need  ThisDPB,DWORD
	i_need  LastPos,WORD
	i_need  ValSec,WORD               ;F.C. >32mb          ;AN000;
	i_need  GrowCnt,DWORD
	i_need  ALLOWED,BYTE
	I_need  JShare,DWORD


	I_need  HIGH_SECTOR,WORD          ;F.C. >32mb          ;AN000;
;	I_need  HIGH_SECTOR_TEMP,WORD     ;M039: Removed; F.C. >32mb ;AN000;

	I_need  EXTERR,WORD                        ; DOS 4.00   ;AN000;
	I_need  EXTERR_LOCUS,BYTE                  ; DOS 4.00   ;AN000;
	I_need  EXTERR_ACTION,BYTE                 ; DOS 4.00   ;AN000;
	I_need  EXTERR_CLASS,BYTE                  ; DOS 4.00   ;AN000;
	I_need  EXITHOLD,DWORD                     ; DOS 4.00   ;AN000;

;**RMFHFE**     I_need  DISK_FULL,BYTE                     ; DOS 4.00   ;AN000;

	I_need  SC_DRIVE,BYTE                      ; DOS 4.00   ;AN000;
	I_need  SC_CACHE_COUNT,WORD                ; DOS 4.00   ;AN000;

        I_need  SC_STATUS,WORD                     ;M039
        I_need  CURSC_SECTOR,WORD                  ;M039
        I_need  CURSC_DRIVE,BYTE                   ;M039

	I_need  ThisDRV,BYTE                       ; DOS 4.00   ;AN000;
	I_need  User_In_AX,WORD                    ; DOS 4.00   ;AN000;
	I_need  DOS34_FLAG,WORD                    ; DOS 4.00   ;AN000;
	I_need  FIRST_BUFF_ADDR,WORD               ; DOS 4.00   ;AN000;

        I_need  TEMP_VAR,WORD                      ;M039
        I_need  TEMP_VAR2,WORD                     ;M039


DOSCODE Segment
	ASSUME  SS:DOSDATA,CS:DOSCODE

Break   <DISKWRITE -- PERFORM USER DISK WRITE>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKWRITE
;
; Inputs:
;       Outputs of SETUP
; Function:
;       Perform disk write
; Outputs:
;    Carry clear
;       CX = No. of bytes read
;       ES:DI point to SFT
;       SFT offset and cluster pointers updated
;    Carry set
;       CX = 0
;       ES:DI point to SFT
;       AX has error code
;----------------------------------------------------------------------------

;hkn; called by DOS_WRITE. DS already set up at this point.

procedure   DISKWRITE,NEAR
	DOSAssume   <DS>,"DiskWrite"

	Assert  ISSFT,<ES,DI>,"DiskWrite"


	invoke  CHECK_WRITE_LOCK          ;IFS. check write lock                 ;AN000;
	JNC     WRITE_OK                  ;IFS. lock check ok                    ;AN000;
	return

WRTEOFJ:
	JMP     WRTEOF

WRITE_OK:
	AND     ES:[DI].SF_FLAGS,NOT (sf_close_nodate OR devid_file_clean)
				; Mark file as dirty, clear no date on close

	MOV	AX,WORD PTR ES:[DI.sf_size]		;M039
        MOV     [TEMP_VAR],AX                           ;M039
	MOV	AX,WORD PTR ES:[DI.sf_size+2]		;M039
        MOV     [TEMP_VAR2],AX                          ;M039

;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039

	LES     BP,[THISDPB]
	Assert  ISDPB,<ES,BP>,"DiskWrite/WriteOk"

	invoke  BREAKDOWN
	MOV     AX,WORD PTR [BYTPOS]
	MOV     DX,WORD PTR [BYTPOS+2]
	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
	ADD     AX,CX
	ADC     DX,0                    ;DX:AX = last byte to write + 1.

	MOV     BX,ES:[BP.dpb_sector_size]

	CALL    DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
	MOV     SI,AX
        MOV     [HIGH_SECTOR],CX

;       [HIGH_SECTOR]:SI = Last full sector to write.

	OR	DX,DX
	PUSH	DX			;M039: Free DX for use by SHR32
	MOV	DX,CX			;M039
	JNZ     CALCLUS
	SUB     AX,1                    ;AX must be zero base indexed          ;AC000;
	SBB	DX,0			;M039 ;F.C. >32mb			       ;AN000;

CALCLUS:
	CALL    SHR32                   ;F.C. >32mb                             ;AN000;
	POP	DX

;       AX = Last cluster to write.
;       DX = # of bytes in last sector to write (the "tail").
;       BX = ES:[BP.dpb_sector_size]

	PUSH    AX
	PUSH	DX

;M039
        mov     dx,[TEMP_VAR2]
        mov     ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
        call    DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
        mov     [TEMP_VAR2],cx
        mov     [VALSEC+2],cx
        mov     cx,ax
        mov     bx,si

;       [HIGH_SECTOR]:BX = Last full sector to write.
;          [VALSEC+2]:CX = Last full sector of current file.
;         [TEMP_VAR2]:CX = Last full sector of current file.
;                     DX = # of bytes in last sector of current file.
;M039

	OR      DX,DX
	JZ      NORND
	ADD     AX,1            	;Round up if any remainder                     ;AC000;
	ADC     [VALSEC+2],0
NORND:	MOV     WORD PTR [VALSEC],AX

;       [VALSEC] = Last sector of current file.

	XOR     AX,AX
	MOV     WORD PTR [GROWCNT],AX
	MOV     WORD PTR [GROWCNT+2],AX
	POP     AX

	MOV     DI,[HIGH_SECTOR]        ;F.C. >32mb                             ;AN000;
	CMP     DI,[TEMP_VAR2]		;M039; F.C. >32mb				;AN000;
	DLJB    NOGROW                  ;F.C. >32mb                             ;AN000;
	JZ      lowsec                  ;F.C. >32mb                             ;AN000;
	SUB     BX,CX                   ;F.C. >32mb                             ;AN000;
	SBB     DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors    ;AN000;
	JMP     short yesgrow           ;F.C. >32mb                             ;AN000;
lowsec:
	MOV     DI,0            ;F.C. >32mb
	SUB     BX,CX           ; Number of full sectors
	JB      NOGROW
	JZ      TESTTAIL
yesgrow:
	MOV     CX,DX
	XCHG    AX,BX
	MUL     ES:[BP.dpb_sector_size]  ; Bytes of full sector growth
	MOV     [HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
	MOV     [TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax                ;AN000;
	MOV     AX,DI                    ;F.C. >32mb                            ;AN000;
	MUL     ES:[BP.dpb_sector_size]  ;F.C. >32mb do higher word multiply    ;AN000;
	ADD     AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
	MOV     DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
	MOV     AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply      ;AN000;

	SUB     AX,CX           ; Take off current "tail"
	SBB     DX,0            ; 32-bit extension
	ADD     AX,BX           ; Add on new "tail"
	ADC     DX,0            ; ripple tim's head off
	JMP     SHORT SETGRW
HAVSTART:
;int 3
	MOV     CX,AX
	invoke  SKPCLP
	JCXZ    DOWRTJ


	invoke  ALLOCATE
	JNC     DOWRTJ

entry   WRTERR
	DOSAssume   <DS>,"DiskWrite/WrtErr"
	ASSUME  ES:NOTHING

	MOV     AH,0FH                          ;MS. write/data/fail/abort      ;AN000;
entry WRTERR22
	MOV     AL,[THISDRV]                    ;MS.                            ;AN000;

;**RMFHFE**     CALL    File_Handle_Fail_Error  ;MS. issue disk full I24

;**RMFHFE**     MOV     CX,0                    ;No bytes transferred
	XOR     CX,CX                   ; will be deleted

	LES     DI,[THISSFT]
	Assert  ISSFT,<ES,DI>,"DiskWrite/WrtErr"
	CLC
	return

DOWRTJ: JMP     short DOWRT

ACC_ERRWJ:
	JMP     SET_ACC_ERRW

TESTTAIL:
	SUB     AX,DX
	JBE     NOGROW
	XOR     DX,DX
SETGRW:
	MOV     WORD PTR [GROWCNT],AX
	MOV     WORD PTR [GROWCNT+2],DX
NOGROW:
	POP     AX
	MOV     CX,[CLUSNUM]    ; First cluster accessed
	invoke  FNDCLUS
	JC      ACC_ERRWJ
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX


	SUB     AX,DX           ; Last cluster minus current cluster
	JZ      DOWRT           ; If we have last clus, we must have first
	JCXZ    HAVSTART        ; See if no more data
	PUSH    CX              ; No. of clusters short of first
	MOV     CX,AX

	invoke  ALLOCATE
	POP     CX
	JC      WRTERR
	MOV     DX,[LASTPOS]
	INC     DX
	DEC     CX
	JZ      NOSKIP
	invoke  SKPCLP
	JC      ACC_ERRWJ
NOSKIP:
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX
DOWRT:
	CMP     [BYTCNT1],0
	JZ      WRTMID
	MOV     BX,[CLUSNUM]
	invoke  BUFWRT
	JC      ACC_ERRWJ
WRTMID:
	MOV     AX,[SECCNT]
	OR      AX,AX
	JZ      WRTLAST                  ;M039
	ADD     WORD PTR [SECPOS],AX
	ADC     WORD PTR [SECPOS+2],0    ;F.C. >32mb                            ;AN000;
	invoke  NEXTSEC
	JC      SET_ACC_ERRW             ;M039
	MOV     BYTE PTR [TRANS],1       ; A transfer is taking place
	MOV     DL,[SECCLUSPOS]
	MOV     BX,[CLUSNUM]
	MOV     CX,[SECCNT]
WRTLP:
	invoke  OPTIMIZE
	JC     	SET_ACC_ERRW

;M039
;       DI = Next physical cluster.
;       AX = # sectors remaining.
;       [DMAADD+2]:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.

	push    di
	push    ax
        call    DskWrtBufPurge          ;DS trashed.
ASSUME DS:NOTHING
;M039

;hkn; SS override for DMAADD and ALLOWED
	MOV     DS,WORD PTR [DMAADD+2]
	MOV	[ALLOWED],allowed_RETRY + allowed_FAIL + allowed_IGNORE

;	put logic from DWRITE in-line here so we can modify it
;	for DISK FULL conditions.

DWRITE_LUP:
	invoke	DSKWRITE
	jz	DWRITE_OKAY

;	int	3
	cmp	al,error_handle_Disk_Full	; compressed volume full?
	jz	DWRITE_DISK_FULL

;hkn; SS override
	MOV	BYTE PTR [READOP],1
	invoke	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	DWRITE_LUP
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	DWRITE_OKAY 	; Ignore
	STC

DWRITE_OKAY:


	POP     CX
	POP     BX

;       CX = # sectors remaining.
;       BX = Next physical cluster.

;hkn; SS override
	Context DS

	JC      SET_ACC_ERRW
	JCXZ    WRTLAST
	MOV     DL,0
	INC     [LASTPOS]       ; We'll be using next cluster
	JMP     WRTLP

DWRITE_DISK_FULL:
        Context DS		;SQ 3-5-93 DS must be setup on return!
	pop	cx		; unjunk stack
	pop	bx
	mov	[DISK_FULL],1
	stc
	jmp	WRTERR		; go to disk full exit

SET_ACC_ERRW:
	transfer SET_ACC_ERR_DS

WRTLAST:
	MOV     AX,[BYTCNT2]
	OR      AX,AX
	JZ      FINWRT
	MOV     [BYTCNT1],AX
	invoke  NEXTSEC
	JC      SET_ACC_ERRW
	MOV     [BYTSECPOS],0
	invoke  BUFWRT
	JC      SET_ACC_ERRW
FINWRT:
	LES     DI,[THISSFT]
	Assert  ISSFT,<ES,DI>,"DiskWrite/FinWrt"
	MOV     AX,WORD PTR [GROWCNT]
	MOV     CX,WORD PTR [GROWCNT+2]
	OR      AX,AX
	JNZ     UPDATE_size
	JCXZ    SAMSIZ
Update_size:
	ADD     WORD PTR ES:[DI.sf_size],AX
	ADC     WORD PTR ES:[DI.sf_size+2],CX
;
; Make sure that all other SFT's see this growth also.
;
	MOV     AX,1
if installed
	call    JShare + 14 * 4
else
	Call    ShSU
endif
SAMSIZ:
	transfer SETCLUS                  ; ES:DI already points to SFT

WRTEOF:
	MOV     CX,AX
	OR      CX,DX
	JZ      KILLFIL
	SUB     AX,1
	SBB     DX,0

	PUSH    BX
	MOV     BX,ES:[BP.dpb_sector_size]    ;F.C. >32mb                       ;AN000;
	CALL    DIV32                         ;F.C. >32mb                       ;AN000;
	POP	BX			      ;F.C. >32mb			;AN000;
	MOV	DX,CX			      ;M039
        MOV     [HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
	CALL    SHR32                         ;F.C. >32mb                       ;AN000;

	MOV     CX,AX
	invoke  FNDCLUS
SET_ACC_ERRWJ2:
	JC      SET_ACC_ERRW


	JCXZ    RELFILE
	invoke  ALLOCATE
	JC      WRTERRJ              ;;;;;;;;; disk full
UPDATE:
	LES     DI,[THISSFT]
	Assert  ISSFT,<ES,DI>,"DiskWrite/update"
	MOV     AX,WORD PTR [BYTPOS]
	MOV     WORD PTR ES:[DI.sf_size],AX
	MOV     AX,WORD PTR [BYTPOS+2]
	MOV     WORD PTR ES:[DI.sf_size+2],AX
;
; Make sure that all other SFT's see this growth also.
;
	MOV     AX,2
if installed
	Call    JShare + 14 * 4
else
	Call    ShSU
endif
	XOR     CX,CX
	transfer ADDREC

WRTERRJ: JMP     WRTERR
;;;;;;;;;;;;;;;; 7/18/86
;;;;;;;;;;;;;;;;;
RELFILE:
	PUSH    ES                    ;AN002; BL   Reset Lstclus and cluspos to
	LES     DI,[THISSFT]          ;AN002; BL   beginning of file if current
	CMP     DX,ES:[DI.sf_cluspos] ;AN002; BL   cluspos is past EOF.
	JAE     SKIPRESET             ;AN002; BL
	MOV     ES:[DI.sf_cluspos],0  ;AN002; BL
	MOV     DX,ES:[DI.sf_firclus] ;AN002; BL
	MOV     ES:[DI.sf_lstclus],DX ;AN002; BL
SKIPRESET:                            ;AN002; BL
	POP     ES                    ;AN002; BL
;
	MOV     DX,0FFFFH
	invoke  RELBLKS
Set_Acc_ERRWJJ:
	JC      SET_ACC_ERRWJ2
	JMP     SHORT UPDATE

KILLFIL:
	XOR     BX,BX
	PUSH    ES
	LES     DI,[THISSFT]
	Assert  ISSFT,<ES,DI>,"DiskWrite/KillFil"
	MOV     ES:[DI.sf_cluspos],BX
	MOV     ES:[DI.sf_lstclus],BX
	XCHG    BX,ES:[DI.sf_firclus]
	POP     ES

	OR      BX,BX
	JZ      UPDATEJ
;; 10/23/86 FastOpen update
	PUSH    ES              ; since first cluster # is 0
	PUSH    BP              ; we must delete the old cache entry
	PUSH    AX
	PUSH    CX
	PUSH    DX
	LES     BP,[THISDPB]             ; get current DPB
	MOV     DL,ES:[BP.dpb_drive]     ; get current drive
	MOV     CX,BX                    ; first cluster #
	MOV     AH,2                     ; delete cache entry by drive:firclus
	invoke  FastOpen_Update          ; call fastopen
	POP     DX
	POP     CX
	POP     AX
	POP     BP
	POP     ES
;; 10/23/86 FastOpen update

	invoke  RELEASE
	JC      SET_ACC_ERRWJJ
UpDateJ:
	JMP     UPDATE
EndProc DISKWRITE



Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
;----------------------------------------------------------------------------
;
; Procedure Name : DskWrtBufPurge
;
; Inputs:
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.
;
; Outputs:
;       (Same as Input.)
; Uses:
;       All registers except DS,AX,SI,DI preserved.
;       SS override for all global variables.
;----------------------------------------------------------------------------
;M039: Created

procedure   DskWrtBufPurge,NEAR

ASSUME  DS:NOTHING

        SaveReg <bx,cx>
        mov	bx,[HIGH_SECTOR]	;BX:DX = Extent start (sector #).
        mov     si,bx
        add     cx,dx
        adc     si,0                    ;SI:CX = Extent end + 1.

	Assert  ISDPB,<ES,BP>,"DskWrtBufPurge"
	mov     al,es:[bp.dpb_drive]

;       BX:DX = Extent start.
;       SI:CX = Extent end + 1.
;          AL = Drive #

	cmp     [SC_CACHE_COUNT],0      ;Secondary cache in-use?
	je      nosc                    ; -no, jump.

;       If any of the sectors to be written are in the secondary cache (SC),
;       invalidate the entire SC. (This is an optimization; we really only
;	need to invalidate those sectors which intersect, but that's slower.)

        cmp     al,[CURSC_DRIVE]        ;Same drive?
        jne     nosc                    ; -no, jump.

        push    ax
        mov     ax,[CURSC_SECTOR]
        mov     di,[CURSC_SECTOR+2]     ;DI:AX = SC start.
        Cmp32   si,cx,di,ax             ;Extent end < SC start?
        jbe     sc5                     ; -yes, jump.
        add     ax,[SC_CACHE_COUNT]
        adc     di,0                    ;DI:AX = SC end + 1.
        Cmp32   bx,dx,di,ax             ;Extent start > SC end?
        jae     sc5                     ; -yes, jump.
        mov     [SC_STATUS],0           ;Extent intersects SC: invalidate SC.
sc5:	pop     ax

;       Free any buffered sectors which are in Extent; they are being over-
;       written.

nosc:	invoke  GETCURHEAD              ;DS:DI -> first buffer in queue.

bufq:   cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
        jne     bufq5                   ; -no, jump.

        Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
        ja	bufq5			;Jump if Extent start > buffer sector.
        Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
        jbe	bufq5                   ;Jump if Extent end < buffer sector.

;       Buffer's sector is in Extent, so free it; it is being over-written.

        testb   [di.buf_flags],buf_dirty ;Buffer dirty?
        jz      bufq2                    ; -no, jump.
        invoke  DEC_DIRTY_COUNT          ; -yes, decrement dirty count.
bufq2:  mov     WORD PTR [di.buf_ID],((buf_visit SHL 8) OR 0FFh)

        invoke  SCANPLACE
        jmp     short bufq6

bufq5:  mov     di,[di.buf_next]
bufq6:  cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
        jne     bufq	                ; --no, go do next buffer.

        RestoreReg <cx,bx>
        return

EndProc DskWrtBufPurge


Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
;----------------------------------------------------------------------------
;
; Procedure Name : DIV32
;
; Inputs:
;       DX:AX = 32 bit dividend   BX= divisor
; Function:
;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
; Outputs:
;       CX:AX = quotient , DX= remainder
; Uses:
;       All registers except AX,CX,DX preserved.
;----------------------------------------------------------------------------
;M039: DIV32 optimized for divisor of 512 (common sector size).

procedure   DIV32,NEAR

        cmp     bx,512
        jne    	short div5

	mov     cx,dx
        mov     dx,ax           ; CX:AX = Dividend
        and     dx,(512-1)      ; DX = Remainder
        mov     al,ah
        mov     ah,cl
        mov     cl,ch
        xor     ch,ch
        shr     cx,1
        rcr     ax,1
        return

div5:	mov     cx,ax
        mov     ax,dx
        xor     dx,dx
        div     bx              ; 0:AX/BX
        xchg    cx,ax
        div     bx              ; DX:AX/BX
        return

EndProc DIV32

Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
;----------------------------------------------------------------------------
;
; Proedure Name : SHR32
;
; Inputs:
;	DX:AX = 32 bit sector number
; Function:
;       Perform 32 bit shift right
; Outputs:
;	AX = cluster number
;	ZF = 1 if no error
;	   = 0 if error (cluster number > 64k)
; Uses:
;       DX,CX
;---------------------------------------------------------------------------
; M017	- SHR32 rewritten for better performance
; M039	- Additional optimization

procedure   SHR32,NEAR

	mov     cl,es:[bp.dpb_cluster_shift]
	xor	ch,ch	    ;ZF=1
	jcxz	norota

rotashft2:
	shr	dx,1	    ;ZF reflects state of DX.
	rcr	ax,1	    ;ZF not affected.
	loop	rotashft2

norota:
	return

EndProc SHR32

COMMENT @

;**RMFHFE** Remove File_Handle_Fail_Error support

;---------------------------------------------------------------------------
;
; Procedure Name : File_Handle_Fail_Error
;
; Issue File Handle Fail INT 24 Critical Error
; Input: Disk_Full=0  ok
;                  1  disk full or EOF
; Function: issue critical error for disk full or EOF error
;
; OutPut: carry clear , no I24
;         carry set, fail from I24
;---------------------------------------------------------------------------

procedure File_Handle_Fail_Error,NEAR                                           ;AN000;

;hkn; SS override for all variables in this procedure
										;AN000;
	CMP     [DISK_FULL],0    ;MS. disk full or EOF                          ;AN000;
	JZ      Fexit            ;MS. no                                        ;AN000;
	TESTB   [DOS34_FLAG],Disable_EOF_I24   ;MS. check input status ?        ;AN000;
	JNZ     Fexit            ;MS. yes                                       ;AN000;
										;AN000;
	LES     DI,[THISSFT]     ;MS. get current SFT                           ;AN000;
;       LES     DI,ES:[DI.sf_DEVPTR];MS. get device header                      ;AN000;
	TESTB   ES:[DI].SF_FLAGS,Handle_Fail_I24  ;MS. gen I24 ?                ;AN000;
	JZ      Fexit            ;MS. no                                        ;AN000;
	PUSH    DS               ;MS. save DS                                   ;AN000;
	test    AH,1                            ;MS. READ ?                     ;AN000;
	JZ      readeof                         ;MS. yes                        ;AN000;
	MOV     [EXTERR],error_Handle_Disk_Full ;MS. set extended error         ;AN000;
	JMP     SHORT errset                    ;MS. set extended error         ;AN000;
readeof:
	MOV     [EXTERR],error_Handle_EOF       ;MS. set extended error         ;AN000;
errset:
	MOV     [EXTERR_CLASS],errCLASS_OutRes  ;MS. set class                  ;AN000;
	MOV     [EXTERR_ACTION],errACT_Abort    ;MS. set action                 ;AN000;
	MOV     [EXTERR_LOCUS],errLOC_Unk       ;MS. set locus                  ;AN000;
	MOV     word ptr [EXITHOLD + 2],ES      ;MS. save es:bp in exithold     ;AN000;
	MOV     word ptr [EXITHOLD],BP          ;MS.                            ;AN000;
	TESTB   ES:[DI].SF_FLAGS,devid_device     ;MS. device  ?                ;AN000;
	JNZ     chardev2                          ;MS. yes                      ;AN000;
	LDS     SI,ES:[DI.sf_DEVPTR]              ;MS. get dpb                  ;AN000;
	LDS     SI,[SI.dpb_driver_addr]           ;MS. get drive device haeder  ;AN000;
	JMP     SHORT doi24                       ;MS. gen I24 ?                ;AN000;
chardev2:
	LDS     SI,ES:[DI.sf_DEVPTR]              ;MS. get chr dev header       ;AN000;
doi24:
	MOV     BP,DS                             ;MS. bp:si -> device header   ;AN000;
	MOV     DI,error_I24_gen_failure        ;MS. general error              ;AN000;
	invoke  NET_I24_ENTRY                   ;MS. issue I24                  ;AN000;
	STC                                     ;MS. must be fail               ;AN000;
	POP     DS                              ;MS. restore DS                 ;AN000;
	MOV     AX,[EXTERR]                     ;MS. set error                  ;AN000;
	JMP     SHORT Fend                      ;MS. exit                       ;AN000;
Fexit:                                                                          ;AN000;
	CLC                                     ;MS. clear carry                ;AN000;
Fend:                                                                           ;AN000;
	return                                  ;MS.                            ;AN000;
										;AN000;
EndProc File_Handle_Fail_Error                                                  ;AN000;

@       ;End COMMENT.

DOSCODE ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\divmes.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
	PUBLIC	DIVMES
Public DIVM001S,DIVM001E
DIVM001S	label byte

include msdos.cl1

	PUBLIC	DivMesLen
DivMesLen   DW	$-DivMes	; Length of the above message in bytes
DIVM001E	label byte

;M018
; Add VxD not found error message
;
	Public	NoVxDErrMsg		;M018
include msdos.cl4			;M018
	Public	VXDMESLEN		;M018
VxDMesLen       equ     $ - NoVxDErrMsg ;M018

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dosprint.asm ===
TITLE	DOSPRINT - PRINTF at DOS level
	NAME	DOSPRINT

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DOSPRINT.ASM - Debug Print Support
;
;	Modification history:
;
;	  Created: MZ 16 June 1984

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	.cref
	.list

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	I_Need	Proc_ID,WORD
	I_Need	User_ID,WORD
	allow_getdseg

BREAK	<debugging output>

if DEBUG



;	PFMT - formatted output.  Calling sequence:
;	  PUSH	  BP
;	  PUSH	  fmtstr
;	  MOV	  BP,SP
;	  PUSH	  args
;	  CALL	  PFMT
;	  ADD	  SP,n
;	  POP	  BP
;
; The format string contains format directives and normal output characters
; much like the PRINTF for C.  We utilize NO format widths.  Special chars
; and strings are:
;
;       $x      output a hex number
;       $s      output an offset string
;       $c      output a character
;       $S      output a segmented string
;       $p      output userid/processid
;       \t      output a tab
;       \n      output a CRLF
;
; The format string must be addressable via CS
;

Procedure PFMT,NEAR
	ASSUME	SS:nothing
	SAVE	<AX,BX,DS,SI>
	MOV     AX,8007h
	INT     2Ah
	GETDSEG DS
	SUB     BP,2
	Call    FMTGetArg
	MOV     SI,AX
FmtLoop:
	LODSB
	OR      AL,AL
	JZ      FmtDone
	CMP     AL,'$'
	JZ      FmtOpt
	CMP     AL,'\'
	JZ      FmtChr
FmtOut:
	CALL	fOut
	JMP     FmtLoop

fOut:
	call	putch			; put character on serial port
	return

FmtDone:
	MOV     AX,8107h
	INT     2Ah
	RESTORE <SI,DS,BX,AX>
	RET
;
; \ leads in a special character. See what the next char is.
;
FmtChr: LODSB
	OR      AL,AL                   ; end of string
	JZ      fmtDone
	CMP     AL,'n'                  ; newline
	JZ      FmtCRLF
	CMP     AL,'t'                  ; tab
	JNZ     FmtOut
	MOV     AL,9
	JMP     FmtOut
FmtCRLF:MOV     AL,13
	CALL	fOut
	MOV     AL,10
	JMP     FmtOut
;
; $ leads in a format specifier.
;
FmtOpt: LODSB
	CMP     AL,'x'                  ; hex number
	JZ      FmtX
	CMP     AL,'c'                  ; single character
	JZ      FmtC
	CMP     AL,'s'                  ; offset string
	JZ      FmtSoff
	CMP     AL,'S'                  ; segmented string
	JZ      FmtSseg
	CMP     AL,'p'
	JZ      FmtUPID
	JMP     FmtOut
FmtX:
	Call    FMTGetArg
	MOV     BX,AX
	CALL    MNUM
	JMP     FmtLoop
FmtC:
	Call    FmtGetArg
	CALL	fOut
	JMP     FmtLoop
FmtSoff:
	SAVE	<SI>
	Call    FmtGetArg
	MOV     SI,AX
	CALL    fmtsout
	RESTORE <SI>
	JMP     FmtLoop
FmtSSeg:
	SAVE	<DS,SI>
	CALL    FMTGetArg
	MOV     DS,AX
	CALL    FMTGetArg
	MOV     SI,AX
	CALL    fmtsout
	RESTORE <SI,DS>
	JMP     FmtLoop
FmtUPID:
	INTTEST
	SAVE	<DS>
	MOV     BX,0
	MOV     DS,BX
	INTTEST 		; what to hell is this 82h?
	MOV     DS,DS:[82h]
    ASSUME DS:DOSDATA
	MOV     BX,User_ID
	CALL    MNUM
	MOV     AL,':'
	CALL	fOUT
	MOV     BX,Proc_ID
	CALL    MNUM
	RESTORE <DS>
    Assume DS:NOTHING
	JMP     FmtLoop
EndProc PFMT

Procedure   FMTGetArg,NEAR
	MOV     AX,[BP]
	SUB     BP,2
	return
EndProc FMTGetArg

Procedure   FmtSOut,NEAR
	LODSB
	OR      AL,AL
	retz
	CALL	fOUT
	JMP     FmtSOut
EndProc FMTSout

;**	MOut - output a message via serial port
;
;	ENTRY	(cs:bx) = message
;	USES	bx

Procedure   MOut,Near
	ASSUME	ES:NOTHING
	PUSHF
	Save	<ds, si, AX>
	PUSH    CS
	POP     DS
	MOV     SI,BX
	Call    FMTSout
	Restore <AX,SI,DS>
	POPF
	return
EndProc MOut

;   MNum - output a number in BX
;   Inputs:     BX contains a number
;   Outputs:    number in hex appears on screen
;   Registers modified: BX

Procedure   MNum,NEAR
	ASSUME	SS:NOTHING
	PUSHF
	SAVE	<ES,DI,AX,BX,CX,SI,DS>
	PUSH    SS
	POP     ES
	SUB     SP,6
	MOV     DI,SP                   ;   p = MNumBuf;
	SAVE	<DI>
	MOV     CX,4                    ;   for (i=0; i < 4; i++)
DLoop:	SAVE	<CX>
	MOV     CX,4                    ;       rotate(n, 4);
	ROL     BX,CL
	RESTORE <CX>
	MOV     AL,BL
	AND     AL,0Fh
	ADD     AL,'0'
	CMP     AL,'9'
	JBE     Nok
	ADD     AL,'A'-'0'-10
Nok:    STOSB                           ;       *p++ = "0123456789ABCDEF"[n];
	LOOP    DLoop
	XOR     AL,AL
	STOSB                           ;   *p++ = 0;
	RESTORE <SI>
	PUSH    ES
	POP     DS
	CALL    FMTSOUT                 ;   mout (mNumBuf);
	ADD     SP,6
	RESTORE <DS,SI,CX,BX,AX,DI,ES>
	POPF
	return
EndProc MNum


comport EQU	03f8h	; default to COM1

;**	putch - put character
;
;	(al) = character to output


	Public	putch
putch	PROC	near
	push	dx

	cmp	al,7
	je	putch1
	cmp	al,0ah		; filter out some garbage characters
	je	putch1		; that %s can produce when we don't
	cmp	al,0dh		; have a null terminated string
	je	putch1
	cmp	al,20h
	jae	pch0
	mov	al,'.'
	jmp	putch1

pch0:	cmp	al,07fh
	jb	putch1
	mov	al,'.'

putch1:
	cmp	al,0ah
	jne	putch2
	call	putraw
	mov	al,0dh
putch2: call	putraw
	pop	dx
	ret

putch	ENDP


	DPUBLIC putraw
putraw	PROC	near

	mov	dx, comport + 03fdh-3f8h
	mov	ah,al
putr5:	in	al,dx
	and	al,020h
	jz	putr5
	mov	al,ah
	mov	dx, comport
	out	dx,al
	ret

putraw	ENDP



 DPUBLIC <FmtLoop, FmtOut, fOut, FmtDone, FmtChr, FmtCRLF, FmtOpt, FmtX>
 DPUBLIC <FmtC, FmtSoff, FmtSSeg, FmtUPID, DLoop, Nok, pch0, putch1, putch2, putr5>

endif

DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dosmes.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)dosmes.asm 1.7 85/10/23
;	SCCSID = @(#)dosmes.asm 1.7 85/10/23
;
; Message file for Internationalized messages.	There is
; only one message here available for translation.
;
;
;    Revision history
;	  A000	  version 4.00  Jan. 1988
;

; -------- M I C R O S O F T   K K ---------------------------------------------
;
;  DOSMES.ASM - MODIFICATION LOG
;
;
;	Note: For more detailed information, see "MS-DOS 4.00 SOURCE CODE
;		MODIFICATION LOG"
;
; ------------------------------------------------------------------------------
;
; 01/11/89:MSKK01:yukini:dos-2:
;	default country information changed to JAPAN (from USA).
;
; -------- M I C R O S O F T   K K ---------------------------------------------



IFNDEF	Rainbow
Rainbow EQU FALSE
ENDIF

	.xlist
	.xcref
include dossym.inc
include dosmac.inc
include doscntry.inc
	.cref
	.list


;hkn; moved to bottom of const2.asm to maintain offsets. previously in 
;hkn; CONSTANTS segment.
;hkn; 
;hkn; CONSTANTS	SEGMENT WORD PUBLIC 'CONST'
;hkn; 
;hkn;     PUBLIC  UserNum, OEMNum
;hkn;     Public DMES001S,DMES001E
;hkn; DMES001S Label byte
;hkn; USERNUM DW	?			; 24 bit user number
;hkn; 	DB	?
;hkn; IF	IBM
;hkn; 	IF	IBMCOPYRIGHT
;hkn; 	OEMNUM	DB	0			; 8 bit OEM number
;hkn; 	ELSE
;hkn; 	OEMNUM	DB	0FFH			; 8 bit OEM number
;hkn; 	ENDIF
;hkn; ELSE
;hkn; OEMNUM	DB	0FFH
;hkn; ENDIF
;hkn; 
;hkn; 
;hkn; DMES001E label byte
;hkn; CONSTANTS	ENDS

DOSCODE	Segment

	Public DMES002S
DMES002S  label byte


include divmes.inc
include yesno.asm

SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
PAGE
; The following two tables implement the current buffered input editing
; routines.  The tables are pairwise associated in reverse order for ease
; in indexing.	That is; The first entry in ESCTAB corresponds to the last
; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.


;hkn; TABLE	SEGMENT
	PUBLIC	CANCHAR
CANCHAR DB	CANCEL			;Cancel line character
	PUBLIC	ESCCHAR
ESCCHAR DB	ESCCH			;Lead-in character for escape sequences
	IF	NOT Rainbow
ESCTAB	LABEL BYTE
	IF	NOT IBM
	IF	WANG
	DB	0C0h			; ^Z inserter
	DB	0C1H			; Copy one char
	DB	0C1H			; Copy one char
	DB	0C7H			; Skip one char
	DB	08AH			; Copy to char
	DB	088H			; Skip to char
	DB	09AH			; Copy line
	DB	0CBH			; Kill line (no change in template)
	DB	08BH			; Reedit line (new template)
	DB	0C3H			; Backspace
	DB	0C6H			; Enter insert mode
	DB	0D6H			; Exit insert mode
	DB	0C6H			; Escape character
	DB	0C6H			; End of table
	ELSE
					; VT52 equivalences
	DB	"Z"                     ; ^Z inserter
	DB	"S"                     ; F1 Copy one char
	DB	"S"                     ; F1 Copy one char
	DB	"V"                     ; F4 Skip one char
	DB	"T"                     ; F2 Copy to char
	DB	"W"                     ; F5 Skip to char
	DB	"U"                     ; F3 Copy line
	DB	"E"                     ; SHIFT ERASE Kill line (no change in template)
	DB	"J"                     ; ERASE Reedit line (new template)
	DB	"D"                     ; LEFT Backspace
	DB	"P"                     ; BLUE Enter insert mode
	DB	"Q"                     ; RED Exit insert mode
	DB	"R"                     ; GRAY Escape character
	DB	"R"                     ; End of table
	ENDIF
	ENDIF
	IF	IBM
	DB	64			; Ctrl-Z - F6
	DB	77			; Copy one char - -->
	DB	59			; Copy one char - F1
	DB	83			; Skip one char - DEL
	DB	60			; Copy to char - F2
	DB	62			; Skip to char - F4
	DB	61			; Copy line - F3
	DB	61			; Kill line (no change to template ) - Not used
	DB	63			; Reedit line (new template) - F5
	DB	75			; Backspace - <--
	DB	82			; Enter insert mode - INS (toggle)
	DB	82			; Exit insert mode - INS (toggle)
	DB	65			; Escape character - F7
	DB	65			; End of table
	ENDIF
ESCEND LABEL BYTE
ESCTABLEN EQU	ESCEND-ESCTAB

ESCFUNC LABEL	WORD
	short_addr  GETCH		; Ignore the escape sequence
	short_addr  TWOESC
	short_addr  EXITINS
	short_addr  ENTERINS
	short_addr  BACKSP
	short_addr  REEDIT
	short_addr  KILNEW
	short_addr  COPYLIN
	short_addr  SKIPSTR
	short_addr  COPYSTR
	short_addr  SKIPONE
	short_addr  COPYONE
	short_addr  COPYONE
	short_addr  CTRLZ
	ENDIF
;hkn; TABLE	ENDS

;
; OEMFunction key is expected to process a single function
;   key input from a device and dispatch to the proper
;   routines leaving all registers UNTOUCHED.
;
; Inputs:   CS, SS are DOSGROUP
; Outputs:  None. This function is expected to JMP to one of
;	    the following labels:
;
;	    GetCh	- ignore the sequence
;	    TwoEsc	- insert an ESCChar in the buffer
;	    ExitIns	- toggle insert mode
;	    EnterIns	- toggle insert mode
;	    BackSp	- move backwards one space
;	    ReEdit	- reedit the line with a new template
;	    KilNew	- discard the current line and start from scratch
;	    CopyLin	- copy the rest of the template into the line
;	    SkipStr	- read the next character and skip to it in the template
;	    CopyStr	- read next char and copy from template to line until char
;	    SkipOne	- advance position in template one character
;	    CopyOne	- copy next character in template into line
;	    CtrlZ	- place a ^Z into the template
; Registers that are allowed to be modified by this function are:
;	    AX, CX, BP

ASSUME	CS:DOSCODE
Procedure   OEMFunctionKey,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 IFDEF  DBCS				;AN000;
extrn	IntCNE0:near			;AN000; 2/17/KK
	CALL	IntCNE0 		;AN000; 2/17/KK
 ELSE					;AN000;
	invoke	$std_con_input_no_echo	; Get the second byte of the sequence
 ENDIF					;AN000;
	IF NOT Rainbow
	MOV	CL,ESCTABLEN		; length of table for scan
	PUSH	DI			; save DI (cannot change it!)

;hkn; ESCTAB is in TABLE seg (DOSCODE)
	MOV	DI,OFFSET DOSCODE:ESCTAB   ; offset of second byte table

;hkn; ES should point to DOSCODE for the string scan
;
	push	es
	push	cs
	pop	es

	REPNE	SCASB			; Look it up in the table
;
;hkn;Restore es 
	pop	es

	POP	DI			; restore DI
	SHL	CX,1			; convert byte offset to word
	MOV	BP,CX			; move to indexable register

;hkn; ESCFUNC is in TABLE seg (DOSCODE)
;hkn;Use CS override since bp contains an address in DOSCODE

	JMP	CS:[BP+OFFSET DOSCODE:ESCFUNC]	; Go to the right routine
	ENDIF
	IF Rainbow

TransferIf  MACRO   value,address
	local	a
	CMP	AL,value
	JNZ	a
	transfer    address
a:
ENDM

	CMP	AL,'['                  ; is it second lead char
	JZ	EatParm 		; yes, go walk tree
GoGetCh:
	transfer    GetCh		; no, ignore sequence
EatParm:
	invoke	$std_con_input_no_echo	; get argument
	CMP	AL,'A'                  ; is it alphabetic arg?
	JAE	EatAlpha		; yes, go snarf one up
	XOR	BP,BP			; init digit counter
	JMP	InDigit 		; jump into internal eat digit routine
EatNum:
	invoke	$std_con_input_no_echo	; get next digit
InDigit:
	CMP	AL,'9'                  ; still a digit?
	JA	CheckNumEnd		; no, go check for end char
	SUB	AL,'0'                  ; turn into potential digit
	JL	GoGetCh 		; oops, not a digit, ignore
	MOV	CX,BP			; save BP for 10 multiply
	CBW				; make AL into AX
	SHL	BP,1			; 2*BP
	SHL	BP,1			; 4*BP
	ADD	BP,CX			; 5*BP
	SHL	BP,1			; 10*BP
	ADD	BP,AX			; 10*BP + digit
	JMP	EatNum			; continue with number
CheckNumEnd:
	CMP	AL,7Eh			; is it end char ~
	JNZ	GoGetCh 		; nope, ignore key sequence
	MOV	AX,BP
	transferIf  1,SkipStr		; FIND key
	transferIf  2,EnterIns		; INSERT HERE key
	transferIf  3,SkipOne		; REMOVE
	transferIf  4,CopyStr		; SELECT
	transferIf  17,TwoEsc		; INTERRUPT
	transferIf  18,ReEdit		; RESUME
	transferIf  19,KilNew		; CANCEL
	transferIf  21,CtrlZ		; EXIT
	transferIf  29,CopyLin		; DO
	JMP	GoGetCh
EatAlpha:
	CMP	AL,'O'                  ; is it O?
	JA	GoGetCh 		; no, after assume bogus
	JZ	EatPQRS 		; eat the rest of the bogus key
	transferIf  'C',CopyOne         ; RIGHT
	transferIf  'D',BackSp          ; LEFT
	JMP	GoGetCh
EatPQRS:
	invoke	$std_con_input_no_echo	; eat char after O
	JMP	GoGetCh
	ENDIF

EndProc OEMFunctionKey

DOSCODE		ENDS

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\exepatch.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;** EXEPATCH.ASM 
;
;	Contains the foll:
;
;		- code to find and overlay buggy unpack code
;		- new code to be overlayed on buggy unpack code 
;		- old code sequence to identify buggy unpack code
;
;	Revision history:
;
;		Created: 5/14/90
;
;
;
;----------------------------------------------------------------------------
;
; M020 : Fix for rational bug - for details see routine header
; M028 : 4b04 implementation
; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
; M032 : set turnoff bit only if DOS in HMA.
; M033 : if IP < 2 then not exepacked.
; M046 : support for a 4th version of exepacked files.
; M068 : support for copy protected apps.
; M071 : use A20OFF_COUNT of 10.
;
;----------------------------------------------------------------------------
;
.XLIST
.XCREF

INCLUDE version.inc
INCLUDE dosseg.inc
INCLUDE DOSSYM.INC
INCLUDE exe.inc
INCLUDE	PDB.INC

.CREF
.LIST


	public	exepatch
	public	RationalPatch				; M020
	public	Rational386Patch
	public	IsCopyProt

PATCH1_COM_OFFSET	EQU	06CH
PATCH1_OFFSET		EQU	028H
PATCH1_CHKSUM		EQU	0EF4EH
CHKSUM1_LEN		EQU	11CH/2

PATCH2_COM_OFFSET	EQU	076H
PATCH2_OFFSET		EQU	032H

	; The strings that start at offset 076h have two possible 
	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM

PATCH2_CHKSUM		EQU	78B2H
CHKSUM2_LEN		EQU	119H/2
PATCH2A_CHKSUM		EQU	1C47H		; M046
CHKSUM2A_LEN		EQU	103H/2		; M046

PATCH3_COM_OFFSET	EQU	074H
PATCH3_OFFSET		EQU	032H
PATCH3_CHKSUM		EQU	4EDEH
CHKSUM3_LEN		EQU	117H/2




DOSDATA	SEGMENT

;	EXTRN	exec_signature	:WORD	; Must contain 4D5A  (yay zibo!)

;	EXTRN	exec_init_IP 	:WORD	; IP of entry
;	EXTRN	exec_init_CS 	:WORD	; CS of entry

	EXTRN	UNPACK_OFFSET	:WORD
	EXTRN	RatBugCode	:FAR
	EXTRN	RationalPatchPtr:word
	EXTRN	fixexepatch	:word		; M028
	EXTRN	Rational386PatchPtr:word
	EXTRN	Special_Version	:word		; M028
;	EXTRN	A20OFF_FLAG	:byte
	extrn	DosHasHMA	:byte		
	extrn	A20OFF_COUNT	:byte		; M068
	extrn	A20OFF_PSP	:word		; M068
	extrn	DOS_FLAG	:byte		; M068

DOSDATA	ENDS


DOSCODE	SEGMENT

; M028 - BEGIN

	EXTRN	Scan_Execname1:near
	EXTRN	Scan_Special_Entries:near

	ASSUME	CS:DOSCODE, SS:DOSDATA

	public	ExecReady

;-------------------------------------------------------------------------
;
;	Procedure Name		: ExecReady
;
;	Input			: DS:DX -> ERStruc (see exe.inc)
;
;--------------------------------------------------------------------------

ExecReady	proc	near

	mov	si, dx			; move the pointer into a friendly one
	test	[si].ER_Flags, ER_EXE	; COM or EXE ?
	jz	er_setver		; only setver for .COM files

	mov	ax, [si].ER_PSP
	add	ax, 10h
	mov	es, ax

	mov	cx, word ptr ds:[si].ER_StartAddr	; M030
	mov	ax, word ptr ds:[si+2].ER_StartAddr	; M030

	call	[fixexepatch]
	call	[Rational386PatchPtr]

er_setver:
					; Q: is this an overlay
	test	[si].ER_Flags, ER_OVERLAY
	jnz	er_chkdoshi		; Y: set A20OFF_COUNT if DOS high
					; N: set up lie version first
	push	ds
	push	si
	lds	si, [si].ER_ProgName
	call	Scan_Execname1
	call	Scan_Special_Entries
	pop	si
	pop	ds
	mov	es, [si].ER_PSP
	mov	ax, Special_Version
	mov	es:[0].PDB_Version, ax
er_chkdoshi:
	cmp	[DosHasHMA], 0		; M032: Q: is dos in HMA (M021)
	je	er_done			; M032: N: done

					; M068 - Start
	mov	ax, [si].ER_PSP		; ax = PSP

	or	[DOS_FLAG], EXECA20OFF	; Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc 
					; under TAG M003 & M009 for 
					; explanation

	test	[si].ER_Flags, ER_EXE	; Q: COM file
	jnz	er_setA20		; N: inc a20off_count , set 
					;    a20off_psp and ret
   	push	ds
	mov	ds, ax			; DS = load segment of com file.
	call	IsCopyProt		; check if copy protected
	pop	ds

er_seta20:

	;
	; We need to inc the A20OFF_COUNT here. Note that if the count
	; is non-zero at this point it indicates that the A20 is to be 
	; turned off for that many int 21 calls made by the app. In 
	; addition the A20 has to be turned off when we exit from this 
	; call. Hence the inc.
	;

	inc	[A20OFF_COUNT]		
	mov	[A20OFF_PSP], ax	; set the PSP for which A20 is to be
					; turned OFF.
er_done:				; M068 - End
	xor	ax, ax
	ret
ExecReady	endp

; M028 - END

;----------------------------------------------------------------------------
;
; procedure : Rational386Patch
;
; Older versions of the Rational DOS Extender have several bugs which trash
; 386 registers (usually just the high word of 32 bit registers) during
; interrupt processing.  Lotus 123 3.1+ is a popular application that uses a
; version of the Rational extender with the 32 bit register trashing bugs.
;
; This routine applies patches to the Rational DOS Extender to work around
; most of the register trashing bugs.
;
; Note that there are additional register trashing bugs not fixed by these
; patches.  In particular, the high word of ESP and the FS and GS registers
; may be modified on interrupts.
;
; There are two different Rational DOS Extender patchs in this module.
; Rational386Patch is to correct 386 register trashing bugs on 386 or later
; processors.  This patch code is executed when MS-DOS is running on a 386
; or later processor, regardless of whether MS-DOS is running in the HMA
; or not.
;
; The other Rational patch routine (RationalPatch, below) fixes a register
; trashing problem on 286 processors, and is only executed if MS-DOS is
; running in the HMA.
;
; This patch detection and replacement is based on an example supplied by
; Ben Williams at Rational.
;
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;
; INPUT : ES = segment where program got loaded
;
;----------------------------------------------------------------------------

rpFind1 	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
rpFind1Len	equ	$ - offset rpFind1

;	cli
;	in	al, 21h
;	pusha
;	xor	ax, ax
;	out	43h, al
;	mov	dx, ...

rpFind1a	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
rpFind1aLen	equ	$ - offset rpFind1a

;	mov	al, 0Eh
;	out	37h, al
;	xor	ax, ax
;	out	0F2h, al


; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI

rpFind2 	db	0Fh, 20h, 0C0h
rpFind2Len	equ	$ - offset rpFind2

;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)

rpFind3 	db	0Fh, 22h, 0C0h, 0EAh
rpFind3Len	equ	$ - offset rpFind3

;	mov	cr0, eax	;may be preceeded by POP CX (59h)
;	jmp	far ptr xxx	;change far ptr to go to replace3
;	mov	ss, bx		;8E D3 ... and come back at or after this

; note, there is no rpRepl1 string

rpRepl2 	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
rpRepl2Len	equ	$ - offset rpRepl2

;	push	eax
;	push	cx
;	mov	eax, cr0

rpRepl3 	db	8Eh, 0D3h, 59h, 66h, 58h
rpRepl3Len	equ	$ - offset rpRepl3

;	mov	ss, bx
;	pop	cx
;	pop	eax

; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI

rpFind4 	db	93h, 58h, 8Bh, 0CCh
rpFind4Len	equ	$ - offset rpFind4

;	xchg	bx, ax
;	pop	ax
;	mov	cx, sp

rpFind5 	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
rpFind5Len	equ	$ - offset rpFind5

;	mov	ax, DE0Ch
;	int	67h
;	mov	sp, cx
;	jmp	bx

rpRepl4 	db	93h, 58h, 8Bh, 0CCh
		db	02Eh, 066h, 0A3h
rpRepl4o1Len	equ	$ - offset rpRepl4
		db	00h, 00h
		db	02Eh, 066h, 89h, 36h
rpRepl4o2Len	equ	$ - offset rpRepl4
		db	00h, 00h
rpRepl4Len	equ	$ - offset rpRepl4

;	xchg	bx, ax
;	pop	ax
;	mov	cx, sp
;	mov	dword ptr cs:[xxxx], eax
;	mov	dword ptr cs:[xxxx], esi

rpRepl5 	db	8Bh, 0E1h
		db	2Eh, 66h, 0A1h
rpRepl5o1Len	equ	$ - offset rpRepl5
		db	00h, 00h
		db	2Eh, 66h, 8Bh, 36h
rpRepl5o2Len	equ	$ - offset rpRepl5
		db	00h, 00h
		db	0FFh, 0E3h
rpRepl5Len	equ	$ - offset rpRepl5

;	mov	sp, cx
;	mov	eax, dword ptr cs:[xxxx]
;	mov	esi, dword ptr cs:[xxxx]
;	jmp	bx

; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI

rpFind6 	db	0FAh, 52h, 51h
rpFind6Len	equ	$ - offset rpFind6

;	cli
;	push	dx
;	push	cx

rpFind7a	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
rpFind7aLen	equ	$ - offset rpFind7a

;	mov	ax, 0DE0Ch
;	call	fword ptr es:[xxxx]

rpFind7b	db	59h, 5Ah, 5Bh
rpFind7bLen	equ	$ - offset rpFind7b

;	pop	cx
;	pop	dx
;	pop	bx

rpRepl6 	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
rpRepl6Len	equ	$ - offset rpRepl6

;	cli
;	push	eax
;	push	ebx
;	push	ecx
;	push	edx

rpRepl7 	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
rpRepl7Len	equ	$ - offset rpRepl7

;	pop	edx
;	pop	ecx
;	pop	ebx
;	pop	eax
;	pop	bx

; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI

rpFind8 	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
rpFind8Len	equ	$ - offset rpFind8

;	pusha
;	push	es
;	push	ds
;	mov	ax, dgroup	;jump back to here from replace8
;	mov	ds, ax

rpFind9 	db	1Fh, 07h, 61h
rpFind9Len	equ	$ - rpFind9

;	pop	ds
;	pop	es
;	popa

rpRepl8 	db	66h, 60h, 06h, 1Eh
rpRepl8Len	equ	$ - offset rpRepl8

;	pushad
;	push	es
;	push	ds

rpRepl9 	db	1Fh, 07h, 66h, 61h, 0C3h
rpRepl9Len	equ	$ - offset rpRepl9

;	pop	ds
;	pop	es
;	popad
;	ret			;no need to jmp back to main-line

;----------------------------------------------------------------------------

SearchPair	STRUC
sp_off1 	dw	?		; offset of 1st search string
sp_len1 	dw	?		; length of 1st search string
sp_off2 	dw	?		; 2nd string
sp_len2 	dw	?		; 2nd string
sp_diff 	dw	?		; max difference between offsets
SearchPair	ENDS

rpBug1Strs	SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
rpBug2Strs	SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
rpBug3Strs	SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
rpBug4Strs	SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>

;----------------------------------------------------------------------------

StackVars	STRUC
sv_wVersion	dw	?		; Rational extender version #
sv_cbCodeSeg	dw	?		; code seg size to scan
sv_pPatch	dw	?		; offset of next avail patch byte
StackVars	ENDS

;----------------------------------------------------------------------------

Rational386Patch  proc	near

	; Do a few quick checks to see if this looks like a Rational
	; Extended application.  Hopefully this will quickly weed out
	; most non Rational apps.

	cmp	word ptr es:[0], 395	; version number goes here - versions
	jae	rp3QuickOut		;   3.95+ don't need patching

	cmp	word ptr es:[0Ch], 20h	; always has this value here
	jne	rp3QuickOut

	push	ax

	mov	ax, 18h 		; extender has 18h at
	cmp	es:[24], ax		;   offsets 24, 28, & 36
	jne	rp3QO_ax
	cmp	es:[28], ax
	jne	rp3QO_ax
	cmp	es:[36], ax
	je	rp3Maybe

rp3QO_ax:
	pop	ax

rp3QuickOut:
	ret

; It might be the rational extender, do more extensive checking

rp3Maybe:

	cld
	push	bx		; note ax pushed above
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	ds			; we use all of them
	push	bp
	sub	sp, SIZE StackVars	; make space for stack variables
	mov	bp, sp

	push	cs
	pop	ds
	assume	ds:nothing

	mov	ax, es:[0]		; save version #
	mov	[bp].sv_wVersion, ax
					; check that binary version # matches
	call	VerifyVersion		;   ascii string
	jne	rp3Exit_j


; Looks like this is it, find where to put the patch code.  The
; patch will be located on top of Rational code specific to 80286
; processors, so these patchs MUST NOT be applied if running on
; an 80286 system.

	; Rational says the code to patch will never be beyond offset 46xxh

	mov	cx, 4500h		; force search len to 4700h (searches
	mov	[bp].sv_cbCodeSeg, cx	;   start at offset 200h)

	mov	es, word ptr es:[20h]	; es=code segment

	mov	si, offset rpFind1	; string to find
	mov	dx, rpFind1Len		; length to match
	call	ScanCodeSeq		; look for code seq
	jz	rpGotPatch

; According to Rational, some very old versions of the extender may not
; have the find1 code sequence.  If the find1 code wasn't found above,
; try an alternative patch area which is on top of NEC 98xx switching code.

	mov	si, offset rpFind1a
	mov	dx, rpFind1aLen
	call	ScanCodeSeq
	jz	rpGotPatch

rp3Exit_j:
	jmp	rp3Exit

; Found the location to write patch code!  DI = offset in code seg.

rpGotPatch:
	mov	[bp].sv_pPatch, di	; save patch pointer

;----------------------------------------------------------------------------
; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI

	cmp	word ptr [bp].sv_wVersion, 381	; only need bug 1 if version
	jae	rpBug2				;   < 3.81

	mov	bx, offset rpBug1Strs		; locate find2 & find3 code
	call	FindBadCode
	jc	rpBug2

; si = rpFind2 offset, di = rpFind3 offset

	push	di
	mov	di, si				; rpFind2 offset
	mov	dx, rpFind2Len

	cmp	byte ptr es:[di-1], 51h 	; find2 preceeded by push cx?
	jne	rp_no_cx

	dec	di				;   yes, gobble up push cx too
	inc	dx
rp_no_cx:
	mov	si, offset rpRepl2		; patch out find2 sequence
	mov	cx, rpRepl2Len
	call	GenPatch

	pop	di				; rpFind3 offset
	cmp	byte ptr es:[di-1], 59h 	; find3 preceeded by pop cx?
	jne	rp_no_cx2

	mov	byte ptr es:[di-1], 90h 	;   yes, no-op it

rp_no_cx2:
	mov	ax, [bp].sv_pPatch		; change offset of far jmp
	mov	es:[di+rpFind3Len], ax		;   to go to patch code

	push	di				; save find3 offset
	mov	si, offset rpRepl3		; copy repl3 to patch area
	mov	cx, rpRepl3Len
	call	CopyPatch

	pop	bx				; find3 offset
	add	bx, rpFind3Len+4		; skip over find3 and far jmp
	call	GenJump 			; jmp back from patch area
	mov	[bp].sv_pPatch, di		;   to main-line, update patch
						;   area pointer

;----------------------------------------------------------------------------
; Bug # 2 -- loss of high regs on 386+ under VCPI only

rpBug2:
	mov	bx, offset rpBug2Strs		; locate find4 & find5 code
	call	FindBadCode
	jc	rpBug3

; si = rpFind4 offset, di = rpFind5 offset

	push	[bp].sv_pPatch			; save current patch pointer
						;   (where repl4 goes)
	push	di				; save find5 offset

	mov	di, si
	mov	dx, rpFind4Len
	mov	si, offset rpRepl4
	mov	cx, rpRepl4Len
	call	GenPatch			; patch out find4 code

	pop	di				; find5 offset
	add	di, 5				; keep 5 bytes of find5 code
	mov	bx, [bp].sv_pPatch		; jump to patch area
	push	bx				; save repl5 location
	call	GenJump

	mov	si, offset rpRepl5		; copy repl5 code to patch
	mov	cx, rpRepl5Len			;   area -- it has a jmp bx
	call	CopyPatch			;   so no need to jmp back to
						;   main-line code

; patches have been made, now update the patch code to store/load dwords just
; after the code in the patch area

	pop	di				; repl5 location
	pop	si				; repl4 location

	mov	ax, [bp].sv_pPatch		; (where dwords go)

	mov	word ptr es:[si+rpRepl4o1Len], ax	; offset for EAX
	mov	word ptr es:[di+rpRepl5o1Len], ax
	add	ax, 4
	mov	word ptr es:[si+rpRepl4o2Len], ax	; offset for ESI
	mov	word ptr es:[di+rpRepl5o2Len], ax

	add	[bp].sv_pPatch, 8		; reserve space for 2 dwords in
						; patch area

;----------------------------------------------------------------------------
; Bug # 3 -- loss of high regs on 386+ under VCPI only

rpBug3:
	mov	bx, offset rpBug3Strs		; locate find6 & find7a code
	call	FindBadCode
	jc	rpBug4

	add	di, rpFind7aLen + 2		; skip over offset in find7a
	push	si				;   code and locate find7b
	mov	si, offset rpFind7b		;   sequence
	mov	dx, rpFind7bLen
	call	ScanCodeSeq_di
	pop	si
	jnz	rpBug4

	push	di				; save find7b code offset

	mov	di, si
	mov	dx, rpFind6Len
	mov	si, offset rpRepl6
	mov	cx, rpRepl6Len
	call	GenPatch			; patch out find6 code

	pop	di
	mov	dx, rpFind7bLen
	mov	si, offset rpRepl7
	mov	cx, rpRepl7Len
	call	GenPatch			; patch out find7b code


;----------------------------------------------------------------------------
; Bug # 4 -- loss of high regs on 386+ under VCPI only

rpBug4:
	cmp	[bp].sv_wVersion, 360	; only applies if version > 3.60
	jbe	rp3Exit 		;   and < 3.95

	mov	bx, offset rpBug4Strs		; locate find8 & find9 code
	call	FindBadCode
	jc	rp3Exit

	push	di				; save find9 code offset

	mov	di, si
	mov	dx, 3
	mov	si, offset rpRepl8
	mov	cx, rpRepl8Len
	call	GenPatch			; patch out find8 code

	pop	di				; find9 offset
	mov	bx, [bp].sv_pPatch		; patch find9 to jmp to
	call	GenJump 			;   patch area

	mov	si, offset rpRepl9		; copy replacement code to
	mov	cx, rpRepl9Len			;   patch area--it does a RET
	call	CopyPatch			;   so no jmp back to main-line

rp3Exit:
	add	sp, SIZE StackVars
	pop	bp
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

Rational386Patch endp

;----------------------------------------------------------------------------
;
; FindBadCode
;
; Searches Rational code segment looking for a pair of find strings (all
; patches have at least two find strings).
;
; Entry:
;	ES    = code segment to search
;	DS:BX = search pair structure for this search
;	[bp].sv_cbCodeSeg = length of code seg to search
;
; Exit:
;	CY flag clear if both strings found, and
;	SI    = offset in ES of 1st string
;	DI    = offset in ES of 2nd string
;	CY set if either string not found, or strings too far apart
;
; Used:
;	CX
;
;----------------------------------------------------------------------------

FindBadCode proc near

	mov	cx, [bp].sv_cbCodeSeg	; search length

	mov	si, [bx].sp_off1	; ds:si -> search string
	mov	dx, [bx].sp_len1	; dx = search len
	call	ScanCodeSeq
	jnz	fbc_error		; done if 1st not found

	push	di			; save 1st string offset

	mov	si, [bx].sp_off2
	mov	dx, [bx].sp_len2
	call	ScanCodeSeq_di		; don't change flags after this!

	pop	si			; restore 1st string offset
	jnz	fbc_error

	mov	ax, di			; sanity check that
	sub	ax, si			;   si < di && di - si <= allowed diff
	jc	fbc_error
	cmp	ax, [bx].sp_diff
	ja	fbc_error

	clc
	ret

fbc_error:
	stc
	ret

FindBadCode endp

;----------------------------------------------------------------------------
;
; GenPatch
;
; Generate a patch sequence.  1) insert a jump at the buggy code location
; (jumps to the patch code area), 2) copy the selected patch code to the
; patch area, 3) insert a jump from the patch area back to the main-line
; code.
;
; Entry:
;	ES:DI = start of buggy code to be patched
;	DX    = length of buggy code to be patched
;	DS:SI = replacement patch code
;	CX    = length of replacement patch code
;	[bp].sv_pPatch = offset in ES of where to copy patch code
;
; Exit:
;	DI, [bp].sv_pPatch = byte after generated patch code
;
; Used:
;	AX, BX, SI, Flags
;
;----------------------------------------------------------------------------

GenPatch proc	near

	push	di			;save offset of buggy code

	mov	bx, [bp].sv_pPatch	;jump from buggy code to patch area
	call	GenJump

	call	CopyPatch		;copy replacement code to patch area

	pop	bx			;offset of buggy code + buggy code
	add	bx, dx			;  length = return from patch offset

	call	GenJump 		;jump from patch area back to main-
	mov	[bp].sv_pPatch, di	;  line code, update patch pointer

	ret

GenPatch endp


;----------------------------------------------------------------------------
;
; CopyPatch
;
; Copies patch code to patch location.
;
; Entry:
;	DS:SI = patch code to be copied
;	ES    = segment of code to patch
;	CX    = length of code to copy
;	[bp].sv_pPatch = offset in ES of where to copy patch code
;
; Exit:
;	DI, [bp].sv_pPatch = byte after copied patch code
;
; Used:
;	SI, Flags
;
;----------------------------------------------------------------------------

CopyPatch proc	near

	push	cx
	mov	di, [bp].sv_pPatch	;patch pointer is the dest offset
	cld
	rep movsb
	pop	cx

	mov	[bp].sv_pPatch, di	;update net pointer location

	ret

CopyPatch endp

;----------------------------------------------------------------------------
;
; GenJump
;
; Generates a rel16 JMP instruction at location 'from' to location 'to'.
;
; Entry:
;	ES:DI = from location (where to put jmp instruction)
;	BX    = to location (where to jump to)
;
; Exit:
;	DI = byte after generated jump
;
; Used:
;	AX
;
;----------------------------------------------------------------------------

GenJump proc	near

	mov	al, 0E9h		; jmp rel16 opcode
	stosb

	mov	ax, bx			; calc offset to 'to' location
	sub	ax, di
	sub	ax, 2

	stosw				; output offset

	ret

GenJump endp

;
;----------------------------------------------------------------------------
;
; ScanCodeSeq
;
; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
;
; returns in ES:DI the start of the pattern if Zero flag is set
;
;----------------------------------------------------------------------------
;
ScanCodeSeq	proc	near
		mov	di, 200h
ScanCodeSeq_di	label	near
		push	cx
		sub	cx, dx
		inc	cx
scsagain:
		push	si
		push	di
		push	cx
		mov	cx, dx
		rep	cmpsb
		pop	cx
		pop	di
		pop	si
		je	scsfound
		inc	di
		loop	scsagain
scsfound:
		pop	cx
		ret
ScanCodeSeq	endp
	
;
;----------------------------------------------------------------------------
;
; VerifyVersion
;
; Checks whether the binary version from ES:0 matches the ASCII version
; from ES:2A.
;
;       Entry: AX = binary version number 
;       Exit : Z flag set if version numbers match
;
;----------------------------------------------------------------------------
;
VerifyVersion	proc	near
		mov	si, es:[2ah]		; offset of version number
						;  in ascii
		mov	bl, 10
		add	si, 3			; point to last digit

		call	VVDigit
		jne	vvexit
		call	VVDigit
		jne	vvexit
		cmp	byte ptr es:[si], '.'
		jne	vvexit
		dec	si
		call	VVDigit
vvexit:
		ret
VerifyVersion	endp

VVDigit		proc	near
		div	bl
		add	ah, '0'
		dec	si
		cmp	es:[si+1], ah
		mov	ah, 0			; do not xor or sub we need Z
		ret
VVDigit 	endp

;-----------------------------------------------------------------------
public		exepatch_start
exepatch_start	label 	byte

	;
	; The following is the code that'll be layed over the buggy unpack
	; code.
	;
str1	label	byte

	db  06h	  		;push	es		 
	db  8Ch, 0D8h		;mov	ax,ds 

first_stop	equ	$ - str1
			
	db  2Bh, 0C2h		;sub	ax, dx			

first		label	byte

	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  57h	    		;push	di
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh 		;mov	al,0FFH 		
	db  0F3h, 0AEh 		;repz	scasb			
	db  47h	    		;inc	di			
	db  8Bh, 0F7h  		;mov	si,di			
	db  5Fh	    		;pop	di
	db  58h	    		;pop	ax

second_stop	equ	$ - first

	db  2Bh, 0C2h  		;sub	ax, dx			

second		label	byte

	db  8Eh, 0C0h  		;mov	es,ax			
		    		;NextRec:				
	db  0B9h, 04h, 02h	;mov	cx, 0204h
		    		;norm_agn:				
	db  8Bh, 0C6h		;mov	ax,si			
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 13h		;jz	SI_ok			
	db  8Ch, 0DAh		;mov	dx,ds			
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H
	db  2Bh, 0D0h		;sub	dx,ax			
	db  73h, 08h		;jnc	SItoDS			
	db  0F7h, 0DAh		;neg	dx			
	db  0D3h, 0E2h		;shl	dx,cl			
	db  2Bh, 0F2h		;sub	si,dx			
	db  33h, 0D2h		;xor	dx,dx			
				;SItoDS: 				
	db  8Eh, 0DAh		;mov	ds,dx		
				;SI_ok:					
	db  87h, 0F7h		;xchg	si,di			
	db  1Eh			;push	ds			
	db  06h			;push	es			
	db  1Fh			;pop	ds			
	db  07h			;pop	es			
	db  0FEh, 0CDh		;dec	ch			
	db  75h, 0DBh		;jnz	norm_agn		
	db  0ACh		;lodsb			
	db  92h			;xchg	dx,ax
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh, 0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah, 0C2h		;mov	al,dl		
	db  24h, 0FEh		;and	al,0FEH		
	db  3Ch, 0B0h		;cmp	al,RPTREC
	db  75h, 05h		;jne	TryEnum
	db  0ACh		;lodsb				
	db  0F3h, 0AAh		;rep stosb			

;	db  0EBh, 07h, 90h	;jmp	TryNext
	db  0EBh, 06h		;jmp	TryNext

				;TryEnum:
	db  3Ch, 0B2h		;cmp	al,ENMREC
	db  75h, 6Ch		;jne	CorruptExe		
	db  0F3h, 0A4h		;rep movsb			
				;TryNext:

	db  92h			;xchg	dx,ax
;	db  8Ah, 0C2h		;mov	al,dl			

	db  0A8h, 01h		;test	al,1			
	db  74h, 0B9h		;jz	NextRec			
	db  90h, 90h		;nop, nop
	

last_stop	equ	$ - second
size_str1	equ	$-str1


	;
	; The following is the code that we need to look for in the exe
	; file.
	;
scan_patch1	label	byte

	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  2Bh, 0C2h		;sub	ax, dx
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh,00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  2Bh, 0C2h		;sub	ax, dx
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0fh,00h	;mov	di,000FH
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 09h		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx		
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H	       
	       			;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 09h		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  83h, 0CFh, 0F0h	;or	di,0FFF0H
				;DI_ok:

size_scan_patch1	equ	$-scan_patch1


scan_patch2	label	byte

			
	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0Fh, 00h	;mov	di,000FH		
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 0Ah		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx		
	db  81h, 0CEh, 0F0h, 0FFh
				;or	si,0FFF0H
				;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 0Ah		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  81h, 0CFh, 0F0h, 0FFh
				;or	di,0FFF0H
				;DI_ok:


size_scan_patch2	equ	$-scan_patch2


scan_patch3	label	byte

			
	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0Fh, 00h	;mov	di,000FH		
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 09h		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx	
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H	
				;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 09h		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  83h, 0CFh, 0F0h	;or	di,0FFF0H
				;DI_ok:


size_scan_patch3	equ	$-scan_patch3


scan_com	label	byte

	db  0ACh		;lodsb			
	db  8Ah, 0D0h		;mov	dl,al		
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh, 0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah, 0C2h		;mov	al,dl		
	db  24h, 0FEh		;and	al,0FEH		
	db  3Ch, 0B0h		;cmp	al,RPTREC
	db  75h, 06h		;jne	TryEnum
	db  0ACh		;lodsb				
	db  0F3h, 0AAh		;rep stosb			
	db  0EBh, 07h, 90h	;jmp	TryNext
				;TryEnum:
	db  3Ch, 0B2h		;cmp	al,ENMREC
	db  75h, 6Bh		;jne	CorruptExe		
	db  0F3h, 0A4h		;rep movsb			
				;TryNext:
	db  8Ah, 0C2h		;mov	al,dl			
	db  0A8h, 01h		;test	al,1			
;	db  74h, 0BAh		;jz	NextRec			

size_scan_com	equ	$-scan_com

ExePatch	proc	near
		call	ExePackPatch
		call	word ptr RationalPatchPtr
		ret
ExePatch	endp



;---------------------------------------------------------------------------
;
; Procedure Name 	: ExePackPatch
;
; Inputs	 	: DS 			-> DOSDATA
;			  ES:0 			-> read in image
;			  ax:cx = start cs:ip of program
; Output		:		
;
;	1. If ES <= 0fffh
;	   2. if exepack signature ('RB') found
;	      3. if common code to patch compares (for 3 diff. versions)
;	       	 4. if rest of the code & checksum compares
;	  	    5. overlay buggy code with code in 
;		       doscode:str1.
;		 6. endif
;	      7. endif
;	   8. endif
;	9. endif
;
;
; Uses			: NONE
;
;---------------------------------------------------------------------------
		

ExePackPatch	proc	near

	push	bx
	mov	bx, es			; bx has load segment
	cmp	bx, 0fffh		; Q: is the load segment > 64K
	jbe	ep_cont			; N: 
	pop	bx			; Y: no need to patch
	ret

ep_cont:
	push	ds
	push	es
	push	ax
	push	cx
	push	si
	push	di
	
		; M033 - start
		; exepacked prgrams have an IP of 12h (>=2)

	sub	cx, 2			; Q: is IP >=2 
	ljc	ep_notpacked		; N: exit
					; ax:cx now points to location of
					; 'RB' if this is an exepacked file.

		; M033 - end

	mov	di, cx
	mov	es, ax
	mov	[unpack_offset], di	; save pointer to 'RB' in 
					; unpack_offset


	cmp	word ptr es:[di], 'BR'
	ljne	ep_notpacked

	push	cs
	pop	ds			; set ds to cs
	assume	ds:nothing

	add	di, PATCH1_COM_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 

	call	chk_common_str		; check for match

	jnz	ep_chkpatch2		; Q: does the patch match
					; N: check at patch2_offset
					; Y: check for rest of patch string

	mov	si, offset DOSCODE:scan_patch1
					; ds:si -> scan string 
	mov	di, [unpack_offset]	; restore di to point to 'RB'

	add	di, PATCH1_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch1
	mov	bx, CHKSUM1_LEN
	mov	ax, PATCH1_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	ep_done1		; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 
	
	mov	si, offset DOSCODE:str1
	mov	cx, size_str1
	
rep	movsb


ep_done1:
	jmp	ep_done


ep_chkpatch2:
	mov	di, PATCH2_COM_OFFSET	; es:di -> possible loaction of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	ep_chkpatch3		; Q: does the patch match
					; N: check for patch3_offset
					; Y: check for rest of patch string

	mov	si, offset DOSCODE:scan_patch2
					; ds:si -> scan string 

	mov	di, PATCH2_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch2
	mov	bx, CHKSUM2_LEN
	mov	ax, PATCH2_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare

					; M046 - Start
					; Q: did we pass the test
	jnc	ep_patchcode2		; Y: overlay code with new 
					; N: try with a different chksum


	mov	si, offset DOSCODE:scan_patch2
					; ds:si -> scan string 
	mov	cx, size_scan_patch2
	mov	bx, CHKSUM2A_LEN
	mov	ax, PATCH2A_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
					; Q: did we pass the test
	jc	ep_notpacked		; N: try with a different chksum
					; Y: overlay code with new 
						
ep_patchcode2:			       	; M046 - End
	mov	si, offset DOSCODE:str1
	mov	cx, first_stop
	
rep	movsb

	mov	ax, 4890h		; ax = opcodes for dec ax, nop
	stosw
	add	si, 2

	mov	cx, second_stop

rep	movsb

	stosw				; put in dec ax and nop
	add	si, 2

	mov	cx, last_stop

rep	movsb

	jmp	short ep_done

ep_chkpatch3:

	mov	di, PATCH3_COM_OFFSET	; es:di -> possible loaction of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	ep_notpacked		; Q: does the patch match
					; N: exit
					; Y: check for rest of patch string


	mov	si, offset DOSCODE:scan_patch3
					; ds:si -> scan string 

	mov	di, PATCH3_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch3
	mov	bx, CHKSUM3_LEN
	mov	ax, PATCH3_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	ep_notpacked		; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 

	mov	si, offset DOSCODE:str1
	mov	cx, first_stop
	
rep	movsb

	mov	al, 48h			; al = opcode for dec ax
	stosb
	add	si, 2

	mov	cx, second_stop

rep	movsb

	stosb				; put in dec ax
	add	si, 2

	mov	cx, last_stop

rep	movsb

	

ep_notpacked:

;	stc
;

ep_done:

	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	es
	pop	ds
	pop	bx
	ret

;-------------------------------------------------------------------------
;
; 	Procedure Name	: chk_common_str
;
;	Input		: DS = DOSCODE
;			; ES:DI points to string in packed file
;
;	Output		; Z if match else NZ
;
;-----------------------------------------------------------------------

chk_common_str	proc	near

	mov	si, offset DOSCODE:scan_com
					; ds:si -> scan string 
	mov	cx, size_scan_com

repe	cmpsb	       

					; M046 - start
	; a fourth possible version of these exepacked programs have a 
	; 056h instead of 06bh. See scan_com above
	;
	; 	db  75h, 6Bh		;jne	CorruptExe		
	;
	; If the mismatch at this point is due to a 56h instead of 6bh 
	; we shall try to match the rest of the string
	;

	jz	ccs_done
	cmp	byte ptr es:[di-1], 56h
	jnz	ccs_done

repe	cmpsb	    
  
ccs_done:				; M046 - end
	ret

chk_common_str	endp		


;---------------------------------------------------------------------------
;
;	Procedure Name	: chk_patchsum
;
;	Input		: DS:SI -> string we're looking for
;			: ES:DI -> offset in packed file
;			: CX 	= scan length
;			: BX	= length of check sum
;			: AX 	= value of check sum
;
;	Output		: if patch & check sum compare
;				NC
;			  else
;				CY
;
;	Uses		: AX, BX, CX, SI
;----------------------------------------------------------------------------

chk_patchsum	proc	near

	push	di

repe	cmpsb			   

	jnz	cp_fail			; Q: does the patch match
					; N: exit
					; Y:	


		; we do a check sum starting from the location of the 
		; exepack signature 'RB' up to 11c/2 bytes, the end of the
		; unpacking code.


	mov	di, [unpack_offset]	; di -> start of unpack code
	mov	cx, bx			; cx = length of check sum

	mov	bx, ax			; save check sum passed to us in bx
	xor	ax, ax

ep_chksum:
	add	ax, word ptr es:[di]
	add	di, 2
	loop	ep_chksum

	pop	di			; restore di

	cmp	ax, bx		 	; Q: does the check sum match
	jnz	cp_fail			; N: exit
					; Y: 

	clc	
	ret

cp_fail:
	stc
	ret

chk_patchsum	endp


ExePackPatch	endp
;
; M020 : BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : RationalPatch
;
; A routine (in Ration DOS extender) which is invoked at hardware interrupts
; clobbers CX registeron 286 machines. (123 release 3 uses Rational DOS
; extender). This routine identfies Buggy Rational EXEs and fixes the bug.
;
; THE BUG is in the following code sequence:
;
;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
;90		even				; word align
;e2 fe		loop	$			; wait		CLOBBERS CX
;e8 xx xx	call	set_A20			; enable A20
;
; This patch routine replaces the mov & the loop with a far call into a
; routine in DOS data segment which is in low memory (because A20 line
; is off). The routine (RatBugCode) in DOS data saves & restores CX around
; a mov & loop.
;
; Identification of Buggy Rational EXE
; ====================================
;
; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
;
; OFFSET				Contains
; ------				--------
; 0000h			100 times Version number in binary
;			bug exists in version 3.48 thru 3.83 (both inclusive)
;
; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
;
; 002ah			offset where version number is stored in ASCII
;				e.g. '3.48A'
;
; 0030h			offset of copyright string. Copyright strings either
;			start with "DOS/16M Copyright...." or
;			"Copyright.....". The string contains
;			"Rational Systems, Inc."
;
; 0020h			word : Paragraph offset of the buggy code segment
;				from the program image
; 0016h			word : size of buggy code segment
;
;	Buggy code is definite to start after offset 200h in its segment
;
;----------------------------------------------------------------------------
;
RScanPattern1	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
RLen1		equ	$ - offset RScanPattern1

RScanPattern2	db	8bh, 0eh, 10h, 00h, 90h, 0e2h, 0feh, 0e8h
RLen2		equ	$ - offset RScanPattern2

RScanPattern3	db	8bh, 0eh, 10h, 00h, 0e2h, 0feh, 0e8h
RLen3		equ	$ - offset RScanPattern2
;
;----------------------------------------------------------------------------
;
; INPUT : ES = segment where program got loaded
;
;----------------------------------------------------------------------------

RationalPatch	proc	near
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds			; we use all of them
		mov	di, 0ah			; look for pat1 at offset 0a
		push	cs
		pop	ds
		assume	ds:nothing
		mov	si, offset RScanPattern1
		mov	cx, RLen1
		rep	cmpsb			; do we have the pattern ?
		jne	rpexit
		mov	ax, es:[0]
		cmp	ax, 348			; is it a buggy version ?
		jb	rpexit
		cmp	ax, 383			; is it a buggy version
		ja	rpexit

		call	VerifyVersion
		jne	rpexit

		mov	cx, es:[16h]		; Length of buggy code seg
		sub	cx, 200h		; Length we search (we start
						;  at offset 200h)
		mov	es, word ptr es:[20h]	; es=buggy code segment
		mov	si, offset RScanPattern2
		mov	dx, RLen2
		call	ScanCodeSeq		; look for code seq with nop
		jz	rpfound

		mov	si, offset RScanPattern3
		mov	dx, RLen3
		call	ScanCodeSeq		; look for code seq w/o nop
		jnz	rpexit
rpfound:

;		we set up a far call into DOS data
;		dx has the length of the doce seq we were searching for

		mov	al, 9ah			; far call opcode
		stosb
		mov	ax, offset RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6			; filler (with NOPs)
		mov	al, 90h
		rep	stosb
rpexit:
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		ret
RationalPatch	endp
;
; M020 END
;

;---------------------------------------------------------------------------
;
;	M068
;
; 	Procedure Name	: IsCopyProt
;
;	Inputs		: DS:100 -> start of com file just read in
;
;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
;			  the program loaded in DS:100 uses a MICROSOFT
;			  copy protect scheme that relies on the A20 line
;			  being turned off for it's scheme to work.
;
;			  Note: The int 21 function dispatcher will turn 
;				a20 off, if the A20OFF_COUNT is non-zero 
;				and dec the A20OFF_COUNT before	iretting 
;				to the user. 
;
;	Uses		: ES, DI, SI, CX
;
;---------------------------------------------------------------------------

CPStartOffset	EQU	0175h
CPID1Offset	EQU	011bh
CPID2Offset	EQU	0173h
CPID3Offset	EQU	0146h
CPID4Offset	EQU	0124h
ID1		EQU	05343h
ID2		EQU	05044h
ID3		EQU	0F413h
ID4		EQU	08000h

CPScanPattern	db	089h, 026h, 048h, 01h		; mov [148], sp
		db	08ch, 0eh , 04ch, 01h		; mov [14c], cs
		db	0c7h, 06h , 04ah, 01h, 0h, 01h	; mov [14a], 100h 
		db 	08ch, 0eh , 013h, 01h		; mov [113], cs
		db	0b8h, 020h, 01h			; mov ax, 120h
		db	0beh, 00h , 01h			; mov si, 100h

CPSPlen		EQU	$ - CPScanPattern

IsCopyProt	proc	near

	cmp	ds:[CPID1Offset], ID1
	jne	CP_done

	cmp	ds:[CPID2Offset], ID2
	jne	CP_done

	cmp	ds:[CPID3Offset], ID3
	jne	CP_done

	cmp	ds:[CPID4Offset], ID4
	jne	CP_done

	push	cs
	pop	es
	mov	di, offset CPScanPattern	; es:di -> Pattern to find

	mov	si, CPStartOffset		; ds:si -> possible location 
						; of pattern

	mov	cx, CPSPlen			; cx = length of pattern

repe	cmpsb

	jnz	CP_done
	mov	ss:[A20OFF_COUNT], 0AH		; M071
CP_done:
	ret
	
IsCopyProt	endp

		
DOSCODE	ENDS

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\fcbio.asm ===
TITLE	FCBIO - FCB system calls
	NAME	FCBIO

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
;
;	$GET_FCB_POSITION
;	$FCB_DELETE
;	$GET_FCB_FILE_LENGTH
;	$FCB_CLOSE
;	$FCB_RENAME
;	SaveFCBInfo
;	ResetLRU
;	SetOpenAge
;	LRUFCB
;	FCBRegen
;	BlastSFT
;	CheckFCB
;	SFTFromFCB
;	FCBHardErr
;
;	Revision history:
;
;		Created: ARR 4 April 1983
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;					  times.  Change so successive closes work by
;					  always returning OK.	Also, detect I/O to
;					  already closed FCB and return EOF.
;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
;					  out of sft into FCB for reconnection
;
;		A000	 version 4.00  Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include cpmfcb.inc
	include syscall.inc
	include filemode.inc
	include dpb.inc
	include mult.inc
	include bugtyp.inc
	.cref
	.list


	I_need	OpenBuf,128		; buffer for translating paths
	I_need	RenBuf,128		; buffer for rename paths
	i_need	THISDPB,DWORD
	i_need	EXTERR,WORD
	i_need	ALLOWED,BYTE
	I_need	ThisSFT,DWORD		; SFT in use
	I_need	WFP_start,WORD		; pointer to canonical name
	I_need	Ren_WFP,WORD		; pointer to canonical name
	I_need	Attrib,BYTE		; Attribute for match attributes
	I_need	sftFCB,DWORD		; pointer to SFTs for FCB cache
	I_need	FCBLRU,WORD		; least recently used count
	I_need	Proc_ID,WORD		; current process ID
	I_Need	Name1,14		; place for device names
	I_need	DEVPT,DWORD		; device pointer
	I_need	OpenLRU,WORD		; open age
	I_need	KeepCount,WORD		; number of fcbs to keep
	I_need	User_In_AX,WORD 	; user input system call.
	I_need	JShare,DWORD		; share jump table
	I_need	FastOpenTable,BYTE	; DOS 3.3 fastopen

	I_need	LocalSFT,DWORD		;added for new FCB implementation


DOSCODE	SEGMENT
	ASSUME	CS:DOSCODE

	extrn	CheckShare:near
	extrn	GetExtended:near
ifdef DBCS
	extrn	TestKanj:near
endif
	extrn	TransFCB:near
	extrn	UCase:near

	allow_getdseg


Break <$Get_FCB_Position - set random record fields to current pos>
;
;----------------------------------------------------------------------------
;
;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
;	extent and next record field and set the random record field to point
;	to that record
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	The random record field of the FCB is set to the current record
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure $Get_FCB_Position,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	call	GetExtended		; point to FCB
	invoke	GetExtent		; DX:AX is current record
	MOV	WORD PTR [SI.fcb_RR],AX ; drop in low order piece
	MOV	[SI+fcb_RR+2],DL	; drop in high order piece
	CMP	[SI.fcb_RECSIZ],64
	JAE	GetFCBBye
	MOV	[SI+fcb_RR+2+1],DH	; Set 4th byte only if record size < 64
GetFCBBye:
	transfer    FCB_Ret_OK
EndProc $GET_FCB_POSITION


	Break <$FCB_Delete - remove several files that match the input FCB>
;
;----------------------------------------------------------------------------
;
;**	$FCB_Delete - Delete from FCB Template
;
;	given an FCB, remove all directory entries in the current
;	directory that have names that match the FCB's ?  marks.
;
;	ENTRY	(DS:DX) = address of FCB
;	EXIT	entries matching the FCB are deleted
;		(al) = ff iff no entries were deleted
;	USES	all
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Delete,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

					; OpenBuf is in DOSDATA
					; appropriate place
	MOV	DI,OFFSET DOSDATA:OpenBuf  

	call	TransFCB		; convert FCB to path
	JC	BadPath 		; signal no deletions

	Context DS			; SS is DOSDATA

	invoke	DOS_Delete		; wham
	JC	BadPath
GoodPath:
	transfer    FCB_Ret_OK		; do a good return
BadPath:

	;
	; Error code is in AX
	;

	transfer    FCB_Ret_Err 	; let someone else signal the error

EndProc $FCB_DELETE

Break <$Get_FCB_File_Length - return the length of a file>
;
;----------------------------------------------------------------------------
;
;   $Get_FCB_File_Length - set the random record field to the length of the
;	file in records (rounded up if partial).
;
;   Inputs:	DS:DX - point to a possible extended FCB
;   Outputs:	Random record field updated to reflect the number of records
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   $Get_FCB_File_Length,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	call	GetExtended		; get real FCB pointer
					; DX points to Input FCB

					; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer

	SAVE	<DS,SI> 		; save pointer to true FCB
	call	TransFCB		; Trans name DS:DX, sets SATTRIB
	RESTORE <SI,DS>
	JC	BadPath
	SAVE	<DS,SI> 		; save pointer

	Context DS			; SS is DOSDATA

	invoke	Get_File_Info		; grab the info
	RESTORE <SI,DS>			; get pointer back
	JC	BadPath 		; invalid something
	MOV	DX,BX			; get high order size
	MOV	AX,DI			; get low order size
	MOV	BX,[SI.fcb_RECSIZ]	; get his record size
	OR	BX,BX			; empty record => 0 size for file
	JNZ	GetSize 		; not empty
	MOV	BX,128
GetSize:
	MOV	DI,AX			; save low order word
	MOV	AX,DX			; move high order for divide
	XOR	DX,DX			; clear out high
	DIV	BX			; wham
	PUSH	AX			; save dividend
	MOV	AX,DI			; get low order piece
	DIV	BX			; wham
	MOV	CX,DX			; save remainder
	POP	DX			; get high order dividend
	JCXZ	LengthStore		; no roundup
	ADD	AX,1
	ADC	DX,0			; 32-bit increment
LengthStore:
	MOV	WORD PTR [SI.FCB_RR],AX ; store low order
	MOV	[SI.FCB_RR+2],DL	; store high order
	OR	DH,DH
	JZ	GoodPath		; not storing insignificant zero
	MOV	[SI.FCB_RR+3],DH	; save that high piece
GoodRet:
	transfer    FCB_Ret_OK
EndProc $GET_FCB_FILE_LENGTH

Break <$FCB_Close - close a file>

;
;----------------------------------------------------------------------------
;
;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
;	as the FCB may be used for further I/O
;
;   Inputs:	DS:DX point to FCB
;   Outputs:	AL = FF if file was not found on disk
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Close,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	XOR	AL,AL			; default search attributes
	call	GetExtended		; DS:SI point to real FCB
	JZ	NoAttr			; not extended
	MOV	AL,[SI-1]		; get attributes
NoAttr:

					; SS override
	MOV	[Attrib],AL		; stash away found attributes

	invoke	SFTFromFCB
	JC	GoodRet 		; MZ 16 Jan Assume death

	;
	; If the sharer is present, then the SFT is not regenable.  Thus, 
	; there is no need to set the SFT's attribute.
	;

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	MOV	AL,ES:[DI].sf_attr
	XOR	AH,AH
	PUSH	AX

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	call	CheckShare
	JNZ	NoStash
	MOV	AL,Attrib
	MOV	ES:[DI].sf_attr,AL	; attempted attribute for close
NoStash:
	MOV	AX,[SI].FCB_FDATE	; move in the time and date
	MOV	ES:[DI].sf_date,AX
	MOV	AX,[SI].FCB_FTIME
	MOV	ES:[DI].sf_time,AX
	MOV	AX,[SI].FCB_FilSiz
	MOV	WORD PTR ES:[DI].sf_size,AX
	MOV	AX,[SI].FCB_FilSiz+2
	MOV	WORD PTR ES:[DI].sf_size+2,AX
	OR	ES:[DI].sf_Flags,sf_close_nodate

					; SS is DOSDATA
	Context DS			; let Close see variables

	invoke	DOS_Close		; wham
	LES	DI,ThisSFT

	;;; 9/8/86 F.C. restore SFT attribute

	POP	CX
	MOV	ES:[DI].sf_attr,CL

	;;; 9/8/86 F.C. restore SFT attribute

	PUSHF
	cmp	ES:[DI.sf_ref_count],0	; zero ref count gets blasted
	JNZ	CloseOK
	PUSH	AX
	MOV	AL,'M'
	call	BlastSFT
	POP	AX
CloseOK:
	POPF
	JNC	GoodRet
	CMP	AL,error_invalid_handle
	JZ	GoodRet
	MOV	AL,error_file_not_found
	transfer    FCB_Ret_Err
EndProc $FCB_CLOSE

;
;----------------------------------------------------------------------------
;
;**	$FCB_Rename - Rename a File
;
;	$FCB_Rename - rename a file in place within a directory.  Renames
;	multiple files copying from the meta characters.
;
;	ENTRY	DS:DX point to an FCB.	The normal name field is the source
;		    name of the files to be renamed.  Starting at offset 11h
;		    in the FCB is the destination name.
;	EXIT	AL = 0 -> no error occurred and all files were renamed
;		AL = FF -> some files may have been renamed but:
;			rename to existing file or source file not found
;	USES	ALL
;
;----------------------------------------------------------------------------
;

Procedure $FCB_Rename,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	call	GetExtended		; get pointer to real FCB
	SAVE	<DX>
	MOV	AL,[SI] 		; get drive byte
	ADD	SI,10h			; point to destination

					; RenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:RenBuf   ; point to destination buffer

	SAVE	<<WORD PTR DS:[SI]>,DS,SI>  ; save source pointer for TransFCB
	MOV	DS:[SI],AL		; drop in real drive
	MOV	DX,SI			; let TransFCB know where the FCB is
	call	TransFCB		; munch this pathname
	RESTORE <SI,DS,<WORD PTR DS:[SI]>>	; get path back
	RESTORE <DX>			; Original FCB pointer
	JC	fren90			; bad path -> error

					; SS override for WFP_Start & Ren_WFP
	MOV	SI,WFP_Start		; get pointer
	MOV	Ren_WFP,SI		; stash it

					; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate spot
	call	TransFCB		; wham
					; NOTE that this call is pointing
					;  back to the ORIGINAL FCB so
					;  SATTRIB gets set correctly
	JC	fren90			; error
	invoke	DOS_Rename
	JC	fren90
	transfer    FCB_Ret_OK

;	Error -
;
;	(al) = error code

fren90:	transfer    FCB_Ret_Err

EndProc $FCB_RENAME

Break <Misbehavior fixers>

;
;   FCBs suffer from several problems.	First, they are maintained in the
;   user's space so he may move them at will.  Second, they have a small
;   reserved area that may be used for system information.  Third, there was
;   never any "rules for behavior" for FCBs; there was no protocol for their
;   usage.
;
;   This results in the following misbehavior:
;
;	infinite opens of the same file:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB);		    FCBOpen (FCB);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	infinite opens of different files:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	multiple closes of the same file:
;
;	FCBOpen (FCB);
;	while (TRUE)
;	    FCBClose (FCB);
;
;	I/O after closing file:
;
;	FCBOpen (FCB);
;	while (TRUE) {
;	    FCBWrite (FCB);
;	    FCBClose (FCB);
;	    }
;
;   The following is am implementation of a methodology for emulating the
;   above with the exception of I/O after close.  We are NOT attempting to
;   resolve that particular misbehavior.  We will enforce correct behaviour in
;   FCBs when they refer to a network file or when there is file sharing on
;   the local machine.
;
;   The reserved fields of the FCB (10 bytes worth) is divided up into various
;   structures depending on the file itself and the state of operations of the
;   OS.  The information contained in this reserved field is enough to
;   regenerate the SFT for the local non-shared file.  It is assumed that this
;   regeneration procedure may be expensive.  The SFT for the FCB is
;   maintained in a LRU cache as the ONLY performance inprovement.
;
;   No regeneration of SFTs is attempted for network FCBs.
;
;   To regenerate the SFT for a local FCB, it is necessary to determine if the
;   file sharer is working.  If the file sharer is present then the SFT is not
;   regenerated.
;
;   Finally, if there is no local sharing, the full name of the file is no
;   longer available.  We can make up for this by using the following
;   information:
;
;	The Drive number (from the DPB).
;	The physical sector of the directory that contains the entry.
;	The relative position of the entry in the sector.
;	The first cluster field.
;	The last used SFT.
;      OR In the case of a device FCB
;	The low 6 bits of sf_flags (indicating device type)
;	The pointer to the device header
;
;
;   We read in the particular directory sector and examine the indicated
;   directory entry.  If it matches, then we are kosher; otherwise, we fail.
;
;   Some key items need to be remembered:
;
;	Even though we are caching SFTs, they may contain useful sharing
;	information.  We enforce good behavior on the FCBs.
;
;	Network support must not treat FCBs as impacting the ref counts on
;	open VCs.  The VCs may be closed only at process termination.
;
;	If this is not an installed version of the DOS, file sharing will
;	always be present.
;
;	We MUST always initialize lstclus to = firclus when regenerating a
;	file. Otherwise we start allocating clusters up the wazoo.
;
;	Always initialize, during regeneration, the mode field to both isFCB
;	and open_for_both.  This is so the FCB code in the sharer can find the
;	proper OI record.
;
;   The test bits are:
;
;	00 -> local file
;	40 -> sharing local
;	80 -> network
;	C0 -> local device

Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
;
;----------------------------------------------------------------------------
;
;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
;	pieces of information into the FCB to allow for subsequent
;	regeneration. Poke LRU also.
;
;   Inputs:	ThisSFT points to a complete SFT.
;		DS:SI point to the FCB (not an extended one)
;   Outputs:	The relevant reserved fields in the FCB are filled in.
;		DS:SI preserved
;		ES:DI point to sft
;   Registers modified: All
;
;
;----------------------------------------------------------------------------
;
Procedure   SaveFCBInfo,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	LES	DI,ThisSFT		; SS override

	Assert	ISSFT,<ES,DI>,"SaveFCBInfo"
	invoke	IsSFTNet
	JZ	SaveLocal		; if not network then save local info
;
;----- In net support -----
;
	MOV	AX,WORD PTR ES:[DI].sf_serial_ID	;AN000;;IFS.  save IFS ID
	MOV	WORD PTR [SI].FCB_netID,ax		;AN000;;IFS.
;	SAVE	<ES,DI>
;	LES	DI,DWORD PTR ES:[DI].sf_netid
;	MOV	WORD PTR [SI].FCB_netID,DI  ; save net ID
;	MOV	WORD PTR [SI].FCB_netID+2,ES
;	RESTORE <DI,ES>
	MOV	BL,FCBNETWORK
;
;----- END In net support -----
;
	jmp	SHORT SaveSFN

SaveLocal:
	IF	Installed
	call	CheckShare
	JZ	SaveNoShare		; no sharer
	JMP	short SaveShare		; sharer present

SaveNoShare:
	TESTB	ES:[DI].sf_flags,devid_device
	JNZ	SaveNoShareDev		; Device
	;
	; Save no sharing local file information
	;
	MOV	AX,WORD PTR ES:[DI].sf_dirsec ; get directory sector F.C.
	MOV	[SI].fcb_nsl_dirsec,AX

	;SR; Store high byte of directory sector

	mov	ax,word ptr es:[di].sf_dirsec+2 ; get high word

	; SR;
	; We have to store the read-only and archive attributes of the file.
	; We extract it from the SFT and store it in the top two bits of the 
	; sector number ( sector number == 22 bits only )
	;
	mov	bl,es:[di].sf_attr
	mov	bh,bl
	ror	bl,1
	shl	bh,1
	or	bl,bh
	and	bl,0c0h

	or	al,bl
	mov	[si].fcb_sfn,al	;sector number = 22-bits

	MOV	AL,ES:[DI].sf_dirpos	; location in sector
	MOV	[SI].fcb_nsl_dirpos,AL
	MOV	AX,ES:[DI].sf_firclus	; first cluster
	MOV	[SI].fcb_nsl_firclus,AX
	MOV	BL,00
	;
	; Create the bits field from the dirty/device bits of the flags word 
	; and the mode byte
	;
SetFCBBits:
	MOV	AX,ES:[DI].sf_flags
	AND	AL,0C0h 		; mask off drive bits
	OR	AL,BYTE PTR ES:[DI].sf_mode ; stick in open mode
	MOV	[SI].fcb_nsl_bits,AL	; save dirty info

	; SR;
	; Check if we came here for local file or device. If for local file, 
	; skip setting of SFT index

	or	bl,bl
	jz	SaveNoSFN	; do not save SFN if local file

	JMP	short SaveSFN 		; go and save SFN

	;
	; Save no sharing local device information
	;
SaveNoShareDev:
	MOV	AX,WORD PTR ES:[DI].sf_devptr
	MOV	WORD PTR [SI].FCB_nsld_drvptr,AX
	MOV	AX,WORD PTR ES:[DI].sf_devptr + 2
	MOV	WORD PTR [SI].FCB_nsld_drvptr + 2,AX
	MOV	BL,FCBDEVICE
	JMP	SetFCBBits		; go and save SFN

SaveShare:
	ENDIF
;
;----- In share support -----
;
if installed
	Call	JShare + 10 * 4
else
	Call	ShSave
endif
;
;----- end in share support -----
;
SaveSFN:
	LEA	AX,[DI-SFTable]
	;
	; Adjust for offset to table.
	;
	SUB	AX,WORD PTR SftFCB	; SS override for SftFCB

	push	bx			;bx = FCB type (net/Share or local)
	MOV	BL,SIZE sf_entry
	DIV	BL
	MOV	[SI].FCB_sfn,AL 	; last used SFN
	pop	bx			;restore bx
SaveNoSFN:

	MOV	AX,ES:[DI].sf_flags
	AND	AL,3Fh			; get real drive
	OR	AL,BL
	MOV	[SI].fcb_l_drive,AL

	MOV	AX,FCBLRU		; get lru count
	INC	AX
	MOV	WORD PTR ES:[DI].sf_LRU,AX
	JNZ	SimpleStuff
	;
	; lru flag overflowed.	Run through all FCB sfts and adjust:  
	; LRU < 8000H get set to 0.  Others -= 8000h.  This LRU = 8000h
	;
	MOV	BX,sf_position
	call	ResetLRU

	;	Set new LRU to AX

SimpleStuff:
	MOV	FCBLRU,AX
	return

EndProc SaveFCBInfo

Break	<ResetLRU - reset overflowed lru counts>

;
;----------------------------------------------------------------------------
;
;   ResetLRU - during lru updates, we may wrap at 64K.	We must walk the
;   entire set of SFTs and subtract 8000h from their lru counts and truncate
;   at 0.
;
;   Inputs:	BX is offset into SFT field where lru firld is kept
;		ES:DI point to SFT currently being updated
;   Outputs:	All FCB SFTs have their lru fields truncated
;		AX has 8000h
;   Registers modified: none
;
;----------------------------------------------------------------------------
;

Procedure   ResetLRU,NEAR

	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
	; DOSDATA

	ASSUME CS:DOSCODE

	DOSAssume <SS>, "ResetLRU"

	Assert	ISSFT,<ES,DI>,"ResetLRU"
	MOV	AX,8000h
	SAVE	<ES,DI>
	LES	DI,sftFCB		; get pointer to head
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable 	; point at table
ovScan:
	SUB	WORD PTR ES:[DI+BX],AX	; decrement lru count
	JA	ovLoop
	MOV	WORD PTR ES:[DI.BX],AX	; truncate at 0
ovLoop:
	ADD	DI,SIZE SF_Entry	; advance to next
	LOOP	ovScan
	RESTORE <DI,ES>
	MOV	ES:[DI+BX],AX
	return

EndProc ResetLRU

IF  0  ; We dont need this routine any more.

Break	<SetOpenAge - update the open age of a SFT>

;
;----------------------------------------------------------------------------
;
;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
;   we keep the 'open age' or an LRU count based on opens.  We update the
;   count here and fill in the appropriate field.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	ES:DI has the open age field filled in.
;		If open age has wraparound, we will have subtracted 8000h
;		    from all open ages.
;   Registers modified: AX
;
;----------------------------------------------------------------------------
;


Procedure   SetOpenAge,NEAR

	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.

	ASSUME CS:DOSCODE

	DOSAssume <SS>, "SetOpenAge"

	Assert	ISSFT,<ES,DI>,"SetOpenAge"

	MOV	AX,OpenLRU		; SS override
	INC	AX
	MOV	ES:[DI].sf_OpenAge,AX
	JNZ	SetDone
	MOV	BX,sf_Position+2
	call	ResetLRU
SetDone:
	MOV	OpenLRU,AX
	return
EndProc SetOpenAge

ENDIF	; SetOpenAge no longer needed


Break	<LRUFCB - perform LRU on FCB sfts>

;
;----------------------------------------------------------------------------
;
;   LRUFCB - find LRU fcb in cache.  Set ThisSFT and return it.  We preserve
;	the first keepcount sfts if they are network sfts or if sharing is
;	loaded.  If carry is set then NO BLASTING is NECESSARY.
;
;   Inputs:	none
;   Outputs:	ES:DI point to SFT
;		ThisSFT points to SFT
;		SFT is zeroed
;		Carry set of closes failed
;   Registers modified: none
;
;----------------------------------------------------------------------------
;
IF 0	; rewritten this routine

Procedure   LRUFCB,NEAR
	ASSUME CS:DOSCODE,SS:NOTHING

	Save_World
	getdseg	<ds>			; ds -> dosdata

; Find nth oldest NET/SHARE FCB.  We want to find its age for the second scan
; to find the lease recently used one that is younger than the open age.  We
; operate be scanning the list n times finding the least age that is greater
; or equal to the previous minimum age.
;
;   BP is the count of times we need to go through this loop.
;   AX is the current acceptable minimum age to consider
;
	mov	bp,KeepCount		; k = keepcount;
	XOR	AX,AX			; low = 0;
;
; If we've scanned the table n times, then we are done.
;
lru1:
	CMP	bp,0			; while (k--) {
	JZ	lru75
	DEC	bp
;
; Set up for scan.
;
;   AX is the minimum age for consideration
;   BX is the minimum age found during the scan
;   SI is the position of the entry that corresponds to BX
;
	MOV	BX,-1			;     min = 0xffff;
	MOV	si,BX			;     pos = 0xffff;
	LES	DI,SFTFCB		;     for (CX=FCBCount; CX>0; CX--)
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable
;
; Innermost loop.  If the current entry is free, then we are done.  Or, if the
; current entry is busy (indicating a previous aborted allocation), then we
; are done.  In both cases, we use the found entry.
;
lru2:
	cmp	es:[di].sf_ref_count,0
	jz	lru25
	cmp	es:[di].sf_ref_count,sf_busy
	jnz	lru3
;
; The entry is usable without further scan.  Go and use it.
;
lru25:
	MOV	si,DI			;	      pos = i;
	JMP	short lru11		;	      goto got;
;
; See if the entry is for the network or for the sharer.
;
;  If for the sharer or network then
;	if the age < current minimum AND >= allowed minimum then
;	    this entry becomes current minimum
;
lru3:
	TESTB	ES:[DI].sf_flags,sf_isnet   ;	  if (!net[i]
	JNZ	lru35
if installed
	call	CheckShare		;		&& !sharing)
	JZ	lru5			;	  else
ENDIF
;
; This SFT is for the net or is for the sharer.  See if it less than the
; current minimum.
;
lru35:
	MOV	DX,ES:[DI].sf_OpenAge
	CMP	DX,AX			;	  if (age[i] >= low &&
	JB	lru5
	CMP	DX,BX
	JAE	lru5			;	      age[i] < min) {
;
; entry is new minimum.  Remember his age.
;
	mov	bx,DX			;	      min = age[i];
	mov	si,di			;	      pos = i;
;
; End of loop.	gp back for more
;
lru5:
add	di,size sf_entry
	loop	lru2			;	      }
;
; The scan is complete.  If we have successfully found a new minimum (pos != -1)
; set then threshold value to this new minimum + 1.  Otherwise, the scan is
; complete.  Go find LRU.
;
lru6:	cmp	si,-1			; position not -1?
	jz	lru75			; no, done with everything
	lea	ax,[bx+1]		; set new threshold age
	jmp	lru1			; go and loop for more
lru65:	stc
	jmp	short	lruDead 	;	  return -1;
;
; Main loop is done.  We have AX being the age+1 of the nth oldest sharer or
; network entry.  We now make a second pass through to find the LRU entry
; that is local-no-share or has age >= AX
;
lru75:
	mov	bx,-1			; min = 0xffff;
	mov	si,bx			; pos = 0xffff;
	LES	DI,SFTFCB		; for (CX=FCBCount; CX>0; CX--)
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable
;
; If this is is local-no-share then go check for LRU else if age >= threshold
; then check for lru.
;
lru8:
	TESTB	ES:[DI].sf_flags,sf_isnet
	jnz	lru85			; is for network, go check age
	call	CheckShare		; sharer here?
	jz	lru86			; no, go check lru
;
; Network or sharer.  Check age
;
lru85:
	cmp	es:[di].sf_OpenAge,ax
	jb	lru9			; age is before threshold, skip it
;
; Check LRU
;
lru86:
	cmp	es:[di].sf_LRU,bx	; is LRU less than current LRU?
	jae	lru9			; no, skip this
	mov	si,di			; remember position
	mov	bx,es:[di].sf_LRU	; remember new minimum LRU
;
; Done with this entry, go back for more.
;
lru9:
	add	di,size sf_entry
	loop	lru8
;
; Scan is complete.  If we found NOTHING that satisfied us then we bomb
; out.	The conditions here are:
;
;   No local-no-shares AND all net/share entries are older than threshold
;
lru10:
	cmp	si,-1			; if no one f
	jz	lru65			;     return -1;
lru11:
	mov	di,si
	MOV	WORD PTR ThisSFT,DI	; set thissft
	MOV	WORD PTR ThisSFT+2,ES
;
; If we have sharing or thisSFT is a net sft, then close it until ref count
; is 0.
;
	TESTB	ES:[DI].sf_flags,sf_isNet
	JNZ	LRUClose
IF INSTALLED
	call	CheckShare
	JZ	LRUDone
ENDIF
;
; Repeat close until ref count is 0
;
LRUClose:

;	DS already set up at beginnnig of proceure.
; 	Context DS

	LES	DI,ThisSFT
	CMP	ES:[DI].sf_ref_count,0	; is ref count still <> 0?
	JZ	LRUDone 		; nope, all done

;	Message     1,"LRUFCB: closing "
;	MessageNum  <WORD PTR THISSFT+2>
;	Message     1,":"
;	MessageNum  <WORD PTR THISSFT>

	Invoke	DOS_Close
	jnc	LRUClose		; no error => clean up
	cmp	al,error_invalid_handle
	jz	LRUClose
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	Restore_World			; use macro

	getdseg	<es>			; es -> dosdata
 	LES     DI,ES:ThisSFT
	assume	es:NOTHING	

	Assert	ISSFT,<ES,DI>,"LRUFCB return"
	retnc
	MOV	AL,error_FCB_unavailable
	return
EndProc LRUFCB

ENDIF	; LRUFCB has been rewritten below.


;******* LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
; maintains separate counts for net/Share and local SFTs. We allocate a 
; net/Share SFT only if we do not find a local SFT. This helps keep
; net/Share SFTs which cannot be regenerated for as long as possible. We
; optimize regeneration operations by keeping track of the current local
; SFT. This avoids scanning of the SFTs as long as we have at least one 
; local SFT in the SFT Block.
;
; Inputs: al = 0 => Regenerate SFT operation
;	    = 1 => Allocate new SFT for Open/Create
;
; Outputs: Carry clear
;	 	es:di = Address of allocated SFT
;	  	ThisSFT = Address of allocated SFT
;
;	  carry set if closes of net/Share files failed 
;		al = error_FCB_unavailable
;
; Registers affected: None
;


PUBLIC	LruFCB
LruFCB	PROC	NEAR
	assume	ds:nothing, es:nothing,ss:nothing

	Save_world
	getdseg	<ds>		;ds = DOSDATA

	or	al,al		;Check if regenerate allocation
	jnz	lru1		;Try to find SFT to use

	;
	; This is a regen call. If LocalSFT contains the address of a valid 
	; local SFT, just return that SFT to reuse
	;

	mov	di,word ptr LocalSFT
	or	di,word ptr LocalSFT+2	;is address == 0?
	jz	lru1			;invalid local SFT, find one

	;
	; We have found a valid local SFT. Recycle this SFT
	;

	les	di,LocalSFT

gotlocalSFT:
	mov	word ptr ThisSFT,di
	mov	word ptr ThisSFT+2,es
	clc
	jmp	LRUDone	;clear up SFT and return

lru1:
	les	di,SFTFCB	;es:di = SF Table for FCBs
	mov	cx,es:[di].sfCount	;cx = number of SFTs
	lea	di,[di].sfTable	;es:di = first SFT

	;
	; We scan through all the SFTs scanning for a free one. It also 
	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
	; bx = min. LRU for local SFTs
	; si = pos. of local SFT with min. LRU
	; dx = min. LRU for net/Share SFTs
	; bp = pos. of net/Share SFT with min. LRU
	;

	mov	bx,-1		; init. to 0xffff ( max. LRU value )
	mov	si,bx
	mov	dx,bx
	mov	bp,bx

findSFT:
	;
	;See if this SFT is a free one. If so, return it
	;

	or	es:[di].sf_ref_count,0	;reference count = 0 ?
	jz	gotSFT		;yes, SFT is free
	cmp	es:[di].sf_ref_count,sf_busy	;Is it busy?
	jz	gotSFT		;no, can use it

	;
	; Check if this SFT is local and store its address in LocalSFT. Can be 
	; used for a later regen.
	;

 	test	es:[di].sf_flags,sf_isnet ;network SFT?
	jnz	lru5		;yes, get net/Share LRU
IF installed
	call	CheckShare	;Share present?
ENDIF
	jnz	lru5		;yes, get net/Share LRU

	;
	;Local SFT, register its address
	;

	; !!HACK!!!
	; There is a slightly dirty hack out here in a desperate bid to save  
	; code space. There is similar code duplicated at label 'gotSFT'. We 
	; enter from there if al = 0, update the LocalSFT variable, and since 
	; al = 0, we jump out of the loop to the exit point. I have commented 
	; out the code that previously existed at label 'gotSFT'
	;

hackpoint:
	mov	word ptr LocalSFT,di
	mov	word ptr LocalSFT+2,es	;store local SFT address

	or	al,al		;Is operation = REGEN?
	jz	gotlocalSFT 	;yes, return this SFT for reuse

	;
	;Get LRU for local files
	;

	cmp	es:[di].sf_LRU,bx	;SFT.LRU < min?
	jae	lru4		;no, skip 

	mov	bx,es:[di].sf_LRU	;yes, store new minimum
	mov	si,di		;store SFT position

lru4:
	add	di,SIZE sf_entry	;go to next SFT
	loop	findSFT

	;
	; Check whether we got a net/Share or local SFT. If local SFT 
	; available, we will reuse it instead of net/Share LRU
	;

	mov	di,si
	cmp	si,-1		;local SFT available?
	jnz	gotSFT		;yes, return it

	;
	;No local SFT, see if we got a net/Share SFT
	;

	mov	di,bp
	cmp	bp,-1		;net/Share SFT available?
	jnz	gotnetSFT	;yes, return it
noSFT:

	;
	; NB: This error should never occur. We always must have an LRU SFT. 
	; This error can occur only if the SFT has been corrupted or the LRU 
	; count is not maintained properly.
	;

	jmp	short errorbadSFT	;error, no FCB available.

	;
	; Handle the LRU for net/Share SFTs
	;

lru5:
	cmp	es:[di].sf_LRU,dx	;SFT.LRU < min?
	jae	lru4		;no, skip 

	mov	dx,es:[di].sf_LRU	;yes, store new minimum
	mov	bp,di		;store SFT position
	jmp	short lru4	;continue with next SFT

gotSFT:
	or	al,al
	jz	hackpoint	;save es:di in LocalSFT

	;
	; HACK!!!
	; The code here differs from the code at 'hackpoint' only in the 
	; order of the check for al. If al = 0, we can junp to 'hackpoint' 
	; and then from  there jump out to 'gotlocalSFT'. The original code 
	; has been commented out below and replaced by the code just above.
	;

;
;If regen, then this SFT can be registered as a local one ( even if free ).
;
;	or	al,al		;Regen?
;	jnz	notlocaluse	;yes, register it and return
;
;Register this SFT as a local one
;
;	mov	word ptr LocalSFT,di
;	mov	word ptr LocalSFT+2,es
;	jmp	gotlocalSFT	;return to caller
;
;notlocaluse:

	;
	; The caller is probably going to use this SFT for a net/Share file. 
	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
	; does not really know whether it is a local file or not. We 
	; invalidate LocalSFT if the SFT we are going to use was previously 
	; registered as a local SFT that can be recycled.
	;

	mov	ax,es
	cmp	word ptr LocalSFT,di		;Offset same?
	jnz	notinvalid
	cmp	word ptr LocalSFT+2,ax	;Segments same?
	jz	zerolocalSFT		;no, no need to invalidate
notinvalid:
	jmp	gotlocalSFT

	;
	; The SFT we are going to use was registered in the LocalSFT variable. 
	; Invalidate this variable i.e LocalSFT = NULL
	;

zerolocalSFT:
	xor	ax,ax
	mov	word ptr LocalSFT,ax
	mov	word ptr LocalSFT+2,ax

	jmp	gotlocalSFT

gotnetSFT:

	;
	; We have an SFT that is currently net/Share. If it is going to be 
	; used for a regen, we know it has to be a local SFT. Update the 
	; LocalSFT variable
	;

	or	al,al
	jnz	closenet

	mov	word ptr LocalSFT,di
	mov	word ptr LocalSFT+2,es	;store local SFT address
closenet:
	mov	word ptr ThisSFT,di	; set thissft
	mov	word ptr ThisSFT+2,es	

	;
	; If we have sharing or thisSFT is a net sft, then close it until ref 
	; count is 0.
	; NB: We come here only if it is a net/Share SFT that is going to be 
	; recycled -- no need to check for this.
	;

LRUClose:

	cmp	es:[di].sf_ref_count,0	; is ref count still <> 0?
	jz	LRUDone 		; nope, all done

	call	DOS_Close
	jnc	LRUClose		; no error => clean up

	;
	; Bugbug: I dont know why we are trying to close after we get an 
	; error closing. Seems like we could have a potential infinite loop  
	; here. This has to be verified.
	;

	cmp	al,error_invalid_handle
	jz	LRUClose
errorbadSFT:
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	Restore_World			; use macro

	getdseg	<es>
	les	di,es:ThisSFT		;es:di points at allocated SFT

	retnc
	MOV	AL,error_FCB_unavailable
	ret
	
LruFCB	ENDP

;**** RegenCopyName -- This function copies the filename from the FCB to
; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
; to copy the name to different destinations
;
; Inputs: ds:si = source string
;	 es:di = destination string
;	 cx = length of string
;
; Outputs: String copied to destination
;
; Registers affected: cx,di,si
;

Procedure  RegenCopyName  NEAR
	
CopyName:
	lodsb			;load character

 IFDEF  DBCS				
	call	testkanj		
	jz	notkanj9		
	STOSB				
	DEC	CX			
	JCXZ	DoneName		; Ignore split kanji char error
	LODSB				
	jmp	short StuffChar2	
					
notkanj9:				
 ENDIF					

	call	UCase		; convert char to upper case
StuffChar2:
	STOSB			;store converted character
	LOOP	CopyName	;
DoneName:
	ret

EndProc	RegenCopyName

	
Break	<FCBRegen - regenerate a sft from the info in the FCB>
;
;----------------------------------------------------------------------------
;
;   FCBRegen - examine reserved field of FCB and attempt to generate the SFT
;	from it.
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	carry clear Filled in SFT
;		Carry set unrecoverable error
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   FCBRegen,NEAR

	; called from SFTFromFCB. SS already DOSDATA

	DOSAssume <SS>, "FCBRegen"

	; General data filling.  Mode is sf_isFCB + open_for_both, date/time 
	; we do not fill, size we do no fill, position we do not fill,
	; bit 14 of flags = TRUE, other bits = FALSE

	MOV	AL,[SI].fcb_l_drive

	; We discriminate based on the first two bits in the reserved field.

	test	AL,FCBSPECIAL		; check for no sharing test
	JZ	RegenNoSharing		; yes, go regen from no sharing

	;
	; The FCB is for a network or a sharing based system.  At this point 
	; we have already closed the SFT for this guy and reconnection is 
	; impossible.
	;
	; Remember that he may have given us a FCB with bogus information in
	; it. Check to see if sharing is present or if the redir is present.
	; If either is around, presume that we have cycled out the FCB and 
	; give the hard error. Otherwise, just return with carry set.
	;

	call	CheckShare		; test for sharer
	JNZ	RegenFail		; yep, fail this.
	MOV	AX,multNet SHL 8	; install check on multnet
	INT	2FH
	OR	AL,AL			; is it there?
	JZ	RegenDead		; no, just fail the operation
RegenFail:
	MOV     AX,User_In_AX		; SS override
	cmp	AH,fcb_close
	jz	RegenDead
	invoke	FCBHardErr		; massive hard error.
RegenDead:
	STC
	return				; carry set

	;
	; Local FCB without sharing.  Check to see if sharing is loaded.  If 
	; so fail the operation.
	;
RegenNoSharing:
	call	CheckShare		; Sharing around?
	JNZ	RegenFail
	;
	; Find an SFT for this guy.
	;
	push	ax
	mov	al,0		;indicate it is a regen operation
	invoke	LRUFcb
	pop	ax

	retc
	MOV	ES:[DI].sf_mode,SF_IsFCB + open_for_both + sharing_compat
	AND	AL,3Fh			; get drive number for flags
	CBW
	OR	AX,sf_close_noDate	; normal FCB operation

	;
	; The bits field consists of the upper two bits (dirty and device) 
	; from the SFT and the low 4 bits from the open mode.
	;

	MOV	CL,[SI].FCB_nsl_bits	; stick in dirty bits.
	MOV	CH,CL
	AND	CH,0C0h 		; mask off the dirty/device bits
	OR	AL,CH
	AND	CL,access_mask		; get the mode bits
	MOV	BYTE PTR ES:[DI].sf_mode,CL
	MOV	ES:[DI].sf_flags,AX	; initial flags
	MOV     AX,Proc_ID		; SS override
	MOV	ES:[DI].sf_PID,AX
	SAVE	<DS,SI,ES,DI>
	Context	<es>

	MOV	DI,OFFSET DOSDATA:Name1	; NAME1 is in DOSDATA

	MOV	CX,8
	INC	SI			; Skip past drive byte to name in FCB

	call	RegenCopyName	;copy the name to NAME1

	context	<ds>			; SS is DOSDATA

	MOV	[ATTRIB],attr_hidden + attr_system + attr_directory
					; Must set this to something interesting
					; to call DEVNAME.
	Invoke	DevName 		; check for device
	ASSUME	DS:NOTHING,ES:NOTHING
	RESTORE <DI,ES,SI,DS>
	JC	RegenFileNoSharing	; not found on device list => file

	;
	; Device found.  We can ignore disk-specific info
	;

	MOV	BYTE PTR ES:[DI].sf_flags,BH   ; device parms
	MOV	ES:[DI].sf_attr,0	; attribute
					; SS override
	LDS	SI,DEVPT		; get device driver
	MOV	WORD PTR ES:[DI].sf_devptr,SI
	MOV	WORD PTR ES:[DI].sf_devptr+2,DS
	ret				; carry is clear

RegenDeadJ:
	JMP	RegenDead

	;
	; File found.  Just copy in the remaining pieces.
	;

RegenFileNoSharing:
	MOV	AX,ES:[DI].sf_flags
	AND	AX,03Fh
	SAVE	<DS,SI>
	Invoke	Find_DPB
	MOV	WORD PTR ES:[DI].sf_devptr,SI
	MOV	WORD PTR ES:[DI].sf_devptr+2,DS
	RESTORE <SI,DS>
	jc	RegenDeadJ		; if find DPB fails, then drive
					; indicator was bogus
	MOV	AX,[SI].FCB_nsl_dirsec
	MOV	WORD PTR ES:[DI].sf_dirsec,AX

	; SR;
	; Update the higher word of the directory sector from the FCB
	;

; 	MOV	WORD PTR ES:[DI].sf_dirsec+2,0	;AN000;>32mb

	; SR;
	; Extract the read-only and archive bits from the top 2 bits of the sector
	; number
	;

	mov	al,[si].fcb_sfn
	and	al,0c0h		;get the 2 attribute bits
	mov	ah,al
	rol	ah,1
	shr	al,1
	or	al,ah
	and	al,03fH		;mask off unused bits
	mov	es:[di].sf_attr,al

	mov	al,[si].fcb_sfn
	and	al,03fh		;mask off top 2 bits -- attr bits
	sub	ah,ah
	mov	word ptr es:[di].sf_dirsec+2,ax ;update high word

	MOV	AX,[SI].FCB_nsl_firclus
	MOV	ES:[DI].sf_firclus,AX
	MOV	ES:[DI].sf_lstclus,AX
	MOV	AL,[SI].FCB_nsl_dirpos
	MOV	ES:[DI].sf_dirpos,AL
	INC	ES:[DI].sf_ref_count	; Increment reference count.
					; Existing FCB entries would be
					; flushed unnecessarily because of
					; check in CheckFCB of the ref_count.
					; July 22/85 - BAS
	LEA	SI,[SI].FCB_name
	LEA	DI,[DI].sf_name
	MOV	CX,fcb_extent-fcb_name

	call	RegenCopyName	;copy name to SFT 

	clc
	ret
EndProc FCBRegen



;**	BlastSFT - FIll SFT with Garbage
;
;	BlastSFT is used when an SFT is no longer needed; it's called with
;	various garbage values to put into the SFT.  I don't know why,
;	presumably to help with debugging (jgl).  We clear the few fields
;	necessary to show that the SFT is free after filling it.
;
;	ENTRY	(es:di) = address of SFT
;		(al) = fill character
;	EXIT	(ax) = -1
;		'C' clear
;	USES	AX, CX, Flags


Procedure   BlastSFT,NEAR
	INTTEST

	push	di
	mov	cx,size sf_entry
	rep	stosb
	pop	di
	sub	ax,ax			; clear 'C'-----------------;
	mov	es:[di].sf_ref_count,ax ; set ref count 	    ;
	mov	es:[di].sf_lru,ax	; set lru		    ;
	dec	ax						    ;
	mov	es:[di].sf_openage,ax	; set open age to -1	    ;
	ret				; return with 'C' clear     ;

EndProc BlastSFT

Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
;
;----------------------------------------------------------------------------
;
;   CheckFCB - examine an FCB and its contents to see if it needs to be
;   regenerated.
;
;   Inputs:	DS:SI point to FCB (not extended)
;		AL is SFT index
;   Outputs:	Carry Set - FCB needs to be regened
;		Carry clear - FCB is OK. ES:DI point to SFT
;   Registers modified: AX and BX
;
;----------------------------------------------------------------------------
;

Procedure   CheckFCB,NEAR
		
	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA

	DOSAssume <SS>, "CheckFCB"

	; SR;
	; We check if the given FCB is for a local file. If so, we return a 
	; bad SFT status forcing the caller to regenerate the SFT.

	test	[si].fcb_l_drive,FCBNETWORK OR FCBSHARE OR FCBDEVICE
	jz	BadSFT			;Local file, return bad SFT

	LES     DI,sftFCB		; SS override

	CMP	BYTE PTR ES:[DI].SFCount,AL
	JC	BadSFT
	MOV	BL,SIZE sf_entry
	MUL	BL
	LEA	DI,[DI].sftable
	ADD	DI,AX
	MOV     AX,Proc_ID		; SS override
	CMP	ES:[DI].sf_PID,AX
	JNZ	BadSFT			; must match process
	CMP	ES:[DI].sf_ref_count,0
	JZ	BadSFT			; must also be in use
	MOV	AL,[SI].FCB_l_Drive
	test	AL,FCBSPECIAL		; a special FCB?
	JZ	CheckNoShare		; No. try local or device

	; Since we are a special FCB, try NOT to use a bogus test instruction.
	; FCBSHARE is a superset of FCBNETWORK.

	PUSH	AX
	AND	AL,FCBMASK
	CMP	AL,FCBSHARE		; net FCB?
	POP	AX
	JNZ	CheckNet		; yes
;
;----- In share support -----
;
if installed
	Call    SS:JShare + 11 * 4
else
	Call	ShChk
endif
	JC	BadSFT
	JMP	SHORT CheckD
;
;----- End in share support -----
;
CheckFirClus:
	CMP	BX,ES:[DI].sf_firclus
	JNZ	BadSFT
CheckD: AND	AL,3Fh
	MOV	AH,BYTE PTR ES:[DI].sf_flags
	AND	AH,3Fh
	CMP	AH,AL
	retz				; carry is clear
BadSFT: STC
	ret				; carry is clear
CheckNet:
;
;----- In net support -----
;
	MOV	AX,WORD PTR [SI].FCB_netID	  ;AN000;IFS.DOS 4.00
	CMP	AX,WORD PTR ES:[DI].sf_serial_ID  ;AN000;IFS.DOS 4.00
	JNZ	BadSFT
;
;----- END In net support -----
;
	ret

CheckNoShare:
	test	AL,FCBDEVICE		; Device?
	JNZ	CheckNoShareDev 	; Yes

	; SR;
	; The code below to match a local FCB with its SFT can no longer be
	; used. We just return a no-match status. This check is done right
	; at the top.
	;

CheckNoShareDev:
	MOV	BX,WORD PTR [SI].FCB_nsld_drvptr
	CMP	BX,WORD PTR ES:[DI].sf_devptr
	JNZ	BadSFT
	MOV	BX,WORD PTR [SI].FCB_nsld_drvptr + 2
	CMP	BX,WORD PTR ES:[DI].sf_devptr + 2
	JNZ	BadSFT
	JMP	CheckD

EndProc CheckFCB

Break	<SFTFromFCB - take a FCB and obtain a SFT from it>

;----------------------------------------------------------------------------
;
;   SFTFromFCB - the workhorse of this compatability crap.  Check to see if
;	the SFT for the FCB is Good.  If so, make ThisSFT point to it.	If not
;	good, get one from the cache and regenerate it.  Overlay the LRU field
;	with PID
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	ThisSFT point to appropriate SFT
;		Carry clear -> OK ES:DI -> SFT
;		Carry set -> error in ax
;   Registers modified: ES,DI, AX
;
;----------------------------------------------------------------------------

Procedure   SFTFromFCB,NEAR

	; called from fcbio and $fcb_close. SS already set up to DOSDATA

	DOSAssume <SS>, "SFTFromFCB"

	SAVE	<AX,BX>
	MOV	AL,[SI].fcb_sfn 	; set SFN for check
	invoke	CheckFCB
	RESTORE <BX,AX>

	MOV     WORD PTR ThisSFT,DI     ; SS override
	MOV     WORD PTR ThisSFT+2,ES

	JNC	SetSFT			; no problems, just set thissft

	fmt	typFCB,LevCheck,<"FCB $x:$x does not match SFT $x:$x\n">,<DS,SI,ES,DI>

	Save_World			; use macro
	invoke	FCBRegen
	Restore_World			; use macro restore world

	MOV     AX,EXTERR		; SS override
	
	retc

;	Message 1,<"FCBRegen Succeeded",13,10>

SetSFT: 
	LES     DI,ThisSFT		; SS override for THISSFT & PROC_ID
	PUSH    Proc_ID                 ; set process id
	POP     ES:[DI].sf_PID
	return				; carry is clear
EndProc SFTFromFCB

Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
;
;----------------------------------------------------------------------------
;
;   FCBHardErr - signal to a user app that he is trying to use an
;	unavailable FCB.
;
;   Inputs:	none.
;   Outputs:	none.
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   FCBHardErr,NEAR

	Assume	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	MOV	AX,error_FCB_Unavailable
	MOV	ES:[ALLOWED],allowed_FAIL
	LES	BP,ES:[THISDPB]
	MOV	DI,1			; Fake some registers
	MOV	CX,DI
	MOV	DX,ES:[BP.dpb_first_sector]
	invoke	HARDERR
	STC
	return
EndProc FCBHardErr

DOSCODE ENDS
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dostab.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;	Revision History
;	================
;
;	M012	SR	08/24/90 Added Umb_Head offset to Win386_DOSVars
;				 table being passed to Win386 on
;				 startup. Needed for Win 3.1 UMB
;				 support.
;
;	M019	SR	08/30/90 Added Umb_Head & UmbFlag to the
;				 instance data structure for Win 3.1
;				 support.
;
;	M036 -	put in patch for Port Of Entry to find offset of errormode
;		flag
;
;	M044 	SR	11/1/90 Bug #3869. Added WinoldPatch2 as the save
;			        area for the last 8 bytes of 16.
;
;		Mihindu 01/08/90 Bug #4475.  Changed upcase mapping of 82h and
;				 file upcase mapping as in COUNTRY.SYS.
;
;	M062	HKN	01/22/91 Added variable UmbSave2 and UmbSaveFlag for
;				 preserving umb_head arena across win /3 
;				 session for win ver < 3.1
;
;       M074    MD      03/18/91 Bug 6298.  Correct length of Exec data block
;                                in Win 3.0 instance data table.
;
;	M075    MD      03/20/91 Revert to DOS 4.0 compatible file name
;                                mapping for y-umlaut and e-acute.
;
IFNDEF	Rainbow
Rainbow EQU FALSE
ENDIF

	.xlist
	.xcref
include dosmac.inc
	.cref
	.list


DOSDATA	Segment


;
; upper case table
;
UCASE_TAB    label   byte
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
		dw	128
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
else
		    dw	128
		    db	128,154,069,065,142,065,143,128         ;M075
		    db	069,069,069,073,073,073,142,143
		    db	144,146,146,079,153,079,085,085
		    db	089,153,154,155,156,157,158,159
		    db	065,073,079,085,165,165,166,167
		    db	168,169,170,171,172,173,174,175
		    db	176,177,178,179,180,181,182,183
		    db	184,185,186,187,188,189,190,191
		    db	192,193,194,195,196,197,198,199
		    db	200,201,202,203,204,205,206,207
		    db	208,209,210,211,212,213,214,215
		    db	216,217,218,219,220,221,222,223
		    db	224,225,226,227,228,229,230,231
		    db	232,233,234,235,236,237,238,239
		    db	240,241,242,243,244,245,246,247
		    db	248,249,250,251,252,253,254,255
; ------------------------------------------------<MSKK01>----------------------
endif

;
; file upper case table
;
FILE_UCASE_TAB	label  byte
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
		dw	128
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
else
		dw  128
		db  128,154,069,065,142,065,143,128                  ;M075
		db  069,069,069,073,073,073,142,143
		db  144,146,146,079,153,079,085,085
		db  089,153,154,155,156,157,158,159                  ;M075
		db  065,073,079,085,165,165,166,167
		db  168,169,170,171,172,173,174,175
		db  176,177,178,179,180,181,182,183
		db  184,185,186,187,188,189,190,191
		db  192,193,194,195,196,197,198,199
		db  200,201,202,203,204,205,206,207
		db  208,209,210,211,212,213,214,215
		db  216,217,218,219,220,221,222,223
		db  224,225,226,227,228,229,230,231
		db  232,233,234,235,236,237,238,239
		db  240,241,242,243,244,245,246,247
		db  248,249,250,251,252,253,254,255

endif
; ------------------------------------------------<MSKK01>----------------------

;
; file char list
;
FILE_CHAR_TAB  label  byte
		dw	22				; length
		db	1,0,255 			; include all
		db	0,0,20h 			; exclude 0 - 20h
		db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
		db	24 dup (?)			; reserved
;
; collate table
;
COLLATE_TAB    label   byte
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
		dw	256
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	129,130,131,132,133,189,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,190,191,192
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
  endif
  ifdef	  TAIWAN
		dw	256
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255

  endif
  ifdef   KOREA							;Keyl/MSCH
                dw      256
                db      0,1,2,3,4,5,6,7
                db      8,9,10,11,12,13,14,15
                db      16,17,18,19,20,21,22,23
                db      24,25,26,27,28,29,30,31
                db      " ","!",'"',"#","$","%","&","'"
                db      "(",")","*","+",",","-",".","/"
                db      "0","1","2","3","4","5","6","7"
                db      "8","9",":",";","<","=",">","?"
                db      "@","A","B","C","D","E","F","G"
                db      "H","I","J","K","L","M","N","O"
                db      "P","Q","R","S","T","U","V","W"
                db      "X","Y","Z","[","\","]","^","_"
                db      "`","A","B","C","D","E","F","G"
                db      "H","I","J","K","L","M","N","O"
                db      "P","Q","R","S","T","U","V","W"
                db      "X","Y","Z","{","|","}","~",127
                db      128,190,191,192,193,194,195,196
                db      197,198,199,200,201,202,203,204
                db      205,206,207,208,209,210,211,212
                db      213,214,215,216,217,218,219,220
                db      221,222,223,224,225,226,227,228
                db      229,230,231,232,233,234,235,236
                db      237,238,239,240,241,242,243,244
                db      245,246,247,248,249,250,251,252
                db      129,130,131,132,133,134,135,136
                db      137,138,139,140,141,142,143,144
                db      145,146,147,148,149,150,151,152
                db      153,154,155,156,157,158,159,160
                db      161,162,163,164,165,166,167,168
                db      169,170,171,172,173,174,175,176
                db      177,178,179,180,181,182,183,184
                db      185,186,187,188,189,253,254,255
  endif
else
		dw	256
	db	0,1,2,3,4,5,6,7
	db	8,9,10,11,12,13,14,15
	db	16,17,18,19,20,21,22,23
	db	24,25,26,27,28,29,30,31
	db	" ","!",'"',"#","$","%","&","'"
	db	"(",")","*","+",",","-",".","/"
	db	"0","1","2","3","4","5","6","7"
	db	"8","9",":",";","<","=",">","?"
	db	"@","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","[","\","]","^","_"
	db	"`","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","{","|","}","~",127
	db	"C","U","E","A","A","A","A","C"
	db	"E","E","E","I","I","I","A","A"
	db	"E","A","A","O","O","O","U","U"
	db	"Y","O","U","$","$","$","$","$"
	db	"A","I","O","U","N","N",166,167
	db	"?",169,170,171,172,"!",'"','"'
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,"S"
	db	226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255
endif


; ------------------------------------------------<MSKK01>----------------------

;
; dbcs is not supported in DOS 3.3
;		   DBCS_TAB	    CC_DBCS <>
;
; DBCS for DOS 4.00			   2/12/KK
   PUBLIC    DBCS_TAB
DBCS_TAB	label byte		;AN000;  2/12/KK
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
		dw	6		; <MSKK01>
		db	081h,09fh	; <MSKK01>
		db	0e0h,0fch	; <MSKK01>
		db	0,0		; <MSKK01>

		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
  endif
  ifdef	  TAIWAN
		dw	4		; <TAIWAN>
		db	081h,0FEh	; <TAIWAN>
		db	0,0		; <TAIWAN>

		db	0,0,0,0,0,0,0,0,0,0,0,0
  endif
  ifdef   KOREA                         ; Keyl
                dw      4               ; <KOREA>
                db      0A1h,0FEh       ; <KOREA>
                db      0,0             ; <KOREA>

		db	0,0,0,0,0,0,0,0,0,0,0,0
  endif
else
		dw	0		;AN000;  2/12/KK      max number
		db	16 dup(0)	;AN000;  2/12/KK

;		dw	6		;  2/12/KK
;		db	081h,09fh	;  2/12/KK
;		db	0e0h,0fch	;  2/12/KK
;		db	0,0		;  2/12/KK
;
;
endif
; ------------------------------------------------<MSKK01>----------------------

ASSUME	CS:DOSDATA,DS:NOTHING,ES:NOTHING,SS:NOTHING

;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
;     ENTRY: AL = Character to map
;     EXIT:  AL = The converted character
; Alters no registers except AL and flags.
; The routine should do nothing to chars below 80H.
;
; Example:

Procedure   MAP_CASE,FAR
	CMP	AL,80H
	JAE	Map1		;Map no chars below 80H ever
	RET
Map1:
	SUB	AL,80H		;Turn into index value
	PUSH	DS
	PUSH	BX
	MOV	BX,OFFSET DOSDATA:UCASE_TAB + 2
FINISH:

	PUSH	CS		;Move to DS
	POP	DS
	XLAT	ds:[bx] 	;Get upper case character
	POP	BX
	POP	DS
L_RET:	RET
EndProc MAP_CASE



;-----------------------------------------------------------HKN------------
;
; The following pieces of data have been moved from the DOS 4 TABLE/CODE 
; segment and added at the end of the DOS data area.
;
;---------------------------------------------------------------------------


; Moved from the TABLE segment in getset.asm

	IF	ALTVECT
VECIN:
; INPUT VECTORS
Public GSET001S,GSET001E
GSET001S  label byte
	DB	22H			; Terminate
	DB	23H			; ^C
	DB	24H			; Hard error
	DB	28H			; Spooler
LSTVEC	DB	?			; ALL OTHER

VECOUT:
; GET MAPPED VECTOR
	DB	int_terminate
	DB	int_ctrl_c
	DB	int_fatal_abort
	DB	int_spooler
LSTVEC2 DB	?			; Map to itself

NUMVEC	=	VECOUT-VECIN
GSET001E label byte
	ENDIF

;hkn; Moved from TABLE segment in ms_table.asm

;---------------------------------------Start of Korean support  2/11/KK
;
; The varialbes for ECS version are moved here for the same data alignments
; as IBM-DOS and MS-DOS.
;

        I_AM    InterChar, byte         ; Interim character flag ( 1= interim)  ;AN000;
                                                                                ;AN000;
;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! ---------------------
DUMMY   LABEL   WORD                                                            ;AN000;
        PUBLIC  InterCon                ; Console in Interim mode ( 1= interim) ;AN000;
InterCon        db      0                                                       ;AN000;
        PUBLIC  SaveCurFlg              ; Print, do not advance cursor flag     ;AN000;
SaveCurFlg      db      0                                                       ;AN000;
;-----------------------------------------End of Korean support  2/11/KK


	I_am	TEMPSEG,WORD		;hkn; used to store ds.

public	redir_patch
redir_patch	db	0

public Mark1
	Mark1 label byte


IF2
	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF

;###########################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	MSVERS	offset D12H
;	YRTAB	offset D14H
; 	MONTAB	offset D1CH
;
; WARNING! WARNING!
; 
; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK1 = 0D0DH
;
;##########################################################################

	ORG	0d12h

PUBLIC	MSVERSION
MSVERSION	LABEL BYTE	
	DB      MAJOR_VERSION
	DB      MINOR_VERSION

; YRTAB & MONTAB moved from TABLE segment in ms_table.asm

	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 


;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------

; SYS init extended table,   DOS 3.3   F.C. 5/29/86
;
	PUBLIC	SysInitTable

SysInitTable  	label  byte
	dw      OFFSET DOSDATA:SYSINITVAR	; pointer to sysinit var
        dw      0                             	; segment
        dw      OFFSET DOSDATA:COUNTRY_CDPG   	; pointer to country tabl
        dw      0                            	; segment of pointer


;
; DOS 3.3 F.C. 6/12/86
; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
;
	PUBLIC	FastOpenTable
	PUBLIC  FastTable               ; a better name
	EXTRN   FastRet:FAR             ; defined in misc2.asm

FastTable	label  byte		; a better name
FastOpenTable  	label  byte
	dw      2                       ; number of entries
	dw      OFFSET DOSCODE:FastRet	; pointer to ret instr.
	dw      0                       ; and will be modified by
	dw      OFFSET DOSCODE:FastRet  ; FASTxxx when loaded in
	dw      0                       
;
; DOS 3.3 F.C. 6/12/86
;

	PUBLIC	FastFlg                 ; flags
FastFlg         label  byte             ; don't change the foll: order
        I_am    FastOpenFlg,BYTE,<0>     
;  RMFS I_am	FastSeekFlg,BYTE,<0>	 


       PUBLIC   FastOpen_Ext_Info

; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
; and clusnum  which are filled by DOS 3.ncwhen calling FastOpen Insert
; or filled by FastOPen when calling FastOpen Lookup

FastOpen_Ext_Info  label  byte		;dirpos
	db	SIZE FASTOPEN_EXTENDED_INFO dup(0) 

; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
; when calling FastOpen Lookup

	PUBLIC  Dir_Info_Buff

Dir_Info_Buff  	label  byte
	db   	SIZE dir_entry dup (0)


	I_am	Next_Element_Start,WORD	; save next element start offset

	I_am    Del_ExtCluster,WORD     ; for dos_delete                       


; The following is a stack and its pointer for interrupt 2F which is uesd
; by NLSFUNC.  There is no significant use of this stack, we are just trying
; not to destroy the INT 21 stack saved for the user.


	PUBLIC	USER_SP_2F

USER_SP_2F      LABEL  WORD
	dw    	OFFSET DOSDATA:FAKE_STACK_2F

	PUBLIC  Packet_Temp
Packet_Temp     label  word		; temporary packet used by readtime
	PUBLIC  DOS_TEMP                ; temporary word
DOS_TEMP        label  word
FAKE_STACK_2F   dw   14 dup (0)         ; 12 register temporary storage

	PUBLIC  Hash_Temp              	; temporary word
Hash_Temp	label  word              
		dw    4 dup (0)		; temporary hash table during config.sys

	PUBLIC  SCAN_FLAG              	; flag to indicate key ALT_Q
SCAN_FLAG      	label  byte
               	db     0

	PUBLIC  DATE_FLAG
DATE_FLAG      	label  word 		; flag to
               	dw     0                ; to update the date

FETCHI_TAG	label  word		; OBSOLETE - no longer used
		dw     0		; formerly part of IBM's piracy protection


      PUBLIC    MSG_EXTERROR 		; for system message addr              
MSG_EXTERROR    label  DWORD                                                     
                dd     0                ; for extended error                   
                dd     0                ; for parser                           
               	dd     0                ; for critical errror                  
               	dd     0                ; for IFS                              
              	dd     0                ; for code reduction                   

      PUBLIC   	SEQ_SECTOR              ; last sector read                     
SEQ_SECTOR     	label  DWORD                                                     
               	dd     -1                                                        

;;      I_am    ACT_PAGE,WORD,<-1>      ; active EMS page                       
	I_am    SC_SECTOR_SIZE,WORD     ; sector size for SC                 
        I_am    SC_DRIVE,BYTE           ; drive # for secondary cache        
        I_am    CurSC_DRIVE,BYTE,<-1>   ; current SC drive                   
        I_am    CurSC_SECTOR,DWORD      ; current SC starting sector         
        I_am    SC_STATUS,WORD,<0>      ; SC status word                     
        I_am    SC_FLAG,BYTE,<0>        ; SC flag                            
        I_am    AbsDskErr,WORD,<0>	; Storage for Abs dsk read/write err

	PUBLIC 	NO_NAME_ID                                                           
NO_NAME_ID      label byte                                                           
                db   'NO NAME    '	; null media id                      

;hkn; moved from TABLE segment in kstrin.asm

Public	KISTR001S,KISTR001E,LOOKSIZ	; 2/17/KK
KISTR001S	label	byte		; 2/17/KK
LOOKSIZ DB	0			; 0 if byte, NZ if word	2/17/KK
KISTR001E	label	byte		; 2/17/KK



; the nul device driver used to be part of the code.  However, since the 
; header is in the data, and the entry points are only given as an offset,
; the strategy and interrupt entry points must also be in the data now.
;

procedure   snuldev,far
assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
 	or	es:[bx.reqstat],stdon	; set done bit
entry inuldev
	ret				; must not be a return!
endproc snuldev

;M044
; Second part of save area for saving last para of Windows memory
;
public WinoldPatch2
WinoldPatch2	db	8 dup (?)	; M044

public	UmbSave2, UmbSaveFlag		; M062
UmbSave2	db	5 dup (?)	; M062
UmbSaveFlag	db	0		; M062

public Mark2
	Mark2	label byte

IF2
	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF


;###########################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	ERR_TABLE_21	offset DDBH
;	ERR_TABLE_24	offset E5BH
; 	ErrMap24	offset EABH
;
; WARNING! WARNING!
;
; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK2 = 0DD0H
;
;##########################################################################



	ORG	0ddbh
;**
;
; The following table defines CLASS ACTION and LOCUS info for the INT 21H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
;

ErrTab  Macro   err,class,action,locus
ifidn <locus>,<0FFh>
    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
ELSE
    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
ENDIF
ENDM

PUBLIC  ERR_TABLE_21
ERR_TABLE_21    LABEL   BYTE
    ErrTab  invalid_function,       Apperr,     Abort,      0FFh
    ErrTab  file_not_found,         NotFnd,     User,       Disk
    ErrTab  path_not_found,         NotFnd,     User,       Disk
    ErrTab  too_many_open_files,    OutRes,     Abort,      Unk
    ErrTab  access_denied,          Auth,       User,       0FFh
    ErrTab  invalid_handle,         Apperr,     Abort,      Unk
    ErrTab  arena_trashed,          Apperr,     Panic,      Mem
    ErrTab  not_enough_memory,      OutRes,     Abort,      Mem
    ErrTab  invalid_block,          Apperr,     Abort,      Mem
    ErrTab  bad_environment,        Apperr,     Abort,      Mem
    ErrTab  bad_format,             BadFmt,     User,       Unk
    ErrTab  invalid_access,         Apperr,     Abort,      Unk
    ErrTab  invalid_data,           BadFmt,     Abort,      Unk
    ErrTab  invalid_drive,          NotFnd,     User,       Disk
    ErrTab  current_directory,      Auth,       User,       Disk
    ErrTab  not_same_device,        Unk,        User,       Disk
    ErrTab  no_more_files,          NotFnd,     User,       Disk
    ErrTab  file_exists,            Already,    User,       Disk
    ErrTab  sharing_violation,      Locked,     DlyRet,     Disk
    ErrTab  lock_violation,         Locked,     DlyRet,     Disk
    ErrTab  out_of_structures,      OutRes,     Abort,      0FFh
    ErrTab  invalid_password,       Auth,       User,       Unk
    ErrTab  cannot_make,            OutRes,     Abort,      Disk
    ErrTab  Not_supported,          BadFmt,     User,       Net
    ErrTab  Already_assigned,       Already,    User,       Net
    ErrTab  Invalid_Parameter,      BadFmt,     User,       Unk
    ErrTab  FAIL_I24,               Unk,        Abort,      Unk
    ErrTab  Sharing_buffer_exceeded,OutRes,     Abort,      Mem
    ErrTab  Handle_EOF,             OutRes,     Abort,      Unk     ;AN000;
    ErrTab  Handle_DISK_FULL,       OutRes,     Abort,      Unk     ;AN000;
    ErrTab  sys_comp_not_loaded,    Unk,        Abort,      Disk    ;AN001;
    DB      0FFh,                   0FFH,       0FFH,       0FFh

;
; The following table defines CLASS ACTION and LOCUS info for the INT 24H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A Locus value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END.

PUBLIC  ERR_TABLE_24
ERR_TABLE_24    LABEL   BYTE
    ErrTab  write_protect,          Media,      IntRet,     Disk
    ErrTab  bad_unit,               Intrn,      Panic,      Unk
    ErrTab  not_ready,              HrdFail,    IntRet,     0FFh
    ErrTab  bad_command,            Intrn,      Panic,      Unk
    ErrTab  CRC,                    Media,      Abort,      Disk
    ErrTab  bad_length,             Intrn,      Panic,      Unk
    ErrTab  Seek,                   HrdFail,    Retry,      Disk
    ErrTab  not_DOS_disk,           Media,      IntRet,     Disk
    ErrTab  sector_not_found,       Media,      Abort,      Disk
    ErrTab  out_of_paper,           TempSit,    IntRet,     SerDev
    ErrTab  write_fault,            HrdFail,    Abort,      0FFh
    ErrTab  read_fault,             HrdFail,    Abort,      0FFh
    ErrTab  gen_failure,            Unk,        Abort,      0FFh
    ErrTab  sharing_violation,      Locked,     DlyRet,     Disk
    ErrTab  lock_violation,         Locked,     DlyRet,     Disk
    ErrTab  wrong_disk,             Media,      IntRet,     Disk
    ErrTab  not_supported,          BadFmt,     User,       Net
    ErrTab  FCB_unavailable,        Apperr,     Abort,      Unk
    ErrTab  Sharing_buffer_exceeded,OutRes,     Abort,      Mem
    DB      0FFh,                   errCLASS_Unk, errACT_Panic, 0FFh

;
; We need to map old int 24 errors and device driver errors into the new set
; of errors.  The following table is indexed by the new errors
;
Public  ErrMap24
ErrMap24    Label   BYTE
    DB  error_write_protect             ;   0
    DB  error_bad_unit                  ;   1
    DB  error_not_ready                 ;   2
    DB  error_bad_command               ;   3
    DB  error_CRC                       ;   4
    DB  error_bad_length                ;   5
    DB  error_Seek                      ;   6
    DB  error_not_DOS_disk              ;   7
    DB  error_sector_not_found          ;   8
    DB  error_out_of_paper              ;   9
    DB  error_write_fault               ;   A
    DB  error_read_fault                ;   B
    DB  error_gen_failure               ;   C
    DB  error_gen_failure               ;   D   RESERVED
    DB  error_gen_failure               ;   E   RESERVED
    DB  error_wrong_disk                ;   F

Public  ErrMap24End
ErrMap24End LABEL   BYTE



        I_am	FIRST_BUFF_ADDR,WORD            ; first buffer address               
        I_am    SPECIAL_VERSION,WORD,<0>        ;AN006; used by INT 2F 47H
        I_am    FAKE_COUNT,<255>                ;AN008; fake version count

        I_am    OLD_FIRSTCLUS,WORD              ;AN011; save old first cluster for fastopen

;----------------------------------------------------------------------------



;smr; moved from TABLE segment in exec.asm

	I_am	exec_init_SP,WORD
	I_am	exec_init_SS,WORD
	I_am	exec_init_IP,WORD
	I_am	exec_init_CS,WORD

	I_am	exec_signature,WORD	; must contain 4D5A  (yay zibo!)
	I_am	exec_len_mod_512,WORD	; low 9 bits of length
	I_am	exec_pages,WORD		; number of 512b pages in file
	I_am	exec_rle_count,WORD	; count of reloc entries
	I_am	exec_par_dir,WORD	; number of paragraphs before image
	I_am	exec_min_BSS,WORD	; minimum number of para of BSS
	I_am	exec_max_BSS,WORD	; max number of para of BSS
	I_am	exec_SS,WORD		; stack of image
	I_am	exec_SP,WORD		; SP of image
	I_am	exec_chksum,WORD	; checksum  of file (ignored)
	I_am	exec_IP,WORD		; IP of entry
	I_am	exec_CS,WORD		; CS of entry
	I_am	exec_rle_table,WORD	; byte offset of reloc table

	public	Exec_header_len
Exec_header_len	EQU $-Exec_Signature					;PBUGBUG

;smr; eom


;SR;
; WIN386 instance table for DOS
;
public	Win386_Info
Win386_Info	db	3, 0
		dd	0, 0, 0
		dw	offset dosdata:Instance_Table, 0


public	Instance_Table
Instance_Table	dw	offset dosdata:contpos, 0, 2
		dw	offset dosdata:bcon, 0, 4
		dw	offset dosdata:carpos, 0, 106h
		dw	offset dosdata:charco, 0, 1
		dw	offset dosdata:exec_init_sp, 0, 34      ; M074
		dw	offset dosdata:umbflag,0,1		; M019
		dw	offset dosdata:umb_head,0,2		; M019
		dw	0, 0

; M001; SR;
; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
; M001; some DOS variables. Note that the only really important variable in 
; M001; this is User_Id. The other variables are needed only to patch stuff 
; M001; which does not need to be done in DOS 5.0. 
; M001; 
public	Win386_DOSVars
Win386_DOSVars	db	5		;Major version 5 ; M001
		db	0		;Minor version 0 ; M001
		dw	offset dosdata:SaveDS	; M001
		dw	offset dosdata:SaveBX	; M001
		dw	offset dosdata:Indos	; M001
		dw	offset dosdata:User_id	; M001
		dw	offset dosdata:CritPatch ; M001
		dw	offset dosdata:UMB_Head	; M012

;SR;
; Flag to indicate whether WIN386 is running or not
;
public	IsWin386
IsWin386		db	0

;M018
; This variable contains the path to the VxD device needed for Win386
;
public 	VxDpath					;M018
VxDpath		db	'c:\wina20.386',0		;M018

;
;End WIN386 support
;

;SR;
; These variables have been added for the special lie support for device
;drivers.
;
	public	DriverLoad
	public	BiosDataPtr
DriverLoad	db	1	;initialized to do special handling
BiosDataPtr	dd	?


;------------------------------------------------------------------------
; Patch for Sidekick
;
; A documented method for finding the offset of the Errormode flag in the 
; dos swappable data area if for the app to scan in the dos segment (data) 
; for the following sequence of instructions.
;
; Ref: Part C, Artice 11, pg 356 of MSDOS Encyclopedia
;
; The Offset of Errormode flag is 0320h
;
;------------------------------------------------------------------------


	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
	db	075h, 0ch			 ; jnz  NearLabel
	db	036h, 0ffh, 036h, 058h, 03h	 ; push ss:[NearWord]
	db	0cdh, 028h			 ; int  28h

;--------------------------------------------------------------------------
; Patch for PortOfEntry - M036
;
; PortOfEntry by Sector Technology uses an un documented way of determining
; the offset of Errormode flag. The following patch is to support them in 
; DOS 5.0. The corresponding code is actually in msdisp.asm
;
;---------------------------------------------------------------------------

	db 	080h, 03eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
	db	075h, 037h			 ; jnz	NearLabel
	db 	0bch, 0a0h, 0ah		  	 ; mov	sp, dosdata:iostack

;
;*** New FCB Implementation
; This variable is used as a cache in the new FCB implementation to remember
;the address of a local SFT that can be recycled for a regenerate operation
;

public	LocalSFT
LocalSFT		dd	0	;0 to indicate invalid pointer

DOSDATA	ENDS




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dup.asm ===
TITLE	DOS_DUP - Internal SFT DUP (for network SFTs)
	NAME	DOS_DUP

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level DUP routine for use by EXEC when creating a new process. Exports
;	  the DUP to the server machine and increments the SFT ref count
;
;	DOS_DUP
;
;	Modification history:
;
;	  Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	.cref
	.list

	i_need	THISSFT,DWORD


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg

BREAK <DOS_DUP -- DUP SFT across network>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_DUP
;
; Inputs:
;	[THISSFT] set to the SFT for the file being DUPed
;		(a non net SFT is OK, in this case the ref
;		 count is simply incremented)
; Function:
;	Signal to the devices that alogical open is occurring
; Returns:
;	ES:DI point to SFT
;    Carry clear
;	SFT ref_count is incremented
; Registers modified: None.
; NOTE:
;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
;	time with SS NOT DOSGROUP. There will be no Network handles at
;	that time.

procedure   DOS_DUP,NEAR

	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata
	LES	DI,ThisSFT
	assume	es:nothing	

	Entry	Dos_Dup_Direct
	Assert	ISSFT,<ES,DI>,"DOSDup"
	invoke	IsSFTNet
	JNZ	DO_INC
	invoke	DEV_OPEN_SFT
DO_INC:
	Assert	ISSFT,<ES,DI>,"DOSDup/DoInc"
	INC	ES:[DI.sf_ref_count]	; Clears carry (if this ever wraps
					;   we're in big trouble anyway)
	return

EndProc DOS_DUP

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\file.asm ===
TITLE	FILE - Pathname related system calls
	NAME	FILE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FILE.ASM - Pathname Related System Calls
;
;	These will be passed direct text of the
;	pathname from the user.  They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff.  I/O specs are
;	defined in DISPATCH.	The system calls are:
;
;	$Open	      written
;	$Creat	      written
;	$ChMod	      written
;	$Unlink	      written
;	$Rename	      written
;	$CreateTempFile   written
;	$CreateNewFile	  written
;	$Extended_Open	  written  DOS 4.00
;	GetIOParms	      written  DOS 4.00
;
;	Revision history:
;
;	    Created: MZ 4 April 1983
;	    A000   version 4.00  Jan. 1988
;	    A001   DOS 4.0, PTM #6069, BL, ROMDOS fix
;           M022   conditional removed 
;	    M049   If access_denied is obtained whle trying to create a temp
;		   file, check to see if this was due to the network drive
; 		   being read only.
;
;	M069	Bug #5913. CreateTempFile now checks for error_net_access_
;		denied instead of error_cannot_make because ExtErr is set
;		to the first errorcode when we try to create a file on a
;		read-only share.
;
;	M070	Bug #5943. CreateTempFile now has a check for
;		error_failed_I24 which is set if the user fails on an I24
;		that is got on a write-protected disk. Previously, the
;		code would go ahead and try another name and then hang
;		because DOS is in an inconsistent state.
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include sf.inc
	include filemode.inc
	include bugtyp.inc
	.cref
	.list

	I_need	WFP_Start,WORD		; pointer to beginning of expansion
	I_Need	ThisCDS,DWORD		; pointer to curdir in use
	I_need	ThisSft,DWORD		; SFT pointer for DOS_Open
	I_need	pJFN,DWORD		; temporary spot for pointer to JFN
	I_need	JFN,WORD		; word JFN for process
	I_need	SFN,WORD		; word SFN for process
	I_Need	OpenBuf,128		; buffer for filename
	I_Need	RenBuf,128		; buffer for filename in rename
	I_need	Sattrib,BYTE		; byte attribute to search for
	I_need	Ren_WFP,WORD		; pointer to real path
	I_need	cMeta,BYTE
	I_need	EXTERR,WORD		; extended error code
	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	i_need	JShare,DWORD		; share jump table
	I_need	fSharing,BYTE		; TRUE => via ServerDOSCall
	I_need	FastOpenTable,BYTE
	I_need	CPSWFLAG,BYTE		;AN000;FT. cpsw falg
	I_need	EXTOPEN_FLAG,WORD	;AN000;FT. extended file open flag
	I_need	EXTOPEN_ON,BYTE 	;AN000;FT. extended open flag
	I_need	EXTOPEN_IO_MODE,WORD	;AN000;FT. IO mode
	I_need	SAVE_ES,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_DI,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_DS,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_SI,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_DX,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_BX,WORD		;AN000;;FT. for get/set XA
	I_need	SAVE_CX,WORD		;AN000;;FT. for get/set XA
	I_need	Temp_Var,WORD		;AN000;;
	I_need	DOS34_FLAG,WORD 	;AN000;;
	I_need	Temp_Var2,WORD		;AN000;;

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE
	EXTRN	DOS_OPEN:NEAR,DOS_CREATE:NEAR,DOS_Create_New:NEAR

	EXTRN	SFNFree:near
        extrn	Set_EXT_mode:near               ;M022 conditional removed

	BREAK <$Open - open a file from a path string>


;**	$OPen - Open a File
;
;	given a path name in DS:DX and an open mode in AL, $Open opens the
;	file and and returns a handle
;
;	ENTRY	(DS:DX) = pointer to asciz name
;		(AL) = open mode
;	EXIT	'C' clear if OK
;		  (ax) = file handle
;		'C' set iff error
;		  (ax) = error code
;	USES	all

Procedure   $Open,NEAR
	DOSAssume   <SS>,"Open"

	fmt TypSysCall,LevArgs,<" Mode = $x file = '$S'\n">,<AX,DS,DX>
	XOR	AH,AH
Entry $Open2				;AN000;
	mov	ch,attr_hidden+attr_system+attr_directory
	call	SetAttrib
	MOV	CX,OFFSET DOSCODE:DOS_Open ; address of routine to call
	SAVE	<AX>			; Save mode on stack
IFDEF DBCS 				;AN000;
	MOV	Temp_Var,0		;AN000;KK. set variable with 0;smr;SS Override
ENDIF					;AN000;


;*	General file open/create code.	The $CREATE call and the various
;	$OPEN calls all come here.
;
;	We'll share a lot of the standard stuff of allocating SFTs, cracking
;	path names, etc., and then dispatch to our individual handlers.
;	WARNING - this info and list is just a guess, not definitive - jgl
;
;	(TOS) = create mode
;	(CX) = address of routine to call to do actual function
;	(DS:DX) = ASCIZ name
;	SAttrib = Attribute mask

;	Get a free SFT and mark it "being allocated"

AccessFile:
IFDEF  DBCS				;AN000;
	TEST	Temp_Var,ATTR_VOLUME_ID	; volume id bit set?
	JZ	novol
	OR	[DOS34_FLAG],DBCS_VOLID ; warn transpath about VOLID
novol:
ENDIF
	EnterCrit   critSFT
	call	SFNFree 		; get a free sfn
	LeaveCrit   critSFT
	JC	OpenFailJ		; oops, no free sft's
	MOV	SFN,BX			; save the SFN for later;smr;SS Override
	fmt	TypAccess,LevSFN,<"AccessFile setting SFN to $x\n">,<BX>
	MOV	WORD PTR ThisSFT,DI	; save the SF offset	;smr;SS Override
	MOV	WORD PTR ThisSFT+2,ES	; save the SF segment	;smr;SS Override

;	Find a free area in the user's JFN table.

	invoke	JFNFree 		; get a free jfn
	JNC	SaveJFN
OpenFailJ:
	JMP	OpenFail		; there were free JFNs... try SFN

SaveJFN:MOV	WORD PTR pJFN,DI	; save the jfn offset	;smr;SS Override
	MOV	WORD PTR pJFN+2,ES	; save the jfn segment	;smr;SS Override
	MOV	JFN,BX			; save the jfn itself	;smr;SS Override

;	We have been given an JFN.  We lock it down to prevent other tasks from
;	reusing the same JFN.

	MOV	BX,SFN						;smr;SS Override
	MOV	ES:[DI],BL		; assign the JFN
	MOV	SI,DX			; get name in appropriate place
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
	SAVE	<CX>			; save routine to call
	invoke	TransPath		; convert the path
	RESTORE <BX>			; (bx) = routine to call
	LDS	SI,ThisSFT					;smr;SS Override
    ASSUME DS:NOTHING
	JC	OpenCleanJ		; no error, go and open file
	CMP	cMeta,-1					;smr;SS Override
	JZ	SetSearch
	MOV	AL,error_file_not_found ; no meta chars allowed
OpenCleanJ:
	JMP	short OpenClean

SetSearch:
	RESTORE <AX>		; Mode (Open), Attributes (Create)

;	We need to get the new inheritance bits.

	xor	cx,cx
	MOV	[SI].sf_mode,cx		; initialize mode field to 0
	MOV	[SI].SF_mft,cx		; clean out sharing info
	CMP	BX,OFFSET DOSCODE:DOS_OPEN
	JNZ	DoOper
	TEST	AL,sharing_no_inherit	; look for no inher
	JZ	DoOper
	AND	AL,07Fh 		; mask off inherit bit
	MOV	CX,sf_no_inherit
DoOper:

;**	Check if this is an extended open. If so you must set the
;	modes in sf_mode. Call Set_EXT_mode to do all this. See
;	Set_EXT_mode in creat.asm

	SAVE	<di, es>                ;M022 conditional removed here
	push	ds
	pop	es
	push	si
	pop	di		; (es:di) = SFT address
	call	Set_EXT_mode
	RESTORE <es, di>

	Context DS
	SAVE	<CX>
	CALL	BX			; blam!
	RESTORE <CX>
	LDS	SI,ThisSFT
	ASSUME	DS:NOTHING
	JC	OpenE2			;AN000;FT. chek extended open hooks first

;	The SFT was successfully opened.  Remove busy mark.

OpenOK:
	ASSUME	DS:NOTHING
	MOV	[SI].sf_ref_count,1
	OR	[SI].sf_flags,CX	; set no inherit bit if necessary

; If the open mode is 70, we scan the system for other SFT's with the same
; contents.  If we find one, then we can 'collapse' thissft onto the already
; opened one.  Otherwise we use this new one.  We compare uid/pid/mode/mft
;
; Since this is only relevant on sharer systems, we stick this code into the
; sharer.

	MOV	AX,JFN						;smr;SS Override
if installed
	Call	JShare + 12 * 4					;smr;SS Override
else
	Call	ShCol						;PBUGBUG
endif
	fmt	TypAccess,LevSFN,<"AccessFile setting SFN to -1\n">
	MOV	SFN,-1			; clear out sfn pointer	;smr;SS Override
	transfer    Sys_Ret_OK		; bye with no errors
;Extended Open hooks check
OpenE2: 				   ;AN000;;EO.
	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
	JNZ	OpenE			   ;AN000;;EO. no.
	JMP	short OpenCritLeave		   ;AN000;;EO. keep handle

;	Extended Open hooks check
;
;	AL has error code.  Stack has argument to dos_open/dos_create.

OpenClean:
	fmt TypSysCall,LevErr,<"Return value from transpath $x\n">,<AX>
	RESTORE <bx>		; clean off stack
OpenE:
	MOV	[SI.SF_Ref_Count],0	; release SFT
	LDS	SI,pJFN						;smr;SS Override
	MOV	BYTE PTR [SI],0FFh	; free the SFN...
	JMP	SHORT OpenCritLeave

OpenFail:
	STI
	RESTORE <CX>		; Clean stack
OpenCritLeave:
	MOV	SFN,-1			; remove mark.
	fmt TypSysCall,LevErr,<"Open/CreateXX: error $x\n">,<AX>
;; File Tagging DOS 4.00
	CMP	[EXTERR],error_Code_Page_Mismatched	;AN000;;FT. code page mismatch;smr;SS Override
	JNZ	NORERR					;AN000;;FT. no
	transfer From_GetSet				;AN000;;FT. yes
NORERR: 						;AN000;

;; File Tagging DOS 4.00
	transfer    Sys_Ret_Err 	; no free, return error

EndProc $Open, NoCheck


	BREAK <$Creat - create a brand-new file>


;**	$Creat - Create a File
;
;	$Creat creates the directory entry specified in DS:DX and gives it the
;	initial attributes contained in CX
;
;	ENTRY	(DS:DX) = ASCIZ path name
;		(CX) = initial attributes
;	EXIT	'C' set if error
;		  (ax) = error code
;		'C' clear if OK
;		  (ax) = file handle
;	USES	all

Procedure   $Creat,NEAR
	DOSAssume   <SS>,"Creat"

	fmt TypSysCall,LevArgs,<"file = '$S'\n">,<DS,DX>
IFDEF DBCS 				;AN000;
	MOV	Temp_Var,CX		;AN000;KK. set variable with attribute	      ;AN000;smr;SS Override
ENDIF					;AN000;
	SAVE	<CX>			; Save attributes on stack
	MOV	CX,OFFSET DOSCODE:DOS_Create; routine to call
AccessSet:
	mov	SAttrib,attr_hidden+attr_system			;smr;SS Override
	JMP	AccessFile		; use good ol' open

EndProc $Creat, NoCheck


	BREAK <$CHMOD - change file attributes>

;**	$CHMOD - Change File Attributes
;
;   Assembler usage:
;	    LDS     DX, name
;	    MOV     CX, attributes
;	    MOV     AL,func (0=get, 1=set)
;	    INT     21h
;   Error returns:
;	    AX = error_path_not_found
;	    AX = error_access_denied
;

procedure $CHMOD,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
	SAVE	<AX,CX> 		; save function and attributes
	MOV	SI,DX			; get things in appropriate places
	invoke	TransPathSet		; get correct path
	RESTORE <CX,AX>		; and get function and attrs back
	JC	ChModErr		; errors get mapped to path not found
	Context DS			; set up for later possible calls
	CMP	cMeta,-1
	JNZ	ChModErr
	MOV	[SAttrib],attr_hidden+attr_system+attr_directory
	SUB	AL,1			; fast way to discriminate
	JB	ChModGet		; 0 -> go get value
	JZ	ChModSet		; 1 -> go set value
	MOV	EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus
	error	error_invalid_function	; bad value
ChModGet:
	invoke	Get_File_Info		; suck out the ol' info
	JC	ChModE			; error codes are already set for ret
	invoke	Get_User_stack		; point to user saved vaiables
	assume	DS:NOTHING		;smr;PBUGBUG
	MOV	[SI.User_CX],AX 	; return the attributes
	transfer    Sys_Ret_OK		; say sayonara
ChModSet:
	MOV	AX,CX			; get attrs in position
	invoke	Set_File_Attribute	; go set
	JC	ChModE			; errors are set
	transfer    Sys_Ret_OK
ChModErr:
	mov	al,error_path_not_found
ChmodE:
	Transfer    SYS_RET_ERR
EndProc $ChMod

	BREAK <$UNLINK - delete a file entry>

;**	$UNLINK - Delete a File
;
;
;	Assembler usage:
;	    LDS     DX, name
;	    IF VIA SERVER DOS CALL
;	     MOV     CX,SEARCH_ATTRIB
;	    MOV     AH, Unlink
;	    INT     21h
;
;	ENTRY	(ds:dx) = path name
;		(cx) = search_attribute, if via server_dos
;	EXIT	'C' clear if no error
;		'C' set if error
;		  (ax) = error code
;			= error_file_not_found
;			= error_access_denied

procedure $UNLINK,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	SAVE	<CX>			; Save possible CX input parm
	MOV	SI,DX			; Point at input string
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; temp spot for path
	invoke	TransPathSet		; go get normalized path
	RESTORE <CX>
	JC	ChModErr		; badly formed path
	CMP	cMeta,-1		; meta chars?		;smr;SS Override
	JNZ	NotFound
	Context DS
	mov	ch,attr_hidden+attr_system   ; unlink appropriate files
	call	SetAttrib
	invoke	DOS_Delete		; remove that file
	JC	UnlinkE 		; error is there
	transfer    Sys_Ret_OK		; okey doksy
NotFound:
	MOV	AL,error_path_not_found
UnlinkE:
	transfer    Sys_Ret_Err 	; bye

EndProc $UnLink

BREAK <$RENAME - move directory entries around>
;
;   Assembler usage:
;	    LDS     DX, source
;	    LES     DI, dest
;	    IF VIA SERVER DOS CALL
;	     MOV     CX,SEARCH_ATTRIB
;	    MOV     AH, Rename
;	    INT     21h
;
;   Error returns:
;	    AX = error_file_not_found
;	       = error_not_same_device
;	       = error_access_denied

procedure $RENAME,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<CX,DS,DX>		; save source and possible CX arg
	PUSH	ES
	POP	DS			; move dest to source
	MOV	SI,DI			; save for offsets
	MOV	DI,OFFSET DOSDATA:RenBuf


	invoke	TransPathSet		; munge the paths
	PUSH	WFP_Start		; get pointer		;smr;SS Override
	POP	Ren_WFP 		; stash it		;smr;SS Override
	RESTORE <SI,DS,CX>		; get back source and possible CX arg
epjc2:	JC	ChModErr		; get old error
	CMP	cMeta,-1					;smr;SS Override
	JNZ	NotFound
	SAVE	<CX>			; Save possible CX arg
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
	invoke	TransPathSet		; wham
	RESTORE <CX>
	JC	EPJC2
	Context DS
	CMP	cMeta,-1
	JB	NotFound

	PUSH	WORD PTR [THISCDS]	   ;AN000;;MS.save thiscds
	PUSH	WORD PTR [THISCDS+2]	   ;AN000;;MS.
	MOV	DI,OFFSET DOSDATA:OpenBuf ;AN000;;MS.
	PUSH	SS			   ;AN000;;MS.
	POP	ES			   ;AN000;;MS.es:di-> source
	XOR	AL,AL			   ;AN000;;MS.scan all CDS
rnloop: 				   ;AN000;
	invoke	GetCDSFromDrv		   ;AN000;;MS.
	JC	dorn			   ;AN000;;MS.	end of CDS
	invoke	StrCmp			   ;AN000;;MS.	current dir ?
	JZ	rnerr			   ;AN000;;MS.	yes
	INC	AL			   ;AN000;;MS.	next
	JMP	rnloop			   ;AN000;;MS.
rnerr:					   ;AN000;
	ADD	SP,4			   ;AN000;;MS. pop thiscds
	error	error_current_directory    ;AN000;;MS.
dorn:					   ;AN000;
	POP	WORD PTR SS:[THISCDS+2]    ;AN000;;MS.;PBUGBUG;SS REQD??
	POP	WORD PTR SS:[THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
	Context DS
	mov	ch,attr_directory+attr_hidden+attr_system; rename appropriate files
	call	SetAttrib
	invoke	DOS_Rename		; do the deed
	JC	UnlinkE 		; errors


	transfer    Sys_Ret_OK
EndProc $Rename

Break <$CreateNewFile - Create a new directory entry>

;
;   CreateNew - Create a new directory entry.  Return a file handle if there
;	was no previous directory entry, and fail if a directory entry with
;	the same name existed previously.
;
;   Inputs:	DS:DX point to an ASCIZ file name
;		CX contains default file attributes
;   Outputs:	Carry Clear:
;		    AX has file handle opened for read/write
;		Carry Set:
;		    AX has error code
;   Registers modified: All

Procedure $CreateNewFile,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	fmt TypSysCall,LevArgs,<" Att = $x file = '$S'\n">,<CX,DS,DX>
IFDEF DBCS 				;AN000;
	MOV	Temp_Var,CX		;AN000;KK. set variable with attribute;smr;SS Override
ENDIF					;AN000;
	SAVE	<CX>			; Save attributes on stack
	MOV	CX,OFFSET DOSCODE:DOS_Create_New   ; routine to call
	JMP	AccessSet		; use good ol' open

EndProc $CreateNewFile, NoCheck

	Break	<BinToAscii - convert a number to a string>

;**	BinToAscii - conver a number to a string.
;
;	BinToAscii converts a 16 bit number into a 4 ascii characters.
;	This routine is used to generate temp file names so we don't spend
;	the time and code needed for a true hex number, we just use
;	A thorugh O.
;
;	ENTRY	(ax) = value
;		(es:di) = destination
;	EXIT	(es:di) updated by 4
;	USES	cx, di, flags

Procedure   BinToAscii,NEAR
	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
bta5:	ROL	AX,CL			; move leftmost nibble into rightmost
	SAVE	<AX>			; preserve remainder of digits
	AND	AL,0Fh			; grab low nibble
	ADD	AL,'A'			; turn into ascii
	STOSB				; drop in the character
	RESTORE <AX>			; (ax) = shifted number
	dec	ch
	jnz	bta5			; process 4 digits
	return

EndProc BinToAscii

Break	<$CreateTempFile - create a unique name>

;
;   $CreateTemp - given a directory, create a unique name in that directory.
;	Method used is to get the current time, convert to a name and attempt
;	a create new.  Repeat until create new succeeds.
;
;   Inputs:	DS:DX point to a null terminated directory name.
;		CX  contains default attributes
;   Outputs:	Unique name is appended to DS:DX directory.
;		AX has handle
;   Registers modified: all

Procedure $CreateTempFile,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	fmt TypSysCall,LevArgs,<" Att = $x dir = '$S'\n">,<CX,DS,DX>
PUBLIC FILE001S,FILE001E
FILE001S:
	LocalVar    EndPtr,DWORD
	LocalVar    FilPtr,DWORD
	LocalVar    Attr,WORD
FILE001E:
	Enter
	TEST	CX,NOT attr_changeable
	JZ	OKatts			; Ok if no non-changeable bits set
;
; We need this "hook" here to detect these cases (like user sets one both of
; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
; below.  The code loops on error_access_denied, but if one of the non
; changeable attributes is specified, the loop COULD be infinite or WILL be
; infinite because CreateNewFile will fail with access_denied always.  Thus we
; need to detect these cases before getting to the loop.
;
	MOV	AX,error_access_denied
	JMP	SHORT SETTMPERR

OKatts:
	MOV	attr,CX 		; save attribute
	MOV	FilPtrL,DX		; pointer to file
	MOV	FilPtrH,DS
	MOV	EndPtrH,DS		; seg pointer to end of dir
	PUSH	DS
	POP	ES			; destination for nul search
	MOV	DI,DX
	MOV	CX,DI
	NEG	CX			; number of bytes remaining in segment
 IFDEF  DBCS				;AN000;
Kloop:					;AN000;; 2/13/KK
	MOV	AL, BYTE PTR ES:[DI]	;AN000;; 2/13/KK
	INC	DI			;AN000;; 2/13/KK
	OR	AL,AL			;AN000;; 2/13/KK
	JZ	GOTEND			;AN000;; 2/13/KK
	invoke	testkanj		;AN000;; 2/13/KK
	jz	Kloop			;AN000;; 2/13/KK
	inc	di			;AN000;; Skip over second kanji byte 2/13/KK
	CMP	BYTE PTR ES:[DI],0	;AN000;; 2/13/KK
	JZ	STOREPTH		;AN000; When char before NUL is sec Kanji byte
					;AN000; do not look for path char. 2/13/KK
	jmp	Kloop			;AN000; 2/13/KK
GOTEND: 				;AN000; 2/13/KK
 ELSE					;AN000;
	OR	CX,CX			;AN000;MS.  cx=0 ? ds:dx on segment boundary
	JNZ	okok			;AN000;MS.  no
	MOV	CX,-1			;AN000;MS.
okok:					;AN000;
	XOR	AX,AX			;AN000;
	REPNZ	SCASB			;AN000;
 ENDIF					;AN000;
	DEC	DI			; point back to the null
	MOV	AL,ES:[DI-1]		; Get char before the NUL
	invoke	PathChrCmp		; Is it a path separator?
	JZ	SETENDPTR		; Yes
STOREPTH:
	MOV	AL,'\'
	STOSB				; Add a path separator (and INC DI)
SETENDPTR:
	MOV	EndPtrL,DI		; pointer to the tail
CreateLoop:
	Context DS			; let ReadTime see variables
	SAVE	<BP>
	invoke	ReadTime		; go get time
	RESTORE <BP>
;
; Time is in CX:DX.  Go drop it into the string.
;
	les	di,EndPtr		; point to the string
	mov	ax,cx
	call	BinToAscii		; store upper word
	mov	ax,dx
	call	BinToAscii		; store lower word
	xor	al,al
	STOSB				; nul terminate
	LDS	DX,FilPtr		; get name
ASSUME	DS:NOTHING
	MOV	CX,Attr 		; get attr
	SAVE	<BP>
	CALL	$CreateNewFile		; try to create a new file
	RESTORE <BP>
	JNC	CreateDone		; failed, go try again
;
; The operation failed and the error has been mapped in AX.  Grab the extended
; error and figure out what to do.
;
					; M049 - start
;;	mov	ax,ExtErr					;smr;SS Override
;;	cmp	al,error_file_exists
;;	jz	CreateLoop		; file existed => try with new name
;;	cmp	al,error_access_denied
;;	jz	CreateLoop		; access denied (attr mismatch)

	CMP	AL,error_file_exists	; Q: did file already exist
	JZ	CreateLoop		; Y: try again
	CMP	AL,error_access_denied	; Q: was it access denied
	JNZ	SETTMPERR		; N: Error out
					; Y: Check to see if we got this due
					;    to the network drive. Note that
					;    the redir will set the exterr
					;    to error_cannot_make if this is 
					;    so. 
	CMP	[EXTERR],error_net_access_denied ; M069
					; See if it's REALLY an att mismatch
	je	SetTmpErr		; no, network error, stop
;M070
; If the user failed on an I24, we do not want to try again
;
	cmp	ExtErr,error_FAIL_I24		;User failed on I24? ;M070
	je	SetTmpErr		;yes, do not try again ;M070

	jmp	short CreateLoop		;attr mismatch, try again ;M070

;;	MOV	AL,error_access_denied	; Return this "extended" error

					; M049 - end

SETTMPERR:
	STC
CreateDone:
	Leave
	JC	CreateFail
	transfer    Sys_Ret_OK		; success!
CreateFail:
	transfer    Sys_Ret_Err
EndProc $CreateTempFile

Break	<SetAttrib - set the search attrib>

;
;   SetAttrib will set the search attribute (SAttrib) either to the normal
;   (CH) or to the value in CL if the current system call is through
;   serverdoscall.
;
;   Inputs:	fSharing == FALSE => set sattrib to CH
;		fSharing == TRUE => set sattrib to CL
;   Outputs:	none
;   Registers changed:	CX

procedure   SetAttrib,NEAR
	assume	SS:DOSDATA			;smr;
	test	fSharing,-1					;smr;SS Override
	jnz	Set
	mov	cl,ch
Set:
	mov	SAttrib,cl					;smr;SS Override
	return
EndProc SetAttrib


Break	<Extended_Open- Extended open the file>

; Input: AL= 0 reserved  AH=6CH
;	 BX= mode
;	 CL= create attribute  CH=search attribute (from server)
;	 DX= flag
;	 DS:SI = file name
;	 ES:DI = parm list
;			   DD  SET EA list (-1) null
;			   DW  n  parameters
;			   DB  type (TTTTTTLL)
;			   DW  IOMODE
; Function: Extended Open
; Output: carry clear
;		     AX= handle
;		     CX=1 file opened
;			2 file created/opened
;			3 file replaced/opened
;	  carry set: AX has error code
;


procedure   $Extended_Open,NEAR 			       ;AN000;
	ASSUME	CS:DOSCODE,SS:DOSDATA	;AN000;

	MOV	[EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
	MOV	[EXTOPEN_IO_MODE],0	  ;AN000;EO. initialize IO mode;smr;SS Override
	TEST	DX,reserved_bits_mask	  ;AN000;EO. reserved bits 0  ?
	JNZ	ext_inval2		  ;AN000;EO. no
	MOV	AH,DL			  ;AN000;EO. make sure flag is right
	CMP	DL,0			  ;AN000;EO. all fail ?
	JZ	ext_inval2		  ;AN000;EO. yes, error
	AND	DL,exists_mask		  ;AN000;EO. get exists action byte
	CMP	DL,2			  ;AN000;EO, > 02
	JA	ext_inval2		  ;AN000;EO. yes ,error
	AND	AH,not_exists_mask	  ;AN000;EO. get no exists action byte
	CMP	AH,10H			  ;AN000;EO. > 10
	JA	ext_inval2		  ;AN000;EO. yes error

;	CMP	DI,-1			  ;AN000;EO. null parm list
;	JZ	no_parm 		  ;AN000;EO. yes
;					  ;AN000;EO
;	PUSH	CX			  ;AN000;EO.
;					  ;AN000;EO.
;	MOV	CX,ES:[DI.EXT_NUM_OF_PARM];AN000;EO. get number of parms
;	OR	CX,CX			  ;AN000;EO. 0 pamrs ?
;	JZ	parmend 		  ;AN000;EO. yes
;	PUSH	SI			  ;AN000;EO.
;	PUSH	DS			  ;AN000;EO.
;	MOV	SI,DI			  ;AN000;EO.
;	ADD	SI,size EXT_OPEN_PARM	  ;AN000;EO. position to 1st parm
;	PUSH	ES			  ;AN000;EO.
;	POP	DS			  ;AN000;EO. ds:si -> parm list
;	CALL	GetIOParms		  ;AN000;EO.
;	POP	DS			  ;AN000;EO.
;	POP	SI			  ;AN000;EO.
;parmend:				  ;AN000;EO
;	POP	CX			  ;AN000;EO. restore CX
;no_parm:				  ;AN000;EO.
	MOV	[SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
	MOV	[SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
	PUSH	[EXTOPEN_FLAG]		  ;AN000;EO.;smr;SS Override
	POP	[SAVE_DX]		  ;AN000;EO.;smr;SS Override
	MOV	[SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
	MOV	[SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
	MOV	[SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
	MOV	[SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
	MOV	AX,BX			  ;AN000;EO. ax= mode

;	TEST	[EXTOPEN_FLAG],no_code_page_check    ;AN000;EO. check no  code page
;	JNZ	no_cdpg_chk			 ;AN000;;EO.  no
	JMP	SHORT goopen2			 ;AN000;;EO.  do nromal
ext_inval2:					 ;AN000;;EO.
	error	error_Invalid_Function		 ;AN000;EO..  invalid function
ext_inval_parm: 				 ;AN000;EO..
	POP	CX				 ;AN000;EO..  pop up satck
	POP	SI				 ;AN000;EO..
	error	error_Invalid_data		 ;AN000;EO..  invalid parms
error_return:					 ;AN000;EO.
	ret					 ;AN000;EO..  return with error
;no_cdpg_chk:						EO.
;	MOV	[CPSWFLAG],0			 ;AN000;EO..  set CPSW flag off
goopen2:					 ;AN000;
	TEST	BX,int_24_error 		 ;AN000;EO..  disable INT 24 error ?
	JZ	goopen				 ;AN000;EO..  no
	OR	[EXTOPEN_ON],EXT_OPEN_I24_OFF	 ;AN000;EO..  set bit to disable;smr;SS Override

goopen: 					 ;AN000;
	OR	[EXTOPEN_ON],EXT_OPEN_ON	 ;AN000;EO..  set Extended Open active;smr;SS Override
	AND	[EXTOPEN_FLAG],0FFH		 ;AN000;EO.create new ?;smr;SS Override
	CMP	[EXTOPEN_FLAG],ext_exists_fail + ext_nexists_create ;AN000;FT.;smr;SS Override
	JNZ	chknext 			 ;AN000;;EO.  no
	invoke	$CreateNewFile			 ;AN000;;EO.  yes
	JC	error_return			 ;AN000;;EO.  error
	CMP	[EXTOPEN_ON],0			 ;AN000;;EO.  IFS does it;smr;SS Override
	JZ	ok_return2			 ;AN000;;EO.  yes
	MOV	[EXTOPEN_FLAG],action_created_opened ;AN000;EO. creted/opened;smr;SS Override
	JMP	setXAttr			 ;AN000;;EO.  set XAs
ok_return2:
	transfer SYS_RET_OK			 ;AN000;;EO.
chknext:
	TEST	[EXTOPEN_FLAG],ext_exists_open	 ;AN000;;EO.  exists open;smr;SS Override
	JNZ	exist_open			 ;AN000;;EO.  yes
	invoke	$Creat				 ;AN000;;EO.  must be replace open
	JC	error_return			 ;AN000;;EO.  return with error
	CMP	[EXTOPEN_ON],0			 ;AN000;;EO.  IFS does it;smr;SS Override
	JZ	ok_return2			 ;AN000;;EO.  yes
	MOV	[EXTOPEN_FLAG],action_created_opened  ;AN000;EO. prsume create/open;smr;SS Override
	TEST	[EXTOPEN_ON],ext_file_not_exists      ;AN000;;EO. file not exists ?;smr;SS Override
	JNZ	setXAttr			      ;AN000;;EO. no
	MOV	[EXTOPEN_FLAG],action_replaced_opened ;AN000;;EO. replaced/opened;smr;SS Override
	JMP	SHORT setXAttr			      ;AN000;;EO. set XAs
error_return2:
	STC                         ; Set Carry again to flag error     ;AN001;
	ret					 ;AN000;;EO.  return with error
						 ;AN000;
exist_open:					 ;AN000;
	test	fSharing,-1			 ;AN000;;EO. server doscall?;smr;SS Override
	jz	noserver			 ;AN000;;EO. no
	MOV	CL,CH				 ;AN000;;EO. cl=search attribute

noserver:
	call	$Open2				 ;AN000;;EO.  do open
	JNC	ext_ok				 ;AN000;;EO.
	CMP	[EXTOPEN_ON],0			 ;AN000;;EO.  error and IFS call;smr;SS Override
	JZ	error_return2			 ;AN000;;EO.  return with error
local_extopen:

	CMP	AX,error_file_not_found 	 ;AN000;;EO.  file not found error
	JNZ	error_return2			 ;AN000;;EO.  no,
	TEST	[EXTOPEN_FLAG],ext_nexists_create;AN000;;EO.  want to fail;smr;SS Override
	JNZ	do_creat			 ;AN000;;EO.  yes
	JMP	short extexit 			 ;AN000;;EO.  yes
do_creat:
	MOV	CX,[SAVE_CX]			 ;AN000;;EO.  get ds:dx for file name;smr;SS Override
	LDS	SI,DWORD PTR [SAVE_SI]		 ;AN000;;EO.  cx = attribute;smr;SS Override
	MOV	DX,SI				 ;AN000;;EO.
	invoke	$Creat				 ;AN000;;EO.  do create
	JC	extexit 			 ;AN000;;EO.  error
	MOV	[EXTOPEN_FLAG],action_created_opened  ;AN000;;EO. is created/opened;smr;SS Override
	JMP	SHORT setXAttr			      ;AN000;;EO.   set XAs

ext_ok:
	CMP	[EXTOPEN_ON],0			 ;AN000;;EO.  IFS call ?;smr;SS Override
	JZ	ok_return			 ;AN000;;EO.  yes
	MOV	[EXTOPEN_FLAG],action_opened	 ;AN000;;EO.  opened;smr;SS Override
setXAttr:
;	LES	DI,DWORD PTR [SAVE_DI]	;AN000;EO.
	PUSH	AX			;AN000;;EO. save handle for final
;	MOV	BX,AX			;AN000;;EO. bx= handle
;	MOV	AX,04H			;AN000;;EO. set extended attr by handle
;	PUSH	DS			;AN000;;EO. save file name addr
;	PUSH	DX			;AN000;;EO.
;	CMP	DI,-1			;AN000;;EO. null parm list
;	JZ	nosetea 		;AN000;;EO. yes
;	CMP	WORD PTR ES:[DI],-1	;AN000;;EO. null set list
;	JZ	nosetea 		;AN000;;EO. yes
;	LES	DI,DWORD PTR ES:[DI]	;AN000;;EO. es:di -> set list
;	invoke	$File_times		;AN000;;EO.
;nosetea:				;AN000; EO
;	POP	DX			;AN000;;EO. restore file name addr
;	POP	DS			;AN000;;EO.
;	JC	extexit2		;AN000;;EO.
	invoke	get_user_stack		;AN000;;EO.
	MOV	AX,[EXTOPEN_FLAG]	;AN000;;EO.;smr;SS Override
	MOV	[SI.USER_CX],AX 	;AN000;;EO. set action code for cx
	POP	AX			;AN000;;EO.
	MOV	[SI.USER_AX],AX 	;AN000;;EO. set handle for ax

ok_return:				;AN000;
	transfer SYS_RET_OK		;AN000;;EO.

extexit2:				;AN000; ERROR RECOVERY

	POP	BX			;AN000;EO. close the handle
	PUSH	AX			;AN000;EO. save error code from set XA
	CMP	[EXTOPEN_FLAG],action_created_opened	;AN000;EO. from create;smr;SS Override
	JNZ	justopen		;AN000;EO.
	LDS	SI,DWORD PTR [SAVE_SI]		 ;AN000;EO.  cx = attribute;smr;SS Override
	LDS	DX,DWORD PTR [SI]		 ;AN000;EO.
	invoke	$UNLINK 		;AN000;EO. delete the file
	JMP	SHORT reserror		;AN000;EO.

justopen:				;AN000;
	invoke	$close			;AN000;EO. pretend never happend
reserror:				;AN000;
	POP	AX			;AN000;EO. retore error code from set XA
	JMP	SHORT extexit		;AN000;EO.


ext_file_unfound:			;AN000;
	MOV	AX,error_file_not_found ;AN000;EO.
	JMP	SHORT extexit		;AN000;EO.
ext_inval:				 ;AN000;
	MOV	AX,error_invalid_function;AN000;EO.
extexit:
	transfer SYS_RET_ERR		;AN000;EO.

EndProc $Extended_Open			;AN000;


Break	<GetIOParms - get IO parms form extended open parm list>

;
;
;   Inputs: DS:SI -> IO parm list
;	    CX= number of parms
;   Function: get IO parms from parm list
;   Outputs:  [EXT_IOMODE]= IO mode parm

;procedure   GetIOParms,NEAR
;
;	LODSB					; get parm type 		;AN000;
;	CMP	AL,0*100B+10B			; have IOMODE			;AN000;
;	JE	SET_IOMODE							;AN000;
;	AND	AL,00000011B			; decode it			;AN000;
;	JZ	SKIP_ASCIIZ							;AN000;
;	DEC	AL								;AN000;
;	JZ	SKIP_LEN							;AN000;
;;	DEC	AL								;AN000;
;	JZ	SKIP_WORD							;AN000;
;SKIP_DWORD:					 ; copy DWORD parm		 ;AN000;
;	LODSW									;AN000;
;SKIP_WORD:					 ; copy WORD parm		 ;AN000;
;	LODSW									;AN000;
;	JMP	SHORT NEXT_PARM 						;AN000;
;SET_IOMODE:					 ; copy IOMODE			 ;AN000;
;	LODSW									;AN000;
;	MOV	[EXTOPEN_IO_MODE],AX						;AN000;
;	JMP	SHORT NEXT_PARM 						;AN000;
;SKIP_LEN:					 ; copy LENGTH parm		 ;AN000;
;	LODSW									;AN000;
;	ADD	SI,AX								;AN000;
;	JMP	SHORT NEXT_PARM 						;AN000;
;SKIP_ASCIIZ:					 ; copy ASCIIZ parm		 ;AN000;
;	LODSB									;AN000;
;	OR	AL,AL								;AN000;
;	JNE	SKIP_ASCIIZ							;AN000;
;NEXT_PARM:									 ;AN000;
;	LOOP	GetIOParms							;AN000;
;	return									;AN000;
;EndProc GetIOParms								 ;AN000;


DOSCODE ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\fat.asm ===
TITLE	FAT - FAT maintenance routines
	NAME	FAT

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FAT.ASM
;
;	Low level local device routines for performing disk change sequence,
;	setting cluster validity, and manipulating the FAT
;
;	IsEof
;	UNPACK
;	PACK
;	MAPCLUSTER
;	FATREAD_SFT
;	FATREAD_CDS
;	FAT_operation
;
;	Revision history:
;
;	  AN000  version Jan. 1988
;	   A001  PTM	      -- disk changed for look ahead buffers
;
;	M014 - if a request for pack\unpack cluster 0 is made we write\read
;	       from CL0FATENTRY rather than disk.
;

	extrn	GetCurHead:near, ScanPlace:near

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include dpb.inc
	include curdir.inc
	.cref
	.list

FastDiv = TRUE

	i_need	CURBUF,DWORD
	i_need	CLUSSPLIT,BYTE
	i_need	CLUSSAVE,WORD
	i_need	CLUSSEC,DWORD		;F.C. >32mb  ;AN000;
	i_need	THISDRV,BYTE
	i_need	THISDPB,DWORD
	i_need	DEVCALL,BYTE
	i_need	CALLMED,BYTE
	i_need	CALLRBYT,BYTE
	i_need	CALLXAD,DWORD
	i_need	CALLBPB,DWORD
	i_need	CDSADDR,DWORD
	i_need	CDSCOUNT,BYTE
	i_need	EXTERR,WORD
	i_need	EXTERRPT,DWORD
	i_need	CALLVIDM,DWORD
	i_need	ReadOp,BYTE
	i_need	FAILERR,BYTE
	i_need	ALLOWED,BYTE
	i_need	VOLCHNG_FLAG,BYTE
	i_need	HIGH_SECTOR,WORD
	i_need	DirtyBufferCount,WORD
	i_need	FIRST_BUFF_ADDR,WORD
	i_need	SC_CACHE_COUNT,WORD	       ;AN001;
	i_need	CURSC_DRIVE,BYTE	       ;AN001;

	i_need	CL0FATENTRY,WORD

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


Break <IsEOF - check the quantity in BX for EOF>
;----------------------------------------------------------------------------
;
; Procedure Name : IsEOF
;
; IsEOF - check the fat value in BX for eof.
;
;   Inputs:	ES:BP point to DPB
;		BX has fat value
;   Outputs:	JAE eof
;   Registers modified: none
;
;---------------------------------------------------------------------------

Procedure IsEof,NEAR
	ASSUME	SS:DOSDATA,CS:DOSCODE

	Assert	    ISDPB,<ES,BP>,"IsEOF"
	CMP	ES:[BP.dpb_max_cluster],4096-10 ; is this 16 bit fat?
	JAE	EOF16			; yes, check for eof there
;J.K. 8/27/86
;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
;of any media that has "F0"(Other) as a MediaByte.
;Hopely, this does not create any side effect for those who may use any value
;other than "FF8-FFF" as an Eof for their own file.
	cmp	bx,0FF0h
	je	IsEOF_other
	CMP	BX,0FF8h		; do the 12 bit compare
IsEOF_other:
	return
EOF16:
	CMP	BX,0FFF8h		; 16 bit compare
	return
EndProc IsEof

Break	<UNPACK -- UNPACK FAT ENTRIES>
;---------------------------------------------------------------------------
;
; Procedur Name : UNPACK
;
; Inputs:
;	BX = Cluster number (may be full 16-bit quantity)
;	ES:BP = Base of drive parameters
; Outputs:
;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
;	Zero set means DI=0 (free cluster)
;	Carry set means error (currently user FAILed to I 24)
; SI Destroyed, No other registers affected. Fatal error if cluster too big.
;
; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
;
;----------------------------------------------------------------------------

procedure   UNPACK,NEAR
	DOSAssume   <DS>,"UnPack"
					; M014 - Start
	or	bx, bx			; Q: are we unpacking cluster 0
	jnz	up_cont			; N: proceed with normal unpack
	mov	di, [CL0FATENTRY]	; Y: return value in CL0FATENTRY
	or	di,di 			; return z if di=0
	ret				; done
up_cont:				; M014 - End
	
	Assert	    ISDPB,<ES,BP>,"Unpack"
	CMP	BX,ES:[BP.dpb_max_cluster]
	JA	HURTFAT
	CALL	MAPCLUSTER
ASSUME	DS:NOTHING
	jc	DoContext
	MOV	DI,[DI]
	JNZ	High12			; MZ if high 12 bits, go get 'em
	MOV	SI,ES:[BP.dpb_max_cluster]  ; MZ is this 16-bit fat?
	CMP	SI,4096-10
	JB	Unpack12		; MZ No, go 'AND' off bits
	OR	DI,DI			; MZ set zero condition code, clears carry
	JMP	SHORT DoContext 	; MZ go do context

High12:
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
Unpack12:
	AND	DI,0FFFH		; Clears carry
DoContext:
	PUSH	SS
	POP	DS
	return

HURTFAT:
	MOV	ES:[BP.dpb_free_cnt],-1 ; Err in FAT must force recomp of freespace
	PUSH	AX
	MOV	AH,allowed_fail + 80h

;hkn; SS override
	MOV	Allowed,allowed_fail
;
; Signal Bad FAT to INT int_fatal_abort handler.  We have an invalid cluster.
;
	MOV	DI,0FFFH		; In case INT int_fatal_abort returns (it shouldn't)
	invoke	FATAL
	CMP	AL,3
	CLC
	JNZ	OKU_RET 		; Try to ignore bad FAT
	STC				; User said FAIL
OKU_RET:
	POP	AX
	return
EndProc UNPACK

Break	<PACK -- PACK FAT ENTRIES>
;----------------------------------------------------------------------------
;
; Procedure Name : PACK
;
; Inputs:
;	BX = Cluster number
;	DX = Data
;	ES:BP = Pointer to drive DPB
; Outputs:
;	The data is stored in the FAT at the given cluster.
;	SI,DX,DI all destroyed
;	Carry set means error (currently user FAILed to I 24)
;	No other registers affected
;
; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
;
;---------------------------------------------------------------------------

procedure   PACK,NEAR
	DOSAssume   <DS>,"Pack"

	Assert	    ISDPB,<ES,BP>,"Pack"
					; M014 - start
	or	bx, bx			; Q: are we packing cluster 0
	jnz	p_cont			; N: proceed with normal pack
	mov	[CL0FATENTRY], dx	; Y: place value in CL0FATENTRY
	ret				; done
p_cont:					; M014 - end

	CALL	MAPCLUSTER
    ASSUME DS:NOTHING
	JC	DoContext
	MOV	SI,[DI]
	JZ	Aligned 		; byte (not nibble) aligned
	PUSH	CX			; move data to upper 12 bits
	MOV	CL,4
	SHL	DX,CL
	POP	CX
	AND	SI,0FH			; leave in original low 4 bits
	JMP	SHORT PACKIN
ALIGNED:
	CMP	ES:[BP.dpb_max_cluster],4096-10 ; MZ 16 bit fats?
	JAE	Pack16			; MZ yes, go clobber original data
	AND	SI,0F000H		; MZ leave in upper 4 bits of original
	AND	DX,0FFFh		; MZ store only 12 bits
	JMP	SHORT PackIn		; MZ go store
Pack16:
	XOR	SI,SI			; MZ no original data
PACKIN:
	OR	SI,DX
	MOV	[DI],SI

;hkn; SS override
	LDS	SI,[CURBUF]
	TESTB	[SI.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	[SI.buf_flags],buf_dirty  ;LB.					;AN000;
yesdirty:				  ;LB.					;AN000;

;hkn; SS override
	CMP	BYTE PTR [CLUSSPLIT],0

;hkn; SS is DOSDATA
	Context DS
	retz				; Carry clear
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	AX,[CLUSSAVE]
	MOV	DS,WORD PTR [CURBUF+2]
ASSUME	DS:NOTHING
	ADD	SI,BUFINSIZ
	MOV	[SI],AH

;hkn; SS is DOSDATA
	Context DS
	PUSH	AX
	MOV	DX,WORD PTR [CLUSSEC+2] 	   ;F.C. >32mb		       ;AN000;
	MOV	WORD PTR [HIGH_SECTOR],DX	   ;F.C. >32mb		       ;AN000;

	MOV	DX,WORD PTR [CLUSSEC]
	MOV	SI,1
	XOR	AL,AL
	invoke	GETBUFFRB
	POP	AX
	JC	POPP_RET
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	TESTB	[DI.buf_flags],buf_dirty  ;LB. if already dirty 		;AN000;
	JNZ	yesdirty2		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	[DI.buf_flags],buf_dirty
yesdirty2:
	ADD	DI,BUFINSIZ
	DEC	DI
	ADD	DI,ES:[BP.dpb_sector_size]
	MOV	[DI],AL
	CLC
POPP_RET:
	PUSH	SS
	POP	DS
	POP	CX
	POP	BX
	POP	AX
	return

EndProc PACK

Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : MAPCLUSTER
;
; Inputs:
;	ES:BP Points to DPB
;	BX Is cluster number
; Function:
;	Get a pointer to the cluster
; Outputs:
;	DS:DI Points to contents of FAT for given cluster
;	DS:SI Points to start of buffer
;	Zero Not set if cluster data is in high 12 bits of word
;	Zero set if cluster data is in low 12 or 16 bits
;	Carry set if failed.
; SI is destroyed.
;
;---------------------------------------------------------------------------

procedure   MAPCLUSTER,NEAR
	DOSAssume   <DS>,"MapCluster"

	Assert	    ISDPB,<ES,BP>,"MapCluster"
	MOV	BYTE PTR [CLUSSPLIT],0
	SAVE	<AX,BX,CX,DX>
	MOV	AX,BX			; AX = BX
	CMP	ES:[BP.dpb_max_cluster],4096-10  ; MZ 16 bit fat?
	JAE	Map16			; MZ yes, do 16 bit algorithm
	SHR	AX,1			; AX = BX/2
Map16:					; MZ skip prev => AX=2*BX
	XOR	DI,DI			; >32mb     fat 			;AN000;
	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
	ADC	DI,DI			; >32mb fat ;DI is zero before op;AN000;
	MOV	CX,ES:[BP.dpb_sector_size]

IF FastDiv
;
; Gross hack:  99% of all disks have 512 bytes per sector.  We test for this
; case and apply a really fast algorithm to get the desired results
;
; Divide method takes 157+4*4=173 (MOV and DIV)
; Fast method takes 39+20*4=119
;
; This saves a bunch.
;
	CMP	CX,512			; 4	Is this 512 byte sector?
	jne	DoDiv			; 4     for no jump
	MOV	DX,AX			; 2	get set for remainder
	AND	DX,512-1		; 4	Form remainder
	MOV	AL,AH			; 2     Quotient in formation in AL
	shr	di, 1			; 2
	rcr	al, 1			; 2
	xor	ah, ah			; 3
	jmp	short DivDone		; 16
DoDiv:
ENDIF
	mov	dx, di			; 2
	DIV	CX			; 155 AX is FAT sector # DX is sector index
IF FastDiv
DivDone:
ENDIF
	ADD	AX,ES:[BP.dpb_first_FAT]
	DEC	CX			; CX is sector size - 1
	SAVE	<AX,DX,CX>
	MOV	DX,AX
	MOV	[HIGH_SECTOR],0 	;F.C. >32mb  low sector #
	XOR	AL,AL
	MOV	SI,1
	invoke	GETBUFFRB
	RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
	JC	MAP_POP
	LDS	SI,[CURBUF]
ASSUME	DS:NOTHING
	LEA	DI,[SI.BufInSiz]
	ADD	DI,AX
	CMP	AX,CX
	JNZ	MAPRET
	MOV	AL,[DI]
	Context DS		 	;hkn; SS is DOSDATA
	INC	BYTE PTR [CLUSSPLIT]
	MOV	BYTE PTR [CLUSSAVE],AL
	MOV	WORD PTR [CLUSSEC],DX
	MOV	WORD PTR [CLUSSEC+2],0	      ;F.C. >32mb			;AN000;
	INC	DX
	MOV	[HIGH_SECTOR],0 	      ;F.C. >32mb  FAT sector <32mb	;AN000;
	XOR	AL,AL
	MOV	SI,1
	invoke	GETBUFFRB
	JC	MAP_POP
	LDS	SI,[CURBUF]
ASSUME	DS:NOTHING
	LEA	DI,[SI.BufInSiz]
	MOV	AL,[DI]
	Context DS			;hkn; SS is DOSDATA
	MOV	BYTE PTR [CLUSSAVE+1],AL

;hkn; CLUSSAVE is in DOSDATA
	MOV	DI,OFFSET DOSDATA:CLUSSAVE
MAPRET:
	RESTORE <DX,CX,BX>
	XOR	AX,AX			; MZ allow shift to clear carry
	CMP	ES:[BP.dpb_max_cluster],4096-10 ; MZ is this 16-bit fat?
	JAE	MapSet			; MZ no, set flags
	MOV	AX,BX
MapSet:
	TEST	AL,1			; set zero flag if not on boundary
	RESTORE <AX>
	return

MAP_POP:
	RESTORE <DX,CX,BX,AX>
	return

EndProc MAPCLUSTER, NoCheck

Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_SFT
;
; Inputs:
;	ES:DI points to an SFT for the drive of intrest (local only,
;		giving a NET SFT will produce system crashing results).
;	DS DOSDATA
; Function:
;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
;	if disk changed.
;	In other respects, same as FATREAD_CDS.
;	(note ES:DI destroyed!)
; Outputs:
;	Carry set if error (currently user FAILed to I 24)
; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
;	as far as invalidating curdir_ID is concerned.
;	Since getting a true disk changed on this call is a screw up
;	anyway, that's the way it goes.
;
;---------------------------------------------------------------------------

procedure  FATREAD_SFT,NEAR
	DOSAssume   <DS>,"FATRead_SFT"

	LES	BP,ES:[DI.sf_devptr]
	Assert	ISDPB,<ES,BP>,"FatReadSFT"
	MOV	AL,ES:[BP.dpb_drive]
	MOV	[THISDRV],AL
	invoke	GOTDPB			;Set THISDPB
	CALL	FAT_GOT_DPB
	return

EndProc FATREAD_SFT

;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_CDS
;
; Inputs:
;	DS:DOSDATA
;	ES:DI points to an CDS for the drive of intrest (local only,
;		giving a NET or NUL CDS will produce system crashing results).
; Function:
;	If disk may have been changed, media is determined and buffers are
;	flagged invalid. If not, no action is taken.
; Outputs:
;	ES:BP = Drive parameter block
;	THISDPB = ES:BP
;	THISDRV set
;	Carry set if error (currently user FAILed to I 24)
; DS preserved , all other registers destroyed
;
;---------------------------------------------------------------------------

procedure   FATREAD_CDS,NEAR
	DOSAssume   <DS>,"FATRd_CDS"

	PUSH	ES
	PUSH	DI
	LES	BP,ES:[DI.curdir_devptr]
	Assert	ISDPB,<ES,BP>,"FatReadCDS"
	MOV	AL,ES:[BP.dpb_drive]
	MOV	[THISDRV],AL
	invoke	GOTDPB			;Set THISDPB
	CALL	FAT_GOT_DPB
	POP	DI			;Get back CDS pointer
	POP	ES
	retc
	JNZ	NO_CHANGE		;Media NOT changed

;	Media changed. We now need to find all CDS structures which use this
;	DPB and invalidate their ID pointers.

MED_CHANGE:
	XOR	AX,AX
	DEC	AX			;AX = -1
	PUSH	DS
	MOV	CL,[CDSCOUNT]
	XOR	CH,CH			; CX is number of structures
	LDS	SI,ES:[DI.curdir_devptr] ; Find all CDS with this devptr
ASSUME	DS:NOTHING

;hkn; SS override

;	Find all CDSs with this DevPtr
;
;	(ax) = -1
;	(ds:si) = DevPtr

	LES	DI,CDSADDR		; (es:di) = CDS pointer
frcd20: TESTB	ES:[DI.curdir_flags],curdir_isnet
	JNZ	frcd25			; Leave NET guys alone!!
	cmp	si,word ptr es:[di].curdir_devptr
	jne	frcd25			; no match
	mov	bx,ds
	cmp	bx,word ptr es:[di].curdir_devptr+2
	jne	frcd25			; CDS not for this drive
	test	ES:[DI].curdir_ID,AX
	JZ	frcd25			; If root (0), leave root
	MOV	ES:[DI].curdir_ID,AX	; else invalid
frcd25:	ADD	DI,SIZE curdir_list	; Point to next CDS
	LOOP	frcd20
	POP	DS
	DOSAssume   <DS>,"FrCd25"
NO_CHANGE:
	LES	BP,THISDPB
	CLC
	return

EndProc FATREAD_CDS

Break	<Fat_Operation - miscellaneous fat stuff>

	procedure   FAT_operation,NEAR
FATERR:
	DOSAssume   <DS>,"FATERR"
	MOV	ES:[BP.dpb_free_cnt],-1 ; Err in FAT must force recomp of freespace
	AND	DI,STECODE		; Put error code in DI
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	MOV	AH,2 + allowed_FAIL + allowed_RETRY ; While trying to read FAT
	MOV	AL,BYTE PTR [THISDRV]	 ; Tell which drive
	invoke	FATAL1
	LES	BP,THISDPB
	CMP	AL,3
	JNZ	FAT_GOT_DPB		; User said retry
	STC				; User said FAIL
	return

	public	fat_got_dpb

FAT_GOT_DPB:
	Context DS			;hkn; SS is DOSDATA
	MOV	AL,DMEDHL
	MOV	AH,ES:[BP.dpb_UNIT]
	MOV	WORD PTR [DEVCALL],AX
	MOV	BYTE PTR [DEVCALL.REQFUNC],DEVMDCH
	MOV	[DEVCALL.REQSTAT],0
	MOV	AL,ES:[BP.dpb_media]
	MOV	BYTE PTR [CALLMED],AL
	PUSH	ES
	PUSH	DS

;hkn; DEVCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVCALL
	LDS	SI,ES:[BP.dpb_driver_addr]  ; DS:SI Points to device header
ASSUME	DS:NOTHING
	POP	ES			; ES:BX Points to call header
	invoke	DEVIOCALL2
	Context DS		 	;hkn; SS is DOSDATA
	POP	ES			; Restore ES:BP
	MOV	DI,[DEVCALL.REQSTAT]
	.errnz	STERR-8000h
	or	di,di
	js	FATERR			; have error
	XOR	AH,AH
	XCHG	AH,ES:[BP.dpb_first_access] ; Reset dpb_first_access
	MOV	AL,BYTE PTR [THISDRV]	; Use physical unit number
; See if we had changed volume id by creating one on the diskette
	cmp	[VOLCHNG_FLAG],AL
	jnz	CHECK_BYT
	mov	[VOLCHNG_FLAG],-1
	jmp	GOGETBPB		; Need to get device driver to read in
					; new volume label.
CHECK_BYT:
	OR	AH,BYTE PTR [CALLRBYT]
	JNS	CHECK_ZR		; ns = 0 or 1
	JMP	short NEWDSK

CHECK_ZR:
	JZ	CHKBUFFDIRT		; jump if I don't know
	CLC
	return				; If Media not changed (NZ)

DISK_CHNG_ERR:
ASSUME	DS:NOTHING
	PUSH	ES
	PUSH	BP
	LES	BP,ES:[BP.dpb_driver_addr]  ; Get device pointer
	TESTB	ES:[BP.SDEVATT],DEVOPCL ; Did it set vol id?
	POP	BP
	POP	ES
	JZ	FAIL_OPJ2		; Nope, FAIL
	PUSH	DS			; Save buffer pointer for ignore
	PUSH	DI
	Context DS			;hkn; SS is DOSDATA
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	PUSH	ES
	LES	DI,[CALLVIDM]		; Get volume ID pointer
	MOV	WORD PTR [EXTERRPT+2],ES
	POP	ES
	MOV	WORD PTR [EXTERRPT],DI
	MOV	AX,error_I24_wrong_disk
	MOV	[READOP],1		; Write
	invoke	HARDERR
	POP	DI			; Get back buffer for ignore
	POP	DS
ASSUME	DS:NOTHING
	CMP	AL,3
FAIL_OPJ2:
	JZ	FAIL_OP
	JMP	FAT_GOT_DPB		; Retry

CHKBUFFDIRT:
	DOSAssume   <DS>,"ChkBuffDirt"
	assume	DS:NOTHING	; BUGBUG - why this assume after the DOSASSUME?
	cmp	[DirtyBufferCount], 0		; any dirty buffers ? ;hkn;
	je	NEWDSK				; no, skip the check
	call	GetCurHead			; get pointer to first buffer
nbuffer:
	cmp	[di].buf_ID, al			; Unit OK ?
	jne	lfnxt				; no, go for next buffer
	TESTB	[di].buf_flags, buf_dirty	; is the buffer dirty ?
	jz	lfnxt				; no, go for next buffer
;	pop	di				; There is a dirty buffer
;	pop	ds				;  assume Media OK ( NZ )
	Context	DS
	clc
	ret

FAIL_OP:					; This label & code is here
	Context	DS				;  for reachability
	STC
	return

	assume	DS:NOTHING
lfnxt:
	mov	di, [di].buf_next		; get next buffer
	cmp	[FIRST_BUFF_ADDR], di		; is this where we started ?;hkn;
	jne	nbuffer				; no, check this guy also

; If no dirty buffers, assume Media changed
NEWDSK:
	mov	ES:[bp].dpb_free_cnt, -1	; Media changed, must
						;  recompute
	call	GetCurHead
nxbuffer:
	cmp	[di].buf_ID, al			; This drive ?
	jne	lfnxt2
	TESTB	[di].buf_flags, buf_dirty
	DLJNZ	DISK_CHNG_ERR
	mov	word ptr [di].buf_ID, (buf_visit SHL 8) OR 0FFh ; free up
	call	ScanPlace
	jmp	short skpbuff
lfnxt2:
	mov	di, [di].buf_next
skpbuff:
	cmp	di, [FIRST_BUFF_ADDR]					;hkn;
	jne	nxbuffer

	CMP	[SC_CACHE_COUNT],0	;LB.  look ahead buffers ?		  ;AN001;
	JZ	GOGETBPB		;LB.  no				  ;AN001;
	CMP	AL,[CURSC_DRIVE]	;LB.  same as changed drive		  ;AN001;
	JNZ	GOGETBPB		;LB.  no				  ;AN001;
	MOV	[CURSC_DRIVE],-1	;LB.  invalidate look ahead buffers	  ;AN000;
GOGETBPB:
	LDS	DI,ES:[BP.dpb_driver_addr]
	TESTB	[DI.SDEVATT],ISFATBYDEV
	JNZ	GETFREEBUF
	context DS	    		;hkn; SS is DOSDATA
	MOV	BX,2
	CALL	UNPACK			; Read the first FAT sector into CURBUF
FAIL_OPJ:
	JC	FAIL_OP
	LDS	DI,[CURBUF]
ASSUME	DS:NOTHING
	JMP	SHORT GOTGETBUF

GETFREEBUF:
ASSUME	DS:NOTHING
	PUSH	ES			; Get a free buffer for BIOS to use
	PUSH	BP
;	LDS	DI,[BUFFHEAD]
	XOR	DX,DX			     ;LB.  fake to get 1st		  ;AN000;

;hkn; SS override
	MOV	[HIGH_SECTOR],DX	     ;LB.  buffer addr			  ;AN000;
	invoke	GETCURHEAD		     ;LB.				  ;AN000;

	invoke	BUFWRITE
	POP	BP
	POP	ES
	JC	FAIL_OPJ
GOTGETBUF:
	ADD	DI,BUFINSIZ

;hkn; SS override
	MOV	WORD PTR [CALLXAD+2],DS
	Context DS			;hkn; SS is DOSDATA
	MOV	WORD PTR [CALLXAD],DI
	MOV	AL,DBPBHL
	MOV	AH,BYTE PTR ES:[BP.dpb_UNIT]
	MOV	WORD PTR [DEVCALL],AX
	MOV	BYTE PTR [DEVCALL.REQFUNC],DEVBPB
	MOV	[DEVCALL.REQSTAT],0
	MOV	AL,BYTE PTR ES:[BP.dpb_media]
	MOV	[CALLMED],AL
	PUSH	ES
	PUSH	DS
	PUSH	WORD PTR ES:[BP.dpb_driver_addr+2]
	PUSH	WORD PTR ES:[BP.dpb_driver_addr]

;hkn; DEVCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DEVCALL
	POP	SI
	POP	DS			; DS:SI Points to device header
ASSUME	DS:NOTHING
	POP	ES			; ES:BX Points to call header
	invoke	DEVIOCALL2
	POP	ES			; Restore ES:BP
	Context DS		 	;hkn; SS is DOSDATA
	MOV	DI,[DEVCALL.REQSTAT]

	.errnz	STERR-8000h
	or	di,di
	js	FATERRJ 		; have error
	MOV	AL,BYTE PTR ES:[BP.dpb_media]
	LDS	SI,[CALLBPB]
ASSUME	DS:NOTHING
	MOV	ES:[BP].DPB_next_free,0 ; recycle scanning pointer
	invoke	$SETDPB

;hkn; SS override
	LDS	DI,[CALLXAD]		; Get back buffer pointer
	MOV	AL,BYTE PTR ES:[BP.dpb_FAT_count]
	MOV	[DI.buf_wrtcnt-BUFINSIZ],AL   ;>32mb				;AN000;
	MOV	AX,ES:[BP.dpb_FAT_size]       ;>32mb				;AC000;
	MOV	[DI.buf_wrtcntinc-BUFINSIZ],AX	 ;>32mb Correct buffer info	;AC000;

	Context DS			;hkn; SS is DOSDATA
	XOR	AL,AL			;Media changed (Z), Carry clear
	return

FATERRJ: JMP	FATERR

EndProc FAT_operation

DOSCODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\fcb.asm ===
TITLE	FCB - FCB parse calls for MSDOS
	NAME	FCB

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	FCB.ASM -  Low level routines for parsing names into FCBs and analyzing
;		   filename characters
;
;	MakeFcb
;	NameTrans
;	PATHCHRCMP
;	GetLet
;	UCase
;	GetLet3
;	GetCharType
;	TESTKANJ
;	NORMSCAN
;	DELIM
;
;	Revision history:
;
;		A000  version 4.00  Jan. 1988
;	
;	M048 - access FILE_UCASE_TAB using DS rather than SS.

.xlist
.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include doscntry.inc			;AN000; 	2/12/KK
.cref
.list

	i_need	Name1,BYTE
	i_need	Attrib,BYTE
	i_need	SpaceFlag,BYTE
	i_need	FILE_UCASE_TAB,byte	   ;DOS 3.3
	i_need	COUNTRY_CDPG,byte	;AN000; 	2/12/KK
	i_need	DrvErr,BYTE		;AN000; 	2/12/KK
	i_need	DOS34_FLAG,WORD 	;AN000; 	2/12/KK

TableLook	equ -1

SCANSEPARATOR	EQU	1
DRVBIT		EQU	2
NAMBIT		EQU	4
EXTBIT		EQU	8


DOSCODE	SEGMENT

	allow_getdseg

;
;----------------------------------------------------------------------------
;
; Procedure : MakeFcb
;
;----------------------------------------------------------------------------
;

	ASSUME	SS:DOSDATA,CS:DOSCODE


procedure   MakeFcb,NEAR

;hkn; SS override
	MOV	BYTE PTR [SpaceFlag],0
	XOR	DL,DL		; Flag--not ambiguous file name
	test	AL,DRVBIT	; Use current drive field if default?
	JNZ	DEFDRV
	MOV	BYTE PTR ES:[DI],0	; No - use default drive
DEFDRV:
	INC	DI
	MOV	CX,8
	test	AL,NAMBIT	; Use current name fields as defualt?
	XCHG	AX,BX		; Save bits in BX
	MOV	AL," "
	JZ	FILLB		; If not, go fill with blanks
	ADD	DI,CX
	XOR	CX,CX		; Don't fill any
FILLB:
	REP	STOSB
	MOV	CL,3
	test	BL,EXTBIT	; Use current extension as default
	JZ	FILLB2
	ADD	DI,CX
	XOR	CX,CX
FILLB2:
	REP	STOSB
	XCHG	AX,CX		; Put zero in AX
	STOSW
	STOSW			; Initialize two words after to zero
	SUB	DI,16		; Point back at start
	test	BL,SCANSEPARATOR; Scan off separators if not zero
	JZ	SKPSPC
	CALL	SCANB		; Peel off blanks and tabs
	CALL	DELIM		; Is it a one-time-only delimiter?
	JNZ	NOSCAN
	INC	SI		; Skip over the delimiter
SKPSPC:
	CALL	SCANB		; Always kill preceding blanks and tabs
NOSCAN:
	CALL	GETLET
	JBE	NODRV		; Quit if termination character
 IFDEF  DBCS			;AN000;
	CALL	TESTKANJ	;AN000;; 2/18/KK
	JNE	NODRV		;AN000;; 2/18/KK
 ENDIF				;AN000;
	CMP	BYTE PTR[SI],":"        ; Check for potential drive specifier
	JNZ	NODRV
	INC	SI		; Skip over colon
	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
	JBE	BADDRV		; Drive letter out of range

	PUSH	AX
	Invoke	GetVisDrv
	POP	AX
	JNC	HavDrv

;hkn; SS override
	CMP	[DrvErr],error_not_DOS_disk  ; if not FAt drive 		;AN000;
	JZ	HavDrv			     ; assume ok			;AN000;
BADDRV:
	MOV	DL,-1
HAVDRV:
	STOSB			; Put drive specifier in first byte
	INC	SI
	DEC	DI		; Counteract next two instructions
NODRV:
	DEC	SI		; Back up
	INC	DI		; Skip drive byte

	entry	NORMSCAN

	MOV	CX,8
	CALL	GETWORD 	; Get 8-letter file name
	CMP	BYTE PTR [SI],"."
	JNZ	NODOT
	INC	SI		; Skip over dot if present

;hkn; SS override
	TESTB	[DOS34_FLAG],DBCS_VOLID2					;AN000;
	JZ	VOLOK								;AN000;
	MOVSB			; 2nd byte of DBCS				;AN000;
	MOV	CX,2								;AN000;
	JMP	SHORT contvol							;AN000;
VOLOK:
	MOV	CX,3		; Get 3-letter extension
contvol:
	CALL	MUSTGETWORD
NODOT:
	MOV	AL,DL

	and	[DOS34_FLAG],not DBCS_VOLID2	; ### BUG FIX ###

	return

NONAM:
	ADD	DI,CX
	DEC	SI
	return

GETWORD:
	CALL	GETLET
	JBE	NONAM		; Exit if invalid character
	DEC	SI

;	UGH!!! Horrible bug here that should be fixed at some point:
;	If the name we are scanning is longer than CX, we keep on reading!

MUSTGETWORD:
	CALL	GETLET

;	If spaceFlag is set then we allow spaces in a pathname

IF NOT TABLELOOK
	JB	FILLNAM
ENDIF
	JNZ	MustCheckCX

;hkn; SS override
	test	BYTE PTR [SpaceFlag],0FFh
	JZ	FILLNAM
	CMP	AL," "
	JNZ	FILLNAM

MustCheckCX:
	JCXZ	MUSTGETWORD
	DEC	CX
	CMP	AL,"*"          ; Check for ambiguous file specifier
	JNZ	NOSTAR
	MOV	AL,"?"
	REP	STOSB
NOSTAR:
	STOSB

 IFDEF   DBCS							  ;AN000;
	CALL	TESTKANJ					  ;AN000;
	JZ	NOTDUAL3					  ;AN000;
	JCXZ	BNDERR		; Attempt to straddle boundry	  ;AN000;
	MOVSB			; Transfer second byte		  ;AN000;
	DEC	CX						  ;AN000;
	JMP	MUSTGETWORD					  ;AN000;
BNDERR: 							  ;AN000;

;hkn; SS override for DOS34_FLAG
	TESTB	[DOS34_FLAG],DBCS_VOLID 			  ;AN000;
	JZ	notvolumeid					  ;AN000;
	TESTB	[DOS34_FLAG],DBCS_VOLID2			  ;AN000;
	JNZ	notvolumeid					  ;AN000;
	OR	[DOS34_FLAG],DBCS_VOLID2			  ;AN000;
	JMP	MUSTGETWORD					  ;AN000;

notvolumeid:
;;	INC	CX		; Undo the store of the first byte
	DEC	DI
	MOV	AL," "          ;PTM.                              ;AN000;
	STOSB			;PTM.				   ;AN000;
	INC	SI		;PTM.				   ;AN000;
	JMP	MUSTGETWORD	;PTM.				   ;AN000;

NOTDUAL3:							   ;AN000;
  ENDIF 							   ;AN000;

	CMP	AL,"?"
	JNZ	MUSTGETWORD
	OR	DL,1		; Flag ambiguous file name
	JMP	MUSTGETWORD
FILLNAM:
	MOV	AL," "
	REP	STOSB
	DEC	SI
	return

SCANB:
	LODSB
	CALL	SPCHK
	JZ	SCANB
 IFDEF  DBCS			;AN000; 						;AN000;
	CMP	AL,DB_SP_HI	;AN000;; 1ST BYTE OF DBCS BLANK 2/18/KK 		;AN000;
	JNE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	CALL	TESTKANJ	;AN000;; 2/23/KK  3/31/KK revoved			;AN000;
	JE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	CMP	BYTE PTR [SI],DB_SP_LO;AN000;H ; 2ND BYTE OF DBCS BLANK 2/18/KK 3/31/KK revove;AN000;
	JNE	SCANB_EXIT	;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	INC	SI		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
	JMP	SCANB		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
    SCANB_EXIT: 		;AN000;; 2/18/KK  3/31/KK revoved			;AN000;
 ENDIF				;AN000;
	DEC	SI
	return
EndProc MakeFCB

;----------------------------------------------------------------------------
;
; Procedure Name : NameTrans
;
; NameTrans is used by FindPath to scan off an element of a path.  We must
; allow spaces in pathnames
;
;   Inputs:	DS:SI points to start of path element
;   Outputs:	Name1 has unpacked name, uppercased
;		ES = DOSGroup
;		DS:SI advanced after name
;   Registers modified: DI,AX,DX,CX
;
;----------------------------------------------------------------------------

procedure   NameTrans,near
	ASSUME	SS:DOSDATA

;hkn; SS override
	MOV	BYTE PTR [SpaceFlag],1
	context ES

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1
	PUSH	DI
	MOV	AX,'  '
	MOV	CX,5
	STOSB
	REP	STOSW		; Fill "FCB" at NAME1 with spaces
	XOR	AL,AL		; Set stuff for NORMSCAN
	MOV	DL,AL
	STOSB
	POP	DI

	CALL	NORMSCAN

;hkn; SS override for NAME1
IFDEF DBCS 			;AN000;;KK.
	MOV	AL,[NAME1]	;AN000;;KK. check 1st char
	call	testkanj	;AN000;;KK. dbcs ?
	JZ	notdbcs 	;AN000;;KK. no
	return			;AN000;;KK. yes
notdbcs:			;AN000;
ENDIF				;AN000;
	CMP	[NAME1],0E5H
	retnz
	MOV	[NAME1],5	; Magic name translation
	return

EndProc nametrans

Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>

If TableLook

;hkn; Table	SEGMENT
	PUBLIC	CharType

; Character type table for file name scanning
; Table provides a mapping of characters to validity bits.
; Four bits are provided for each character.  Values 7Dh and above
; have all bits set, so that part of the table is chopped off, and
; the translation routine is responsible for screening these values.
; The bit values are defined in DOSSYM.INC

	      ; ^A and NUL
CharType db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^C and ^B
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^E and ^D
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^G and ^F
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; TAB and BS
	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^K and ^J
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^M and ^L
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^O and ^N
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^Q and ^P
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^S and ^R
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^U and ^T
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^W and ^V
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^Y and ^X
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ESC and ^Z
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^] and ^\
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ^_ and ^^
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; ! and SPACE
	 db   LOW (NOT FCHK+FDELIM+FSPCHK)

	      ; # and "
	 db   LOW (NOT FFCB+FCHK)

	      ; $ - )
	 db   3 dup (0FFh)

	      ; + and *
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh

	      ; - and '
	 db   NOT (FFCB+FCHK+FDELIM)

	      ; / and .
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh

	      ; 0 - 9
	 db   5 dup (0FFh)

	      ; ; and :
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh

	      ; = and <
	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh

	      ; ? and >
	 db   NOT FFCB+FCHK+FDELIM

	      ; A - Z
	 db   13 dup (0FFh)

	      ; \ and [
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh

	      ; ^ and ]
	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh

	      ; _ - {
	 db   15 dup (0FFh)

	      ; } and |
	 db   NOT FFCB+FCHK+FDELIM

CharType_last equ ($ - CharType) * 2	; This is the value of the last
					; character in the table

;hkn; Table	ENDS

ENDIF

;----------------------------------------------------------------------------
;
; Procedure Names : GetLet, UCase, GetLet3
;
; These routines take a character, convert it to upper case, and check
; for delimiters.  Three different entry points:
;	GetLet -  DS:[SI] = character to convert
;	UCase  -  AL = character to convert
;	GetLet3 - AL = character
;		  [BX] = translation table to use
;
;	Exit (in all cases) : AL = upper case character
;			      CY set if char is control char other than TAB
;			      ZF set if char is a delimiter
;	Uses : AX, flags
;
; NOTE: This routine exists in a fast table lookup version, and a slow
; inline version.  Return with carry set is only possible in the inline
; version.  The table lookup version is the one in use.
;
;----------------------------------------------------------------------------


; This entry point has character at [SI]

procedure   GetLet,NEAR
	assume	CS:DOSCODE,SS:DOSDATA
	LODSB

; This entry point has character in AL

entry UCase
	PUSH	BX
	MOV	BX,OFFSET DOSDATA:FILE_UCASE_TAB+2

; Convert the character in AL to upper case

gl_0:
	CMP	AL,"a"
	JB	gl_2		; Already upper case, go check type
	CMP	AL,"z"
	JA	gl_1
	SUB	AL,20H		; Convert to upper case

; Map European character to upper case

gl_1:
	CMP	AL,80H
	JB	gl_2		; Not EuroChar, go check type
	SUB	AL,80H		; translate to upper case with this index

	; M048 - Start 
	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
	; preserve it.
	;

	push	ds
	getdseg	<ds>

	XLAT	BYTE PTR [BX]	; ds as file_ucase_tab is in DOSDATA

	pop	ds
	assume	ds:nothing

	; M048 - End

; Now check the type

If TableLook

gl_2:
	PUSH	AX
	CALL	GetCharType	; returns type flags in AL
	TEST	AL,FCHK 	; test for normal character
	POP	AX
	POP	BX
	RET

; This entry has character in AL and lookup table in BX

entry GetLet3
	PUSH	BX
	JMP	short gl_0

ELSE

gl_2:
	POP	BX
	CMP	AL,"."
	retz
	CMP	AL,'"'
	retz
	CALL	PATHCHRCMP
	retz
	CMP	AL,"["
	retz
	CMP	AL,"]"
	retz
ENDIF

;---------------------------------------------------------------------
;
; DELIM - check if character is a delimiter
;	Entry : AX = character to check
;	Exit  : ZF set if character is not a delimiter
;	Uses  : Flags
;
;--------------------------------------------------------------------

entry	DELIM

IF TableLook
	PUSH	AX

	CALL	GetCharType
	TEST	AL,FDELIM
	POP	AX
	RET
ELSE
	CMP	AL,":"
	retz

	CMP	AL,"<"
	retz
	CMP	AL,"|"
	retz
	CMP	AL,">"
	retz

	CMP	AL,"+"
	retz
	CMP	AL,"="
	retz
	CMP	AL,";"
	retz
	CMP	AL,","
	retz
ENDIF

;-------------------------------------------------------------------------
;
;  SPCHK - checks to see if a character is a space or equivalent
;	Entry : AL = character to check
;	Exit  : ZF set if character is a space
;	Uses  : flags
;
;-------------------------------------------------------------------------

entry SPCHK

IF  TableLook
	PUSH	AX
	CALL	GetCharType
	TEST	AL,FSPCHK
	POP	AX
	RET
ELSE
	CMP	AL,9		; Filter out tabs too
	retz
; WARNING! " " MUST be the last compare
	CMP	AL," "
	return
ENDIF
EndProc GetLet


;-------------------------------------------------------------------------
;
;  GetCharType - return flag bits indicating character type
;	Bits are defined in DOSSYM.INC.  Uses lookup table
;	defined above at label CharType.
;
;	Entry : AL = character to return type flags for
;	Exit  : AL = type flags
;	Uses  : AL, flags
;
;-------------------------------------------------------------------------

Procedure	GetCharType, Near

	cmp	al,CharType_last	; beyond end of table?
	jae	gct_90			; return standard value

	push	bx
	mov	bx, offset DOSCODE:CharType ; load lookup table
	shr	al,1			; adjust for half-byte table entry size
	xlat	cs:[bx] 		; get flags
	pop	bx

; carry clear from previous shift means we want the low nibble.  Otherwise
; we have to shift the flags down to the low nibble

	jnc	gct_80			; carry clear, no shift needed

	shr	al,1			; we want high nibble, shift it down
	shr	al,1
	shr	al,1
	shr	al,1

gct_80:
	and	al,0Fh			; clear the unused nibble
	ret

gct_90:
	mov	al,0Fh			; set all flags
	ret

EndProc GetCharType


;----------------------------------------------------------------------------
;
; Procedure : PATHCHRCMP
;
;----------------------------------------------------------------------------
;

Procedure   PATHCHRCMP,NEAR
	CMP	AL,'/'
	JBE	PathRet
	CMP	AL,'\'
	return
GotFor:
	MOV	AL,'\'
	return
PathRet:
	JZ	GotFor
	return
EndProc PathChrCMP


 IFDEF  DBCS
;---------------------	2/12/KK	 ------------------------------------------
;
; Procedure Name : TESTKANJ
;
; Function: Check if an input byte is in the ranges of DBCS vectors.
;
;   Input:   AL ; Code to be examined
;
;  Output:   ZF = 1 :  AL is SBCS      ZF = 0 : AL is a DBCS leading byte
;
;  Register:  All registers are unchanged except FL
;
;--------------------------------------------------------------------------

procedure   TESTKANJ,NEAR							;AN000;
	call	Chk_DBCS							;AN000;
	jc	TK_DBCS 							;AN000;
	cmp	AL,AL		; set ZF					;AN000;
	return									;AN000;
TK_DBCS:
	PUSH	AX								;AN000;
	XOR	AX,AX		;Set ZF 					;AN000;
	INC	AX		;Reset ZF					;AN000;
	POP	AX								;AN000;
	return									;AN000;
EndProc TESTKANJ								;AN000;
;
Chk_DBCS	PROC								;AN000;
	PUSH	DS								;AN000;
	PUSH	SI								;AN000;
	PUSH	BX								;AN000;

;hkn; SS is DOSDATA
	Context DS  
     
;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccSetDBCS			;AN000;
	LDS	SI,[BX+1]		; set EV address to DS:SI		;AN000;
	ADD	SI,2			; Skip length				;AN000;
DBCS_LOOP:
	CMP	WORD PTR [SI],0 	; terminator ?				;AN000;
	JE	NON_DBCS		; if yes, no DBCS			;AN000;
	CMP	AL,[SI] 		; else					;AN000;
	JB	DBCS01			; check if AL is			;AN000;
	CMP	AL,[SI+1]		; in a range of Ev			;AN000;
	JA	DBCS01			; if yes, DBCS				;AN000;
	STC				; else					;AN000;
	JMP	DBCS_EXIT		; try next DBCS Ev			;AN000;
DBCS01:
	ADD	SI,2								;AN000;
	JMP	DBCS_LOOP							;AN000;
NON_DBCS:
	CLC									;AN000;
DBCS_EXIT:
	POP	BX								;AN000;
	POP	SI								;AN000;
	POP	DS								;AN000;
	RET									;AN000;
Chk_DBCS	ENDP								;AN000;
 ENDIF										;AN000;
DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\fcbio2.asm ===
;	SCCSID = @(#)fcbio2.asm 1.2 85/07/23
	TITLE	FCBIO2 - FCB system calls
	NAME	FCBIO2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
;
;	GetRR
;	GetExtent
;	SetExtent
;	GetExtended
;	GetRecSize
;	FCBIO
;	$FCB_OPEN
;	$FCB_CREATE
;	$FCB_RANDOM_WRITE_BLOCK
;	$FCB_RANDOM_READ_BLOCK
;	$FCB_SEQ_READ
;	$FCB_SEQ_WRITE
;	$FCB_RANDOM_READ
;	$FCB_RANDOM_WRITE
;
;	Revision history:
;
;		Created: ARR 4 April 1983
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;				  times.  Change so successive closes work by
;				  always returning OK.	Also, detect I/O to
;				  already closed FCB and return EOF.
;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
;				  out of sft into FCB for reconnection
;
;	    A000   version 4.00	Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include cpmfcb.inc
	include filemode.inc
	include bugtyp.inc
	.cref
	.list


	I_need	DMAAdd,DWORD		; current user's DMA address
	I_need	OpenBuf,128		; buffer for translating paths
	I_need	ThisSFT,DWORD		; SFT in use
	I_need	sftFCB,DWORD		; pointer to SFTs for FCB cache
	I_need	FCBLRU,WORD		; least recently used count
	I_need	DISK_FULL,BYTE		; flag for disk full

	I_need	LocalSFT,DWORD		;Cache for new FCB implementation

; Defintions for FCBOp flags

Random	=   2				; random operation
FCBRead =   4				; doing a read
Block	=   8				; doing a block I/O


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


	EXTRN	DOS_Read:NEAR, DOS_Write:NEAR
	EXTRN	DOS_Open:NEAR, DOS_Create:NEAR


 Break <GetRR - return the random record field in DX:AX>
;---------------------------------------------------------------------------
;
;
;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
;	from the FCB pointed to by DS:SI
;
;   Inputs:	DS:SI point to an FCB
;		BX has record size
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

Procedure   GetRR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AX,WORD PTR [SI.FCB_RR] ; get low order part
	MOV	DX,WORD PTR [SI.FCB_RR+2]   ; get high order part
	CMP	BX,64			; ignore MSB of RR if recsiz > 64
	JB	GetRRBye
	XOR	DH,DH
GetRRBye:
	return
EndProc GetRR

Break <GetExtent - retrieve next location for sequential IO>
;---------------------------------------------------------------------------
;
;   GetExtent - Construct the next record to perform I/O from the EXTENT and
;	NR fields in the FCB.
;
;   Inputs:	DS:SI - point to FCB
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

Procedure   GetExtent,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,[SI.fcb_NR]		; get low order piece
	MOV	DX,[SI.fcb_EXTENT]	; get high order piece
	SHL	AL,1
	SHR	DX,1
	RCR	AL,1			; move low order bit of DL to high order of AH
	MOV	AH,DL
	MOV	DL,DH
	XOR	DH,DH
	return
EndProc GetExtent

Break <SetExtent - update the extent/NR field>
;---------------------------------------------------------------------------
;
;   SetExtent - change the position of an FCB by filling in the extent/NR
;	fields
;
;   Inputs:	DS:SI point to FCB
;		DX:AX is a record location in file
;   Outputs:	Extent/NR fields are filled in
;   Registers modified: CX
;---------------------------------------------------------------------------

Procedure SetExtent,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX,DX>
	MOV	CX,AX
	AND	AL,7FH			; next rec field
	MOV	[SI.fcb_NR],AL
	AND	CL,80H			; save upper bit
	SHL	CX,1
	RCL	DX,1			; move high bit of CX to low bit of DX
	MOV	AL,CH
	MOV	AH,DL
	MOV	[SI.fcb_EXTENT],AX	; all done
	RESTORE <DX,AX>
	return
EndProc SetExtent

Break <GetExtended - find FCB in potential extended fcb>
;---------------------------------------------------------------------------
;
;   GetExtended - Make DS:SI point to FCB from DS:DX
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	DS:SI point to the FCB part
;		zeroflag set if not extended fcb
;   Registers modified: SI
;---------------------------------------------------------------------------

Procedure   GetExtended,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	SI,DX			; point to Something
	CMP	BYTE PTR DS:[SI],-1	; look for extention
	JNZ	GetBye			; not there
	ADD	SI,7			; point to FCB
GetBye:
	CMP	SI,DX			; set condition codes
	return
EndProc GetExtended

Break <GetRecSize - return in BX the FCB record size>
;---------------------------------------------------------------------------
;
;   GetRecSize - return in BX the record size from the FCB at DS:SI
;
;   Inputs:	DS:SI point to a non-extended FCB
;   Outputs:	BX contains the record size
;   Registers modified: None
;---------------------------------------------------------------------------

Procedure   GetRecSize,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	BX,[SI.fcb_RECSIZ]	; get his record size
	OR	BX,BX			; is it nul?
	retnz
	MOV	BX,128			; use default size
	MOV	[SI.fcb_RECSIZ],BX	; stuff it back
	return
EndProc GetRecSize

BREAK <FCBIO - do internal FCB I/O>
;---------------------------------------------------------------------------
;
;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
;
;   Inputs:	FCBOP flags which operations need to be performed
;		DS:DX point to FCB
;		CX may have count of number of records to xfer
;   Outputs:	AL has error code
;   Registers modified: all
;---------------------------------------------------------------------------

Procedure   FCBIO,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

PUBLIC FCBIO001S,FCBIO001E
FCBIO001S:
	LocalVar    FCBErr,BYTE
	LocalVar    cRec,WORD
	LocalVar    RecPos,DWORD
	LocalVar    RecSize,WORD
	LocalVar    bPos,DWORD
	LocalVar    cByte,WORD
	LocalVar    cResult,WORD
	LocalVar    cRecRes,WORD
	LocalVar    FCBOp,BYTE
FCBIO001E:
	Enter

FEOF	EQU	1
FTRIM	EQU	2
	MOV	FCBOp,AL
	MOV	FCBErr,0		;   FCBErr = 0;
	invoke	GetExtended		;   FCB = GetExtended ();
	TESTB	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
	JNZ	GetPos
	MOV	CX,1			;	cRec = 1;
GetPos:
	MOV	cRec,CX 		;*Tail coalesce
	invoke	GetExtent		;   RecPos = GetExtent ();
	invoke	GetRecSize		;   RecSize = GetRecSize ();
	MOV	RecSize,BX
	TESTB	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
	JZ	GetRec
	invoke	GetRR			;	RecPos = GetRR ();
GetRec:
	MOV	RecPosL,AX		;*Tail coalesce
	MOV	RecPosH,DX
	invoke	SetExtent		;   SetExtent (RecPos);
	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
	MUL	BX
	MOV	DI,AX
	MOV	AX,RecPosL
	MUL	BX
	ADD	DX,DI
	MOV	bPosL,AX
	MOV	bPosH,DX
	MOV	AX,cRec 		;   cByte = cRec * RecSize;
	MUL	BX
	MOV	cByte,AX

;hkn; 	SS override
	ADD	AX,WORD PTR DMAAdd	;   if (cByte+DMA > 64K) {
	ADC	DX,0
	JZ	DoOper
	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;

;hkn; 	SS override
	MOV	AX,WORD PTR DMAAdd	;	cRec = (64K-DMA)/RecSize;
	NEG	AX
	JNZ	DoDiv
	DEC	AX
DoDiv:
	XOR	DX,DX
	DIV	BX
	MOV	cRec,AX
	MUL	BX			;	cByte = cRec * RecSize;
	MOV	cByte,AX		;	}
DoOper:
	XOR	BX,BX
	MOV	cResult,BX		;   cResult = 0;
	CMP	cByte,BX		;   if (cByte <> 0 ||
	JNZ	DoGetExt
	TESTB	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
	JZ	DoGetExt
IF	DEBUG
	JMP	SkipOp
ELSE
	JMP	short SkipOp
ENDIF

DoGetExt:
	invoke	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
	JNC	ContinueOp
FCBDeath:
	invoke	FCB_Ret_Err		; signal error, map for extended
	MOV	cRecRes,0		; no bytes transferred
	MOV	FCBErr,FEOF		;	    return FTRIM;
	JMP	FCBSave 		; bam!
ContinueOp:
	Assert	ISSFT,<ES,DI>,"ContinueOP"
	MOV	AX,WORD PTR [SI].fcb_filsiz
	MOV	WORD PTR ES:[DI].sf_size,AX
	MOV	AX,WORD PTR [SI].fcb_filsiz+2
	MOV	WORD PTR ES:[DI].sf_size+2,AX
	MOV	AX,bPosL
	MOV	DX,bPosH
	MOV	WORD PTR ES:[DI.sf_position],AX
	XCHG	WORD PTR ES:[DI.sf_position+2],DX
	PUSH	DX			; save away Open age.
	MOV	CX,cByte		;	cResult =

;hkn; DOS_Read is in DOSCODE
	MOV	DI,OFFSET DOSCODE:DOS_Read ;	    *(OP&FCBRead ? DOS_Read
	TESTB	FCBOp,FCBRead		;			 : DOS_Write)(cRec);
	JNZ	DoContext

;hkn; DOS_Write is in DOSCODE
	MOV	DI,OFFSET DOSCODE:DOS_Write
DoContext:
	SAVE	<BP,DS,SI>

;hkn; SS is DOSDATA
	Context DS
;; Fix for disk full
	CALL	DI
	RESTORE <SI,DS,BP>
	ASSUME	DS:NOTHING
	JC	FCBDeath
	CMP	BYTE PTR [DISK_FULL],0	; treat disk full as error
	JZ	NODSKFULL
	MOV	BYTE PTR [DISK_FULL],0	; clear the flag
	MOV	FCBerr,FEOF		; set disk full flag
NODSKFULL:
;; Fix for disk full
	MOV	cResult,CX
	invoke	SaveFCBInfo		;	SaveFCBInfo (FCB);
	Assert	ISSFT,<ES,DI>,"FCBIO/SaveFCBInfo"
;	BUGBUG - why not just use the SF_OPENAGE symbol?
	.errnz	SF_POSITION+2-SF_OPENAGE
	POP	WORD PTR ES:[DI].sf_Position+2	; restore open age
	MOV	AX,WORD PTR ES:[DI].sf_size
	MOV	WORD PTR [SI].fcb_filsiz,AX
	MOV	AX,WORD PTR ES:[DI].sf_size+2
	MOV	WORD PTR [SI].fcb_filsiz+2,AX
					;	}
SkipOp:
	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
	XOR	DX,DX
	DIV	RecSize
	MOV	cRecRes,AX
	ADD	RecPosL,AX		;   RecPos += cRecResult;
	ADC	RecPosH,0
;
; If we have not gotten the expected number of records, we signal an EOF
; condition.  On input, this is EOF.  On output this is usually disk full.
; BUT...  Under 2.0 and before, all device output IGNORED this condition.  So
; do we.
;
	CMP	AX,cRec 		;   if (cRecRes <> cRec)
	JZ	TryBlank
	TESTB	FCBOp,FCBRead		;	if (OP&FCBRead || !DEVICE)
	JNZ	SetEOF
	TESTB	ES:[DI].sf_flags,devid_device
	JNZ	TryBlank
SetEOF:
	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
TryBlank:				;
	OR	DX,DX			;   if (cResult%RecSize <> 0) {
	JZ	SetExt
	ADD	RecPosL,1		;	RecPos++;
	ADC	RecPosH,0
	TESTB	FCBOp,FCBRead		;	if(OP&FCBRead) <> 0) {
	JZ	SetExt
	INC	cRecRes 		;	cRecRes++;
	MOV	FCBErr,FTRIM + FEOF	;	FCBErr = FTRIM | FEOF;
	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
	SUB	CX,DX			;	       DMA+cResult);
	XOR	AL,AL

;hkn; 	SS override
	LES	DI,DMAAdd
	ADD	DI,cResult
	REP	STOSB			;   }	}
SetExt:
	MOV	DX,RecPosH
	MOV	AX,RecPosL
	TESTB	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
	JZ	DoSetExt
	TESTB	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
	JZ	TrySetRR
DoSetExt:
	invoke	SetExtent		;	SetExtent (RecPos, FCB);
TrySetRR:
	TESTB	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	TryReturn
	MOV	WORD PTR [SI.FCB_RR],AX ;	FCB->RR = RecPos;
	MOV	BYTE PTR [SI.FCB_RR+2],DL
	CMP	[SI.fcb_RECSIZ],64
	JAE	TryReturn
	MOV	[SI+fcb_RR+2+1],DH	; Set 4th byte only if record size < 64
TryReturn:
	TESTB	FCBOP,FCBRead		;   if (!(FCBOP & FCBREAD)) {
	JNZ	FCBSave
	SAVE	<DS>			;	FCB->FDate = date;
	Invoke	Date16			;	FCB->FTime = time;
	RESTORE <DS>
	MOV	[SI].FCB_FDate,AX
	MOV	[SI].FCB_FTime,DX	;	}
FCBSave:
	TESTB	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	DoReturn
	MOV	CX,cRecRes		;	user_CX = cRecRes;
	invoke	Get_User_Stack
	MOV	[SI.User_CX],CX
DoReturn:
	MOV	AL,FCBErr		;   return (FCBERR);
	Leave
	return
EndProc FCBIO

Break <$FCB_Open - open an old-style FCB>
;---------------------------------------------------------------------------
;
;   $FCB_Open - CPM compatability file open.  The user has formatted an FCB
;	for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;---------------------------------------------------------------------------

Procedure $FCB_Open,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AX,sharing_Compat+Open_For_Both

;hkn; DOS_Open is in DOSCODE
	MOV	CX,OFFSET DOSCODE:DOS_Open
;
; The following is common code for Creation and openning of FCBs.  AX is
; either attributes (for create) or open mode (for open)...  DS:DX points to
; the FCB
;
DoAccess:
	SAVE	<DS,DX,CX,AX>		; save FCB pointer away

;hkn; 	OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf
	invoke	TransFCB		; crunch the fcb
	RESTORE <AX,CX,DX,DS>	; get fcb
	JNC	FindFCB 		; everything seems ok
FCBOpenErr:
;
; AL has error code
;
	transfer    FCB_Ret_Err
FindFCB:
	invoke	GetExtended		; DS:SI will point to FCB

	push	ax
	mov	al,1			;indicate Open/Create operation
	invoke	LRUFCB			; get a sft entry (no error)
	pop	ax

	JC	HardMessage
	ASSUME	ES:NOTHING

;	Message 1,"Entering "
;	MessageNum  ES
;	Message 1,":"
;	MessageNum  DI
;	Message 1,<13,10>

	MOV	ES:[DI].sf_mode,sf_ISFCB
	SAVE	<DS,SI,BX>		; save fcb pointer
	MOV	SI,CX

;hkn; SS is DOSDATA
	Context DS			; let DOS_Open see variables
	CALL	SI			; go open the file
	RESTORE <BX,SI,DS>		; get fcb
	ASSUME	DS:NOTHING

;hkn; SS override
	LES	DI,ThisSFT		; get sf pointer
	JNC	FCBOK			; operation succeeded
	Assert	ISSFT,<ES,DI>,"DeadFCB"
failopen:
	PUSH	AX
	MOV	AL,"R"                  ; clear out field (free sft)
	invoke	BlastSFT
	POP	AX
	CMP	AX,error_too_many_open_files
	JZ	HardMessage
	CMP	AX,error_sharing_buffer_exceeded
	jnz	DeadFCB
HardMessage:
	PUSH	AX
	invoke	FCBHardErr
	POP	AX
DeadFCB:
	transfer    FCB_Ret_Err
FCBOK:
	invoke	IsSFTNet		       ;AN007;F.C. >32mb  Non Fat file?
	JNZ	FCBOK2			       ;AN007;F.C. >32mb  yes
	invoke	CheckShare		       ;AN000;F.C. >32mb  share around?
	JNZ	FCBOK2			       ;AN000;F.C. >32mb  yes
;SR;
; If we reach here, we know we have got a local SFT. Let's update the 
; LocalSFT variable to reflect this.
;
	mov	word ptr LocalSFT,di	;
	mov	word ptr LocalSFT+2,es; Store the SFT address
;SR;
; The check below is not valid anymore since we regenerate for media > 32M.
;
;	CMP	WORD PTR ES:[DI].sf_dirsec+2,0 ;AN000;F.C. >32mb  if dirsec >32mb
;	JZ	FCBOK2			       ;AN000;F.C. >32mb    then error
;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
;	JMP	failopen		       ;AN000;F.C. >32mb

FCBOK2:

	INC	ES:[DI].sf_ref_count	; increment reference count
	invoke	SaveFCBInfo
	Assert	ISSFT,<ES,DI>,"FCBOK"

	TESTB	ES:[DI].sf_flags,devid_device
	JNZ	FCBNoDrive		; do not munge drive on devices
	MOV	AL,DS:[SI]		; get drive byte
	invoke	GetThisDrv		; convert
	INC	AL
	MOV	DS:[SI],AL		; stash in good drive letter
FCBNoDrive:
	MOV	[SI].FCB_RecSiz,80h	; stuff in default record size
	MOV	AX,ES:[DI].SF_Time	; set time
	MOV	[SI].FCB_FTime,AX
	MOV	AX,ES:[DI].SF_Date	; set date
	MOV	[SI].FCB_FDate,AX
	MOV	AX,WORD PTR ES:[DI].SF_Size ; set sizes
	MOV	[SI].FCB_FILSIZ,AX
	MOV	AX,WORD PTR ES:[DI].SF_Size+2
	MOV	[SI].FCB_FILSIZ+2,AX
	XOR	AX,AX			; convenient zero
	MOV	[SI].FCB_Extent,AX	; point to beginning of file
;
; We must scan the set of FCB SFTs for one that appears to match the current
; one.	We cheat and use CheckFCB to match the FCBs.
;

;hkn; 	SS override
	LES	DI,SFTFCB		; get the pointer to head of the list
	MOV	AH,BYTE PTR ES:[DI].sfCount ; get number of SFTs to scan
OpenScan:
	CMP	AL,[SI].fcb_sfn 	; don't compare ourselves
	JZ	SkipCheck
	SAVE	<AX>			; preserve count
	invoke	CheckFCB		; do they match
	RESTORE <AX>		; get count back
	JNC	OpenFound		; found a match!
SkipCheck:
	INC	AL			; advance to next FCB
	CMP	AL,AH			; table full?
	JNZ	OpenScan		; no, go for more
OpenDone:
	xor	al,al			; return success
	return
;
; The SFT at ES:DI is the one that is already in use for this FCB.  We set the
; FCB to use this one.	We increment its ref count.  We do NOT close it at all.
; Consider:
;
;   open (foo)	delete (foo) open (bar)
;
; This causes us to recycle (potentially) bar through the same local SFT as
; foo even though foo is no longer needed; this is due to the server closing
; foo for us when we delete it.  Unfortunately, we cannot see this closure.
; If we were to CLOSE bar, the server would then close the only reference to
; bar and subsequent I/O would be lost to the redirector.
;
; This gets solved by NOT closing the sft, but zeroing the ref count
; (effectively freeing the SFT) and informing the sharer (if relevant) that
; the SFT is no longer in use.	Note that the SHARER MUST keep its ref counts
; around.  This will allow us to access the same file through multiple network
; connections and NOT prematurely terminate when the ref count on one
; connection goes to zero.
;
OpenFound:
	MOV	[SI].fcb_SFN,AL 	; assign with this
	INC	ES:[DI].sf_ref_count	; remember this new invocation
	MOV	AX,FCBLRU		; update LRU counts
	MOV	ES:[DI].sf_LRU,AX
;
; We have an FCB sft that is now of no use.  We release sharing info and then
; blast it to prevent other reuse.
;

;hkn; SS is DOSDATA
	context DS
	LES	DI,ThisSFT
	DEC	ES:[DI].sf_ref_count	; free the newly allocated SFT
	invoke	ShareEnd
	Assert	ISSFT,<ES,DI>,"Open blasting"
	MOV	AL,'C'
	invoke	BlastSFT
	JMP	OpenDone
EndProc $FCB_Open

BREAK	<$FCB_Create - create a new directory entry>
;----------------------------------------------------------------------------
;
;   $FCB_Create - CPM compatability file create.  The user has formatted an
;	FCB for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;----------------------------------------------------------------------------

Procedure $FCB_Create,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; DOS_Create is in DOSCODE
	MOV	CX,OFFSET DOSCODE:DOS_Create	; routine to call
	XOR	AX,AX			; attributes to create
	invoke	GetExtended		; get extended FCB
	JZ	DoAccessJ		; not an extended FCB
	MOV	AL,[SI-1]		; get attributes
DoAccessJ:
	JMP	DoAccess		; do dirty work
EndProc $FCB_Create

BREAK <$FCB_Random_write_Block - write a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
;	and write a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = 0 write was successful and the FCB position is updated
;		AL <> 0 Not enough room on disk for the output
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Write_Block,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+Block
	JMP	FCBIO

EndProc $FCB_Random_Write_Block

BREAK <$FCB_Random_Read_Block - read a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
;	and read a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Read_Block,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+FCBRead+Block
	JMP	FCBIO
EndProc $FCB_Random_Read_Block

BREAK <$FCB_Seq_Read - read the next record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
;	memory
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Seq_Read,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,FCBRead
	JMP	FCBIO
EndProc $FCB_Seq_Read

BREAK <$FCB_Seq_Write - write the next record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
;	file
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Seq_Write,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,0
	jmp	FCBIO

EndProc $FCB_SEQ_WRITE

BREAK <$FCB_Random_Read - Read a single record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
;	record from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Read,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+FCBRead
	jmp	FCBIO			; single block
EndProc $FCB_RANDOM_READ

BREAK <$FCB_Random_Write - write a single record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
;	a record to it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Write,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random
	jmp	FCBIO
EndProc $FCB_RANDOM_WRITE

DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\finfo.asm ===
TITLE	FILE_INFO - Internal Get/Set File Info routines
	NAME	FILE_INFO

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level routines for returning file information and setting file
;	attributes
;
;	GET_FILE_INFO
;	SET_FILE_ATTRIBUTE
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	M025: Return access_denied if attempting to set
;	      attribute of root directory.
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include fastxxxx.inc
	include fastopen.inc
	include mult.inc
	.cref
	.list

Installed = TRUE

	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	NoSetDir,BYTE
	i_need	THISDRV,BYTE
	I_need	EXTERR_CLASS,BYTE
	I_need	EXTERR_ACTION set
	I_need	EXTERR_LOCUS,BYTE
	i_need	DMAADD,DWORD
	i_need	FastOpenFlg,BYTE

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


SUBTTL GET_FILE_INFO -- Get File Information
PAGE
;----------------------------------------------------------------------------
;
; Procedure Name : GET_FILE_INFO
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Get Information about a file
; Returns:
;	CARRY CLEAR
;	    AX = Attribute of file
;	    CX = Time stamp of file
;	    DX = Date stamp of file
;	    BX:DI = Size of file (32 bit)
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------


	procedure   GET_FILE_INFO,NEAR

;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	DOSAssume   <DS>,"Get_File_Info"
	ASSUME	ES:NOTHING

	Invoke	TestNet
	JNC	Local_Info

IF NOT Installed
	transfer NET_GET_FILE_INFO
ELSE
	MOV	AX,(multNET SHL 8) OR 15
	INT	2FH
	return
ENDIF

LOCAL_INFO:
	EnterCrit   critDisk
	MOV	[NoSetDir],1		; if we find a dir, don't change to it
	invoke	Get_FAST_PATH
info_check:
	JNC	info_check_dev

NO_PATH:
	DOSAssume   <DS>,"No_Path"
	ASSUME	ES:NOTHING

	JNZ	bad_path
	OR	CL,CL
	JZ	bad_path
info_no_file:
	MOV	AX,error_file_not_found
BadRet:
	STC
justRet:
	LeaveCrit   critDisk
	return

bad_path:
	MOV	AX,error_path_not_found
	jmp	BadRet

info_check_dev:
	OR	AH,AH
	JS	info_no_file		; device
;SR;
; If root dir then CurBuf == -1. Check for this case and return subdir attr
;for a root dir
;
	cmp	word ptr CurBuf,-1		;is it a root dir?
	jne	not_root		;no, CurBuf ptr is valid

	xor	ah,ah
	mov	al,ATTR_DIRECTORY
	clc
	jmp	short justret
not_root:

	PUSH	DS
	MOV	DS,WORD PTR [CURBUF+2]
ASSUME	DS:NOTHING
	MOV	SI,BX
	XOR	BX,BX			; Assume size=0 (dir)
	MOV	DI,BX
	MOV	CX,[SI.dir_time]
	MOV	DX,[SI.dir_date]
	XOR	AH,AH
	MOV	AL,[SI.dir_attr]
	TEST	AL,attr_directory
	JNZ	NO_SIZE
	MOV	DI,[SI.dir_size_l]
	MOV	BX,[SI.dir_size_h]
NO_SIZE:
	POP	DS
	CLC
	jmp	JustRet
EndProc GET_FILE_INFO

Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
;-------------------------------------------------------------------------------
;
; Procedure Name : SET_FILE_ATTRIBUTE
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] is attribute of search (determines what files may be found)
;	AX is new attributes to give to file
; Function:
;	Set File Attributes
; Returns:
;	CARRY CLEAR
;	    No error
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to set an attribute which cannot be set
;			(attr_directory, attr_volume_ID)
;		error_sharing_violation
;			Sharing mode of file did not allow the change
;			(this request requires exclusive write/read access)
;			(INT 24H generated)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

	procedure   SET_FILE_ATTRIBUTE,NEAR

;hkn; set_file_attr is called from file.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	DOSAssume   <DS>,"Set_File_Attribute"
    ASSUME ES:NOTHING

	TEST	AX,NOT attr_changeable
	JZ	set_look
BAD_ACC:
	MOV	ExtErr_Locus,errLoc_UNK
	MOV	ExtErr_Class,errClass_Apperr
	MOV	ExtErr_Action,errAct_Abort
	MOV	AX,error_access_denied
	STC
	return

set_look:
	Invoke	TestNet
	JNC	Local_Set

IF NOT Installed
	transfer NET_SEQ_SET_FILE_ATTRIBUTE
ELSE
	PUSH	AX
	MOV	AX,(multNET SHL 8) OR 14
	INT	2FH
	POP	BX			; clean stack
	return
ENDIF

LOCAL_SET:
	EnterCrit   critDisk
	PUSH	AX			; Save new attributes
	MOV	[NoSetDir],1		; if we find a dir, don't change to it
	invoke	GetPath 		; get path through fastopen if there	 ;AC000;
	JNC	set_check_device
	POP	BX			; Clean stack (don't zap AX)
	JMP	NO_PATH

set_check_device:
	OR	AH,AH
	JNS	set_check_share
	POP	AX
	LeaveCrit   critDisk
	JMP	BAD_ACC 		; device

set_check_share:
	POP	AX			; Get new attributes

	cmp	word ptr [CURBUF], -1	; M025: Q: is this the root dir
	je	cannot_set_root		; M025: Y: return error

	invoke	REN_DEL_Check
	JNC	set_do
	MOV	AX,error_sharing_violation
	jmp	short	ok_bye

cannot_set_root:			; M025:
	mov	ax, error_access_denied	; M025: return error is attempting
	stc				; M025: to set attr. of root
	jmp	short ok_bye		; M025:

set_do:
	LES	DI,[CURBUF]
	AND	BYTE PTR ES:[BX].dir_attr,NOT attr_changeable
	OR	BYTE PTR ES:[BX].dir_attr,AL

	TEST	ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	ES:[DI.buf_flags],buf_dirty
yesdirty:
	MOV	AL,[THISDRV]
;;;; 10/1/86 F.C update fastopen cache
	PUSH	DX
	PUSH	DI
	MOV	AH,0		  ; dir entry update
	MOV	DL,AL		  ; drive number A=0,B=1,,
	MOV	DI,BX		  ; ES:DI -> dir entry
	invoke	FastOpen_Update
	POP	DI
	POP	DX
;;;; 9/11/86 F.C update fastopen cache
	invoke	FlushBuf
	JNC	OK_BYE
	MOV	AX,error_file_not_found
OK_BYE:
	LeaveCrit   critDisk
	return

EndProc SET_FILE_ATTRIBUTE



	procedure   GET_FAST_PATH,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING

;hkn; use SS override for FastOpenFlg
	OR	[FastOpenFlg],FastOpen_Set ;FO. trigger fastopen		;AN000;
	invoke	GetPath
	PUSHF			       ;FO.					;AN000;
	AND    [FastOpenFlg],Fast_yes  ;FO. clear all fastopen flags		;AN000;
	POPF			       ;FO.					;AN000;
	return

EndProc GET_FAST_PATH

DOSCODE	ENDS
    END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\getset.asm ===
TITLE  GETSET - GETting and SETting MS-DOS system calls
	NAME   GETSET

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; ==========================================================================
;**	GETSET - System Calls which get and set various things
;
;	$GET_VERSION
;	$GET_VERIFY_ON_WRITE
;	$SET_VERIFY_ON_WRITE
;	$INTERNATIONAL
;	$GET_DRIVE_FREESPACE
;	$GET_DMA
;	$SET_DMA
;	$GET_DEFAULT_DRIVE
;	$SET_DEFAULT_DRIVE
;	$GET_INTERRUPT_VECTOR
;	$SET_INTERRUPT_VECTOR
;	RECSET
;	$CHAR_OPER
;	$GetExtendedError		DOS 3.3
;	Get_Global_CdPg			DOS 4.0
;	$ECS_CALL			DOS 4.0
;
;	Revision history:
;
;	Created: ARR 30 March 1983
;
;	A000   	version 4.0   Jan. 1988
;	A006   	D503-- fake version for IBMCACHE
;	A008   	P4070- fake version for MS WINDOWS
;
;	DOS5 	added new getversion call AX=3001H -- 4/3/90
;		Returns flags in BH:
;
;		 	bits 0-2 = DOS internal revision
;			bits 3-7 = DOS type flags
;			     bit 3    = DOS is in ROM
;			     bit 4    = DOS in in HMA
;			     bits 5-7 = reserved
;
;	M004 - MS PASCAL 3.2 support. Please see under tag M003 in dossym.inc
;	       7/30/90
;
;       M007 - Change to new style GetVersion call - 8/6/90
;
;	M068 - use a count value (A20OFF_COUNT) rather than a bit to 
;	       indicate to dos dispatcher to turn  a20 off before iret. 
;	       See M004.
;
; ==========================================================================

.xlist
.xcref
	INCLUDE version.inc
	INCLUDE dosseg.inc
	INCLUDE dossym.inc
	INCLUDE devsym.inc
	INCLUDE doscntry.inc
	INCLUDE mult.inc
	INCLUDE pdb.inc
.cref
.list

IFNDEF	ALTVECT
	ALTVECT EQU	0			; FALSE
ENDIF

; ==========================================================================

DosData SEGMENT WORD PUBLIC 'DATA'

	EXTRN	USERNUM 	:WORD
	EXTRN	MSVERS		:WORD
	EXTRN	VERFLG		:BYTE
	EXTRN	CNTCFLAG	:BYTE
	EXTRN	DMAADD		:DWORD
	EXTRN	CURDRV		:BYTE
	EXTRN	chSwitch	:BYTE
	EXTRN	COUNTRY_CDPG	:byte		;DOS 3.3
	EXTRN	CDSCount	:BYTE
	EXTRN	ThisCDS 	:DWORD
	EXTRN	EXTERR		:WORD
	EXTRN	EXTERR_ACTION	:BYTE
	EXTRN	EXTERR_CLASS	:BYTE
	EXTRN	EXTERR_LOCUS	:BYTE
	EXTRN	EXTERRPT	:DWORD
	EXTRN	UCASE_TAB	:BYTE
	EXTRN	FILE_UCASE_TAB	:BYTE
	EXTRN	InterCon	:BYTE
	EXTRN	CURRENTPDB	:WORD

	EXTRN	DBCS_TAB	:BYTE
	EXTRN	NLS_YES 	:BYTE
	EXTRN	NLS_yes2	:BYTE
	EXTRN	NLS_NO		:BYTE
	EXTRN	NLS_no2 	:BYTE

	EXTRN	Special_version :WORD
	EXTRN	Fake_Count	:BYTE
	EXTRN	A20OFF_COUNT	:BYTE	; M068, M004
	EXTRN	DOS_FLAG	:BYTE	; M068

DosData ENDS

; ==========================================================================

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg

	EXTRN	CurrentPDB	:WORD

	EXTRN	Get_User_Stack	:NEAR	; return pointer to user stack

BREAK <$Get_Version -- Return DOS version number>
; =========================================================================
;	$Get_Version - Return DOS Version Number
;
;	Fake_Count is used to lie about the version numbers to support
;	old binarys.  See ms_table.asm for more info.
;
;	ENTRY	none
;	EXIT	(bl:cx) = user number (24 bits)
;		(al.ah) = version # (in binary)
;	
;		if input al = 00
;		  (bh) = OEM number			
;		else if input al = 01
;		  (bh) = version flags
;		 
;		       	 bits 0-2 = DOS internal revision
;		       	 bits 3-7 = DOS type flags
;		              bit 3    = DOS is in ROM
;		              bit 4    = DOS in in HMA
;		              bits 5-7 = reserved
;               M007 change - only bit 3 is now valid.  Other bits
;               are 0 when AL = 1

;	USES	all
; =========================================================================

PROCEDURE $Get_Version ,NEAR

	context DS			; SS is DOSDATA

	mov	BX,[UserNum + 2]
	mov	CX,[UserNum]

		;If AL == 1, ROMDOS will return BH = dos internal version # &
		;DOS flags

	cmp	AL,1
	jnz	Norm_Vers

ifdef ROMDOS

	mov	BH, DOSINROM            ; Just set the bit for ROM version

else

        xor     bh,bh                   ; Otherwise return 0
endif                                   ;M007 end
                                        ;
norm_vers:				; MSVERS is a label in TABLE segment
	push	DS			; Get the version number from the
	mov	DS,CurrentPDB 		; current app's PSP segment
	mov	AX,DS:[PDB_Version] 	; AX = DOS version number
	pop	DS


	call	Get_User_Stack 		; Returns DS:SI --> Caller's stack

	ASSUME	DS:NOTHING

	mov	[SI.User_AX],AX		; Put values for return registers 
	mov	[SI.User_BX],BX		; in the proper place on the user's
	mov	[SI.User_CX],CX		; stack addressed by DS:SI

	return

ENDPROC $Get_Version

; =========================================================================


BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
; =========================================================================
;**	$Get_Verify_On_Write - Get Status of Verify on write flag
;
;	ENTRY	none
;	EXIT	(al) = value of VERIFY flag
;	USES	all
; =========================================================================

procedure   $GET_VERIFY_ON_WRITE,NEAR

;hkn; SS override
	MOV	AL,[VERFLG]
	return

EndProc $GET_VERIFY_ON_WRITE



;**	$Set_Verify_On_Write - Set Status of Verify on write flag
;
;	ENTRY	(al) = value of VERIFY flag
;	EXIT	none
;	USES	all

procedure   $SET_VERIFY_ON_WRITE,NEAR

	AND	AL,1
;hkn; SS override
	MOV	[VERFLG],AL
	return

EndProc $SET_VERIFY_ON_WRITE

BREAK <$International - return country-dependent information>
;----------------------------------------------------------------------------
;
; Procedure Name : $INTERNATIONAL
;
; Inputs:
;	MOV	AH,International
;	MOV	AL,country	(al = 0 => current country)
;      [MOV	BX,country]
;	LDS	DX,block
;	INT	21
; Function:
;	give users an idea of what country the application is running
; Outputs:
;	IF DX != -1 on input (get country)
;	  AL = 0 means return current country table.
;	  0<AL<0FFH means return country table for country AL
;	  AL = 0FF means return country table for country BX
;	  No Carry:
;	     Register BX will contain the 16-bit country code.
;	     Register AL will contain the low 8 bits of the country code.
;	     The block pointed to by DS:DX is filled in with the information
;	     for the particular country.
;		BYTE  Size of this table excluding this byte and the next
;		BYTE  Country code represented by this table
;			A sequence of n bytes, where n is the number specified
;			by the first byte above and is not > internat_block_max,
;			in the correct order for being returned by the
;			INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.	=0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.	=0 12 hour clock  =1 24 hour
;		DWORD	Call address of case conversion routine
;		2 BYTE	Data list separator null terminated.
;	  Carry:
;	     Register AX has the error code.
;	IF DX = -1 on input (set current country)
;	  AL = 0 is an error
;	  0<AL<0FFH means set current country to country AL
;	  AL = 0FF means set current country to country BX
;	  No Carry:
;	    Current country SET
;	    Register AL will contain the low 8 bits of the country code.
;	  Carry:
;	     Register AX has the error code.
;-----------------------------------------------------------------------------

procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
	CMP	AL,0FFH
	JZ	BX_HAS_CODE		; -1 means country code is in BX
	MOV	BL,AL			; Put AL country code in BX
	XOR	BH,BH
BX_HAS_CODE:
	PUSH	DS
	POP	ES
	PUSH	DX
	POP	DI			; User buffer to ES:DI

;hkn; SS is DOSDATA
	context DS

	CMP	DI,-1
	JZ	international_set
	OR	BX,BX
	JNZ	international_find

;hkn; country_cdpg is in DOSDATA segment.
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	JMP	SHORT international_copy

international_find:
	MOV	BP,0			 ; flag it for GetCntry only
	CALL	international_get
	JC	errtn
	CMP	BX,0			 ; nlsfunc finished it ?
	JNZ	SHORT international_copy ; no, copy by myself
	MOV	BX,DX			 ; put country back
	JMP	SHORT international_ok3

international_get:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG
	CMP	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override

	retz				 ; return if equal
	MOV	DX,BX
	XOR	BX,BX			 ; bx = 0, default code page
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JNZ	interr			   ; not in memory
	or	bp,bp			 ; GetCntry ?
	JNZ	stcdpg
	CallInstall GetCntry,NLSFUNC,4	 ; get country info
	JMP	short chkok
stcdpg:
	CallInstall SetCodePage,NLSFUNC,3  ; set country info
chkok:
	or	al,al			   ; success ?
	retz				   ; yes
setcarry:
	STC				 ; set carry
	ret
interr:
	MOV	AL,0FFH 		   ; flag nlsfunc error
	JMP	setcarry

international_copy:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	MOV	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccDFormat

	MOV	CX,OLD_COUNTRY_SIZE

;hkn;	must set up DS to SS so that international info can be copied
	push	ds
	push	ss					; cs -> ss
	pop	ds

	REP	MOVSB			 ;copy country info

;hkn;	restore ds
	pop	ds

international_ok3:
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_BX],BX
international_ok:
	MOV	AX,BX		     ; Return country code in AX too.
	transfer SYS_RET_OK

international_set:

;hkn; ASSUME	DS:DOSGROUP
ASSUME	DS:DOSDATA

	MOV	BP,1		     ; flag it for SetCodePage only
	CALL	international_get
	JNC	international_ok
errtn:
	CMP	AL,0FFH
	JZ	errtn2
	transfer SYS_RET_ERR	     ; return what we got from NLSFUNC
errtn2:
	error	error_Invalid_Function	; NLSFUNC not existent


EndProc $INTERNATIONAL



BREAK <$GetExtCntry - return extended country-dependent information>
;---------------------------------------------------------------------------
;
; Procedure Name : $GetExtCntry
;
; Inputs:
;	if AL >= 20H
;	  AL= 20H    capitalize single char, DL= char
;	      21H    capitalize string ,CX= string length
;	      22H    capitalize ASCIIZ string
;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
;	      80H bit 0 = use normal upper case table
;		      1 = use file upper case table
;	   DS:DX points to string
;
;	else
;
;	MOV	AH,GetExtCntry	 ; DOS 3.3
;	MOV	AL,INFO_ID	( info type,-1	selects all)
;	MOV	BX,CODE_PAGE	( -1 = active code page )
;	MOV	DX,COUNTRY_ID	( -1 = active country )
;	MOV	CX,SIZE 	( amount of data to return)
;	LES	DI,COUNTRY_INFO ( buffer for returned data )
;	INT	21
; Function:
;	give users extended country dependent information
;	or capitalize chars
; Outputs:
;	  No Carry:
;	     extended country info is succesfully returned
;	  Carry:
;	     Register AX has the error code.
;	     AX=0, NO	 for YES/NO CHECK
;		1, YES
;-------------------------------------------------------------------------------

procedure   $GetExtCntry,NEAR	; DOS 3.3
	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
ifdef DBCS
	jnb	capcap
	jmp	notcap
else
	JB	notcap
endif
capcap: 				;
	TEST	AL,UPPER_TABLE		; which upper case table
	JNZ	fileupper		; file upper case

;hkn; UCASE_TAB in DOSDATA
	MOV	BX,OFFSET DOSDATA:UCASE_TAB+2 ; get normal upper case
	JMP	SHORT capit
fileupper:

;hkn; FILE_UCASE_TAB in DOSDATA
	MOV	BX,OFFSET DOSDATA:FILE_UCASE_TAB+2 ; get file upper case
capit:					;
	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
	JNZ	chkyes			; no
	MOV	AL,DL			; set up AL
	invoke	GETLET3 		; upper case it
	call	get_user_stack		; get user stack
	MOV	byte ptr [SI.user_DX],AL; user's DL=AL
	JMP	SHORT nono		; done
chkyes: 				;
	CMP	AL,CHECK_YES_NO 	; check YES or NO ?
	JNZ	capstring		; no
	XOR	AX,AX			; presume NO
IFDEF  DBCS				;
	PUSH	AX			;
	MOV	AL,DL			;
	invoke	TESTKANJ		; DBCS ?
	POP	AX			;
	JNZ	dbcs_char		; yes, return error
ENDIF					;
		      
;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
;hkn; included in yesno.asm in the DOSCODE segment.

	CMP	DL,cs:NLS_YES		; is 'Y' ?
	JZ	yesyes			; yes
	CMP	DL,cs:NLS_yes2		; is 'y' ?
	JZ	yesyes			; yes
	CMP	DL,cs:NLS_NO		; is  'N'?
	JZ	nono			; no
	CMP	DL,cs:NLS_no2		; is 'n' ?
	JZ	nono			; no
dbcs_char:				;
	INC	AX			; not YES or NO
yesyes: 				;
	INC	AX			; return 1
nono:					;
	transfer SYS_RET_OK		; done
capstring:				;
	MOV	SI,DX			; si=dx
	CMP	AL,CAP_STRING		; cap string ?
	JNZ	capascii		; no
	OR	CX,CX			; check count 0
	JZ	nono			; yes finished
concap: 				;
	LODSB				; get char
 IFDEF  DBCS				;
	invoke	TESTKANJ		; DBCS ?
	JZ	notdbcs 		; no
	INC	SI			; skip 2 chars
	DEC	CX			; bad input, one DBCS char at end
	JNZ	next99			 ; yes

notdbcs:				;
 ENDIF					;

	invoke	GETLET3 		; upper case it
	MOV	byte ptr [SI-1],AL	; store back
next99: 				;
	LOOP	concap			; continue
	JMP	nono			; done
capascii:				;
	CMP	AL,CAP_ASCIIZ		; cap ASCIIZ string ?
	JNZ	capinval		; no
concap2:				;
	LODSB				; get char
	or	al,al			; end of string ?
	JZ	nono			; yes
 IFDEF  DBCS				;
	invoke	TESTKANJ		; DBCS ?
	JZ	notdbcs2		; no
	CMP	BYTE PTR [SI],0 	; bad input, one DBCS char at end
	JZ	nono			; yes
	INC	SI			; skip 2 chars
	JMP	concap2 		;
notdbcs2:				;
 ENDIF					;
	invoke	GETLET3 		; upper case it
	MOV	byte ptr [SI-1],AL	; store back
	JMP	concap2 		; continue


notcap:
	CMP	CX,5			; minimum size is 5
	jb	short sizeerror

GEC_CONT:
;hkn; SS is DOSDATA
	context DS

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	CMP	DX,-1			; active country ?
	JNZ	GETCDPG 		; no

;hkn; use DS override to accesss country_cdpg fields
	MOV	DX,[SI.ccDosCountry]	; get active country id;smr;use DS

GETCDPG:
	CMP	BX,-1			; active code page?
	JNZ	CHKAGAIN		; no, check again

;hkn; use DS override to accesss country_cdpg fields
	MOV	BX,[SI.ccDosCodePage]	; get active code page id;smr;Use DS

CHKAGAIN:
	CMP	DX,[SI.ccDosCountry]	; same as active country id?;smr;use DS
	JNZ	CHKNLS			; no
	CMP	BX,[SI.ccDosCodePage]	; same as active code pg id?;smr;use DS
	JNZ	CHKNLS			; no
CHKTYPE:
	MOV	BX,[SI.ccSysCodePage]	; bx = sys code page id;smr;use DS
;	CMP	AL,SetALL		; select all?
;	JNZ	SELONE
;	MOV	SI,OFFSET DOSGROUP:COUNTRY_CDPG.ccNumber_of_entries
SELONE:
	PUSH	CX			; save cx
	MOV	CX,[SI.ccNumber_of_entries]	;smr;use DS
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccSetUcase;smr;CDPG in DOSDATA
NXTENTRY:
	CMP	AL,[SI] 		; compare info type;smr;use DS
	JZ	FOUNDIT
	ADD	SI,5			; next entry
	LOOP	NXTENTRY
	POP	CX
capinval:
	error	error_Invalid_Function	; info type not found
FOUNDIT:

	MOVSB				; move info id byte
	POP	CX			; retsore char count
	CMP	AL,SetCountryInfo	; select country info type ?
	JZ	setsize
	MOV	CX,4			; 4 bytes will be moved
	MOV	AX,5			; 5 bytes will be returned in CX
OK_RETN:

	REP	MOVSB			; copy info
	MOV	CX,AX			; CX = actual length returned
	MOV	AX,BX			; return sys code page in ax
GETDONE:
	call	get_user_stack		; return actual length to user's CX
	MOV	[SI.user_CX],CX
	transfer SYS_RET_OK
setsize:
	SUB	CX,3			; size after length field
	CMP	WORD PTR [SI],CX	; less than table size;smr;use ds
	JAE	setsize2		; no
	MOV	CX,WORD PTR [SI]	; truncate to table size;smr;use ds
setsize2:
	MOV	ES:[DI],CX		; copy actual length to user's
	ADD	DI,2			; update index
	ADD	SI,2
	MOV	AX,CX
	ADD	AX,3			; AX has the actual length
	JMP	OK_RETN 		; go move it
CHKNLS:
	XOR	AH,AH
	PUSH	AX			   ; save info type
	POP	BP			   ; bp = info type
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JZ	NLSNXT			   ;	 in memory
sizeerror:
	error	error_Invalid_Function
NLSNXT: CallInstall GetExtInfo,NLSFUNC,2  ;get extended info
	CMP	AL,0			   ; success ?
	JNZ	NLSERROR
	MOV	AX,[SI.ccSysCodePage]	; ax = sys code page id;smr;use ds;BUGBUG;check whether DS is OK after the above calls
	JMP	GETDONE
NLSERROR:
	transfer SYS_RET_ERR		; return what is got from NLSFUNC

EndProc $GetExtCntry

BREAK <$GetSetCdPg - get or set global code page>

;**	$GetSetCdPg - Get or Set Global Code Page
;
;   System call format:
;
;	MOV	AH,GetSetCdPg	; DOS 3.3
;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
;	MOV	BX,CODE_PAGE	( set code page only)
;	INT	21
;
;	ENTRY	(al) = n
;		(bx) = code page
;	EXIT	'C' clear
;		  global code page is set	(set global code page)
;		  (BX) = active code page id	(get global code page)
;		  (DX) = system code page id	(get global code page)
;		'C' set
;		  (AX) = error code

procedure   $GetSetCdPg,NEAR   ; DOS 3.3

;hkn; SS is DOSDATA
	context DS

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	CMP	AL,1		       ; get global code page
	JNZ	setglpg 	       ; set global cod epage
	MOV	BX,[SI.ccDosCodePage]  ; get active code page id;smr;use ds
	MOV	DX,[SI.ccSysCodePage]  ; get sys code page id;smr;use ds
	call	get_user_stack
ASSUME DS:NOTHING
	MOV	[SI.user_BX],BX        ; update returned bx
	MOV	[SI.user_DX],DX        ; update returned dx
OK_RETURN:
	transfer SYS_RET_OK
;hkn; ASSUME DS:DOSGROUP
ASSUME	DS:DOSDATA

setglpg:
	CMP	AL,2
	JNZ	nomem
;;;;;;; CMP	BX,[SI.ccDosCodePage]  ; same as active code page
;;;;;;; JZ	OK_RETURN	       ; yes
	MOV	DX,[SI.ccDosCountry]			;smr;use ds
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JNZ	nomem			   ; not in memory
	CallInstall SetCodePage,NLSFUNC,1  ;set the code page
	or	al,al			   ; success ?
	JZ	OK_RETURN		   ; yes
	CMP	AL,65			   ; set device code page failed
	JNZ	seterr
	MOV	AX,65
	MOV	[EXTERR],AX
	MOV	[EXTERR_ACTION],errACT_Ignore
	MOV	[EXTERR_CLASS],errCLASS_HrdFail
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	transfer   From_GetSet

seterr:
	transfer  SYS_RET_ERR
nomem:
	error	error_Invalid_Function ; function not defined
;
EndProc $GetSetCdPg


BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>


;**	$Get_Drive_Freespace - Return amount of drive free space
;
;	$Get_Drive_Freespace returns the # of free allocation units on a
;		drive.
;
;	This call returns the same info in the same registers (except for the
;	FAT pointer) as the old FAT pointer calls
;
;	ENTRY	DL = Drive number
;	EXIT	AX = Sectors per allocation unit
;		   = -1 if bad drive specified
;		On User Stack
;		    BX = Number of free allocation units
;		    DX = Total Number of allocation units on disk
;		    CX = Sector size

procedure   $GET_DRIVE_FREESPACE,NEAR

;hkn; SS is DOSDATA
	context DS

	MOV	AL,DL
	invoke	GetThisDrv		; Get drive
SET_AX_RET:
	JC	BADFDRV
	invoke	DISK_INFO
	XCHG	DX,BX
	JC	SET_AX_RET		; User FAILed to I 24
	XOR	AH,AH			; Chuck Fat ID byte
DoSt:
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_DX],DX
	MOV	[SI.user_CX],CX
	MOV	[SI.user_BX],BX
	MOV	[SI.user_AX],AX
	return
BADFDRV:
;	MOV	AL,error_invalid_drive	; Assume error
	invoke	FCB_RET_ERR
	MOV	AX,-1
	JMP	DoSt
EndProc $GET_DRIVE_FREESPACE

	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>


;**	$Get_DMA - Get Disk Transfer Address
;
;	ENTRY	none
;	EXIT	ES:BX is current transfer address
;	USES	all

procedure   $GET_DMA,NEAR

;hkn; ss override for DMAADD
	MOV	BX,WORD PTR [DMAADD]
	MOV	CX,WORD PTR [DMAADD+2]
	call	get_user_stack
    ASSUME DS:nothing
	MOV	[SI.user_BX],BX
	MOV	[SI.user_ES],CX
	return

EndProc $GET_DMA



;**	$Set_DMA - Set Disk Transfer Address
;
;	ENTRY	DS:DX is current transfer address
;	EXIT	none
;	USES	all

procedure   $SET_DMA,NEAR
;hkn; ss override for DMAADD
	MOV	WORD PTR [DMAADD],DX
	MOV	WORD PTR [DMAADD+2],DS
	return

EndProc $SET_DMA

	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>

;**	$Get_Default_Drive - Get Current Default Drive
;
;	ENTRY	none
;	EXIT	(AL) = drive number
;	USES	all

procedure   $GET_DEFAULT_DRIVE,NEAR

;hkn; SS override
	MOV	AL,[CURDRV]
	return

EndProc $GET_DEFAULT_DRIVE


;**	$Set_Default_Drive - Specify new Default Drive
;
;	$Set_Default_Drive sets a new default drive.
;
;	ENTRY	(DL) = Drive number for new default drive
;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD

procedure   $SET_DEFAULT_DRIVE,NEAR

	MOV	AL,DL
	INC	AL			; A=1, b=2...
	invoke	GetVisDrv		; see if visible drive
	JC	SETRET			; errors do not set
;	LDS	SI,ThisCDS		; get CDS
;	TEST	[SI].curdir_flags,curdir_splice ; was it spliced?
;	JNZ	SetRet			; yes, do not set

;hkn; SS override
	MOV	[CURDRV],AL		; no, set

SETRET:

;hkn; SS override
	MOV	AL,[CDSCOUNT]		; let user see what the count really is
	return

EndProc $SET_DEFAULT_DRIVE

BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>


;**	$Get_Interrupt_Vector - Get Interrupt Vector
;
;	$Get_Interrupt_Vector is the official way for user pgms to get the
;	contents of an interrupt vector.
;
;	ENTRY	(AL) = interrupt number
;	EXIT	(ES:BX) = current interrupt vector

procedure   $GET_INTERRUPT_VECTOR,NEAR

	CALL	RECSET
	LES	BX,DWORD PTR ES:[BX]
	call	get_user_stack
	MOV	[SI.user_BX],BX
	MOV	[SI.user_ES],ES
	return

EndProc $GET_INTERRUPT_VECTOR



;**	$Set_Interrupt_Vector - Set Interrupt Vector
;
;	$Set_Interrupt_Vector is the official way for user pgms to set the
;	contents of an interrupt vector.
;
;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
;	for explanation.
;
;	ENTRY	(AL) = interrupt number
;		(ds:dx) = desired new vector value
;	EXIT	none
;	USES	all

procedure   $SET_INTERRUPT_VECTOR,NEAR

	CALL	RECSET
	CLI				; Watch out!!!!! Folks sometimes use
	MOV	ES:[BX],DX		;   this for hardware ints (like timer).
	MOV	ES:[BX+2],DS
	STI
					; M004, M068 - Start
	test	[DOS_FLAG], EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	jnz	@f			; Y: go set count
	return				; N: return

@@:	
	cmp	[A20OFF_COUNT], 0	; Q: is count 0
	jne	@f			; N: done 
	mov	[A20OFF_COUNT], 1	; Y: set it to 1 to indicate to dos 
					; dispatcher to turn A20 Off before 
					; returning to user.
@@:
	ret				; M004, M068 - End
	
EndProc $SET_INTERRUPT_VECTOR

;hkn; Moved the TABLE segment to DOSDATA in msdata.inc
;	IF	ALTVECT
;TABLE	SEGMENT
;VECIN:
;; INPUT VECTORS
;Public GSET001S,GSET001E
;GSET001S  label byte
;	DB	22H			; Terminate
;	DB	23H			; ^C
;	DB	24H			; Hard error
;	DB	28H			; Spooler
;LSTVEC	DB	?			; ALL OTHER
;
;VECOUT:
;; GET MAPPED VECTOR
;	DB	int_terminate
;	DB	int_ctrl_c
;	DB	int_fatal_abort
;	DB	int_spooler
;LSTVEC2 DB	?			; Map to itself
;
;NUMVEC	=	VECOUT-VECIN
;GSET001E label byte
;TABLE	ENDS
;	ENDIF

procedure   RECSET,NEAR

	IF	ALTVECT
	context ES

;hkn; SS override for LSTVEC and LSTVEC2
	MOV	[LSTVEC],AL		; Terminate list with real vector
	MOV	[LSTVEC2],AL		; Terminate list with real vector
	MOV	CX,NUMVEC		; Number of possible translations

;hkn; VECIN is in DOSDATA
	MOV	DI,OFFSET DOSDATA:VECIN    ; Point to vectors

	REPNE	SCASB
	MOV	AL,ES:[DI+NUMVEC-1]	; Get translation
	ENDIF

	XOR	BX,BX
	MOV	ES,BX
	MOV	BL,AL
	SHL	BX,1
	SHL	BX,1
	return
EndProc recset

	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>


;**	$Char_Oper - Manipulate Switch Character
;
;	This function was put in to facilitate XENIX path/switch compatibility
;
;	ENTRY	AL = function:
;		    0 - read switch char
;		    1 - set switch char (char in DL)
;		    2 - read device availability
;			Always returns available
;		    3 - set device availability
;			No longer supported (NOP)
;	EXIT	(al) = 0xff iff error
;		(al) != 0xff if ok
;		  (dl) = character/flag, iff "read switch char" subfunction
;	USES	AL, DL
;
;	NOTE	This already obsolete function has been deactivated in DOS 5.0
;		The character / is always returned for subfunction 0,
;		subfunction 2 always returns -1, all other subfunctions are ignored.

procedure   $CHAR_OPER,NEAR

	or	al,al				; get switch?
	mov	dl,'/'				; assume yes
	jz	chop_1				; jump if yes
	cmp	al,2				; check device availability?
	mov	dl,-1				; assume yes
	jz	chop_1				; jump if yes
	return					; otherwise just quit

; subfunctions requiring return of value to user come here.  DL holds
; value to return

chop_1:
	call	Get_User_Stack
	ASSUME	DS:Nothing
	mov	[si].User_DX,dx 		; store value for user
	return


EndProc $CHAR_OPER

BREAK <$GetExtendedError - Return Extended DOS error code>


;**	$GetExtendedError - Return Extended error code
;
;	This function reads up the extended error info from the static
;	variables where it was stored.
;
;	ENTRY	none
;	EXIT	AX = Extended error code (0 means no extended error)
;		BL = recommended action
;		BH = class of error
;		CH = locus of error
;		ES:DI = may be pointer
;	USES	ALL

procedure   $GetExtendedError,NEAR

;hkn; SS is DOSDATA
	Context DS
	MOV	AX,[EXTERR]
	LES	DI,[EXTERRPT]
	MOV	BX,WORD PTR [EXTERR_ACTION]	; BL = Action, BH = Class
	MOV	CH,[EXTERR_LOCUS]
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_DI],DI
	MOV	[SI.user_ES],ES
	MOV	[SI.user_BX],BX
	MOV	[SI.user_CX],CX
	transfer SYS_RET_OK

EndProc $GetExtendedError

BREAK <$Get_Global_CdPg  - Return Global Code Page>
;---------------------------------------------------------------------------
;
; input:    None
; output:   AX = Global Code Page
;
;---------------------------------------------------------------------------

Procedure   Get_Global_CdPg,NEAR
	PUSH	SI

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG
	MOV	AX,SS:[SI.ccDosCodePage]			;smr;CS->SS
	POP	SI
	return

EndProc Get_Global_CdPg

;-------------------------------Start of DBCS 2/13/KK
BREAK	<ECS_call - Extended Code System support function>

;---------------------------------------------------------------------------
; Inputs:
;	AL = 0	get lead byte table
;		on return DS:SI has the table location
;
;	AL = 1	set / reset interim console flag
;		DL = flag (00H or 01H)
;		no return
;
;	AL = 2	get interim console flag
;		on return DL = current flag value
;
;	AL = OTHER then error, and returns with:
;		AX = error_invalid_function
;
;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
;	 SS:SP WILL BE PRESERVED!
;---------------------------------------------------------------------------

procedure   $ECS_call,NEAR

 IFDEF  DBCS									;AN000;
										;AN000;
	or	al, al			; AL = 0 (get table)?			;AN000;
	je	get_lbt 							;AN000;
	cmp	al, SetInterimMode	; AL = 1 (set / reset interim flag)?	;AN000;
	je	set_interim							;AN000;
	cmp	al, GetInterimMode	; AL = 2 (get interim flag)?		;AN000;
	je	get_interim							;AN000;
	error	error_invalid_function						;AN000;
										;AN000;
get_lbt:				; get lead byte table			;AN000;
	push	ax								;AN000;
	push	bx								;AN000;
	push	ds								;AN000;

;hkn; SS is DOSDATA
	context DS								;AN000;
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccSetDBCS			;AN000;
	MOV	AX,[BX+1]		; set EV address to DS:SI		;AN000;smr;use ds
	MOV	BX,[BX+3]							;AN000;smr;use ds
	ADD	AX,2			; Skip Lemgth				;AN000;
	call	get_user_stack							;AN000;
 assume ds:nothing								;AN000;
	MOV	[SI.user_SI], AX						;AN000;
	MOV	[SI.user_DS], BX						;AN000;
	pop	ds								;AN000;
	pop	bx								;AN000;
	pop	ax								;AN000;
	transfer SYS_RET_OK							;AN000;

set_interim:				; Set interim console flag		;AN000;
	push	dx								;AN000;
	and	dl,01			; isolate bit 1 			;AN000;

;hkn; SS override
	mov	[InterCon], dl							;AN000;
	push	ds
;hkn; SS override
	mov	ds, [CurrentPDB]						;AN000;
	mov	byte ptr ds:[PDB_InterCon], dl	; update value in pdb		;AN000;
	pop	ds								;AN000;
	pop	dx								;AN000;
	transfer SYS_RET_OK							;AN000;

get_interim:									;AN000;
	push	dx								;AN000;
	push	ds								;AN000;
;hkn; SS override
	mov	dl,[InterCon]							;AN000;
	call	get_user_stack		; get interim console flag		;AN000;
 assume ds:nothing								;AN000;
	mov	[SI.user_DX],DX 						;AN000;
	pop	ds								;AN000;
	pop	dx								;AN000;
	transfer SYS_RET_OK							;AN000;
 ELSE										;AN000;
	or	al, al			; AL = 0 (get table)?
	jnz	okok
get_lbt:
	call	get_user_stack
 assume ds:nothing

;hkn; dbcs_table moved low to dosdata
	MOV	[SI.user_SI], Offset DOSDATA:DBCS_TAB+2

	push	es
	getdseg <es>			; es = DOSDATA
	assume	es:nothing
	MOV	[SI.user_DS], es
	pop	es

okok:
	transfer SYS_RET_OK		;

 ENDIF

$ECS_call endp

DOSCODE	ENDS
	END




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\isearch.asm ===
TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
	NAME	DOS_SEARCH

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level routines for doing local and NET directory searches
;
;	DOS_SEARCH_FIRST
;	DOS_SEARCH_NEXT
;	RENAME_NEXT
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00  Jan. 1988
;	    A001	PTM 3564 -- serach for fastopen

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE fastopen.inc
	INCLUDE fastxxxx.inc
	include curdir.inc
	include dpb.inc
	include mult.inc
	.cref
	.list

Installed = TRUE

	i_need	NoSetDir,BYTE
	i_need	Creating,BYTE
	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	DMAADD,DWORD
	i_need	DummyCDS,128
	i_need	THISDPB,DWORD
	i_need	THISDRV,BYTE
	i_need	NAME1,BYTE
	i_need	ATTRIB,BYTE
	i_need	DIRSTART,WORD
	i_need	LASTENT,WORD
	i_need	FOUND_DEV,BYTE
	I_need	WFP_Start,WORD
	i_need	EXTERR_LOCUS,BYTE
	i_need	FastopenFlg,BYTE
	I_need	DOS34_FLAG,WORD


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

;--------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_FIRST
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[DMAADD] Points to 53 byte buffer
; Function:
;	Initiate a search for the given file spec
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes ot DMAADD are filled in as follows:
;
;	LOCAL
;	    Drive Byte (A=1, B=2, ...) High bit clear
;		NEVER STORE DRIVE BYTE AFTER  found_it
;	    11 byte search name with Meta chars in it
;	    Search Attribute Byte, attribute of search
;	    WORD LastEnt value
;	    WORD DirStart
;	    4 byte pad
;	    32 bytes of the directory entry found
;	NET
;	    21 bytes First byte has high bit set
;	    32 bytes of the directory entry found
;
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No match for this file
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; called from rename & search. DS already set up to DOSDATA.

	ASSUME	ES:NOTHING
procedure   DOS_SEARCH_FIRST,NEAR
	DOSAssume   <DS>,"DOS_Search_First"

	LES	DI,[THISCDS]
	CMP	DI,-1
	JNZ	TEST_RE_NET
IF NOT Installed
	transfer NET_SEQ_SEARCH_FIRST
ELSE
	MOV	AX,(multNET SHL 8) OR 25
	INT	2FH
	return
ENDIF

TEST_RE_NET:
	TEST	ES:[DI.curdir_flags],curdir_isnet
	JZ	LOCAL_SEARCH_FIRST
IF NOT Installed
	transfer NET_SEARCH_FIRST
ELSE
	MOV	AX,(multNET SHL 8) OR 27
	INT	2FH
	return
ENDIF

LOCAL_SEARCH_FIRST:
	EnterCrit   critDisk
	TEST	[DOS34_FLAG],SEARCH_FASTOPEN  ;AN000;
	JZ	NOFN			      ;AN000;
	OR	[FastOpenflg],Fastopen_Set    ;AN000;
NOFN:					      ;AN000;
	MOV	[NoSetDir],1		; if we find a dir, don't change to it
	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
	JNC	norm_getpath		;AN000;;FO. no
	AND	[FastOpenflg],Fast_yes	;AN000;;FO. reset fastopen
norm_getpath:
	invoke	GetPath
getdone:
	JNC	find_check_dev
	JNZ	bad_path
	OR	CL,CL
	JZ	bad_path
find_no_more:
	MOV	AX,error_no_more_files
BadBye:

;hkn; FastOpenFlag is in DOSDATA use SS 
	AND	SS:[FastOpenflg],Fast_yes  ;AN000;;FO. reset fastopen

	STC
	LeaveCrit   critDisk
	return

bad_path:
	MOV	AX,error_path_not_found
	JMP	BadBye

find_check_dev:
	OR	AH,AH
	JNS	found_entry
	MOV	[LastEnt],-1		; Cause DOS_SEARCH_NEXT to fail
	INC	[Found_Dev]		; Tell DOS_RENAME we found a device
found_entry:
;
; We set the physical drive byte here Instead of after found_it; Doing
; a search-next may not have wfp_start set correctly
;
	LES	DI,[DMAADD]
	MOV	SI,WFP_Start		; get pointer to beginning
	LODSB
	SUB	AL,'A'-1                ; logical drive
	STOSB				; High bit not set (local)
found_it:
	LES	DI,[DMAADD]
	INC	DI
	PUSH	DS			;FO.;AN001; save ds
	TEST	[Fastopenflg],Set_For_Search	  ;FO.;AN001; from fastopen
	JZ	notfast 			  ;FO.;AN001;
	MOV	SI,BX				  ;FO.;AN001;
	MOV	DS,WORD PTR [CURBUF+2]		  ;FO.;AN001;
	JMP	SHORT movmov			  ;FO.;AN001;


notfast:

;hkn; NAME1 is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NAME1; find_buf 2 = formatted name

movmov:
; Special E5 code
	MOVSB
	CMP	BYTE PTR ES:[DI-1],5
	JNZ	NOTKANJB
	MOV	BYTE PTR ES:[DI-1],0E5H
NOTKANJB:

	MOV	CX,10
	REP	MOVSB
	POP	DS			;FO.;AN001; restore ds

	MOV	AL,[Attrib]
	STOSB
	PUSH	AX			; Save AH device info
	MOV	AX,[LastEnt]
	STOSW
	MOV	AX,[DirStart]
	STOSW
; 4 bytes of 21 byte cont structure left for NET stuff
	ADD	DI,4
	POP	AX			; Recover AH device info
	OR	AH,AH
	JS	DOSREL			; Device entry is DOSGROUP relative
	CMP	WORD PTR [CURBUF],-1
	JNZ	OKSTORE
	TEST	[FastOPenFlg],Set_For_Search ;AN000;;FO. from fastopen and is good
	JNZ	OKSTORE 		     ;AN000;;FO.


	; The user has specified the root directory itself, rather than some
	; contents of it. We can't "find" that.
	MOV	WORD PTR ES:[DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
					;   stuffing a -1 at Lastent
	JMP	find_no_more

OKSTORE:
	MOV	DS,WORD PTR [CURBUF+2]
ASSUME	DS:NOTHING
DOSREL:
	MOV	SI,BX			; SI-> start of entry

; NOTE: DOS_RENAME depends on BX not being altered after this point

	MOV	CX,SIZE dir_entry
;;;;; 7/29/86
	MOV	AX,DI			; save the 1st byte addr
	REP	MOVSB
	MOV	DI,AX			; restore 1st byte addr
	CMP	BYTE PTR ES:[DI],05H	; special char check
	JNZ	NO05
	MOV	BYTE PTR ES:[DI],0E5H	; convert it back to E5
NO05:

;;;;; 7/29/86

;hkn; FastOpenflg is in DOSDATA use SS
	AND	[FastOpenflg],Fast_yes  ;AN000;;FO. reset fastopen

;hkn; SS is DOSDATA
	context DS
	CLC
	LeaveCrit   critDisk
	return

EndProc DOS_SEARCH_FIRST

BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_NEXT
;
; Inputs:
;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
;	    (only first 21 bytes must have valid information)
; Function:
;	Look for subsequent matches
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes at DMAADD are updated for next call
;		(see DOS_SEARCH_FIRST)
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No more files to find
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; called from search.asm. DS already set up at this point.

	ASSUME	ES:NOTHING
procedure   DOS_SEARCH_NEXT,NEAR
	DOSAssume   <DS>,"DOS_Search_Next"

	LES	DI,[DMAADD]
	MOV	AL,ES:[DI]
	TEST	AL,80H			; Test for NET
	JZ	LOCAL_SEARCH_NEXT
IF NOT Installed
	transfer NET_SEARCH_NEXT
ELSE
	MOV	AX,(multNET SHL 8) OR 28
	INT	2FH
	return
ENDIF

LOCAL_SEARCH_NEXT:
;AL is drive A=1
	MOV	[EXTERR_LOCUS],errLOC_Disk
	EnterCrit   critDisk

;hkn; DummyCDS is in DOSDATA
	MOV     WORD PTR ThisCDS,OFFSET DOSDATA:DummyCDS
;hkn; Segment address is DOSDATA - use ds
;hkn;	MOV     WORD PTR ThisCDS+2,CS
	mov	WORD PTR ThisCDS+2,DS

	ADD	AL,'A'-1
	invoke	InitCDS

;	invoke	GetThisDrv		; Set CDS pointer

	JC	No_files		; Bogus drive letter
	LES	DI,[THISCDS]		; Get CDS pointer
	LES	BP,ES:[DI.curdir_devptr]; Get DPB pointer
	invoke	GOTDPB			; [THISDPB] = ES:BP

	mov	AL,ES:[BP.dpb_drive]
	mov	ThisDrv,AL

	MOV	WORD PTR CREATING, DIRFREE*256 + 0
	MOV	[NoSetDir],1		; if we find a dir, don't change to it
	LDS	SI,[DMAADD]
ASSUME	DS:NOTHING
	LODSB				; Drive Byte

;	DEC	AL
;	MOV	[THISDRV],AL

	entry	RENAME_NEXT		; Entry used by DOS_RENAME

	context ES			; THIS BLOWS ES:BP POINTER TO DPB

;hkn; NAME1 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME1

	MOV	CX,11
	REP	MOVSB			; Search name
	LODSB				; Attribute

;hkn; SS override
	MOV	[ATTRIB],AL
	LODSW				; LastEnt
	OR	AX,AX
	JNS	cont_load
No_files:
	JMP	find_no_more

cont_load:
	PUSH	AX			; Save LastEnt
	LODSW				; DirStart
	MOV	BX,AX

;hkn; SS is DOSDATA
	context DS
	LES	BP,[THISDPB]		; Recover ES:BP
	invoke	SetDirSrch
	JNC	SEARCH_GOON
	POP	AX			; Clean stack
	JMP	No_files

SEARCH_GOON:
	invoke	StartSrch
	POP	AX
	invoke	GetEnt
	JC	No_files
	invoke	NextEnt
	JC	No_files
	XOR	AH,AH			; If Search_Next, can't be a DEV
	JMP	found_it

EndProc DOS_SEARCH_NEXT

;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_QUESTION
;
; Input: [WFP_START]= pointer to final path
; Function: check '?' char
; Output: carry clear, if no '?'
;	 carry set, if '?' exists
;---------------------------------------------------------------------------

	procedure   CHECK_QUESTION,NEAR ;AN000;
	ASSUME	ES:NOTHING,DS:NOTHING	;AN000;

;hkn; wfp_start is in DOSDATA;hkn;	MOV     WORD PTR ThisCDS+2,CS
;hkn;	PUSH	CS			;AN000;;FO.
	push	ss

	POP	DS			;AN000;;FO. ds:si -> final path
	MOV	SI,[WFP_START]		;AN000;;FO.
getnext:				;AN000;
	LODSB				;AN000;;FO. get char
	OR	AL,AL			;AN000;;FO. is it null
	JZ	NO_Question		;AN000;;FO. yes
	CMP	AL,'?'                  ;AN000;;FO. is '?'
	JNZ	getnext 		;AN000;;FO. no
	STC				;AN000;;FO.
NO_Question:				;AN000;
	return				;AN000;;FO.

EndProc CHECK_QUESTION			;AN000;

DOSCODE	ENDS
    END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\kstrin.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)strin.asm	1.2 85/04/18
;
;	Revision history:
;	   A000  version 4.00   Jan. 1988
;
Break

; Inputs:
;	DS:DX Point to an input buffer
; Function:
;	Fill buffer from console input until CR
; Returns:
;	None

	procedure   $STD_CON_STRING_INPUT,NEAR	 ;System call 10
ASSUME	DS:NOTHING,ES:NOTHING

	MOV	AX,SS
	MOV	ES,AX
	MOV	SI,DX
	XOR	CH,CH
	LODSW

;hkn; use ss override
	mov	ss:Temp_Var,si	 ;AN000;   ; 3/31/KK
;
; AL is the buffer length
; AH is the template length
;
	OR	AL,AL
	retz			;Buffer is 0 length!!?
	MOV	BL,AH		;Init template counter
	MOV	BH,CH		;Init template counter
 ;
 ; BL is the number of bytes in the template
 ;
	CMP	AL,BL
	JBE	NOEDIT		;If length of buffer inconsistent with contents
	CMP	BYTE PTR [BX+SI],c_CR
	JZ	EDITON		;If CR correctly placed EDIT is OK
;
; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;
NOEDIT:
	MOV	BL,CH		;Reset buffer
EDITON:
	MOV	DL,AL
	DEC	DX		;DL is # of bytes we can put in the buffer
;
; Top level.  We begin to read a line in.
;
NEWLIN:

;hkn; SS override
	MOV	AL,[CARPOS]
	MOV	[STARTPOS],AL	;Remember position in raw buffer
	PUSH	SI

;hkn; INBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:INBUF	;Build the new line here

;hkn; SS override
	MOV	[INSMODE],CH	;Insert mode off
	MOV	BH,CH		;No chars from template yet
	MOV	DH,CH		;No chars to new line yet
	call	IntCNE0 	;AN000; Get first char			 2/17/KK
	jz	SavCh		;AN000; if ZF set then interim character 2/17/KK
	CMP	AL,c_LF 	;Linefeed
	JNZ	GOTCH		;Filter out LF so < works
;
; This is the main loop of reading in a character and processing it.
;
;   BH is the index of the next byte in the template
;   BL is the length of the template
;   DH is the number of bytes in the buffer
;   DL is the length of the buffer
;
entry	GETCH
	call	IntCNE0 	;AN000;; 2/17/KK
	jz	SavCh		;AN000;; if ZF set then interim character 2/17/KK
GOTCH:
;
; ^F ignored in case BIOS did not flush the input queue.
;
	CMP	AL,"F"-"@"
	JZ	GETCH
;
; If the leading char is the function-key lead byte
;

;hkn; ESCCHAR is in TABLE seg (DOSCODE)
	CMP	AL,[ESCCHAR]
	JNZ	ARM03		;AN000;; 2/17/KK
	Jmp	ESCC		;AN000;; 2/17/KK
ARM03:				;AN000;; 2/17/KK
;
; Rubout and ^H are both destructive backspaces.
;
	CMP	AL,c_DEL
	JZ	BACKSPJ0	;AN000; 2/17/KK
	CMP	AL,c_BS
	JNZ	ARM04		;AN000;; 2/17/KK
BACKSPJ0:			;AN000;; 2/17/KK
	Jmp	BACKSPJ 	;AN000;; 2/17/KK
ARM04:				;AN000;; 2/17/KK
;
; ^W deletes backward once and then backs up until a letter is before the
; cursor
;
	CMP	AL,"W" - "@"
; The removal of the comment characters before the jump statement will
; cause ^W to backup a word.
;***	JZ	WordDel
ifdef	JAPAN				    ; MSKK01 07/14/89
	jnz	NotWordDel
	jmp	WordDel
NotWordDel:
else
	NOP
	NOP
endif
	CMP	AL,"U" - "@"
; The removal of the comment characters before the jump statement will
; cause ^U to clear a line.
;***	JZ	LineDel
ifdef	JAPAN				    ; MSKK01 07/14/89
	jnz	NotLineDel
	jmp	LineDel
NotLineDel:
else
	NOP
	NOP
endif

;
; CR terminates the line.
;
	CMP	AL,c_CR
	JNZ	ARM01		;AN000;; 2/17/KK
	Jmp	ENDLIN		;AN000;; 2/17/KK
ARM01:				;AN000;; 2/17/KK
;
; LF goes to a new line and keeps on reading.
;
	CMP	AL,c_LF
	JNZ	ARM00		;AN000;; 2/17/KK
	Jmp	PHYCRLF 	;AN000;; 2/17/KK
ARM00:				;AN000;; 2/17/KK
;
; ^X (or ESC) deletes the line and starts over
;


;hkn; CANCHAR is in TABLE seg (DOSCODE), so CS override
	CMP	AL,[CANCHAR]
	JNZ	SAVCH		;AN000;; 2/13/KK
	JMP	KILNEW		;AN000;; 2/13/KK
InterLoop:			;AN000;; 2/17/KK
	call	IntCNE0 	;AN000;; Get another interim character 2/17/KK
;
; Otherwise, we save the input character.
;
SAVCH:
	pushf			;AN000; 2/17/KK
	CMP	DH,DL
	JAE	BUFFUL			; buffer is full.
;----------------------------- Start of DBCS 2/13/KK

	invoke	TESTKANJ		;AN000;
	JZ	ISNORM			;AN000;
	INC	DH			;AN000;
	CMP	DH,DL			;AN000;
	JB	GOTROOM 		;AN000;
	DEC	DH			;AN000;; No room for second byte
	call	IntCNE0 		;AN000;; Get second byte
	JMP	SHORT BUFFUL		;AN000;
					;AN000;
GOTROOM:				;AN000;
	STOSB				;AN000;; Store first byte
	popf				;AN000;
	call	outchax 		;AN000;
	call	IntCNE0 		;AN000;; Get second byte
	pushf				;AN000;
	STOSB				;AN000;; Store second byte
	INC	DH			;AN000;
	popf				;AN000;
	call	outchax 		;AN000;
	jnz	ContIn1 		;AN000;; interim character?
	call	InterCheck		;AN000;
	call	InterCheck		;AN000;
	jmp	short InterLoop 	;AN000;; not interim skip another check

ISNORM:
;----------------------------- End of DBCS 2/13/KK
	STOSB				;AN000;
	INC	DH			;AN000;; increment count in buffer.
	popf				;AN000;; 2/17/KK
	invoke	BUFOUTx 		;AN000;; Print control chars nicely 2/17/KK
	jnz	ContIn1 		;AN000;; 2/17/KK
	call	InterCheck		;AN000;; 2/17/KK
	jmp	short InterLoop 	;AN000;; 2/17/KK
CONTIN1:				;AN000;; 2/13/KK
;;;CONTIN:				;AN000;; 2/13/KK

;hkn; SS override
	CMP	BYTE PTR [INSMODE],0
	JNZ	GETCH0			; insertmode => don't advance template
	CMP	BH,BL
	JAE	GETCH0			; no more characters in template
	INC	SI			; Skip to next char in template
	INC	BH			; remember position in template

	PUSH	AX			;
	MOV	AL,BYTE PTR [SI-1]	;AN000;;		    2/13/KK
	invoke	TESTKANJ		;AN000;;		    2/13/KK
	POP	AX			;AN000;;		    2/13/KK
	JZ	GETCH0			;AN000;; Wasn't a dual byte 2/13/KK
	INC	SI			;AN000;; Was a dual byte,   2/13/KK
	INC	BH			;AN000;;     skip one more  2/13/KK
GETCH0: 				;AN000;; 2/17/KK
	JMP	GETCH			;AN000;; 2/17/KK

BACKSPJ: JMP	SHORT BACKSP

BUFFUL:
	popf				;AN000;; 2/17/KK
	MOV	AL,7			;AN000;; Bell to signal full buffer
	invoke	OUTT
	JMP	GETCH
;						2/17/KK
;	Reduce character count, reduce pointer	2/17/KK
;						2/17/KK
InterCheck:				;AN000;;       2/17/KK
	dec	dh			;AN000;; adjust count	       2/17/KK
	dec	di			;AN000;; adjust buffer pointer 2/17/KK
	ret				;AN000;;		       2/17/KK

ESCC:
	transfer    OEMFunctionKey	; let the OEM's handle the key dispatch

ENDLIN:
	STOSB				; Put the CR in the buffer
	invoke	OUTT			; Echo it
	POP	DI			; Get start of user buffer
	MOV	[DI-1],DH		; Tell user how many bytes
	INC	DH			; DH is length including CR
COPYNEW:
	SAVE	<DS,ES>
	RESTORE <DS,ES>		; XCHG ES,DS

;hkn; INBUF is in DOSDATA
	MOV	SI,OFFSET DOSDATA:INBUF
	MOV	CL,DH			; set up count
	REP	MOVSB			; Copy final line to user buffer
	return
;
; Output a CRLF to the user screen and do NOT store it into the buffer
;
PHYCRLF:
	invoke	CRLF
	JMP	GETCH

;
; Delete the previous line
;
LineDel:
	OR	DH,DH
	JNZ	bridge00	;AN000;; 2/13/KK
	JMP	GetCh		;AN000;; 2/13/KK
bridge00:			;AN000;; 2/13/KK
	Call	BackSpace
	JMP	LineDel

;
; delete the previous word.
;
WordDel:
WordLoop:
	Call	BackSpace		; backspace the one spot
	OR	DH,DH
	JZ	GetChJ
	MOV	AL,ES:[DI-1]
	cmp	al,'0'
	jb	GetChj
	cmp	al,'9'
	jbe	WordLoop
	OR	AL,20h
	CMP	AL,'a'
	JB	GetChJ
	CMP	AL,'z'
	JBE	WordLoop
GetChJ:
	JMP	GetCh
;
; The user wants to throw away what he's typed in and wants to start over.  We
; print the backslash and then go to the next line and tab to the correct spot
; to begin the buffered input.
;
	entry	KILNEW
	MOV	AL,"\"
	invoke	OUTT		;Print the CANCEL indicator
	POP	SI		;Remember start of edit buffer
PUTNEW:
	invoke	CRLF		;Go to next line on screen

;hkn; SS override
	MOV	AL,[STARTPOS]
	invoke	TAB		;Tab over
	JMP	NEWLIN		;Start over again


;
; Destructively back up one character position
;
entry	BackSp
	Call	BackSpace
	JMP	GetCh

BackSpace:
	OR	DH,DH
	JZ	OLDBAK		;No chars in line, do nothing to line
	CALL	BACKUP		;Do the backup
	MOV	AL,ES:[DI]	;Get the deleted char
	invoke	TESTKANJ	;AN000;2/13/KK
	JNZ	OLDBAK		;AN000; Was a dual byte, done  2/13/KK
	CMP	AL," "
	JAE	OLDBAK		;Was a normal char
	CMP	AL,c_HT
	JZ	BAKTAB		;Was a tab, fix up users display
ifdef	JAPAN			; MSKK02 07/14/89

;	^U and ^T backspace 2 characters in KANJI VERSION

else
;; 9/27/86 fix for ctrl-U backspace
	CMP	AL,"U"-"@"      ; ctrl-U is a section symbol not ^U
	JZ	OLDBAK
	CMP	AL,"T"-"@"      ; ctrl-T is a paragraphs symbol not ^T
	JZ	OLDBAK
;; 9/27/86 fix for ctrl-U backspace
endif
	CALL	BACKMES 	;Was a control char, zap the '^'
OLDBAK:

;hkn; SS override
	CMP	BYTE PTR [INSMODE],0
	retnz			;In insert mode, done
	OR	BH,BH
	retz			;Not advanced in template, stay where we are
	DEC	BH		;Go back in template
	DEC	SI
;-------------------------- Start of DBCS 2/13/KK
	OR	BH,BH		;AN000;
	retz			;AN000;; If we deleted one char and it was the only
				;AN000;;  one, could not have dual byte
;;;;	POP	AX		;AN000;; Get start of template
;;;;	PUSH	AX		;AN000;; Put it back on stack

;hkn; SS override
	mov	ax,ss:Temp_Var	;AN000;; 3/31/KK
	XCHG	AX,SI		;AN000;
LOOKDUAL:			;AN000;
	CMP	SI,AX		;AN000;
	JAE	ATLOC		;AN000;
	PUSH	AX		;AN000;
	MOV	AL,BYTE PTR [SI];AN000;
	invoke	TESTKANJ	;AN000;
	POP	AX		;AN000;
	JZ	ONEINC		;AN000;
	INC	SI		;AN000;
ONEINC: 			;AN000;
	INC	SI		;AN000;
	JMP	SHORT LOOKDUAL	;AN000;
				;AN000;
ATLOC:				;AN000;
	retz			;AN000;; Correctly pointing to start of single byte
	DEC	AX		;AN000;; Go back one more to correctly point at start
	DEC	BH		;AN000;        ; of dual byte
	MOV	SI,AX		;AN000;
	return			;AN000;
;-------------------------- End of DBCS 2/13/KK

BAKTAB:
	PUSH	DI
	DEC	DI		;Back up one char
	STD			;Go backward
	MOV	CL,DH		;Number of chars currently in line
	MOV	AL," "
	PUSH	BX
	MOV	BL,7		;Max
	JCXZ	FIGTAB		;At start, do nothing
FNDPOS:
	SCASB			;Look back
	JNA	CHKCNT
	CMP	BYTE PTR ES:[DI+1],9
	JZ	HAVTAB		;Found a tab
	DEC	BL		;Back one char if non tab control char
CHKCNT:
	LOOP	FNDPOS
FIGTAB:

;hkn; SS override
	SUB	BL,[STARTPOS]
HAVTAB:
	SUB	BL,DH
	ADD	CL,BL
	AND	CL,7		;CX has correct number to erase
	CLD			;Back to normal
	POP	BX
	POP	DI
	JZ	OLDBAK		;Nothing to erase
TABBAK:
	invoke	BACKMES
	LOOP	TABBAK		;Erase correct number of chars
	JMP	SHORT OLDBAK

BACKUP:
	DEC	DH		;Back up in line
	DEC	DI
;-------------------------Start of DBCS 2/13/KK
	OR	DH,DH			;AN000;
	JZ	BACKMES 		;AN000;; If deleted one and got only, no dual
	MOV	AX,DI			;AN000;

;hkn; INBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:INBUF;AN000;
LOOKDUAL2:				;AN000;
	CMP	DI,AX			;AN000;
	JAE	ATLOC2			;AN000;
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	ONEINC2 		;AN000;
	INC	DI			;AN000;
ONEINC2:				;AN000;
	INC	DI			;AN000;
	JMP	SHORT LOOKDUAL2 	;AN000;
					;AN000;
ATLOC2: 				;AN000;
	JE	BACKMES 		;AN000;; Correctly deleted single byte
	DEC	AX			;AN000; Go back one more to correctly delete dual byte
	DEC	DH			;AN000;
	MOV	DI,AX			;AN000;
	CALL	BACKMES 		;AN000;
;---------------------------End of DBCS 2/13/KK
BACKMES:
	MOV	AL,c_BS 	;Backspace
	invoke	OUTT
	MOV	AL," "          ;Erase
	invoke	OUTT
	MOV	AL,c_BS 	;Backspace
	JMP	OUTT		;Done

;User really wants an ESC character in his line
	entry	TwoEsc

;hkn; ESCCHAR is in DOSCODE so CS override
	MOV	AL,[ESCCHAR]
	JMP	SAVCH

;Copy the rest of the template
	entry	COPYLIN
	MOV	CL,BL		;Total size of template
	SUB	CL,BH		;Minus position in template, is number to move
	JMP	SHORT COPYEACH

	entry	CopyStr
	invoke	FINDOLD 	;Find the char
	JMP	SHORT COPYEACH	;Copy up to it

;Copy one char from template to line
	entry	COPYONE
	MOV	CX,1			;AN000;;	       2/13/KK
	MOV	AL,[SI] 		;AN000;; get char      2/13/KK
	invoke	TestKanj		;AN000;; is it kanji?  2/13/KK
	JZ	CopyEach		;AN000;; no, go do copy2/13/KK
	INC	CX			;AN000;; do 2 byte copy2/13/KK

;Copy CX chars from template to line
COPYEACH:

;hkn; SS override
	MOV	BYTE PTR [INSMODE],0	;All copies turn off insert mode
	CMP	DH,DL
	JZ	GETCH2			;At end of line, can't do anything
	CMP	BH,BL
	JZ	GETCH2			;At end of template, can't do anything
	LODSB
	STOSB
;----------------------------- Start of DBCS 2/13/KK
	INC	BH			;AN000;; Ahead in template
	INC	DH			;AN000;; Ahead in line
	CALL	TestKanj		;AN000;; 2 byte character?
	JZ	CopyLoop		;AN000;; no, go copy next
	CMP	DH,DL			;AN000;; over boundary?
	JNZ	CopyBoth		;AN000;; no, move both
	DEC	BH			;AN000;; yes, backup template
	DEC	DH			;AN000;; back up line
	DEC	SI			;AN000;; patch (from Dohhaku)
	DEC	DI			;AN000;; remember to backup after previous move
	JMP	GetCh			;AN000;; go get next char
					;AN000;
CopyBoth:				;AN000;
	invoke	BUFOUT			;AN000;; output the first byte
	LODSB				;AN000;; get the second
	STOSB				;AN000;; move the second
	INC	BH			;AN000;; bump template
	INC	DH			;AN000;; bump line
	DEC	CX			;AN000;; dump byte count
CopyLoop:				;AN000;
	invoke	BUFOUT			;AN000;
	LOOP	COPYEACH		;AN000;
;;;;;	invoke	BUFOUT
;;;;;	INC	BH			;Ahead in template
;;;;;	INC	DH			;Ahead in line
;;;;;	LOOP	COPYEACH
;----------------------------- End of DBCS 2/13/KK
GETCH2:
	JMP	GETCH

;Skip one char in template
	entry	SKIPONE
	CMP	BH,BL
	JZ	GETCH2			;At end of template
	INC	BH			;Ahead in template
	INC	SI
	PUSH	AX			;AN000;; 2/13/KK
	MOV	AL,BYTE PTR [SI-1]	;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	POP	AX			;AN000;; 2/13/KK
	JZ	GETCH2			;AN000;; 2/13/KK
	INC	BH			;AN000;; 2/13/KK
	INC	SI			;AN000;; 2/13/KK
	JMP	GETCH

	entry	SKIPSTR
	invoke	FINDOLD 		;Find out how far to go
	ADD	SI,CX			;Go there
	ADD	BH,CL
	JMP	GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;	address is popped off and a jump to GETCH is taken.
;	Make sure nothing extra on stack when this routine
;	is called!!! (no PUSHes before calling it).

;hkn; LOOKSIZ has been moved to DATA seg (ms_data.asm)
;hkn; TABLE	SEGMENT 			;AN000;; 2/17/KK
;hkn; Public	KISTR001S,KISTR001E		;AN000;; 2/17/KK
;hkn; KISTR001S	label	byte		;AN000;; 2/17/KK
;hkn; LOOKSIZ DB	0			;AN000;; 0 if byte, NZ if word	2/17/KK
;hkn; KISTR001E	label	byte		;AN000;; 2/17/KK
;hkn; TABLE	ENDS				;AN000;; 2/17/KK

extrn	LOOKSIZ	: byte

FINDOLD:

;hkn; SS override
	MOV	[LOOKSIZ],0		;AN000;; Initialize to byte    2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK

;hkn; ESCCHAR is in DOSCODE so CS override
	CMP	AL,[ESCCHAR]		;AN000;; did he type a function key?
;;;;;	JNZ	FindSetup		;AN000;; no, set up for scan   2/13/KK
	JNZ	TryKanj 		;AN000;; no, continue testing  2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK
	JMP	NotFnd			       ; go try again
;;;;;;;FindSetup:			;AN000;; 2/13/KK
TryKanj:				;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	JZ	GOTLSIZ 		;AN000;; 2/13/KK

;hkn; SS override
	INC	[LOOKSIZ]		;AN000;; Gonna look for a word	2/13/KK
	PUSH	AX			;AN000;; Save first byte	2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK
	POP	CX			;AN000;; 2/13/KK
	MOV	AH,AL			;AN000;; 2/13/KK
	MOV	AL,CL			;AN000;; AX is dual byte sequence to look for
	XOR	CX,CX			;AN000;; Re-zero CH	2/13/KK
GOTLSIZ:
	MOV	CL,BL
	SUB	CL,BH		;CX is number of chars to end of template
	JZ	NOTFND		;At end of template
	DEC	CX		;Cannot point past end, limit search
	JZ	NOTFND		;If only one char in template, forget it
	PUSH	AX			;AN000;; 2/13/KK
	MOV	AL,BYTE PTR [SI]	;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	POP	AX			;AN000;; 2/13/KK
	JZ	NOTDUAL5		;AN000;; 2/13/KK
	DEC	CX			;AN000;; And one more besides	2/13/KK
	JZ	NOTFND			;AN000;; If only one char in template, forget it
NOTDUAL5:				;AN000;; 2/13/KK
	PUSH	ES
	PUSH	DS
	POP	ES
	PUSH	DI
	MOV	DI,SI		;Template to ES:DI
;;;;	INC	DI		  2/13/KK
;;;;	REPNE	SCASB		;Look  2/13/KK
;--------------------- Start of DBCS 2/13/KK
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	ONEINC5 		;AN000;
	INC	DI			;AN000;; We will skip at least something
ONEINC5:				;AN000;
	INC	DI			;AN000;

;hkn; SS override
	CMP	[LOOKSIZ],0		;AN000;
	JNZ	LOOKWORD		;AN000;
LOOKBYTE:				;AN000;
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	TESTITB 		;AN000;
	INC	DI			;AN000;
	INC	DI			;AN000;
	DEC	CX			;AN000;
	LOOP	LOOKBYTE		;AN000;
	JMP	SHORT ATNOTFND		;AN000;
					;AN000;
TESTITB:				;AN000;
	DEC	CX			;AN000;
	CMP	AL,ES:[DI]		;AN000;
	JZ	ATSPOT			;AN000;
	INC	DI			;AN000;
	INC	CX			;AN000;; Counter next instruction
	LOOP	LOOKBYTE		;AN000;
ATNOTFND:				;AN000;
	XOR	AL,AL			;AN000;
	INC	AL			;AN000;; Set NZ
ATSPOT: 			; 2/13/K;AN000;K
;--------------------- End of DBCS 2/13/KK
	POP	DI
	POP	ES
	JNZ	NOTFND		;Didn't find the char
	NOT	CL		;Turn how far to go into how far we went
	ADD	CL,BL		;Add size of template
	SUB	CL,BH		;Subtract current pos, result distance to skip
	return

NOTFND:
	POP	BP		;Chuck return address
	JMP	GETCH
;------------------------- Start of DBCS 2/13/KK
LOOKWORD:			       ;AN000;
	PUSH	AX		       ;AN000;
	MOV	AL,BYTE PTR ES:[DI]    ;AN000;
	invoke	TESTKANJ	       ;AN000;
	POP	AX		       ;AN000;
	JNZ	TESTITW 	       ;AN000;
	INC	DI		       ;AN000;
	LOOP	LOOKWORD	       ;AN000;
	JMP	SHORT ATNOTFND	       ;AN000;
				       ;AN000;
TESTITW:			       ;AN000;
	DEC	CX		       ;AN000;
	CMP	AX,ES:[DI]	       ;AN000;
	JZ	ATSPOT		       ;AN000;
	INC	DI		       ;AN000;
	INC	DI		       ;AN000;
	LOOP	LOOKWORD	       ;AN000; ; Performs second DEC of CX
	JMP	SHORT ATNOTFND	       ;AN000;
;------------------------- End of DBCS 2/13/KK

entry	REEDIT
	MOV	AL,"@"          ;Output re-edit character
	invoke	OUTT
	POP	DI
	PUSH	DI
	PUSH	ES
	PUSH	DS
	invoke	COPYNEW 	;Copy current line into template
	POP	DS
	POP	ES
	POP	SI
	MOV	BL,DH		;Size of line is new size template
	JMP	PUTNEW		;Start over again

	entry	EXITINS
	entry	ENTERINS

;hkn; SS override
	NOT	BYTE PTR [INSMODE]
	JMP	GETCH

;Put a real live ^Z in the buffer (embedded)
	entry	CTRLZ
	MOV	AL,"Z"-"@"
	JMP	SAVCH

;Output a CRLF
	entry	CRLF
	MOV	AL,c_CR
	invoke	OUTT
	MOV	AL,c_LF
	JMP	OUTT

EndProc $STD_CON_STRING_INPUT

;-------------- Start of DBCS 2/17/KK
PUBLIC	IntCNE0 			;AN000;
procedure	IntCNE0,near		;AN000;

;hkn SS override for InterCon
	push	word ptr [InterCon]	;AN000;
	mov	[InterCon],01		;AN000;
get_com:				;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO ;AN000;; get a byte character
	pop	word ptr [InterCon]	;AN000;
	ret				;AN000;
IntCNE0 endp				;AN000;
					;AN000;
procedure	IntCNE1,near		;AN000;
	push	word ptr [InterCon]	;AN000;
	mov	[InterCon],00		;AN000;
	jmp	short get_com		;AN000;
IntCNE1 endp				;AN000;
					;AN000;
	procedure	outchax,near	;AN000;

;hkn; SS override for SaveCurFlag
	pushf				;AN000;
	mov	[SaveCurFlg],0		;AN000;
	jnz	sj1			;AN000;
	mov	[SaveCurFlg],1		;AN000;
sj1:					;AN000;
	CALL	OUTCHA			;AN000;
	mov	[SaveCurFlg],0		;AN000;
	popf				;AN000;
	ret				;AN000;
outchax endp				;AN000;
					;AN000;
	procedure	bufoutx,near	;AN000;
	pushf				;AN000;
	mov	[SaveCurFlg],0		;AN000;
	jnz	sj2			;AN000;
	mov	[SaveCurFlg],1		;AN000;
sj2:					;AN000;
	invoke	BUFOUT			;AN000;
	mov	[SaveCurFlg],0		;AN000;
	popf				;AN000;
	ret				;AN000;
bufoutx endp				;AN000;
;-------------- End of DBCS 2/17/KK


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\macro.asm ===
TITLE	MACRO - Pathname and macro related internal routines
	NAME	MACRO

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	MACRO.ASM
;
;	$AssignOper
;	FIND_DPB
;	InitCDS
;	$UserOper
;	GetVisDrv
;	GetThisDrv
;	GetCDSFromDrv
;
;   Revision history:
;
;	Created: MZ 4 April 1983
;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
;		 AR 2 June 1983     Define/Delete macro for NET redir.
;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
;		 MZ 18 Nov 83	    Rewrite string processing for subtree
;				    aliasing.
;
;   MSDOS performs several types of name translation.  First, we maintain for
;   each valid drive letter the text of the current directory on that drive.
;   For invalid drive letters, there is no current directory so we pretend to
;   be at the root.  A current directory is either the raw local directory
;   (consisting of drive:\path) or a local network directory (consisting of
;   \\machine\path.  There is a limit on the point to which a ..  is allowed.
;
;   Given a path, MSDOS will transform this into a real from-the-root path
;   without .  or ..  entries.	Any component that is > 8.3 is truncated to
;   this and all * are expanded into ?'s.
;
;   The second part of name translation involves subtree aliasing.  A list of
;   subtree pairs is maintained by the external utility SUBST.	The results of
;   the previous 'canonicalization' are then examined to see if any of the
;   subtree pairs is a prefix of the user path.  If so, then this prefix is
;   replaced with the other subtree in the pair.
;
;   A third part involves mapping this "real" path into a "physical" path.  A
;   list of drive/subtree pairs are maintained by the external utility JOIN.
;   The output of the previous translation is examined to see if any of the
;   subtrees in this list are a prefix of the string.  If so, then the prefix
;   is replaced by the appropriate drive letter.  In this manner, we can
;   'mount' one device under another.
;
;   The final form of name translation involves the mapping of a user's
;   logical drive number into the internal physical drive.  This is
;   accomplished by converting the drive number into letter:CON, performing
;   the above translation and then converting the character back into a drive
;   number.
;
;   There are two main entry points:  TransPath and TransFCB.  TransPath will
;   take a path and form the real text of the pathname with all .  and ..
;   removed.  TransFCB will translate an FCB into a path and then invoke
;   TransPath.
;
;	A000	version 4.00  Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include dpb.inc
	include curdir.inc
	.cref
	.list

Installed = TRUE

	I_need	ThisCDS,DWORD		; pointer to CDS used
	I_need	CDSAddr,DWORD		; pointer to CDS table
	I_need	CDSCount,BYTE		; number of CDS entries
	I_need	CurDrv,BYTE		; current macro assignment (old
					; current drive)
	I_need	NUMIO,BYTE		; Number of physical drives
	I_need	fSharing,BYTE		; TRUE => no redirection allowed
	I_need	DummyCDS,80h		; buffer for dummy cds
	I_need	DIFFNAM,BYTE		; flag for MyName being set
	I_need	MYNAME,16		; machine name
	I_need	MYNUM,WORD		; machine number
	I_need	DPBHEAD,DWORD		; beginning of DPB chain
	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	I_need	DrvErr,BYTE		; drive error


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

BREAK <$AssignOper -- Set up a Macro>

; Inputs:
;	AL = 00 get assign mode 		    (ReturnMode)
;	AL = 01 set assign mode 		    (SetMode)
;	AL = 02 get attach list entry		    (GetAsgList)
;	AL = 03 Define Macro (attch start)
;	    BL = Macro type
;	       = 0 alias
;	       = 1 file/device
;	       = 2 drive
;	       = 3 Char device -> network
;	       = 4 File device -> network
;	    DS:SI -> ASCIZ source name
;	    ES:DI -> ASCIZ destination name
;	AL = 04 Cancel Macro
;	    DS:SI -> ASCIZ source name
;	AL = 05 Modified get attach list entry
;	AL = 06 Get ifsfunc item
;	AL = 07 set in_use of a drive's CDS
;	     DL = drive number, 0=default  0=A,,
;	AL = 08 reset in_use of a drive's CDS
;	     DL = drive number, 0=A, 1=B,,,
; Function:
;	Do macro stuff
; Returns:
;	Std Xenix style error return

procedure   $AssignOper,NEAR

	CMP	AL,7			      ; set in_use ?		;AN000;
	JNZ	chk08			      ; no			;AN000;
srinuse:								;AN000;
	PUSH	AX			      ; save al 		;AN000;
	MOV	AL,DL			      ; AL= drive id		;AN000;
	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
	POP	AX			      ; 			;AN000;
	JC	baddrv			      ; bad drive		;AN000;
	CMP	WORD PTR [SI.curdir_devptr],0 ; dpb ptr =0 ?		;AN000;
	JZ	baddrv			      ;     no			;AN000;
	CMP	AL,7			      ; set ?			;AN000;
	JNZ	resetdrv		      ; no			;AN000;
	OR	[SI.curdir_flags],curdir_inuse; set in_use		;AN000;
	JMP	SHORT okdone		      ; 			;AN000;
resetdrv:								;AN000;
	AND	[SI.curdir_flags],NOT curdir_inuse; reset in_use		;AN000;
	JMP	SHORT okdone			; 			;AN000;
baddrv: 								;AN000;
	MOV	AX,error_invalid_drive	      ; error			;AN000;
	JMP	SHORT ASS_ERR		      ; 			;AN000;
chk08:									;AN000;
	CMP	AL,8			      ; reset inuse ?		;AN000;
	JZ	srinuse 		      ; yes			;AN000;

	IF	NOT INSTALLED
	transfer NET_ASSOPER
	ELSE
	PUSH	AX
	MOV	AX,(multnet SHL 8) OR 30
	INT	2FH
	POP	BX			; Don't zap error code in AX
	JC	ASS_ERR
okdone:
	transfer SYS_RET_OK

ASS_ERR:
	transfer SYS_RET_ERR
	ENDIF

EndProc $AssignOper

Break <FIND_DPB - Find a DPB from a drive number>

;**	FIND_DPB - Find a DPB from a Drive #
;
;	ENTRY	AL has drive number A = 0
;	EXIT	'C' set
;		    No DPB for this drive number
;		'C' clear
;		    DS:SI points to DPB for drive
;	USES	SI, DS, Flags

Procedure FIND_DPB,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	LDS	SI,DPBHEAD		;smr;SS Override
fdpb5:	CMP	SI,-1
	JZ	fdpb10
	CMP	AL,[SI].dpb_drive
	jz	ret_label		; Carry clear (retz)
	LDS	SI,[SI].dpb_next_dpb
	JMP	fdpb5

fdpb10:	STC

ret_label:
	return

EndProc FIND_DPB

	Break <InitCDS - set up an empty CDS>


;**	InitCDS - Setup an Empty CDS
;
;	ENTRY	ThisCDS points to CDS
;		AL has uppercase drive letter
;	EXIT	ThisCDS is now empty
;		(ES:DI) = CDS
;		'C' set if no DPB associated with drive
;	USES	AH,ES,DI, Flags

Procedure InitCDS,NEAR
	DOSASSUME <SS>,"InitCDS"
	ASSUME	CS:DOSCODE

	SAVE	<ax>			; save (AL) for caller
	LES	DI,THISCDS		; (es:di) = CDS address
	MOV	ES:[DI].curdir_flags,0	; "free" CDS
	SUB	AL,"A"-1                ; A = 1
	CMP	NUMIO,AL					;smr;SS Override
	JC	icdsx			; Drive does not map a physical drive
	dec	ax			; (AL) = 0 if A, 1 if B, etc.
	PUSH	AX			; save drive number for later
	add	al,"A"
	MOV	AH,':'
	MOV	WORD PTR ES:[DI.curdir_text],AX 	; set "x:"
	MOV	WORD PTR ES:[DI.curdir_text+2],"\"   ; NUL terminate
	.errnz	CURDIR_INUSE-4000h
	OR	byte ptr ES:[DI].curdir_flags+1,curdir_inuse SHR 8
	sub	ax,ax
	MOV	ES:[DI].curdir_ID,ax
	MOV	ES:[DI].curdir_ID+2,ax
	mov	al,2
	MOV	ES:[DI].curdir_END,ax
	pop	ax			; (al) = drive number
	SAVE	<ds,si>
	invoke	FIND_DPB
	JC	icds5			; OOOOPPPPPSSSS!!!!
	MOV	WORD PTR ES:[DI.curdir_devptr],SI
	MOV	WORD PTR ES:[DI.curdir_devptr+2],DS
icds5:	RESTORE <si,ds>
icdsx:	RESTORE <ax>
	return

EndProc InitCDS

Break <$UserOper - get/set current user ID (for net)>

;
;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
;	maintain this string and do no verifications.
;
;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
;				      4-printer-set-flags,5-printer-get-flags)
;		DS:DX is user string pointer (calls 1,2)
;		ES:DI is user buffer (call 3)
;		BX is assign index (calls 2,3,4,5)
;		CX is user number (call 1)
;		DX is flag word (call 4)
;   Outputs:	If AL = 0 then the current user string is written to DS:DX
;			and user CX is set to the user number
;		If AL = 3 then CX bytes have been put at input ES:DI
;		If AL = 5 then DX is flag word

Procedure   $UserOper,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	PUSH	AX
	SUB	AL,1			; quick dispatch on 0,1
	POP	AX
	JB	UserGet 		; return to user the string
	JZ	UserSet 		; set the current user
	CMP	AL,5			; test for 2,3,4 or 5
	JBE	UserPrint		; yep
	MOV	EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus	;smr;SS Override
	error	error_Invalid_Function	; not 0,1,2,3

UserGet:
; Transfer MYNAME to DS:DX
; Set Return CX to MYNUM
	PUSH	DS			; switch registers
	POP	ES
	MOV	DI,DX			; destination
	MOV	CX,[MYNUM]		; Get number		;smr;SS Override
	invoke	get_user_stack
	MOV	[SI.User_CX],CX 	; Set number return
	Context DS			; point to DOSDATA
ASSUME	DS:DOSDATA
	MOV	SI,OFFSET DOSDATA:MyName   ; point source to user string
UserMove:
ASSUME	DS:NOTHING
	MOV	CX,15
	REP	MOVSB			; blam.
	XOR	AX,AX			; 16th byte is 0
	STOSB
UserBye:
	transfer    sys_ret_ok		; no errors here

UserSet:
ASSUME	DS:NOTHING
; Transfer DS:DX to MYNAME
; CX to MYNUM
	MOV	[MYNUM],CX					;smr;SS Override
	MOV	SI,DX			; user space has source
	Context ES
	MOV	DI,OFFSET DOSDATA:MyName   ; point dest to user string
	INC	[DiffNam]		  ; signal change	;smr;SS Override
	JMP	UserMove

UserPrint:
	ASSUME	ES:NOTHING
IF NOT Installed
	transfer PRINTER_GETSET_STRING
ELSE
	PUSH	AX
	MOV	AX,(multNET SHL 8) OR 31
	INT	2FH
	POP	DX			; Clean stack
	JNC	OKPA
	transfer SYS_RET_ERR

OKPA:
	transfer SYS_RET_OK
ENDIF

EndProc $UserOper

Break	<GetVisDrv - return visible drive>

;
;   GetVisDrv - correctly map non-spliced inuse drives
;
;   Inputs:	AL has drive identifier (0=default)
;   Outputs:	Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		    ThisCDS points to CDS
;   Registers modified: AL

Procedure   GetVisDrv,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	CALL	GetThisDrv		; get inuse drive
	retc
	SAVE	<DS,SI>
	LDS	SI,ThisCDS					;smr;SS Override
	TEST	[SI].curdir_flags,curdir_splice
	RESTORE <SI,DS>
	retz				; if not spliced, return OK
	MOV	[DrvErr],error_invalid_drive ;IFS.				;AN000;smr;SS Override
	STC				; signal error
	return
EndProc GetVisDrv

Break <Getthisdrv - map a drive designator (0=def, 1=A...)>

;
;   GetThisDrv - look through a set of macros and return the current drive and
;	macro pointer
;
;   Inputs:	AL has drive identifier (1=A, 0=default)
;   Outputs:
;		Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		   ThisCDS points to macro
;   Registers modified: AL

Procedure   GetThisDrv,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	OR	AL,AL			; are we using default drive?
	JNZ	gtd10			; no, go get the CDS pointers
	MOV	AL,[CurDrv]		; get the current drive
	INC	ax			; Counteract next instruction
gtd10:	DEC	ax			; 0 = A
	SAVE	<DS,SI> 		; save world
	mov	[EXTERR_LOCUS],errLOC_Disk			;smr;SS Override
	TEST	fSharing,-1		; Logical or Physical?	;smr;SS Override
	JZ	gtd20			; Logical
	SAVE	<AX,ES,DI>
	MOV	WORD PTR ThisCDS,OFFSET DOSDATA:DummyCDS	;smr;SS Override
	MOV	WORD PTR ThisCDS+2,SS	;	ThisCDS = &DummyCDS;smr;
	ADD	AL,'A'
	CALL	InitCDS 		;	InitCDS(c);
	TEST	ES:[DI.curdir_flags],curdir_inuse	; Clears carry
	RESTORE <DI,ES,AX>
	JZ	gtd30			; Not a physical drive.
	JMP	SHORT gtdx		; carry clear

gtd20:	invoke	GetCDSFromDrv
	JC	gtd30			; Unassigned CDS -> return error already set
	TEST	[SI.curdir_flags],curdir_inuse	; Clears Carry
	JNZ	gtdx				; carry clear
gtd30:	MOV	AL,error_invalid_drive	; invalid FAT drive
	MOV	[DrvErr],AL		; save this for IOCTL
	mov	[EXTERR_LOCUS],errLOC_UNK
	STC
gtdx:	RESTORE <SI,DS>		; restore world
	return

EndProc GetThisDrv

Break <GetCDSFromDrv - convert a drive number to a CDS pointer>

;
;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
;	pointer, returning an error if the drive number is greater than the
;	number of CDS's
;
;   Inputs:	AL is physical unit # A=0...
;   Outputs:	Carry Set if Bad Drive
;		Carry Clear
;		    DS:SI -> CDS
;		    [THISCDS] = DS:SI
;   Registers modified: DS,SI

Procedure   GetCDSFromDrv,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	CMP	AL,[CDSCount]		; is this a valid designator;smr;SS Override
	JB	GetCDS			; yes, go get the macro
	STC				; signal error
	return				; bye
GetCDS:
	SAVE	<BX,AX>
	LDS	SI,[CDSAddr]		; get pointer to table	;smr;SS Override
	MOV	BL,SIZE CurDir_list	; size in convenient spot
	MUL	BL			; get net offset
	ADD	SI,AX			; convert to true pointer
	MOV	WORD PTR [ThisCDS],SI	; store convenient offset;smr;SS Override
	MOV	WORD PTR [ThisCDS+2],DS ; store convenient segment;smr;SS Override
	RESTORE <AX,BX>
	CLC				; no error
	return				; bye!
EndProc GetCDSFromDrv

DOSCODE ends
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\lock.asm ===
TITLE	LOCK ROUTINES - Routines for file locking
	NAME	LOCK

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	LOCK.ASM - File Locking Routines
;
;	LOCK_CHECK
;	LOCK_VIOLATION
;	$LockOper
;
;	Revision history:
;	  A000	 version 4.00	Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include lock.inc
	include mult.inc
	include dpb.inc
	include sf.inc
	.cref
	.list

AsmVars <IBM, Installed>

Installed = TRUE

	i_need	THISSFT,DWORD
	i_need	THISDPB,DWORD
	i_need	EXTERR,WORD
	i_need	ALLOWED,BYTE
	i_need	RetryCount,WORD
	I_need	fShare,BYTE
	I_Need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	i_need	JShare,DWORD
	i_need	Lock_Buffer,DWORD	; DOS 4.00
	i_need	Temp_Var,WORD		; DOS 4.00


DOSCODE SEGMENT

	allow_getdseg

	ASSUME	SS:DOSDATA,CS:DOSCODE

BREAK <$LockOper - Lock Calls>

;
;   Assembler usage:
;	    MOV     BX, Handle	       (DOS 3.3)
;	    MOV     CX, OffsetHigh
;	    MOV     DX, OffsetLow
;	    MOV     SI, LengthHigh
;	    MOV     DI, LengthLow
;	    MOV     AH, LockOper
;	    MOV     AL, Request
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation
;
;   Assembler usage:
;	    MOV     AX, 5C??	       (DOS 4.00)
;
;				    0? lock all
;				    8? lock write
;				    ?2 lock multiple
;				    ?3 unlock multiple
;				    ?4 lock/read
;				    ?5 write/unlock
;				    ?6 add (lseek EOF/lock/write/unlock)
;	    MOV     BX, Handle
;	    MOV     CX, count or size
;	    LDS     DX, buffer
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation

	procedure   $LockOper,NEAR
	CMP	AL,1
	JA	lock_bad_func

	PUSH	DI			       ; Save LengthLow
	invoke	SFFromHandle		       ; ES:DI -> SFT
	JNC	lock_do 		       ; have valid handle
	POP	DI			       ; Clean stack
	error	error_invalid_handle
lock_bad_func:
	MOV	EXTERR_LOCUS,errLoc_Unk        ; Extended Error Locus;smr;SS Override
	error	error_invalid_function

; Align_buffer call has been deleted, since it corrupts the DTA  (6/5/88) P5013
; Dead code deleted, MD, 23 Mar 90

lock_do:
	MOV	BX,AX				; save AX
	MOV	BP, OFFSET DOSDATA:Lock_Buffer	; get DOS LOCK buffer
	MOV	WORD PTR [BP.Lock_position],DX	; set low offset
	MOV	WORD PTR [BP.Lock_position+2],CX; set high offset
	POP	CX				; get low length
	MOV	WORD PTR [BP.Lock_length],CX	; set low length
	MOV	WORD PTR [BP.Lock_length+2],SI	; set high length
	MOV	CX,1				; one range

;;	PUSH	CS				;
;;	POP	DS				; DS:DX points to

	Context	<ds>

	MOV	DX,BP				;   Lock_Buffer
	TEST	AL,Unlock_all			; function 1
	JNZ	DOS_Unlock			; yes
	JMP	short DOS_Lock			; function 0

DOS_Unlock:
	TESTB	ES:[DI].SF_FLAGS,sf_isnet
	JZ	LOCAL_UNLOCK

	CallInstall Net_Xlock,multNet,10
	JMP	SHORT ValChk
LOCAL_UNLOCK:
if installed
	Call	JShare + 7 * 4					;smr;SS Override
else
	Call	clr_block					;PBUGBUG
endif
ValChk:
	JNC	Lock_OK
lockerror:
	transfer SYS_RET_ERR
Lock_OK:
	MOV	AX,[Temp_VAR]			 ;AN000;;MS. AX= number of bytes;smr;SS Override
	transfer SYS_Ret_OK
DOS_Lock:
	TESTB	ES:[DI].SF_FLAGS,sf_isnet
	JZ	LOCAL_LOCK
	CallInstall NET_XLock,multNet,10
	JMP	ValChk
LOCAL_LOCK:
if installed
	Call	JShare + 6 * 4					;smr;SS Override
else
	Call	Set_Block					;PBUGBUG
endif
	JMP	ValChk

EndProc $LockOper

; Inputs:
;	Outputs of SETUP
;	[USER_ID] Set
;	[PROC_ID] Set
; Function:
;	Check for lock violations on local I/O
;	Retries are attempted with sleeps in between
; Outputs:
;    Carry clear
;	Operation is OK
;    Carry set
;	A lock violation detected
; Outputs of SETUP preserved

procedure   LOCK_CHECK,NEAR
	DOSAssume   <DS>,"Lock_Check"

	MOV	BX,RetryCount		; Number retries
LockRetry:
	SAVE	<BX,AX> 		; save regs
if installed
	call	JShare + 8 * 4
else
	Call	chk_block					;PBUGBUG
endif
	RESTORE <AX,BX> 	; restrore regs
	jnc	ret_label	; There are no locks (retnc)
	Invoke	Idle		; wait a while
	DEC	BX		; remember a retry
	JNZ	LockRetry	; more retries left...
	STC

ret_label:
	return
EndProc LOCK_CHECK

; Inputs:
;	[THISDPB] set
;	[READOP] indicates whether error on read or write
; Function:
;	Handle Lock violation on compatibility (FCB) mode SFTs
; Outputs:
;	Carry set if user says FAIL, causes error_lock_violation
;	Carry clear if user wants a retry
;
; DS, ES, DI, CX preserved, others destroyed

procedure   LOCK_VIOLATION,NEAR
	DOSAssume   <DS>,"Lock_Violation"

	PUSH	DS
	PUSH	ES
	PUSH	DI
	PUSH	CX
	MOV	AX,error_lock_violation
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	LES	BP,[THISDPB]
	MOV	DI,1				; Fake some registers
	MOV	CX,DI
	MOV	DX,ES:[BP.dpb_first_sector]
	invoke	HARDERR
	POP	CX
	POP	DI
	POP	ES
	POP	DS
	CMP	AL,1
	retz			; 1 = retry, carry clear
	STC
	return

EndProc LOCK_VIOLATION

IF  INSTALLED

;	do a retz to return error

Procedure   CheckShare,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	push	ds					;smr;
	getdseg	<ds>			; ds -> dosdata
	CMP     fShare,0
	pop	ds					;smr;
	ASSUME	DS:NOTHING				;smr;
	return
EndProc CheckShare

ENDIF

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\handle.asm ===
TITLE	HANDLE - Handle-related system calls
	NAME	HANDLE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Handle related system calls for MSDOS 2.X.  Only top-level system calls
;	are present.	I/O specs are defined in DISPATCH.  The system calls are:
;
;	$Close	   written
;	$Commit    written		  DOS 3.3  F.C. 6/4/86
;	$ExtHandle written		  DOS 3.3  F.C. 6/4/86
;	$Read	   written
;	Align_Buffer		  DOS 4.00
;	$Write	   written
;	$LSeek	   written
;	$FileTimes written
;	$Dup	   written
;	$Dup2	   written
;
;	Revision history:
;
;	    Created: MZ 28 March 1983
;		 MZ 15 Dec   1982 Jeff Harbers and Multiplan hard disk copy
;				  rely on certain values in AX when $CLOSE
;				  succeeds even though we document it as
;				  always trashing AX.
;
;	    A000	version 4.00  Jan. 1988

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include mult.inc
	include pdb.inc
	include filemode.inc
	include syscall.inc
	include bugtyp.inc
	.cref
	.list


DOSDATA Segment

	extrn	ThisSFT:dword		; pointer to SFT entry
	extrn	DMAAdd:dword		; old-style DMA address
	extrn	EXTERR_LOCUS:byte	; Extended Error Locus
	extrn	FailErr:byte		; failed error flag
	extrn	User_ID:word		; current effective user_id
	extrn	JShare:dword		; jump table
	extrn	CurrentPDB:word 	; current process data block
	extrn	EXTOPEN_ON:byte 	; flag for extended open
	extrn	THISCDS:dword
	extrn	DUMMYCDS:byte
	extrn	SAVE_ES:word		; saved ES
	extrn	SAVE_DI:word		; saved DI
	extrn	SAVE_DS:word		; saved DS
	extrn	SAVE_SI:word		; saved SI
	extrn	SAVE_CX:word		; saved CX

;SR;
;   Flag to indicate WIN386 presence
;
	extrn	IsWin386:byte

DOSDATA ENDS

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	DOS_Read:NEAR
	EXTRN	DOS_Write:NEAR
	EXTRN	pJfnFromHandle:near


	BREAK <$Close - return a handle to the system>


;**	$Close - Close a file Handle
;
;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
;		path
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Close
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	<normal INT21 return convention>
;	USES	all

Procedure   $Close,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	fmt TypSysCall,LevArgs,<"$p  Handle = $x\n">,<BX>

;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	DLJC	CloseError		; error return
	fmt TypAccess,LevSFN,<"$p  Close SFT $x:$x\n">,<es,di>
	context DS			; For DOS_CLOSE
	MOV	WORD PTR [ThisSFT],DI	; save offset of pointer
	MOV	WORD PTR [ThisSFT+2],ES ; save segment value

; DS:SI point to JFN table entry.
; ES:DI point to SFT
;
; We now examine the user's JFN entry; If the file was a 70-mode file (network
; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
; If the file was not a net FCB, we free the JFN too.

	CMP	ES:[DI].sf_ref_count,1	; will the SFT become free?
	JZ	FreeJFN 		; yes, free JFN anyway.
	MOV	AL,BYTE PTR ES:[DI].sf_mode
	AND	AL,sharing_mask
	CMP	AL,sharing_net_fcb
	JZ	PostFree		; 70-mode and big ref count => free it

; The JFN must be freed.  Get the pointer to it and replace the contents with
; -1.

FreeJFN:
	call	pJFNFromHandle		;   d = pJFN (handle);
	fmt TypAccess,LevSFN,<"$p  Close jfn pointer $x:$x\n">,<es,di>
	MOV	BYTE PTR ES:[DI],0FFh	; release the JFN
PostFree:

; ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_CLOSE!

	invoke	DOS_Close

; DOS_Close may return an error.  If we see such an error, we report it but
; the JFN stays closed because DOS_Close always frees the SFT!

	JC	CloseError
	MOV	AH,close		; MZ Bogus multiplan fix
	transfer    Sys_Ret_OK
CloseError:
	ASSUME	DS:NOTHING
	transfer    Sys_Ret_Err
EndProc $Close

	BREAK <$Commit - commit the file>

;**	$Commit - Commit a File
;
;	$Commit "commits" a file to disk - all of it's buffers are
;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
;	the directory entry, etc., so this commit is pretty useless.  check
;	and fix this!! jgl
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Commit
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	none
;	USES	all

Procedure   $Commit,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	JC	Commiterror		; error return
	context DS			; For DOS_COMMIT
	MOV	WORD PTR [ThisSFT],DI	; save offset of pointer
	MOV	WORD PTR [ThisSFT+2],ES ; save segment value

;	ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_COMMIT
;
;	ES:DI point to SFT

	invoke	DOS_COMMIT
	JC	Commiterror
	MOV	AH,Commit		;
	transfer    Sys_Ret_OK
Commiterror:
	ASSUME	DS:NOTHING
	transfer    Sys_Ret_Err

EndProc $Commit


	BREAK <$ExtHandle - extend handle count>

;**	$ExtHandle - Extend Handle Count
;
;	Assembler usage:
;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
;	    MOV     AX, 6700H			 reserved to mark SFT
;	    INT     int_command 		 busy )
;
;	ENTRY	(bx) = new number of handles
;	EXIT	'C' clear if OK
;		'C' set iff err
;		  (ax) = error code
;			 AX = error_not_enough_memory
;			      error_too_many_open_files
;	USES	all

Procedure   $ExtHandle,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
	CMP	BX,FilPerProc
	JAE	exth2			; Don't set less than FilPerProcno
	MOV	BX,FilPerProc

exth2:	MOV	ES,CurrentPDB		; get user process data block;smr;SS Override
	MOV	CX,ES:PDB_JFN_Length	; get number of handle allowed
	CMP	BX,CX			; the requested == current
	JE	ok_done 		; yes and exit
	JA	larger			; go allocate new table

;	We're going to shrink the # of handles available

	MOV	BP,1			; shrink
	MOV	DS,WORD PTR ES:[PDB_JFN_Pointer+2] ;
	MOV	SI,BX			;
	SUB	CX,BX			; get difference

;	BUGBUG - code a SCASB here, should be a bit smaller
chck_handles:
	CMP	BYTE PTR DS:[SI],-1	; scan through handles to ensure close
	JNZ	too_many_files		; status
	INC	SI
	LOOP	chck_handles
	CMP	BX,FilPerProc		; = 20
	JA	larger			; no

	MOV	BP,2			; psp
	MOV	DI,PDB_JFN_Table	; es:di -> jfn table in psp
	PUSH	BX
	JMP	short movhandl

larger:
	CMP	BX,-1			; 65535 is not allowed
	JZ	invalid_func
	CLC
	PUSH	BX			; save requested number
	ADD	BX,0FH			; adjust to paragraph boundary
	MOV	CL,4
	RCR	BX,CL			; DOS 4.00 fix				;AC000;
	AND	BX,1FFFH		; clear most 3 bits

	PUSH	BP
	invoke	$ALLOC			; allocate memory
	POP	BP
	JC	no_memory		; not enough meory

	MOV	ES,AX			; es:di points to new table memory
	XOR	DI,DI
movhandl:
	MOV	DS,[CurrentPDB] 	; get user PDB address	;smr;SS Override

	test	BP,3			; enlarge ?
	JZ	enlarge 		; yes
	POP	CX			; cx = the amount you shrink
	PUSH	CX
	JMP	short copy_hand

;	Done.  'C' clear

ok_done:transfer    Sys_Ret_OK

too_many_files:
	MOV	AL,error_too_many_open_files
	transfer    Sys_Ret_Err


enlarge:
	MOV	CX,DS:[PDB_JFN_Length]	  ; get number of old handles
copy_hand:
	MOV	DX,CX
	LDS	SI,DS:[PDB_JFN_Pointer]   ; get old table pointer
ASSUME DS:NOTHING
	REP	MOVSB			; copy infomation to new table

	POP	CX			; get new number of handles
	PUSH	CX			; save it again
	SUB	CX,DX			; get the difference
	MOV	AL,-1			; set availability to handles
	REP	STOSB

	MOV	DS,[CurrentPDB] 	; get user process data block;smr;SS Override
	CMP	WORD PTR DS:[PDB_JFN_Pointer],0  ; check if original table pointer
	JNZ	update_info		; yes, go update PDB entries
	PUSH	BP
	PUSH	DS			; save old table segment
	PUSH	ES			; save new table segment
	MOV	ES,WORD PTR DS:[PDB_JFN_Pointer+2] ; get old table segment
	invoke	$DEALLOC		; deallocate old table meomory
	POP	ES			; restore new table segment
	POP	DS			; restore old table segment
	POP	BP

update_info:
	test	BP,2			; psp?
	JZ	non_psp 		; no
	MOV	WORD PTR DS:[PDB_JFN_Pointer],PDB_JFN_Table   ; restore
	JMP	short final
non_psp:
	MOV	WORD PTR DS:[PDB_JFN_Pointer],0  ; new table pointer offset always 0
final:
	MOV	WORD PTR DS:[PDB_JFN_Pointer+2],ES  ; update table pointer segment
	POP	DS:[PDB_JFN_Length]	 ; restore new number of handles
	transfer   Sys_Ret_Ok
no_memory:
	POP	BX			; clean stack
	MOV	AL,error_not_enough_memory
	transfer    Sys_Ret_Err
invalid_func:
	MOV	AL,error_invalid_function
	transfer    Sys_Ret_Err
EndProc $ExtHandle

	BREAK <$READ - Read from a file handle>

;**	$Read - Read from a File Handle
;
;   Assembler usage:
;
;	LDS	DX, buf
;	MOV	CX, count
;	MOV	BX, handle
;	MOV	AH, Read
;	INT	int_command
;	  AX has number of bytes read
;
;	ENTRY	(bx) = file handle
;		(cx) = byte count
;		(ds:dx) = buffer address
;	EXIT	Through system call return so that to user:
;		  'C' clear if OK
;		    (ax) = bytes read
;		  'C' set if error
;		    (ax) = error code

procedure   $READ,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	fmt TypSysCall,LevArgs,<" Handle $x Cnt $x Buf $x:$x\n">,<BX,CX,DS,DX>

	MOV	SI,OFFSET DOSCODE:DOS_Read
ReadDo:	call	pJFNFromHandle
	JC	ReadError
	MOV	AL,ES:[DI]
	call	CheckOwner		; get the handle
	JNC	ReadSetup		; no errors do the operation

;	Have an error.	'C' set

ReadError:
	transfer    SYS_RET_ERR 	; go to error traps

ReadSetup:
	MOV	WORD PTR [ThisSFT],DI	; save offset of pointer;smr;SS Override
	MOV	WORD PTR [ThisSFT+2],ES ; save segment value	;smr;SS Override
;; Extended Open
	TESTB	ES:[DI.sf_mode],INT_24_ERROR  ;AN000;;EO. need i24
	JZ	needi24 		      ;AN000;;EO. yes
	OR	[EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;;EO. set it off;smr;SS Override
needi24:				      ;AN000;

;; Extended Open
	SAVE	<<WORD PTR [DMAAdd]>, <WORD PTR [DMAAdd+2]>>;smr;SS Override
;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
	CALL	Align_Buffer		;AN000;MS. align user's buffer
;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
	context DS			; go for DOS addressability
	CALL	SI			; indirect call to operation
	RESTORE <<WORD PTR [DMAAdd+2]>, <WORD PTR [DMAAdd]>>

	JNC	READ_OK 		      ;AN002;
	JMP	READERROR		      ;AN002; if error, say bye bye

READ_OK:
	MOV	AX,CX			; get correct return in correct reg
	transfer    sys_ret_ok		; successful return

EndProc $READ

;
;   Input: DS:DX points to user's buffer addr
;   Function: rearrange segment and offset for READ/WRITE buffer
;   Output: [DMAADD] set
;
;

procedure   Align_Buffer,NEAR		;AN000;
	ASSUME	CS:DOSCODE,SS:DOSDATA  ;AN000;
	MOV	BX,DX			; copy offset
	SAVE	<CX>			; don't stomp on count
	MOV	CL,4			; bits to shift bytes->para
	SHR	BX,CL			; get number of paragraphs
	RESTORE <CX>		; get count back
	MOV	AX,DS			; get original segment
	ADD	AX,BX			; get new segment
	MOV	DS,AX			; in seg register
	AND	DX,0Fh			; normalize offset
	MOV	WORD PTR [DMAAdd],DX	; use user DX as offset	;smr;SS Override
	MOV	WORD PTR [DMAAdd+2],DS	; use user DS as segment for DMA;smr;SS Override
	return				;AN000;
EndProc Align_Buffer			;AN000;

BREAK <$WRITE - write to a file handle>

;
;   Assembler usage:
;	    LDS     DX, buf
;	    MOV     CX, count
;	    MOV     BX, handle
;	    MOV     AH, Write
;	    INT     int_command
;	  AX has number of bytes written
;   Errors:
;	    AX = write_invalid_handle
;	       = write_access_denied
;
;   Returns in register AX

procedure   $WRITE,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	fmt TypSysCall,LevArgs,<" Handle $x Cnt $x Buf $x:$x\n">,<BX,CX,DS,DX>
	MOV	SI,OFFSET DOSCODE:DOS_Write
	JMP	ReadDo
EndProc $Write

BREAK <$LSEEK - move r/w pointer>

;
;   Assembler usage:
;	    MOV     DX, offsetlow
;	    MOV     CX, offsethigh
;	    MOV     BX, handle
;	    MOV     AL, method
;	    MOV     AH, LSeek
;	    INT     int_command
;	  DX:AX has the new location of the pointer
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;   Returns in registers DX:AX

procedure   $LSEEK,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	call	CheckOwner		; get system file entry
LSeekError:
	JNC	CHKOWN_OK		;AN002;
	JMP	ReadError		;AN002; error return

CHKOWN_OK:				;AN002;
	CMP	AL,2			; is the seek value correct?
	JBE	LSeekDisp		; yes, go dispatch
	MOV	EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus	;smr;SS Override
	error	error_invalid_function	; invalid method
LSeekDisp:
	CMP	AL,1			; best way to dispatch; check middle
	JB	LSeekStore		; just store CX:DX
	JA	LSeekEOF		; seek from end of file
	ADD	DX,WORD PTR ES:[DI.SF_Position]
	ADC	CX,WORD PTR ES:[DI.SF_Position+2]
LSeekStore:
	MOV	AX,CX			; AX:DX
	XCHG	AX,DX			; DX:AX is the correct value
LSeekSetpos:
	MOV	WORD PTR ES:[DI.SF_Position],AX
	MOV	WORD PTR ES:[DI.SF_Position+2],DX
	invoke	Get_user_stack
	MOV	DS:[SI.User_DX],DX	; return DX:AX
	transfer    SYS_RET_OK		; successful return

LSeekEOF:
	TESTB	ES:[DI].SF_FLAGS,sf_isnet
	JNZ	Check_LSeek_Mode	; Is Net
LOCAL_LSeek:
	ADD	DX,WORD PTR ES:[DI.SF_Size]
	ADC	CX,WORD PTR ES:[DI.SF_Size+2]
	JMP	LSeekStore		; go and set the position

Check_LSeek_Mode:
	TESTB	ES:[DI.sf_mode],sf_isfcb
	JNZ	LOCAL_LSeek		; FCB treated like local file
	MOV	AX,ES:[DI.sf_mode]
	AND	AX,sharing_mask
	CMP	AX,sharing_deny_none
	JZ	NET_LSEEK		; LSEEK exported in this mode
	CMP	AX,sharing_deny_read
	JNZ	LOCAL_LSeek		; Treated like local Lseek
NET_LSEEK:
;	 JMP	 LOCAL_LSeek
; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
	CallInstall Net_Lseek,multNet,33
	JNC	LSeekSetPos
	transfer    SYS_RET_ERR

EndProc $LSeek

BREAK <FileTimes - modify write times on a handle>


;----------------------------------------------------------------------------
;   Assembler usage:
;	    MOV AH, FileTimes (57H)
;	    MOV AL, func
;	    MOV BX, handle
;	; if AL = 1 then then next two are mandatory
;	    MOV CX, time
;	    MOV DX, date
;	    INT 21h
;	; if AL = 0 then CX/DX has the last write time/date
;	; for the handle.
;
;	AL=02		 get extended attributes
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   DS:SI query list (si=-1, selects all EA)
;	   ES:DI buffer to hold EA list
;
;	AL=03		 get EA name list
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   ES:DI buffer to hold name list
;
;	AL=04		 set extended attributes
;	   BX=handle
;	   ES:DI buffer of EA list
;
;
;
;
;   Error returns:
;	    AX = error_invalid_function
;	       = error_invalid_handle
;----------------------------------------------------------------------------

procedure   $File_Times,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	cmp	al, 2			; correct subfunction ?
	jae	inval_func

	call	CheckOwner		; get sft
	jc	LSeekError		; bad handle

	or	al, al			; get time/date ?
	jnz	ft_set_time

;------ here we get the time & date from the sft for the user

	cli				; is this cli/sti reqd ? BUGBUG
	mov	cx, es:[di].sf_Time	; get the time
	mov	dx, es:[di].sf_Date	;  & date
	sti
	invoke	Get_User_Stack
	mov	[si].user_CX, cx
	mov	[si].user_DX, dx
	jmp	short ok_ret

;------ here we set the time in sft

ft_set_time:
	EnterCrit critSFT
	mov	es:[di].sf_Time, cx	; drop in new time
	mov	es:[di].sf_Date, dx	;  and date

	xor	ax, ax
if installed
	Call	JShare + 14 * 4		; SS Override
else
	Call	ShSU
endif

;------ set the flags in SFT entry

	and	es:[di].sf_Flags,NOT DEVID_FILE_CLEAN	; mark file as dirty

	or	es:[di].sf_Flags,SF_CLOSE_NODATE	; ask close not to
							;   bother about date
							;   and time
	LeaveCrit   critSFT
ok_ret:
	transfer SYS_RET_OK

inval_func:
	mov	ExtErr_Locus,errLoc_Unk ; Extended Error Locus	;SS Override
	error	error_invalid_function	; give bad return

EndProc $File_Times

BREAK <$DUP - duplicate a jfn>
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     AH, Dup
;	    INT     int_command
;	  AX has the returned handle
;   Errors:
;	    AX = dup_invalid_handle
;	       = dup_too_many_open_files

Procedure   $DUP,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AX,BX			; save away old handle in AX
	invoke	JFNFree 		; free handle? into ES:DI, new in BX
DupErrorCheck:
	JC	DupErr			; nope, bye
	SAVE	<ES,DI> 		; save away SFT
	RESTORE <SI,DS>		; into convenient place DS:SI
	XCHG	AX,BX			; get back old handle
	call	CheckOwner		; get sft in ES:DI
	JC	DupErr			; errors go home
	invoke	DOS_Dup_Direct
	call	pJFNFromHandle		; get pointer
	MOV	BL,ES:[DI]		; get SFT number
	MOV	DS:[SI],BL		; stuff in new SFT
	transfer    SYS_RET_OK		; and go home
DupErr: transfer    SYS_RET_ERR

EndProc $Dup

BREAK <$DUP2 - force a dup on a particular jfn>
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     CX, newfh
;	    MOV     AH, Dup2
;	    INT     int_command
;   Error returns:
;	    AX = error_invalid_handle

Procedure   $Dup2,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<BX,CX> 		; save source
	MOV	BX,CX			; get one to close
	invoke	$Close			; close destination handle
	RESTORE <BX,AX>		; old in AX, new in BX
	call	pJFNFromHandle		; get pointer
	JMP	DupErrorCheck		; check error and do dup
EndProc $Dup2

Break	<CheckOwner - verify ownership of handles from server>

;
;   CheckOwner - Due to the ability of the server to close file handles for a
;   process without the process knowing it (delete/rename of open files, for
;   example), it is possible for the redirector to issue a call to a handle
;   that it soes not rightfully own.  We check here to make sure that the
;   issuing process is the owner of the SFT.  At the same time, we do a
;   SFFromHandle to really make sure that the SFT is good.
;
;	ENTRY	BX has the handle
;		User_ID is the current user
;	EXIT	Carry Clear => ES:DI points to SFT
;		Carry Set => AX has error code
;	USES	none

Procedure   CheckOwner,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	invoke	SFFromHandle
	jc	ret_label	; retc
	push	ax

;SR;
;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
;SR; are shared across multiple VMs in win386.
;SR;
	test	[IsWin386],1
	jz	no_win386		;win386 is not present
	xor	ax,ax			;set the zero flag
	jmp	short skip_win386	

no_win386:

	mov	ax,user_id					;smr;SS Override
	cmp	ax,es:[di].sf_UID

skip_win386:

	pop	ax
	retz
	mov	al,error_invalid_handle
	stc

ret_label:
	return
EndProc CheckOwner

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\ioctl.asm ===
PAGE	,132

	TITLE	IOCTL - IOCTL system call
	NAME	IOCTL

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	IOCTL system call.
;
;	$IOCTL
;
;	  Revision history:
;
;		Created: ARR 4 April 1983
;
;		GenericIOCTL added:		KGS	22 April 1985
;
;		A000	version 4.00	Jan. 1988
;
;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include bpb.inc
	include mult.inc
	include dpb.inc
	include sf.inc
	include vector.inc
	include curdir.inc
	include ioctl.inc
	.cref
	.list

	i_need	THISCDS,DWORD
	i_need	IOCALL,BYTE
	i_need	IOMED,BYTE
	i_need	IOSCNT,WORD
	i_need	IOXAD,DWORD
	I_need	RetryCount,WORD
	I_need	RetryLoop,WORD
	I_need	EXTERR_LOCUS,BYTE
	I_need	OPENBUF,BYTE
	I_need	ExtErr,WORD
	I_need	DrvErr,BYTE
	I_need	USER_IN_AX,WORD 		;AN000;
	I_need	Temp_Var2,WORD			;AN000;

	extrn	GetThisDrv:near

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

BREAK <IOCTL - munge on a handle to do device specific stuff>
;---------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, Handle
;	    MOV     DX, Data
;
;	(or LDS     DX,BUF
;	    MOV     CX,COUNT)
;
;	    MOV     AH, Ioctl
;	    MOV     AL, Request
;	    INT     21h
;
;   AH = 0  Return a combination of low byte of sf_flags and device driver
;	    attribute word in DX, handle in BX:
;	    DH = high word of device driver attributes
;	    DL = low byte of sf_flags
;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
;	    in BX.
;	 2  Read CX bytes from the device control channel for handle in BX
;	    into DS:DX.  Return number read in AX.
;	 3  Write CX bytes to the device control channel for handle in BX from
;	    DS:DX.  Return bytes written in AX.
;	 4  Read CX bytes from the device control channel for drive in BX
;	    into DS:DX.  Return number read in AX.
;	 5  Write CX bytes to the device control channel for drive in BX from
;	    DS:DX.  Return bytes written in AX.
;	 6  Return input status of handle in BX. If a read will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 7  Return output status of handle in BX. If a write will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 8  Given a drive in BX, return 1 if the device contains non-
;	    removable media, 0 otherwise.
;	 9  Return the contents of the device attribute word in DX for the
;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
;	    network. 8000h is the bit for local use.
;	 A  Return 8000h if the handle in BX is for the network or not.
;	 B  Change the retry delay and the retry count for the system. BX is
;	    the count and CX is the delay.
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_invalid_data
;
;-------------------------------------------------------------------------------
;
;   This is the documentation copied from DOS 4.0 it is much better
;   than the above
;
;	There are several basic forms of IOCTL calls:
;
;
;	** Get/Set device information:	**
;
;	ENTRY	(AL) = function code
;		  0 - Get device information
;		  1 - Set device information
;		(BX) = file handle
;		(DX) = info for "Set Device Information"
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = info for "Get Device Information"
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Handle  **
;
;	ENTRY	(AL) = function code
;		  2 - Read device control info
;		  3 - Write device control info
;		(BX) = file handle
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Block Device  **
;
;	ENTRY	(AL) = function code
;		  4 - Read device control info
;		  5 - Write device control info
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Get Input/Output Status  **
;
;	ENTRY	(AL) = function code
;		  6 - Get Input status
;		  7 - Get Output Status
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AL) = 00 if not ready
;		  (AL) = FF if ready
;	USES	ALL
;
;
;	**  Get Drive Information  **
;
;	ENTRY	(AL) = function code
;		  8 - Check for removable media
;		  9 - Get device attributes
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = 0/1 media is removable/fixed (func. 8)
;		  (DX) = device attribute word (func. 9)
;	USES	ALL
;
;
;	**  Get Redirected bit	**
;
;	ENTRY	(AL) = function code
;		  0Ah - Network stuff
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = SFT flags word, 8000h set if network file
;	USES	ALL
;
;
;	**  Change sharer retry parameters  **
;
;	ENTRY	(AL) = function code
;		  0Bh - Set retry parameters
;		(CX) = retry loop count
;		(DX) = number of retries
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;	USES	ALL
;
;
;   =================================================================
;
;	**  New Standard Control  **
;
;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
;	FORMS ARE OBSOLETE.
;
;   =================================================================
;
;	ENTRY	(AL) = function code
;		  0Ch - Control Function subcode
;		(BX) = File Handle
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (SI) = Return value, meaning is function dependent
;		  (DI) = Return value, meaning is function dependent
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;    ============== Generic IOCTL Definitions for DOS 3.2 ============
;     (See inc\ioctl.inc for more info)
;
;	ENTRY	(AL) = function code
;		  0Dh - Control Function subcode
;		(BL) = Drive Number (0 = Default, 1= 'A')
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;---------------------------------------------------------------------------

TABENT	macro ORDINAL, handler_address

;	.errnz	$-IOCTLJMPTABLE-2*ORDINAL
	DW	handler_address

	endm

IOCTLJMPTABLE	label	word
		TABENT	IOCTL_GET_DEVICE_INFO   , ioctl_getset_data	; 0
		TABENT	IOCTL_SET_DEVICE_INFO	, ioctl_getset_data   	; 1
		TABENT	IOCTL_READ_HANDLE	, ioctl_control_string	; 2
		TABENT	IOCTL_WRITE_HANDLE	, ioctl_control_string	; 3
		TABENT 	IOCTL_READ_DRIVE	, ioctl_get_dev		; 4
		TABENT 	IOCTL_WRITE_DRIVE	, ioctl_get_dev		; 5
		TABENT 	IOCTL_GET_INPUT_STATUS	, ioctl_status		; 6
		TABENT 	IOCTL_GET_OUTPUT_STATUS , ioctl_status		; 7
		TABENT 	IOCTL_CHANGEABLE?	, ioctl_rem_media	; 8
		TABENT 	IOCTL_DeviceLocOrRem?	, Ioctl_Drive_attr	; 9
		TABENT 	IOCTL_HandleLocOrRem?	, IOCTL_Handle_Redir	; a
		TABENT 	IOCTL_SHARING_RETRY	, Set_Retry_Parameters	; b
		TABENT 	GENERIC_IOCTL_HANDLE	, GENERICIOCTLHANDLE	; c
		TABENT 	GENERIC_IOCTL		, GENERICIOCTL		; d
		TABENT  IOCTL_GET_DRIVE_MAP 	, ioctl_drive_owner	; e
		TABENT  IOCTL_SET_DRIVE_MAP	, ioctl_drive_owner	; f
		TABENT 	IOCTL_QUERY_HANDLE	, query_handle_support	; 10
		TABENT 	IOCTL_QUERY_BLOCK	, query_device_support	; 11

	procedure   $IOCTL,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING


	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
	context DS			;hkn; SS is DOSDATA

	cmp	al, 11h			; al must be between 0 & 11h
	ja	ioctl_bad_funj2		; if not bad function #

	push	AX			; Need to save AL for generic IOCTL
	mov	di, ax			; di NOT a PARM
	and	di, 0ffh		; di = al
	shl	di, 1			; di = index into jmp table
	pop	AX			; Restore AL for generic IOCTL

	jmp	word ptr cs:[IOCTLJMPTABLE+di]


ioctl_bad_funj2:
	JMP	ioctl_bad_fun


;--------------------------------------------------------------------------
;
; IOCTL: AL= 0,1
;
; ENTRY : DS = DOSDATA
;
;---------------------------------------------------------------------

ioctl_getset_data:

	invoke	SFFromHandle		; ES:DI -> SFT
	JNC	ioctl_check_permissions ; have valid handle
ioctl_bad_handle:
	error	error_invalid_handle

ioctl_check_permissions:
	CMP	AL,0
	MOV	AL,BYTE PTR ES:[DI].SF_FLAGS; Get low byte of flags
	JZ	ioctl_read		; read the byte

;**RMFHFE**	test	dh, 0feh		;AN000;MS.allow dh=1

	or	dh, dh
	JZ	ioctl_check_device	; can I set with this data?
	error	error_invalid_data	; no DH <> 0

ioctl_check_device:
	test	AL,devid_device 	; can I set this handle?

;**RMFHFE**	JZ	do_exception		; no, it is a file.

	jz	ioctl_bad_funj2
	OR	DL,devid_device 	; Make sure user doesn't turn off the
					;   device bit!! He can muck with the
					;   others at will.
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	MOV	BYTE PTR ES:[DI].SF_FLAGS,DL  ;AC000;MS.; Set flags


;**RMFHFE**do_exception:
;**RMFHFE**	OR	BYTE PTR ES:[DI.sf_flags+1],DH;AN000;MS.;set 100H bit for disk full

	transfer    SYS_RET_OK



ioctl_read:
	MOV	[EXTERR_LOCUS],errLOC_Disk
	XOR	AH,AH
	test	AL,devid_device 	; Should I set high byte
	JZ	ioctl_no_high		; no
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	LES	DI,ES:[DI.sf_devptr]	; Get device pointer
	MOV	AH,BYTE PTR ES:[DI.SDEVATT+1]	; Get high byte
ioctl_no_high:
	MOV	DX,AX
	invoke	get_user_stack
	MOV	[SI.user_DX],DX
	transfer    SYS_RET_OK


;--------------------------------------------------------------------------
;
; IOCTL: 2,3
;
; ENTRY : DS = DOSDATA
;	  Si = user's DS
;
;--------------------------------------------------------------------------

ioctl_control_string:

	invoke	SFFromHandle		; ES:DI -> SFT
	JC	ioctl_bad_handle	; invalid handle
	TESTB	ES:[DI].SF_FLAGS,devid_device	; can I?
	jz	ioctl_bad_funj2			; No it is a file
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	LES	DI,ES:[DI.sf_devptr]	; Get device pointer
	XOR	BL,BL			; Unit number of char dev = 0
	JMP	ioctl_do_string


;--------------------------------------------------------------------------
;
; IOCTL: AL = 6,7
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_status:

	MOV	AH,1
	SUB	AL,6			; 6=0,7=1
	JZ	ioctl_get_status
	MOV	AH,3
ioctl_get_status:
	PUSH	AX
	invoke	GET_IO_SFT
	POP	AX
	JNC	DO_IOFUNC
	JMP	ioctl_bad_handle	; invalid SFT

DO_IOFUNC:
	invoke	IOFUNC
	MOV	AH,AL
	MOV	AL,0FFH
	JNZ	ioctl_status_ret
	INC	AL
ioctl_status_ret:
	transfer SYS_RET_OK


;------------------------------------------------------------------------
;
; IOCTL: AL = B
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

Set_Retry_Parameters:
	MOV	RetryLoop,CX		; 0 retry loop count allowed
	OR	DX,DX			; zero retries not allowed
	JZ	IoCtl_Bad_Fun
	MOV	RetryCount,DX		; Set new retry count
doneok:
	transfer	Sys_Ret_Ok	; Done

;--------------------------------------------------------------------------
;
; Generic IOCTL entry point. AL = C, D, 10h, 11h
;
;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
;	SI:DX -> Users Device Parameter Table
;	IOCALL -> IOCTL_Req structure
;
; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
;	call.
;
; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;----------------------------------------------------------------------------

query_handle_support:	; Entry point for handles
GENERICIOCTLHANDLE:

	invoke	SFFromHandle		; Get SFT for device.
	jc	ioctl_bad_handlej

	TESTB	ES:[DI].SF_FLAGS,sf_isnet	; M031;
	jnz	ioctl_bad_fun		; Cannot do this over net.

	mov	[EXTERR_LOCUS],ErrLOC_Serdev
	les	di,es:[di.sf_devptr]	; Get pointer to device.
	jmp	short Do_GenIOCTL

query_device_support:	; Entry point for devices:
GENERICIOCTL:

	mov	[EXTERR_LOCUS],ErrLOC_Disk
	cmp	ch,IOC_DC		; Only disk devices are allowed to use
	jne	ioctl_bad_fun		; no handles with Generic IOCTL.

	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
	JNZ	ioctl_bad_fun		; There are no "net devices", and they

Do_GenIOCTL:

	TESTB	ES:[DI.SDEVATT],DEV320	; Can device handle Generic IOCTL funcs
	jz	ioctl_bad_fun

	mov	byte ptr IOCALL.ReqFunc,GENIOCTL ;Assume real Request
	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
	jl	SetIOCtlBlock

	TESTB	ES:[DI.SDEVATT],IOQUERY ; See if device supports a query
	jz	ioctl_bad_fun		  ; No support for query 

	mov	byte ptr IOCALL.ReqFunc,IOCTL_QUERY ; Just a query (5.00)

SetIOCtlBlock:
	PUSH	ES			; DEVIOCALL2 expects Device header block
	PUSH	DI			; in DS:SI
					; Setup Generic IOCTL Request Block
	mov	byte ptr IOCALL.ReqLen,(size IOCTL_Req)
	MOV	byte ptr IOCALL.ReqUnit,BL
	MOV	byte ptr IOCALL.MajorFunction,CH
	MOV	byte ptr IOCALL.MinorFunction,CL
	MOV	word ptr IOCALL.Reg_SI,SI
	MOV	word ptr IOCALL.Reg_DI,DI
	MOV	word ptr IOCALL.GenericIOCTL_Packet,DX
	MOV	word ptr IOCALL.GenericIOCTL_Packet + 2,SI

;hkn; IOCALL is in DOSDATA
	MOV	BX,offset DOSDATA:IOCALL

	PUSH	SS
	POP	ES

ASSUME DS:NOTHING			; DS:SI -> Device header.
	POP	SI
	POP	DS
	jmp	ioctl_do_IO		; Perform Call to device driver

ioctl_bad_fun:
	error	error_invalid_function

ioctl_bad_handlej:
	jmp	ioctl_bad_handle

;---------------------------------------------------------------------------
;
; IOCTL AL = 8
;
; ENTRY:  DS = DOSDATA
;
; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ioctl_rem_media:

	CALL	Check_If_Net
	JNZ	ioctl_bad_fun		; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	TESTB	ES:[DI.SDEVATT],DEVOPCL ; See if device can
	JZ	ioctl_bad_fun		; NO

;hkn; SS override for IOCALL
	MOV	[IOCALL.REQFUNC],DEVRMD
	MOV	AL,REMHL
	MOV	AH,BL			; Unit number
	MOV	WORD PTR [IOCALL.REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL.REQSTAT],AX
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

;hkn; IOCALL is in DOSDATA (msconst.asm)
	MOV	BX,OFFSET DOSDATA:IOCALL   ; ES:BX -> Call header
	SAVE	<DS,SI>
	invoke	DEVIOCALL2
	RESTORE <SI,DS>

;hkn; SS override
	MOV	AX,[IOCALL.REQSTAT]	; Get Status word
	AND	AX,STBUI		; Mask to busy bit
	MOV	CL,9
	SHR	AX,CL			; Busy bit to bit 0
	transfer    SYS_RET_OK

;-------------------------------------------------------------------------
;
; IOCTL: AL = 9
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

Ioctl_Drive_attr:
	mov	al, bl
	call	GetThisDrv
	jc	ioctl_drv_err
	call	Get_Driver_BL
	JC	ioctl_drv_err		; drive not valid

	mov	dx,word ptr es:[di.SDEVATT]	
					; get device attribute word
	MOV	BL,AL			; Phys letter to BL (A=0)

;hkn; SS override
	LES	DI,[THISCDS]
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	JZ	IOCTLShare

;	Net devices don't return a device attribute word.
;	Bit 12 = 1, meaning net device, all others = 0.

	MOV	DX,1000h
IOCTLShare:
	Context DS
ASSUME	DS:NOTHING

;hkn; OPENBUF is in DOSDATA
	MOV	SI,OFFSET DOSDATA:OPENBUF
	ADD	BL,"A"
	MOV	[SI],BL
	MOV	WORD PTR [SI+1],003AH	; ":",0
	MOV	AX,0300H
	CLC
	INT	int_IBM
	JNC	ioctlLocal		; Not shared
	OR	DX,0200H		; Shared, bit 9
IOCTLLocal:
	TESTB	ES:[DI].curdir_flags,curdir_local
	JZ	ioctl_set_dx
	OR	DX,8000h

ioctl_set_DX:
	invoke	get_user_stack
	MOV	[SI.user_DX],DX
	transfer    SYS_RET_OK

ioctl_drv_err:

	error	error_invalid_drive

;--------------------------------------------------------------------------
; IOCTL: AL = A
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

Ioctl_Handle_redir:
	invoke	SFFromHandle		; ES:DI -> SFT
	JNC	ioctl_got_sft		; have valid handle
	jmp	ioctl_bad_handle

ioctl_got_sft:
	MOV	DX,ES:[DI].SF_FLAGS	; Get flags
	JMP	ioctl_set_DX		; pass dx to user and return

ioctl_bad_funj:
	JMP	ioctl_bad_fun

;--------------------------------------------------------------------------
;
; IOCTL: AL= 4,5
;
; ENTRY: DS = DOSDATA
;	 SI = user's DS
;
;
; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ioctl_get_dev:
 	
	DOSAssume   <DS>,"IOCtl_Get_Dev"

	CALL	Check_If_Net
	JNZ	ioctl_bad_funj		; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
ioctl_do_string:
	TESTB	ES:[DI.SDEVATT],DEVIOCTL; See if device accepts control
	JZ	ioctl_bad_funj		; NO
					; assume IOCTL read
	MOV	[IOCALL.REQFUNC],DEVRDIOCTL

	TEST	AL, 1			; is it func. 4/5 or 2/3
	JZ	ioctl_control_call	; it is read. goto ioctl_control_call

					; it is an IOCTL write
	MOV	[IOCALL.REQFUNC],DEVWRIOCTL

ioctl_control_call:
	MOV	AL,DRDWRHL
ioctl_setup_pkt:
	MOV	AH,BL			; Unit number
	MOV	WORD PTR [IOCALL.REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL.REQSTAT],AX
	MOV	[IOMED],AL
	MOV	[IOSCNT],CX
	MOV	WORD PTR [IOXAD],DX
	MOV	WORD PTR [IOXAD+2],SI
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

;hkn; IOCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:IOCALL   ; ES:BX -> Call header
ioctl_do_IO:
	invoke	DEVIOCALL2

;hkn; SS override for IOCALL
	TESTB	[IOCALL.REQSTAT],STERR	    ;Error?
	JNZ	Ioctl_string_err

;hkn; SS override
	MOV	AX,[IOSCNT]		; Get actual bytes transferred
	transfer    SYS_RET_OK

Ioctl_string_err:
	MOV	DI,[IOCALL.REQSTAT]	;Get Error
device_err:
	AND	DI,STECODE		; mask out irrelevant bits
	MOV	AX,DI
	invoke	SET_I24_EXTENDED_ERROR

;hkn; use SS override
;hkn;	mov	ax, cs:extErr
	mov	ax, ss:extErr
	transfer    SYS_RET_ERR

;--------------------------------------------------------------------------
; Proc name : Get_Driver_BL
;
;	DS is DOSDATA
;	BL is drive number (0=default)
;	Returns pointer to device in ES:DI, unit number in BL if carry clear
;	No regs modified
;
;---------------------------------------------------------------------------

Get_Driver_BL:

	DOSAssume   <DS>,"Get_Driver_BL"
    ASSUME ES:NOTHING

	PUSH	AX
	MOV	AL,BL			; Drive
	invoke	GETTHISDRV
	jc	ioctl_bad_drv
	XOR	BL,BL			; Unit zero on Net device
	MOV	[EXTERR_LOCUS],errLOC_Net
	LES	DI,[THISCDS]
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	LES	DI,ES:[DI.curdir_devptr]; ES:DI -> Dpb or net dev
	JNZ	got_dev_ptr		; Is net
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	BL,ES:[DI.dpb_UNIT]	; Unit number
	LES	DI,ES:[DI.dpb_driver_addr]  ; Driver addr
got_dev_ptr:
	CLC
ioctl_bad_drv:
	POP	AX
	return

;-------------------------------------------------------------------------
; Proc Name : Check_If_Net:
;
;
; Checks if the device is over the net or not. Returns result in ZERO flag.
; If no device is found, the return address is popped off the stack, and a
; jump is made to ioctl_drv_err.
;
; On Entry:
; Registers same as those for Get_Driver_BL
;
; On Exit:
; ZERO flag	- set if not a net device
;		- reset if net device
; ES:DI -> the device
;
;
; BUGBUG: This function assumes the following stack setup on entry
;
;	  SP+2 -> Error return address
;	  SP   -> Normal return address
;
;-------------------------------------------------------------------------

Check_If_Net:
	CALL	Get_Driver_BL
	JC	ioctl_drv_err_pop	; invalid drive letter
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	POP	DI
	POP	ES
	ret

ioctl_drv_err_pop:
	pop	ax			; pop off return address
	jmp	ioctl_drv_err

ioctl_bad_funj3:
	jmp	ioctl_bad_fun

ioctl_string_errj:
	jmp	ioctl_string_err

;--------------------------------------------------------------------------
;
; IOCTL: AL = E, F
;
; ENTRY: DS = DOSDATA
;
;
; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;--------------------------------------------------------------------------

ioctl_drive_owner:
	Call	Check_If_Net
	JNZ	ioctl_bad_funj3 	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	TESTB	ES:[DI.SDEVATT],DEV320	; See if device can handle this
	JZ	ioctl_bad_funj3 	; NO
	mov	[IOCALL.REQFUNC],DEVGETOWN	; default to get owner
	cmp	al, 0eh			; Get Owner ?
	jz	GetOwner
	MOV	[IOCALL.REQFUNC],DEVSETOWN
GetOwner:
	MOV	AL,OWNHL
	MOV	AH,BL			; Unit number
	MOV	WORD PTR [IOCALL.REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL.REQSTAT],AX
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

;hkn; IOCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:IOCALL   ; ES:BX -> Call header
	SAVE	<DS,SI>
	invoke	DEVIOCALL2
	RESTORE <SI,DS>

;hkn; SS override
	TESTB	[IOCALL.REQSTAT],STERR
	jnz	ioctl_string_errj
	MOV	AL,BYTE PTR [IOCALL.REQUNIT]	; Get owner returned by device
						; owner returned is 1-based.
	transfer    SYS_RET_OK

EndProc $IOCTL


DOSCODE ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mknode.asm ===
TITLE	MKNODE - Node maker
	NAME	MKNODE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	MKNODE.ASM
;
;	Low level routines for making a new local file system node
;	and filling in an SFT from a directory entry
;
;	BUILDDIR
;	SETDOTENT
;	MakeNode
;	NEWENTRY
;	FREEENT
;	NEWDIR
;	DOOPEN
;	RENAME_MAKE
;	CHECK_VIRT_OPEN
;
;	Revision history:
;
;	 AN000	version 4.0  Jan. 1988
;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include fastopen.inc
	include dossym.inc
	include sf.inc
	include dpb.inc
	include filemode.inc
	include devsym.inc
	.cref
	.list

        i_need  EntFree,WORD
        i_need  DirStart,WORD
        i_need  LastEnt,WORD
        i_need  ClusNum,WORD
        i_need  CurBuf,DWORD
        i_need  Attrib,BYTE
        i_need  VolID,BYTE
        i_need  Name1,BYTE
        i_need  ThisDPB,DWORD
        i_need  EntLast,WORD
        i_need  Creating,BYTE
        i_need  SecClusPos,BYTE
        i_need  ClusFac,BYTE
        i_need  NxtClusNum,WORD
        i_need  DirSec,WORD
        i_need  NoSetDir,BYTE
        i_need  THISSFT,DWORD
        i_need  SATTRIB,BYTE
        i_need  ALLOWED,BYTE
        i_need  FAILERR,BYTE
        i_need  VIRTUAL_OPEN
        I_need  FastOpen_Ext_info,BYTE        ; DOS 3.3
        I_need  FastOpenFlg,BYTE              ; DOS 3.3
        I_need  CPSWFLAG,BYTE                 ;FT. DOS 3.4                      ;AN000;
        I_need  EXTOPEN_ON,BYTE               ;FT. DOS 3.4                      ;AN000;
        I_need  EXTOPEN_FLAG,WORD             ;FT. DOS 3.4                      ;AN000;
        I_need  EXTOPEN_IO_MODE,WORD          ;FT. DOS 3.4                      ;AN000;
        I_need  HIGH_SECTOR,WORD              ;>32mb                            ;AN000;


DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE

Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>

;----------------------------------------------------------------------------
;
; Procedure Name : BUILDDIR,NEWDIR
;
; Inputs:
;       ES:BP Points to DPB
;       [THISSFT] Set if using NEWDIR entry point
;               (used by ALLOCATE)
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [DIRSTART] Points to first cluster of dir (0 means root)
; Function:
;       Grow directory if no free entries and not root
; Outputs:
;       CARRY SET IF FAILURE
;       ELSE
;          AX entry number of new entry
;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
;               AX = first entry of new dir
;       GETENT should be called to set [LASTENT]
;
;----------------------------------------------------------------------------

procedure BUILDDIR,NEAR
	DOSAssume   <DS>,"BuildDir"

        MOV     AX,[ENTFREE]
        CMP     AX,-1
        JZ      CHECK_IF_ROOT
        CLC
        return

CHECK_IF_ROOT:
        CMP     [DIRSTART],0
        JNZ     NEWDIR
        STC
        return                  ; Can't grow root

        entry   NEWDIR
        MOV     BX,[DIRSTART]
        OR      BX,BX
        JZ      NULLDIR
        invoke  GETEOF
        retc                    ; Screw up
NULLDIR:
        MOV     CX,1
        invoke  ALLOCATE
        retc
        MOV     DX,[DIRSTART]
        OR      DX,DX
        JNZ     ADDINGDIR
        invoke  SETDIRSRCH
        retc
        MOV     [LASTENT],-1
        JMP     SHORT GOTDIRREC
ADDINGDIR:
        PUSH    BX
        MOV     BX,[ClusNum]
        Invoke  IsEof
        POP     BX
        JB      NOTFIRSTGROW
;;;; 10/17/86 update CLUSNUM in the fastopen cache
        MOV     [CLUSNUM],BX
        PUSH    CX
        PUSH    AX
        PUSH    BP
        MOV     AH,1                       ; CLUSNUM update
        MOV     DL,ES:[BP.dpb_drive]       ; drive #
        MOV     CX,[DIRSTART]              ; first cluster #
        MOV     BP,BX                      ; CLUSNUM
        invoke  FastOpen_Update
        POP     BP
        POP     AX
        POP     CX

;;;; 10/17/86 update CLUSNUM in the fastopen cache
NOTFIRSTGROW:
        MOV     DX,BX
        XOR     BL,BL
        invoke  FIGREC
GOTDIRREC:
        MOV     CL,ES:[BP.dpb_cluster_mask]
        INC     CL
        XOR     CH,CH
ZERODIR:
        PUSH    CX
        MOV     [ALLOWED],allowed_FAIL + allowed_RETRY
        MOV     AL,0FFH
        invoke  GETBUFFR
        JNC     GET_SSIZE
        POP     CX
        return

GET_SSIZE:
        MOV     CX,ES:[BP.dpb_sector_size]
        PUSH    ES
        LES     DI,[CURBUF]
        OR      ES:[DI.buf_flags],buf_isDIR
        PUSH    DI
        ADD     DI,BUFINSIZ
        XOR     AX,AX
        SHR     CX,1
        REP     STOSW
        JNC     EVENZ
        STOSB
EVENZ:
        POP     DI

	TESTB	 ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		 ;AN000;
        JNZ     yesdirty                  ;LB.    don't increment dirty count   ;AN000;
        invoke  INC_DIRTY_COUNT           ;LB.                                  ;AN000;
        OR      ES:[DI.buf_flags],buf_dirty
yesdirty:
        POP     ES
        POP     CX

;        INC     DX
	add	dx, 1
	adc	[HIGH_SECTOR], 0

        LOOP    ZERODIR
        MOV     AX,[LASTENT]
        INC     AX
        CLC
        return

EndProc BUILDDIR

;--------------------------------------------------------------------------
;
; Procedure Name : SETDOTENT
;
; set up a . or .. directory entry for a directory.
;
;   Inputs:     ES:DI point to the beginning of a directory entry.
;               AX contains ". " or ".."
;               DX contains first cluster of entry
;
;----------------------------------------------------------------------------

procedure SETDOTENT,NEAR
	DOSAssume   <DS>,"SetDotEnt"

;	Fill in name field

        STOSW
        MOV     CX,4
        MOV     AX,"  "
        REP     STOSW
        STOSB

;	Set up attribute

        MOV     AL,attr_directory
	.errnz	dir_attr-(dir_name+11)
        STOSB

;	Initialize time and date of creation

        ADD     DI,10
        MOV     SI,WORD PTR [THISSFT]
        MOV     AX,[SI.sf_time]
	.errnz	dir_time-(dir_attr+1+10)
        STOSW
        MOV     AX,[SI.sf_date]
	.errnz	dir_date-(dir_time+2)
        STOSW

;	Set up first cluster field

        MOV     AX,DX
	.errnz	dir_first-(dir_date+2)
        STOSW

;	0 file size

        XOR     AX,AX
	.errnz	dir_size_l-(dir_first+2)
        STOSW
        STOSW
	.errnz	(size dir_entry)-(dir_size_l+4)
        return

EndProc SETDOTENT

Break   <MAKENODE -- CREATE A NEW NODE>
;---------------------------------------------------------------------------
;
; Procedure Name : MakeNode
;
; Inputs:
;       AL - attribute to create
;       AH = 0 if it is ok to truncate a file already by this name
;	AH != 0 if truncation not allowed (prexisting file is an error)
;               (AH ignored on dirs and devices)
;
;        NOTE: When making a DIR or volume ID, AH need not be set since
;               a name already existant is ALWAYS an error in these cases.
;
;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;               terminated)
;       [CURR_DIR_END] Points to end of Current dir part of string
;               ( = -1 if current dir not involved, else
;                Points to first char after last "/" of current dir part)
;       [THISCDS] Points to CDS being used
;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
; Function:
;       Make a new node
; Outputs:
;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
;       CARRY SET IF ERROR
;          AX = 1 A node by this name exists and is a directory
;          AX = 2 A new node could not be created
;          AX = 3 A node by this name exists and is a disk file
;               (AH was NZ on input)
;          AX = 4 Bad Path
;               SI return from GetPath maintained
;          AX = 5 Attribute mismatch
;          AX = 6 Sharing Violation
;               (INT 24 generated ALWAYS since create is always compat mode
;          AX = 7 file not found for Extended Open (not exists and fails)
;       ELSE
;          AX = 0       Disk Node
;          AX = 3       Device Node (error in some cases)
;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
;               containing new node.
;          [CURBUF+2]:BX Points to entry
;          [CURBUF+2]:SI Points to entry.dir_first
;          [THISSFT] is filled in
;               sf_mode = unchanged.
;          Attribute byte in entry is input AL
; DS preserved, others destroyed
;
;-------------------------------------------------------------------------

procedure MakeNode,NEAR
	DOSAssume   <DS>,"MakeNode"

	MOV	WORD PTR CREATING, DIRFREE*256 + 0ffh	; Creating, not DEL *.*
        PUSH    AX              ; Save AH value
	MOV	NoSetDir,0
	MOV	SATTRIB,AL
        invoke  GetPathNoSet
        MOV     DL,CL           ; Save CL info
        MOV     CX,AX           ; Device ID to CH
        POP     AX              ; Get back AH
        JNC     make_exists     ; File existed
        JNZ     make_err_4      ; Path bad
        CMP     DL,80H          ; Check "CL" return from GETPATH
        JZ      make_type       ; Name simply not found, and no metas
make_err_4:
        MOV     AL,4            ; case 1 bad path
make_err_ret:
        XOR     AH,AH
        STC
        return

        entry   RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node

make_type:
;Extended Open hooks
	TESTB	EXTOPEN_ON,ext_open_on	;FT. from extended open		 ;AN000;
	JZ	make_type2		;FT. no				 ;AN000;
	OR	EXTOPEN_ON,ext_file_not_exists ;FT. set for extended open	 ;AN000;
	TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails		 ;AN000;
	JNZ    make_type2		;FT. no 			       ;AN000;
	STC				;FT. set carry			       ;AN000;
	MOV    AX,7			;FT. file not found		       ;AN000;
	return				;FT.				       ;AN000;

;	Extended Open hooks

make_type2:
        LES     DI,[THISSFT]
;       MOV     ES:[DI.sf_mode],sharing_compat + open_for_both
        XOR     AX,AX           ; nothing exists Disk Node
        STC                     ; Not found
        JMP     short make_new

;
; The node exists.  It may be either a device, directory or file:
;   Zero set => directory
;   High bit of CH on => device
;   else => file
make_exists:
        JZ      make_exists_dir
        MOV     AL,3            ; file exists type 3  (error or device node)
	TESTB	Attrib,<attr_volume_id+attr_directory>
        JNZ     make_err_ret_5  ; Cannot already exist as Disk or Device Node
                                ;       if making DIR or Volume ID
        OR      CH,CH
        JS      make_share      ; No further checks on attributes if device
        OR      AH,AH
        JNZ     make_err_ret    ; truncating NOT OK (AL = 3)
        PUSH    CX              ; Save device ID
        MOV     ES,WORD PTR [CURBUF+2]
        MOV     CH,ES:[BX+dir_attr] ; Get file attributes
	test	 CH,attr_read_only
        JNZ     make_err_ret_5P ; Cannot create on read only files
        invoke  MatchAttributes
        POP     CX              ; Devid back in CH
        JNZ     make_err_ret_5  ; Attributes not ok
        XOR     AL,AL           ; AL = 0, Disk Node
make_share:
        XOR     AH,AH
        PUSH    AX              ; Save Disk or Device node
        PUSH    CX              ; Save Device ID
        MOV     AH,CH           ; Device ID to AH
        CALL    DOOPEN          ; Fill in SFT for share check
        LES     DI,[THISSFT]
;       MOV     ES:[DI.sf_mode],sharing_compat + open_for_both
	SAVE	<SI,BX> 	; Save CURBUF pointers
        invoke  ShareEnter
        jnc     MakeEndShare
;
; User failed request.
;
	RESTORE <BX,SI,CX,AX>
Make_Share_ret:
        MOV     AL,6
        JMP     make_err_ret

make_err_ret_5P:
        POP     CX              ; Get back device ID
make_err_ret_5:
        MOV     AL,5            ; Attribute mismatch
        JMP     make_err_ret

make_exists_dir:
        MOV     AL,1            ; exists as directory, always an error
        JMP     make_err_ret

make_save:
        PUSH    AX              ; Save whether Disk or File
        MOV     AX,CX           ; Device ID to AH
        CALL    NewEntry
        POP     AX              ; 0 if Disk, 3 if File
        retnc
        MOV     AL,2            ; create failed case 2
        return

make_new:
        call    make_save
        retc                    ; case 2 fail
	test	 BYTE PTR Attrib,attr_directory
        retnz                   ; Don't "open" directories, so don't
                                ;   tell the sharer about them
	SAVE	<AX,BX,SI>	; Save AL code
        invoke  ShareEnter
	RESTORE <SI,BX,AX>
        retnc
;
; We get here by having the user FAIL a share problem.  Typically a failure of
; this nature is an out-of-space or an internal error.  We clean up as best as
; possible:  delete the newly created directory entry and return share_error.
;
        PUSH    AX
        LES     DI,CurBuf
	MOV	BYTE PTR ES:[BX],DIRFREE	; nuke newly created entry.

	TESTB	ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		 ;AN000;
        JNZ     yesdirty2                 ;LB.    don't increment dirty count   ;AN000;
        invoke  INC_DIRTY_COUNT           ;LB.                                  ;AN000;
        OR      ES:[DI].buf_flags,buf_dirty ; flag buffer as dirty
yesdirty2:
        LES     BP,ThisDPB
        MOV     AL,ES:[BP].DPB_Drive    ; get drive for flush
        Invoke  FlushBuf                ; write out buffer.
        POP     AX
        jmp     make_Share_ret
;
; We have found an existing file.  We have also entered it into the share set.
; At this point we need to call newentry to correctly address the problem of
; getting rid of old data (create an existing file) or creating a new
; directory entry (create a new file).  Unfortunately, this operation may
; result in an INT 24 that the user doesn't return from, thus locking the file
; irretrievably into the share set.  The correct solution is for us to LEAVE
; the share set now, do the operation and then reassert the share access.
;
; We are allowed to do this!  There is no window!  After all, we are in
; critDisk here and for someone else to get in, they must enter critDisk also.
;
MakeEndShare:
        LES     DI,ThisSFT              ; grab SFT
        XOR     AX,AX
        EnterCrit   critSFT
        XCHG    AX,ES:[DI].sf_ref_count
	SAVE	<AX,DI,ES>
        PUSHF
        invoke  ShareEnd                ; remove sharing
        POPF
	RESTORE <ES,DI,ES:[DI].sf_ref_count>
        LeaveCrit   critSFT
	RESTORE <BX,SI,CX,AX>
        CALL    make_save
;
; If the user failed, we do not reenter into the sharing set.
;
        retc                            ; bye if error
	SAVE	<AX,BX,SI>
        PUSHF
        invoke  ShareEnter
        POPF
	RESTORE <SI,BX,AX>
;
; If Share_check fails, then we have an internal ERROR!!!!!
;
        return
EndProc MakeNode,NoCheck

;---------------------------------------------------------------------------
;
; Procedure Name : NEWENTRY
;
; Inputs:
;       [THISSFT] set
;       [THISDPB] set
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [VOLID] set if a volume ID was found during search
;	Attrib Contains attributes for new file
;       [DIRSTART] Points to first cluster of dir (0 means root)
;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
;               NC means file existed (device)
;               C  means file did not exist
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Make a new directory entry
;       If an old one existed it is truncated first
; Outputs:
;       Carry set if error
;               Can't grow dir, atts didn't match, attempt to make 2nd
;               vol ID, user FAILed to I 24
;       else
;               outputs of DOOPEN
; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
;
;----------------------------------------------------------------------------

procedure NEWENTRY,NEAR
	DOSAssume   <DS>,"NewEntry"

        LES     BP,[THISDPB]
ASSUME  ES:NOTHING
        JNC     EXISTENT
        CMP     [FAILERR],0
        STC
        retnz                   ; User FAILed, node might exist
        CALL    BUILDDIR        ; Try to build dir
        retc                    ; Failed
        invoke  GETENT          ; Point at that free entry
        retc                    ; Failed
        JMP     SHORT FREESPOT

ERRRET3:
        STC
        return

EXISTENT:
	DOSAssume   <DS>,"ExistEnt"
        OR      AH,AH           ; Check if file is I/O device
        JNS     NOT_DEV1
        JMP     DOOPEN          ; If so, proceed with open

NOT_DEV1:
        invoke  FREEENT         ; Free cluster chain
        retc                    ; Failed
FREESPOT:
	test	 BYTE PTR Attrib,attr_volume_id
        JZ      NOTVOLID
        CMP     BYTE PTR [VOLID],0
        JNZ     ERRRET3         ; Can't create a second volume ID
NOTVOLID:
        MOV     ES,WORD PTR [CURBUF+2]
        MOV     DI,BX

;hkn; NAME1 is in DOADATA
        MOV     SI,OFFSET DOSDATA:NAME1

        MOV     CX,5
        REP     MOVSW
        MOVSB                   ; Move name into dir entry
	MOV	AL,Attrib
	.errnz	dir_attr-(dir_name+11)
        STOSB                   ; Attributes

;; File Tagging for Create DOS 4.00
        MOV     CL,5            ;FT. assume normal FBUGBUG                    ;AN000;
;; File Tagging for Create DOS 4.00

        XOR     AX,AX
        REP     STOSW           ; Zero pad
        invoke  DATE16
        XCHG    AX,DX
	.errnz	dir_time-(dir_attr+1+2*5)
        STOSW                   ; dir_time
        XCHG    AX,DX
	.errnz	dir_date-(dir_time+2)
        STOSW                   ; dir_date
        XOR     AX,AX
        PUSH    DI              ; Correct SI input value (recomputed for new buffer)

	.errnz	dir_first-(dir_date+2)
        STOSW                   ; Zero dir_first and size
	.errnz	dir_size_l-(dir_first+2)
        STOSW
        STOSW
updnxt:
	.errnz	(size dir_entry)-(dir_size_l+4)
        MOV     SI,WORD PTR [CURBUF]

	TESTB	ES:[SI.buf_flags],buf_dirty  ;LB. if already dirty		 ;AN000;
        JNZ     yesdirty3                 ;LB.    don't increment dirty count   ;AN000;
        invoke  INC_DIRTY_COUNT           ;LB.                                  ;AN000;
        OR      ES:[SI.buf_flags],buf_dirty
yesdirty3:
        LES     BP,[THISDPB]
        MOV     AL,ES:[BP.dpb_drive]    ; Sets AH value again (in AL)
        PUSH    AX
        PUSH    BX
; If we have a file, we need to increment the open ref. count so that
; we have some protection against invalid media changes if an Int 24
; error occurs.
; Do nothing for a device.
	SAVE	<ES,DI>
        LES     DI,[THISSFT]
	TESTB	es:[di].SF_FLAGS,devid_device
        jnz     GotADevice
	SAVE	<DS,BX>
        LDS     BX,[THISDPB]
        MOV     word ptr ES:[DI.sf_devptr],BX
        MOV     BX,DS
        MOV     word ptr ES:[DI.sf_devptr+2],BX
	RESTORE <BX,DS>	    ; need to use DS for segment later on
        invoke  Dev_Open_SFT    ; increment ref. count
        mov     [VIRTUAL_OPEN],1; set flag
GotADevice:
	RESTORE <DI,ES>

        invoke  FLUSHBUF
        Call    CHECK_VIRT_OPEN ; decrement ref. count                          ;AN000;
        POP     BX
        POP     AX
        POP     SI              ; Get SI input back
        MOV     AH,AL           ; Get I/O driver number back
        retc                    ; Failed


;NOTE FALL THROUGH

; Inputs:
;       [THISDPB] points to DPB if file
;       [THISSFT] points to SFT being used
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Fill in SFT from dir entry
; Outputs:
;       CARRY CLEAR
;       sf_ref_count and sf_mode fields not altered
;       sf_flags high byte = 0
;       sf_flags low byte = AH except
;       sf_flags Bit 6 set (not dirty or not EOF)
;       sf_attr sf_date sf_time sf_name set from entry
;       sf_position = 0
;       If device
;           sf_devptr = dword at dir_first (pointer to device header)
;           sf_size = 0
;       If file
;           sf_firclus sf_size set from entry
;           sf_devptr = [THISDPB]
;           sf_cluspos = 0
;           sf_lstclus = sf_firclus
;           sf_dirsec sf_dirpos set
; DS,SI,BX preserved, others destroyed

entry	 DOOPEN
        ASSUME  ES:NOTHING
	DOSAssume   <DS>,"DoOpen"


;	Generate and store attribute

        MOV     DH,AH           ; AH to different place
        LES     DI,[THISSFT]
        ADD     DI,sf_attr      ; Skip ref_count and mode fields
        XOR     AL,AL           ; Assume it's a device, devices have an
                                ;   attribute of 0 (for R/O testing etc).
        OR      DH,DH           ; See if our assumption good.
        JS      DEV_SFT1        ; If device DS=DOSGROUP
        MOV     DS,WORD PTR [CURBUF+2]
ASSUME  DS:NOTHING
        MOV     AL,[BX.dir_attr] ; If file, get attrib from dir entry
DEV_SFT1:
        STOSB                   ; sf_attr, ES:DI -> sf_flags

;	Generate and store flags word

        XOR     AX,AX
        MOV     AL,DH
        OR      AL,devid_file_clean
        STOSW                   ; sf_flags, ES:DI -> sf_devptr

;	Generate and store device pointer

        PUSH    DS
        LDS     AX,DWORD PTR [BX.dir_first]       ; Assume device
        OR      DH,DH
        JS      DEV_SFT2

;hkn; SS override
        LDS     AX,[THISDPB]            ; Was file
DEV_SFT2:
        STOSW                           ; store offset
        MOV     AX,DS
        POP     DS
        STOSW                           ; store segment
                                        ; ES:DI -> sf_firclus

;	Generate pointer to, generate and store first cluster (irrelevant  for
;	devices)

        PUSH    SI              ; Save pointer to dir_first
        MOVSW                   ; dir_first -> sf_firclus
                                ; DS:SI -> dir_size_l, ES:DI -> sf_time

;	Copy time/date of last modification

        SUB     SI,dir_size_l - dir_time        ; DS:SI->dir_time
        MOVSW                   ; dir_time -> sf_time
                                ; DS:SI -> dir_date, ES:DI -> sf_date
        MOVSW                   ; dir_date -> sf_date
                                ; DS:SI -> dir_first, ES:DI -> sf_size

;	Generate and store file size (0 for devices)

        LODSW                   ; skip dir_first, DS:SI -> dir_size_l
        LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
        MOV     CX,AX           ; dir_size_l in CX
        LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
        OR      DH,DH
        JNS     FILE_SFT1
        XOR     AX,AX
        MOV     CX,AX           ; Devices are open ended
FILE_SFT1:
        XCHG    AX,CX
        STOSW                   ; Low word of sf_size
        XCHG    AX,CX
        STOSW                   ; High word of sf_size
                                ; ES:DI -> sf_position
;
; Initialize position to 0
;
        XOR     AX,AX
        STOSW
        STOSW                   ; sf_position
                                ; ES:DI -> sf_cluspos
;
; Generate cluster optimizations for files
;
        OR      DH,DH
        JS      DEV_SFT3
        STOSW                   ; sf_cluspos
        MOV     AX,[BX.dir_first]
;;;;    STOSW                   ; sf_lstclus
        PUSH    DI              ;AN004; save dirsec offset
        SUB     DI,sf_dirsec    ;AN004; es:di -> SFT
        MOV     ES:[DI.sf_lstclus],AX  ;AN004; save it
        POP     DI              ;AN004; restore dirsec offset



; DOS 3.3  FastOpen  6/13/86

        PUSH   DS

;hkn; SS is DOSDATA
        context DS
	TESTB	FastOpenFlg,Special_Fill_Set
	JZ	Not_FastOpen

;hkn; FastOpen_Ext_Info is in DOSDATA
        MOV     SI,OFFSET DOSDATA:FastOpen_Ext_Info

        MOV     AX,WORD PTR [SI.FEI_dirsec]
        STOSW                   ; sf_dirsec
        MOV     AX,WORD PTR [SI.FEI_dirsec+2]  ;;; changed for >32mb
        STOSW                   ; sf_dirsec
        MOV     AL,[SI.FEI_dirpos]
        STOSB                   ; sf_dirpos
        POP     DS
        JMP     short Next_Name

; DOS 3.3  FastOpen  6/13/86

Not_FastOpen:
        POP     DS                      ; normal path
ASSUME  DS:NOTHING

;hkn; SS override
        MOV     SI,WORD PTR [CURBUF]    ; DS:SI->buffer header

        MOV     AX,WORD PTR [SI.buf_sector]     ;F.C. >32mb                        ;AN000;
        STOSW                   ; sf_dirsec     ;F.C. >32mb                        ;AN000;
        MOV     AX,WORD PTR [SI.buf_sector+2]   ;F.C. >32mb                        ;AN000;
        STOSW                   ; sf_dirsec     ;F.C. >32mb                        ;AN000;
        MOV     AX,BX
        ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
        SUB     AX,SI           ; AX = BX relative to start of sector
        MOV     CL,SIZE dir_entry
        DIV     CL
        STOSB                   ; sf_dirpos

Next_Name:
	.errnz	sf_name-(sf_dirpos+1)
        JMP     SHORT FILE_SFT2

DEV_SFT3:
        ADD     DI,sf_name - sf_cluspos
FILE_SFT2:
;
; Copy in the object's name
;
        MOV     SI,BX           ; DS:SI points to dir_name
        MOV     CX,11
        REP     MOVSB           ; sf_name
        POP     SI              ; recover DS:SI -> dir_first

;hkn; SS is DOSDATA
        context DS
        CLC
        return

EndProc NEWENTRY

;---------------------------------------------------------------------------
;
; Procedure Name : FREEENT
;
; Inputs:
;       ES:BP -> DPB
;       [CURBUF] Set
;       [CURBUF+2]:BX points to directory entry
;       [CURBUF+2]:SI points to above dir_first
; Function:
;       Free the cluster chain for the entry if present
; Outputs:
;       Carry set if error (currently user FAILed to I 24)
;       (NOTE dir_firclus and dir_size_l/h are wrong)
; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
;---------------------------------------------------------------------------

procedure FREEENT,NEAR
	DOSAssume   <DS>,"FreeEnt"

        PUSH    DS
        LDS     DI,[CURBUF]
ASSUME  DS:NOTHING
        MOV     CX,[SI]         ; Get pointer to clusters
        MOV     DX,WORD PTR [DI.buf_sector+2]  ;F.C. >32mb                      ;AN000;

;hkn; SS override
        MOV     [HIGH_SECTOR],DX               ;F.C. >32mb                      ;AN000;
        MOV     DX,WORD PTR [DI.buf_sector]
        POP     DS
	DOSAssume   <DS>,"FreeEnt2"
        CMP     CX,2
        JB      RET1            ; Was 0 length file (or mucked Firclus if CX=1)
        CMP     CX,ES:[BP.dpb_max_cluster]
        JA      RET1            ; Treat like zero length file (firclus mucked)
        SUB     BX,DI
        PUSH    BX              ; Save offset
        PUSH    [HIGH_SECTOR]                  ;F.C. >32mb                      ;AN000;
        PUSH    DX              ; Save sector number

        MOV     BX,CX
        invoke  RELEASE         ; Free any data allocated
        POP     DX
        POP     [HIGH_SECTOR]                  ;F.C. >32mb                      ;AN000;
        JNC     GET_BUF_BACK
        POP     BX
        return                  ; Screw up

GET_BUF_BACK:

        MOV     [ALLOWED],allowed_RETRY + allowed_FAIL
        XOR     AL,AL
        invoke  GETBUFFR        ; Get sector back
        POP     BX              ; Get offset back
        retc
        invoke  SET_BUF_AS_DIR
        ADD     BX,WORD PTR [CURBUF]    ; Correct it for new buffer
        MOV     SI,BX
        ADD     SI,dir_first    ; Get corrected SI
RET1:
        CLC
        return
EndProc FREEENT

;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_VIRT_OPEN
;
; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
; flag [VIRTUAL_OPEN].
; No registers affected (including flags).
; On input, [THISSFT] points to current SFT.
;
;---------------------------------------------------------------------------

Procedure CHECK_VIRT_OPEN,NEAR
	DOSAssume   <DS>,"Check_Virt_Open"

        PUSH    AX
        lahf                    ; preserve flags
        CMP     [VIRTUAL_OPEN],0
        JZ      ALL_CLOSED
        mov     [VIRTUAL_OPEN],0        ; reset flag
	SAVE	<ES,DI>
        LES     DI,[THISSFT]
        INVOKE  DEV_CLOSE_SFT
	RESTORE <DI,ES>

ALL_CLOSED:
        sahf                    ; restore flags
        POP     AX
        return

EndProc CHECK_VIRT_OPEN


DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\misc2.asm ===
TITLE MISC2 - Miscellanious routines for MS-DOS
	NAME  MISC2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	MISC2.ASM - Miscellaneous useful routines
;
;	StrCpy
;	StrCmp
;	StrLen
;	DStrLen
;	Idle
;	TableDispatch
;	FastInit			  ; DOS 4.0
;	FastRet			  ; DOS 4.0
;	NLS_OPEN			  ; DOS 4.0
;	NLS_LSEEK			  ; DOS 4.0
;	Fake_User_Stack		  ; DOS 4.0
;	GetDevList			  ; DOS 4.0
;	NLS_IOCTL			  ; DOS 4.0
;	NLS_GETEXT			  ; DOS 4.0
;	MSG_RETRIEVAL		  ; DOS 4.0
;	Fake_Version		  ; DOS 4.0
;
;	Revision history:
;
;	   Created: ARR 30 March 1983
;
;	   A000   version 4.0	Jan. 1988
;	   A001   DCR 486 - Share installation for >32mb drives
;	   A006   DCR 503 - fake version number for IBMCACHE
;	   DOS 5.00 Moved fake version to caller's PSP
	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include sysvar.inc
	include sf.inc
	include curdir.inc
	include fastxxxx.inc
	include bugtyp.inc
	.cref
	.list

	i_need	THISCDS,DWORD
	I_Need	RetryLoop,WORD
	I_need	fSharing,BYTE		; TRUE => server-issued call
	I_need	FastTable,BYTE		;AN000;
	I_need	FastFlg,BYTE		;AN000;
	I_need	User_SP_2F,WORD 	;AN000;
	I_need	User_SP,WORD		;AN000;
	I_need	User_SS,WORD		;AN000;
	I_need	SysInitTable,BYTE	;AN000;
	I_need	EXTERR,WORD		;AN000;
	I_need	MSG_EXTERROR,DWORD	;AN000;
	I_need	fshare,byte		;AN001;
	I_need	Special_version,WORD	;AN006;

DOSCODE	SEGMENT

	allow_getdseg

	ASSUME	SS:DOSDATA,CS:DOSCODE



Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
;		Strings of different lengths don't match.
;   Inputs:	DS:SI - pointer to source string  ES:DI - pointer to dest string
;   Outputs:	Z if strings same, NZ if different
;   Registers modified: NONE
;----------------------------------------------------------------------------

Procedure   StrCmp,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<SI,DI,AX>
Cmplp:
	LODSB
 IFDEF  DBCS				;AN000;
	invoke	testkanj		;AN000;; 2/13/KK
	jz	notkanj1		;AN000;; 2/13/KK
	dec	si			;AN000;; Do source again 2/13/KK
	cmpsb				;AN000;; First byte	 2/13/KK
	JNZ	PopRet			;AN000;; Strings dif	 2/13/KK
	cmpsb				;AN000;; Second byte of kanji char 2/13/KK
	JNZ	PopRet			;AN000;; Strings dif	 2/13/KK
	mov	al,byte ptr [SI-1]	;AN000;; Need last byte in AL  2/13/KK
	jmp	short Tend		;AN000;
notkanj1:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	MOV	AH,AL
	MOV	AL,ES:[DI]
	INC	DI
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	CMP	AH,AL
	JNZ	PopRet			; Strings dif
Tend:
	OR	AL,AL
	JNZ	Cmplp			; More string
PopRet:
	RESTORE <AX,DI,SI>
	return
EndProc StrCmp

Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI.  no modification of
;	characters.
;
;   Inputs:	DS:SI - pointer to source string
;		ES:DI - pointer to destination string
;   Outputs:	ES:DI point byte after nul byte at end of dest string
;		DS:SI point byte after nul byte at end of source string
;   Registers modified: SI,DI
;----------------------------------------------------------------------------

Procedure   StrCpy,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX>
CPYLoop:
	LODSB
 IFDEF  DBCS			;AN000;
	invoke	testkanj	;AN000;; 2/13/KK
	jz	notkanj2	;AN000;; 2/13/KK
	STOSB			;AN000;; 2/13/KK
	LODSB			;AN000;; 2/13/KK
	STOSB			;AN000;; 2/13/KK
	jmp	short CPYLoop	;AN000;; 3/31/KK

notkanj2:			;AN000;; 2/13/KK
 ENDIF				;AN000;
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	STOSB
Tend2:
	OR	AL,AL
	JNZ	CPYLoop
	RESTORE <AX>
	return
EndProc StrCpy

;----------------------------------------------------------------------------
; Procedure Name : FStrCpy
;----------------------------------------------------------------------------

Procedure   FStrCpy,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX>
FCPYLoop:
	LODSB
	STOSB
	OR	AL,AL
	JNZ	FCPYLoop
	RESTORE <AX>
	return
EndProc FStrCpy

	Break <StrLen - compute length of string ES:DI>

;**	StrLen - Compute Length of String
;
;	StrLen computes the length of a string, including the trailing 00
;
;	ENTRY	(es:di) = address of string
;	EXIT	(cx) = size of string
;	USES	cx, flags

Procedure   StrLen,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	SAVE	<di, ax>
	MOV	CX,-1
	XOR	AL,AL
	REPNE	SCASB
	NOT	CX
	RESTORE <ax, di>
	return

EndProc StrLen


;**	DStrLen - Compute Length of String
;
;	ENTRY	(ds:si) = address of string
;	EXIT	(cx) = size of string, including trailing NUL
;	USES	cx, flags

Procedure   DStrLen,NEAR	; BUGBUG - this guy is a pig, who uses him?
	CALL	XCHGP
	CALL	StrLen
	CALL	XCHGP
	return
EndProc DStrLen


	Break	<XCHGP - exchange source and destination pointers>

;**	XCHGP - Exchange Pointers
;
;	XCHGP exchanges (DS:SI) and (ES:DI)
;
;	ENTRY	none
;	EXIT	pairs exchanged
;	USES	SI, DI, DS, ES

Procedure XCHGP,NEAR

	SAVE	<DS,ES>
	RESTORE	<DS,ES>
	XCHG	SI,DI
	return

EndProc XCHGP


Break	<Idle - wait for a specified amount of time>
;----------------------------------------------------------------------------
;
;   Idle - when retrying an operation due to a lock/sharing violation, we spin
;   until RetryLoop is exhausted.
;
;   Inputs:	RetryLoop is the number of times we spin
;   Outputs:	Wait
;   Registers modified: none
;----------------------------------------------------------------------------
Procedure   Idle,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	cmp	fSharing,0
	retnz
	SAVE	<CX>

;hkn; SS override
	MOV	CX,RetryLoop
	JCXZ	Idle3
Idle1:	PUSH	CX
	XOR	CX,CX
Idle2:	LOOP	Idle2
	POP	CX
	LOOP	Idle1
Idle3:	RESTORE <CX>
	return
EndProc Idle

Break	<TableDispatch - dispatch to a table>
;----------------------------------------------------------------------------
;
;   TableDispatch - given a table and an index, jmp to the approptiate
;   routine.  Preserve all input registers to the routine.
;
;   Inputs:	Push	return address
;		Push	Table address
;		Push	index (byte)
;   Outputs:	appropriate routine gets jumped to.
;		return indicates invalid index
;   Registers modified: none.
;----------------------------------------------------------------------------
TableFrame  STRUC
OldBP	DW  ?
OldRet	DW  ?
Index	DB  ?
Pad	DB  ?
Tab	DW  ?
NewRet	DW  ?
TableFrame  ENDS

procedure   TableDispatch,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	PUSH	BP
	MOV	BP,SP
	PUSH	BX			; save BX
	MOV	BX,[BP.Tab]		; get pointer to table
	MOV	BL,CS:[BX]		; maximum index
	CMP	[BP.Index],BL		; table error?
	JAE	TableError		; yes
	MOV	BL,[BP.Index]		; get desired table index
	XOR	BH,BH			; convert to word
	SHL	BX,1			; convert to word pointer
	INC	BX			; point past first length byte
	ADD	BX,[BP.Tab]		; get real offset
	MOV	BX,CS:[BX]		; get contents of table entry
	MOV	[BP.Tab],BX		; put table entry into return address
	POP	BX			; restore BX
	POP	BP			; restore BP
	ADD	SP,4			; clean off Index and our return addr
	return				; do operation
TableError:
	POP	BX			; restore BX
	POP	BP			; restore BP
	RET	6			; clean off Index, Table and RetAddr
EndProc TableDispatch

Break	<TestNet - determine if a CDS is for the network>
;----------------------------------------------------------------------------
;
;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
;	network CDS.  This will handle NULL cds also.
;
;   Inputs:	ThisCDS points to CDS or NULL
;   Outputs:	ES:DI = ThisCDS
;		carry Set => network
;		carry Clear => local
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   TestNet,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	getdseg	<es>			; es -> dosdata
	LES	DI,ThisCDS
	assume	es:NOTHING

	CMP	DI,-1
	JZ	CMCRet			; UNC? carry is clear
	TESTB	ES:[DI].curdir_flags,curdir_isnet
	JNZ	CMCret			; jump has carry clear
	return				; carry is clear
CMCRet: CMC
	return

EndProc TestNet

Break	<IsSFTNet - see if an sft is for the network>
;----------------------------------------------------------------------------
;
;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
;	network file.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	Zero set if not network sft
;		zero reset otherwise
;		Carry CLEAR!!!
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   IsSFTNet,NEAR

	ASSUME	CS:DOSCODE,SS:NOTHING
	TESTB	ES:[DI].sf_flags,sf_isnet
	return

EndProc IsSFTNet

Break	<FastInit - Initialize FastTable entries >
;----------------------------------------------------------------------------
;   DOS 4.00   2/9/87
;   FastInit  - initialize the FASTXXX routine entry
;		  in the FastTable
;
;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
;		DS:SI = address of FASTXXX routine entry
;		   SI = -1 for query only
;   Outputs:	Carry flag clear, if success
;		Carry flag set,   if failure
;
;
;----------------------------------------------------------------------------

Procedure   FastInit,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

;hkn; set up es to dosdataseg.

	push	es
	getdseg	<es>			; es -> dosdata

;hkn; FastTable is in DOSDATA
	MOV	DI,OFFSET DOSDATA:FastTable + 2 ;AN000;FO. points to fastxxx entry
	DEC	BX				;AN000;FO.;; decrement index
	MOV	DX,BX				;AN000;FO.;; save bx
	SHL	BX,1				;AN000;FO.;; times 4 , each entry is DWORD
	SHL	BX,1				;AN000;FO.
	ADD	DI,BX				;AN000;FO. index to the entry
	MOV	AX,WORD PTR ES:[DI+2]		;AN000;FO. get entry segment
fcheck: 					;AN000;
	MOV	CX,CS				;AN000;FO.;; get DOS segment
	CMP	AX,CX				;AN000;FO.;; first time installed ?
	JZ	ok_install			;AN000;FO.;; yes
	OR	AX,AX				;AN000;FO.;
	JZ	ok_install			;AN000;FO.;
	STC					;AN000;FO.;; already installed !
	JMP	SHORT FSret			;AN000;FO. set carry
ok_install:					;AN000;
	CMP	SI,-1				;AN000;FO.; Query only ?
	JZ	FSret				;AN000;FO.; yes
	MOV	CX,DS				;AN000;FO.; get FASTXXX entry segment
	MOV	WORD PTR ES:[DI+2],CX		;AN000;FO.; initialize routine entry
	MOV	WORD PTR ES:[DI],SI		;AN000;FO.; initialize routine offset

;hkn; FastFlg moved to DOSDATA
	MOV	DI,OFFSET DOSDATA:FastFlg	;AN000;FO.; get addr of FASTXXX flags
	ADD	DI,DX				;AN000;FO.; index to a FASTXXX flag
	OR	byte ptr ES:[DI],Fast_yes	;AN000;FO.; indicate installed

FSret:						;AN000;
	pop	es
	return					;AN000;FO.
EndProc FastInit				;AN000;FO.

	Break	<FastRet - initial routine in FastOpenTable >

;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   FastRet	- indicate FASTXXXX  not in memory
;
;   Inputs:	None
;   Outputs:	AX = -1 and carry flag set
;
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   FastRet,FAR
	STC
	sbb	ax,ax		; (ax) = -1, 'C' set
	RET
EndProc FastRet

Break	<NLS_OPEN - do $open for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_OPEN	- call $OPEN for NLSFUNC
;
;   Inputs:	Same input as $OPEN except CL = mode
;   Outputs:	same output as $OPEN
;
;----------------------------------------------------------------------------

;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!

Procedure   NLS_OPEN,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
;	MOV	[CPSWFLAG],0
;	PUSH	BX		 ; save current state

	MOV	AL,CL		 ; set up correct interface for $OPEN
	invoke	$OPEN

 ;	POP	BX		 ; restore current state
 ;	MOV	[CPSWFLAG],BL
	RET
EndProc NLS_OPEN

Break	<NLS_LSEEK - do $LSEEK for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_LSEEK	- call $LSEEK for NLSFUNC
;
;   Inputs:	BP = open mode
;   Outputs:	same output as $LSEEK
;
;----------------------------------------------------------------------------

Procedure   NLS_LSEEK,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	PUSH	ss:[user_SP]	 ; save user stack
	PUSH	ss:[user_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP	     ; set up correct interface for $LSEEK
	invoke	$LSEEK
	POP	ss:[user_SS]	 ; restore user stack
	POP	ss:[user_SP]
	RET
EndProc NLS_LSEEK


Break	<Fake_User_Stack - save user stack >

;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   Fake_User_Stack - save user stack pointer
;
;----------------------------------------------------------------------------

Procedure   Fake_User_Stack,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	MOV	AX,ss:[User_SP_2F] 	      ; replace with INT 2F stack
	MOV	ss:[user_SP],AX

;hkn;	MOV	AX,CS

	mov	ax, ss
	MOV	ss:[user_SS],AX		      ; DOSGROUP

	RET
EndProc Fake_User_Stack

;
Break	<GetDevList - get device header list pointer>

;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   GetDevList - get device header list pointer
;
;   Output: AX:BX points to the device header list
;----------------------------------------------------------------------------

Procedure   GetDevList,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	SI,OFFSET DOSDATA:SysInitTable

;hkn; set up ds to point to DOSDATA
	getdseg	<ds>			; ds -> dosdata

	LDS	SI,[SI.SYSI_InitVars]

	MOV	AX,WORD PTR DS:[SI.SYSI_DEV]
	MOV	BX,WORD PTR DS:[SI.SYSI_DEV+2]

	RET
EndProc GetDevList

Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_IOCTL	- call $IOCTL for NLSFUNC
;
;   Inputs:	BP = function code 0CH
;   Outputs:	same output as generic $IOCTL
;
;----------------------------------------------------------------------------

Procedure   NLS_IOCTL,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	PUSH	ss:[user_SP]	 ; save user stack
	PUSH	ss:[user_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP	     ; set up correct interface for $LSEEK
	invoke	$IOCTL
	POP	ss:[user_SS]	 ; restore user stack
	POP	ss:[user_SP]
	RET
EndProc NLS_IOCTL

Break	<NLS_GETEXT- get extended error for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_GETEXT	-
;
;   Inputs:	none
;   Outputs:	AX = extended error
;
;----------------------------------------------------------------------------

Procedure   NLS_GETEXT,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	MOV	AX,SS:[EXTERR]	 ; return extended error
	RET

EndProc NLS_GETEXT

Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
;----------------------------------------------------------------------------
;   DOS 4.00
;
;   Inputs:	DL=0 get extended error message addr
;		  =1 set extended error message addr
;		  =2 get parser error message addr
;		  =3 set parser error message addr
;		  =4 get critical error message addr
;		  =5 set critical error message addr
;		  =6 get file system error message addr
;		  =7 set file system error message addr
;		  =8 get address for code reduction
;		  =9 set address for code reduction
;   Function:	get/set message address
;   Outputs:	ES:DI points to addr when get
;----------------------------------------------------------------------------

Procedure   MSG_RETRIEVAL,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING


;;	NOTE:  This function lives in command.com resident code now.
;;	If the int 2F ever gets this far, we'll return registers
;;	unchanged, which produces the same result as before, if
;;	command.com wasn't present (and therefore no messages available).
;;
;;	I didn't point the entry in the 2F table to No_Op because
;;	No_Op zeroes AL.
;;
;;;hkn; set up ds to point to DOSDATA
;;	push	ds
;;	getdseg	<ds>			; ds -> dosdata
;;
;;	PUSH	AX		    ;AN000;;MS. save regs
;;	PUSH	SI		    ;AN000;;MS. save regs
;;	MOV	AX,DX		    ;AN000;;MS.
;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
;;	test	AL,1		    ;AN000;;MS. get ?
;;	JZ	toget		    ;AN000;;MS. yes
;;	DEC	AL		    ;AN000;;MS.
;;toget:				    ;AN000;
;;	SHL	AL,1		    ;AN000;;MS. times 2
;;	XOR	AH,AH		    ;AN000;;MS.
;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
;;	test	DL,1		    ;AN000;;MS. get ?
;;	JZ	getget			     ;AN000;;MS. yes
;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
;;getget: 				     ;AN000;
;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
;;MSGret: 				     ;AN000;
;;	POP	SI			     ;AN000;;MS.
;;	POP	AX			     ;AN000;;MS.
;;
;;	pop	ds
	return				     ;AN000;;MS. exit

EndProc MSG_RETRIEVAL			     ;AN000;


;***Break	<Fake_version - set/reset version flag>
;***;----------------------------------------------------------------------------
;***;
;***;   Inputs:	DL=0 current version number
;***;		  <>0  special version number
;***;   Function:	set special version number
;***;   Outputs:	version number is changed
;***;
;***;----------------------------------------------------------------------------
;***
;***Procedure   Fake_version,NEAR
;***	ASSUME	CS:DOSCODE,SS:NOTHING
;***
;***;hkn; set up ds to point to DOSDATA
;***	push	ds
;***	getdseg	<ds>			; ds -> dosdata
;***	MOV	[Special_version],DX   ;AN006;MS.
;***	pop	ds
;***	return			       ;AN006;;MS. exit
;***
;***EndProc Fake_version		       ;AN006;;MS.


DOSCODE	ENDS
	END




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mpatch.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;mpatch.asm -- holds data patch location for callouts 
; -- allocate cluster in rom.asm
;
; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
; Currently, this location is used only by magicdrv.sys's patch to
; cluster allocation, however it can be expanded to be used by other
; patches.  This is important since we have an easy-access pointer to
; this location in OffsetMagicPatch.  Magicdrv.sys is guaranteed to
; only patch out a far call/retf, so any space after that could be
; used as a patch by using OffsetMagicPatch+6.  See rom.asm on how
; to call out here.
;
; Currently, we allocate only the minimum space required for the 6
; byte magicdrv patch, so if you change the dos data, you may want
; to reserve space here if your new data will be position dependent
; and would prohibit growing of this table.
;       
;history	-	created 8-7-92 by scottq
;		-	added Rational386PatchPtr 2-1-93 by jimmat
;
;Exported Functions
;==================
;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
;
DosData Segment

; Rational386PatchPtr points to either a RET instruction (80286 or less) or
; a routine to fix buggy versions of the Rational DOS Extender (80386 or
; greater).  Added to this file because it needed to be somewhere and is
; 'patch' related.

	public	Rational386PatchPtr

Rational386PatchPtr	dw	?	; points to patch routine or RET instr.


MagicPatch proc far
        retf            ;default is to just return to allocate
        nop             ;however, this code will be patched
        nop             ;by magicdrv.sys to
        nop             ; call far ?:?     
        nop             ; retf or perhaps just jmp far
        nop             ;retf/nop take one byte, so we need six instructions
                        ;for 6 byte patch
MagicPatch endp

DosData Ends

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mscode.asm ===
TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
	NAME	IBMCODE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	MSCODE.ASM - System Call Dispatch Code
;
;	Revision History
;	================
;
;	M001	SR	07/16/90 Return new patch table even if patches
;				 not needed.
;	M002	SR	07/16/90 Numerous bug fixes for WIN386 3.0
;
;	M013	SMR	08/27/90 INT 25/26 do not use user_ss & user_sp
;				 any longer.
;
;	M018	SR	08/29/90 Added support to ask Win386 to load
;				 VxD for local A20 & paging bugs.
;
;       M022    MD      09/07/90 Removed IBMCOPYRIGHT conditional
;
;	M023	SR	9/7/90	 Fixed Share build problems with msdata
;
;	M037	SR	10/16/90 Changed version check for loading VxD
;				 to load if version < 3.10
;
;       M039    DB      10/25/90 Optimized buffer scan in ABSDWRT; added dirty
;                                buffer check to ABSDRD.
;
;	M044	SR	11/1/90	 Bug #3869. Changed int 2fh handler to
;				 detect switcher Windows Swapout &
;				 Swapin calls to save & restore the
;				 last para of Windows memory.
;
; 	M048	HKN	11/14/90 set up DS using getdseg in cal_lk as we
;				 do not want to make any assumptions 
;				 regarding SS
;
;	M062	HKN	01/22/91 save and restore the umb_head arena at 
;				 win startup and exit time for win ver < 3.1.
;
;	M066	SMR	01/29/91 Added SWITCHES=/W for suppressing mandatory
;				 loading of WINA20.386
;
;	M067	SR	2/8/91   Bug #5758. Null out the VxD ptr in
;				 Win386_info before doing the version
;				 check so that the ptr is null for
;				 Win 3.1 always.
;
;	M072	HKN	03/08/91 Use es to access AbsRdWr_SS/SP to restore
;				 user stack.
;



	.xlist
	.xcref
	include version.inc
	include mssw.asm
	.cref
	.list

;**	MSCODE.ASM -- MSDOS code
;

	.xlist
	.xcref
	include version.inc
	include dossym.inc
	include devsym.inc
	include dosseg.inc
	include fastopen.inc
	include fastxxxx.inc
	include mult.inc
	include dpb.inc
	include vector.inc
	include curdir.inc
	include mi.inc

	include win386.inc	;Win386 constants
	include syscall.inc	;M018

	.cref
	.list

AsmVars <Debug>

    I_need  InDos,BYTE			; TRUE => we are in dos, no interrupt
    I_need  OpenBuf,128 		; temp name buffer
    I_need  ExtErr,WORD 		; extended error code
    I_need  AbsRdWr_SS,WORD		; stack segment from user M013
    I_need  AbsRdWr_SP,WORD		; stack pointer from user M013
    I_need  DskStack,BYTE		; stack segment inside DOS
    I_need  ThisCDS,DWORD		; Currently referenced CDS pointer
    I_need  ThisDPB,DWORD		; Currently referenced DPB pointer
    I_need  Err_Table_21		; allowed return map table for errors
    I_need  FailErr,BYTE		; TRUE => system call is being failed
    I_need  ExtErr_Action,BYTE		; recommended action
    I_need  ExtErr_Class,BYTE		; error classification
    I_need  ExtErr_Locus,BYTE		; error location
    I_need  User_In_AX,WORD		; initial input user AX
    I_need  HIGH_SECTOR,WORD		; >32mb
    I_need  AbsDskErr,WORD		; >32mb
    I_need  FastOpenFlg,BYTE		;


    I_need  CURSC_DRIVE,BYTE		;
    I_need  TEMPSEG,WORD		; hkn; used to store ds temporarily
;
;These needed for code to flush buffers when doing absolute writes(int 26h)
;added by SR - 3/25/89
;
    I_need  FIRST_BUFF_ADDR,WORD	;DOS 4.0
    I_need  SC_CACHE_COUNT,WORD		;DOS 4.0
    I_need  SC_DRIVE,BYTE		;DOS 4.0

;
; SR;
; Needed for WIN386 support
;
	I_need	IsWin386,byte		; flag indicating Win386 presence
	I_need	Win386_Info,byte	; DOS instance table for Win386

;
; M001; New table for WIN386 giving offsets of some DOS vars
;
	I_need	Win386_DOSVars		; Table of DOS offsets ; M001
	I_need	Redir_Patch		; Crit section flag    ; M002

;
; Win386 2.xx instance table
;
	I_need	OldInstanceJunk

	I_need	BootDrive,byte		; M018
	I_need	VxDpath, byte		; M018


        I_need  TEMP_VAR,WORD           ; M039
        I_need  TEMP_VAR2,WORD          ; M039

	I_need	CurrentPDB,WORD		; M044
	I_need	WinoldPatch1,BYTE	; M044
	I_need	WinoldPatch2,BYTE	; M044

	I_need	UmbSave1,BYTE		; M062
	I_need  UmbSave2,BYTE		; M062
	I_need	UmbSaveFlag,BYTE	; M062

	I_need	umb_head,WORD

	I_need	Dos_Flag,BYTE		; M066

;
; Include bios data segment declaration. Used for accessing DOS data segment 
; at 70:3 & bios int 2F entry point at 70:5
;

BData	segment at 70H			; M023
			
	extrn	bios_i2f:far		; M023

BData	ends				; M023


DOSCODE	SEGMENT
	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

    	extrn FOO:WORD			; return address for dos 2f dispatch
    	extrn DTAB:WORD			; dos 2f dispatch table
    	extrn I21_Map_E_Tab:BYTE	; mapping extended error table

	extrn 	NoVxDErrMsg:BYTE	; no VxD error message ;M018
	extrn	VXDMESLEN:ABS		; length of above message ;M018

ifdef ROMDOS
	allow_getdseg			; M023
else
	extrn DosDseg:word
endif


BREAK <NullDev -- Driver for null device>

; ROMDOS note:
;	NUL device driver used to be here, but it was removed and placed in
;	DOSDATA, because the entry points have to be in the segment as the
;	header, which is also in DOSDATA.


BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>

Public MSC001S,MSC001E
MSC001S label byte
	IF	IBM
; Codes returned by BIOS
ERRIN:
	DB	2			; NO RESPONSE
	DB	6			; SEEK FAILURE
	DB	12			; GENERAL ERROR
	DB	4			; BAD CRC
	DB	8			; SECTOR NOT FOUND
	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
ERROUT:
; DISK ERRORS RETURNED FROM INT 25 and 26
	DB	80H			; NO RESPONSE
	DB	40H			; Seek failure
	DB	2			; Address Mark not found
	DB	10H			; BAD CRC
	DB	4			; SECTOR NOT FOUND
	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK

NUMERR	EQU	$-ERROUT
	ENDIF
MSC001E label byte

;--------------------------------------------------------------------------
;
; Procedure Name : AbsSetup
;
;   AbsSetup - setup for abs disk functions
;
;----------------------------------------------------------------------------

Procedure   AbsSetup,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	INC	INDOS			; SS override
	STI
	CLD
	PUSH	DS

	Context DS			; SS is DOSDATA
	CALL	GETBP
	JC	errdriv 		; PM. error drive			;AN000;
	MOV	ES:[BP.dpb_free_cnt],-1 ; do not trust user at all.
errdriv:
	POP	DS
ASSUME	DS:NOTHING
	retc

					; SS override
	MOV	[HIGH_SECTOR],0 	;>32mb	from API			;AN000;
	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit	;AN000;
	retc

	invoke	SET_RQ_SC_PARMS 	;LB. set up SC parms			;AN000;
	PUSH	DS
	PUSH	SI
	PUSH	AX

	Context DS			; SS is DOSDATA & OPENBUF is in 
					; DOSDATA
	MOV	SI,OFFSET DOSDATA:OPENBUF
	MOV	[SI],AL
	ADD	BYTE PTR [SI],"A"
	MOV	WORD PTR [SI+1],003AH	; ":",0
	MOV	AX,0300H
	CLC
	INT	int_IBM 		; Will set carry if shared
	POP	AX
	POP	SI
	POP	DS
ASSUME	DS:NOTHING
	retnc
	MOV	ExtErr,error_not_supported
	return
EndProc AbsSetup

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDRD
;
; Interrupt 25 handler.  Performs absolute disk read.
; Inputs:	AL - 0-based drive number
;		DS:BX point to destination buffer
;		CX number of logical sectors to read
;		DX starting  logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------

procedure   ABSDRD,FAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	CLI

;	set up ds to point to DOSDATA

	push	ax			; preserve AX value
	mov	ax, ds			; store DS value in AX
	getdseg	<ds>
	mov	[TEMPSEG], ax		; store DS value in TEMPSEG
	pop	ax			; restore AX value

	;
	; M072:
	; We shall save es on the user stack here. We need to use ES in
	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
	; time in order to restore the user stack.
	;

	push	es			; M072

	MOV	[AbsRdWr_SS],SS		; M013
	MOV	[AbsRdWr_SP],SP		; M013

;	PUSH	CS
;	POP	SS

;
; 	set up ss to point to DOSDATA
;
; NOTE!  Due to an obscure bug in the 80286, you cannot use the ROMDOS
; version of the getdseg macro with the SS register!  An interrupt will
; sneak through.

ifndef ROMDOS
	getdseg	<ss>				; cli in entry of routine
else
	mov	ds, cs:[BioDataSeg]
	assume	ds:bdata

	mov	ss, ds:[DosDataSg]
	assume	ss:DOSDATA

endif ; ROMDOS

	MOV	SP,OFFSET DOSDATA:DSKSTACK

					; SS override
	mov	ds, [TEMPSEG]		; restore DS value
	assume	ds:nothing

					; use macro
	Save_World		      	;>32mb save all regs

	PUSH	ES
	CALL	AbsSetup
	JC	ILEAVE
                                        ;M022 conditional removed here
	;
	; Here is a gross temporary fix to get around a serious design flaw in
	;  the secondary cache.  The secondary cache does not check for media
	;  changed (it should).  Hence, you can change disks, do an absolute
	;  read, and get data from the previous disk.  To get around this,
	;  we just won't use the secondary cache for absolute disk reads.
	;                                                      -mw 8/5/88

	EnterCrit   critDisk
	MOV	[CURSC_DRIVE],-1	; invalidate SC	;AN000;
	LeaveCrit   critDisk
	invoke	DSKREAD

;M039
        jnz     ERR_LEAVE               ;Jump if read unsuccessful.

        mov     cx,di
        mov     WORD PTR [TEMP_VAR2],ds
        mov     WORD PTR [TEMP_VAR],bx

;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;	The Buffer Queue must now be scanned: the contents of any dirty
;	buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.

        invoke  DskRdBufScan		;This trashes DS, but don't care.
        jmp     short ILEAVE
;M039

TLEAVE:
	JZ	ILEAVE
ERR_LEAVE:                              ;M039
	IF	IBM
	PUSH	ES
	PUSH	CS
	POP	ES
	XOR	AH,AH			; Nul error code
	MOV	CX,NUMERR		; Number of possible error conditions

					; ERRIN is defined in DOSCODE
	MOV	DI,OFFSET DOSCODE:ERRIN ; Point to error conditions

	REPNE	SCASB
	JNZ	LEAVECODE		; Not found
	MOV	AH,ES:[DI+NUMERR-1]	; Get translation
LEAVECODE:
	POP	ES
	ENDIF
					; SS override
	MOV	AbsDskErr,AX		;>32mb save error
	STC
ILEAVE:
	POP	ES
					;use macro
	Restore_World		     	

	CLI

	MOV	AX,AbsDskErr	     	;>32mb restore error;AN000;

; SS override for INDOS, AbsRdWr_sp & AbsRdWr_ss	; M013
	DEC	INDOS

	push	ss			; M072 - Start
	pop	es			; es - dosdata
	mov	ss, es:[AbsRdWr_ss]	; M013
	mov	sp, es:[AbsRdWr_sp]	; M013
	
;; 	mov	sp, [AbsRdWr_sp]	; M013
;; 	mov	ss, [AbsRdWr_ss]	; M013
	assume	ss:nothing

	pop	es			; Note es was saved on user
					; stack at entry 
					; M072 - End

	STI
	RET				; This must not be a RETURN!
EndProc ABSDRD

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDWRT
;
; Interrupt 26 handler.  Performs absolute disk write.
; Inputs:	AL - 0-based drive number
;		DS:BX point to source buffer
;		CX number of logical sectors to write
;		DX starting  logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------

procedure   ABSDWRT,FAR
	ASSUME	SS:NOTHING

	CLI

;	set up ds to point to DOSDATA

	push	ax
	mov	ax, ds
	getdseg	<ds>
	mov	[TEMPSEG], ax
	pop	ax


	; M072:
	; We shall save es on the user stack here. We need to use ES in
	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
	; time in order to restore the user stack.
	;

	push	es			; M072

	MOV	[AbsRdWr_SS],SS		; M013
	MOV	[AbsRdWr_SP],SP		; M013

;	PUSH	CS
;	POP	SS

	;
	; set up ss to point to DOSDATA
	;
	; NOTE!  Due to an obscure bug in the 80286, you cannot use the 
	; ROMDOS version of the getdseg macro with the SS register!
	; An interrupt will sneak through.
	;

ifndef ROMDOS
	getdseg	<ss>				; cli in entry of routine
else
	mov	ds, cs:[BioDataSeg]
	assume	ds:bdata

	mov	ss, ds:[DosDataSg]
	ASSUME	SS:DOSDATA

endif ; ROMDOS

	MOV	SP,OFFSET DOSDATA:DSKSTACK
	; we are now switched to DOS's disk stack

	mov	ds, [TEMPSEG]		; restore user's ds
	assume	ds:nothing

					; use macro 
	Save_World		      	;>32mb save all regs		;AN000;

	PUSH	ES
	CALL	AbsSetup
	JC	ILEAVE

	EnterCrit   critDisk

					; SS override
	MOV	[CURSC_DRIVE],-1	; invalidate SC			;AN000;
	CALL	Fastxxx_Purge		; purge fatopen			;AN000;
	LeaveCrit   critDisk

;M039
;       DS:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;       [CURSC_DRIVE] = -1 (invalid drive).
;
;       Free any buffered sectors which are in Extent; they are being over-
;       written.  Note that all the above registers are preserved for
;       DSKWRITE.

        push    ds
        invoke  DskWrtBufPurge          ;This trashes DS.
        pop     ds
;M039

	invoke	DSKWRITE
	JMP	TLEAVE
EndProc ABSDWRT

;----------------------------------------------------------------------------
;
; Procedure Name : GETBP
;
; Inputs:
;	AL = Logical unit number (A = 0)
; Function:
;	Find Drive Parameter Block
; Outputs:
;	ES:BP points to DPB
;	[THISDPB] = ES:BP
;	Carry set if unit number bad or unit is a NET device.
;		Later case sets extended error error_I24_not_supported
; No other registers altered
;
;----------------------------------------------------------------------------

Procedure GETBP,NEAR
	DOSAssume   <DS>,"GetBP"

	PUSH	AX
	ADD	AL,1			; No increment; need carry flag
	JC	SkipGet
	invoke	GetThisDrv
	JNC	SkipGet 		;PM. good drive			;AN000;
	XOR	AH,AH			;DCR. ax= error code 		;AN000;
	CMP	AX,error_not_dos_disk	;DCR. is unknown media ?		;AN000;
	JZ	SkipGet 		;DCR. yes, let it go 		;AN000;
	STC				;DCR.				;AN000;
	MOV	ExtErr,AX		;PM. invalid drive or Non DOS drive	;AN000;
	mov	AbsDskErr, 201h
SkipGet:
	POP	AX
	retc
	LES	BP,[THISCDS]
	TEST	ES:[BP.curdir_flags],curdir_isnet   ; Clears carry
	JZ	GETBP_CDS
	MOV	ExtErr,error_not_supported
	STC
	return

GETBP_CDS:
	LES	BP,ES:[BP.curdir_devptr]

entry	GOTDPB
	DOSAssume   <DS>,"GotDPB"

;	Load THISDPB from ES:BP

	MOV	WORD PTR [THISDPB],BP
	MOV	WORD PTR [THISDPB+2],ES
	return
EndProc GetBP

BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>

ASSUME	SS:DOSDATA
;----------------------------------------------------------------------------
;
; Procedure Name : SYS_RETURN
;
; These are the general system call exit mechanisms.  All internal system
; calls will transfer (jump) to one of these at the end.  Their sole purpose
; is to set the user's flags and set his AX register for return.
;
;---------------------------------------------------------------------------

procedure   SYS_RETURN,NEAR
entry	SYS_RET_OK
	invoke	get_user_stack
	AND	[SI.user_F],NOT f_Carry ; turn off user's carry flag
	JMP	SHORT DO_RET		; carry is now clear

entry	SYS_RET_ERR
	XOR	AH,AH			; hack to allow for smaller error rets
	invoke	ETAB_LK 		; Make sure code is OK, EXTERR gets set
	CALL	ErrorMap
entry	From_GetSet
	invoke	get_user_stack
	OR	[SI.user_F],f_Carry	; signal carry to user
	STC				; also, signal internal error
DO_RET:
	MOV	[SI.user_AX],AX 	; Really only sets AH
	return

	entry	FCB_RET_OK
	entry	NO_OP			; obsolete system calls dispatch to here
	XOR	AL,AL
	return

	entry	FCB_RET_ERR
	XOR	AH,AH
	mov	exterr,AX
	CALL	ErrorMap
	MOV	AL,-1
	return

	entry	errorMap
	PUSH	SI

					; ERR_TABLE_21 is now in DOSDATA
	MOV	SI,OFFSET DOSDATA:ERR_TABLE_21

					; SS override for FAILERR and EXTERR
	CMP	[FAILERR],0		; Check for SPECIAL case.
	JZ	EXTENDED_NORMAL 	; All is OK.
	MOV	[EXTERR],error_FAIL_I24 ; Ooops, this is the REAL reason
EXTENDED_NORMAL:
	invoke	CAL_LK			; Set CLASS,ACTION,LOCUS for EXTERR
	POP	SI
	return

EndProc SYS_RETURN

;---------------------------------------------------------------------------
;
; Procedure Name : CAL_LK
;
; Inputs:
;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
;		(DS NEED not be DOSDATA)
;	[EXTERR] is set with error
; Function:
;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
; Outputs:
;	[EXTERR_CLASS] set
;	[EXTERR_ACTION] set
;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
; Destroys SI, FLAGS
;
;--------------------------------------------------------------------------

procedure   CAL_LK,NEAR

	PUSH	DS
	PUSH	AX
	PUSH	BX

;M048	Context DS		; DS:SI -> Table
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	getdseg	<ds>		; M048: DS:SI -> Table

	MOV	BX,[EXTERR]	; Get error in BL
TABLK1:
	LODSB

	CMP	AL,0FFH
	JZ	GOT_VALS	; End of table
	CMP	AL,BL
	JZ	GOT_VALS	; Got entry
	ADD	SI,3		; Next table entry
	JMP	TABLK1

GOT_VALS:
	LODSW			; AL is CLASS, AH is ACTION

	CMP	AH,0FFH
	JZ	NO_SET_ACT
	MOV	[EXTERR_ACTION],AH     ; Set ACTION
NO_SET_ACT:
	CMP	AL,0FFH
	JZ	NO_SET_CLS
	MOV	[EXTERR_CLASS],AL      ; Set CLASS
NO_SET_CLS:
	LODSB			; Get LOCUS

	CMP	AL,0FFH
	JZ	NO_SET_LOC
	MOV	[EXTERR_LOCUS],AL
NO_SET_LOC:
	POP	BX
	POP	AX
	POP	DS
	return
EndProc CAL_LK

;----------------------------------------------------------------------------
;
; Procedure Name : ETAB_LK
;
; Inputs:
;	AX is error code
;	[USER_IN_AX] has AH value of system call involved
; Function:
;	Make sure error code is appropriate to this call.
; Outputs:
;	AX MAY be mapped error code
;	[EXTERR] = Input AX
; Destroys ONLY AX and FLAGS
;
;---------------------------------------------------------------------------

procedure   ETAB_LK,NEAR

	PUSH	DS
	PUSH	SI
	PUSH	CX
	PUSH	BX

	Context DS			; SS is DOSDATA
	MOV	[EXTERR],AX		; Set EXTERR with "real" error

					; I21_MAP_E_TAB is now in DOSCODE
	MOV	SI,OFFSET DOSCODE:I21_MAP_E_TAB
	MOV	BH,AL			; Real code to BH
	MOV	BL,BYTE PTR [USER_IN_AX + 1]	; Sys call to BL
TABLK2:
;hkn;	LODSW
	LODS	word ptr cs:[si]

	CMP	AL,0FFH 		; End of table?
	JZ	NOT_IN_TABLE		; Yes
	CMP	AL,BL			; Found call?
	JZ	GOT_CALL		; Yes
	XCHG	AH,AL			; Count to AL
	XOR	AH,AH			; Make word for add
	ADD	SI,AX			; Next table entry
	JMP	TABLK2

NOT_IN_TABLE:
	MOV	AL,BH			; Restore original code
	JMP	SHORT NO_MAP

GOT_CALL:
	MOV	CL,AH
	XOR	CH,CH			; Count of valid err codes to CX
CHECK_CODE:
;hkn;	LODSB
	LODS	byte ptr cs:[si]

	CMP	AL,BH			; Code OK?
	JZ	NO_MAP			; Yes
	LOOP	CHECK_CODE
NO_MAP:
	XOR	AH,AH			; AX is now valid code
	POP	BX
	POP	CX
	POP	SI
	POP	DS
	return

EndProc ETAB_LK

BREAK <DOS 2F Handler and default NET 2F handler>

IF installed
;----------------------------------------------------------------------------
;
; Procedure Name : SetBad
;
; SetBad sets up info for bad functions
;
;--------------------------------------------------------------------------

Procedure   SetBad,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	MOV	AX,error_invalid_function	; ALL NET REQUESTS get inv func

;	set up ds to point to DOSDATA

	push	ds
	getdseg	<ds>

	MOV	ExtErr_LOCUS,errLoc_UNK

	pop	ds	  		;hkn; restore ds
	assume	ds:nothing

	STC
	ret
EndProc SetBad

;--------------------------------------------------------------------------
;
; Procedure Name : BadCall
;
; BadCall is the initial routine for bad function calls
;
;--------------------------------------------------------------------------

procedure   BadCall,FAR
	call	SetBad
	ret
EndProc BadCall

;--------------------------------------------------------------------------
;
; OKCall always sets carry to off.
;
;-----------------------------------------------------------------------

Procedure   OKCall,FAR

	ASSUME	CS:DOSCODE,SS:NOTHING
	CLC
	ret

EndProc OKCall

;---------------------------------------------------------------------------
;
; Procedure Name : INT2F
;
; INT 2F handler works as follows:
;   PUSH    AX
;   MOV     AX,multiplex:function
;   INT     2F
;   POP     ...
; The handler itself needs to make the AX available for the various routines.
;
;----------------------------------------------------------------------------

PUBLIC	Int2F
INT2F	PROC	FAR

INT2FNT:
	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	STI
	CMP	AH,multNET
	JNZ	INT2FSHR
TestInstall:
	OR	AL,AL
	JZ	Leave2F
BadFunc:
	CALL	SetBad
	entry	Leave2F
	RET	2			; long return + clear flags off stack

INT2FSHR:
	CMP	AH,multSHARE		; is this a share request
	JZ	TestInstall		; yes, check for installation

INT2FNLS:
	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
	JZ	TestInstall		; yes check for installation

INT2FDOS:
	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	CMP	AH,multDOS
	JNZ	check_win		;check if win386 broadcast
	jmp	DispatchDOS

check_win:
	cmp	ah,multWIN386		; Is this a broadcast from Win386?
	je	Win386_Msg

	;
	; M044
	; Check if the callout is from Winoldap indicating swapping out or in 
	; of Windows. If so, do special action of going and saving last para
	; of the Windows memory arena which Winoldap does not save due to a 
	; bug
	;

	cmp	ah,WINOLDAP		; from Winoldap?
	jne	next_i2f		; no, chain on
	jmp	Winold_swap		; yes, do desired action

next_i2f:
	jmp	bios_i2f


;	IRET				; This assume that we are at the head
					; of the list
INT2F	ENDP

;
; We have received a message from Win386.  There are three possible
; messages we could get from Win386:
;
; Init 		- for this, we set the IsWin386 flag and return a pointer
;		  to the Win386 startup info structure.
; Exit		- for this, we clear the IsWin386 flag.
; DOSMGR query 	- for this, we need to indicate that instance data
;		  has already been handled.  this is indicated by setting
;		  CX to a non-zero value.
;

Win386_Msg:

	push	ds

	getdseg	<DS>			; ds is DOSDATA

	;
	; For WIN386 2.xx instance data
	;

	cmp	al,03			;win386 2.xx instance data call?
	lje	OldWin386Init		;yes, return instance data

	cmp	al, Win386_Exit		; is it an exit call?
	lje	Win386_Leaving
	cmp	al, Win386_Devcall	; is it call from DOSMGR?
	lje	Win386_Query
	cmp	al, Win386_Init		; is it an init call?
	ljne	win_nexti2f		; no, return

Win386_Starting:
	test	dx, 1			; is this really win386?
	jz	@f			; YES! go and handle it
	jmp	win_nexti2f		; NO!  It's win 286 dos extender! M002
@@:

	;
	; M018 -- start of block changes
	; The VxD needs to be loaded only for Win 3.0. If version is greater 
	; than 030ah, we skip the VxD presence check
	;

;M067 -- Begin changes
; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
;run, it tries to unnecesarily load the VxD even though it is not needed.
;So, we null out the VxD ptr before the check.
;
	mov	word ptr Win386_Info.SIS_Virt_Dev_File_Ptr, 0
	mov	word ptr Win386_Info.SIS_Virt_Dev_File_Ptr+2, 0
;
;M067 -- End changes
;

ifdef JAPAN
	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
else
	cmp	di,030ah		; version >= 30a i.e 3.10 ;M037
endif
	ljae	noVxD31			; yes, VxD not needed 	 ;M037


	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di			; save regs !!dont change order!!

	mov	bx, [umb_head]		; M062 - Start
	cmp	bx, 0ffffh    		; Q: have umbs been initialized
	je	Vxd31			; N: continue
					; Y: save arena associated with 
					;    umb_head

	mov	[UmbSaveFlag], 1	; indicate that we're saving 
					; umb_arena
	push	ds
	push	es

	mov	ax, ds
	mov	es, ax			; es - > dosdata

	mov	ds, bx
	xor	si, si			; ds:si -> umb_head

	cld

	mov	di, offset dosdata:UmbSave1
	mov	cx, 0bh
rep	movsb

	mov	di, offset dosdata:UmbSave2
	mov	cx, 05h
rep	movsb	

	pop	es
	pop	ds			; M062 - End

Vxd31:
	test	Dos_Flag, SUPPRESS_WINA20	; M066
	jz	Dont_Supress			; M066
	pop	di				; M066
	pop	si				; M066
	pop	dx				; M066
	pop	cx				; M066
	pop	bx				; M066
	pop	ax				; M066
	jmp	short NoVxd31			; M066

	;
	; We check here if the VxD is available in the root of the boot drive. 
	; We do an extended open to suppress any error messages
	;
Dont_Supress:
	mov	al,BootDrive
	add	al,'A' - 1		; get drive letter
	mov	byte ptr VxDpath,al	; path is root of bootdrive
	mov	ah,EXTOPEN		; extended open
	mov	al,0			; no extended attributes
	mov	bx,2080h		; read access, compatibility mode
					; no inherit, suppress crit err
	mov	cx,7			; hidden,system,read-only attr
	mov	dx,1			; fail if file does not exist
	mov	si,offset DOSDATA:VxDpath	
					; path of VxD file
	mov	di,0ffffh		; no extended attributes

	int	21h			; do extended open
	pop	di
	pop	si
	pop	dx
	pop	cx
	jnc	VxDthere		; we found the VxD, go ahead

	;
	; We could not find the VxD. Cannot let windows load. Return cx != 0 
	; to indicate error to Windows after displaying message to user that 
	; VxD needs to be present to run Windows in enhanced mode.
	;

	push	dx
	push	ds
	push	si
	mov	si,offset DOSCODE:NoVxDErrMsg
	push	cs
	pop	ds
	mov	cx,VXDMESLEN		;
	mov	ah,02			; write char to console
	cld
vxdlp:
	lodsb
	xchg	dl,al			; get char in dl
	int	21h
	loop	vxdlp

	pop	si
	pop	ds
	pop	dx
	pop	bx
	pop	ax			;all registers restored
	inc	cx			;cx != 0 to indicate error
	jmp	win_nexti2f		;chain on

VxDthere:
	mov	bx,ax
	mov	ah,CLOSE
	int	21h			;close the file

	;
	; Update the VxD ptr in the instance data structure with path to VxD
	;
	mov	bx,offset DOSDATA:Win386_Info
	mov	word ptr [bx].SIS_Virt_Dev_File_Ptr, offset DOSDATA:VxDpath
	mov	word ptr [bx].SIS_Virt_Dev_File_Ptr+2, ds	;

	pop	bx
	pop	ax
NoVxD31:
	
	;
	; M018; End of block changes
	;

	or	ds:IsWIN386,1 		; Indicate WIN386 present
	or	ds:redir_patch,1	; Enable critical sections; M002

	; M002;
	; Save the previous es:bx (instance data ptr) into our instance table
	;

	push	dx			; M002
	mov	dx,bx			; M002
					; point ES:BX to Win386_Info ; M002
	mov	bx, offset dosdata:Win386_Info 
	mov	word ptr [bx+2],dx	; M002
	mov	word ptr [bx+4],es	; M002
	pop	dx			; M002
	push	ds			; M002
	pop	es			; M002
	jmp	win_nexti2f		; M002

Win386_Leaving:
	test	dx, 1			; is this really win386?
	ljnz	win_nexti2f		; NO!  It's win 286 dos extender! M002

					; M062 - Start
	cmp	ds:[UmbSaveFlag], 1	; Q: was umb_arena saved at win start
					;    up.
	jne	noumb			; N: not saved 
	mov	ds:[UmbSaveFlag], 0	; Y: clear UmbSaveFlag and restore 
					;    previously saved umb_head
	push	ax
	push	es
	push	cx
	push	si
	push	di

	mov	ax, [umb_head]	
	mov	es, ax
	xor	di, di			; es:di -> umb_head

	cld

	mov	si, offset dosdata:UmbSave1
	mov	cx, 0bh
rep	movsb
	mov	si, offset dosdata:UmbSave2
	mov	cx, 05h
rep	movsb

	pop	di
	pop	si
	pop	cx
	pop	es
	pop	ax
noumb:					; M062 - End
	
	and	ds:[IsWIN386],0		; Win386 is gone
	and	ds:redir_patch,0	; Disable critical sections ; M002
	jmp	short win_nexti2f

Win386_Query:
	cmp	bx, Win386_DOSMGR	; is this from DOSMGR?
	jne	win_nexti2f     	; no, ignore it & chain to next
	or	cx, cx			; is it an instance query?
	jne	dosmgr_func		; no, some DOSMGR query
	inc	cx			; indicate that data is instanced

;
; M001; We were previously returning a null ptr in es:bx. This will not work.
; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
; M001;  
; M001; OFFSETS  STRUC
; M001; 	Major_version	db	?
; M001; 	Minor_version	db	?
; M001; 	SaveDS		dw	?
; M001; 	SaveBX		dw	?
; M001; 	Indos		dw	?
; M001; 	User_id		dw	?
; M001; 	CritPatch	dw	?
; M001; OFFSETS	 ENDS
; M001; 
; M001; User_Id is the only variable really important for proper functioning  
; M001; of Win386. The other variables are used at init time to patch stuff
; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
; M001; pass this table because Win386 depends on this table to get the 
; M001; User_Id offset.
; M001; 
	mov	bx,offset Win386_DOSVars; M001 
	push	ds			; M001
	pop	es			; es:bx points at offset table ; M001
	jmp	short PopIret		; M001

	;
	; Code to return Win386 2.xx instance table
	;
OldWin386Init:
	pop	ax			; discard ds pushed on stack
	mov	si,offset dosdata:OldInstanceJunk 
					; ds:si = instance table
	mov	ax, 5248h		; indicate instance data present
	jmp	next_i2f


dosmgr_func:
	dec	cx
	jz	win386_patch		; call to patch DOS
	dec	cx
	jz	PopIret			; remove DOS patches, ignore
	dec	cx
	jz	win386_size		; get size of DOS data structures
	dec	cx
	jz	win386_inst		; instance more data
	dec	cx
	jnz	PopIret			; no functions above this

	;
	; Get DOS device driver size -- es:di points at device driver header
	; In DOS 4.x, the para before the device header contains an arena 
	; header for the driver.
	;
	mov	ax,es			; ax = device header segment

	;
	; We check to see if we have a memory arena for this device driver. 
	; The way to do this would be to look at the previous para to see if
	; it has a 'D' marking it as an arena and also see if the owner-field 
	; in the arena is the same as the device header segment. These two 
	; checks together should take care of all cases
	;

	dec	ax			; get arena header
	push	es
	mov	es,ax			; arena header for device driver

	cmp	byte ptr es:[di],'D'	; is it a device arena?
	jnz	cantsize		; no, cant size this driver
	inc	ax			; get back device header segment
	cmp	es:[di+1],ax		; owner field pointing at driver?
	jnz	cantsize		; no, not a proper arena

	mov	ax,es:[di+3]		; get arena size in paras
	pop	es

	;
	; We have to multiply by 16 to get the number of bytes in (bx:cx)
	; Speed is not critical and so we choose the shortest method 
	; -- use "mul"
	;
	mov	bx,16
	mul	bx
	mov	cx,ax
	mov	bx,dx
	jmp	short win386_done	; return with device driver size
cantsize:
	pop	es
	xor	ax,ax
	xor	dx,dx			; ask DOSMGR to use its methods
	jmp	short PopIret		; return

win386_patch:

	;
	; dx contains bits marking the patches to be applied. We return 
	; the field with all bits set to indicate that all patches have been
	; done
	;

	mov	bx,dx			; move patch bitfield to bx
 	jmp	short win386_done	; done, return

win386_size:

	;
	;Return the size of DOS data structures -- currently only CDS size
	;

	test	dx,1			; check for CDS size bit
	jz	PopIret			; no, unknown structure -- return

	mov	cx,size CURDIR_LIST	; cx = CDS size
	jmp	short win386_done	; return with the size

win386_inst:

	;
	; WIN386 check to see if DOS has identified the CDS,SFT and device 
	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
	; this by returning a status of not previously instanced. The basic 
	; structure of these things have not changed and so the current 
	; DOSMGR code should be able to work it out
	;
	xor	dx,dx			; make sure dx has a not done value
	jmp	short PopIret		; skip done indication

win386_done:

	mov	ax,WIN_OP_DONE		;
	mov	dx,DOSMGR_OP_DONE	;
PopIret:
	pop	ds
	assume 	ds:nothing
	iret				; return back up the chain

win_nexti2f:
	pop	ds
	assume	ds:nothing
	jmp	next_i2f		; go to BIOS i2f handler

;
;End WIN386 support
;

;M044; Start of changes
; Winoldap has a bug in that its calculations for the Windows memory image
; to save is off by 1 para. This para can happen to be a Windows arena if the
; DOS top of memory happens to be at an odd boundary (as is the case when
; UMBs are present). This is because Windows builds its arenas only at even
; para boundaries. This arena now gets trashed when Windows is swapped back
; in leading to a crash. Winoldap issues callouts when it swaps WIndows out
; and back in. We sit on these callouts. On the Windows swapout, we save the
; last para of the Windows memory block and then restore this para on the
; Windows swapin callout. 
;

getwinlast	proc	near
	assume	ds:DOSDATA

	mov	si,CurrentPDB
	dec	si
	mov	es,si
	add	si,es:[3]
	ret
getwinlast	endp

winold_swap:
	push	ds
	push	es
	push	si
	push	di
	push	cx
	getdseg	<ds>			;ds = DOSDATA

	cmp	al,01			;swap Windows out call
	jne	swapin			;no, check if Swap in call
	call	getwinlast
	push	ds
	pop	es
	mov	ds,si			;ds = memory arena of Windows
	assume	ds:nothing
	xor	si,si
	mov	di,offset DOSDATA:WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;save first 8 bytes
	pop	cx
	mov	di,offset DOSDATA:WinoldPatch2
	rep	movsb			;save next 8 bytes
	jmp	short winold_done
swapin:
	cmp	al,02			;swap Windows in call?
	jne	winold_done		;no, something else, pass it on
	assume	ds:DOSDATA
	call	getwinlast
	mov	es,si
	xor	di,di
	mov	si,offset DOSDATA:WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;restore first 8 bytes
	pop	cx
	mov	si,offset DOSDATA:WinoldPatch2
	rep	movsb			;restore next 8 bytes
winold_done:
	pop	cx
	pop	di
	pop	si
	pop	es
	pop	ds
	assume 	ds:nothing
	jmp	next_i2f		;chain on

;
;M044; End of changes
;


DispatchDOS:
	PUSH	FOO			; push return address
	PUSH	DTab			; push table address
	PUSH	AX			; push index
	PUSH	BP
	MOV	BP,SP
; stack looks like:
;   0	BP
;   2	DISPATCH
;   4	TABLE
;   6	RETURN
;   8	LONG-RETURN
;   c	FLAGS
;   e	AX

	MOV	AX,[BP+0Eh]		; get AX value
	POP	BP
	Invoke	TableDispatch
	JMP	BadFunc 		; return indicates invalid function

Procedure   INT2F_etcetera,NEAR
	entry	DosGetGroup

;SR; Cannot use CS now
;
;	PUSH	CS
;	POP	DS

	getdseg	<ds>
	return

	entry	DOSInstall
	MOV	AL,0FFh
	return
EndProc INT2F_etcetera

ENDIF

;---------------------------------------------------------------------------
;
; Procedure Name : RW32_CONVERT
;
;Input: same as ABSDRD and ABSDWRT
;	 ES:BP -> DPB
;Functions: convert 32bit absolute RW input parms to 16bit input parms
;Output: carry set when CX=-1 and drive is less then 32mb
;	 carry clear, parms ok
;
;---------------------------------------------------------------------------

Procedure   RW32_CONVERT,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	CMP	CX,-1			     ;>32mb  new format ?		;AN000;
	JZ	new32format		     ;>32mb  yes			;AN000;
	PUSH	AX			     ;>32mb  save ax			;AN000;
	PUSH	DX			     ;>32mb  save dx			;AN000;
	MOV	AX,ES:[BP.dpb_max_cluster]   ;>32mb  get max cluster #		;AN000;
	MOV	DL,ES:[BP.dpb_cluster_mask]  ;>32mb				;AN000;
	CMP	DL,0FEH 		     ;>32mb  removable ?		;AN000;
	JZ	letold			     ;>32mb  yes			;AN000;
	INC	DL			     ;>32mb				;AN000;
	XOR	DH,DH			     ;>32mb  dx = sector/cluster	;AN000;
	MUL	DX			     ;>32mb  dx:ax= max sector #	;AN000;
	OR	DX,DX			     ;>32mb  > 32mb ?			;AN000;
letold:
	POP	DX			     ;>32mb  retore dx			;AN000;
	POP	AX			     ;>32mb  restore ax 		;AN000;
	JZ	old_style		     ;>32mb  no 			;AN000;

	push	ds
	getdseg	<ds>
	mov	AbsDskErr, 207h		     ;>32mb  bad address mark
	pop	ds

	STC				     ;>32mb				;AN000;
	return				     ;>32mb				;AN000;
new32format:

	assume	ds:nothing
	MOV	DX,WORD PTR [BX.SECTOR_RBA+2];>32mb				;AN000;

	push	ds			     ; set up ds to DOSDATA
	getdseg	<ds>

	MOV	[HIGH_SECTOR],DX	     ;>32mb				;AN000;

	pop	ds
	assume	ds:nothing

	MOV	DX,WORD PTR [BX.SECTOR_RBA]  ;>32mb				;AN000;
	MOV	CX,[BX.ABS_RW_COUNT]	     ;>32mb				;AN000;
	LDS	BX,[BX.BUFFER_ADDR]	     ;>32mb				;AN000;
old_style:				     ;>32mb				;AN000;
	CLC				     ;>32mb				;AN000;
	return				     ;>32mb				;AN000;
EndProc RW32_CONVERT

;---------------------------------------------------------------------------
;
; Procedure Name : Fastxxx_Purge
;
; Input: None
; Functions: Purge Fastopen/ Cache Buffers
; Output: None
;
;------------------------------------------------------------------------

Procedure   Fastxxx_Purge,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	PUSH	AX			      ; save regs.			;AN000;
	PUSH	SI								;AN000;
	PUSH	DX								;AN000;

topen:

	push	ds			      ; set up ds to DOSDATA
	getdseg	<ds>

	TEST	FastOpenflg,Fast_yes	      ; fastopen installed ?		;AN000;

	pop	ds
	assume	ds:nothing

	JZ	nofast			      ; no				;AN000;
	MOV	AH,FastOpen_ID		      ; 				AN000;
dofast:
	MOV	AL,FONC_purge		      ; purge				;AN000;
	MOV	DL,ES:[BP.dpb_drive]	      ; set up drive number		;AN000;
	invoke	Fast_Dispatch		      ; call fastopen/seek		;AN000;
nofast:
	POP	DX								;AN000;
	POP	SI			      ; restore regs			;AN000;
	POP	AX			      ; 				;AN000;

	return				      ; exit				;AN000;

EndProc Fastxxx_Purge

DOSCODE	ENDS

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msconst.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	MSCONST.ASM
;
;	Revision history
;	    AN000  version 4.00  Jan. 1988
;	    AN007  fake version check for IBMCACHE.COM
;
;	    M000   added save_ax, umb_head and start_arena for umb support
;		   7/9/90
;	    M003   added umbflag for link/unlink UMB support. 7/18/90
;	    M004   added PAS32_FLAG for MS PASCAL 3.2 comaptibility support
;	  	   7/30/90
;	    M014   added CL0FATENTRY. see pack/unpack in fat.asm for usage.
;		   8/28/90
;	    M044   bug #3869. Added WinoldPatch1, save area for the first
;		   8 0f 16 bytes to be saved.
;
;	    M063   added variable allocmsave for temporarily saving 
;		   allocmethod in msproc.asm.
;
;	    M068   support for copy protected apps. Added ChkCopyProt,
;		   A20OFF_PSP and changed A20OFF_FLAG to A20OFF_COUNT
;

include mshead.asm

DOSCODE	SEGMENT
	Extrn	LeaveDOS:NEAR
	Extrn	BadCall:FAR, OKCall:FAR

	PUBLIC	BugTyp,BugLev
if DEBUG
	DB	"BUG "                  ; THIS FIELD MUST BE EVEN # OF BYTES
BugTyp	DW	TypSyscall
BugLev	DW	LevLog
else
BugTyp	label	word
BugLev	label	word
endif

include bugtyp.inc			; put this after BUGTYP definition

DOSCODE	ENDS

Break <Initialized data and data used at DOS initialization>

;
; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.
;

	AsmVars <Debug, Redirector, ShareF>

DOSDATA	SEGMENT

	ORG	0

;hkn; add 4 bytes to get correct offsets since jmp has been removed in START

	db	4 dup (?)	

	EVEN
;
; WANGO!!!  The following word is used by SHARE and REDIR to determin data
; area compatability.  This location must be incremented EACH TIME the data
; area here gets mucked with.
;
; Also, do NOT change this position relative to DOSDATA:0.
;
Public MSCT001S,MSCT001E
MSCT001S	LABEL 	BYTE
	I_am	DataVersion,WORD,<1>	;AC000; [SYSTEM] version number for DOS DATA

;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
;hkn; been removed to DOSCODE above

;M044
; First part of save area for saving last para of Window memory
;
public WinoldPatch1
WinoldPatch1	db	8 dup (?)		;M044

	I_am	MYNUM,WORD,<0>		; [SYSTEM] A number that goes with MYNAME
	I_am	FCBLRU,WORD,<0> 	; [SYSTEM] LRU count for FCB cache
	I_am	OpenLRU,WORD,<0>	; [SYSTEM] LRU count for FCB cache opens
; NOTE: We include the decl of OEM_HANDLER in IBM DOS even though it is not used.
;	This allows the REDIRector to work on either IBM or MS-DOS.
	PUBLIC	OEM_HANDLER
OEM_HANDLER	DD	-1		; [SYSTEM] Pointer to OEM handler code
;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
;;			way that we leave DOS???? - jgl
	I_am	LeaveAddr,WORD,<<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
	I_am	RetryCount,WORD,<3>	; [SYSTEM] Share retries
	I_am	RetryLoop,WORD,<1>	; [SYSTEM] Share retries
	I_am	LastBuffer,DWORD,<-1,-1>; [SYSTEM] Buffer queue recency pointer
	I_am	CONTPOS,WORD		; [SYSTEM] location in buffer of next read
	I_am	arena_head,WORD 	; [SYSTEM] Segment # of first arena in memory
; The following block of data is used by SYSINIT.  Do not change the order or
; size of this block
	PUBLIC	SYSINITVAR		; [SYSTEM]
SYSINITVAR  LABEL   WORD		; [SYSTEM]
	I_am	DPBHEAD,DWORD		; [SYSTEM] Pointer to head of DPB-FAT list
	I_am	sft_addr,DWORD,<<OFFSET DOSDATA:sfTabl>,?> ; [SYSTEM] Pointer to first SFT table
	I_am	BCLOCK,DWORD		; [SYSTEM] The CLOCK device
	I_am	BCON,DWORD		; [SYSTEM] Console device entry points
	I_am	MAXSEC,WORD,<128>	; [SYSTEM] Maximum allowed sector size
	I_am	BUFFHEAD,DWORD		; [SYSTEM] Pointer to head of buffer queue
	I_am	CDSADDR,DWORD		; [SYSTEM] Pointer to curdir structure table
	I_am	sftFCB,DWORD		; [SYSTEM] pointer to FCB cache table
	I_am	KeepCount,WORD		; [SYSTEM] count of FCB opens to keep
	I_am	NUMIO,BYTE		; [SYSTEM] Number of disk tables
	I_am	CDSCOUNT,BYTE		; [SYSTEM] Number of CDS structures in above
; A fake header for the NUL device
	I_am	NULDEV,DWORD		; [SYSTEM] Link to rest of device list
	DW	DEVTYP OR ISNULL	; [SYSTEM] Null device attributes
	dw	offset dosdata:SNULDEV	; [SYSTEM] Strategy entry point
	dw	offset dosdata:INULDEV	; [SYSTEM] Interrupt entry point
	DB	"NUL     "              ; [SYSTEM] Name of null device
	I_am	Splices,BYTE,<0>	; [SYSTEM] TRUE => splices being done
	I_am	Special_Entries,WORD,<0>; [SYSTEM] address of specail entries	;AN000;
	I_am	UU_IFS_DOS_CALL,DWORD	; [SYSTEM] entry for IFS DOS service	;AN000;

;***	I_am	UU_IFS_HEADER,DWORD	; [SYSTEM] IFS header chain		;AN000;

	I_am	ChkCopyProt, WORD	; M068
	I_am	A20OFF_PSP, WORD	; M068

	I_am	BUFFERS_PARM1,WORD,<0>	; [SYSTEM] value of BUFFERS= ,m 	;AN000;
	I_am	BUFFERS_PARM2,WORD,<0>	; [SYSTEM] value of BUFFERS= ,n 	;AN000;
	I_am	BOOTDRIVE,BYTE		; [SYSTEM] the boot drive		;AN000;
	I_am	DDMOVE,BYTE,<0> 	; [SYSTEM] 1 if we need DWORD move	;AN000;
	I_am	EXT_MEM_SIZE,WORD,<0>	; [SYSTEM] extended memory size 	;AN000;

	PUBLIC	HASHINITVAR		; [SYSTEM]				;AN000;
HASHINITVAR  LABEL   WORD		; [SYSTEM]				;AN000;
;
; Replaced by next two declarations
;
;	I_am	UU_BUF_HASH_PTR,DWORD		; [SYSTEM] buffer Hash table 
						;          addr
;	I_am	UU_BUF_HASH_COUNT,WORD,<1> 	; [SYSTEM] number of Hash 
						;          entries

	I_am	BufferQueue,DWORD		; [SYSTEM] Head of the buffer 
						;  	   Queue
	I_am	DirtyBufferCount,WORD,<0> 	; [SYSTEM] Count of Dirty 
						;          buffers in the Que
						; BUGBUG ---- change to byte

	I_am	SC_CACHE_PTR,DWORD		; [SYSTEM] secondary cache 
						;	   pointer
	I_am	SC_CACHE_COUNT,WORD,<0> 	; [SYSTEM] secondary cache 
						;	   count
	I_am	BuffInHMA,byte,<0>		; Flag to indicate that buffs
						;  are in HMA
	I_am	LoMemBuff,dword			; Ptr to intermediate buffer
						;  in Low mem when buffs
						;  are in HMA

;
; All variables which have UU_ as prefix can be reused for other
; purposes and can be renamed. All these variables were used for
; EMS support of Buffer Manager. Now they are useless for Buffer
; manager ---- MOHANS
;

	I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
						; holds the first page above 
						; 640K
;**	I_am	UU_BUF_EMS_NPA640,WORD,<0>	; holds the number of pages 
						; above 640K		

	I_am	CL0FATENTRY, WORD,<-1>		; M014:	Holds the data that
						; is used in pack/unpack rts.
						; in fat.asm if cluster 0 
						; is specified.

						; SR;
	I_am	IoStatFail,BYTE,<0>		; IoStatFail has been added to 
						; record a fail on an I24 
						; issued from IOFUNC on a 
						; status call. 

;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; [SYSTEM] EMS mode			;AN000;
;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; [SYSTEM] buffer EMS handle		;AN000;
;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; [SYSTEM] EMS page frame #	;AN000;
;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; [SYSTEM] EMS seg count		;AN000;
;***	I_am	UU_BUF_EMS_PFRAME,WORD		; [SYSTEM] EMS page frame seg address	;AN000;
;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; [SYSTEM] reserved			;AN000;

;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
						; state of the 	buffers page.
						; This one byte is retained to 
						; keep the size of this data 
						; block the same.

	I_am	ALLOCMSAVE,BYTE,<0>		; M063: temp var. used to 
						; M063: save alloc method in
						; M063: msproc.asm

	I_am	A20OFF_COUNT,BYTE,<0>		; M068: indiactes the # of 
						; M068: int 21 calls for 
						; M068: which A20 is off
						

	I_am 	DOS_FLAG,BYTE,<0>		; see DOSSYM.INC for Bit 
						; definitions

	I_am	UNPACK_OFFSET,WORD,<0>		; saves pointer to the start
						; of unpack code in exepatch.
						; asm.

	I_am	UMBFLAG,BYTE,<0> 		; M003: bit 0 indicates the 
						; M003: link state of the UMBs
						; M003: whether linked or not 
						; M003: to the DOS arena chain


	I_am	SAVE_AX,WORD,<0>		; M000: temp varibale to store ax
						; M000: in msproc.asm

	I_am	UMB_HEAD,WORD,<-1>		; M000: this is initialized to  
						; M000: the first umb arena by 
						; M000: BIOS sysinit.

	I_am	START_ARENA,WORD,<1>		; M000: this is the first arena 
						; M000: from which DOS will 
						; M000: start its scan for alloc.


; End of SYSINITVar block

;
; Sharer jump table
;
PUBLIC	JShare
	EVEN
JShare	LABEL	DWORD
	DW	OFFSET DOSCODE:BadCall, 0
	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU

MSCT001E	LABEL	BYTE
DOSDATA	ENDS


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\misc.asm ===
TITLE MISC - Miscellanious routines for MS-DOS
	NAME  MISC

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Miscellaneous system calls most of which are CAVEAT
;
;	$SLEAZEFUNC
;	$SLEAZEFUNCDL
;	$GET_INDOS_FLAG
;	$GET_IN_VARS
;	$GET_DEFAULT_DPB
;	$GET_DPB
;	$DISK_RESET
;	$SETDPB
;	$Dup_PDB
;	$CREATE_PROCESS_DATA_BLOCK
;	SETMEM
;	FETCHI_CHECK
;	$GSetMediaID
;
;	Revision  history:
;
;	    Created: ARR 30 March 1983
;
;	    A000   version 4.00   Jan. 1988
;	    A001   D490 -- Change IOCTL subfunctions from 63h, 43h to 66h , 46h

;
;------------------------------------------------------------------------------
;
; M041 : Fixing Secondary cache problem with DISK_RESET
;
;------------------------------------------------------------------------------
;
	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include pdb.inc
	include dpb.inc
	include bpb.inc
	include vector.inc
	include sf.inc
	include filemode.inc
	include mi.inc
	include curdir.inc
	include bugtyp.inc
	.cref
	.list

	i_need	LASTBUFFER,DWORD
	i_need	INDOS,BYTE
	i_need	SYSINITVAR,BYTE
	i_need	CurrentPDB,WORD
	i_need	CreatePDB,BYTE
	i_need	FATBYTE,BYTE
	i_need	THISCDS,DWORD
	i_need	THISSFT,DWORD
	i_need	HIGH_SECTOR,WORD		 ;AN000; high word of sector #
	i_need	DOS34_FLAG,WORD 		 ;AN000;
	i_need	SC_STATUS,WORD			 ; M041


DOSCODE	SEGMENT

	allow_getdseg


	ASSUME	SS:DOSDATA,CS:DOSCODE

ENTRYPOINTSEG	EQU	0CH
MAXDIF		EQU	0FFFH
SAVEXIT 	EQU	10
WRAPOFFSET	EQU	0FEF0h


	BREAK	<SleazeFunc -- get a pointer to media byte>
;
;----------------------------------------------------------------------------
;
;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
;
;	Return Stuff sort of like old get fat call
;
;	ENTRY	none
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
;
;	Identical to $SLEAZEFUNC except (dl) = drive
;
;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;----------------------------------------------------------------------------
;


procedure   $SLEAZEFUNC,NEAR

	MOV	DL,0

entry	$SLEAZEFUNCDL

;hkn; 	SS is DOSDATA
	context DS

	MOV	AL,DL
	invoke	GETTHISDRV		; Get CDS structure
SET_AL_RET:
;	MOV	AL,error_invalid_drive	; Assume error				;AC000;
	JC	BADSLDRIVE
	invoke	DISK_INFO
	JC	SET_AL_RET		; User FAILed to I 24
	MOV	[FATBYTE],AH
; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
; CALL AGAIN

;hkn;	FATBYTE is in DATA seg (DOADATA)
	MOV	DI,OFFSET DOSDATA:FATBYTE
	XOR	AH,AH			; AL has sectors/cluster
	invoke	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_CX],CX
	MOV	[SI.user_DX],BX
	MOV	[SI.user_BX],DI

;hkn; Use SS as pointer to DOSDATA
	mov	[si.user_DS],SS
;	MOV     [SI.user_DS],CS         ; stash correct pointer

	return
BADSLDRIVE:
	transfer    FCB_Ret_ERR

EndProc $SleazeFunc

	BREAK <$Get_INDOS_Flag -- Return location of DOS critical-section flag>

;
;----------------------------------------------------------------------------
;
;**	$Get_INDOS_Flag - Return location of DOS Crit Section Flag
;
;	Returns location of DOS status for interrupt routines
;									   ;
;	ENTRY	none
;	EXIT	(es:bx) = flag location
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $GET_INDOS_FLAG,NEAR

	invoke	get_user_stack

;hkn;	INDOS is in DATA seg (DOSDATA)
	MOV     [SI.user_BX],OFFSET DOSDATA:INDOS

	MOV	[SI.user_ES],SS
	return

EndProc $GET_INDOS_FLAG


	BREAK <$Get_IN_VARS -- Return a pointer to DOS variables>

;
;----------------------------------------------------------------------------
;
;**	$Get_IN_Vars - Return Pointer to DOS Variables
;
;	Return a pointer to interesting DOS variables This call is version
;	dependent and is subject to change without notice in future versions.
;	Use at risk.
;
;	ENTRY	none
;	EXIT	(es:bx) = address of SYSINITVAR
;	uses	ALL
;
;----------------------------------------------------------------------------
;

procedure   $GET_IN_VARS,NEAR

	invoke	get_user_stack
    ASSUME DS:nothing
;hkn;	SYSINITVAR is in CONST seg (DOSDATA)
	MOV     [SI.user_BX],OFFSET DOSDATA:SYSINITVAR

	MOV	[SI.user_ES],SS
	return
EndProc $GET_IN_VARS


BREAK <$Get_Default_DPB,$Get_DPB -- Return pointer to DPB>

;
;----------------------------------------------------------------------------
;
;**	$Get_Default_DPB - Return a pointer to the Default DPB
;
;	Return pointer to drive parameter table for default drive
;
;	ENTRY	none
;	EXIT	(ds:bx) = DPB address
;	USES	all
;
;**	$Get_DPB - Return a pointer to a specified DPB
;
;	Return pointer to a specified drive parameter table
;
;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
;	EXIT	(al) = 0 iff ok
;		  (ds:bx) = DPB address
;		(al) = -1 if bad drive
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $GET_DEFAULT_DPB,NEAR

	MOV	DL,0

	entry	$GET_DPB

	context DS

	MOV	AL,DL
	invoke	GETTHISDRV		; Get CDS structure
	JC	ISNODRV 		; no valid drive
	LES	DI,[THISCDS]		; check for net CDS
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	JNZ	ISNODRV 		; No DPB to point at on NET stuff
	EnterCrit CritDisk
	invoke	FATRead_CDS		; Force Media Check and return DPB
	LeaveCrit CritDisk
	JC	ISNODRV 		; User FAILed to I 24, only error we
					;   have.
	invoke	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_BX],BP
	MOV	[SI.user_DS],ES
	XOR	AL,AL
	return

ISNODRV:
	MOV	AL,-1
	return

EndProc $GET_Default_dpb


	BREAK <$Disk_Reset -- Flush out all dirty buffers>

;
;----------------------------------------------------------------------------
;
;**	$Disk_Reset - Flush out Dirty Buffers
;
;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
;		we really invalidate?  SHould we?  THis screws non-removable
;		caching.  Maybe CHKDSK relies upon it, though....
;
;	ENTRY	none
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $DISK_RESET,NEAR

	MOV	AL,-1
;hkn; SS is DOSDATA
	context DS

	EnterCrit   critDisk
	OR	[DOS34_FLAG],FROM_DISK_RESET					;AN000;
	invoke	FLUSHBUF
	AND	[DOS34_FLAG],NO_FROM_DISK_RESET 				;AN000;

	mov	SC_STATUS, 0		; Throw out secondary cache M041

;
; We will "ignore" any errors on the flush, and go ahead and invalidate.  This
; call doesn't return any errors and it is supposed to FORCE a known state, so
; let's do it.
;
; Invalidate 'last-buffer' used
;
	MOV	BX,-1
	MOV	WORD PTR [LASTBUFFER+2],BX
	MOV	WORD PTR [LASTBUFFER],BX
	LeaveCrit   critDisk
	MOV	AX,-1
	CallInstall NetFlushBuf,multNET,32,AX,AX
	return

EndProc $DISK_RESET

	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>

;
;----------------------------------------------------------------------------
;
;**	$SetDPB - Create a DPB
;
;	SetDPB Creates a valid DPB from a user-specified BPB
;
;	ENTRY	eS:BP Points to DPB
;		DS:SI Points to BPB
;	EXIT	DPB setup
;	USES	ALL but BP, DS, ES
;
;----------------------------------------------------------------------------
;
word3	dw	3		; M008 -- word value for divides

procedure   $SETDPB,NEAR

	MOV	DI,BP
	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
	LODSW
	STOSW				; dpb_sector_size
	CMP	BYTE PTR [SI.BPB_NUMBEROFFATS-2],0     ; FAT file system drive		;AN000;
	JNZ	yesfat			      ; yes				;AN000;
	MOV	BYTE PTR ES:[DI.dpb_FAT_count-4],0
	JMP	short setend			      ; NO				;AN000;
yesfat:
	MOV	DX,AX
	LODSB
	DEC	AL
	STOSB				; dpb_cluster_mask
	INC	AL
	XOR	AH,AH
LOG2LOOP:
	test	AL,1
	JNZ	SAVLOG
	INC	AH
	SHR	AL,1
	JMP	SHORT LOG2LOOP
SAVLOG:
	MOV	AL,AH
	STOSB				; dpb_cluster_shift
	MOV	BL,AL
	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
	LODSB
	STOSB				; dpb_FAT_count Number of FATs
;	OR	AL,AL			; NONFAT ?				;AN000;
;	JZ	setend			; yes, don't do anything                ;AN000;
	MOV	BH,AL
	LODSW
	STOSW				; dpb_root_entries Number of directory entries
	MOV	CL,5
	SHR	DX,CL			; Directory entries per sector
	DEC	AX
	ADD	AX,DX			; Cause Round Up
	MOV	CX,DX
	XOR	DX,DX
	DIV	CX
	MOV	CX,AX			; Number of directory sectors
	INC	DI
	INC	DI			; Skip dpb_first_sector
	MOVSW				; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
	LODSB
	MOV	ES:[BP.dpb_media],AL	; Media byte
	LODSW				; Number of sectors in a FAT
	STOSW				;AC000;;>32mb dpb_FAT_size
	MOV	DL,BH			;AN000;;>32mb
	XOR	DH,DH			;AN000;;>32mb
	MUL	DX			;AC000;;>32mb Space occupied by all FATs
	ADD	AX,ES:[BP.dpb_first_FAT]
	STOSW				; dpb_dir_sector
	ADD	AX,CX			; Add number of directory sectors
	MOV	ES:[BP.dpb_first_sector],AX

	MOV	CL,BL		       ;F.C. >32mb				;AN000;
	CMP	WORD PTR ES:[BP.DSKSIZ],0	;F.C. >32mb			;AN000;
	JNZ	normal_dpb	       ;F.C. >32mb				;AN000;
	XOR	CH,CH		       ;F.C. >32mb				;AN000;
	MOV	BX,WORD PTR [SI+BPB_BigTotalSectors-BPB_SectorsPerTrack]	;AN000;
	MOV	DX,WORD PTR [SI+BPB_BigTotalSectors-BPB_SectorsPerTrack+2]	;AN000;
	SUB	BX,AX		       ;AN000;;F.C. >32mb
	SBB	DX,0		       ;AN000;;F.C. >32mb
	OR	CX,CX		       ;AN000;;F.C. >32mb
	JZ	norot		       ;AN000;;F.C. >32mb
rott:				       ;AN000;;F.C. >32mb
	CLC			       ;AN000;;F.C. >32mb
	RCR	DX,1		       ;AN000;;F.C. >32mb
	RCR	BX,1		       ;AN000;;F.C. >32mb
	LOOP	rott		       ;AN000;;F.C. >32mb
norot:				       ;AN000;
	MOV	AX,BX		       ;AN000;;F.C. >32mb
	JMP	short setend		;AN000;;F.C. >32mb
normal_dpb:
	SUB	AX,ES:[BP.DSKSIZ]
	NEG	AX			; Sectors in data area
;;	MOV	CL,BL			; dpb_cluster_shift
	SHR	AX,CL			; Div by sectors/cluster
setend:

;	M008 - CAS
;
	INC	AX			; +2 (reserved), -1 (count -> max)
;
;	There has been a bug in our fatsize calculation for so long
;	  that we can't correct it now without causing some user to
;	  experience data loss.  There are even cases where allowing
;	  the number of clusters to exceed the fats is the optimal
;	  case -- where adding 2 more fat sectors would make the
;	  data field smaller so that there's nothing to use the extra
;	  fat sectors for.
;
;	Note that this bug had very minor known symptoms.  CHKDSK would
;	  still report that there was a cluster left when the disk was
;	  actually full.  Very graceful failure for a corrupt system
;	  configuration.  There may be worse cases that were never
;	  properly traced back to this bug.  The problem cases only
;	  occurred when partition sizes were very near FAT sector
;	  rounding boundaries, which were rare cases.
;
;	Also, it's possible that some third-party partition program might
;	  create a partition that had a less-than-perfect FAT calculation
;	  scheme.  In this hypothetical case, the number of allocation
;	  clusters which don't actually have FAT entries to represent
;	  them might be larger and might create a more catastrophic
;	  failure.  So we'll provide the safeguard of limiting the
;	  max_cluster to the amount that will fit in the FATs.
;
;	ax = maximum legal cluster, ES:BP -> dpb

;	make sure the number of fat sectors is actually enough to
;	  hold that many clusters.  otherwise, back the number of
;	  clusters down

	mov	bx,ax			; remember calculated # clusters
	mov	ax,ES:[BP.dpb_fat_size]
	mul	ES:[BP.dpb_sector_size]	; how big is the FAT?
	cmp	bx,4096-10		; test for 12 vs. 16 bit fat
	jb	setend_fat12
	shr	dx,1
;cs3 7/2/92
	jnz	setend_faterr		; some bonehead gave us more fatspace
;					; than enough for the maximum FAT,
;					; so go ahead and use the calculated
;					; number of clusters.
;cs3 7/2/92

	rcr	ax,1			; find number of entries
	cmp	ax,4096-10+1		; would this truncation move us
;					;  into 12-bit fatland?
	jb	setend_faterr		; then go ahead and let the
;					;  inconsistency pass through
;					;  rather than lose data by
;					;  correcting the fat type
	jmp	short setend_fat16

setend_fat12:
	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
	adc	dx,dx
;cs3 7/2/92
	cmp	dx,3			; if our fatspace is WAY more than
	jnb	setend_faterr		; we need, we may get an overflow
;					; here.  Check for it and use
;					; the calcuated size in this case.
;cs3 7/2/92
	div	cs:word ptr word3

setend_fat16:
	dec	ax			; limit at 1
	cmp	ax,bx			; is fat big enough?
	jbe	setend_fat		; use max value that'll fit

setend_faterr:
	mov	ax,bx			; use calculated value

setend_fat:

;	now ax = maximum legal cluster

;	end M008

	MOV	ES:[BP.dpb_max_cluster],AX
	MOV	ES:[BP.dpb_next_free],0 ; Init so first ALLOC starts at
					; begining of FAT
	MOV	ES:[BP.dpb_free_cnt],-1 ; current count is invalid.
	return
EndProc $SETDPB

BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>

;
;----------------------------------------------------------------------------
;
;**	$Dup_PDB
;
; Inputs:   DX is new segment address of process
;	    SI is end of new allocation block
;
;----------------------------------------------------------------------------
;

procedure   $Dup_PDB,NEAR
	ASSUME	SS:NOTHING

;hkn;	CreatePDB would have a CS override. This is not valid.
;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.

	getdseg	<ds>			; ds -> dosdata

	MOV	CreatePDB,0FFH		; indicate a new process
	MOV	DS,CurrentPDB
	PUSH	SI
	JMP	SHORT	CreateCopy
EndProc $Dup_PDB

;
;----------------------------------------------------------------------------
;
; Inputs:
;	DX = Segment number of new base
; Function:
;	Set up program base and copy term and ^C from int area
; Returns:
;	None
; Called at DOS init
;
;----------------------------------------------------------------------------
;

procedure   $CREATE_PROCESS_DATA_BLOCK,NEAR
	ASSUME	SS:NOTHING

	CALL	get_user_stack
	MOV	DS,[SI.user_CS]
	PUSH	DS:[PDB_Block_len]
CreateCopy:
	MOV	ES,DX

	XOR	SI,SI			; copy entire PDB
	MOV	DI,SI
	MOV	CX,80H
	REP	MOVSW
; DOS 3.3 7/9/86


	MOV	CX,FilPerProc		; copy handles in case of
	MOV	DI,PDB_JFN_Table	; Set Handle Count has been issued
	PUSH	DS
	LDS	SI,DS:[PDB_JFN_Pointer]
	REP	MOVSB
	POP	DS

; DOS 3.3 7/9/86

		;hkn;CreatePDB would have a CS override. This is not valid.
		;hkn;Must set up ds in order to acess CreatePDB. Also SS is 
		;hkn;has been assumed to be NOTHING. It may not have DOSDATA.

	getdseg	<ds>			; ds -> dosdata

	cmp	CreatePDB,0		; Shall we create a process?
	JZ	Create_PDB_cont 	; nope, old style call
;
; Here we set up for a new process...
;

;hkn;	PUSH    CS                      ; Called at DOSINIT time, NO SS
;hkn;	POP     DS

;hkn;	must set up DS to DOSDATA

	getdseg	<ds>			; ds -> dosdata

	DOSAssume   <DS>,"Create PDB"
	XOR	BX,BX			; dup all jfns
	MOV	CX,FilPerProc		; only 20 of them

Create_dup_jfn:
	PUSH	ES			; save new PDB
	invoke	SFFromHandle		; get sf pointer
	MOV	AL,-1			; unassigned JFN
	JC	CreateStash		; file was not really open
	TESTB	ES:[DI].sf_flags,sf_no_inherit
	JNZ	CreateStash		; if no-inherit bit is set, skip dup.
;
; We do not inherit network file handles.
;
	MOV	AH,BYTE PTR ES:[DI].sf_mode
	AND	AH,sharing_mask
	CMP	AH,sharing_net_fcb
	jz	CreateStash
;
; The handle we have found is duplicatable (and inheritable).  Perform
; duplication operation.
;
	MOV	WORD PTR [THISSFT],DI
	MOV	WORD PTR [THISSFT+2],ES
	invoke	DOS_DUP 		; signal duplication
;
; get the old sfn for copy
;
	invoke	pJFNFromHandle		; ES:DI is jfn
	MOV	AL,ES:[DI]		; get sfn
;
; Take AL (old sfn or -1) and stash it into the new position
;
CreateStash:
	POP	ES
	MOV	ES:[BX].PDB_JFN_Table,AL; copy into new place!
	INC	BX			; next jfn...
	LOOP	create_dup_jfn

	MOV	BX,CurrentPDB		; get current process
	MOV	ES:[PDB_Parent_PID],BX	; stash in child
	MOV	[CurrentPDB],ES
	ASSUME	DS:NOTHING
	MOV	DS,BX
;
; end of new process create
;
Create_PDB_cont:

;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV     BYTE PTR [CreatePDB],0h ; reset flag
	pop	ds

	POP	AX

	entry	SETMEM
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
;---------------------------------------------------------------------------
; Inputs:
;	AX = Size of memory in paragraphs
;	DX = Segment
; Function:
;	Completely prepares a program base at the
;	specified segment.
; Called at DOS init
; Outputs:
;	DS = DX
;	ES = DX
;	[0] has INT int_abort
;	[2] = First unavailable segment
;	[5] to [9] form a long call to the entry point
;	[10] to [13] have exit address (from int_terminate)
;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
;	[18] to [21] have fatal error address (from int_fatal_abort)
; DX,BP unchanged. All other registers destroyed.
;---------------------------------------------------------------------------

	XOR	CX,CX
	MOV	DS,CX
	MOV	ES,DX
	MOV	SI,addr_int_terminate
	MOV	DI,SAVEXIT
	MOV	CX,6
	REP	MOVSW
	MOV	ES:[2],AX
	SUB	AX,DX
	CMP	AX,MAXDIF
	JBE	HAVDIF
	MOV	AX,MAXDIF
HAVDIF:
	SUB	AX,10H			; Allow for 100h byte "stack"
	MOV	BX,ENTRYPOINTSEG	;	in .COM files
	SUB	BX,AX
	MOV	CL,4
	SHL	AX,CL
	MOV	DS,DX

	;
	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
	; making this equvalnce valid for this particular case. If however
	; there is less than 64K remaining the address in BX:AX will not 
	; be the same as above. We will then stuff 0:c0 , the call 5 address
	; into the PSP.
	;
	; Therefore for the case where there is less than 64K remaining in 
	; the system old CPM Apps that look at PSP:6 to determine memory
	; requirements will not work. Call 5, however will continue to work
	; for all cases.
	;

	MOV	WORD PTR DS:[PDB_CPM_Call+1],AX
	MOV	WORD PTR DS:[PDB_CPM_Call+3],BX

	cmp	ax, WRAPOFFSET		; Q: does the system have >= 64k of
					;    memory left
	je	addr_ok			; Y: the above calculated address is
					;    OK
					; N: 


	MOV	WORD PTR DS:[PDB_CPM_Call+1],0c0h
	MOV	WORD PTR DS:[PDB_CPM_Call+3],0

addr_ok:

	MOV	DS:[PDB_Exit_Call],(int_abort SHL 8) + mi_INT
	MOV	BYTE PTR DS:[PDB_CPM_Call],mi_Long_CALL
	MOV	WORD PTR DS:[PDB_Call_System],(int_command SHL 8) + mi_INT
	MOV	BYTE PTR DS:[PDB_Call_System+2],mi_Long_RET
	MOV	WORD PTR DS:[PDB_JFN_Pointer],PDB_JFN_Table
	MOV	WORD PTR DS:[PDB_JFN_Pointer+2],DS
	MOV	WORD PTR DS:[PDB_JFN_Length],FilPerProc
;
; The server runs several PDB's without creating them VIA EXEC.  We need to
; enumerate all PDB's at CPS time in order to find all references to a
; particular SFT.  We perform this by requiring that the server link together
; for us all sub-PDB's that he creates.  The requirement for us, now, is to
; initialize this pointer.
;
	MOV	word ptr DS:[PDB_Next_PDB],-1
	MOV	word ptr DS:[PDB_Next_PDB+2],-1

			; Set the real version number in the PSP - 5.00
	mov	ES:[PDB_Version],(MINOR_VERSION SHL 8)+MAJOR_VERSION

	return

EndProc $CREATE_PROCESS_DATA_BLOCK


BREAK <$GSetMediaID -- get set media ID>
;---------------------------------------------------------------------------
; Inputs:
;	BL= drive number as defined in IOCTL
;	AL= 0 get media ID
;	    1 set media ID
;	DS:DX= buffer containing information
;		DW  0  info level (set on input)
;		DD  ?  serial #
;		DB  11 dup(?)  volume id
;		DB   8 dup(?)  file system type
; Function:
;	Get or set media ID
; Returns:
;	carry clear, DS:DX is filled
;	carry set, error
;---------------------------------------------------------------------------

procedure   $GSetMediaID,NEAR ;AN000;

	MOV	CX,0866H	      ;AN000;MS.; assume get  for IOCTL
	CMP	AL,0		      ;AN001;MS.; get ?
	JZ	doioctl 	      ;AN000;MS.; yes
	CMP	AL,1		      ;AN000;MS.; set ?
	JNZ	errorfunc	      ;AN000;MS.; no
	MOV	CX,0846H	      ;AN001;MS.;
doioctl:			      ;AN000;
	MOV	AL,0DH		      ;AN000;MS.; generic IOCTL
	invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
	return			      ;AN000;MS.;
errorfunc:			      ;AN000;
	error	error_invalid_function;AN000;MS.	; invalid function
EndProc $GSetMediaID		      ;AN000;

DOSCODE	ENDS
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\macro2.asm ===
TITLE   MACRO2 - Pathname and macro related internal routines
	NAME    MACRO2

;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;

;**     MACRO2.ASM
;
;       TransFCB
;       TransPath
;       TransPathSet
;       TransPathNoSet
;       Canonicalize
;       PathSep
;       SkipBack
;       CopyComponent
;       Splice
;       $NameTrans
;       DriveFromText
;       TextFromDrive
;       PathPref
;       ScanPathChar
;
;   Revision history:
;
;       Created: MZ 4 April 1983
;                MZ 18 April 1983   Make TransFCB handle extended FCBs
;                AR 2 June 1983     Define/Delete macro for NET redir.
;                MZ 3 Nov 83        Fix InitCDS to reset length to 2
;                MZ 4 Nov 83        Fix NetAssign to use STRLEN only
;                MZ 18 Nov 83       Rewrite string processing for subtree
;                                   aliasing.
;                BAS 3 Jan 85       ScanPathChar to search for path separator
;                                   in null terminated string.
;
;   MSDOS performs several types of name translation.  First, we maintain for
;   each valid drive letter the text of the current directory on that drive.
;   For invalid drive letters, there is no current directory so we pretend to
;   be at the root.  A current directory is either the raw local directory
;   (consisting of drive:\path) or a local network directory (consisting of
;   \\machine\path.  There is a limit on the point to which a ..  is allowed.
;
;   Given a path, MSDOS will transform this into a real from-the-root path
;   without .  or ..  entries.  Any component that is > 8.3 is truncated to
;   this and all * are expanded into ?'s.
;
;   The second part of name translation involves subtree aliasing.  A list of
;   subtree pairs is maintained by the external utility SUBST.  The results of
;   the previous 'canonicalization' are then examined to see if any of the
;   subtree pairs is a prefix of the user path.  If so, then this prefix is
;   replaced with the other subtree in the pair.
;
;   A third part involves mapping this "real" path into a "physical" path.  A
;   list of drive/subtree pairs are maintained by the external utility JOIN.
;   The output of the previous translation is examined to see if any of the
;   subtrees in this list are a prefix of the string.  If so, then the prefix
;   is replaced by the appropriate drive letter.  In this manner, we can
;   'mount' one device under another.
;
;   The final form of name translation involves the mapping of a user's
;   logical drive number into the internal physical drive.  This is
;   accomplished by converting the drive number into letter:CON, performing
;   the above translation and then converting the character back into a drive
;   number.
;
;       M015 - allocate even number of bytes on stack in TransFCB
;       M027 - set up Sattrib in $Nametrans


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include curdir.inc
	.cref
	.list

Installed = TRUE

	I_need  Splices,BYTE            ; TRUE => splices are being done.
	I_need  WFP_Start,WORD          ; pointer to beginning of expansion
	I_need  Curr_Dir_End,WORD       ; offset to end of current dir
	I_need  ThisCDS,DWORD           ; pointer to CDS used
	I_need  ThisDPB,DWORD           ; pointer to DPB used
	I_need  NAME1,11                ; Parse output of NameTrans
	I_need  OpenBuf,128             ; ususal destination of strings
	I_need  ExtFCB,BYTE             ; flag for extended FCBs
	I_need  Sattrib,BYTE            ; attribute of search
	I_need  fSplice,BYTE            ; TRUE => do splice after canonicalize
	I_need  fSharing,BYTE           ; TRUE => no redirection allowed
	I_Need  NoSetDir,BYTE           ; TRUE => syscall is interested in
					; entry, not contents.  We splice only
					; inexact matches
	I_Need  cMeta,BYTE              ; count of meta chars in path
	I_Need  Temp_Var,WORD           ;AN000; variable for temporary use 3/31/KK
	I_Need  DOS34_FLAG,WORD         ;AN000; variable for dos34

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

ifdef DBCS
	EXTRN   TestKanj:near
endif
	EXTRN   PathChrCmp:near

BREAK <TransFCB - convert an FCB into a path, doing substitution>

;
;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
;       gritty substitution.
;
;   Inputs:     DS:DX - pointer to FCB
;               ES:DI - point to destination
;   Outputs:    Carry Set - invalid path in final map
;               Carry Clear - FCB has been mapped into ES:DI
;                   Sattrib is set from possibly extended FCB
;                   ExtFCB set if extended FCB found
;   Registers modified: most

Procedure   TransFCB,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA

PUBLIC MACRO001S,MACRO001E
MACRO001S:
	LocalVar    FCBTmp,16           ; M015 - allocate even number of bytes on stack
MACRO001E:
	Enter
	Context ES                      ; get DOSDATA addressability
	SAVE    <ES,DI>                 ; save away final destination
	LEA     DI,FCBTmp               ; point to FCB temp area
	MOV     [ExtFCB],0              ; no extended FCB found ;smr;SS Override
	MOV     [Sattrib],0             ; default search attributes;smr;SS Override
	invoke  GetExtended             ; get FCB, extended or not
	JZ      GetDrive                ; not an extended FCB, get drive
	MOV     AL,[SI-1]               ; get attributes
	MOV     [SAttrib],AL            ; store search attributes;smr;SS Override
	MOV     [ExtFCB],-1             ; signal extended FCB   ;smr;SS Override
GetDrive:
	LODSB                           ; get drive byte
	invoke  GetThisDrv
	jc      BadPack
	CALL    TextFromDrive           ; convert 0-based drive to text
;
; Scan the source to see if there are any illegal chars
;
 IFDEF  DBCS                            ;
;----------------------------- Start of DBCS 2/13/KK
	SAVE    <SI>                    ; back over name, ext
	MOV     CX,8                    ; 8 chars in main part of name
FCBScan:LODSB                           ; get a byte
	call    TestKanj                ;
	jz      notkanj2                ;
	DEC     CX                      ;
	JCXZ    VolidChck               ; Kanji half char screw up
	LODSB                           ; second kanji byte
	jmp     short Nextch
VolidChck:
	TEST    [SAttrib],attr_volume_id ; volume id ?   ;smr;SS Override
	JZ      Badpack                  ; no, error
	OR      [DOS34_FLAG],DBCS_VOLID  ; no, error     ;smr;SS Override
	DEC     CX                       ; cx=-1
	INC     SI                       ; next char
	JMP     SHORT FCBScango
notkanj2:
	invoke  GetCharType              ;get bits;smr;
	TEST    AL,fFCB
	JZ      BadPack
NextCh:
	LOOP    FCBScan
FCBScango:
	ADD     CX,3                    ; Three chars in extension
FCBScanE:
	LODSB
	call    TestKanj
	jz      notkanj3
	DEC     CX
	JCXZ    BadPack                 ; Kanji half char problem
	LODSB                           ; second kanji byte
	jmp     short NextChE
notkanj3:
	invoke  GetCharType              ;get bits;smr;
	TEST    AL,fFCB
	JZ      BadPack
NextChE:
	LOOP    FCBScanE
;----------------------------- End of DBCS 2/13/KK
 ELSE

	MOV     CX,11
	SAVE    <SI>                    ; back over name, ext
FCBScan:LODSB                           ; get a byte
	invoke  GetCharType              ;get bits;smr;
	TEST    AL,fFCB
	JZ      BadPack
NextCh: LOOP    FCBScan
 ENDIF
	RESTORE <SI>
	MOV     BX,DI
	invoke  PackName                ; crunch the path
	RESTORE <DI,ES>         ; get original destination
	Context DS                      ; get DS addressability
	LEA     SI,FCBTmp               ; point at new pathname
	CMP     BYTE PTR [BX],0
	JZ      BadPack
	SAVE    <BP>
	CALL    TransPathSet            ; convert the path
	RESTORE <BP>
	JNC     FCBRet                  ; bye with transPath error code
BadPack:
	STC
	MOV     AL,error_path_not_found
FCBRet: Leave
	return
EndProc TransFCB,NoCheck

BREAK <TransPath - copy a path, do string sub and put in current dir>

;
;   TransPath - copy a path from DS:SI to ES:DI, performing component string
;       substitution, insertion of current directory and fixing .  and ..
;       entries.  Perform splicing.  Allow input string to match splice
;       exactly.
;
;   TransPathSet - Same as above except No splicing is performed if input path
;       matches splice.
;
;   TransPathNoSet - No splicing/local using is performed at all.
;
;   The following anomalous behaviour is required:
;
;       Drive letters on devices are ignored.  (set up DummyCDS)
;       Paths on devices are ignored. (truncate to 0-length)
;       Raw net I/O sets ThisCDS => NULL.
;       fSharing => dummyCDS and no subst/splice.  Only canonicalize.
;
;   Other behaviour:
;
;       ThisCDS set up.
;       FatRead done on local CDS.
;       ValidateCDS done on local CDS.
;
;   Brief flowchart:
;
;       if fSharing then
;           set up DummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           splice
;           fatRead
;           return
;       if \\ or d:\\ lead then
;           set up null CDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if device then
;           set up dummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if file then
;           getCDS (sets (ThisCDS) from name)
;           validateCDS (may reset current dir)
;           Copy current dir
;           canonicalize (set cMeta)
;           splice
;           generate correct CDS (ThisCDS)
;           if local then
;               fatread
;           return
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               DI - point to buffer in DOSDATA
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc. or user FAILed to I 24.
;               WFP_Start - points to beginning of buffer
;               Curr_Dir_End - points to end of current dir in path
;               DS - DOSDATA
;   Registers modified: most

Procedure   TransPath,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
	XOR     AL,AL
	JMP     SHORT SetSplice
	Entry   TransPathSet
	MOV     AL,-1
SetSplice:
	MOV     NoSetDir,AL             ;   NoSetDir = !fExact; ;smr;SS Override
	MOV     AL,-1
	Entry   TransPathNoSet

	MOV     fSplice,AL              ;   fSplice = TRUE;     ;smr;SS Override
	MOV     cMeta,-1                                        ;smr;SS Override
	MOV     WFP_Start,DI                                    ;smr;SS Override
	MOV     Curr_Dir_End,-1         ; crack from start      ;smr;SS Override
	Context ES
	LEA     BP,[DI+TEMPLEN]         ; end of buffer
;
; if this is through the server dos call, fsharing is set.  We set up a
; dummy cds and let the operation go.
;
	TEST    fSharing,-1             ; if no sharing         ;smr;SS Override
	JZ      CheckUNC                ; skip to UNC check
;
; ES:DI point to buffer
;
	CALL    DriveFromText           ; get drive and advance DS:SI
	invoke  GetThisDrv              ; Set ThisCDS and convert to 0-based
	jc      NoPath
	CALL    TextFromDrive           ; drop in new
	LEA     BX,[DI+1]               ; backup limit
	CALL    Canonicalize            ; copy and canonicalize
	retc                            ; errors
;
; Perform splices for net guys.
;
	Context DS
	MOV     SI,wfp_Start            ; point to name
	TEST    fSplice,-1
	JZ      NoServerSplice
	CALL    Splice
NoServerSplice:
	Context DS                      ; for FATREAD
	LES     DI,ThisCDS              ; for fatread
	EnterCrit   critDisk
	Invoke  FatRead_CDS
	LeaveCrit   critDisk
NoPath:
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	return                          ; any errors are in Carry flag
	ASSUME  DS:NOTHING
;
; Let the network decide if the name is for a spooled device.  It will map
; the name if so.
;
CheckUnc:
	MOV     WORD PTR ThisCDS,-1     ; NULL thisCDS          ;smr;SS Override
	CallInstall NetSpoolCheck,multNet,35
	JNC     UNCDone
;
; At this point the name is either a UNC-style name (prefixed with two leading
; \\s) or is a local file/device.  Remember that if a net-spooled device was
; input, then the name has been changed to the remote spooler by the above net
; call.  Also, there may be a drive in front of the \\.
;
NO_CHECK:
	CALL    DriveFromText           ; eat drive letter
	PUSH    AX                      ; save it
	MOV     AX,WORD PTR [SI]        ; get first two bytes of path
	call    PathChrCmp              ; convert to normal form
	XCHG    AH,AL                   ; swap for second byte
	call    PathChrCmp              ; convert to normal form
	JNZ     CheckDevice             ; not a path char
	CMP     AH,AL                   ; are they same?
	JNZ     CheckDevice             ; nope
;
; We have a UNC request.  We must copy the string up to the beginning of the
; local machine root path
;

	POP     AX
	MOVSW                           ; get the lead \\
UNCCpy: LODSB                           ; get a byte
 IFDEF  DBCS                            ;AN000;
;----------------------------- Start of DBCS 2/23/KK
	call    TestKanj                ;AN000;
	jz      notkanj1                ;AN000;
	STOSB                           ;AN000;
	LODSB                           ;AN000;
	OR      AL,AL                   ;AN000;
	JZ      UNCTerm                 ;AN000;; Ignore half kanji error for now
	STOSB                           ;AN000;
	jmp     UNCCpy                  ;AN000;
notkanj1:                               ;AN000;
;----------------------------- End of DBCS 2/23/KK
 ENDIF                                  ;AN000;
	invoke  UCase                   ;AN000;; convert the char
	OR      AL,AL
	JZ      UNCTerm                 ; end of string.  All done.
	call    PathChrCmp              ; is it a path char?
	MOV     BX,DI                   ; backup position
	STOSB
	JNZ     UNCCpy                  ; no, go copy
	CALL    Canonicalize            ; wham (and set cMeta)
UNCDone:
	Context DS
 IFDEF  DBCS
;----------------------------- Start of DBCS 2/23/KK
	retc                            ;AN000; Return if error from Canonicalize

; Although Cononicalize has done lots of good things for us it may also have
; done e5 to 05 conversion on the fisrt char following a path sep char which is
; not wanted on a UNC request as this should be left for the remote station.
; The simplest thing to do is check for such conversions and convert them back
; again.
; This check loop is also called from the DoFile section of TransPath if the
; file is a remote file. Entry point when called is TP_check05 with the
; inputs/outputs as follows;
;       Inputs : ES:DI = Buffer to check for re-conversion
;       Outputs: None
;       Used   : DI,AX


	MOV     DI,WFP_start            ;AN000;; ES:DI points to converted string;smr;SS Override
TP_check05:                             ;AN000;
	MOV     AL,BYTE PTR ES:[DI]     ;AN000;; Get character from path
	OR      AL,AL                   ;AN000;; End of null terminated path?
	JZ      TP_end05                ;AN000;; Finished, CF =0 from OR (ret success)
	call    TestKanj                ;AN000;; Kanji lead character?
	JZ      TP_notK                 ;AN000;; Check for path seperator if not
	INC     DI                      ;AN000;; Bypass Kanji second byte
	JMP     TP_nxt05                ;AN000;; Go to check next character
TP_notK:                                ;AN000;
	call    PathChrCmp              ;AN000;; Is it a path seperator char?
	JNZ     TP_nxt05                ;AN000;; Check next character if not
	CMP     BYTE PTR ES:[DI+1],05   ;AN000;; 05 following path sep char?
	JNZ     TP_nxt05                ;AN000;; Check next character if not
	MOV     BYTE PTR ES:[DI+1],0E5h ;AN000;; Convert 05 back to E5
TP_nxt05:                               ;AN000;
	INC     DI                      ;AN000;; Point to next char in path
	JMP     TP_check05              ;AN000;; Test all chars in path
TP_end05:
;----------------------------- End of DBCS 2/23/KK
 ENDIF                                  ;AN000;
	return                          ; return error code

	ASSUME  DS:NOTHING
UNCTerm:
	STOSB                           ;AN000;
	JMP     UNCDone                 ;AN000;

CheckDevice:
;
; Check DS:SI for device.  First eat any path stuff
;
	POP     AX                      ; retrieve drive info
	CMP     BYTE PTR DS:[SI],0      ; check for null file
	JNZ     CheckPath
	MOV     AL,error_file_not_found ; bad file error
	STC                             ; signal error on null input
	RETURN                          ; bye!
CheckPath:
	SAVE    <AX,BP>                 ; save drive number

;;;BUGBUG BUG 10-26-1992 scottq
;;;This is a hack for the CDROM extensions (2.1) who scan looking
;;;for the following POP BP == 5Dh (restore <bp,ax>).
;;;The problem is that a direct call to CheckThisDevice can (and did)
;;;end up having a 5D in the opcode's displacement field.  The
;;;scanning code would choke on this thinking it was a POP BP instruction.
;;;
;;;What we do here is do a call to a function that is less than 5Dh
;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
;;;to the correct function.  This cannot accidently insert a 5Dh.
;;;
;;;More info:
;;;  This particular scan is begun at the UNCdone label for 32 bytes
;;;looking for pop BP, so you cannot put a 5D between here and there.
;;;
	call    no5Dshere
start5Dhack:
;following is replaced with 5Dhack code--Invoke  CheckThisDevice         
backfrom5Dhack:
	RESTORE <BP,AX>         ; get drive letter back
	JNC     DoFile                  ; yes we have a file.
;
; We have a device.  AX has drive letter.  At this point we may fake a CDS ala
; sharing DOS call.  We know by getting here that we are NOT in a sharing DOS
; call.
;
	MOV     fSharing,-1             ; simulate sharing dos call;smr;SS Override
	invoke  GetThisDrv              ; set ThisCDS and init DUMMYCDS
	MOV     fSharing,0              ;                       ;smr;SS Override
;
; Now that we have noted that we have a device, we put it into a form that
; getpath can understand.  Normally getpath requires d:\ to begin the input
; string.  We relax this to state that if the d:\ is present then the path
; may be a file.  If D:/ (note the forward slash) is present then we have
; a device.
;
	CALL    TextFromDrive
	MOV     AL,'/'                  ; path sep.
	STOSB
	invoke  StrCpy                  ; move remainder of string
	CLC                             ; everything OK.
	Context DS                      ; remainder of OK stuff
	return
no5Dshere:
	Transfer  CheckThisDevice         ; snoop for device
.erre (no5Dshere - start5Dhack - 5D)


;
; We have a file.  Get the raw CDS.
;
DoFile:
	ASSUME  DS:NOTHING
	invoke  GetVisDrv               ; get proper CDS
	MOV     AL,error_path_not_found ; Set up for possible bad file error
	retc                            ; CARRY set -> bogus drive/spliced
;
; ThisCDS has correct CDS.  DS:SI advanced to point to beginning of path/file.
; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
; Use the one that we are going to use (ES:DI).
;
	SAVE    <DS,SI,ES,DI>           ; save all string pointers.
	invoke  ValidateCDS             ; poke CDS amd make everything OK
	RESTORE <DI,ES,SI,DS>   ; get back pointers
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	retc                            ; someone failed an operation
;
; ThisCDS points to correct CDS.  It contains the correct text of the
; current directory.  Copy it in.
;
	SAVE    <DS,SI>
	LDS     SI,ThisCDS              ; point to CDS          ;smr;SS Override
	MOV     BX,DI                   ; point to destination
	ADD     BX,[SI].curdir_end      ; point to backup limit
;       LEA     SI,[SI].curdir_text     ; point to text
	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 IFDEF  DBCS                            ;AN000;
;------------------------ Start of DBCS 2/13/KK
Kcpylp:                                 ;AN000;
	LODSB                           ;AN000;
	call    TestKanj                ;AN000;
	jz      Notkanjf                ;AN000;
	STOSB                           ;AN000;
	MOVSB                           ;AN000;
	CMP     BYTE PTR [SI],0         ;AN000;
	JNZ     Kcpylp                  ;AN000;
	MOV     AL, '\'                 ;AN000;
	STOSB                           ;AN000;
	JMP     SHORT GetOrig           ;AN000;
Notkanjf:                               ;AN000;
	STOSB                           ;AN000;
	OR      AL,AL                   ;AN000;
	JNZ     Kcpylp                  ;AN000;
	DEC     DI                      ;AN000;; point to NUL byte

;------------------------ End of DBCS 2/13/KK
 ELSE                                   ;AN000;
	invoke  FStrCpy                 ; copy string.  ES:DI point to end
	DEC     DI                      ; point to NUL byte
 ENDIF                                  ;AN000;
;
; Make sure that there is a path char at end.
;
	MOV     AL,'\'
	CMP     ES:[DI-1],AL
	JZ      GetOrig
	STOSB
;
; Now get original string.
;
GetOrig:
	DEC     DI                      ; point to path char
	RESTORE <SI,DS>
;
; BX points to the end of the root part of the CDS (at where a path char
; should be) .  Now, we decide whether we use this root or extend it with the
; current directory.  See if the input string begins with a leading \
;
	CALL    PathSep                 ; is DS:SI a path sep?
	JNZ     PathAssure              ; no, DI is correct. Assure a path char
	OR      AL,AL                   ; end of string?
	JZ      DoCanon                 ; yes, skip.
;
; The string does begin with a \.  Reset the beginning of the canonicalization
; to this root.  Make sure that there is a path char there and advance the
; source string over all leading \'s.
;
	MOV     DI,BX                   ; back up to root point.
SkipPath:
	LODSB
	call    PathChrCmp
	JZ      SkipPath
	DEC     SI
	OR      AL,AL
	JZ      DoCanon
;
; DS:SI start at some file name.  ES:DI points at some path char.  Drop one in
; for yucks.
;
PathAssure:
	MOV     AL,'\'
	STOSB
;
; ES:DI point to the correct spot for canonicalization to begin.
; BP is the max extent to advance DI
; BX is the backup limit for ..
;
DoCanon:
	CALL    Canonicalize            ; wham.
	retc                            ; badly formatted path.
 IFDEF  DBCS                            ;AN000;
;--------------------- Start of DBCS 2/13/KK
; Although Cononicalize has done lots of good things for us it may also have
; done e5 to 05 conversion on the fisrt char following a path sep char which is
; not wanted if this a remote file as this should be left for the remote
; station. Check for a leading \\ in the path buffer and call TP_check05 to
; reconvert if found.

	MOV     DI,WFP_start            ;AN000;; ES:DI points to string;smr;SS Override
	MOV     AX,WORD PTR ES:[DI]     ;AN000;; Get leading 2 chars from path buffer
	call    PathChrCmp              ;AN000;; First char a path char?
	JNZ     TP_notremote            ;AN000;; Not remote if not.
	xchg    al,ah
	call    PathChrCmp              ;AN000;; Second char a path char?
	JNZ     TP_notremote            ;AN000;; Not remote if not
	CALL    TP_check05              ;AN000;; Remote so convert 05 back to e5
TP_notremote:                           ;AN000;
;--------------------- End of DBCS 2/13/KK
 ENDIF
;
; The string has been moved to ES:DI.  Reset world to DOS context, pointers
; to wfp_start and do string substitution.  BP is still the max position in
; buffer.
;
	Context DS
	MOV     DI,wfp_start            ; DS:SI point to string
	LDS     SI,ThisCDS              ; point to CDS
	ASSUME  DS:NOTHING
;       LEA     SI,[SI].curdir_text     ; point to text
	CALL    PathPref                ; is there a prefix?
	JNZ     DoSplice                ; no, do splice
;
; We have a match. Check to see if we ended in a path char.
;
 IFDEF  DBCS                            ;AN000;
;---------------------------- Start of DBCS 2/13/KK
	PUSH    BX                      ;AN000;
	MOV     BX,SI                   ;AN000;
	MOV     SI,WORD PTR ThisCDS     ;AN000;; point to CDS   ;smr;SS Override
LOOKDUAL:                               ;AN000;
	MOV     AL,BYTE PTR [SI]        ;AN000;
	call    TestKanj                ;AN000;
	JZ      ONEINC                  ;AN000;
	INC     SI                      ;AN000;
	INC     SI                      ;AN000;
	CMP     SI,BX                   ;AN000;
	JB      LOOKDUAL                ;AN000;
	POP     BX                      ;AN000;; Last char was KANJI, don't look back
	JMP     SHORT Pathline          ;AN000;;  for path sep, there isn't one.
					;AN000;
ONEINC:                                 ;AN000;
	INC     SI                      ;AN000;
	CMP     SI,BX                   ;AN000;
	JB      LOOKDUAL                ;AN000;
	POP     BX                      ;AN000;
;------------------------ End of DBCS 2/13/KK
 ENDIF                                  ;AN000;
	MOV     AL,DS:[SI-1]            ; last char to match
	call    PathChrCmp              ; did we end on a path char? (root)
	JZ      DoSplice                ; yes, no current dir here.
Pathline:                               ; 2/13/KK
	CMP     BYTE PTR ES:[DI],0      ; end at NUL?
	JZ      DoSplice
	INC     DI                      ; point to after current path char
	MOV     Curr_Dir_End,DI         ; point to correct spot ;smr;SS Override
;
; Splice the result.
;
DoSplice:
	Context DS                      ; back to DOSDATA
	MOV     SI,wfp_Start            ; point to beginning of string
	XOR     CX,CX
	TEST    fSplice,-1
	JZ      SkipSplice
	CALL    Splice                  ; replaces in place.
SkipSplice:
	ASSUME  DS:NOTHING
;
; The final thing is to assure ourselves that a FATREAD is done on the local
; device.
;
	Context DS
	LES     DI,ThisCDS              ; point to correct drive
	TEST    ES:[DI].curdir_flags,curdir_isnet
	JNZ     Done                    ; net, no fatread necessary (retnz)
	JCXZ    Done
	EnterCrit   critDisk
	invoke  FatRead_CDS
	LeaveCrit   critDisk
	MOV     AL,error_path_not_found ; Set up for possible bad path error
Done:   return                          ; any errors in carry flag.
EndProc TransPath

BREAK <Canonicalize - copy a path and remove . and .. entries>

;
;   Canonicalize - copy path removing . and .. entries.
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               ES:DI - point to buffer
;               BX - backup limit (offset from ES) points to slash
;               BP - end of buffer
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc.
;               Carry Clear -
;                   DS:DI - advanced to end of string
;                   ES:DI - advanced to end of canonicalized form after nul
;   Registers modified: AX CX DX (in addition to those above)

Procedure Canonicalize,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
;
; We copy all leading path separators.
;
	LODSB                           ;   while (PathChr (*s))
	call    PathChrCmp
 IFDEF  DBCS
	JNZ     CanonDec0               ; 2/19/KK
 ELSE
	JNZ     CanonDec
 ENDIF
	CMP     DI,BP                   ;       if (d > dlim)
	JAE     CanonBad                ;           goto error;
	STOSB
	JMP     Canonicalize            ;           *d++ = *s++;
 IFDEF  DBCS                            ;AN000;
CanonDec0:                              ;AN000; 2/19/KK
;       mov     cs:Temp_Var,di          ;AN000; 3/31/KK
 ENDIF                                  ;AN000;
CanonDec:
	DEC     SI
;
; Main canonicalization loop.  We come here with DS:SI pointing to a textual
; component (no leading path separators) and ES:DI being the destination
; buffer.
;
CanonLoop:
;
; If we are at the end of the source string, then we need to check to see that
; a potential drive specifier is correctly terminated with a path sep char.
; Otherwise, do nothing
;
	XOR     AX,AX
	CMP     [SI],AL                 ;       if (*s == 0) {
	JNZ     DoComponent
 IFDEF  DBCS                            ;AN000;
	call    chk_last_colon          ;AN000; 2/18/KK
 ELSE                                   ;AN000;
	CMP     BYTE PTR ES:[DI-1],':'  ;           if (d[-1] == ':')
 ENDIF                                  ;AN000;
	JNZ     DoTerminate
	MOV     AL,'\'                  ;               *d++ = '\';
	STOSB
	MOV     AL,AH
DoTerminate:
	STOSB                           ;           *d++ = 0;
	CLC                             ;           return (0);
	return
 IFDEF  DBCS                            ;AN000;
;---------------- Start of DBCS 2/18/KK
chk_last_colon  proc                    ;AN000;
	push    si                      ;AN000;
	push    ax                      ;AN000;
	push    bx                      ;AN000;
	mov     si,[WFP_START]          ;AN000;;PTM. for cd ..  use beginning of buf;smr;SS Override
	cmp     si,di                   ;AN000;; no data stored ?
	jb      CLC02                   ;AN000;;PTM. for cd ..
	inc     si                      ;AN000;; make NZ flag
	JMP     SHORT CLC09             ;AN000;
CLC02:                                  ;AN000;
	mov     bx,di                   ;AN000;
	dec     bx                      ;AN000;
CLC_lop:                                ;AN000;
	cmp     si,bx                   ;AN000;
	jb      CLC00                   ;AN000;
	jne     CLC09                   ;AN000;
CLC01:                                  ;AN000;
	CMP     BYTE PTR ES:[DI-1],':'  ;AN000;;           if (d[-1] == ':')
	jmp     CLC09                   ;AN000;
CLC00:                                  ;AN000;
	mov     al,es:[si]              ;AN000;
	inc     si                      ;AN000;
	call    TestKanj                ;AN000;
	je      CLC_lop                 ;AN000;
	inc     si                      ;AN000;
	jmp     CLC_lop                 ;AN000;
CLC09:                                  ;AN000;
	pop     bx                      ;AN000;
	pop     ax                      ;AN000;
	pop     si                      ;AN000;
	ret                             ;AN000;
chk_last_colon  endp                    ;AN000;
;---------------- Endt of DBCS 2/18/KK
 ENDIF                                  ;AN000;

CanonBad:
	CALL    ScanPathChar            ; check for path chars in rest of string
	MOV     AL,error_path_not_found ; Set up for bad path error
	JZ      PathEnc                 ; path character encountered in string
	MOV     AL,error_file_not_found ; Set bad file error
PathEnc:
	STC
	return
;
; We have a textual component that we must copy.  We uppercase it and truncate
; it to 8.3
;
DoComponent:                            ;           }
	CALL    CopyComponent           ;       if (!CopyComponent (s, d))
	retc                            ;           return (-1);
;
; We special case the . and .. cases.  These will be backed up.
;
	CMP     WORD PTR ES:[DI],'.' + (0 SHL 8)
	JZ      Skip1
	CMP     WORD PTR ES:[DI],'..'
	JNZ     CanonNormal
	DEC     DI                      ;           d--;
Skip1:  CALL    SkipBack                ;           SkipBack ();
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	retc
	JMP     short CanonPath         ;           }
;
; We have a normal path.  Advance destination pointer over it.
;
CanonNormal:                            ;       else
	ADD     DI,CX                   ;           d += ct;
;
; We have successfully copied a component.  We are now pointing at a path
; sep char or are pointing at a nul or are pointing at something else.
; If we point at something else, then we have an error.
;
CanonPath:
	CALL    PathSep
	JNZ     CanonBad                ; something else...
;
; Copy the first path char we see.
;
	LODSB                           ; get the char
	call    PathChrCmp              ; is it path char?
	JNZ     CanonDec                ; no, go test for nul
	CMP     DI,BP                   ; beyond buffer end?
	JAE     CanonBad                ; yep, error.
	STOSB                           ; copy the one byte
;
; Skip all remaining path chars
;
CanonPathLoop:
	LODSB                           ; get next byte
	call    PathChrCmp              ; path char again?
	JZ      CanonPathLoop           ; yep, grab another
	DEC     SI                      ; back up
	JMP     CanonLoop               ; go copy component
EndProc Canonicalize

BREAK <PathSep - determine if char is a path separator>

;
;   PathSep - look at DS:SI and see if char is / \ or NUL
;   Inputs:     DS:SI - point to a char
;   Outputs:    AL has char from DS:SI (/ => \)
;               Zero set if AL is / \ or NUL
;               Zero reset otherwise
;   Registers modified: AL

Procedure   PathSep,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
	MOV     AL,[SI]                 ; get the character
	entry   PathSepGotCh            ; already have character
	OR      AL,AL                   ; test for zero
	retz                            ; return if equal to zero (NUL)
	call    PathChrCmp              ; check for path character
	return                          ; and return HIS determination
EndProc PathSep

BREAK <SkipBack - move backwards to a path separator>

;
;   SkipBack - look at ES:DI and backup until it points to a / \
;   Inputs:     ES:DI - point to a char
;               BX has current directory back up limit (point to a / \)
;   Outputs:    ES:DI backed up to point to a path char
;               AL has char from output ES:DI (path sep if carry clear)
;               Carry set if illegal backup
;               Carry Clear if ok
;   Registers modified: DI,AL

Procedure   SkipBack,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
 IFDEF  DBCS                   ;AN000;
;-------------------------- Start of DBCS 2/13/KK
	PUSH    DS              ;AN000;
	PUSH    SI              ;AN000;
	PUSH    CX              ;AN000;
	PUSH    ES              ;AN000;
	POP     DS              ;AN000;
	MOV     SI,BX           ;AN000;; DS:SI -> start of ES:DI string
	MOV     CX,DI           ;AN000;; Limit of forward scan is input DI
	MOV     AL,[SI]         ;AN000;
	call    PathChrCmp      ;AN000;
	JNZ     SkipBadP        ;AN000;; Backup limit MUST be path char
	CMP     DI,BX           ;AN000;
	JBE     SkipBadP        ;AN000;
	MOV     DI,BX           ;AN000;; Init backup point to backup limit
Skiplp:                         ;AN000;
	CMP     SI,CX           ;AN000;
	JAE     SkipOK          ;AN000;; Done, DI is correct backup point
	LODSB                   ;AN000;
	call    TestKanj        ;AN000;
	jz      Notkanjv        ;AN000;
	lodsb                   ;AN000;; Skip over second kanji byte
	JMP     Skiplp          ;AN000;
NotKanjv:                       ;AN000;
	call    PathChrCmp      ;AN000;
	JNZ     Skiplp          ;AN000;; New backup point
	MOV     DI,SI           ;AN000;; DI point to path sep
	DEC     DI              ;AN000;
	jmp     Skiplp          ;AN000;
SkipOK:                         ;AN000;
	MOV     AL,ES:[DI]      ;AN000;; Set output AL
	CLC                     ;AN000;; return (0);
	POP     CX              ;AN000;
	POP     SI              ;AN000;
	POP     DS              ;AN000;
	return                  ;AN000;
				;AN000;
SkipBadP:                       ;AN000;
	POP     CX              ;AN000;
	POP     SI              ;AN000;
	POP     DS              ;AN000;
;-------------------------- End of DBCS 2/13/KK
 ELSE                           ;AN000;
	CMP     DI,BX                   ;   while (TRUE) {
	JB      SkipBad                 ;       if (d < dlim)
	DEC     DI                      ;           goto err;
	MOV     AL,ES:[DI]              ;       if (pathchr (*--d))
	call    PathChrCmp              ;           break;
	JNZ     SkipBack                ;       }
	CLC                             ;   return (0);
	return                          ;
 ENDIF                                  ;AN000;
SkipBad:                                ;err:
	MOV     AL,error_path_not_found ; bad path error
	STC                             ;   return (-1);
	return                          ;
EndProc SkipBack

Break <CopyComponent - copy out a file path component>

;
;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
;
;   Inputs:     DS:SI - source path
;               ES:DI - destination
;               ES:BP - end of buffer
;   Outputs:    Carry Set - too long
;               Carry Clear - DS:SI moved past component
;                   CX has length of destination
;   Registers modified: AX,CX,DX

Procedure   CopyComponent,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
CopyBP      EQU     WORD PTR [BP]
CopyD       EQU     DWORD PTR [BP+2]
CopyDoff    EQU     WORD PTR [BP+2]
CopyS       EQU     DWORD PTR [BP+6]
CopySoff    EQU     WORD PTR [BP+6]
CopyTemp    EQU     BYTE PTR [BP+10]
	SUB     SP,14                   ; room for temp buffer
	SAVE    <DS,SI,ES,DI,BP>
	MOV     BP,SP
	MOV     AH,'.'
	LODSB
	STOSB
	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
	JNZ     NormalComp
	CALL    PathSep                 ;       if (!pathsep(*s))
	JZ      NulTerm
TryTwoDot:
	LODSB                           ;           if ((*d++=*s++) != '.'
	STOSB
	CMP     AL,AH
	JNZ     CopyBad
	CALL    PathSep
	JNZ     CopyBad                 ;               || !pathsep (*s))
NulTerm:                                ;               return -1;
	XOR     AL,AL                   ;       *d++ = 0;
	STOSB
	MOV     CopySoff,SI
	JMP     SHORT GoodRet           ;       }
NormalComp:                             ;   else {
	MOV     SI,CopySoff
	Invoke  NameTrans               ;       s = NameTrans (s, Name1);
	CMP     SI,CopySOff             ;       if (s == CopySOff)
	JZ      CopyBad                 ;           return (-1);
	TEST    fSharing,-1             ;       if (!fSharing) {;smr;SS Override
	JNZ     DoPack
	AND     DL,1                    ;           cMeta += fMeta;
	ADD     cMeta,DL                ;           if (cMeta > 0);smr;SS Override
	JG      CopyBad                 ;               return (-1);
	JNZ     DoPack                  ;           else
	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
	JZ      CopyBadPath             ;               return (-1);
DoPack:                                 ;           }
	MOV     CopySoff,SI
	Context DS
	MOV     SI,OFFSET DOSDATA:NAME1
	LEA     DI,CopyTemp
	SAVE    <DI>
	Invoke  PackName                ;       PackName (Name1, temp);
	RESTORE <DI>
	Invoke  StrLen                  ;       if (strlen(temp)+d > bp)
	DEC     CX
	ADD     CX,CopyDoff
	CMP     CX,CopyBP
	JAE     CopyBad                 ;           return (-1);
	MOV     SI,DI                   ;       strcpy (d, temp);
	LES     DI,CopyD
	Invoke  FStrCpy
GoodRet:                                ;       }
	CLC
	JMP     SHORT CopyEnd           ;   return 0;
CopyBad:
	STC
	CALL    ScanPathChar            ; check for path chars in rest of string
	MOV     AL,error_file_not_found ; Set up for bad file error
	JNZ     CopyEnd
CopyBadPath:
	STC
	MOV     AL,error_path_not_found ; Set bad path error
CopyEnd:
	RESTORE <BP,DI,ES,SI,DS>
	LAHF
	ADD     SP,14                   ; reclaim temp buffer
	Invoke  Strlen
	DEC     CX
	SAHF
	return
EndProc CopyComponent,NoCheck

Break <Splice - pseudo mount by string substitution>

;
;   Splice - take a string and substitute a prefix if one exists.  Change
;       ThisCDS to point to physical drive CDS.
;   Inputs:     DS:SI point to string
;               NoSetDir = TRUE => exact matches with splice fail
;   Outputs:    DS:SI points to thisCDS
;               ES:DI points to DPB
;               String at DS:SI may be reduced in length by removing prefix
;               and substituting drive letter.
;               CX = 0 If no splice done
;               CX <> 0 otherwise
;               ThisCDS points to proper CDS if spliced, otherwise it is
;                   left alone
;               ThisDPB points to proper DPB
;   Registers modified: DS:SI, ES:DI, BX,AX,CX

Procedure   Splice,NEAR
	ASSUME  CS:DOSCODE,SS:DOSDATA
	TEST    Splices,-1                                      ;smr;SS Override
	JZ      AllDone
	SAVE    <<WORD PTR ThisCDS>,<WORD PTR ThisCDS+2>>   ; TmpCDS = ThisCDS;smr;SS Override
	SAVE    <DS,SI>
	RESTORE <DI,ES>
	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
SpliceScan:
	invoke  GetCDSFromDrv
	JC      SpliceDone
	INC     AL
	TEST    [SI.curdir_flags],curdir_splice
	JZ      SpliceScan              ;       if ( Spliced (i) ) {
	SAVE    <DI>
	CALL    PathPref                ;           if (!PathPref (s, d))
	JZ      SpliceFound             ;
SpliceSkip:
	RESTORE <DI>
	JMP     SpliceScan              ;               continue;
SpliceFound:
	CMP     BYTE PTR ES:[DI],0      ;           if (*s || NoSetDir) {
	JNZ     SpliceDo
	TEST    NoSetDir,-1                                     ;smr;SS Override
	JNZ     SpliceSkip
SpliceDo:
	MOV     SI,DI                   ;               p = src + strlen (p);
	SAVE    <ES>
	RESTORE <DS,DI>
	CALL    TextFromDrive1          ;               src = TextFromDrive1(src,i);
	MOV     AX,Curr_Dir_End                                 ;smr;SS Override
	OR      AX,AX
	JS      NoPoke
	ADD     AX,DI                   ;               curdirend += src-p;
	SUB     AX,SI
	MOV     Curr_Dir_End,AX                                 ;smr;SS Override
NoPoke:
	CMP     BYTE PTR [SI],0         ;               if (*p)
	JNZ     SpliceCopy              ;                   *src++ = '\\';
	MOV     AL,"\"
	STOSB
SpliceCopy:                             ;               strcpy (src, p);
	invoke  FStrCpy
	ADD     SP,4                    ; throw away saved stuff
	OR      CL,1                    ; signal splice done.
	JMP     SHORT DoSet             ;               return;
SpliceDone:                             ;               }
	ASSUME  DS:NOTHING              ;   ThisCDS = TmpCDS;
	RESTORE <<WORD PTR ThisCDS+2>,<WORD PTR ThisCDS>>       ;smr;SS Override
AllDone:
	XOR     CX,CX
DoSet:
	LDS     SI,ThisCDS              ;   ThisDPB = ThisCDS->devptr;;smr;SS Override
	LES     DI,[SI].curdir_devptr
	MOV     WORD PTR ThisDPB,DI                             ;smr;SS Override
	MOV     WORD PTR ThisDPB+2,ES                           ;smr;SS Override
	return

EndProc Splice, NoCheck

Break <$NameTrans - partially process a name>

;
;   $NameTrans - allow users to see what names get mapped to.  This call
;   performs only string substitution and canonicalization, not splicing.  Due
;   to Transpath playing games with devices, we need to insure that the output
;   has drive letter and :  in it.
;
;   Inputs:     DS:SI - source string for translation
;               ES:DI - pointer to buffer
;   Outputs:
;       Carry Clear
;               Buffer at ES:DI is filled in with data
;               ES:DI point byte after nul byte at end of dest string in buffer
;       Carry Set
;               AX = error_path_not_found
;   Registers modified: all

Procedure   $NameTrans,Near
	ASSUME  CS:DOSCODE,SS:DOSDATA
	SAVE    <DS,SI,ES,DI,CX>

; M027 - Start
;
; Sattrib must be set up with default values here. Otherwise, the value from
; a previous DOS call is used for attrib and DevName thinks it is not a 
; device if the old call set the volume attribute bit. Note that devname in
; dir2.asm gets ultimately called by Transpath. See also M026. Also save
; and restore CX.
;

	mov     ch,attr_hidden+attr_system+attr_directory
	invoke  SetAttrib

; M027 - End

	MOV     DI,OFFSET DOSDATA:OpenBuf
	CALL    TransPath               ; to translation (everything)
	RESTORE <CX,DI,ES,SI,DS>
	JNC     TransOK
	transfer    SYS_Ret_Err
TransOK:
	MOV     SI,OFFSET DOSDATA:OpenBuf
	Context DS
GotText:
	Invoke  FStrCpy
	Transfer    SYS_Ret_OK
EndProc $NameTrans

Break   <DriveFromText - return drive number from a text string>

;
;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
;   pointer.
;
;   Inputs:     DS:SI point to a text string
;   Outputs:    AL has drive number
;               DS:SI advanced
;   Registers modified: AX,SI.

Procedure   DriveFromText,NEAR
	ASSUME  CS:DOSCODE,SS:NOTHING
	XOR     AL,AL                   ;       drive = 0;
	CMP     BYTE PTR [SI],0         ;       if (*s &&
	retz
	CMP     BYTE PTR [SI+1],':'     ;           s[1] == ':') {
	retnz
 IFDEF  DBCS                            ;AN000;
;--------------------- Start of DBCS 2/18/KK
	push    ax                     ;AN000;
	mov     al,[si]                ;AN000;
	call    TestKanj               ;AN000;
	pop     ax                     ;AN000;
	retnz                          ;AN000;
;--------------------- End of DBCS 2/18/KK
 ENDIF                                 ;AN000;
	LODSW                           ;           drive = (*s | 020) - 'a'+1;
	OR      AL,020h
	SUB     AL,'a'-1                ;           s += 2;
	retnz
	MOV     AL,-1                   ; nuke AL...
	return                          ;           }
EndProc DriveFromText

Break   <TextFromDrive - convert a drive number to a text string>

;
;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
;   trailing :. TextFromDrive1 takes a 1-based number.
;
;   Inputs:     AL has 0-based drive number
;   Outputs:    ES:DI advanced
;   Registers modified: AX

Procedure TextFromDrive,NEAR
	ASSUME  CS:DOSCODE,SS:NOTHING
	INC     AL
	Entry   TextFromDrive1
	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
	MOV     AH,":"                  ;   strcat (d, ":");
	STOSW
	return
EndProc TextFromDrive

Break   <PathPref - see if one path is a prefix of another>

;
;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
;   other.  Remember that only at a pathchar break are we allowed to have a
;   prefix: A:\ and A:\FOO
;
;   Inputs:     DS:SI potential prefix
;               ES:DI string
;   Outputs:    Zero set => prefix found
;                   DI/SI advanced past matching part
;               Zero reset => no prefix, DS/SI garbage
;   Registers modified: CX

Procedure   PathPref,NEAR
	Invoke  DStrLen                 ; get length
	DEC     CX                      ; do not include nul byte
 IFDEF  DBCS                            ;AN000;
;----------------------- Start of DBCS 2/13/KK
	SAVE    <AX>                    ;AN000;; save char register
CmpLp:                                  ;AN000;
	MOV     AL,[SI]                 ;AN000;
	call    TestKanj                ;AN000;
	jz      NotKanj9                ;AN000;
	CMPSW                           ;AN000;
	JNZ     Prefix                  ;AN000;
	DEC     CX                      ;AN000;
	LOOP    CmpLp                   ;AN000;
	JMP     SHORT NotSep            ;AN000;
NotKanj9:                               ;AN000;
	CMPSB                           ;AN000;
	JNZ     Prefix                  ;AN000;
	LOOP    CmpLp                   ;AN000;
;----------------------- End of DBCS 2/13/KK
 ELSE                                   ;AN000;
	REPZ    CMPSB                   ; compare
	retnz                           ; if NZ then return NZ
	SAVE    <AX>                    ; save char register
 ENDIF                                  ;AN000;
	MOV     AL,[SI-1]               ; get last byte to match
	call    PathChrCmp              ; is it a path char (Root!)
	JZ      Prefix                  ; yes, match root (I hope)
NotSep:                                 ; 2/13/KK
	MOV     AL,ES:[DI]              ; get next char to match
	CALL    PathSepGotCh            ; was it a pathchar?
Prefix:
	RESTORE <AX>            ; get back original
	return
EndProc PathPref

Break   <ScanPathChar - see if there is a path character in a string>

;
;     ScanPathChar - search through the string (pointed to by DS:SI) for
;     a path separator.
;
;     Input:    DS:SI target string (null terminated)
;     Output:   Zero set => path separator encountered in string
;               Zero clear => null encountered
;     Registers modified: SI

Procedure     ScanPathChar,NEAR
	LODSB                           ; fetch a character
 IFDEF  DBCS                            ;AN000;
	call    TestKanj                ;AN000;; 2/13/KK
	jz      NotKanjr                ;AN000;; 2/13/KK
	LODSB                           ;AN000;; 2/13/KK
	OR      AL,AL                   ;AN000;; 2/13/KK  3/31/removed
	JNZ     ScanPathChar            ;AN000;; 2/13/KK  3/31/removed
	INC     AL                      ;AN000;; 2/13/KK
	return                          ;AN000;; 2/13/KK
					;AN000;
NotKanjr:                               ;AN000;; 2/13/KK
 ENDIF                                  ;AN000;
	call    PathSepGotCh
	JNZ     ScanPathChar            ; not \, / or NUL => go back for more
	call    PathChrCmp              ; path separator?
	return
EndProc       ScanPathChar

DOSCODE ends
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msctrlc.asm ===
;**	MSCTRLC.ASM - ^C and error handler for MSDOS
;
;
;
	.xlist
	.xcref
	include version.inc
	include mssw.asm
	.cref
	.list

	TITLE	Control C detection, Hard error and EXIT routines
	NAME	IBMCTRLC

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Low level routines for detecting special characters on CON input,
;	the ^C exit/int code, the Hard error INT 24 code, the
;	process termination code, and the INT 0 divide overflow handler.
;
;	FATAL
;	FATAL1
;	reset_environment
;	DSKSTATCHK
;	SPOOLINT
;	STATCHK
;	CNTCHAND
;	DIVOV
;	CHARHARD
;	HardErr
;
;	Revision history:
;
;	    AN000	version 4.0   Jan 1988
;	    A002	PTM    -- dir >lpt3 hangs
;	    A003	PTM 3957- fake version for IBMCAHE.COM
;
; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
;	      flags register. In order to return to user normally DOS used to
;	      move F202 into flags, which sets bit number 1 in flags uncondit-
;	      ionally. Now it is modified to maintain the state of bit 1.
;
; 	M024: suppressed fail and ignore options if not in the middle of int 
;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
;	      charhard.
;


	.xlist
	include dosseg.inc
	.xcref
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include pdb.inc
	include dpb.inc
	include exe.inc
	include sf.inc
	include vector.inc
	include filemode.inc
	include mi.inc
	include syscall.inc
	include bugtyp.inc
	.cref
	.list

	I_need	SFN,WORD
	I_NEED	pJFN,DWORD
	i_need	DevIOBuf,BYTE
	i_need	DidCTRLC,BYTE
	i_need	INDOS,BYTE
	i_need	DSKSTCOM,BYTE
	i_need	DSKSTCALL,BYTE
	i_need	DSKSTST,WORD
	i_need	BCON,DWORD
	i_need	DSKCHRET,BYTE
	i_need	DSKSTCNT,WORD
	i_need	IDLEINT,BYTE
	i_need	CONSWAP,BYTE
	i_need	user_SS,WORD
	i_need	user_SP,WORD
	i_need	User_In_AX,WORD
	i_need	ERRORMODE,BYTE
	i_need	ConC_spsave,WORD
	i_need	Exit_type,BYTE
	i_need	PFLAG,BYTE
	i_need	ExitHold,DWORD
	i_need	WPErr,BYTE
	i_need	ReadOp,BYTE
	i_need	CONTSTK,WORD
	i_need	Exit_Code,WORD
	i_need	CurrentPDB,WORD
	i_need	DIVMES,BYTE
	i_need	ALLOWED,BYTE
	i_need	FAILERR,BYTE
	i_need	EXTERR,WORD
	i_need	ERR_TABLE_24,BYTE
	I_need	ErrMap24,BYTE
	I_need	ErrMap24End,BYTE
	I_need	fAborting,BYTE
	I_need	AUXStack,BYTE
	I_need	SCAN_FLAG,BYTE
	I_need	EXTOPEN_ON,BYTE 	      ;AN000; DOS 4.0
	I_need	InterCon,BYTE		      ;AN000; DOS 4.0
	I_need	DOS34_FLAG,WORD 	      ;AN000; DOS 4.0
	I_need	Special_Version,WORD	      ;AN007; DOS 4.0

	I_need	TEMPSEG, WORD
	I_need	DosHasHMA,byte			; M021



ifndef ROMDOS

DOSDATA	SEGMENT
	extrn	LowInt23:near
	extrn	LowInt24:near
	extrn	LowInt28:near
DOSDATA	ENDS

endif ; ROMDOS


DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	extrn	DivMesLen:WORD

	allow_getdseg

ifndef ROMDOS

		public	LowInt23Addr		
LowInt23Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt23, 0

		public	LowInt24Addr
LowInt24Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt24, 0

		public	LowInt28Addr
LowInt28Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt28, 0

endif ; ROMDOS


Break	<Checks for ^C in CON I/O>

;---------------------------------------------------------------------------
;
; Procedure Name : DSKSTATCHK
;
; Check for ^C if only one level in
;
;---------------------------------------------------------------------------

procedure   DSKSTATCHK,NEAR	

	CMP	BYTE PTR InDos,1	; SS override
	retnz				; Do NOTHING
	DOSAssume   <SS>,"DskStatChk"
	PUSH	CX
	PUSH	ES
	PUSH	BX
	PUSH	DS
	PUSH	SI

	MOV	BX, SS			; SS is DOSDATA. ES:BX must be set up
	MOV	ES, BX			; for deviocall2
	assume	es:nothing		
	MOV	DS, BX
	MOV	BYTE PTR DskStCom,DEVRDND
	MOV	BYTE PTR DskStCall,DRDNDHL
	MOV	DskStSt,0
 IFDEF  DBCS				;AN000;
	MOV	AL, InterCon		;AN000; get type of status read 2/13/KK
	MOV	BYTE PTR DskChRet,AL	;AN000; load interim flag into packet
 ENDIF					;AN000;

					; DSKSTCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DSKSTCALL
	LDS	SI,BCon
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2
	TESTB	DSKSTST,STBUI		; SS override
	JZ	GotCh			; No characters available
	XOR	AL,AL			; Set zero
RET36:
	POP	SI
	POP	DS
	POP	BX
	POP	ES
	POP	CX
	return

GotCh:

	MOV	AL,BYTE PTR DskChRet	; SS override
DSK1:
	CMP	AL,"C"-"@"
	JNZ	RET36

					; SS used for next 5 instructions 
	MOV	BYTE PTR DskStCom,DEVRD
	MOV	BYTE PTR DskStCall,DRDWRHL
	MOV	BYTE PTR DskChRet,CL
	MOV	DskStSt,0
	MOV	DskStCnt,1
	invoke	DEVIOCALL2		; Eat the ^C
	POP	SI
	POP	DS
	POP	BX			; Clean stack
	POP	ES
	POP	CX
	JMP	CNTCHAND

NOSTOP:
	CMP	AL,"P"-"@"
	JNZ	check_next

				    	; SS override
	CMP	BYTE PTR Scan_Flag,0	; ALT_Q ?
	JZ	INCHKJ			; no
	return
check_next:
	IF	NOT TOGLPRN
	CMP	AL,"N"-"@"
	JZ	INCHKJ
	ENDIF

	CMP	AL,"C"-"@"
	JZ	INCHKJ
check_end:
	return

INCHKJ:
	JMP	INCHK

EndProc DSKSTATCHK

;----------------------------------------------------------------------------
;
; Procedure Name : SpoolInt
;
; SpoolInt - signal processes that the DOS is truly idle.  We are allowed to
; do this ONLY if we are working on a 1-12 system call AND if we are not in
; the middle of an INT 24.
;
;----------------------------------------------------------------------------

procedure   SPOOLINT,NEAR
	PUSHF
	cmp	IdleInt,0		; SS override for IdleInt & ErrorMode
	je	POPFRet
	cmp	ErrorMode,0
	jnz	POPFRet
	
	;
	; Note that we are going to allow an external program to issue system 
	; calls at this time.  We MUST preserve IdleInt across this.
	;

	PUSH	WORD PTR IdleInt

ifndef ROMDOS 
	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
	jne	do_low_int28		; Y: the int must be done from low mem
	INT	int_spooler		; N: Execute user int 28 handler
	jmp	short spool_ret_addr

do_low_int28:
	call	dword ptr LowInt28Addr

spool_ret_addr:
else
	INT	int_spooler		; if in ROM just do int 
endif ; ROMDOS

	POP	WORD PTR IdleInt
POPFRET:
	POPF
	return
EndProc SPOOLINT


;----------------------------------------------------------------------------
;
; Procedure Name : STATCHK
;
;----------------------------------------------------------------------------

	procedure   STATCHK,NEAR

	invoke	DSKSTATCHK		; Allows ^C to be detected under
					; input redirection
	PUSH	BX
	XOR	BX,BX
	invoke	GET_IO_SFT
	POP	BX
	retc
	MOV	AH,1
	invoke	IOFUNC
	JZ	SPOOLINT
	CMP	AL,"S"-"@"
	JNZ	NOSTOP

					; SS override
	CMP	BYTE PTR Scan_Flag,0	; AN000; ALT_R ?
	JNZ	check_end		; AN000; yes
	XOR	AH,AH
	invoke	IOFUNC			; Eat Cntrl-S
	JMP	SHORT PAUSOSTRT
PRINTOFF:
PRINTON:

	NOT	BYTE PTR PFlag		; SS override
	PUSH	BX
	MOV	BX,4
	invoke	GET_IO_SFT
	POP	BX
	retc
	PUSH	ES
	PUSH	DI
	PUSH	DS
	POP	ES
	MOV	DI,SI			; ES:DI -> SFT
	TESTB	ES:[DI].SF_FLAGS,sf_net_spool
	JZ	NORM_PR 		; Not redirected, echo is OK
	Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> ; See if allowed
	JNC	NORM_PR 		; Echo is OK

					; SS override
	MOV	BYTE PTR PFlag,0	; If not allowed, disable echo
	Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
	JMP	SHORT RETP6

NORM_PR:
	CMP	BYTE PTR PFlag,0	; SS override
	JNZ	PRNOPN
	invoke	DEV_CLOSE_SFT
	JMP	SHORT RETP6

PRNOPN:
	invoke	DEV_OPEN_SFT
RETP6:
	POP	DI
	POP	ES
	return

PAUSOLP:
	CALL	SPOOLINT
PAUSOSTRT:
	MOV	AH,1
	invoke	IOFUNC
	JZ	PAUSOLP
INCHK:
	PUSH	BX
	XOR	BX,BX
	invoke	GET_IO_SFT
	POP	BX
	retc
	XOR	AH,AH
	invoke	IOFUNC
	CMP	AL,"P"-"@"

	;;;;;  7/14/86	ALT_Q key fix

	JZ	PRINTON			; no! must be CTRL_P

NOPRINT:

	;;;;;  7/14/86	ALT_Q key fix

	IF	NOT TOGLPRN
	CMP	AL,"N"-"@"
	JZ	PRINTOFF
	ENDIF
	CMP	AL,"C"-"@"
	retnz
EndProc STATCHK

;	!! NOTE: FALL THROUGH !!

;---------------------------------------------------------------------------
;
; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
;
; "^C" and CR/LF is printed.  Then the user registers are restored and the
; user CTRL-C handler is executed.  At this point the top of the stack has 1)
; the interrupt return address should the user CTRL-C handler wish to allow
; processing to continue; 2) the original interrupt return address to the code
; that performed the function call in the first place.	If the user CTRL-C
; handler wishes to continue, it must leave all registers unchanged and RET
; (not IRET) with carry CLEAR.	If carry is SET then an terminate system call
; is simulated.
;
;---------------------------------------------------------------------------

procedure   CNTCHAND,NEAR

					; SS override
					; AN002; from RAWOUT
	TESTB	Dos34_Flag,CTRL_BREAK_FLAG  
	JNZ	around_deadlock 	; AN002;
	MOV	AL,3			; Display "^C"
	invoke	BUFOUT
	invoke	CRLF
around_deadlock:			;AN002;
	Context DS			; SS is DOSDATA
	CMP	BYTE PTR ConSwap,0
	JZ	NOSWAP
	invoke	SWAPBACK
NOSWAP:
	CLI				; Prepare to play with stack
	MOV	SS,User_SS		; User stack now restored
ASSUME	SS:NOTHING
	MOV	SP,User_SP

					; use macro for restore_world
	restore_world			; User registers now restored

	;
	; CS was used to address these variables. We have to use DOSDATA 
	;
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV	BYTE PTR InDos,0	; Go to known state
	MOV	BYTE PTR ErrorMode,0
	MOV	ConC_Spsave,SP		; save his SP


	; User SP has changed because of push. Adjust for it

	add	ConC_Spsave,2		

ifndef ROMDOS
	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
 	pop	ds	;restore ds
	assume	ds:NOTHING

	jne	do_low_int23		; Y: the int must be done from low mem
	CLC				
	INT	int_ctrl_c		; N: Execute user Ctrl-C handler
	jmp	short ctrlc_ret_addr

do_low_int23:
	clc
	call	dword ptr LowInt23Addr

ctrlc_ret_addr:
else
 	pop	ds	;restore ds
	assume	ds:NOTHING

	CLC
	INT	int_ctrl_c		; Execute user Ctrl-C handler

endif ; ROMDOS


;
; The user has returned to us.	The circumstances we allow are:
;
;   IRET	We retry the operation by redispatching the system call
;   CLC/RETF	POP the stack and retry
;   ... 	Exit the current process with ^C exit
;
; User's may RETURN to us and leave interrupts on.  Turn 'em off just to be
; sure
;
	CLI

	;
	; We have to use DOSDATA for these variables. Previously CS was used 
	;

	push	ax
	mov	ax, ds
	getdseg	<ds>			; ds -> dosdata

	mov	TempSeg, ax
	pop	ax

	MOV	User_In_AX,ax		; save the AX
	PUSHF				; and the flags (maybe new call)
	POP	AX

	;
	; See if the input stack is identical to the output stack
	;

	CMP	SP,ConC_Spsave
	JNZ	ctrlc_try_new		; current SP not the same as saved SP

	;
	; Repeat the operation by redispatching the system call.
	;

ctrlc_repeat:
	MOV	AX,User_In_AX		; ds still points to dosdata 

					
	mov	ds, TempSeg		; restore ds and original sp 
	assume	ds:NOTHING

	transfer    COMMAND

	;
	; The current SP is NOT the same as the input SP.  Presume that he 
	; RETF'd leaving some flags on the stack and examine the input
	;

ctrlc_try_new:
	ADD	SP,2			; pop those flags
	TESTB	AX,f_carry		; did he return with carry?
	JZ	Ctrlc_Repeat		; no carry set, just retry

					
	assume	ds:DOSDATA		;restore ds 
	mov	ds, TempSeg
	assume	ds:NOTHING

	;
	; Well...  time to abort the user.  Signal a ^C exit and use the EXIT 
	; system call..
	;

ctrlc_abort:
	MOV	AX,(EXIT SHL 8) + 0

	push	ds
	getdseg	<ds>			; ds -> dosdata
	
	MOV	DidCTRLC,-1

	pop	ds
	assume	ds:NOTHING

	transfer    COMMAND		; give up by faking $EXIT

EndProc CNTCHAND

Break	<DIVISION OVERFLOW INTERRUPT>
;----------------------------------------------------------------------------
;
; Procedure Name : DIVOV
;
; Default handler for division overflow trap
;
;----------------------------------------------------------------------------

procedure   DIVOV,NEAR
	ASSUME	SS:NOTHING

					; DIVMES is in DOSCODE
	MOV	SI,OFFSET DOSCODE:DIVMES
	MOV	BX,DivMesLen

					; Point SS to dosdata 
	getdseg	<ss>			; we are in an ISR flag is CLI

					; AUXSTACK is in DOSDATA
					; Enough stack for interrupts
	MOV	SP,OFFSET DOSDATA:AUXSTACK 
	CALL	OutMes
	JMP	ctrlc_abort		; Use Ctrl-C abort on divide overflow
EndProc DIVOV

;---------------------------------------------------------------------------
;
; Procedure Name : OutMes
;
;
; OutMes: perform message output
; Inputs:   SS:SI points to message
;	    BX has message length
; Outputs:  message to BCON
;
;Actually, cs:si points to the message now. The segment address is filled in
;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
;NB. This procedure is called only from DIVOV. -SR
;
;---------------------------------------------------------------------------

procedure   OutMes,NEAR

	Context ES			; get ES addressability
	Context DS			; get DS addressability

	MOV	BYTE PTR DskStCom,DevWrt
	MOV	BYTE PTR DskStCall,DRdWrHL
	MOV	DskStSt,0
	MOV	DskStCnt,BX

					; DSKSTCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DskStCall
	MOV	WORD PTR [DskChRet+1],SI; transfer address (need an EQU)


					; CS is used for string, fill in 
					; segment address 
	MOV	WORD PTR [DskChRet+3],CS

	LDS	SI,BCon

ASSUME	DS:NOTHING
	invoke	DEVIOCALL2
					; ES still points to DOSDATA. ES is
					; not destroyed by deviocall2. So use
					; ES override.

					; DEVIOBUF is in DOSDATA
	MOV	WORD PTR ES:[DskChRet+1],OFFSET DOSDATA:DevIOBuf
	MOV	ES:[DskStCnt],1
	return
EndProc OutMes

Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
;---------------------------------------------------------------------------
;
; Procedure Name : CHARHARD
;
;
; Character device error handler
; Same function as HARDERR
;
;---------------------------------------------------------------------------

procedure   CHARHARD,NEAR
	ASSUME	SS:DOSDATA

		   			; M024 - start
	cmp	byte ptr [ErrorMode], 0	; Q: are we in the middle of int 24
	jne	@f			; Y: allow fail

	OR	AH, allowed_RETRY	; assume ctrl p

	test	byte ptr [PFLAG], -1	; Q: has ctrl p been pressed
	jnz	ctrlp			; Y: 
@@:					; M024 - end

	OR	AH,allowed_FAIL + allowed_IGNORE + allowed_RETRY

ctrlp:					; M024

					; SS override for Allowed and EXITHOLD
	MOV	Allowed,AH
	MOV	WORD PTR EXITHOLD+2,ES
	MOV	WORD PTR EXITHOLD,BP
	PUSH	SI
	AND	DI,STECODE
	MOV	BP,DS			; Device pointer is BP:SI
	CALL	FATALC
	POP	SI
	return
EndProc CHARHARD

;---------------------------------------------------------------------------
;
; Procedure Name : HardErr
;
; Hard disk error handler. Entry conditions:
;	DS:BX = Original disk transfer address
;	DX = Original logical sector number
;	CX = Number of sectors to go (first one gave the error)
;	AX = Hardware error code
;	DI = Original sector transfer count	
;	ES:BP = Base of drive parameters
;	[READOP] = 0 for read, 1 for write
;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
; Output:
;	[FAILERR] will be set if user responded FAIL
;
;--------------------------------------------------------------------------

procedure   HardErr,NEAR

	XCHG	AX,DI			; Error code in DI, count in AX
	AND	DI,STECODE		; And off status bits
	CMP	DI,error_I24_write_protect ; Write Protect Error?
	JNZ	NOSETWRPERR
	PUSH	AX
	MOV	AL,ES:[BP.dpb_drive]

					; SS override
	MOV	BYTE PTR WPERR,AL	; Flag drive with WP error
	POP	AX
NOSETWRPERR:
	SUB	AX,CX			; Number of sectors successfully transferred
	ADD	DX,AX			; First sector number to retry
	PUSH	DX
	MUL	ES:[BP.dpb_sector_size] ; Number of bytes transferred
	POP	DX
	ADD	BX,AX			; First address for retry
	XOR	AH,AH			; Flag disk section in error
	CMP	DX,ES:[BP.dpb_first_FAT]; In reserved area?
	JB	ERRINT
	INC	AH			; Flag for FAT
					; In FAT?
	CMP	DX,ES:[BP.dpb_dir_sector]   
	JAE	TESTDIR 		; No
	MOV	ES:[BP.dpb_free_cnt],-1 ; Err in FAT must force recomp of freespace
	JMP	SHORT ERRINT

TESTDIR:
	INC	AH
					; In directory?
	CMP	DX,ES:[BP.dpb_first_sector] 
	JB	ERRINT
	INC	AH			; Must be in data area
ERRINT:
	SHL	AH,1			; Make room for read/write bit

					; SS override
	OR	AH,BYTE PTR READOP	; Set bit 0

	;
	; If we have a write protect error when writing on a critical area on ,
	; disk, do not allow a retry as this may write out garbage on any 
	; subsequent disk.
	;
	;test	ah,1
	;jz	Not_Crit
	;cmp	ah,5
	;ja	Not_Crit
	;and	Allowed,NOT Allowed_RETRY

Not_Crit:

					; SS override for allowed and EXITHOLD
	OR	AH,Allowed		; Set the allowed_ bits
	entry	FATAL
	MOV	AL,ES:[BP.dpb_drive]	; Get drive number
	entry	FATAL1
	MOV	WORD PTR EXITHOLD+2,ES
	MOV	WORD PTR EXITHOLD,BP	; The only things we preserve
	LES	SI,ES:[BP.dpb_driver_addr]
	MOV	BP,ES			; BP:SI points to the device involved

	;
	; DI has the INT-24-style extended error.  We now map the error code 
	; for this into the normalized get extended error set by using the 
	; ErrMap24 table as a translate table.  Note that we translate ONLY 
	; the device returned codes and leave all others beyond the look up 
	; table alone.
	;

FATALC:
	call	SET_I24_EXTENDED_ERROR
	CMP	DI,error_I24_gen_failure
	JBE	GOT_RIGHT_CODE		; Error codes above gen_failure get
	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
					;  Only come via GetExtendedError
;**
;
; Entry point used by REDIRector on Network I 24 errors.
;
;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
;
; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
;     EXITHOLD set for restore of ES:BP.
;

	entry	NET_I24_ENTRY

GOT_RIGHT_CODE:

					; SS override
	CMP	BYTE PTR ErrorMode,0	; No INT 24s if already INT 24
	JZ	NoSetFail
	MOV	AL,3
IF	DEBUG
	JMP	FailRet
ELSE
	JMP	short FailRet
ENDIF
NoSetFail:

					; SS override
	MOV	CONTSTK,SP
	Context ES
	fmt TypINT24,LevLog,<"INT 24: AX = $x DI = $x\n">,<AX,DI>

	;
	; Wango!!!  We may need to free some user state info...  In 
	; particular, we may have locked down a JFN for a user and he may 
	; NEVER return to us. Thus,we need to free it here and then 
	; reallocate it when we come back.
	;

					; SS override for SFN and pJFN
	CMP	SFN,-1
	JZ	NoFree
	SAVE	<DS,SI>
	LDS	SI,pJFN
	MOV	BYTE PTR [SI],0FFH
	RESTORE <SI,DS>
NoFree:
	CLI				; Prepare to play with stack

					; SS override for ERRORMODE, INDOS, 
					; DOS34_FLAG, EXTOPEN_ON
	INC	BYTE PTR ErrorMode	; Flag INT 24 in progress
	DEC	BYTE PTR InDos		; INT 24 handler might not return

	;; Extended Open hooks

					; AN000;IFS.I24 error disabled	      ;AN000;
	TESTB	EXTOPEN_ON,EXT_OPEN_I24_OFF 
	JZ	i24yes			; AN000;IFS.no			      ;AN000;
faili24:				; AN000;
	MOV	AL,3			; AN000;IFS.fake fail		      ;AN000;
	JMP	short passi24 		; AN000;IFS.exit			      ;AN000;
i24yes: 				; AN000;

	;; Extended Open hooks

	MOV	SS,User_SS
ASSUME	SS:NOTHING
	MOV	SP,ES:User_SP		; User stack pointer restored

ifndef ROMDOS
	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
	jne	do_low_int24		; Y: the int must be done from low mem
	INT	int_fatal_abort 	; Fatal error interrupt vector, 
					; must preserve ES
	jmp	short criterr_ret_addr

do_low_int24:
	call	dword ptr LowInt24Addr

criterr_ret_addr:
else

	INT	int_fatal_abort 	; Fatal error interrupt vector, must preserve ES

endif ; ROMDOS
	MOV	ES:User_SP,SP		; restore our stack
	MOV	ES:User_SS,SS
	MOV	BP,ES
	MOV	SS,BP
ASSUME	SS:DOSDATA
passi24:				; AN000;

					; SS override for nect 3 instructions.
	MOV	SP,CONTSTK
	INC	BYTE PTR InDos		; Back in the DOS
	MOV	BYTE PTR ErrorMode,0	; Back from INT 24
	STI
;;	MOV	ACT_PAGE,-1		; LB. invalidate DOS active page 	;AN000;
;;	invoke	SAVE_MAP		; LB. save user's EMS map                ;AN000;
	fmt TypINT24,LevLog,<"INT 24: User reply = $x\n">,<AX>
FAILRET:

					
	LES	BP,EXITHOLD		; SS override
ASSUME	ES:NOTHING

	;
	; Triage the user's reply.
	;

	CMP	AL,1
	JB	CheckIgnore		; 0 => ignore
	JZ	CheckRetry		; 1 => retry
	CMP	AL,3			; 3 => fail
	JNZ	DoAbort 		; 2, invalid => abort

	;
	; The reply was fail.  See if we are allowed to fail.
	;

					; SS override for ALLOWED, EXTOPEN_ON, 
					; ALLOWED, FAILERR, WpErr, SFN, pJFN
	TESTB	Allowed,allowed_FAIL	; Can we?
	JZ	DoAbort 		; No, do abort
DoFail:
	MOV	AL,3			; just in case...
					; AN000;EO. I24 error disabled
	TESTB	EXTOPEN_ON,EXT_OPEN_I24_OFF 
	JNZ	cleanup 		; AN000;EO. no
	INC	FAILERR			; Tell everybody
CleanUp:
	MOV	WpErr,-1
	CMP	SFN,-1
	retz
	SAVE	<DS,SI,AX>
	MOV	AX,SFN
	LDS	SI,pJFN
	MOV	[SI],AL
	RESTORE <AX,SI,DS>
	return

	;
	; The reply was IGNORE.  See if we are allowed to ignore.
	;

CheckIgnore:
	TESTB	Allowed,allowed_IGNORE 	; Can we?
	JZ	DoFail			; No, do fail
	JMP	CleanUp

	;	
	; The reply was RETRY.	See if we are allowed to retry.
	;

CheckRetry:
	TESTB	Allowed,allowed_RETRY 	; Can we?
	JZ	DoFail			; No, do fail
	JMP	CleanUp

	;
	; The reply was ABORT.
	;

DoAbort:
	Context DS
	CMP	BYTE PTR ConSwap,0
	JZ	NOSWAP2
	invoke	SWAPBACK
NOSWAP2:

	;	
	; See if we are to truly abort.  If we are in the process of aborting, 
	; turn this abort into a fail.
	;

	cmp	fAborting,0
	JNZ	DoFail

	;
	; Set return code
	;

	MOV	BYTE PTR [exit_Type],Exit_hard_error
	XOR	AL,AL

	;
	; we are truly aborting the process.  Go restore information from 
	; the PDB as necessary.
	;

	Transfer    exit_inner
;**
;
; reset_environment checks the DS value against the CurrentPDB.  If they are
; different, then an old-style return is performed.  If they are the same,
; then we release jfns and restore to parent.  We still use the PDB at DS:0 as
; the source of the terminate addresses.
;
; Some subtlety:  We are about to issue a bunch of calls that *may* generate
; INT 24s.  We *cannot* allow the user to restart the abort process; we may
; end up aborting the wrong process or turn a terminate/stay/resident into a
; normal abort and leave interrupt handlers around.  What we do is to set a
; flag that will indicate that if any abort code is seen, we just continue the
; operation.  In essence, we dis-allow the abort response.
;
; output:   none.
;
	entry	reset_environment
	ASSUME	DS:NOTHING,ES:NOTHING

;***	invoke	Reset_Version		; AN007;MS. reset version number
	PUSH	DS			; save PDB of process

	;
	; There are no critical sections in force.  Although we may enter 
	; here with critical sections locked down, they are no longer 
	; relevant. We may safely free all allocated resources.
	;

	MOV	AH,82h
	INT	int_IBM

					; SS override
	MOV	fAborting,-1		; signal abort in progress

					; DOS 4.00 doesn't need it
	CallInstall NetResetEnvironment, multNet, 34  
					; Allow REDIR to clear some stuff
					; On process exit.
	MOV	AL,int_Terminate
	invoke	$Get_interrupt_vector	; and who to go to

	POP	CX			; get ThisPDB
	SAVE	<ES,BX> 		; save return address

	MOV	BX,[CurrentPDB] 	; get currentPDB
	MOV	DS,BX
	MOV	AX,DS:[PDB_Parent_PID]	; get parentPDB

	;
	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
	; is not Exit_keep_process
	;
	
	CMP	AX,BX
	JZ	reset_return		; parentPDB = CurrentPDB
	CMP	BX,CX
	JNZ	reset_return		; CurrentPDB <> ThisPDB
	PUSH	AX			; save parent

					; SS override
	CMP	BYTE PTR [exit_type],Exit_keep_process
	JZ	reset_to_parent 	; keeping this process

	;
	; We are truly removing a process.  Free all allocation blocks 
	; belonging to this PDB
	;

	invoke	arena_free_process

	;
	; Kill off remainder of this process.  Close file handles and signal 
	; to relevant network folks that this process is dead.  Remember that 
	; CurrentPDB is STILL the current process!
	;

	invoke	DOS_ABORT

reset_to_parent:
					; SS override
	POP	[CurrentPDB]		; set up process as parent

reset_return:				; come here for normal return

	Context	DS			; DS is used to refer to DOSDATA  

	MOV	AL,-1

	;
	; make sure that everything is clean In this case ignore any errors, 
	; we cannot "FAIL" the abort, the program being aborted is dead.
	;

	EnterCrit   critDisk
	invoke	FLUSHBUF
	LeaveCrit   critDisk

	;
	; Decrement open ref. count if we had done a virtual open earlier.
	;

	invoke	CHECK_VIRT_OPEN
	CLI
	MOV	BYTE PTR InDos,0	; Go to known state
	MOV	BYTE PTR [WPERR],-1	; Forget about WP error
	MOV	fAborting,0		; let aborts occur
	POP	WORD PTR ExitHold
	POP	WORD PTR ExitHold+2

	;
	; Snake into multitasking... Get stack from CurrentPDB person
	;

	MOV	DS,[CurrentPDB]
	ASSUME	DS:NOTHING
	MOV	SS,WORD PTR DS:[PDB_user_stack+2]
	MOV	SP,WORD PTR DS:[PDB_user_stack]

	ASSUME	SS:NOTHING
	restore_world			; use macro

	ASSUME	ES:NOTHING


	push	ax			; set up ds, but save ds in TEMPSEG 
	mov	ax, ds			; and not on stack.
	getdseg <ds>			; ds ->dosdata
	mov	TempSeg, ax
	pop	ax
					; set up ds to DOSDATA
	MOV	User_SP,AX

	POP	AX			; suck off CS:IP of interrupt...
	POP	AX
	POP	AX

; M011 : BEGIN

;	MOV	AX,0F202h		; STI

	LAHF
	XCHG	AH, AL
	AND	AL, 02
	MOV	AH, 0F2h

; M011 : END

	PUSH	AX

 
	PUSH	WORD PTR [EXITHOLD+2]
	PUSH	WORD PTR [EXITHOLD]

	MOV	AX,User_SP

	mov	ds,TempSeg		; restore ds
	assume	ds:NOTHING

	IRET				; Long return back to user terminate address
EndProc HardErr,NoCheck

;---------------------------------------------------------------------------
;
; Procedure Name : SET_I24_EXTENDED_ERROR
;
; This routine handles extended error codes.
; Input : DI = error code from device
; Output: All EXTERR fields are set
;
;--------------------------------------------------------------------------

Procedure SET_I24_EXTENDED_ERROR,NEAR
	PUSH	AX

					; ErrMap24End is in DOSDATA
	MOV	AX,OFFSET DOSDATA:ErrMap24End
	SUB	AX,OFFSET DOSDATA:ErrMap24

					; Change to dosdata to access 
					; ErrMap24 and EXTERR -SR
	push	ds
	getdseg <ds>			; ds ->dosdata

	;
	; AX is the index of the first unavailable error.  Do not translate 
	; if greater or equal to AX.
	;

	CMP	DI,AX
	MOV	AX,DI
	JAE	NoTrans

	MOV	AL,ErrMap24[DI]
	XOR	AH,AH
NoTrans:

	MOV	[EXTERR],AX
	pop	ds
	assume	ds:nothing
	POP	AX

	;
	; Now Extended error is set correctly.	Translate it to get correct 
	; error locus class and recommended action.
	;

	PUSH	SI

					; ERR_TABLE_24 is in DOSCODE 
	MOV	SI,OFFSET DOSDATA:ERR_TABLE_24
	invoke	CAL_LK			; Set other extended error fields
	POP	SI
	ret
EndProc SET_I24_EXTENDED_ERROR


;--------------------------------------------------------------------------
;
; Proc. name : dos_high
;
; ENTRY: CS = current doscode segment
; 
; EXIT: if CS >=F000 (DOS is in HMA)
;	   CY stc
;	else	     (DOS is LOW)
;	   NC clc	
;
; USED: nothing
;
;-------------------------------------------------------------------------
;
;public	dos_high
;dos_high	proc	near
;
;	push	ax
;	mov	ax, cs
;	cmp	ax, 0f000h		; Q: is current cs >= f000
;	pop	ax
;	cmc				; clc if dos is low
;					; stc if dos is high 
;	ret
;
;dos_high	endp
;

DOSCODE	ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msdata.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	SCCSID = @(#)ibmdata.asm	1.1 85/04/10
;
; DATA Segment for DOS.
;

.xlist
.xcref
include version.inc
include mssw.asm
include dosseg.inc
include dossym.inc
INCLUDE SF.INC
INCLUDE CURDIR.INC
INCLUDE DPB.INC
INCLUDE ARENA.INC
INCLUDE VECTOR.INC
INCLUDE DEVSYM.INC
INCLUDE PDB.INC
INCLUDE FIND.INC
INCLUDE MI.INC
include doscntry.inc
include fastopen.inc
include xmm.inc
.cref
.list

TITLE   IBMDATA - DATA segment for DOS
NAME    IBMDATA

installed = TRUE

include msbdata.inc			; M023
include msconst.asm
include const2.asm
include ms_data.asm
include dostab.asm
include lmstub.asm
include	wpatch.inc
include mpatch.asm
;WARNING: read comments in mpatch.asm before adding more data here! scottq
;hkn; include msinit.asm

	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msdosme.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;**	Standard device IO for MSDOS (first 12 function calls)
;


	.xlist
	.xcref
	include version.inc
        include mssw.asm
	include dosseg.inc
	.cref
	.list

	TITLE	IBMDOSMES - DOS OEM dependancies
	NAME	IBMDOSMES

include dosmes.inc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msdisp.asm ===
PAGE ,132
; ==========================================================================
;
;	TITLE	MS DOS DISPATCHER - System call dispatch code
;	NAME	DISP
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	System call dispatch code
;	System call entry points and dispatcher
;
; Revision History:
;
;	M004 - MS PASCAL 3.2 support. Please see under tag M003 in dossym.inc
;	       7/30/90. Also see under tag M009 in dossym.inc.
;
;	M007 - Modified Set_Ctrl_C_Trapping to support new GetVersion subfunc.
;		8/6/90
;
;	M042 - clear all bits of DOS34_FLAG except bit 11. See open.asm.
;	       10/26/90
;
;	M043 - initialize nss & nsp to user_ss and user_sp unconditionally.
;
;	M045 - do not do xchg bp,sp to save bp, as this prevents NMIs from
;	       being properly handled at this point. 
;
;	M068 - support for copy protected apps. Turn A20 off if count is 
;	       non-zero. Also dec count.
;
; ==========================================================================


.XLIST
.XCREF

INCLUDE version.inc
INCLUDE mssw.asm
INCLUDE dossym.inc
INCLUDE	devsym.inc			; M042
INCLUDE dosseg.inc
INCLUDE pdb.inc
INCLUDE vector.inc
INCLUDE syscall.inc
INCLUDE mi.inc
INCLUDE bugtyp.inc

.CREF
.LIST


AsmVars <Debug>

; ==========================================================================
; ==========================================================================

DosData SEGMENT

	EXTRN	AuxStack	:BYTE
	EXTRN	BootDrive	:BYTE
	EXTRN	ConSwap 	:BYTE
	EXTRN	CntCFlag	:BYTE
	EXTRN	CpswFlag	:BYTE
	EXTRN	CpswSave	:BYTE

;**RMFHFE**	EXTRN	Disk_Full	:BYTE

	EXTRN	DskStack	:BYTE
	EXTRN	ErrorMode	:BYTE
	EXTRN	ExtOpen_On	:BYTE
	EXTRN	Exterr_Locus	:BYTE
	EXTRN	FailErr 	:BYTE
	EXTRN	fSharing	:BYTE
	EXTRN	IdleInt 	:BYTE
	EXTRN	InDos		:BYTE
	EXTRN	IoStack 	:BYTE
	EXTRN	InterCon	:BYTE
	EXTRN	IsWin386	:BYTE
	EXTRN	NoSetDir	:BYTE
	EXTRN	Printer_Flag	:BYTE
	EXTRN	WpErr		:BYTE

	EXTRN	CurrentPDB	:WORD

	EXTRN	Dispatch	:WORD

	EXTRN	Dos34_Flag	:WORD
	EXTRN	Nsp		:WORD
	EXTRN	Nss		:WORD
	EXTRN	Proc_ID 	:WORD
	EXTRN	Restore_Tmp	:WORD
	EXTRN	SaveDS		:WORD
	EXTRN	SaveBX		:WORD
	EXTRN	User_In_AX	:WORD
	EXTRN	User_ID 	:WORD
	EXTRN	User_SP 	:WORD
	EXTRN	User_SS 	:WORD

	EXTRN	disa20_iret	:WORD
	EXTRN	A20OFF_COUNT	:BYTE		; M004
	extrn	DosHasHMA	:byte		; M021
	EXTRN	DOS_FLAG	:byte		; M068
	EXTRN	A20OFF_PSP	:word		; M068


IF	NOT IBM
EXTRN	OEM_HANDLER:DWORD
ENDIF

DosData ENDS

; ==========================================================================
; ==========================================================================


; ==========================================================================
; ==========================================================================

DosCode SEGMENT

	allow_getdseg

	EXTRN	MaxCall 	:ABS
	EXTRN	MaxCom		:ABS

IF	DEBUG
	INCLUDE scnam.inc
ENDIF

	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

;M007 - New version of this routine
; ==========================================================================
;
; $Set_CTRL_C_Trapping
;
; Function:
;	Enable disable ^C checking in dispatcher
;
; Inputs:
;		AL = 0 read ^C status
;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
;		AL = 2 Set ^C status to contents of DL.	Output is old state.
;		AL = 5 get DOS boot drive
;		AL = 6 Get version number
;			RETURNS:
;				BH = Minor version number
;				BL = Major version number
;				DL = DOS internal revision
;				DH = DOS type flags
;					Bit 3 	- DOS in ROM
;					Bit 4 	- DOS in HMA
;					Bit 0-2, 5-7 - Reserved
; Outputs:
;		If AL = 0 then DL = 0/1 for ^C off/on
;
; History:
;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
; ==========================================================================
	PUBLIC $Set_Ctrl_C_Trapping
$Set_Ctrl_C_Trapping PROC NEAR
	ASSUME	SS:NOTHING

	cmp	AL, 6			; Is this a valid subfunction?
	jbe	scct_1			; If yes continue processing

	mov	AL, 0ffh		; Else set AL to -1 and

	iret

scct_1:
	push	DS

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	
	push	AX			; DL only register that can change
	push	SI

	mov	SI, OFFSET CntCFlag	; DS:SI --> Ctrl C Status byte
	xor	AH, AH			; Clear high byte of AX
	or	AX, AX			; Check for subfunction 0
	jnz	scct_2			; If not 0 jmp to next check

	mov	DL, [SI]		; Else move current ctrl C status
	jmp	SHORT scct_9s		; into DL and jmp to exit

scct_2:
	dec	AX			; Now dec AX and see if it was 1
	jnz	scct_3			; If not 0 it wasn't 1 so do next chk

	and	DL, 1			; Else mask off bit 0 of DL and
	mov	[SI], DL		; save it as new Ctrl C status
	jmp	SHORT scct_9s		; Jmp to exit

scct_3:
	dec	AX			; Dec AX again to see if it was 2
	jnz	scct_4			; If not 0 wasn't 2 so go to next chk

	and	DL, 1			; Else mask off bit 0 of DL and
	xchg	[SI], DL		; Exchange DL with old status byte
	jmp	SHORT scct_9s		; Jump to exit (returning old status)

scct_4:
	cmp	AX,3 			; Test for 5 after it was dec twice
	jne	scct_5			; If not equal then not get boot drv
	mov	DL, BootDrive		; Else return boot drive in DL
	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)

scct_5:
	cmp	AX,4 			; Test for 6 after it was dec twice
	jne	scct_9s			; If not equal then not get version
	
	mov	BX,(Minor_Version SHL 8) + Major_Version
	mov	DL, DOSREVNM

	xor	dh, dh			; assume vanilla DOS
	cmp	[DosHasHMA], 0		; is DOS in HMA?  (M021)
	je	@F
	or	DH, DOSINHMA
@@:

ifdef ROMDOS
	or	DH, DOSINROM
endif ; ROMDOS

scct_9s:
	pop	SI
	pop	AX
	pop	DS

scct_9f:
	iret

;M007 end

SetCtrlShortEntry:			; This allows a conditional entry
					; from main dispatch code
	jmp	SHORT $Set_Ctrl_C_Trapping

$Set_Ctrl_C_Trapping ENDP

; ==========================================================================
;									   ;
; The following two routines are dispatched to directly with ints disabled
; immediately after the int 21h entry.	no DIS state is set.
;
; $Set_current_PDB takes BX and sets it to be the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

	PUBLIC	$Set_Current_PDB
$Set_Current_PDB PROC NEAR
	ASSUME	SS:NOTHING

	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	CurrentPDB,BX		; Set new PSP segment from caller's BX
	pop	DS
	iret

EndProc $Set_Current_PDB

; ==========================================================================
;
; $get_current_PDB returns in BX the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

	PUBLIC $Get_Current_PDB
$Get_Current_PDB PROC NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	BX,CurrentPDB		; Return current PSP segment in BX
	pop	DS
	iret

$Get_Current_PDB ENDP

; ==========================================================================
;
; Sets the Printer Flag to whatever is in AL.
; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
;
; ==========================================================================

	PUBLIC $Set_Printer_Flag
$Set_Printer_Flag PROC NEAR
	ASSUME	SS:NOTHING

	push	ds
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	Printer_Flag,AL 	; Set printer flag from caller's AL
	pop	ds
	iret

$Set_Printer_Flag ENDP

; ==========================================================================
;
; The Quit entry point is where all INT 20h's come from.  These are old- style
; exit system calls.  The CS of the caller indicates which Process is dying.
; The error code is presumed to be 0.  We simulate an ABORT system call.
;
; ==========================================================================

	PUBLIC	System_Call
System_Call PROC NEAR

	PUBLIC Quit
Quit:						; entry	QUIT
	xor	AH,AH
	jmp	SHORT SavRegs

	; The system call in AH is out of the range that we know how
	; to handle. We arbitrarily set the contents of AL to 0 and
	; IRET. Note that we CANNOT set the carry flag to indicate an
	; error as this may break some programs compatability.

BadCall:
	xor	AL,AL

	PUBLIC Irett
Irett:
	iret

	; An alternative method of entering the system is to perform a
	; CALL 5 in the program segment prefix with the contents of CL
	; indicating what system call the user would like. A subset of
	; the possible system calls is allowed here only the
	; CPM-compatible calls may get dispatched.


	PUBLIC Call_Entry		; entry   Call_Entry
Call_Entry:				; System call entry point and dispatcher
	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	pop	SaveDs			; Save original DS

	pop	AX			; IP from the long call at 5
	pop	AX			; Segment from the long call at 5
	pop	User_SP 		; IP from the CALL 5

					; Re-order the stack to simulate an
					; interrupt 21.
	pushf				; Start re-ordering the stack
	cli
	push	AX			; Save segment
	push	User_SP 		; Stack now ordered as if INT used

	push	SaveDS
	pop	DS

	ASSUME	DS:NOTHING

	cmp	CL,MaxCall		; Max old style CPM call number

	ja	BadCall 		

	mov	AH,CL
	jmp	SHORT SavRegs

	; This is the normal INT 21 entry point. We first perform a
	; quick test to see if we need to perform expensive DOS-entry
	; functions. Certain system calls are done without interrupts
	; being enabled.


	entry	COMMAND 		; Interrupt call entry point (int 21h)

IF	NOT IBM

	cmp	AH,SET_OEM_HANDLER
	jb	@F

	jmp	$Set_Oem_Handler

@@:

ENDIF
	cli

	cmp	AH,MaxCom		; Max int 21h function call number
	ja	BadCall

	; The following set of calls are issued by the server at
	; *arbitrary* times and, therefore, must be executed on
	; the user's entry stack and executed with interrupts off.

SAVREGS:

	cmp	AH,SET_CTRL_C_TRAPPING	; Check Minimum special case #
	jb	SaveAllRegs		; Not special case so continue
	jz	SetCtrlShortEntry

	cmp	AH,SET_PRINTER_FLAG	; Check Max case number
	ja	SaveAllRegs		; Not special case so continue
	jz	$Set_Printer_Flag	; If equal jmp directly to function

	cmp	AH,GET_CURRENT_PDB	; Is this a Get PSP call (51h)?
	jz	$Get_Current_PDB	; Yes, jmp directly to function

	cmp	AH,GETCURRENTPSP	; Is this a Get PSP call (62h)?
	jz	$GET_CURRENT_PDB	; Yes, jmp directly to function

	cmp	AH,SET_CURRENT_PDB	; Is this a Set PSP call (50h) ?
ifndef ROMDOS
	jz	$Set_Current_PDB	; Yes, jmp directly to function
else
	; fucking jump out of range by *two* bytes!
	jnz	@f
	jmp	$Set_Current_PDB
@@:
endif

SaveAllRegs:
	push	ES
	push	DS
	push	BP
	push	DI
	push	SI
	push	DX
	push	CX
	push	BX
	push	AX

	mov	AX,DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	SaveDS, AX		; save caller's DS
	mov	SaveBX,BX


	; M043
	; Note: Nsp and Nss have to be unconditionally initialized here 
	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
	; this!!!
	;

	mov	AX,User_SP		; Provide one level of reentrancy for
	mov	Nsp,AX			; int 24 recallability.
	mov	AX,User_SS
	mov	Nss,AX

	xor	AX,AX
	mov	fSharing,AL		; allow redirection

	test	IsWIN386,1		; WIN386 patch. Do not update USER_ID
	jnz	@F			; if win386 present
	mov	User_Id,AX
@@:
	inc	InDos			; Flag that we're in the DOS

	mov	User_SP,SP		; Save user's stack
	mov	User_SS,SS

	mov	AX,CurrentPDB
	mov	Proc_Id,AX
	mov	DS,AX
	pop	AX
	push	AX

	ASSUME	DS:NOTHING
	mov	WORD PTR DS:PDB_User_stack,SP	; for later returns (possibly
	mov	WORD PTR DS:PDB_User_stack+2,SS ; from EXEC)

	getdseg	<ss>			; ss -> dosdat,  already flag is CLI

	PUBLIC	Redisp
Redisp: 				; Entry REDISP

	mov	SP,OFFSET DosData:AuxStack ; Enough stack for interrupts
	sti				; stack is in our space now...


	IFDEF  DBCS				
		mov	BH, BYTE PTR DS:PDB_InterCon	; Get interim mode
		mov	SS:InterCon, BH        		
	ENDIF

	mov	BX,SS
	mov	DS,BX

	xchg	BX,AX

	xor	AX,AX

;**RMFHFE**	mov	Disk_Full,AL		; No disk full

	mov	ExtOpen_On,AL		; Clear extended open flag

;;	mov	Dos34_Flag,AX		; Clear common flag
	and	DOS34_Flag, EXEC_AWARE_REDIR
					; M042: clear all bits except bit 11

	mov	ConSwap,AL		; random clean up of possibly mis-set flags
	mov	BYTE PTR NoSetDir,AL	; set directories on search
	mov	BYTE PTR FailErr,AL	; FAIL not in progress

	inc	AX 			; AL = 1
	mov	IdleInt,AL		; presume that we can issue INT 28

	xchg	AX,BX			; Restore AX and BX = 1

	mov	BL,AH
	shl	BX,1			; 2 bytes per call in table

	cld
		; Since the DOS maintains mucho state information across system
		; calls, we must be very careful about which stack we use.
		; First, all abort operations must be on the disk stack. This
		; is due to the fact that we may be hitting the disk (close
		; operations, flushing) and may need to report an INT 24.

	or	AH,AH
	jz	DskROut 		; ABORT

		; Second, PRINT and PSPRINT and the server issue
		; GetExtendedError calls at INT 28 and INT 24 time.
		; This call MUST, therefore, use the AUXSTACK.

	cmp	AH,GetExtendedError
	jz	DISPCALL

		; Old 1-12 system calls may be either on the IOSTACK (normal
		; operation) or on the AUXSTACK (at INT 24 time).

	cmp	AH,12
	ja	DskROut
	cmp	ErrorMode,0		; Are we in an INT 24?
	jnz	DispCall		; Stay on AUXSTACK if INT 24.
	mov	SP,OFFSET DosData:IoStack
	jmp	SHORT DispCall

		; We are on a system call that is classified as "the rest".
		; We place ourselves onto the DSKSTACK and away we go.	We
		; know at this point:
		;
		; o  An INT 24 cannot be in progress.  Therefore we reset
		;    ErrorMode and WpErr
		; o  That there can be no critical sections in effect. We
		;    signal the server to remove all the resources.

DskROut:
	mov	User_In_AX,AX		; Remember what user is doing
	mov	ExtErr_Locus,ErrLoc_Unk ; Default
	mov	ErrorMode,0		; Cannot make non 1-12 calls in
	mov	WpErr,-1		; error mode, so good place to make

	push	AX			; Release all resource information
	mov	AH,82h
	int	Int_IBM
	pop	AX


		; Since we are going to be running on the DSKStack and since
		; INT 28 people will use the DSKStack, we must turn OFF the
		; generation of INT 28's.

	mov	IdleInt,0
	mov	SP,OFFSET DosData:DskStack
	test	CntCFlag,-1
	jz	DispCall		; Extra ^C checking is disabled
	push	AX
	invoke	DskStatChk
	pop	AX

DispCall:
	mov	BX,CS:Dispatch[BX]
	xchg	BX,SaveBX
	mov	DS,SaveDS

    ASSUME  DS:NOTHING

	if	DEBUG
		call	PrintCall		; debug print system call
	endif

	call	SS:SaveBX

	;
	; M068
	;
	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
	; here. Please see under M003, M009 and M068 tags in dossym.inc
	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
	; return to LeaveDos and hence will not clear this bit. This is 
	; because this bit is used to indicate to the next int 21 call that
	; the previous int 21 was an exec.
	;
	; So do not add any code between the call above and the label 
	; LeaveDOS if it needs to be executed even for ax=4b05
	;

	and	[DOS_FLAG], NOT EXECA20OFF


	PUBLIC	LeaveDos		; Exit from a system call.
LeaveDos:

	ASSUME	SS:NOTHING		; User routines may misbehave
	cli

	if	DEBUG
		call	PrintRet
	endif

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg

					; M004, M068
  	cmp	[A20OFF_COUNT], 0	; M068: Q: is count 0
	jne	disa20			; M068: N: dec count and turn a20 off
 
LeaveA20On:
	dec	InDos
	mov	SS,User_SS
	mov	SP,User_SP
	mov	BP,SP
	mov	BYTE PTR [BP.User_AX],AL
	mov	AX,Nsp
	mov	User_SP,AX
	mov	AX,Nss
	mov	User_SS,AX

	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
	pop	ES
	iret

disa20:	   				; M068 - Start
	mov	bx, [A20OFF_PSP]	; bx = PSP for which a20 to be off'd
	cmp	bx, [CurrentPDB]	; Q: do the PSP's match
	jne	LeaveA20On		; N: don't clear bit and don't turn 
					;    a20 off
					; Y: turn a20 off and dec a20off_count
	dec	[A20OFF_COUNT]		; M068 - End
 
					; Start - M004
	push	ds			; segment of stub
	mov	bx, offset disa20_iret	; offset in stub
	push	bx
	retf	  			; go to stub
					; End - M004

	

System_Call ENDP

; ==========================================================================
;
; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
; the stack prior to giving the user control
;
; ==========================================================================

procedure Restore_User_World,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	pop	restore_tmp
	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS

	jmp	Restore_Tmp

EndProc restore_User_world

; ==========================================================================
;
; Save_World saves complete registers on the stack
;
; ==========================================================================

procedure Save_User_World ,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	pop	restore_tmp

	push	DS
	push	BP
	push	DI
	push	SI
	push	DX
	push	CX
	push	BX
	push	AX

	push	restore_tmp

;	cli				; M045 - start
;	xchg	BP, SP
;	mov	ES, [BP+18]
;	assume	ES:NOTHING
;	xchg	SP,BP
;	sti

	push	BP		
	mov	BP, SP
	mov	ES, [BP+20]		; es was pushed before call
	assume	ES:NOTHING
	pop	BP			; M045 - end

	ret

EndProc save_user_world

; ==========================================================================
;
; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
;
; ==========================================================================

procedure Get_User_Stack,NEAR

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	lds	SI,DWORD PTR User_SP
	return

EndProc Get_User_Stack

; ==========================================================================
;
; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
; Inputs:
;	User registers, User Stack, INTS disabled
;	If CALL F8, DS:DX is new handler address
; Function:
;	Process OEM INT 21 extensions
; Outputs:
;	Jumps to OEM_HANDLER if appropriate
;
; ==========================================================================
IF	NOT IBM

$Set_Oem_Handler:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING


	push	es
	getdseg	<es>			; es -> dosdata

	jne	Do_Oem_Func		; If above F8 try to jump to handler
	mov	WORD PTR Oem_Handler,DX ; Set Handler
	mov	WORD PTR Oem_Handler+2,DS

	pop	ES
	iret				; Quick return, Have altered no registers


DO_OEM_FUNC:
	cmp	WORD PTR Oem_Handler,-1
	jnz	Oem_Jmp

	pop	ES
	jmp	BadCall 		; Handler not initialized

OEM_JMP:
	push	ES
	pop	DS
	pop	ES

	ASSUME	DS:DosData

	jmp	Oem_Handler

ENDIF



; ==========================================================================
;
;	PrintCall - Debug Printout of System Call
;
;	If system call printout is turned on, print
;
;	S:<name> ax bx cx dx si di bp ds es
;
;	ENTRY	registers as from user program
;	EXIT	none
;	USES	flags
;
; ==========================================================================

IF DEBUG

	ASSUME	DS:nothing,ES:nothing,SS:DOSDATA
	DPUBLIC PrintCall
PrintCall PROC	Near

	test	BugTyp,TypSyscall
	retz
					; Going to print the sucker out.
					; Lookup the name string
	SAVE	<BX>
	sub	BX,BX
	mov	BL,AH
	add	BX,BX
	mov	BX,scptrs[BX]		; (cs:bx) = address of name string
	FMT	TypSyscall, LevLog, <"S:$S">,<cs, bx>
	RESTORE <BX>
	FMT	TypSyscall, LevLog, <"  a-d=$x $x $x $x">,<AX,BX,CX,DX>
	FMT	TypSyscall, LevLog, <" sd=$x $x de=$x $x\n">,<si,di,ds,es>
prcalx: ret

PrintCall ENDP

; ==========================================================================
;
;	PrintRet - Debug Printout of System Call Return
;
;	If system call printout is turned on, print
;
;	"  OK: ax bx cx dx si di"   -or-
;	"  ERROR:  ax bx cx dx si di"
;
;	ENTRY	registers as from user program
;	EXIT	none
;	USES	none
; ==========================================================================

	DPUBLIC PrintRet

	ASSUME	DS:nothing,ES:nothing,SS:nothing
PrintRet PROC	NEAR
	pushf

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg

	test	BugTyp,TypSyscall
	LJZ	pretx

	SAVE	<ds, si>		; Am to print return code
	call	Get_User_Stack

	ASSUME DS:nothing

	test	[SI.user_F],f_Carry	; signal carry to user
	jnz	pret2			; have error
	FMT	TypSyscall, LevLog, <"  OK: ">
	jmp	SHORT Pret4

Pret2:	FMT	TypSyscall, LevLog, <"  ERROR: ">

Pret4:	FMT	TypSyscall, LevLog, <" $x $x $x">,<User_AX[si],User_BX[si],User_CX[si]>
	FMT	TypSyscall, LevLog, <" $x $x $x\n">,<User_DX[si],User_SI[si],User_DI[si]>
	RESTORE <SI, DS>
Pretx:	popf
	ret

PRINTRET ENDP

endif

; ==========================================================================

DOSCODE    ENDS

; ==========================================================================

	END

; ==========================================================================




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msinit.asm ===
;**	msinit.asm -- ms-dos initialization code
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;
;	an000 version 4.0 jan. 1988
;	an007 ptm 3957 - fake version for ibmcache.com
;	an008 ptm 4070 - fake version for ms windows
;
;
;
;
;
;	Revision History
;	================
;
;	M019	SR	08/30/90	Changed number of instance items for
;				Win 3.1 UMB support.
;
; 	M020 : Fix for Rational bug for details see exepatch.asm
;
;	M023	SR	09/7/90	Initialize exepatch & Rational patch
;				ptrs here. Previous init in lmstub.asm
;				causes extrn problems when msdata is
;				linked in by other utilities e.g.Share
;
;	M068 - support for copy protected apps.
;
;	M079 - skip block device drivers which return 0 units
;

	.xlist
	.xcref
	include version.inc
	include dossym.inc
	include mssw.asm
	include dosseg.inc
	include sf.inc
	include curdir.inc
	include dpb.inc
	include arena.inc
	include vector.inc
	include devsym.inc
	include pdb.inc
	include find.inc
	include mi.inc
	include xmm.inc
	installed = true


	include sysvar.inc
	include doscntry.inc
	include fastopen.inc
	include bugtyp.inc
	include	cputype.inc			; M020

	include win386.inc	;Win386 constants

	.cref
	.list




BData	segment	at 70h

	extrn	DosDataSg:word		; using this to access the data seg

ifdef ROMDOS
	extrn	DOS_Res:word
endif

BData	ends

;
; This macro gets the DOS data segment value and puts it in the specified
; segment register.  This is the init segment version of GetDseg in dosmac
;

InitGetdseg	macro 	r

ifdef ROMDOS
	mov	r, cs:[InitBioDataSeg]
	assume	r:bdata
	mov	r, r:[DosDataSg]
else
	mov	r, cs:[DosDseg]
endif
	assume	r:dosdata
endm




DOSDATA SEGMENT

	extrn	dmaadd:dword		; current dma address
	extrn	DPBHead:dword		; long pointer to dpb chain
	extrn	sft_addr:dword		; pointer to open file list
	extrn	numio:byte		; number of physical drives
	extrn	buffhead:dword		; pointer to buffer chain
	extrn	endmem:word		; first unavailable address in memory
	extrn	currentpdb:word 	; current process id
	extrn	createpdb:byte		; true => create a new pdb
	extrn	arena_head:word 	; paragraph address of head of arena
	extrn	sftabl:byte		; internal file table
	extrn	sysinitvar:byte 	; label for internal structures
	extrn	nuldev:dword		; long pointer to device chain
	extrn	bcon:dword		; pointer to console device
	extrn	bclock:dword		; pointer to clock device
	extrn	callunit:byte		; unit field in dd packet
	extrn	callbpb:dword		; returned bpb from dd
	extrn	maxsec:word
	extrn	dskchret:byte
	extrn	devcall:byte
	extrn	jshare:dword
	extrn	country_cdpg:byte	 ; country info table, dos 3.3
	extrn	sysinittable:byte	 ; sys init table for sysinit
	extrn	fastopentable:byte	 ; table for fastopen
	extrn	special_entries:word	 ; address of special entries ;an007;
	extrn	hashinitvar:word	 ; hash table variables       ;an000;
	extrn	packet_temp:word	 ; used for initial hash table;an000;


	extrn	user_ss:word
	extrn	user_sp:word

	extrn	msdat001e:byte		; end of dosdata segment
	extrn	msct001s:byte		; start of dosdata segment	

	extrn	XMMcontrol:dword	; entry into BIOS xmm driver
	extrn	dosinttable:dword	; int vec table for DOS

	extrn	dskstack:byte
	extrn	temp_dosloc:word	; stores the temp. location of DOS seg

;SR;
; WIN386 instance table variables
;
	extrn	Win386_Info:byte, Instance_Table:word

;
;Win386 2.xx instance table
;
	extrn	OldInstanceJunk: word


	extrn	i0patch:word
	extrn	i20patch:word
	extrn	i21patch:word
	extrn	i25patch:word
	extrn	i26patch:word
	extrn	i27patch:word
	extrn	i2fpatch:word
	extrn	cpmpatch:word
	extrn	BiosDataPtr:dword	;ptr to BIOS data exchange block
	extrn	DosHasHMA:byte		; M021
	extrn	RationalPatchPtr:word	; M020
	extrn	fixexepatch:word
	extrn	Rational386PatchPtr:word
	extrn	ChkCopyProt:word	; M068

IFDEF	ROMDOS
	extrn	I20To28Count:word
ENDIF

DOSDATA ENDS


DOSCODE	SEGMENT

	extrn	irett:near
	extrn	int2f:near
	extrn	call_entry:near
	extrn	quit:near
	extrn	command:near
	extrn	absdrd:near
	extrn	absdwrt:near
	extrn	divov:near
	extrn	stay_resident:near

	extrn	lirett:near
	extrn	lint2f:near
	extrn	lcall_entry:near
	extrn	lquit:near
	extrn	lcommand:near
	extrn	labsdrd:near
	extrn	labsdwrt:near
	extrn	ldivov:near
	extrn	lstay_resident:near

	extrn	$startcode:word
	extrn	header:byte


	extrn	exepatch:near		; Routine in exepatch.asm
	extrn	exepatch_start:byte	; in exepatch.asm
	extrn	RationalPatch:near	; M020
	extrn	RetExePatch:near	; M023
	extrn	IsCopyProt:near 	; M068
	extrn	Rational386Patch:near

ifndef	ROMDOS
	extrn	LowInt23Addr:dword
	extrn	LowInt24Addr:dword	
	extrn	LowInt28Addr:dword

	extrn	dosdseg:word		; used by InitGetDseg macro
endif

;
; When using ROMDOS, init code is not in the DOSCODE segment.  Therefore,
; we need some entry points in DOSCODE to allow far calls to be made to
; certain routines in the DOS.  These just do a near call to the appropriate
; routine, and then do a far return back to the init code.
;
ifdef	ROMDOS

$setdpb_far	proc	far
	invoke	$setdpb
	ret
$setdpb_far	endp

setmem_far	proc	far
	invoke	setmem
	ret
setmem_far	endp

deviocall2_far	proc	far
	invoke	deviocall2
	ret
deviocall2_far	endp

endif ; ROMDOS

	public	sysbuf

sysbuf	label	word

	ASSUME	cs:doscode,ds:nothing,es:nothing,ss:nothing


; ROMDOS Note:  For RomDos, all the initialization stuff goes into
; the segment DOSINITSEG instead of DOSCODE.  The entry point from
; the BIOS will actually be right here.

ifdef ROMDOS

DOSCODE		ENDS

DOSINITSEG	segment

	assume	cs:dosinitseg

	jmp	SHORT DosInit		; jump down to the starting point

; We need to make some far calls from here to the DOS code, but we're not
; sure where it will be.  There are some special far entry points into
; the DOS (see above), so we need to set up some far pointer to them so
; that we can make the calls.  The segment parts of these pointers will
; be patched in at runtime (below).

$setdpb_ptr	dd	offset doscode:$setdpb_far
setmem_ptr	dd	offset doscode:setmem_far
deviocall2_ptr	dd	offset doscode:deviocall2_far


endif ; ROMDOS


; temp iret instruction

initiret:				
	iret

; pointer to the BIOS data segment that will be available just to the
; initialization code

InitBioDataSeg	dw	70H


; Convert AX from a number of bytes to a number of paragraphs (round up).
ParaRound	proc	near
	add	ax, 15
	rcr	ax, 1
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	ret
ParaRound	endp


;
; MAIN ENTRY FOR DOS INITIALIZATION
;

	ENTRY	DosInit

	cli
	cld

	push	dx			; save parameters from BIOS
	push	si
	push	ds
	push	di			;save di (ptr to BiosComBlock)
	mov	bx,es			;bx:di = ptr to BiosComBlock


; First, move the DOS data segment to its final location in low memory

	mov	ax, offset memstrt	; get offset of end of init code

	add	ax, 15			; round to nearest paragraph
	and	ax, not	15		; boudary

	mov	si, ax			; si = offset of DOSDATA in current 
					; code segment
	mov	ax, cs
	mov	ds, ax			; ds = current code segment
					; DS:SI now points to dosdata

	mov	es, cs:[InitBioDataSeg]	; First access to DosDataSg in
					;  BData segment. Cannot use
					;  getdseg macro here!!!
	assume	es:BData
	mov	es, es:[DosDataSg]	; Get free location in low memory
	assume	es:nothing
	xor	di, di			; ES:DI now points to RAM data

	mov	cx, offset MSDAT001e	; get end of dosdata = size of dosdata
	rep	movsb			; move data to final location
	

	pop	di			;restore ptr to BiosComBlock
	pop	ds			; restore parms from BIOS
	pop	si
	pop	dx	

	push	es
	push	ds
	pop	es			; es:si -> device chain
	pop	ds			; ds points to dosdata

	assume	ds:dosdata

;SR;
;We get a ptr to the BIOS exchange data block. This has been setup right 
;now so that the EXEC call knows when SysInit is present to do the special
;lie table handling for device drivers. This can be expanded later on to
;establish a communication block from the BIOS to the DOS.
;

	mov	word ptr BiosDataPtr,di
	mov	word ptr BiosDataPtr+2,bx	;save ptr to BiosComBlock

ifndef ROMDOS

	mov	[dosdseg], ds		; set pointer to dosdata in code seg

	;
	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
	;

	mov	word ptr [LowInt23Addr+2], ds	; set pointers in code seg
	mov	word ptr [LowInt24Addr+2], ds
	mov	word ptr [LowInt28Addr+2], ds

endif ; ROMDOS

	mov	[endmem],dx
	mov	[user_sp],sp
	mov	[user_ss],ss

	mov	ax,ds			; set up ss:sp to dosdata:dskstack
	mov	ss,ax
	assume	ss:dosdata

	mov	sp,offset dosdata:dskstack

;M023
; Init patch ptrs to default values
;
	mov	FixExePatch, offset DOSCODE:RetExePatch		; M023
	mov	[RationalPatchPtr], offset DOSCODE:RetExePatch 	; M023
	mov	[ChkCopyProt], offset DOSCODE:RetExePatch	; M068

; Setup to call 386 Rational DOS Extender patch routine if running on
; a 386 or later.  Unlike other patches, this is not dependent on MS-DOS
; running in the HMA.

	call	WhatCPUType		; get cpu type (0 < 286,1==286,2 >= 386)
	cmp	al, 2			;   386 or later?

	mov	ax, offset DOSCODE:Rational386Patch
	jae	di_set_patch
	mov	ax, offset DOSCODE:RetExePatch	; < 386, don't need this patch

di_set_patch:
	mov	[Rational386PatchPtr], ax	; patch routine or RET instr.

	; Set up the variable temp_dosloc to point to the dos code segment

ifndef ROMDOS
	mov	ax, cs			; ax = current segment of DOS code
else
	push	es			; preserve es sent from BIOS
	mov	es, [InitBioDataSeg]	; get seg of bios data in ES
	mov	ax, es:[DOS_Res]	; get DOS resident code segment (ROM)
	pop	es			; restore es sent from BIOS

	; fix up far pointers to procedures in DOS code

	mov	word ptr [$setdpb_ptr+2], ax
	mov	word ptr [setmem_ptr+2], ax
	mov	word ptr [deviocall2_ptr+2], ax

endif ; ROMDOS
	; ax now holds segment of DOS code
	mov	[temp_dosloc], ax	; store temp location of DOS


	mov	word ptr [nuldev+2],es 	; nuldev -> points to device chain
	mov	word ptr [nuldev],si   

;SR;
; There are some locations in the Win386 instance data structures
; which need to be set up with the DOS data segment.  First, initialize
; the segment part of the instance table pointer in the SIS.

	mov	word ptr [Win386_Info + SIS_Instance_Data_Ptr + 2], ds

; Now initialize the segment part of the pointer to the data in each
; instance table entry.

	push	si			; preserve pointer to device chain
	mov	cx, 7		; There are 7 entries in the instance table
				; M019
	mov	si, (offset dosdata:Instance_Table) + 2	; point si to segment field
Instance_init_loop:
	mov	word ptr ds:[si], ds	; set offset in instance entry
	add	si, (size Win386_IIS)	; move on to next entry
	loop	Instance_init_loop
	
;
;Initialize the WIN386 2.xx instance table with the DOS data segment value
;
	mov	cx, 5		; There are five entries in the instance table
	mov	si, (offset dosdata:OldInstanceJunk) + 6
				; point si to segment field
OldInstance_init_loop:
	mov	word ptr ds:[si], ds	; set offset in instance entry
	add	si, 6		; move on to next entry
	loop	OldInstance_init_loop
	pop	si			; restore pointer to device chain
;
;End of WIN386 2.xx compatibility bullshit
;


	push	es
	pop	ds
	assume	ds:nothing		; ds:si points to console device


	; need crit vector inited to use deviocall
	push	ds			; preserve segment of device chain
	xor	ax,ax
	mov	ds,ax			; point DS to int vector table
	mov	ax,offset initiret
	mov	ds:[addr_int_ibm],ax
	mov	ax,cs
	mov	ds:[addr_int_ibm+2],ax
	pop	ds			; restore segment of device chain

	call	charinit  		; initialize console driver
	push	si			; save pointer to header

	push	ss			; move pointer to dos data...
	pop	es			; ...into ES
	assume	es:dosdata

	;initialize sft for file 0 (CON)

	mov	di,offset dosdata:sftabl + sftable   
	mov	ax,3
	stosw				; refcount
	dec	al
	.errnz	sf_mode-(sf_ref_count+2)
	stosw				; access rd/wr, compatibility
	xor	al,al
	.errnz	sf_attr-(sf_mode+2)
	stosb				; attribute
	mov	al,devid_device_eof or devid_device or iscin or iscout
	.errnz	sf_flags-(sf_attr+1)
	stosw				; flags
	mov	ax,si
	.errnz	sf_devptr-(sf_flags+2)
	stosw				; device pointer in devptr
	mov	ax,ds
	stosw
	xor	ax,ax
	.errnz	sf_firclus-(sf_devptr+4)
	stosw				; firclus
	.errnz	sf_time-(sf_firclus+2)
	stosw				; time
	.errnz	sf_date-(sf_time+2)
	stosw				; date
	dec	ax
	.errnz	sf_size-(sf_date+2)
	stosw				; size
	stosw
	inc	ax
	.errnz	sf_position-(sf_size+4)
	stosw				; position
	stosw
	add	di,sf_name - sf_cluspos ; point at name
	add	si,sdevname		; point to name
	mov	cx,4
	rep	movsw			; name
	mov	cl,3
	mov	al," "
	rep	stosb			; extension
	pop	si			; get back pointer to header

					; mark device as CON I/O
	or	byte ptr [si.sdevatt],iscin or iscout
	mov	word ptr [bcon],si
	mov	word ptr [bcon+2],ds

	; initialize each device until the clock device is found

char_init_loop:
	lds	si,dword ptr [si]	; aux device
	call	charinit
	test	byte ptr [si.sdevatt],isclock
	jz	char_init_loop
	
	mov	word ptr [bclock],si	; bclock -> clock device
	mov	word ptr [bclock+2],ds

					; bp = pointer to free mem
	mov	bp,offset MSDAT001e	; es:bp points to dpb area

	mov	word ptr [DPBHead], bp	; set offset of pointer to DPB's
	mov	word ptr [DPBHead+2], es; set segment of pointer to DPB's

	; build dpb for each unit in each block device

perdrv:
	lds	si,SDEVNEXT [si]	; next device
	cmp	si,-1			; Q: any more devices
	je	continit		;  N: goto continit
	call	charinit		;  Y: initialize the device
	test	[si.sdevatt],devtyp	; Q: is it a block device
	jnz	perdrv			; skip any other character devs
	mov	cl,[callunit]
	xor	ch,ch
IFDEF	ROMDOS
	jcxz	perdrv			; skip to next dev if 0 units	; M079
ENDIF ; ROMDOS
	mov	[si.sdevname],cl	; number of units in name field
	mov	dl,numio		; dl is drive # for dpb
	xor	dh,dh			; dh is unit # for dpb
	add	numio,cl		; adjust total block device count
	push	ds			; save pointer to device header
	push	si
	lds	bx,callbpb		; ds:bx -> bpb array
perunit:
	mov	si,[bx] 		; ds:si points to bpb
	inc	bx
	inc	bx			; on to next bpb
	mov	es:[bp].DPB_DRIVE,dl
	mov	es:[bp].DPB_UNIT,dh
	push	bx			; save regs of interest while building
	push	cx
	push	dx
ifndef ROMDOS
	invoke	$setdpb			; build DPB!
else
	call	dword ptr [$setdpb_ptr]	; call $setdpb in DOSCODE
endif ; ROMDOS
	mov	ax,es:[bp].DPB_SECTOR_SIZE
	cmp	ax,maxsec		; Q:is this the largest sector so far
	jbe	notmax			; N:
	mov	maxsec,ax		; Y: save it in maxsec
notmax:

					; set the next dpb field in the 
					; currently built bpb and mark as 
					; never accessed

	mov	ax, bp			; get pointer to DPB
	add	ax, DPBSIZ		; advance pointer to next DPB
					; set seg & offset of next DPB
	mov	word ptr es:[bp].DPB_NEXT_DPB, ax
	mov	word ptr es:[bp].DPB_NEXT_DPB+2, es
					; mark as never accessed
	mov	es:[bp].DPB_FIRST_ACCESS, -1

	pop	dx			; restore regs
	pop	cx
	pop	bx
	mov	ax,ds			; save segment of bpb array
	pop	si			
	pop	ds			; ds:si -> device header
					; store it in the corresponding dpb
	mov	word ptr es:[bp].DPB_DRIVER_ADDR,si
	mov	word ptr es:[bp].DPB_DRIVER_ADDR+2,ds
	
	push	ds			; save pointer to device header
	push	si
	inc	dh			; inc unit #
	inc	dl			; inc drive #
	mov	ds,ax			; restore segment of BPB array
	add	bp,DPBSIZ		; advance pointer to next dpb
	loop	perunit			; process all units in each driver

	pop	si			; restore pointer to device header
	pop	ds
	jmp	perdrv			; process all drivers in chain

continit:
					; set link in last DPB to -1
	sub	bp,DPBSIZ		; back up to last dpb
					; set last link offset & segment
	mov	word ptr [bp].DPB_NEXT_DPB,-1
	mov	word ptr [bp].DPB_NEXT_DPB+2,-1
	add	BP, DPBSIZ		; advance to free memory again
					; the DPB chain is done.  

;M060;	; let's compute the length of the version_fake_table
;M060;
;M060;	mov	si,offset version_fake_table	
;M060;	mov	dx,si		     	; dx = start of version table
;M060;	xor	ah,ah		     
;M060;	
;M060;	push	cs
;M060;	pop	ds			; ds:si -> version_fake_table
;M060;
;M060;nxtentry:
;M060;	lodsb			     	; get name length
;M060;	or	al,al		     	; Q: end of list
;M060;	jz	endlist 	     	;  Y:
;M060;	add	si,ax		     	;  N:position to
;M060;
;M060;	add	SI,2			; SI -> next entry
;M060;;***	add	si,3		;    next entry
;M060;
;M060;	jmp	nxtentry
;M060;endlist:			     
;M060;	sub	si,dx		     
;M060;
;M060;	
;M060;	; set up the following:
;M060;	; ds:si -> version_fake_table (in doscode, or dosinitseg if romdos)
;M060;	; es:di -> dosdata:free mem (bp)
;M060;	; cx = length of version_fake_table
;M060;	
;M060;	mov	cx, si
;M060;	mov	si, offset version_fake_table
;M060;	mov	di, bp
;M060;	push	ss
;M060;	pop	es			; es -> dosdata
;M060;	push	cs
;M060;	pop	ds			; ds -> doscode (dosinitseg if romdos)
;M060;
;M060;	rep	movsb			; copy the version_fake_table at the
;M060;					; end of the dpbs
	push	ss
	pop	ds

	assume	ds:dosdata

;M060;	mov	[special_entries], bp	; store start fake version table
;M060;	mov	bp,di

	mov	ax,bp
	call	ParaRound		; round up to segment

	mov	dx,ds			; dx = dosdata segment
	add	dx,ax			; dx = ds+ax first free segment
	mov	bx,0fh
	mov	cx,[endmem]


					; set seg inpacketto dosdata					
	mov	word ptr [dskchret+3],ds


; Patch in the segments of the interrupt vectors with current code segment.
; Also patch in the segment of the pointers in the dosdata area.
;
; Note:  Formerly, temp_dosloc was initialized to -1 until after these
; calls were done.  The procedure patch_misc_segments is called multiple
; times, and relies on temp_dosloc being initialized to -1 as a flag
; for the first invocation.  Thus, we must set it to -1 for this call.


	push	dx			; preserve first free segment
	mov	ax, [temp_dosloc]	; ax = segment to patch in 
	mov	es, ax			; es = segment of DOS
	mov	[temp_dosloc], -1	; -1 means first call to patch_misc_segments

	call	patch_vec_segments	; uses AX as doscode segment
	call	patch_misc_segments	; patch in segments for sharer and 
					; other tables with seg in ES.
	mov	[temp_dosloc], es	; put back segment of dos code

	pop	dx			; restore first free segment


;
; We shall now proceed to set the offsets of the interrupt vectors handled
; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
; HIMEM the offsets also will be patched to their appropriate values in the
; low_mem_stub by seg_reinit.
;				

	xor	ax,ax
	mov	ds,ax
	mov	es,ax
assume	ds:nothing,es:nothing

	; set the segment of int 24 vector that was 
	; left out by patch_vec_segments above.

	mov	di, 4 * int_fatal_abort
	mov	ax, [temp_dosloc]
	mov	[di+2], ax
	mov	di,intbase+2

	; set default divide trap offset

	mov	word ptr ds:[0],offset doscode:divov	

	; set vectors 20-28 and 2a-3f to point to iret.

	mov	di,intbase
	mov	ax,offset doscode:irett

IFDEF	ROMDOS
	mov	cx,dosdata:i20To28Count	; set 9 offsets (skip 2 between each)
					; or 8 offsets depending on POWER
					; being included in BIOS or not
					;   sets offsets for ints 20h-28h/27h
					; ALSO LOOK AT inc\LMSTUB.ASM
ELSE
	mov	cx,9			; set 9 offsets (skip 2 between each)
					;   sets offsets for ints 20h-28h
ENDIF

iset1:
	stosw
	add	di,2
	loop	iset1

IFDEF ROMDOS
	mov	di,intbase
	add	di,10 * 4
	
ELSE
	add	di,4			; skip vector 29h
ENDIF

	mov	cx,6			; set 6 offsets (skip 2 between each)
					;   sets offsets for ints 2ah-2fh
iset2:
	stosw
	add	di,2
	loop	iset2

; 30h & 31H is the CPM call entry point whose segment address is set up by
; patch_vec_segments above. So skip it.

	add	di,8			; skip vector 30h & 31h 


	mov	cx,14			; set 14 offsets (skip 2 between each)
					;   sets offsets for ints 32h-3fh
iset3:
	stosw
	add	di,2
	loop	iset3


if installed
	; set the offset of int2f handler
	mov	word ptr ds:[02fh * 4],offset doscode:int2f
	; set segment to doscode as we we have to do int 2f to check for XMS
	mov	ax, [temp_dosloc]	; get segment of doscode
	mov	word ptr ds:[(02fh * 4) + 2], ax
endif

	; set up entry point call at vectors 30-31h. Note the segment of the 
	; long jump will be patched in by  seg_reinit

	mov	byte ptr ds:[entrypoint],mi_long_jmp
	mov	word ptr ds:[entrypoint+1],offset doscode:call_entry


	mov	word ptr ds:[addr_int_abort],offset doscode:quit
	mov	word ptr ds:[addr_int_command],offset doscode:command
	mov	word ptr ds:[addr_int_terminate],100h
	mov	word ptr ds:[addr_int_terminate+2],dx
	mov	word ptr ds:[addr_int_disk_read],offset doscode:absdrd   
	mov	word ptr ds:[addr_int_disk_write],offset doscode:absdwrt  
	mov	word ptr ds:[addr_int_keep_process],offset doscode:stay_resident

	push	ss
	pop	ds
	push	ss
	pop	es
assume	ds:dosdata,es:dosdata

	push	dx			; remember address of arena

	inc	dx			; leave room for arena header
        mov     [currentpdb], dx	; set current pdb

	xor	di, di			; point es:di at end of memory
	mov	es, dx			; ...where psp will be
	assume	es:nothing
	xor	ax, ax
	mov	cx, 80h			; psp is 128 words
	rep	stosw			; zero out psp area
        mov     ax,[endmem]

ifndef ROMDOS	
        invoke  setmem         	 	; build psp at dx; ax is memory size
else
	call	dword ptr [setmem_ptr]	; call setmem in DOSCODE
endif ;ROMDOS

	; ds, es now point to PSP

	assume	ds:nothing,es:nothing

	push	ss
	pop	ds
	assume	ds:dosdata

	mov	di,pdb_jfn_table	; es:di -> pdb_jfn_table in psp
	xor	ax,ax
	stosw
	stosb				; 0,1 and 2 are con device
	mov	al,0ffh
	mov	cx,filperproc - 3
	rep	stosb			; rest are unused

	push	ss
	pop	es
	assume	es:dosdata
					; must be set to print messages
	mov	word ptr [sft_addr+2],ds     

; after this point the char device functions for con will work for
; printing messages

	if	(not ibm) or (debug)
	mov	si,offset doscode:header
outmes:
	lods	cs:byte ptr [si]
	cmp	al,"$"
	jz	outdone
	invoke	outt
	jmp	short outmes
outdone:
	push	ss			; out stomps on segments
	pop	ds
	push	ss
	pop	es
	endif

if	DEBUG
	mov	ax,11100011b
	sub	dx,dx
	int	14h			; init serial port, 9600 baud
endif
	fmt TypSysCall,LevLog,<"Start Boot - CS=$x\n">,<CS>

	; at this point es is dosdata

	; Fill in the segment addresses of sysinitvar and country_cdpg 
	; in sysinittable (ms_data.asm)

	mov	si,offset dosdata:sysinittable
	mov	word ptr es:[si.sysi_country_tab + 2],es
	mov	word ptr es:[si.sysi_initvars + 2],es

	; buffhead -> dosdata:hashinitvar 

	mov	word ptr es:[buffhead+2],es	; BUGBUG - unused, remove this
	mov	si,offset dosdata:hashinitvar	; and all other references
	mov	word ptr es:[buffhead],si

        pop     dx                      ; restore address of arena

        mov     word ptr [dmaadd+2],dx

        mov     es:[arena_head],dx
        mov     ds, dx
	assume	ds:nothing

        mov     ds:[arena_signature],arena_signature_end
        mov     ds:[arena_owner],arena_owner_system
        mov     ax, [endmem]
	sub	ax, dx
        dec     ax
        mov     ds:[arena_size],ax

	; point to sft 0

        mov     di,offset dosdata:sftabl + sftable   
        mov     ax,3
        stosw           		; adjust refcount

	; es:di is shared data area i.e., es:di -> dosdata:sysinttable

        mov     di,offset dosdata:sysinittable	

	inc	dx			; advance dx from arena to psp
	mov	ds, dx			; point ds to psp

        if      not installed
        invoke  netwinit
        endif

					; pass the address os seg_reinit 
					; in dx
	mov	dx, offset seg_reinit
	mov	cx, offset doscode:exepatch_start
	sub	cx, offset $startcode	; cx = (doscode - exepatch) - dosinit
	mov	ax, offset doscode:sysbuf
	sub	ax, offset $startcode	; ax=size of doscode - dosinit


        mov     sp,[user_sp]		; use ss override for next 2
        mov     ss,[user_ss]
	assume	ss:nothing

        retf

;
; END OF DOSINIT
;
;--------------------------------------------------------------------------



	assume	ds:nothing,es:nothing,ss:dosdata
charinit:
	; ds:si points to device header
	mov	[devcall.reqlen],dinithl
	mov	[devcall.requnit],0
	mov	[devcall.reqfunc],devinit
	mov	[devcall.reqstat],0
	push	es
	push	bx
	push	ax
	mov	bx,offset dosdata:devcall
	push	ss
	pop	es
ifndef ROMDOS
	invoke	deviocall2
else
	call	dword ptr [deviocall2_ptr]	; call deviocall2 in DOSCODE
endif
	pop	ax
	pop	bx
	pop	es
	ret



;-----------------------------------------------------------------------------
;
;	check_XMM: routine to check presence of XMM driver
;
;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
;
;	USED:	none
;
;-----------------------------------------------------------------------------

check_XMM proc	near
;
; determine whether or not an XMM driver is installed
;
	push	ax
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
	int	2Fh
	cmp	al,80h			; Q: installed
	jne	short cXMM_no_driver	;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	push	bx
	push	dx
	push	ds
	push	es
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
	int	2Fh

	InitGetdseg	<ds>

	mov	word ptr [XMMcontrol], bx
	mov	word ptr [XMMcontrol+2],es

cXMMexit:
	clc
	pop	es
	pop	ds
	pop	dx
	pop	bx
	pop	ax
	ret				; done
;
; set carry if XMM driver not present
;
cXMM_no_driver:
	stc
	pop	ax
	ret

check_XMM	endp



;---------------------------------------------------------------------------
;
; Procedure Name : seg_reinit
;
; Inputs	 : ES has final dos code location
;		   AX = 0 / 1
;
; Outputs	 : Patch in the sharer and other tables with seg in ES
;		   if AX =0
;		      if first entry
;			 patch segment & offset of vectors with stub
;			 and stub with segment in ES
;		      else
;			 patch stub with segment in ES
;
;		   else if AX = 1
;			patch segment of vectors with segment in ES	
;
; NOTE		 : This routine can be called at most twice!
;
; Regs Mod.	 : es, ax, di, cx, bx
;-----------------------------------------------------------------------------

num_entry	db	0	; keeps track of the # of times this routine
				; has been called. (0 or 1)
seg_reinit	proc	far

	push	ds

	InitGetdseg	<ds>
	assume	ds:DOSDATA

	call	patch_misc_segments	; patch in segments for sharer and 
					; other tables with seg in ES.

	cmp	ax, 0
	jne	patch_vec_seg		; patch vectors with segment in es

	cmp	num_entry, 0		; Q: is it the first call to this 
	jne	second_entry		; N: just patch the stub with 
					;    segment in ES
					; Y: patch the vectors with stub 
	mov	ax, ds
	call	patch_vec_segments	; patch the segment of vectors
	call	patch_offset		; patch the offsets of vectors 
					; with those in the stub.

second_entry:
	mov	ax, es			; patch the stub with segment in es

	mov	di, OFFSET DOSDATA:DOSINTTABLE
	mov	cx, 9
	push	ds			
	pop	es			; es:di -> DOSINTTABLE

dosinttabloop:
	add	di, 2
	stosw
	loop	dosinttabloop	

; For ROMDOS, this routine will only be called when the DOS wants to
; use the HMA, so we don't want to check CS


ifndef ROMDOS
	cmp	ax, 0f000h		; Q: is the DOS running in the HMA
	jb	short sr_done		; N: done
endif
	call	check_XMM		; Y: set up the XMS entry point
	jc	sr_done			; failed to set up XMS do not do
					; A20 toggling in the stub.
	call	patch_in_nops		; enable the stub to check A20 state

; M021-
	mov	[DosHasHMA], 1		; set flag telling DOS control of HMA 
				
					; set pointer to the routine that 
					; patches buggy exepacked code.
	mov	[fixexepatch], offset DOSCODE:exepatch

					; M068: set pointer to the routine 
					; M068: that detects copy protected
					; M068: apps
	mov	[ChkCopyProt], offset DOSCODE:IsCopyProt

; M020 - begin

	call	WhatCPUType
	cmp	al, 1
	jne	sr_done 		; we need Rational Patch only
					;  on 286 systems
	mov	[RationalPatchPtr], offset DOSCODE:RationalPatch

; M020 - end

	jmp	short sr_done


patch_vec_seg:				; patch vectors with segment in es

	mov	ax, es
	call	patch_vec_segments	; patch in DOSCODE for the segments
					; NOTE we don't have to patch the 
					; offsets as they have been already
					; set to the doscode offsets at
					; DOSINIT.

sr_done:
	mov	num_entry, 1
	pop	ds
	ret		

seg_reinit	endp
	


;----------------------------------------------------------------------------
;
; Procedure Name : WhatCPUType
;
; Inputs	 : none
;
; Outputs	 : AL = 0 if CPU <  286
;		      = 1 if CPU == 286
;		      = 2 if CPU >= 386
;
; Regs. Mod.	 : AX
;
;----------------------------------------------------------------------------

WhatCPUType	proc	near

	get_cpu_type	; done with a MACRO which can't be generated > once

	ret

WhatCPUType	endp

;----------------------------------------------------------------------------
;
; Procedure Name : patch_vec_segments
;
; Inputs	 : ax -> has segment address to patch in
;		   ds -> DOSDATA
;
; Outputs	 : Patches in AX as the segment for the following vectors:
;			
;			0,20-28,3a-3f
;
; Regs. Mod.	 : DI,CX,DX,AX
;
;----------------------------------------------------------------------------

patch_vec_segments	proc	near

	push	es

	xor	cx,cx
	mov	es,cx
assume	es:nothing

	mov	di,intbase+2		; di -> segment of int 20 vector

	mov	es:[2],ax		; segment of default divide trap handler

					; set vectors 20 & 21

	mov	cx, 2
ps_set1:
	stosw
	add	di, 2
	loop	ps_set1

	add	di, 4			; skip	int 22h vector

	stosw				; set int 23h
	add	di, 6			; skip int 24h

					; set vectors 25-28 and 2a-3f 

	mov	cx, 4			; set 4 segments
ps_set2:
	stosw				
	add	di, 2
	loop	ps_set2

	add	di,4			; skip int 29h vector (fast con) as it may
					;   already be set.


	mov	cx,6			; set 6 segs (skip 2 between each)
					;   set segs for ints 2ah-2fh
ps_set3:
	stosw
	add	di,2
	loop	ps_set3

; 30h & 31H is the CPM call entry point whose segment address is set up by
; below. So skip it.

	add	di,8			; skip vector 30h & 31h 


	mov	cx,14			; set 14 segs (skip 2 between each)
					;   sets segs for ints 32h-3fh
ps_set4:
	stosw
	add	di,2
	loop	ps_set4



; set offset of int2f

if installed
;	mov	word ptr es:[02fh * 4],offset doscode:int2f
endif

	mov	word ptr es:[entrypoint+3],ax

	pop	es
	ret

patch_vec_segments	endp


;---------------------------------------------------------------------------
;
; Procedure Name : patch_misc_segments
;
; Inputs	 : es = segment to patch in
;		   ds = dosdata
;
; outputs	 : patches in the sharer and other tables in the dos
;		   with right dos code segment in es
;
; Regs Mod	 : DI,SI,CX
;
;---------------------------------------------------------------------------
patch_misc_segments	proc	near

	push	bx
	push	es
	push	ax

	mov	ax, es			; ax - > DOS segment
	
	push	ds
	pop	es			; es -> DOSDATA
	

;
; initialize the jump table for the sharer...
;
	mov	di,offset dosdata:jshare
	mov	bx, [temp_dosloc]	; bx = location to which the share
					; table was patched during the first
					; call to this routine
	mov	cx,15
jumptabloop:
	add	di,2			; skip offset
	cmp	bx, -1			; Q: is this called for the 1st time
	je	share_patch		;  Y: patch in sharer table
					;  N: 
	cmp	bx, es:[di]		; Q: has share been installed
	jne	no_share_patch		;  Y: don't patch in sharer table

share_patch:
	stosw				; drop in segment

no_share_patch:
	loop	jumptabloop

					; BUGBUG patching the country info 
					; with dosdata can be done inline
					; in dosinit.
					; for dos 3.3 country info
					; table address
	mov	si,offset dosdata:country_cdpg   

					; initialize double word
					; pointers with dosdata in ds
	mov	word ptr [si.ccucase_ptr + 2],ds    
	mov	word ptr [si.ccfileucase_ptr + 2],ds 
	mov	word ptr [si.ccfilechar_ptr + 2],ds
	mov	word ptr [si.cccollate_ptr + 2],ds
	mov	word ptr [si.ccmono_ptr + 2],ds
	mov	word ptr [si.ccdbcs_ptr + 2],ds	

					; fastopen routines are in doscode
					; so patch with doscode seg in ax

	mov	si,offset dosdata:fastopentable

	cmp	[temp_dosloc], -1	; Q: first time 
	je	fast_patch		; Y: patch segment
	mov	cx, [temp_dosloc]
					; Q: has fastopen patched in it's
					;    segment
	cmp	cx, word ptr [si.fastopen_name_caching + 2]
	jne	no_fast_patch		; Y: don't patch in doscode seg

fast_patch:
	mov	word ptr [si.fastopen_name_caching + 2],ax
no_fast_patch:

	pop	ax
	pop	es
	pop	bx

	ret

patch_misc_segments	endp

;--------------------------------------------------------------------------
;
; Procedure Name : patch_offset
; 
; Inputs	 : NONE
;
; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
;		   0,20-28,3a-3f, and 30,31
;
;
; Regs. Mod	 : AX,DI,CX
;--------------------------------------------------------------------------
patch_offset	proc	near

	push	es		; preserve es

	xor	ax,ax
	mov	es,ax
assume	ds:nothing,es:nothing

				; set default divide trap address
	mov	word ptr es:[0],offset dosdata:ldivov	

	mov	di,intbase	; di-> offset of int 20 handler
	mov	ax,offset dosdata:lirett

				; set vectors 20 & 21 to point to iret.
	mov	cx,2		; set 2 offsets (skip 2 between each)

po_iset1:
	stosw
	add	di, 2
	loop	po_iset1

	add	di, 4		; skip vector 22h

	stosw			; set offset of 23h
	add	di, 6		; skip 24h

				; set vectors 25-28 and 2a-3f to iret.
	mov	cx,4		; set 4 offsets (skip 2 between each)
				;   sets offsets for ints 25h-28h
po_iset2:
	stosw
	add	di,2
	loop	po_iset2

	add	di,4		; skip vector 29h


	mov	cx,6		; set 6 offsets (skip 2 between each)
				;   sets offsets for ints 2ah-2fh
po_iset3:
	stosw
	add	di,2
	loop	po_iset3

; 30h & 31H is the CPM call entry point whose offset address is set up by
; below. So skip it.

	add	di,8		; skip vector 30h & 31h 


	mov	cx,14		; set 14 offsets (skip 2 between each)
				;   sets offsets for ints 32h-3fh
po_iset4:
	stosw
	add	di,2
	loop	po_iset4


if installed
	mov	word ptr es:[02fh * 4],offset dosdata:lint2f
endif


; set up entry point call at vectors 30-31h
	mov	byte ptr es:[entrypoint],mi_long_jmp
	mov	word ptr es:[entrypoint+1],offset dosdata:lcall_entry


	mov	word ptr es:[addr_int_abort],offset dosdata:lquit
	mov	word ptr es:[addr_int_command],offset dosdata:lcommand
	mov	word ptr es:[addr_int_disk_read],offset dosdata:labsdrd   
	mov	word ptr es:[addr_int_disk_write],offset dosdata:labsdwrt 
	mov	word ptr es:[addr_int_keep_process],offset dosdata:lstay_resident

	pop	es		; restore es
	ret

patch_offset	endp

;--------------------------------------------------------------------------
;
; 	Procedure Name	:	patch_in_nops
;
; 	Entry		: 	ES -> DOSDATA
;
;	Regs Mod	: 	cx, di
;
;	Description:
;		This routine patches in 2 nops at the offsets specifed in 
;	patch_table. This basically enables the low mem stub to start 
;	making XMS calls.
;
;--------------------------------------------------------------------------

patch_table	label	byte
	dw	offset dosdata:i0patch
	dw	offset dosdata:i20patch
	dw	offset dosdata:i21patch
	dw	offset dosdata:i25patch
	dw	offset dosdata:i26patch
	dw	offset dosdata:i27patch
	dw	offset dosdata:i2fpatch
	dw	offset dosdata:cpmpatch
patch_table_size	equ	($ - patch_table) / 2

patch_in_nops	proc	near

	push	ax
	push	si
	mov	si, offset patch_table
	mov	ax, 09090h
	mov	cx, patch_table_size
	
pin_loop:
	mov	di, cs:[si]
	stosw
	add	si, 2
	loop	pin_loop
	pop	si
	pop	ax
	ret

patch_in_nops	endp


public msini002s,msini002e
msini002s label byte

;M060;;the following entries don't expect version 4.0
;M060;	;the entry format: name_length, name, expected version
;M060;	;dw	?
;M060;	;db	"SPECIAL ENTRIES TABLE",0     ;an007  tiltle
;M060;
;M060;	PUBLIC	LIE_TABLE_OFFSET
;M060;	LIE_TABLE_OFFSET EQU $
;M060;
;M060;	version_fake_table:			; starting address for special
;M060;	db	10,"WIN200.BIN" 	,3,40  	; windows 2.x 
;M060;	db	10,"WIN100.BIN" 	,3,40	; win 1.x 
;M060;	db	11,"WINWORD.EXE"	,4,10	; winword 1.0	
;M060;	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
;M060;	db	11,"HITACHI.SYS"	,4,00	; CDROMS
;M060;	db	10,"MSCDEX.EXE"		,4,00	; CDROMS
;M060;	db	10,"REDIR4.EXE"		,4,00	; Banyan networks
;M060;	db	7, "NET.EXE"		,4,00	; 3+ Open
;M060;	db	7, "NET.COM"		,3,30	; IBM PCLP
;M060;	db	12,"NETWKSTA.EXE"	,4,00	; 3+ Open
;M060;	db	12,"DXMA0MOD.SYS"	,3,30	; Token ring
;M060;	db	7, "BAN.EXE"		,4,00	; Banyan
;M060;	db	7, "BAN.COM"		,4,00	; Banyan
;M060;	db      11,"MSREDIR.EXE"        ,4,00   ; LanMan
;M060;	db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
;M060;	db      12,"IBMCACHE.SYS"       ,3,40   ; IBM CHACHE Program
;M060;	db      11,"REDIR40.EXE"        ,4,00   ; IBM PCLP 1.3/4 redirector
;M060;	db	6, "DD.EXE"		,4,01	; Laplink III software
;M060;	db	6, "DD.BIN"		,4,01	; Laplink III software
;M060;	db	7, "LL3.EXE"		,4,01   ; Laplink III software
;M060;	db      9, "REDIR.EXE"          ,4,00   ; DOS 4 redir
;M060;	db      9, "SYQ55.SYS"          ,4,00   ; Removable SCSII drive from Syquest
;M060;	db      12,"SSTDRIVE.SYS"       ,4,00   ; Columbia SCSI driver
;M060;	db      8, "ZDRV.SYS"           ,4,01   ; Unisys CD-ROM B#4734
;M060;	db      8, "ZFMT.SYS"           ,4,01   ; Unisys CD-ROM B#4734
;M060;	
;M060;	db	(512 - ($ - version_fake_table)) dup (0)
;M060;
;M060;	PUBLIC	LIE_TABLE_LEN
;M060;	LIE_TABLE_LEN EQU ($ - LIE_TABLE_OFFSET)

	public	memstrt

memstrt	label 	word

msini002e label byte


; if not ROMDOS, then we close the dos code segment, otherwise we close
; the dos initialization segment

ifndef ROMDOS

doscode	ends

else

dosinitseg ends

endif ; ROMDOS


 DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 DPUBLIC <notmax,  patch_offset, perdrv>
 DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 DPUBLIC <sr_done, version_fake_table, xxx>

	end




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mssw.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)ibmsw.asm	1.1 85/04/10


IBM		EQU	ibmver
WANG		EQU	FALSE

; Set this switch to cause DOS to move itself to the end of memory
HIGHMEM EQU	FALSE

; Turn on switch below to allow testing disk code with DEBUG. It sets
; up a different stack for disk I/O (functions > 11) than that used for
; character I/O which effectively makes the DOS re-entrant.

	IF	IBM
ESCCH	EQU	0			; character to begin escape seq.
CANCEL	EQU	27			;Cancel with escape
TOGLPRN EQU	TRUE			;One key toggles printer echo
ZEROEXT EQU	TRUE
	ELSE
ESCCH	EQU	1BH
CANCEL	EQU	"X"-"@" 		;Cancel with Ctrl-X
TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
ZEROEXT EQU	TRUE
	ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msioctl.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	SCCSID = @(#)IBMIOCTL.INC	1.1 85/04/10
IBM	EQU	0FFFFH		;TRUE

INCLUDE IOCTL.INC
	SCCSID = @(#)IBMIOCTL.INC	1.1 85/04/10

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\msproc.asm ===
; =========================================================================
;	SCCSID = @(#)MSproc.asm        1.1 85/04/10
;
; Pseudo EXEC system call for DOS
;
; =========================================================================

.cref
.list

	TITLE	MSPROC - process maintenance
	NAME	MSPROC

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
	PAGE	,132

; =========================================================================
;**	Process related system calls and low level routines for DOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$WAIT
;	$EXEC
;	$Keep_process
;	Stay_resident
;	$EXIT
;	$ABORT
;	abort_inner
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;		AN000	version 4.0 jan. 1988
;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
;		A008	PTM 4070 - fake version for MS WINDOWS
;
;		M000	added support for loading programs into UMBs 7/9/90
;
;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
;		       dossym.inc. 7/30/90
;		M005 - Support for EXE programs with out STACK segment and 
;		       with resident size < 64K - 256 bytes. A 256 byte 
;		       stack is provided at the end of the program. Note that
;		       only SP is changed.
;		M020 - Fix for Rational bug for details see exepatch.asm
;
;		M028 - 4b04 implementation
;
;		M029 - Support for EXEs without stack rewritten. If EXE is
;			in memory block >= 64K, sp = 0. If memory block
;			obtained is <64K, point sp at the end of the memory
;			block. For EXEs smaller than 64K, 256 bytes are still
;			added for a stack segment which may be needed if it
;			is loaded in low memory situations.
;
;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
;
;		M040 - Bug #3052. The environment sizing code would flag a
;			a bad environment if it reached 32767 bytes. Changed
;			to allow 32768 bytes of environment.
;
;		M047 - Release the allocated UMB when we failed to load a 
;		       COM file high. Also ensure that if the biggest block
;		       into which we load the com file is less than 64K then
;		       we provide atleast 256 bytes of stack to the user.
;
;		M050 - Made Lie table search CASE insensitive
;
;		M060 - Removed special version table from the kernal and
;                      put it in a device drive which puts the address
;                      in the DOS DATA area location UU_IFS_DOS_CALL
;		       as a DWORD.
;
;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
;		       entry do not try to load low if there is no space in
;		       UMBs.
;
;		M068 - Support for copy protect apps. Call ChkCopyProt to 
;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
;		       change return address to LeaveDos if AL=5.
;
;               20-Jul-1992 bens    Added ifdef RESTRICTED_BUILD code that
;                      controls building a version of MSDOS.SYS that only
;                      runs programs from a fixed list (defined in the
;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
;                      for details.  This feature is used to build a
;                      "special" version of DOS that can be handed out to
;                      OEM/ISV customers as part of a "service" disk.
;
; =========================================================================

.XLIST
.XCREF

INCLUDE version.inc
INCLUDE dosseg.inc
INCLUDE DOSSYM.INC
INCLUDE DEVSYM.INC
INCLUDE exe.inc
INCLUDE sf.inc
INCLUDE curdir.inc
INCLUDE syscall.inc
INCLUDE arena.inc
INCLUDE pdb.inc
INCLUDE vector.inc

.CREF
.LIST

public	retexepatch

; =========================================================================

ifdef	ROMEXEC
ifndef	JAPAN

BDATA	segment at 70h
	extrn	RomStartAddr	:word
BDATA	ends

endif ; JAPAN
endif ; ROMEXEC

; =========================================================================

DosData SEGMENT WORD PUBLIC 'DATA'

	EXTRN	CreatePDB	:BYTE
	EXTRN	DidCtrlC	:BYTE
	EXTRN	Exit_type	:BYTE
	EXTRN	ExtErr_Locus	:BYTE	; Extended Error Locus
	EXTRN	InDos		:BYTE

	EXTRN	OpenBuf		:BYTE
;	EXTRN	OpenBuf		:128

	EXTRN	CurrentPDB	:WORD
	EXTRN	Exit_code	:WORD

	EXTRN	DmaAdd		:DWORD


		; the following includes & i_needs are for exec.asm
		; which is included in this source

		; **** Fake_count to commented out
		
	EXTRN	Fake_Count	:BYTE	; Fake version count

	EXTRN	Special_Entries :WORD	; Address of special entries
	EXTRN	Special_Version :WORD	; Special version number
	EXTRN	Temp_Var2	:WORD	; File type from $open

		; following i_needs are becuse of moving these vars from
		; exec.asm to ../inc/ms_data.asm

	EXTRN	exec_init_SP	:WORD
	EXTRN	exec_init_SS	:WORD
	EXTRN	exec_init_IP	:WORD
	EXTRN	exec_init_CS	:WORD


	EXTRN	exec_signature	:WORD	; Must contain 4D5A  (yay zibo!)
	EXTRN	exec_len_mod_512:WORD	; Low 9 bits of length
	EXTRN	exec_pages	:WORD	; Number of 512b pages in file
	EXTRN	exec_rle_count	:WORD	; Count of reloc entries
	EXTRN	exec_par_dir	:WORD	; Number of paragraphs before image
	EXTRN	exec_min_BSS	:WORD	; Minimum number of para of BSS
	EXTRN	exec_max_BSS	:WORD	; Max number of para of BSS
	EXTRN	exec_SS 	:WORD	; Stack of image
	EXTRN	exec_SP 	:WORD	; SP of image
	EXTRN	exec_chksum	:WORD	; Checksum  of file (ignored)
	EXTRN	exec_IP 	:WORD	; IP of entry
	EXTRN	exec_CS 	:WORD	; CS of entry
	EXTRN	exec_rle_table	:WORD	; Byte offset of reloc table

	EXTRN	DOS_FLAG	:BYTE	; flag to indicate to redir that open
					; came from exec. 


	EXTRN   AllocMethod	:BYTE   ; how to alloc first(best)last
	EXTRN	SAVE_AX		:WORD	; temp to save ax
	EXTRN	AllocMsave	:BYTE	; M063: temp to save AllocMethod

	EXTRN	UU_IFS_DOS_CALL	:DWORD	; M060 Ptr to version table

	EXTRN	A20OFF_PSP	:WORD	; M068
	EXTRN	A20OFF_COUNT	:BYTE	; M068


; =========================================================================

	EXTRN	Disa20_Xfer	:WORD

	allow_getdseg

	EXTRN	DriverLoad	:BYTE
	EXTRN	BiosDataPtr	:DWORD
	extrn	DosHasHMA	:byte		; M021
	extrn	fixexepatch	:word
	extrn	Rational386PatchPtr:word
	extrn	ChkCopyProt	:word 		; M068
	extrn	LeaveDos	:word		; M068


DosData ENDS

; =========================================================================

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


	EXTRN	ExecReady:near
	EXTRN	UCase:near			; M050


SAVEXIT 	EQU	10

	BREAK	<$WAIT - return previous process error code>

; =========================================================================
;	$WAIT - Return previous process error code.
;
;	Assembler usage:
;
;	    MOV     AH, WaitProcess
;	    INT     int_command
;
;	ENTRY	none
;	EXIT	(ax) = exit code
;	USES	all
; =========================================================================

	ASSUME	DS:NOTHING,ES:NOTHING

PROCEDURE $Wait ,NEAR

	xor	AX,AX
	xchg	AX,exit_code
	transfer Sys_Ret_OK

ENDPROC $Wait

ifdef RESTRICTED_BUILD
;***    IsFileOnGuestList - Check that file name is allowed to execute
;
;       This function is called by $Exec just before it attempts to
;       $Open the program file.
;
;       Entry
;           ds:dx = asciiz "guest" file name.
;                   Must be upper case and have no meta characters.
;           CLD
;
;       Exit-Success
;           returns Carry CLEAR
;
;       Exit-Failure
;           returns Carry SET
;           ax = error_access_denied

IsFileOnGuestList  proc    near
        SaveReg <bx,cx,si,di,ds,es>

;*  Compute length of guest name

        push    ds
        pop     es
        mov     di,dx                   ; es:di -> guest name
        invoke  StrLen                  ; cx = length of name including 00
        mov     bx,cx                   ; Save length for repeated use

;*  Get list of allowed names
        push    cs
        pop     es
        mov     di,offset aszRestrict   ; es:di -> allowed name list

;*  Set null character and no error in one fell swoop!
        xor     ax,ax

;*  Scan list for matching file name
;
;   ax     = 0 (used for repne scasb and successful return code)
;   bx     = length of guest name, including 00 terminator
;   ds:dx -> guest name
;   es:di -> next name on list

fgl10:  cmp     byte ptr es:[di],00     ; At end of list?
        jz      fgle                    ;   YES, file not allowed, go fail

;*  Compare names
        mov     si,dx                   ; ds:si -> guest name
        mov     cx,bx                   ; Length of guest name
        repe    cmpsb                   ; Do names match?
        jz      fglx                    ;   YES, return success

;*  Now we either ran past the end of the string in the list, or we are not
;   at the end, but found a difference.  We back up one character, since
;   repe cmpsb advanced one character past the difference, and then scan
;   the string in the list to find its end.

        dec     di                      ; es:di -> character that did not match
        mov     cx,-1                   ; Make sure we look far enough ahead
        repne   scasb                   ; Find tail of name in list

;*  Now es:[di] is first character of the next name in the list (or 00)
;
        jmp     fgl10                   ; Go check next name

;*  Name not found on list
;
fgle:   mov     ax,error_access_denied  ; Set error code
        stc                             ; Indicate error

fglx:   RestoreReg <es,ds,di,si,cx,bx>
        ret
IsFileOnGuestList  endp


;**     rstfile - macro to add file name to list
;
rstfile MACRO   name
    db  name,0
endm

;**     aszRestrict - list of files allowed to execute
;
aszRestrict LABEL   byte

include restrict.inc    ; build table

    db  0               ; terminate table

endif ; RESTRICTED_BUILD


; =========================================================================
;BREAK <$exec - load/go a program>
;	EXEC.ASM - EXEC System Call
;
;
; Assembler usage:
;	    lds     DX, Name
;	    les     BX, Blk
;	    mov     AH, Exec
;	    mov     AL, FUNC
;	    int     INT_COMMAND
;
;	AL  Function
;	--  --------
;	 0  Load and execute the program.
;	 1  Load, create  the  program	header	but  do  not
;	    begin execution.
;	 3  Load overlay. No header created.
;
;	    AL = 0 -> load/execute program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;
;	    AL = 1 -> load program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | CS:IP			|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | SS:IP			|
;	    +---------------------------+
;
;	    AL = 3 -> load overlay
;
;	    +---------------------------+
;	    | WORD segment address where|
;	    | file will be loaded.	|
;	    +---------------------------+
;	    | WORD relocation factor to |
;	    | be applied to the image.	|
;	    +---------------------------+
;
; Returns:
;	    AX = error_invalid_function
;	       = error_bad_format
;	       = error_bad_environment
;	       = error_not_enough_memory
;	       = error_file_not_found
; =========================================================================
;
;   Revision history:
;
;	 A000	version 4.00  Jan. 1988
;
; =========================================================================

	EXTRN	Exec_Header_Len :ABS

Exec_Internal_Buffer		EQU	OpenBuf
Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLEN)

; =========================================================================

;IF1		; warning message on buffers
;%out	Please make sure that the following are contiguous and of the
;%out	following sizes:
;%out
;%out	OpenBuf     128
;%out	RenBuf	    128
;%out	SearchBuf    53
;%out	DummyCDS    CurDirLen
;ENDIF

; =========================================================================

ifdef	ROMEXEC				;SR; Externals from romfind.asm

	EXTRN	Check_name	:NEAR
	EXTRN	Check_ROM	:NEAR

	IFDEF	JAPAN			; YI 09/05/89

		EXTRN	ROMSTARTSEG	:ABS
		EXTRN	ROMENDSEG	:ABS

	ENDIF

	EXTRN	BioDataSeg	:WORD
endif ; ROMEXEC

; =========================================================================
;
; =========================================================================

procedure	$Exec,NEAR

	PUBLIC EXEC001S
EXEC001S:

	LocalVar    Exec_Blk		,DWORD
	LocalVar    Exec_Func		,BYTE
	LocalVar    Exec_Load_High	,BYTE
	LocalVar    Exec_FH		,WORD
	LocalVar    Exec_Rel_Fac	,WORD
	LocalVar    Exec_Res_Len_Para	,WORD
	LocalVar    Exec_Environ	,WORD
	LocalVar    Exec_Size		,WORD
	LocalVar    Exec_Load_Block	,WORD
	LocalVar    Exec_DMA		,WORD
	LocalVar    ExecNameLen 	,WORD
	LocalVar    ExecName		,DWORD

	LocalVar    Exec_DMA_Save	,WORD
	LocalVar    Exec_NoStack	,BYTE

ifdef ROMEXEC
			; Added 2 local variables to support exec from ROM
	LocalVar    ExecRomFound	,BYTE
	LocalVar    ExecRomAddr 	,DWORD

endif ; ROMEXEC

	; ==================================================================
	; validate function
	; ==================================================================

	PUBLIC	EXEC001E
EXEC001E:
		      	
	;
	; M068 - Start
	;
	; Reset the A20OFF_COUNT to 0. This is done as there is a 
	; possibility that the count may not be decremented all the way to
	; 0. A typical case is if the program for which we intended to keep 
	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
	; calls), exits pre-maturely due to error conditions.
	;

	mov	[A20OFF_COUNT], 0

	;
	; If al=5 (ExecReady) we'll change the return address on the stack	
	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
	;
	cmp	al, 5			; Q: is this ExecReady call
	jne	@f			; N: continue
					; Y: change ret addr. to LeaveDos.
	pop	cx			; Note CX is not input to ExecReady
	mov	cx, offset DOSCODE:LeaveDos
	push	cx
@@:
	;
	; M068 - End
	;

	Enter

	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
					; M030
	jna	exec_check_2

Exec_Bad_Fun:
	mov	ExtErr_Locus,ErrLoc_Unk ; Extended Error Locus	;smr;SS Override
	mov	al,Error_Invalid_Function

Exec_Ret_Err:
	Leave
	transfer    SYS_RET_ERR
ExecReadyJ:
	call	ExecReady		; M028
	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028

Exec_Check_2:
	cmp	AL,2
	jz	Exec_Bad_Fun

	cmp	al, 4			; 2 & 4 are not allowed
	je	Exec_Bad_Fun

	cmp	al, 5			; M028 ; M030
	je	ExecReadyJ		; M028

	mov	Exec_BlkL,BX		; stash args
	mov	Exec_BlkH,ES
	mov	Exec_Func,AL
	mov	Exec_Load_high,0

	mov	execNameL,DX		; set up length of exec name
	mov	execNameH,DS
	mov	SI,DX			; move pointer to convenient place
	invoke	DStrLen
	mov	ExecNameLen,CX		; save length

ifdef ROMEXEC
					; Check if ROM program
	mov     execRomFound,0          ; assume not in ROM		
					; Do not check for ROM if load overlay
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jnz	Do_Normal

					; A ROM program exec should have no
					; path or drive specifiers
	push	DX
	push	CX
	push	DS
	push	SI
	push	ES
	dec	CX			; length should not include NUL char

		; Check if the program exists in  ROM - returns address in
		; dx,ax if success

	call	Check_name		; DS:SI points to string
	jc      not_rom_name

Exist_ROM:

	push	DS
	mov	DS, CS:[BioDataSeg]
IFDEF	JAPAN				; YI 09/05/89
	mov	AX,DS:[ROMSTARTSEG]
ELSE
	mov	AX,DS:RomStartAddr
ENDIF
	pop	DS

	mov	ES,AX
	xor	AX,AX			; setup start addr for ROM scan
	call    Check_ROM
	jc      not_rom_name

	mov	execRomFound,1		; flag that program is in ROM
	mov	execRomAddrL,AX
	mov	execRomAddrH,ES
	pop	ES
	pop	SI			; Skip file opening and checking -
	pop	DS			; check environment
	pop	CX
	pop	DX
	jmp	short exec_check_environ

not_rom_name:
	pop	ES
	pop	SI
	pop	DS
	pop	CX
	pop	DX			; restore dx

do_normal:

endif ; ROMEXEC

	mov	al, [AllocMethod]	; M063: save alloc method in 
	mov	[AllocMsave], al	; M063: AllocMsave

	xor	AL,AL			; open for reading
	push	BP

	or	[DOS_FLAG], EXECOPEN	; this flag is set to indicate to 
					; the redir that this open call is
					; due to an exec.
ifdef RESTRICTED_BUILD
        call    IsFileOnGuestList       ; Should we execute this?
        jc      @F                      ;   NO, skip open and fail
endif ; RESTRICTED_BUILD

	invoke	$OPEN			; is the file there?

ifdef RESTRICTED_BUILD
@@: ;* Come here if file name does not pass muster
endif ; RESTRICTED_BUILD

	pushf
	and	[DOS_FLAG], not EXECOPEN; reset flag
	popf

	pop	BP
ifdef	ROMEXEC
	jnc	@F
	jmp	Exec_Ret_Err
@@:
else
	jc	Exec_Ret_Err
endif

	mov	Exec_Fh,AX
	mov	BX,AX
	xor	AL,AL
	invoke	$Ioctl
	jc	Exec_BombJ

	test	DL,DEVID_ISDEV
	jz	Exec_Check_Environ

	mov	AL,ERROR_FILE_NOT_FOUND
Exec_bombJ:
	jmp	Exec_Bomb

BadEnv:
	mov	AL,ERROR_BAD_ENVIRONMENT
	jmp	Exec_Bomb

Exec_Check_Environ:
	mov	Exec_Load_Block,0
	mov	Exec_Environ,0
					; overlays... no environment
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jnz	Exec_Read_Header

	lds	SI,Exec_Blk		; get block
	mov	AX,[SI].Exec1_Environ	; address of environ
	or	AX,AX
	jnz	exec_scan_env

	mov	DS,CurrentPDB		;smr;SS Override
	mov	AX,DS:[PDB_environ]

;---------------------------------------------BUG 92 4/30/90-----------------
;
; Exec_environ is being correctly initialized after the environment has been
; allocated and copied form the parent's env. It must not be initialized here.
; Because if the call to $alloc below fails Exec_dealloc will deallocate the
; parent's environment.
;	mov	Exec_Environ,AX
;
;----------------------------------------------------------------------------

	or	AX,AX
	jz	Exec_Read_Header

Exec_Scan_Env:
	mov	ES,AX
	xor	DI,DI
	mov	CX,8000h		; at most 32k of environment ;M040
	xor	AL,AL

Exec_Get_Environ_Len:
	repnz	scasb			; find that nul byte
	jnz	BadEnv

	dec	CX			; Dec CX for the next nul byte test
	js	BadEnv			; gone beyond the end of the environment

	scasb				; is there another nul byte?
	jnz	Exec_Get_Environ_Len	; no, scan some more

	push	DI
	lea	BX,[DI+0Fh+2]
	add	BX,ExecNameLen		; BX <- length of environment
					; remember argv[0] length
					; round up and remember argc
	mov	CL,4
	shr	BX,CL			; number of paragraphs needed
	push	ES
	invoke	$Alloc			; can we get the space?
	pop	DS
	pop	CX
	jnc	Exec_Save_Environ

	jmp	SHORT Exec_No_Mem	; nope... cry and sob

Exec_Save_Environ:
	mov	ES,AX
	mov	Exec_Environ,AX 	; save him for a rainy day
	xor	SI,SI
	mov	DI,SI
	rep	movsb			; copy the environment
	mov	AX,1
	stosw
	lds	SI,ExecName
	mov	CX,ExecNameLen
	rep	movsb

Exec_Read_Header:

ifdef ROMEXEC
		; SR; For a ROM program, we skip reading the program header.
		; We assume it to be a .COM program and go ahead.

	cmp	ExecRomFound,1
	jne	NoRom
	jmp	Exec_Com_File		;program is in ROM
NoRom:

endif ; ROMEXEC

		; We read in the program header into the above data area and
		; determine where in this memory the image will be located.

	Context DS
	mov	CX,Exec_Header_Len	; header size
	mov	DX,OFFSET DosData:Exec_Signature
	push	ES
	push	DS
	call	ExecRead
	pop	DS
	pop	ES
	jc	Exec_Bad_File

	or	AX,AX
	jz	Exec_Bad_File
	cmp	AX,EXEC_HEADER_LEN	; did we read the right number?
	jnz	Exec_Com_Filej		; yep... continue

	test	Exec_Max_BSS,-1 	; indicate load high?
	jnz	Exec_Check_Sig

	mov	Exec_Load_High,-1

Exec_Check_Sig:
	mov	AX,Exec_Signature	; rms;NSS
	cmp	AX,Exe_Valid_Signature	; zibo arises!
	jz	Exec_Save_Start 	; assume com file if no signature

	cmp	AX,exe_valid_Old_Signature  ; zibo arises!
	jz	Exec_Save_Start 	; assume com file if no signature

Exec_Com_Filej:
	jmp	Exec_Com_file

		; We have the program header... determine memory requirements

Exec_Save_Start:
	mov	AX,Exec_Pages		; get 512-byte pages	;rms;NSS
	mov	CL,5			; convert to paragraphs
	shl	AX,CL
	sub	AX,Exec_Par_Dir 	; AX = size in paragraphs;rms;NSS
	mov	Exec_Res_Len_Para,AX

		; Do we need to allocate memory?
		; Yes if function is not load-overlay

	test	BYTE PTR exec_func,exec_func_overlay
	jz	exec_allocate		; allocation of space

		; get load address from block

	les	DI,Exec_Blk
	mov	AX,ES:[DI].Exec3_Load_Addr
	mov	exec_dma,AX
	mov	AX,ES:[DI].Exec3_Reloc_Fac
	mov	Exec_Rel_Fac,AX

	jmp	Exec_Find_Res		; M000

Exec_No_Mem:
	mov	AL,Error_Not_Enough_Memory
	jmp	SHORT Exec_Bomb

Exec_Bad_File:
	mov	AL,Error_Bad_Format

Exec_Bomb:
	ASSUME	DS:NOTHING,ES:NOTHING

	mov	BX,Exec_fh
	call	Exec_Dealloc
	LeaveCrit   CritMem
	save	<AX,BP>
	invoke	$CLOSE
	restore <BP,AX>
	jmp	Exec_Ret_Err


Exec_Chk_Mem: 
		     			; M063 - Start
	mov	al, [AllocMethod]	; save current alloc method in ax
	mov	bl, [AllocMsave]
	mov	[AllocMethod], bl	; restore original allocmethod
	test	bl, HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	jnz	Exec_No_Mem		; Y: no space in UMBs. Quit
					; N: continue

	test	al, HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	Exec_No_Mem		; N: no memory 
	mov	ax, [save_ax]		; Y: restore ax and
	jmp	short Exec_Norm_Alloc	;    Try again
					; M063 - End
	
Exec_Allocate:
	DOSAssume   <DS>,"exec_allocate"


		; M005 - START
		; If there is no STACK segment for this exe file and if this
		; not an overlay and the resident size is less than 64K - 
		; 256 bytes we shall add 256bytes bytes to the programs 
		; resident memory requirement and set Exec_SP to this value.

	mov	Exec_NoStack,0
	cmp	Exec_SS, 0		; Q: is there a stack seg
	jne	@f			; Y: continue normal processing
	cmp	Exec_SP, 0		; Q: is there a stack ptr
	jne	@f			; Y: continue normal processing

	inc	Exec_NoStack
	cmp	ax, 01000h-10h		; Q: is this >= 64K-256 bytes
	jae	@f			; Y: don't set Exec_SP

	add	ax, 010h		; add 10h paras to mem requirement
@@:

		; M005 - END

					; M000 - start
	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is the alloc strat high_first
	jz	Exec_Norm_Alloc		; N: normal allocate
					; Y: set high_only bit
	or	byte ptr [AllocMethod], HIGH_ONLY
					; M000 - end

Exec_Norm_Alloc:

	mov	[save_ax], ax		; M000: save ax for possible 2nd  
					; M000: attempt at allocating memory
;	push	ax			; M000

	mov	BX,0ffffh		; see how much room in arena
	push	DS
	invoke	$Alloc			; should have carry set and BX has max
	pop	DS

	mov	ax, [save_ax]		; M000
;	pop	AX			; M000

	add	AX,10h			; room for header
	cmp	BX,11h			; enough room for a header

	jb	Exec_Chk_Mem		; M000
;	jb	Exec_No_Mem		; M000


	cmp	AX,BX			; is there enough for bare image?

	ja	Exec_Chk_Mem		; M000
;	ja	Exec_No_Mem		; M000

	test	Exec_Load_High,-1	; if load high, use max
	jnz	Exec_BX_Max		; use max

	add	AX,Exec_Min_BSS 	; go for min allocation;rms;NSS

	jc	Exec_Chk_Mem		; M000
;	jc	Exec_No_Mem		; M000: oops! carry

	cmp	AX,BX			; enough space?

	ja	Exec_Chk_Mem		; M000: nope...	
;	ja	Exec_No_Mem		; M000: nope...


	sub	AX,Exec_Min_BSS 	; rms;NSS
	add	AX,Exec_Max_BSS 	; go for the MAX
	jc	Exec_BX_Max

	cmp	AX,BX
	jbe	Exec_Got_Block

Exec_BX_Max:
	mov	AX,BX

Exec_Got_Block:
	push	DS
	mov	BX,AX
	mov	exec_size,BX
	invoke	$Alloc			; get the space
	pop	DS

	ljc	exec_chk_mem		; M000

	mov	cl, [AllocMsave]	; M063: 
	mov	[AllocMethod], cl	; M063: restore allocmethod


;M029; Begin changes
; This code does special handling for programs with no stack segment. If so,
;check if the current block is larger than 64K. If so, we do not modify
;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
;case Exec_SS is not changed.
;
	cmp	Exec_NoStack,0
	je	@f

	cmp	bx,1000h		; Q: >= 64K memory block
	jae	@f			; Y: Exec_SP = 0

;
;Make Exec_SP point at the top of the memory block
;
	mov	cl,4
	shl	bx,cl			; get byte offset
	sub	bx,100h		; take care of PSP
	mov	Exec_SP,bx		; Exec_SP = top of block
@@:
;
;M029; end changes
;

	mov	exec_load_block,AX
	add	AX,10h
	test	exec_load_high,-1
	jz	exec_use_ax		; use ax for load info

	add	AX,exec_size		; go to end
	sub	AX,exec_res_len_para	; drop off header
	sub	AX,10h			; drop off pdb

Exec_Use_AX:
	mov	Exec_Rel_Fac,AX 	; new segment
	mov	Exec_Dma,AX		; beginning of dma

		; Determine the location in the file of the beginning of
		; the resident

Exec_Find_Res:

	mov	DX, exec_dma
	mov	exec_dma_save, DX

	mov	DX,Exec_Par_Dir
	push	DX
	mov	CL,4
	shl	DX,CL			; low word of location
	pop	AX
	mov	CL,12
	shr	AX,CL			; high word of location
	mov	CX,AX			; CX <- high

		; Read in the resident image (first, seek to it)

	mov	BX,Exec_FH
	push	DS
	xor	AL,AL
	invoke	$Lseek			; Seek to resident
	pop	DS
	jnc	exec_big_read

	jmp	exec_bomb

Exec_Big_Read:				; Read resident into memory
	mov	BX,Exec_Res_Len_Para
	cmp	BX,1000h		; Too many bytes to read?
	jb	Exec_Read_OK

	mov	BX,0fe0h		; Max in one chunk FE00 bytes

Exec_Read_OK:
	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
	push	BX
	mov	CL,4
	shl	BX,CL			; Get count in bytes from paras
	mov	CX,BX			; Count in correct register
	push	DS
	mov	DS,Exec_DMA		; Set up read buffer

	ASSUME	DS:NOTHING

	xor	DX,DX
	push	CX			; Save our count
	call	ExecRead
	pop	CX			; Get old count to verify
	pop	DS
	jc	Exec_Bad_FileJ

	DOSAssume   <DS>,"exec_read_ok"

	cmp	CX,AX			; Did we read enough?
	pop	BX			; Get paragraph count back
	jz	ExecCheckEnd		; and do reloc if no more to read

		; The read did not match the request. If we are off by 512
		; bytes or more then the header lied and we have an error.

	sub	CX,AX
	cmp	CX,512
	jae	Exec_Bad_FileJ

		; We've read in CX bytes... bump DTA location

ExecCheckEnd:
	add	Exec_DMA,BX		; Bump dma address
	test	Exec_Res_Len_Para,-1
	jnz	Exec_Big_Read

		; The image has now been read in. We must perform relocation
		; to the current location.


ifdef ROMDOS
	cmp	[DosHasHMA], 0		; DOS using HMA?  (M021)
	je	exec_do_reloc		; if not, then no patch needed.
endif

exec_do_reloc:
	mov	CX,Exec_Rel_Fac
	mov	AX,Exec_SS		; get initial SS ;rms;NSS
	add	AX,CX			; and relocate him
	mov	Exec_Init_SS,AX 	; rms;NSS

	mov	AX,Exec_SP		; initial SP ;rms;NSS
	mov	Exec_Init_SP,AX 	; rms;NSS



	les	AX,DWORD PTR exec_IP	; rms;NSS
	mov	Exec_Init_IP,AX 	; rms;NSS
	mov	AX,ES			; rms;NSS
	add	AX,CX			; relocated...
	mov	Exec_Init_CS,AX 	; rms;NSS

	xor	CX,CX
	mov	DX,Exec_RLE_Table	; rms;NSS
	mov	BX,Exec_FH
	push	DS
	xor	AX,AX
	invoke	$Lseek
	pop	DS

	jnc	Exec_Get_Entries

exec_bad_filej:
	jmp	Exec_Bad_File

exec_get_entries:
	mov	DX,Exec_RLE_Count	; Number of entries left ;rms;NSS

exec_read_reloc:
	ASSUME	DS:NOTHING

	push	DX
	mov	DX,OFFSET DOSDATA:Exec_Internal_Buffer
	mov	CX,((EXEC_INTERNAL_BUFFER_SIZE)/4)*4
	push	DS
	call	ExecRead
	pop	ES
	pop	DX
	jc	Exec_Bad_FileJ

	mov	CX,(EXEC_INTERNAL_BUFFER_SIZE)/4
					; Pointer to byte location in header
	mov	DI,OFFSET DOSDATA:exec_internal_buffer 
	mov	SI,Exec_Rel_Fac 	; Relocate a single address

exec_reloc_one:
	or	DX,DX			; Any more entries?
	je	Exec_Set_PDBJ

exec_get_addr:
	lds	BX,DWORD PTR ES:[DI]	; Get ra/sa of entry
	mov	AX,DS			; Relocate address of item

;;;;;;	add	AX,SI
	add	AX, exec_dma_save

	mov	DS,AX
	add	[BX],SI
	add	DI,4
	dec	DX
	loop	Exec_Reloc_One		; End of internal buffer?

		; We've exhausted a single buffer's worth. Read in the next
		; piece of the relocation table.

	push	ES
	pop	DS
	jmp	Exec_Read_Reloc

Exec_Set_PDBJ:

		;
		; We now determine if this is a buggy exe packed file and if 
		; so we patch in the right code. Note that fixexepatch will
		; point to a ret if dos loads low. The load segment as 
		; determined above will be in exec_dma_save
		;

	push	es
	push	ax			; M030
	push	cx			; M030
	mov	es, exec_dma_save
	mov	ax, exec_init_CS	; M030
	mov	cx, exec_init_IP	; M030
	call	word ptr [fixexepatch]
	call	word ptr [Rational386PatchPtr]
	pop	cx			; M030
	pop	ax			; M030
	pop	es

	jmp	Exec_Set_PDB

Exec_No_Memj:
	jmp	Exec_No_Mem

		; we have a .COM file.	First, determine if we are merely
		; loading an overlay.

Exec_Com_File:
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jz	Exec_Alloc_Com_File
	lds	SI,Exec_Blk		; get arg block
	lodsw				; get load address
	mov	Exec_DMA,AX
	mov	AX,0ffffh
	jmp	SHORT Exec_Read_Block	; read it all!


			
Exec_Chk_Com_Mem:			
		     			; M063 - Start
	mov	al, [AllocMethod]	; save current alloc method in ax
	mov	bl, [AllocMsave]
	mov	[AllocMethod], bl	; restore original allocmethod
	test	bl, HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	jnz	Exec_No_Memj		; Y: no space in UMBs. Quit
					; N: continue

	test	al, HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	Exec_No_Memj		; N: no memory 

	mov	ax, exec_load_block	; M047: ax = block we just allocated	
	xor	bx, bx			; M047: bx => free arena
	call	ChangeOwner		; M047: free this block

	jmp	short Exec_Norm_Com_Alloc
					; M063 - End
	
		; We must allocate the max possible size block (ick!)
		; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
		; size of block.

Exec_Alloc_Com_File:
					; M000 -start
	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is the alloc strat high_first
	jz	Exec_Norm_Com_Alloc	; N: normal allocate
					; Y: set high_only bit
	or	byte ptr [AllocMethod], HIGH_ONLY
					; M000 - end


Exec_Norm_Com_Alloc:			; M000

	mov	BX,0FFFFh
	invoke	$Alloc			; largest piece available as error
	or	BX,BX

	jz	Exec_Chk_Com_Mem	; M000
;	jz	Exec_No_Memj		; M000

	mov	Exec_Size,BX		; save size of allocation block
	push	BX
	invoke	$ALLOC			; largest piece available as error
	pop	BX			; get size of block...
	mov	Exec_Load_Block,AX
	add	AX,10h			; increment for header
	mov	Exec_DMA,AX
	xor	AX,AX			; presume 64K read...
	cmp	BX,1000h		; 64k or more in block?
	jae	Exec_Read_Com		; yes, read only 64k

	mov	AX,BX			; convert size to bytes
	mov	CL,4
	shl	AX,CL
        cmp     AX,200h                 ; enough memory for PSP and stack?

	jbe	Exec_Chk_Com_Mem	; M000: jump if not
;	jbe	Exec_No_Memj		; M000: jump if not

					; M047: size of the block is < 64K
	sub	ax, 100h		; M047: reserve 256 bytes for stack

Exec_Read_Com:
	sub	AX,100h 		; remember size of psp

ifdef ROMEXEC
		; If ROM program, do not read in file - start building header
	cmp	execRomFound,1
	jne	Exec_Read_Block		; not found, read file
	jmp     exec_build_header	; skip reading of file
endif

Exec_Read_Block:
	push	AX			; save number to read
	mov	BX,Exec_FH		; of com file
	xor	CX,CX			; but seek to 0:0
	mov	DX,CX
	xor	AX,AX			; seek relative to beginning
	invoke	$Lseek			; back to beginning of file
	pop	CX			; number to read
	mov	DS,Exec_DMA
	xor	DX,DX
	push	CX
	call	ExecRead
	pop	SI			; get number of bytes to read
	jnc	OkRead

	jmp	Exec_Bad_File

OkRead:
	cmp	AX,SI			; did we read them all?

	ljz	Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
;	ljz	Exec_No_Memj		; M00: exactly the wrong number...

	mov	bl, [AllocMsave]	; M063
	mov	[AllocMethod], bl	; M063: restore allocmethod

	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jnz	Exec_Set_PDB		; no starto, chumo!

	mov	AX,Exec_DMA
	sub	AX,10h
	mov	Exec_Init_CS,AX
	mov	Exec_Init_IP,100h	; initial IP is 100

		; SI is AT MOST FF00h.	Add FE to account for PSP - word
		; of 0 on stack.

	add	SI,0feh 		; make room for stack

	cmp	si, 0fffeh		; M047: Q: was there >= 64K available
	je	Exec_St_Ok		; M047: Y: stack is fine
	add	si, 100h		; M047: N: add the xtra 100h for stack

Exec_St_Ok:
	mov	Exec_Init_SP,SI 	; max value for read is also SP!;smr;SS Override
	mov	Exec_Init_SS,AX 				;smr;SS Override
	mov	DS,AX
	mov	WORD PTR [SI],0 	; 0 for return

	;
	; M068
	;
	; We now determine if this is a Copy Protected App. If so the 
	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
	; a ret if DOS is loaded low. Also DS contains the load segment.

	call	word ptr [ChkCopyProt]	

Exec_Set_PDB:
	mov	BX,Exec_FH		; we are finished with the file.
	call	Exec_Dealloc
	push	BP
	invoke	$Close			; release the jfn
	pop	BP
	call	Exec_Alloc
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jz	Exec_Build_Header

	call	Scan_Execname
	call	Scan_Special_Entries

;SR;
;The current lie strategy uses the PSP to store the lie version. However,
;device drivers are loaded as overlays and have no PSP. To handle them, we
;use the Sysinit flag provided by the BIOS as part of a structure pointed at
;by BiosDataPtr. If this flag is set, the overlay call has been issued from
;Sysinit and therefore must be a device driver load. We then get the lie 
;version for this driver and put it into the Sysinit PSP. When the driver
;issues the version check, it gets the lie version until the next overlay
;call is issued.
;
	cmp	DriverLoad,0		;was Sysinit processing done?
	je	norm_ovl		;yes, no special handling
	push	si
	push	es
	les	si,BiosDataPtr		;get ptr to BIOS data block
	cmp	byte ptr es:[si],0		;in Sysinit?
	je	sysinit_done		;no, Sysinit is finished

	mov	es,CurrentPDB		;es = current PSP (Sysinit PSP)
	push	Special_Version
	pop	es:PDB_Version		;store lie version in Sysinit PSP
	jmp	short setver_done
sysinit_done:
	mov	DriverLoad,0		;Sysinit done,special handling off
setver_done:
	pop	es
	pop	si
norm_ovl:

	leave
	transfer    Sys_Ret_OK		; overlay load -> done

Exec_Build_Header:

ifdef ROMEXEC
		; Set up cs:ip and ss:sp for the ROM program; ax contains
		; offset of stack 100h for PSP

	cmp	ExecRomFound,1
	jnz	Not_ROM_Exec

		; AX is at most FF00h.	Add FE to account for PSP - word of
		; 0 on stack.

	add	AX,0feh
	mov	SI,AX			;store sp value
	mov	Exec_Init_SP, AX
	mov	AX,Exec_load_block	;address of PSP
	mov	Exec_Init_SS, AX	;set up ss
					;Set up word of 0 on stack for return
	mov	DS,AX			;PSP segment
	mov	WORD PTR [SI],0
	mov	AX, ExecRomAddrL	;get IP
	mov	Exec_init_IP, AX
	mov	AX,ExecRomAddrH 	;get CS
	mov	Exec_Init_CS, AX

Not_ROM_Exec:

endif ; ROMEXEC

	mov	DX,Exec_Load_Block
					; assign the space to the process
	mov	SI,Arena_Owner		; pointer to owner field
	mov	AX,Exec_Environ 	; get environ pointer
	or	AX,AX
	jz	No_Owner		; no environment

	dec	AX			; point to header
	mov	DS,AX
	mov	[SI],DX 		; assign ownership

No_Owner:
	mov	AX,Exec_Load_Block	; get load block pointer
	dec	AX
	mov	DS,AX			; point to header
	mov	[SI],DX 		; assign ownership

	push	DS			;AN000;MS. make ES=DS
	pop	ES			;AN000;MS.
	mov	DI,Arena_Name		;AN000;MS. ES:DI points to destination
	call	Scan_Execname		;AN007;MS. parse execname
					;	   ds:si->name, cx=name length
	push	CX			;AN007;;MS. save for fake version
	push	SI			;AN007;;MS. save for fake version

MoveName:				;AN000;
	lodsb				;AN000;;MS. get char
	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
	jz	Mem_Done		;AN000;;MS. no, move to header
					;AN000;
	stosb				;AN000;;MS. move char
					; MSKK bug fix - limit length copied
	cmp	di,16			; end of memory arena block?
	jae	mem_done		; jump if so

	loop	movename		;AN000;;MS. continue
Mem_Done:				;AN000;
	xor	AL,AL			;AN000;;MS. make ASCIIZ
	cmp	DI,SIZE ARENA		;AN000;MS. if not all filled
	jae	Fill8			;AN000;MS.

	stosb				;AN000;MS.

Fill8:					;AN000;
	pop	SI			;AN007;MS. ds:si -> file name
	pop	CX			;AN007;MS.

	call	Scan_Special_Entries	;AN007;MS.

	push	DX
	mov	SI,exec_size
	add	SI,DX
	Invoke	$Dup_PDB		; ES is now PDB
	pop	DX

	push	exec_environ
	pop	ES:[PDB_environ]
					; *** Added for DOS 5.00
					; version number in PSP
 	push	[Special_Version]	; Set the DOS version number to
	pop	ES:[PDB_Version]	; to be used for this application

					; set up proper command line stuff
	lds	SI,Exec_Blk		; get the block
	push	DS			; save its location
	push	SI
	lds	SI,[SI.EXEC0_5C_FCB]	; get the 5c fcb

		; DS points to user space 5C FCB

	mov	CX,12			; copy drive, name and ext
	push	CX
	mov	DI,5Ch
	mov	BL,[SI]
	rep	movsb

		; DI = 5Ch + 12 = 5Ch + 0Ch = 68h

	xor	AX,AX			; zero extent, etc for CPM
	stosw
	stosw

		; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch

	pop	CX
	pop	SI			; get block
	pop	DS
	push	DS			; save (again)
	push	SI
	lds	SI,[SI.exec0_6C_FCB]	; get 6C FCB

		; DS points to user space 6C FCB

	mov	BH,[SI] 		; do same as above
	rep	movsb
	stosw
	stosw
	pop	SI			; get block (last time)
	pop	DS
	lds	SI,[SI.exec0_com_line]	; command line

		; DS points to user space 80 command line

	or	CL,80h
	mov	DI,CX
	rep	movsb			; Wham!

		; Process BX into default AX (validity of drive specs on args).
		; We no longer care about DS:SI.

	dec	CL			; get 0FFh in CL
	mov	AL,BH
	xor	BH,BH
	invoke	GetVisDrv
	jnc	Exec_BL

	mov	BH,CL

Exec_BL:
	mov	AL,BL
	xor	BL,BL
	invoke	GetVisDrv
	jnc	exec_Set_Return

	mov	BL,CL

Exec_Set_Return:
	invoke	get_user_stack		; get his return address
	push	[SI.user_CS]		; suck out the CS and IP
	push	[SI.user_IP]
	push	[SI.user_CS]		; suck out the CS and IP
	push	[SI.user_IP]
	pop	WORD PTR ES:[PDB_Exit]
	pop	WORD PTR ES:[PDB_Exit+2]
	xor	AX,AX
	mov	DS,AX
					; save them where we can get them
					; later when the child exits.
	pop	DS:[ADDR_INT_TERMINATE]
	pop	DS:[ADDR_INT_TERMINATE+2]
	mov	WORD PTR DMAADD,80h	; SS Override
	mov	DS,CurrentPDB		; SS Override
	mov	WORD PTR DMAADD+2,DS	; SS Override
	test	BYTE PTR exec_func,exec_func_no_execute
	jz	exec_go

	lds	SI,DWORD PTR Exec_Init_SP ; get stack SS Override
	les	DI,Exec_Blk		; and block for return
	mov	ES:[DI].EXEC1_SS,DS	; return SS

	dec	SI			; 'push' default AX
	dec	SI
	mov	[SI],BX 		; save default AX reg
	mov	ES:[DI].Exec1_SP,SI	; return 'SP'

	lds	AX,DWORD PTR Exec_Init_IP ; SS Override
	mov	ES:[DI].Exec1_CS,DS	; initial entry stuff

	mov	ES:[DI].Exec1_IP,AX
	leave
	transfer Sys_Ret_OK

exec_go:
	lds	SI,DWORD PTR Exec_Init_IP   ; get entry point SS Override
	les	DI,DWORD PTR Exec_Init_SP   ; new stack SS Override
	mov	AX,ES


	cmp	[DosHasHMA], 0		; Q: is dos in HMA (M021)
	je	Xfer_To_User		; N: transfer control to user

	push	ds			; Y: control must go to low mem stub	
	getdseg	<ds>			;    where we disable a20 and Xfer 
					;    control to user 

	or	[DOS_FLAG], EXECA20OFF	; M068:
					; M004: Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc 
					; under TAG M003 & M009 for 
					; explanation
	mov	[A20OFF_PSP], dx	; M068: set the PSP for which A20 is
					; M068: going to be turned OFF.

	mov	ax, ds			; ax = segment of low mem stub
	pop	ds
	assume	ds:nothing

	push	ax			; ret far into the low mem stub
	mov	ax, OFFSET Disa20_Xfer
	push	ax
	mov	AX,ES			; restore ax
	retf

Xfer_To_User:


		; DS:SI points to entry point
		; AX:DI points to initial stack
		; DX has PDB pointer
		; BX has initial AX value

	cli
	mov	BYTE PTR InDos,0	; SS Override

	ASSUME	SS:NOTHING

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
	sti

	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX

	retf

EndProc $Exec

; =========================================================================
;
; =========================================================================

Procedure   ExecRead,NEAR
	CALL	exec_dealloc
	MOV	bx,exec_fh
	PUSH	BP
	invoke	$READ
	POP	BP
	CALL	exec_alloc
	return
EndProc ExecRead

; =========================================================================
;
; =========================================================================

procedure   exec_dealloc,near

	push	    BX
	.errnz	    arena_owner_system
	sub	    BX,BX		; (bx) = ARENA_OWNER_SYSTEM
	EnterCrit   CritMEM
	call	    ChangeOwners
	pop	    BX
	return

EndProc exec_dealloc

; =========================================================================
;
; =========================================================================

procedure   exec_alloc,near
	ASSUME	SS:DOSDATA

	push	    BX
	mov	    BX,CurrentPDB	; SS Override
	call	    ChangeOwners
	LeaveCrit   CritMEM
	pop	    BX
	return

EndProc exec_alloc

; =========================================================================
;
; =========================================================================

PROCEDURE   ChangeOwners,NEAR

	pushf
	push	AX
	mov	AX,exec_environ
	call	ChangeOwner
	mov	AX,exec_load_block
	call	ChangeOwner
	pop	AX
	popf
	return

ENDPROC ChangeOwners

; =========================================================================
;
; =========================================================================

PROCEDURE   ChangeOwner,NEAR

	or	AX,AX			; is area allocated?
	retz				; no, do nothing
	dec	AX
	push	DS
	mov	DS,AX
	mov	DS:[ARENA_OWNER],BX
	pop	DS
	return

EndProc ChangeOwner

; =========================================================================
;
; =========================================================================

Procedure	Scan_Execname,near
	ASSUME	SS:DosData

	lds	SI,ExecName		; DS:SI points to name
Entry	Scan_Execname1			; M028
Save_Begin:				;
	mov	CX,SI			; CX= starting addr
Scan0:					;
	lodsb				; get char

IFDEF	DBCS		 		; MSKK01 07/14/89
	invoke	TESTKANJ		; Is Character lead byte of DBCS?
	jz	@F			; jump if not
	lodsb				; skip over DBCS character
	jmp	short scan0		; do scan again
@@:
ENDIF

	cmp	AL,':'			; is ':' , may be A:name
	jz	save_begin		; yes, save si
	cmp	AL,'\'                  ; is '\', may be A:\name
	jz	save_begin		; yes, save si
	cmp	AL,0			; is end of name
	jnz	scan0			; no, continue scanning
	sub	SI,CX			; get name's length
	xchg	SI,CX			; cx= length, si= starting addr

	return

EndProc Scan_Execname

; =========================================================================
;
; =========================================================================

Procedure    Scan_Special_Entries,near
	assume	SS:DOSDATA

	dec	CX			; cx= name length
;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
					;reset to current version
	mov    [Special_Version],(Minor_Version SHL 8) + Major_Version
;***	call	Reset_Version

;M060	push	SS
;M060	pop	ES

	les	DI,SS:UU_IFS_DOS_CALL	;M060; ES:DI --> Table in SETVER.SYS
	mov	AX,ES			;M060; First do a NULL ptr check to
	or	AX,DI			;M060; be sure the table exists
	jz	End_List		;M060; If ZR then no table

GetEntries:
	mov	AL,ES:[DI]		; end of list
	or	AL,AL
	jz	End_List		; yes

	mov	[Temp_Var2],DI		; save di
	cmp	AL,CL			; same length ?
	jnz	SkipOne 		; no

	inc	DI			; es:di -> special name
	push	CX			; save length and name addr
	push	SI

;
; M050 - BEGIN
;
	push	ax			; save len
sse_next_char:
	lodsb
	call	UCase
	scasb
	jne	Not_Matched
	loop	sse_next_char
	
;
;	repz	cmpsb			; same name ?
;
;	jnz	Not_Matched		; no
;
	pop	ax			; take len off the stack
;
; M050 - END
;
	mov	AX,ES:[DI]		; get special version
	mov	[Special_Version],AX	; save it

;***	mov	AL,ES:[DI+2]		; get fake count
;***	mov	[Fake_Count],AL 	; save it

	pop	SI
	pop	CX
	jmp	SHORT end_list

Not_Matched:
	pop	ax			; get len from stack ; M050
	pop	SI			; restore si,cx
	pop	CX

SkipOne:
	mov	DI,[Temp_Var2]		; restore old di use SS Override
	xor	AH,AH			; position to next entry
	add	DI,AX

	add	DI,3			; DI -> next entry length
;***	add	DI,4			; DI -> next entry length

	jmp	Getentries

End_List:
	return

EndProc Scan_Special_Entries

; =========================================================================
;
; =========================================================================
;
;Procedure    Reset_Version,near
;	assume	SS:DOSDATA
;
;	cmp    [Fake_Count],0ffh
;	jnz    @F
;	mov    [Special_Version],0	;reset to current version
;@@:
;	return
;
;EndProc Reset_Version,near

PAGE
; =========================================================================
;SUBTTL Terminate and stay resident handler
;
; Input:    DX is  an  offset  from  CurrentPDB  at which to
;	    truncate the current block.
;
; output:   The current block is truncated (expanded) to be [DX+15]/16
;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
;	    and restoring the vectors.
;
; =========================================================================
PROCEDURE $Keep_process ,NEAR
	ASSUME DS:NOTHING,ES:NOTHING,SS:DosData

	push	AX			; keep exit code around
	mov	BYTE PTR Exit_type,EXIT_KEEP_PROCESS
	mov	ES,CurrentPDB
	cmp	DX,6h			; keep enough space around for system
	jae	Keep_shrink		; info

	mov	DX,6h

Keep_Shrink:
	mov	BX,DX
	push	BX
	push	ES
	invoke	$SETBLOCK		; ignore return codes.
	pop	DS
	pop	BX
	jc	keep_done		; failed on modification

	mov	AX,DS
	add	AX,BX
	mov	DS:PDB_block_len,AX	;PBUGBUG

Keep_Done:
	pop	AX
	jmp	SHORT exit_inner	; and let abort take care of the rest

EndProc $Keep_process

; =========================================================================
;
; =========================================================================

PROCEDURE Stay_Resident,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	mov	AX,(Keep_process SHL 8) + 0 ; Lower part is return code;PBUGBUG
	add	DX,15
	rcr	DX,1
	mov	CL,3
	shr	DX,CL

	transfer    COMMAND

ENDPROC Stay_resident


PAGE
; =========================================================================
;SUBTTL $EXIT - return to parent process
;   Assembler usage:
;	    MOV     AL, code
;	    MOV     AH, Exit
;	    INT     int_command
;   Error return:
;	    None.
;
; =========================================================================

PROCEDURE   $Exit ,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:DosData

	xor	AH,AH
	xchg	AH,BYTE PTR DidCtrlC
	or	AH,AH
	mov	BYTE PTR Exit_Type,EXIT_TERMINATE
	jz	exit_inner
	mov	BYTE PTR Exit_type,exit_ctrl_c

	entry	Exit_inner

	invoke	get_user_stack		;PBUGBUG

	ASSUME DS:NOTHING

	push	CurrentPDB
	pop	[SI.User_CS]		;PBUGBUG
	jmp	SHORT Abort_Inner

EndProc $EXIT

BREAK <$ABORT -- Terminate a process>
; =========================================================================
; Inputs:
;	user_CS:00 must point to valid program header block
; Function:
;	Restore terminate and Cntrl-C addresses, flush buffers and transfer to
;	the terminate address
; Returns:
;	TO THE TERMINATE ADDRESS
; =========================================================================

PROCEDURE   $Abort ,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING	;PBUGBUG

	xor	AL,AL
	mov	exit_type,exit_abort

		; abort_inner must have AL set as the exit code! The exit type
		; is retrieved from exit_type. Also, the PDB at user_CS needs
		; to be correct as the one that is terminating.

	PUBLIC	Abort_Inner
Abort_Inner:

	mov	AH,Exit_Type
	mov	Exit_Code,AX
	invoke	Get_User_Stack

	ASSUME DS:NOTHING

	mov	DS,[SI.User_CS]	; set up old interrupts ;PBUGBUG
	xor	AX,AX
	mov	ES,AX
	mov	SI,SavExit
	mov	DI,Addr_Int_Terminate
	movsw
	movsw
	movsw
	movsw
	movsw
	movsw
	transfer reset_environment

ENDPROC $ABORT

;==========================================================================
;
; fixexepatch will poin to this is DOS loads low. 
;
;=========================================================================
retexepatch	proc	near
	
	ret

retexepatch 	endp

; =========================================================================

DOSCODE	ENDS

; =========================================================================

	END




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mshalo.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
;   there is a header that describes a block of rom program.  This header
;   contains information needed to initialize a module and to provide PCDOS
;   with a set of reserved names for execution.
;
;   This header has the following format:
;
;   rom_header	STRUC
;	Signature1  DB	55h
;	Signature2  DB	AAh
;	rom_length  DB	?		; number of 512 byte pieces
;	init_jmp    DB	3 dup (?)
;	name_list   name_struc <>
;   rom_header	ENDS
;
;   name_struc	STRUC
;	name_len    DB	?
;	name_text   DB	? DUP (?)
;	name_jmp    DB	3 DUP (?)
;   name_struc	ENDS
;
;   The name list is a list of names that are reserved by a particular section
;   of a module.  This list of names is terminated by a null name (length
;   is zero).
;
;   Consider now, the PCDOS action when a user enters a command:
;
;	COMMAND.COM has control.
;	o   If location FFFFEh has FDh then
;	o	Start scanning at C0000h, every 800h for a byte 55h followed
;		    by AAh, stop scan if we get above or = F0000H
;	o	When we've found one, compare the name entered by the user
;		    with the one found in the rom.  If we have a match, then
;		    set up the environment for execution and do a long jump
;		    to the near jump after the found name.
;	o	If no more names in the list, then continue scanning the module
;		    for more 55h followed by AAh.
;	o   We get to this point only if there is no matching name in the
;		rom.  We now look on disk for the command.
;
;   This gives us the flexibility to execute any rom cartridge without having
;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
;   want to be invisible to the DOS should not have any names in their lists
;   (i.e. they have a single null name).
;
;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
;   Clearly this version will be available on disk.  How does a user actually
;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
;   EXEC loader will execute the ROM before it even looks at the disk!	Only
;   solution:
;
;   o	Keep things consistent and force the user to have his software named
;	differently from the ROM names (BASIC1, BASIC2, etc).

rom_header  STRUC
    Signature1	DB  ?
    Signature2	DB  ?
    rom_length	DB  ?
    init_jmp	DB  3 dup (?)
    name_list	DB  ?
rom_header  ENDS

name_struc  STRUC
    name_len	DB  ?
    name_text	DB  1 DUP (?)
    name_jmp	DB  3 DUP (?)
name_struc  ENDS

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;
; Check for IBM HALO rom cartrides. DS:DX is a pointer to name
;
ROM_SCAN:
	PUSH	ES
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX
	PUSH	BX
;
; check for halo signature in rom
;
	MOV	AX,0F000h
	MOV	ES,AX
	CMP	BYTE PTR ES:[0FFFEh],0FDh
	JZ	SCAN_IT
NO_ROM:
	CLC
ROM_RET:
	POP	BX
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	POP	ES
	RET
SCAN_IT:
;
; start scanning at C000
;
	MOV	AX,0C000h
SCAN_ONE:
	MOV	ES,AX
	XOR	DI,DI
SCAN_MODULE:
;
; check for a valid header
;
	CMP	WORD PTR ES:[DI],0AA55h
	JZ	SCAN_LIST
	ADD	AX,080h
SCAN_END:
	CMP	AX,0F000h
	JB	SCAN_ONE
	JMP	NO_ROM
;
; trundle down list of names
;
SCAN_LIST:
	MOV	BL,ES:[DI].rom_length	; number of 512-byte jobbers
	XOR	BH,BH			; nothing in the high byte
	SHL	BX,1
	SHL	BX,1			; number of paragraphs
	ADD	BX,7Fh
	AND	BX,0FF80h		; round to 2k

	MOV	DI,name_list
SCAN_NAME:
	MOV	CL,ES:[DI]		; length of name
	INC	DI			; point to name
	XOR	CH,CH
	OR	CX,CX			; zero length name
	JNZ	SCAN_TEST		; nope... compare
	ADD	AX,BX			; yep, skip to next block
	JMP	SCAN_END
;
; compare a single name
;
SCAN_TEST:
	MOV	SI,DX
	INC	SI
	REPE	CMPSB			; compare name
	JZ	SCAN_FOUND		; success!
SCAN_NEXT:
	ADD	DI,CX			; failure, next name piece
	ADD	DI,3
	JMP	SCAN_NAME
;
; found a name. save entry location
;
SCAN_FOUND:
	CMP	BYTE PTR DS:[SI],'?'
	JZ	SCAN_SAVE
	CMP	BYTE PTR DS:[SI],' '
	JNZ	SCAN_NEXT
SCAN_SAVE:
	MOV	[rom_cs],ES
	MOV	[ROM_ip],DI
	STC
	JMP	ROM_RET

;
; execute a rom-placed body of code. allocate largest block
;
ROM_EXEC:
	MOV	BX,0FFFFh
	MOV	AH,ALLOC
	INT	int_command
	MOV	AH,ALLOC
	INT	int_command
	PUSH	BX
	PUSH	AX
;
; set terminate addresses
;
	MOV	AX,(set_interrupt_vector SHL 8) + int_terminate
	PUSH	DS
	MOV	DS,[RESSEG]
	ASSUME	DS:RESGROUP
	MOV	DX,OFFSET RESGROUP:EXEC_WAIT
	INT	int_command
	MOV	DX,DS
	MOV	ES,DX
	ASSUME	ES:RESGROUP
	POP	DS
	ASSUME	DS:NOTHING
;
; and create program header and dup all jfn's
;
	POP	DX
	MOV	AH,DUP_PDB
	INT	int_command
;
; set up dma address
;
	MOV	DS,DX
	MOV	DX,080h
	MOV	AH,SET_DMA
	INT	int_command
;
; copy in environment info
;
	MOV	AX,[ENVIRSEG]
	MOV	DS:[PDB_environ],AX
;
; set up correct size of block
;
	POP	BX			; BX has size, DS has segment
	MOV	DX,DS
	ADD	DX,BX
	MOV	DS:[PDB_block_len],DX
;
; change ownership of block
;
	MOV	DX,DS
	DEC	DX
	MOV	DS,DX
	INC	DX
	MOV	DS:[arena_owner],DX
	MOV	DS,DX
;
; set up correct stack
;
	CMP	BX,1000h
	JB	GOT_STACK
	XOR	BX,BX
GOT_STACK:
	MOV	CL,4
	SHL	BX,CL
	MOV	DX,DS
	MOV	SS,DX
	MOV	SP,BX
	XOR	AX,AX
	PUSH	AX
;
; set up initial registers and go to the guy
;
	NOT	AX
	PUSH	[ROM_CS]
	PUSH	[ROM_IP]
	MOV	ES,DX
ASSUME ES:NOTHING
FOOBAR	PROC	FAR
	RET
FOOBAR	ENDP

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\parse.asm ===
TITLE PARSE - Parsing system calls for MS-DOS
	NAME  PARSE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


; System calls for parsing command lines
;
;   $PARSE_FILE_DESCRIPTOR
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;               EE PathParse 10 Sept 1983
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	.cref
	.list


DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
;---------------------------------------------------------------------------
; Inputs:
;       DS:SI Points to a command line
;       ES:DI Points to an empty FCB
;       Bit 0 of AL = 1 At most one leading separator scanned off
;                   = 0 Parse stops if separator encountered
;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
;                   = 0  "    "    "     "         "      "  - put 0 in FCB
;       Bit 2 of AL = 1 If filename field blank - leave FCB
;                   = 0  "       "      "       - put blanks in FCB
;       Bit 3 of AL = 1 If extension field blank - leave FCB
;                   = 0  "       "      "        - put blanks in FCB
; Function:
;       Parse command line into FCB
; Returns:
;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
;       DS:SI points to first character after filename
;---------------------------------------------------------------------------

	procedure   $PARSE_FILE_DESCRIPTOR,NEAR
ASSUME  DS:NOTHING,ES:NOTHING

	invoke  MAKEFCB
	PUSH    SI
	invoke  get_user_stack
	POP     [SI.user_SI]
	return
EndProc $PARSE_FILE_DESCRIPTOR


DOSCODE    ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\mstable.asm ===
;	SCCSID = @(#)ibmtable.asm	1.1 85/04/10
;
; Table Segment for DOS
;

.xlist
.xcref
include version.inc
include mssw.asm
.cref
.list

TITLE	IBMTABLE - Table segment for DOS
NAME	IBMTABLE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; ==========================================================================



;**	MS_TABLE.ASM
;
;       Revision history:
;         A000   version 4.0  Jan. 1988
;         A001   DCR 486 - Share installation for >32mb drives
;         A006   DCR 503 - fake version for IBMCACHE
;         A008   PTM 4070 - fake version for MS WINDOWS
;	  M006   Fake Version call no longer supported. 8/6/90

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include fastopen.inc
	include dossym.inc
	include syscall.inc
	.cref
	.list

        AsmVars <Debug, Redirector, ShareF>

DOSCODE SEGMENT

TableZero   LABEL   BYTE

        PUBLIC  MSVERS
PUBLIC MSTAB001s,MSTAB001e
MSTAB001S       label byte

MSVERS  EQU     THIS WORD               ; MS-DOS version in hex for $GET_VERSION
MSMAJOR DB      MAJOR_VERSION
MSMINOR DB      MINOR_VERSION

;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
;        I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
;        I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]

;
; This is the error code mapping table for INT 21 errors.  This table defines
; those error codes which are "allowed" for each system call.  If the error
; code ABOUT to be returned is not "allowed" for the call, the correct action
; is to return the "real" error via Extended error, and one of the allowed
; errors on the actual call.
;
; The table is organized as follows:
;
;    Each entry in the table is of variable size, but the first
;       two bytes are always:
;
;       Call#,Cnt of bytes following this byte
;
; EXAMPLE:
;       Call 61 (OPEN)
;
;       DB      61,5,12,3,2,4,5
;
;       61 is the AH INT 21 call value for OPEN.
;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
;       Next five bytes are those error codes which are "allowed" on OPEN.
;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
;       this case 5).  The last value will be the one returned on the call if
;       the "real" error is not one of the allowed ones.
;
; There are a number of calls (for instance all of the FCB calls) for which
;   there is NO entry.  This means that NO error codes are returned on this
;   call, so set up an Extended error and leave the current error code alone.
;
; The table is terminated by a call value of 0FFh

PUBLIC  I21_MAP_E_TAB
I21_MAP_E_TAB   LABEL   BYTE
    DB  International,2,error_invalid_function,error_file_not_found
    DB  MKDir,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  RMDir,4,error_current_directory,error_path_not_found
    DB          error_file_not_found,error_access_denied
    DB  CHDir,2,error_file_not_found,error_path_not_found
    DB  Creat,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files
    DB          error_access_denied
    DB  Open,6,error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files
    DB          error_not_dos_disk,error_access_denied
    DB  Close,1,error_invalid_handle
    DB  Read,2,error_invalid_handle,error_access_denied
    DB  Write,2,error_invalid_handle,error_access_denied
    DB  Unlink,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  LSeek,2,error_invalid_handle,error_invalid_function
    DB  CHMod,4,error_path_not_found,error_file_not_found,error_invalid_function
    DB          error_access_denied
    DB  IOCtl,5,error_invalid_drive,error_invalid_data,error_invalid_function
    DB          error_invalid_handle,error_access_denied
    DB  XDup,2,error_invalid_handle,error_too_many_open_files
    DB  XDup2,2,error_invalid_handle,error_too_many_open_files
    DB  Current_Dir,2,error_not_DOS_disk,error_invalid_drive
    DB  Alloc,2,error_arena_trashed,error_not_enough_memory
    DB  Dealloc,2,error_arena_trashed,error_invalid_block
    DB  Setblock,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
    DB  Exec,8,error_path_not_found,error_invalid_function,error_file_not_found
    DB          error_too_many_open_files,error_bad_format,error_bad_environment
    DB          error_not_enough_memory,error_access_denied
    DB  Find_First,3,error_path_not_found,error_file_not_found,error_no_more_files
    DB  Find_Next,1,error_no_more_files
    DB  Rename,5,error_not_same_device,error_path_not_found,error_file_not_found
    DB          error_current_directory,error_access_denied
    DB  File_Times,4,error_invalid_handle,error_not_enough_memory
    DB               error_invalid_data,error_invalid_function
    DB  AllocOper,1,error_invalid_function
    DB  CreateTempFile,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files,error_access_denied
    DB  CreateNewFile,5,error_file_exists,error_path_not_found
    DB          error_file_not_found,error_too_many_open_files,error_access_denied
    DB  LockOper,4,error_invalid_handle,error_invalid_function
    DB          error_sharing_buffer_exceeded,error_lock_violation
    DB  GetExtCntry,2,error_invalid_function,error_file_not_found       ;DOS 3.3
    DB  GetSetCdPg,2,error_invalid_function,error_file_not_found        ;DOS 3.3
    DB  Commit,1,error_invalid_handle                                   ;DOS 3.3
    DB  ExtHandle,3,error_too_many_open_files,error_not_enough_memory
    DB              error_invalid_function
    DB  ExtOpen,10
    DB    error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files,error_file_exists,error_not_enough_memory
    DB          error_not_dos_disk,error_invalid_data
    DB              error_invalid_function,error_access_denied
    DB  GetSetMediaID,4,error_invalid_drive,error_invalid_data
    DB          error_invalid_function,error_access_denied
    DB  0FFh


        PUBLIC  DISPATCH

;MAXCALL 	EQU      VAL1
;MAXCOM  	EQU	 VAL2

; Standard Functions
DISPATCH    LABEL WORD
        short_addr  $ABORT                          ;  0      0
        short_addr  $STD_CON_INPUT                  ;  1      1
        short_addr  $STD_CON_OUTPUT                 ;  2      2
        short_addr  $STD_AUX_INPUT                  ;  3      3
        short_addr  $STD_AUX_OUTPUT                 ;  4      4
        short_addr  $STD_PRINTER_OUTPUT             ;  5      5
        short_addr  $RAW_CON_IO                     ;  6      6
        short_addr  $RAW_CON_INPUT                  ;  7      7
        short_addr  $STD_CON_INPUT_NO_ECHO          ;  8      8
        short_addr  $STD_CON_STRING_OUTPUT          ;  9      9
        short_addr  $STD_CON_STRING_INPUT           ; 10      A
        short_addr  $STD_CON_INPUT_STATUS           ; 11      B
        short_addr  $STD_CON_INPUT_FLUSH            ; 12      C
        short_addr  $DISK_RESET                     ; 13      D
        short_addr  $SET_DEFAULT_DRIVE              ; 14      E
        short_addr  $FCB_OPEN                       ; 15      F
        short_addr  $FCB_CLOSE                      ; 16     10
        short_addr  $DIR_SEARCH_FIRST               ; 17     11
        short_addr  $DIR_SEARCH_NEXT                ; 18     12
        short_addr  $FCB_DELETE                     ; 19     13
        short_addr  $FCB_SEQ_READ                   ; 20     14
        short_addr  $FCB_SEQ_WRITE                  ; 21     15
        short_addr  $FCB_CREATE                     ; 22     16
        short_addr  $FCB_RENAME                     ; 23     17
	short_addr  NO_OP			    ; 24     18
        short_addr  $GET_DEFAULT_DRIVE              ; 25     19
        short_addr  $SET_DMA                        ; 26     1A

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $SLEAZEFUNC                     ; 27     1B
        short_addr  $SLEAZEFUNCDL                   ; 28     1C
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

	short_addr  NO_OP			    ; 29     1D
	short_addr  NO_OP			    ; 30     1E
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $GET_DEFAULT_DPB                ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
	short_addr  NO_OP			    ; 32     20
        short_addr  $FCB_RANDOM_READ                ; 33     21
        short_addr  $FCB_RANDOM_WRITE               ; 34     22
        short_addr  $GET_FCB_FILE_LENGTH            ; 35     23
        short_addr  $GET_FCB_POSITION               ; 36     24


VAL1    =       ($-DISPATCH)/2 - 1

	PUBLIC	MAXCALL
MaxCall = VAL1

; Extended Functions
        short_addr  $SET_INTERRUPT_VECTOR           ; 37     25
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $CREATE_PROCESS_DATA_BLOCK      ; 38     26
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $FCB_RANDOM_READ_BLOCK          ; 39     27
        short_addr  $FCB_RANDOM_WRITE_BLOCK         ; 40     28
        short_addr  $PARSE_FILE_DESCRIPTOR          ; 41     29
        short_addr  $GET_DATE                       ; 42     2A
        short_addr  $SET_DATE                       ; 43     2B
        short_addr  $GET_TIME                       ; 44     2C
        short_addr  $SET_TIME                       ; 45     2D
        short_addr  $SET_VERIFY_ON_WRITE            ; 46     2E

; Extended functionality group
        short_addr  $GET_DMA                        ; 47     2F
        short_addr  $GET_VERSION                    ; 48     30
        short_addr  $Keep_Process                   ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $GET_DPB                        ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $SET_CTRL_C_TRAPPING            ; 51     33
        short_addr  $GET_INDOS_FLAG                 ; 52     34
        short_addr  $GET_INTERRUPT_VECTOR           ; 53     35
        short_addr  $GET_DRIVE_FREESPACE            ; 54     36
        short_addr  $CHAR_OPER                      ; 55     37
        short_addr  $INTERNATIONAL                  ; 56     38
; XENIX CALLS
;   Directory Group
        short_addr  $MKDIR                          ; 57     39
        short_addr  $RMDIR                          ; 58     3A
        short_addr  $CHDIR                          ; 59     3B
;   File Group
        short_addr  $CREAT                          ; 60     3C
        short_addr  $OPEN                           ; 61     3D
        short_addr  $CLOSE                          ; 62     3E
        short_addr  $READ                           ; 63     3F
        short_addr  $WRITE                          ; 64     40
        short_addr  $UNLINK                         ; 65     41
        short_addr  $LSEEK                          ; 66     42
        short_addr  $CHMOD                          ; 67     43
        short_addr  $IOCTL                          ; 68     44
        short_addr  $DUP                            ; 69     45
        short_addr  $DUP2                           ; 70     46
        short_addr  $CURRENT_DIR                    ; 71     47
;    Memory Group
        short_addr  $ALLOC                          ; 72     48
        short_addr  $DEALLOC                        ; 73     49
        short_addr  $SETBLOCK                       ; 74     4A
;    Process Group
        short_addr  $EXEC                           ; 75     4B
        short_addr  $EXIT                           ; 76     4C
        short_addr  $WAIT                           ; 77     4D
        short_addr  $FIND_FIRST                     ; 78     4E
;   Special Group
        short_addr  $FIND_NEXT                      ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $SET_CURRENT_PDB                ; 80     50
        short_addr  $GET_CURRENT_PDB                ; 81     51
        short_addr  $GET_IN_VARS                    ; 82     52
        short_addr  $SETDPB                         ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $GET_VERIFY_ON_WRITE            ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $DUP_PDB                        ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $RENAME                         ; 86     56
        short_addr  $FILE_TIMES                     ; 87     57
        short_addr  $AllocOper                      ; 88     58
; Network extention system calls
        short_addr  $GetExtendedError               ; 89     59
        short_addr  $CreateTempFile                 ; 90     5A
        short_addr  $CreateNewFile                  ; 91     5B
        short_addr  $LockOper                       ; 92     5C
        short_addr  $ServerCall                     ; 93     5D
        short_addr  $UserOper                       ; 94     5E
        short_addr  $AssignOper                     ; 95     5F
        short_addr  $NameTrans                      ; 96     60
	short_addr  NO_OP			    ; 97     61
        short_addr  $Get_Current_PDB                ; 98     62
; the next call is reserved for hangool sys call
        short_addr  $ECS_Call                       ; 99     63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $Set_Printer_Flag               ; 100    64
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $GetExtCntry                    ; 101    65
        short_addr  $GetSetCdPg                     ; 102    66
        short_addr  $ExtHandle                      ; 103    67
        short_addr  $Commit                         ; 104    68
        short_addr  $GSetMediaID                    ; 105    69   ;AN000;
        short_addr  $Commit                         ; 106    6A   ;AN000;
        short_addr  NO_OP                           ; 107    6B   
						    ; IFS_IOCTL no longer 
						    ; supported
        short_addr  $Extended_Open                  ; 108    6C   ;AN000;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
ifdef ROMEXEC
        short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
        short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
	short_addr  $ROM_EXCLUDE		    ; 111    6F		; M078
endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;




VAL2    =       ($-DISPATCH)/2 - 1

	PUBLIC	MAXCOM
MaxCom 	= 	VAL2

        If      Installed

PUBLIC FOO
FOO     LABEL WORD
        Short_addr  Leave2F
DTab    DW  OFFSET  DOSCODE:DOSTable
        PUBLIC FOO,DTAB

DOSTable    LABEL   WORD
        DB      (DOSTableEnd-DOSTable-1)/2
        Short_addr  DOSInstall          ;   0 install check
        Short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
        Short_addr  RECSET              ;   2   RECSET
        Short_addr  DOSGetGroup         ;   3   Get DOSGROUP
        Short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
        Short_addr  OUTT                ;   5   OUT
        Short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
        Short_addr  PLACEBUF            ;   7   PLACEBUF
        Short_addr  FREE_SFT            ;   8   FREE_SFT
        Short_addr  BUFWRITE            ;   9   BUFWRITE
        Short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
        Short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
        Short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
        Short_addr  DATE16              ;   13  DATE16
        Short_addr  idle                ;   14      empty slot
        Short_addr  SCANPLACE           ;   15  SCANPLACE
        Short_addr  idle                ;   16      empty slot
        Short_addr  StrCpy              ;   17  StrCpy
        Short_addr  StrLen              ;   18  StrLen
        Short_addr  Ucase               ;   19  Ucase
        Short_addr  POINTCOMP           ;   20  POINTCOMP
        Short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
        Short_addr  SFFromSFN           ;   22  SFFromSFN
        Short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
        Short_addr  Get_User_Stack      ;   24  Get_User_Stack
        Short_addr  GetThisDrv          ;   25  GetThisDrv
        Short_addr  DriveFromText       ;   26  DriveFromText
        Short_addr  SETYEAR             ;   27  SETYEAR
        Short_addr  DSUM                ;   28  DSUM
        Short_addr  DSLIDE              ;   29  DSLIDE
        Short_addr  StrCmp              ;   30  StrCmp
        Short_addr  InitCDS             ;   31  initcds
        Short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
        Short_addr  $NameTrans          ;   33  $NameTrans
        Short_addr  CAL_LK              ;   34  CAL_LK
        Short_addr  DEVNAME             ;   35  DEVNAME
        Short_addr  Idle                ;   36  Idle
        Short_addr  DStrLen             ;   37  DStrLen
        Short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
        Short_addr  $CLOSE              ;   39  $CLOSE        DOS 3.3
        Short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
        Short_addr  $READ               ;   41  $READ         DOS 3.3
        Short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
        Short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
        Short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
        Short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
        Short_addr  MSG_RETRIEVAL       ;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;

	Short_addr  NO_OP		;   M006: 47  no longer supported
;***       Short_addr  Fake_Version     ;   47  Fake_Version  DOS 4.0  ;AN006;

DOSTableEnd LABEL   BYTE

        ENDIF

; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
;       module. The reason is so that the data alignments are the same in
;       IBM-DOS and MS-DOS up through header.


        PUBLIC  HEADER
Header  LABEL   BYTE
        IF      DEBUG
        DB      13,10,"Debugging DOS version "
        DB      MAJOR_VERSION + "0"
        DB      "."
        DB      (MINOR_VERSION / 10) + "0"
        DB      (MINOR_VERSION MOD 10) + "0"
        ENDIF

        IF      NOT IBM
        DB      13,10,"MS-DOS version "
        DB      MAJOR_VERSION + "0"
        DB      "."
        DB      (MINOR_VERSION / 10) + "0"
        DB      (MINOR_VERSION MOD 10) + "0"

        IF      HIGHMEM
        DB      "H"
        ENDIF

	DB	13,10, "Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
	ENDIF

IF DEBUG
        DB      13,10,"$"
ENDIF

MSTAB001E       label byte

include copyrigh.inc


DOSCODE   ENDS

; ==========================================================================

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\origin.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;-------------------------------------------------------------------------
;
; This is the first file to be linked in the DOS. It contains the appropriate
; offset to which the DOS is to be ORG'd. 
;
; See ..\inc\origin.inc for description
;
;---------------------------------------------------------------------------
 	
include version.inc
include dosseg.inc
include dossym.inc
include origin.inc

DOSCODE SEGMENT

	org	0


ifndef ROMDOS

	dw	PARASTART

	org	PARASTART

endif ; ROMDOS

	
DOSCODE ENDS

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\open.asm ===
TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
	NAME	DOS_OPEN

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	OPEN.ASM - File Open
;
;	Low level routines for openning a file from a file spec.
;	Also misc routines for sharing errors
;
;	DOS_Open
;	Check_Access_AX
;	SHARE_ERROR
;	SET_SFT_MODE
;	Code_Page_Mismatched_Error		   ; DOS 4.00
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00   Jan. 1988
;
;	M034 - The value in save_bx must be pushed on to the stack for
; 	       remote extended opens and not save_cx.
;
;	M035 - if open made from exec then we must set the appropriate bits
;	       on the stack before calling off to the redir.
;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
;	       to handle open from exec. In this case set the appropriate bit
;	       else do not.
	

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include fastopen.inc
	include fastxxxx.inc
	include sf.inc
	include mult.inc
	include filemode.inc
	include curdir.inc

	.cref
	.list

Installed = TRUE

	i_need	NoSetDir,BYTE
	i_need	THISSFT,DWORD
	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	CurrentPDB,WORD
	i_need	CURR_DIR_END,WORD
	I_need	RetryCount,WORD
	I_need	Open_Access,BYTE
	I_need	fSharing,BYTE
	i_need	JShare,DWORD
	I_need	FastOpenFlg,byte
	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
	I_need	SAVE_BX,WORD			  ;M034

	I_need	DOS_FLAG,BYTE
	I_need	DOS34_FLAG,WORD			  ;M042



DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<DOS_Open - internal file access>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_Open
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file found
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Access and Sharing mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
;
;	  For FCB SFTs AL should = sharing_compat + open_for_both
;		(not checked)
; Function:
;	Try to open the specified file
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_invalid_access
;			Bad sharing mode or bad access mode or bad combination
;		error_access_denied
;			Attempt to open read only file for writting, or
;			open a directory
;		error_sharing_violation
;			The sharing mode was correct but not allowed
;			generates an INT 24 on compatibility mode SFTs
; DS preserved, others destroyed
;----------------------------------------------------------------------------

procedure   DOS_Open,NEAR

	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 

	DOSAssume   <DS>,"DOS_Open"

	MOV	[NoSetDir],0
	CALL	Check_Access_AX
	JC	ret_label		    ; retc
	LES	DI,[THISSFT]
	XOR	AH,AH

	; sleaze! move only access/sharing mode in.  Leave sf_isFCB unchanged

	MOV	BYTE PTR ES:[DI.sf_mode],AL ; For moment do this on FCBs too
	PUSH	ES
	LES	SI,[THISCDS]
	CMP	SI,-1
	JNZ	TEST_RE_NET
	POP	ES
;Extended open hooks

	TEST	[EXTOPEN_ON],ext_open_on    ;FT. from extnded open		;AN000;
	JZ	NOEXTOP 		    ;FT. no, do normal			;AN000;
IFS_extopen:									;AN000;
	MOV	AL,byte ptr [SAVE_BX]	    ; M034 - save_bx has original bx  
					    ; with which call was made. This
					    ; has the open access bits. 
;;	MOV	AL,byte ptr [SAVE_CX]	    ; M034 - FT. al= create attribute

	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
	MOV	AX,(multNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
	INT	2FH			    ;FT.				;AN000;
	POP	BX			    ;FT. trash bx			;AN000;
	MOV	[EXTOPEN_ON],0		    ;FT.				;AN000;

ret_label:
	return				    ;FT.				;AN000;
NOEXTOP:

;Extended open hooks

IF NOT Installed
	transfer NET_SEQ_OPEN
ELSE

do_net_int2f:


	testb	[DOS_FLAG], EXECOPEN	; Q: was this open call made from exec
	jz	not_exec_open		; N: just do net open
					; Y: check to see if redir is aware
					;    of this 

					; M042 - start
	testb	[DOS34_FLAG], EXEC_AWARE_REDIR
					; Q: does this redir know how to 
					;    this
	jz	not_exec_open		; N: just do net open
					; Y: set bit 3 of access byte and 
					;    set sharing mode to DENY_WRITE
					; M042 - end

	; NOTE: This specific mode has not been set for the code assembled
	; under the "NOT Installed" conditional. Currently Installed is 
	; always one.
					; M035 - set the bits on the stack
	mov	AL, SHARING_DENY_WRITE+EXEC_OPEN

not_exec_open:

	PUSH	AX
	MOV	AX,(multNET SHL 8) OR 22
	INT	2FH
	POP	BX			; clean stack
	return
ENDIF

TEST_RE_NET:
	TEST	ES:[SI.curdir_flags],curdir_isnet
	POP	ES
	JZ	LOCAL_OPEN

;Extended open hooks

	TEST	[EXTOPEN_ON],ext_open_on    ;FT. from extnded open		;AN000;
	JNZ	IFS_extopen		    ;FT. isuue extended open		;AN000;

;Extended open hooks

IF NOT Installed
	transfer NET_OPEN
ELSE

	jmp	short do_net_int2f

;**	PUSH	AX
;**	MOV	AX,(multNET SHL 8) OR 22
;**	INT	2FH
;**	POP	BX			    ; clean stack
;**	return

ENDIF

LOCAL_OPEN:
	EnterCrit   critDisk

; DOS 3.3 FastOPen 6/16/86

	OR	[FastOpenFlg],FastOpen_Set+Special_Fill_Set   ;  only open can
	invoke	GetPath


; DOS 3.3 FastOPen 6/16/86

	JNC	Open_found
	JNZ	bad_path
	OR	CL,CL
	JZ	bad_path
OpenFNF:
	MOV	AX,error_file_not_found
OpenBadRet:

;hkn; FastOpenFlg is in DOSDATA use SS override
	AND	BYTE PTR SS:[FastOpenFlg],Fast_yes    ;; DOS 3.3
	STC
	LeaveCrit   critDisk
	JMP	Clear_FastOpen

bad_path:
	MOV	AX,error_path_not_found
	JMP	OpenBadRet

open_bad_access:
	MOV	AX,error_access_denied
	JMP	OpenBadRet

Open_found:
	JZ	Open_Bad_Access 	; test for directories
	OR	AH,AH
	JS	open_ok 		; Devices don't have attributes
	MOV	ES,WORD PTR [CURBUF+2]	; get buffer location
	MOV	AL,ES:[BX].dir_attr
	TEST	AL,attr_volume_id	; can't open volume ids
	JNZ	open_bad_access
	TEST	AL,attr_read_only	; check write on read only
	JZ	open_ok
;
; The file is marked READ-ONLY.  We verify that the open mode allows access to
; the read-only file.  Unfortunately, with FCB's and net-FCB's we cannot
; determine at the OPEN time if such access is allowed.  Thus, we defer such
; processing until the actual write operation:
;
; If FCB, then we change the mode to be read_only.
; If net_FCB, then we change the mode to be read_only.
; If not open for read then error.
;
	SAVE	<DS,SI>
	LDS	SI,[THISSFT]
	MOV	CX,[SI].sf_mode
	TEST	CX,sf_isFCB		; is it FCB?
	JNZ	ResetAccess		; yes, reset the access
	MOV	DL,CL
	AND	DL,sharing_mask
	CMP	DL,sharing_net_FCB	; is it net FCB?
	JNZ	NormalOpen		; no
ResetAccess:
	AND	CX,NOT access_mask	; clear access
	.errnz	open_for_read
;	OR	CX,open_for_read	; stick in open_for_read
	MOV	[SI].sf_mode,CX
	JMP	SHORT FillSFT
;
; The SFT is normal.  See if the requested access is open_for_read
;
NormalOpen:
	AND	CL,access_mask		; remove extras
	CMP	CL,open_for_read	; is it open for read?
	JZ	FillSFT
	RESTORE <SI,DS>
	JMP	short open_bad_access
;
; All done, restore registers and fill the SFT.
;
FillSFT:
	RESTORE <SI,DS>
open_ok:
	invoke	DOOPEN			; Fill in SFT

;hkn; FastOpenFlg is in DOSDATA. use SS override
	AND	BYTE PTR SS:[FastOpenFlg],Fast_yes    ;; DOS 3.3
	CALL	DO_SHARE_CHECK		;
	JNC	Share_Ok
	LeaveCrit   critDisk
	JMP	short Clear_FastOPen

SHARE_OK:
	MOV	AX,3
	LES	DI,ThisSFT
if installed
	call	JShare + 14 * 4
else
	Call	ShSU
endif
	LeaveCrit   critDisk
	FallThru    Set_SFT_Mode

EndProc DOS_Open,NoCheck

;----------------------------------------------------------------------------
; Procedure Name : SET_SFT_MODE
;
; Finish SFT initialization for new reference.	Set the correct mode.
;
;   Inputs:
;	ThisSFT points to SFT
;
;   Outputs:
;	Carry clear
;   Registers modified: AX.
;---------------------------------------------------------------------------

;hkn; called from create. DS already set up to DOSDATA.

PROCEDURE Set_SFT_Mode,NEAR

	DOSAssume   <DS>,"Set_SFT_Mode"
	LES	DI,ThisSFT
	invoke	DEV_OPEN_SFT
	TEST	ES:[DI.sf_mode],sf_isfcb; Clears carry
	JZ	Clear_FastOpen		; sf_mode correct (retz)
	MOV	AX,[CurrentPDB]
	MOV	ES:[DI.sf_PID],AX	; For FCB sf_PID=PDB

Clear_FastOpen:
	return			       ;;;;; DOS 3.3

ENDPROC Set_SFT_MODE

;----------------------------------------------------------------------------
;
; Procedure Name : SHARE_ERROR
;
; Called on sharing violations. ES:DI points to SFT. AX has error code
; If SFT is FCB or compatibility mode gens INT 24 error.
; Returns carry set AX=error_sharing_violation if user says ignore (can't
; really ignore).  Carry clear
; if user wants a retry. ES, DI, DS preserved
;---------------------------------------------------------------------------

procedure SHARE_ERROR,NEAR
	DOSAssume   <DS>,"Share_Error"

	TEST	ES:[DI.sf_mode],sf_isfcb
	JNZ	HARD_ERR
	MOV	CL,BYTE PTR ES:[DI.sf_mode]
	AND	CL,sharing_mask
	CMP	CL,sharing_compat
	JNE	NO_HARD_ERR
HARD_ERR:
	invoke	SHARE_VIOLATION
	retnc				; User wants retry
NO_HARD_ERR:
	MOV	AX,error_sharing_violation
	STC
	return

EndProc SHARE_ERROR

;----------------------------------------------------------------------------
;
; Procedure Name : DO_SHARE_CHECK
;
; Input: THISDPB, WFP_Start, THISSFT set
; Functions: check file sharing mode is valid
; Output: carry set, error
;	  carry clear, share ok
;----------------------------------------------------------------------------

procedure DO_SHARE_CHECK,NEAR
	DOSAssume   <DS>,"DO_SHARE__CHECK"
	EnterCrit   critDisk		; enter critical section

OPN_RETRY:
	MOV	CX,RetryCount		; Get # tries to do
OpenShareRetry:
	SAVE	<CX>			; Save number left to do
	invoke	SHARE_CHECK		; Final Check
	RESTORE <CX>		; CX = # left
	JNC	Share_Ok2		; No problem with access
	Invoke	Idle
	LOOP	OpenShareRetry		; One more retry used up
OpenShareFail:
	LES	DI,[ThisSft]
	invoke	SHARE_ERROR
	JNC	OPN_RETRY		; User wants more retry
Share_Ok2:
	LeaveCrit   critDisk		; leave critical section
	return

EndProc DO_SHARE_CHECK

;-----------------------------------------------------------------------------
;
; Procedure Name : Check_Access
;
; Inputs:
;	AX is mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
; Function:
;	Check this access mode for correctness
; Outputs:
;	[open_access] = AL input
;	Carry Clear
;		Mode is correct
;		AX unchanged
;	Carry Set
;		Mode is bad
;		AX = error_invalid_access
; No other registers effected
;----------------------------------------------------------------------------

procedure Check_Access_AX
	DOSAssume   <DS>,"Check_Access"

	MOV	Open_Access,AL
	PUSH	BX

;	If sharing, then test for special sharing mode for FCBs

	MOV	BL,AL
	AND	BL,sharing_mask
	CMP	fSharing,-1
	JNZ	CheckShareMode		; not through server call, must be ok
	CMP	BL,sharing_NET_FCB
	JZ	CheckAccessMode 	; yes, we have an FCB
CheckShareMode:
	CMP	BL,40h			; is this a good sharing mode?
	JA	Make_Bad_Access
CheckAccessMode:
	MOV	BL,AL
	AND	BL,access_mask
	CMP	BL,2
	JA	Make_Bad_Access
	POP	BX
	CLC
	return

make_bad_access:
	MOV	AX,error_invalid_access
	POP	BX
	STC
	return

EndProc Check_Access_AX


DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\path.asm ===
TITLE	PATH - Directory related system calls
	NAME	PATH

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Directory related system calls.  These will be passed direct text of the
;	pathname from the user.  They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff.  I/O specs are
;	defined in DISPATCH.	The system calls are:
;
;	$CURRENT_DIR  Written
;	$RMDIR	  Written
;	$CHDIR	  Written
;	$MKDIR	  Written
;
;
;	Modification history:
;
;	    Created: ARR 4 April 1983
;		 MZ 10 May 1983     CurrentDir implemented
;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
;				    current directory.
;		 MZ 19 Jan 1983     Brain damaged applications rely on success

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include curdir.inc
	include filemode.inc
	include mult.inc
	include dpb.inc
	.cref
	.list

	I_Need	ThisCDS,DWORD		; pointer to Current CDS
	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
	I_Need	OpenBuf,128		; temp spot for translated name
	I_need	fSplice,BYTE		; TRUE => do splice
	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
	I_Need	cMeta,BYTE
	I_Need	DrvErr,BYTE							;AN000;


DOSCODE	SEGMENT

	allow_getdseg
	
	ASSUME	SS:DOSDATA,CS:DOSCODE


	EXTRN	DOS_MkDir:NEAR,DOS_RmDir:NEAR


BREAK <$CURRENT_DIR - dump the current directory into user space>
;---------------------------------------------------------------------------
;   Procedure Name : $CURRENT_DIR
;
;   Assembler usage:
;		LDS	SI,area
;		MOV	DL,drive
;		INT	21h
;	    ; DS:SI is a pointer to 64 byte area that contains drive
;	    ; current directory.
;   Error returns:
;	    AX = error_invalid_drive
;
;---------------------------------------------------------------------------

procedure $CURRENT_DIR,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	EnterCrit   critDisk
	MOV	AL,DL			; get drive number (0=def, 1=A)
	Invoke	GetVisDrv		; grab it
	JNC	CurrentValidate 	; no error -> go and validate dir
CurdirErr:
	LeaveCrit   critDisk

;hkn; 	Set up DS to access DrvErr
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV	AL,[DrvErr]		;IFS.					;AN000;

	pop	ds
	assume	ds:nothing

	transfer SYS_RET_ERR		;IFS. make noise			;AN000;
CurrentValidate:
	SAVE	<DS,SI> 		; save destination

;hkn; 	Set up DS to access ThisCDS
	getdseg	<ds>			; ds -> dosdata

	LDS	SI,ThisCDS

	assume	ds:nothing

	TEST	[SI].curdir_flags,curdir_isnet
	JNZ	DoCheck
; Random optimization nuked due to some utilities using GetCurrentDir to do
; media check.
;	CMP	[SI].curdir_id,0
;	JZ	GetDst
DoCheck:

;hkn; 	Set up DS to access NoSetDir

	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV	NoSetDir,0		; interested only in contents

	pop	ds
	assume	ds:nothing		;hkn; restore ds

;hkn; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf

	Invoke	ValidateCDS		; output is ES:DI -> CDS
	SAVE	<ES,DI> 		; swap source and destination
	RESTORE <SI,DS>
GetDst:
	RESTORE <DI,ES>		; get real destination
	JC	CurdirErr
	ADD	SI,curdir_text
	ADD	SI,[SI.curdir_END]
	CMP	BYTE PTR [SI],'\'       ; root or subdirs present?
	JNZ	CurrentCopy
	INC	SI
CurrentCopy:
;	Invoke	FStrCpy
;; 10/29/86 E5 char
	PUSH	AX
	LODSB			      ; get char
	OR	AL,AL
	JZ	FOK
	CMP	AL,05
	JZ	FCHANGE
	JMP	short FFF
FCPYNEXT:
	LODSB			      ; get char
FFF:
	CMP	AL,'\'                ; beginning of directory
	JNZ	FOK		      ; no
	STOSB			      ; put into user's buffer
	LODSB			      ; 1st char of dir is 05?
	CMP	AL,05H
	JNZ	FOK		      ; no
FCHANGE:
	MOV	AL,0E5H 	      ; make it E5
FOK:
	STOSB			      ; put into user's buffer
	OR	AL,AL		      ; final char
	JNZ	FCPYNEXT	      ; no
	POP	AX

;; 10/29/86 E5 char
	xor	AL,AL			; MZ 19 Jan 84
	LeaveCrit   critDisk
	transfer    Sys_Ret_OK		; no more, bye!
EndProc $Current_Dir

BREAK <$RmDir -- Remove a directory>
;---------------------------------------------------------------------------
;
; Procedure Name : $RmDir
;
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Delete directory if empty
; Returns:
;	STD XENIX Return
;	AX = error_path_not_found If path bad
;	AX = error_access_denied If
;		Directory not empty
;		Path not directory
;		Root directory specified
;		Directory malformed (. and .. not first two entries)
;		User tries to delete a current directory
;	AX = error_current_directory
;----------------------------------------------------------------------------

procedure $RMDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	push	dx			; Save ptr to name
	push	ds
	mov	si,dx			; Load ptr into si

;hkn; OpenBuf is in DOSDATA
	mov	di,offset DOSDATA:OpenBuf	; di = ptr to buf for trans name
	push	di
	Invoke	TransPathNoSet		; Translate the name
	pop	di			; di = ptr to buf for trans name
	jnc	rmlset			; If transpath succeeded, continue
	pop	ds
	pop	dx			; Restore the	 name
	error	error_path_not_found	; Otherwise, return an error

rmlset:

;hkn; SS override
	CMP	cMeta,-1		;   if (cMeta >= 0)
	Jnz	rmerr			;	return (-1);
	Context ES
	xor	al,al			; al = 0 , ie drive a:
rmloop: Invoke	GetCDSFromDrv		; Get curdir for drive in al
	jc	rmcont			; If error, exit loop & cont normally
	Invoke	StrCmp			; Are the 2 paths the same?
	jz	rmerr			; Yes, report error.
	inc	al			; No, inc al to next drive number
	jmp	rmloop			; Go check next drive.

rmerr:
	pop	ds
	pop	dx			; Restore the	 name
	error	error_current_directory ;  error

rmcont:
	pop	ds
	pop	dx			; Restore the	 name

;hkn; DOS_RmDIR is in DOSCODE
	MOV	SI,OFFSET DOSCODE:DOS_RmDIR
	JMP	DoDirCall
EndProc $RMDIR

BREAK <$ChDir -- Change current directory on a drive>
;----------------------------------------------------------------------------
;
; $ChDir - Top-level change directory system call.  This call is responsible
; for setting up the CDS for the specified drive appropriately.  There are
; several cases to consider:
;
;   o	Local, simple CDS.  In this case, we take the input path and convert
;	it into a WFP.	We verify the existance of this directory and then
;	copy the WFP into the CDS and set up the ID field to point to the
;	directory cluster.
;   o	Net CDS.  We form the path from the root (including network prefix)
;	and verify its existance (via DOS_Chdir).  If successful, we copy the
;	WFP back into the CDS.
;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
;	call TransPath, we will get the PHYSICAL CDS that the path refers to
;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
;	good for the validation but not for currency.  We call TransPathNoSet
;	to process the path but to return the logical CDS and the logical
;	path.  We then copy the logical path into the logical CDS.
;
; Inputs:
;	DS:DX Points to asciz name
; Returns:
;	STD XENIX Return
;	AX = chdir_path_not_found if error
;----------------------------------------------------------------------------

procedure $CHDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; spot for translated name
	MOV	SI,DX			; get source
	Invoke	TransPath		; go munge the path and get real CDS
	JNC	ChDirCrack		; no errors, try path
ChDirErrP:
	MOV	AL,error_path_not_found
ChdirErr:
	transfer    SYS_Ret_Err 	; oops!

ChDirCrack:

;hkn; 	Transpath sets DS to DOSGroup (DOSDATA now)
;hkn;	Assume	DS:DOSGroup

	Assume	DS:DOSDATA

	CMP	cMeta,-1		; No meta chars allowed.
	JNZ	ChDirErrP
;
; We cannot do a ChDir (yet) on a raw CDS.  This is treated as a path not
; found.
;
	LES	DI,ThisCDS
	CMP	DI,-1			;   if (ThisCDS == NULL)
	JZ	ChDirErrP		;	error ();
 ;
 ; Find out if the directory exists.
 ;
	Invoke	DOS_ChDir
	JC	ChDirErr
;
; Get back CDS to see if a join as seen.  Set the currency pointer (only if
; not network).  If one was seen, all we need to do is copy in the text
;
	LES	DI,ThisCDS
	TEST	ES:[DI].curdir_flags,curdir_splice
	JZ	GotCDS
;
; The CDS was joined.  Let's go back and grab the logical CDS.
;
	SAVE	<ES,DI,CX>		; save CDS and cluster...
	Invoke	Get_User_Stack		; get original text
	ASSUME	DS:NOTHING
	MOV	DI,[SI.User_DX]
	MOV	DS,[SI.User_DS]

;hkn; OpenBuf is in DOSDATA
	MOV	SI,OFFSET DOSDATA:OpenBuf  ; spot for translated name

	XCHG	SI,DI
	XOR	AL,AL			; do no splicing
	SAVE	<DI>
	Invoke	TransPathNoSet		; Munge path
	RESTORE <SI>
;hkn;	Assume	DS:DOSGroup

	Assume	DS:DOSDATA
;
; There should NEVER be an error here.
;
IF FALSE
	JNC SKipErr
	fmt <>,<>,<"$p: Internal CHDIR error\n">
SkipErr:
ENDIF
	LES	DI,ThisCDS		; get new CDS
	MOV	ES:[DI].curdir_ID,-1	; no valid cluster here...
	RESTORE <CX,DI,ES>
;
; ES:DI point to the physical CDS, CX is the ID (local only)
;
GotCDS:
;
; wfp_start points to the text.  See if it is long enough
;
	CALL	Check_PathLen		;PTM.					;AN000;
	JA	ChDirErrP
	TEST	ES:[DI].curdir_flags,curdir_isnet
	JNZ	SkipRecency
	TEST	ES:[DI].curdir_flags,curdir_splice   ;PTM. for Join and Subst	;AN000;
	JZ	setdirclus			     ;PTM.			;AN000;
	MOV	CX,-1				     ;PTM.			;AN000;
setdirclus:
	MOV	ES:[DI].curdir_id,CX
	LES	DI,ThisCDS		; get logical CDS
SkipRecency:
	invoke	FStrCpy
	XOR	AL,AL
	transfer    Sys_Ret_OK
EndProc $CHDIR

BREAK <$MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : $MkDir
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Make a new directory
; Returns:
;	STD XENIX Return
;	AX = mkdir_path_not_found if path bad
;	AX = mkdir_access_denied  If
;		Directory cannot be created
;		Node already exists
;		Device name given
;		Disk or directory(root) full
;---------------------------------------------------------------------------

procedure $MKDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; DOS_MkDir is in DOSCODE
	MOV	SI,OFFSET DOSCODE:DOS_MkDir
DoDirCall:

;hkn; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; spot for translated name

	SAVE	<SI>
	MOV	SI,DX			; get source
	Invoke	TransPath		; go munge the path
	RESTORE <SI>
	JNC	MkDirCrack		; no errors, try path
MkErrP:
	MOV	AL,error_Path_Not_Found    ; oops!
MkErr:
	transfer    Sys_Ret_Err
MkDirCrack:

;hkn; SS override
	CMP	cMeta,-1
	JNZ	MkErrP

	PUSH	SI			;PTM.					;AN000;
	CALL	Check_PathLen		;PTM.  check path len > 67 ?		;AN000;
	POP	SI			;PTM.					;AN000;
	JBE	pathok			;PTM.					;AN000;
	MOV	AL,error_Access_Denied	;PTM. ops!
	transfer Sys_Ret_Err		;PTM.
pathok:
	CALL	SI			; go get file
	ASSUME	ES:NOTHING
	JC	MkErr			; no errors
	transfer    Sys_Ret_OK
EndProc $MKDIR

;----------------------------------------------------------------------------
;
; Procedure Name : Check_PathLen
;
; Inputs:
;	nothing
; Function:
;	check if final path length greater than 67
; Returns:
;	Above flag set if > 67
;---------------------------------------------------------------------------

procedure Check_PathLen,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	MOV	SI,Wfp_Start
  entry Check_PathLen2

;hkn; SS is DOSDATA
	Context <DS>

	SAVE	<CX>
	invoke	DStrLen
	CMP	CX,DirStrLen
	RESTORE <CX>
	ret

EndProc Check_PathLen
DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\restrict.inc ===
;***    RESTRICT.INC - List of programs that are allowed to $Exec
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;
;       History:
;           20-Jul-1992 bens Initial version
;           27-Jul-1992 randym updated from Symantec list (7/23/92)
;           13-Aug-1992 randym updated from Symantec mods for 8/10/92

;       Description:
;           This file is included by msproc.asm ONLY when the symbol
;           RESTRICTED_BUILD is defined.
;
;           The file names in this include file must be ALL UPPERCASE,
;           and may have no meta characters (:.\/)
;

;* Start of list

rstfile 'INSTALL.EXE'
rstfile 'CLEANUP.EXE'
rstfile 'NAVSETUP.EXE'
rstfile 'NSETUP.OVL'
rstfile 'NAV.EXE'
rstfile 'RESCUE.EXE'
rstfile 'NRESTORE.EXE'
rstfile 'NRESTORE.OVL'
rstfile 'NBCONFIG.OVL'
rstfile 'CALIBRAT.EXE'
rstfile 'DISKTOOL.EXE'
rstfile 'NDD.EXE'
rstfile 'UNFORMAT.EXE'
rstfile 'DISKEDIT.EXE'
rstfile 'UNERASE.EXE'
rstfile 'NDIAG.EXE'
rstfile 'NORTON.EXE'
rstfile 'NORTON.OVL'
rstfile 'STARTUP.EXE'
rstfile 'STARTUP.OVL'

;* End of list
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\rom.asm ===
page	,164
	TITLE	ROM - Miscellaneous routines
	NAME	ROM

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Misc Low level routines for doing simple FCB computations, Cache
;       reads and writes, I/O optimization, and FAT allocation/deallocation
;
;	SKPCLP
;	FNDCLUS
;	BUFSEC
;	BUFRD
;	BUFWRT
;	NEXTSEC
;	OPTIMIZE
;	FIGREC
;	ALLOCATE
;	RESTFATBYT
;	RELEASE
;	RELBLKS
;	GETEOF
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;               M039: DB 10/25/90 - Disk read/write optimization.

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include fastxxxx.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include dpb.inc
	.cref
	.list

        i_need  CLUSNUM,WORD
        i_need  NEXTADD,WORD
        i_need  LASTPOS,WORD
        i_need  SECCLUSPOS,BYTE
        i_need  FATBYT,WORD
        i_need  THISSFT,DWORD
        i_need  TRANS,BYTE
        i_need  BYTCNT1,WORD
        i_need  CURBUF,DWORD
        i_need  BYTSECPOS,WORD
        i_need  DMAADD,WORD
        i_need  SECPOS,DWORD                         ;F.C. >32mb
        i_need  VALSEC,DWORD                         ;F.C. >32mb
        i_need  ALLOWED,BYTE

        i_need  HIGH_SECTOR,WORD                     ; DOS 3.4
        i_need  DISK_FULL,BYTE                       ; DOS 3.4
        i_need  Temp_VAR2,WORD                       ; DOS 3.4

        i_need  BufferQueue,DWORD                    ;M039

	i_need  OffsetMagicPatch,WORD		;scottq 8-6-92

DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE


Break   <FNDCLUS -- Skip over allocation units>
;--------------------------------------------------------------------------
;
; Procedure Name : FNDCLUS
;
; Inputs:
;       CX = No. of clusters to skip
;       ES:BP = Base of drive parameters
;       [THISSFT] point to SFT
; Outputs:
;       BX = Last cluster skipped to
;       CX = No. of clusters remaining (0 unless EOF)
;       DX = Position of last cluster
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;--------------------------------------------------------------------------

procedure FNDCLUS,NEAR
	DOSAssume   <DS>,"FndClus"

        Assert      ISDPB,<ES,BP>,"FndCLus"

	PUSH	ES
        LES     DI,[THISSFT]			; setup addressability to SFT

        Assert      ISSFT,<ES,DI>,"FndClus"

	MOV	BX,ES:[DI.sf_lstclus]
        MOV     DX,ES:[DI.sf_cluspos]
	OR	BX,BX
	JZ	NOCLUS

        SUB     CX,DX
        JNB     FINDIT

        ADD     CX,DX
        XOR     DX,DX
        MOV     BX,ES:[DI.sf_firclus]
FINDIT:
        POP     ES
	JCXZ	RET9

entry   SKPCLP

        invoke  UNPACK
        JC	ret_label		; retc

	xchg	bx,di
	invoke	IsEOF
	xchg	bx,di
	jae	ret9

;	push	bx
;        MOV     BX,DI
;        Invoke  IsEOF
;	pop	bx
;        JAE     RET9

        XCHG    BX,DI
        INC     DX
	LOOP	SKPCLP				; RMFS
RET9:										;AN000;
	CLC
        return
NOCLUS:
        POP     ES
        INC     CX
        DEC     DX
        CLC

ret_label:
        return

EndProc FNDCLUS

Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
;--------------------------------------------------------------------------
;
; Procedure Name : BUFSEC
;
; Inputs:
;       AH = priority of buffer
;       AL = 0 if buffer must be read, 1 if no pre-read needed
;       ES:BP = Base of drive parameters
;       [CLUSNUM] = Physical cluster number
;       [SECCLUSPOS] = Sector position of transfer within cluster
;       [BYTCNT1] = Size of transfer
; Function:
;       Insure specified sector is in buffer, flushing buffer before
;       read if necessary.
; Outputs:
;       ES:DI = Pointer to buffer
;       SI = Pointer to transfer address
;       CX = Number of bytes
;       [NEXTADD] updated
;       [TRANS] set to indicate a transfer will occur
;       Carry set if error (user FAILed to I 24)
;--------------------------------------------------------------------------

procedure BUFSEC,NEAR
	DOSAssume   <DS>,"BufSec"

        Assert      ISDPB,<ES,BP>,"BufSec"
        MOV     DX,[CLUSNUM]
        MOV     BL,[SECCLUSPOS]
        MOV     [ALLOWED],allowed_FAIL + allowed_RETRY + allowed_IGNORE
        CALL    FIGREC
        invoke  GETBUFFR
        retc

        MOV     BYTE PTR [TRANS],1      ; A transfer is taking place
        MOV     SI,[NEXTADD]
        MOV     DI,SI
        MOV     CX,[BYTCNT1]
        ADD     DI,CX
        MOV     [NEXTADD],DI
        LES     DI,[CURBUF]
        Assert  ISBUF,<ES,DI>,"BufSec"
        OR      ES:[DI.buf_flags],buf_isDATA
        LEA     DI,[DI].BUFINSIZ        ; Point to buffer
        ADD     DI,[BYTSECPOS]
        CLC
        return
EndProc BUFSEC

Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
;---------------------------------------------------------------------------
;
; Procedure Name : BUFRD
;
; Do a partial sector read via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------

procedure BUFRD,NEAR
	DOSAssume   <DS>,"BufRd"

        Assert      ISDPB,<ES,BP>,"BufRd"
        PUSH    ES
        xor	ax, ax			; pre-read sector
        CALL    BUFSEC
        JNC     BUF_OK

BUF_IO_FAIL:				; this label used by BUFWRT also
        POP     ES
        JMP     SHORT RBUFPLACED

BUF_OK:
        MOV     BX,ES
        MOV     ES,[DMAADD+2]
        MOV     DS,BX
	ASSUME  DS:NOTHING
        XCHG    DI,SI
        SHR     CX,1

;M039
;        JNC     EVENRD
;        MOVSB
;EVENRD:
;        REP     MOVSW

;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
;       DS:SI-> Source within Buffer.
;       ES:DI-> Destination within Transfer memory block.

	rep	movsw			;Copy Buffer to Transfer memory.
	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	rep	movsb                   ;Copy last byte.
;M039

        POP     ES
;hkn; SS override
        LDS     DI,[CURBUF]
        Assert  ISBUF,<DS,DI>,"BufRD/EvenRD"
        LEA     BX,[DI.BufInSiz]
        SUB     SI,BX                   ; Position in buffer
        invoke  PLACEBUF
        Assert  ISDPB,<ES,BP>,"BufRD/EvenRD"
        CMP     SI,ES:[BP.dpb_sector_size] ; Read Last byte?
        JB      RBUFPLACEDC             ; No, leave buf where it is

;M039
;       invoke  PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.
        MOV	WORD PTR [BufferQueue],DI ; Make it prime candidate for
;M039                                     ; chucking even though it is MRU.

RBUFPLACEDC:
        CLC
RBUFPLACED:
	Context	<DS>
        return
EndProc BUFRD
;
;----------------------------------------------------------------------------
;
; Procedure : BUFWRT
;
; Do a partial sector write via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------
;

procedure BUFWRT,NEAR
	DOSAssume   <DS>,"BufWrt"

	Assert	ISDPB,<ES,BP>,"BufWrt"
        MOV     AX,WORD PTR [SECPOS]
        ADD     AX,1            ; Set for next sector
        MOV     WORD PTR [SECPOS],AX      ;F.C. >32mb                           ;AN000;
        ADC     WORD PTR [SECPOS+2],0     ;F.C. >32mb                           ;AN000;
        MOV     AX,WORD PTR [SECPOS+2]    ;F.C. >32mb                           ;AN000;
        CMP     AX,WORD PTR [VALSEC+2]    ;F.C. >32mb                           ;AN000;
        MOV     AL,1                      ;F.C. >32mb                           ;AN000;
        JA      NOREAD                    ;F.C. >32mb                           ;AN000;
        JB      doread                    ;F.C. >32mb                           ;AN000;
        MOV     AX,WORD PTR [SECPOS]      ;F.C. >32mb                           ;AN000;
        CMP     AX,WORD PTR [VALSEC]     ; Has sector been written before?
        MOV     AL,1
        JA      NOREAD          	 ; Skip preread if SECPOS>VALSEC
doread:
        XOR     AL,AL
NOREAD:
        PUSH    ES
        CALL    BUFSEC
	DLJC	 BUF_IO_FAIL
        MOV     DS,[DMAADD+2]
	ASSUME  DS:NOTHING
        SHR     CX,1

;M039
;       JNC     EVENWRT
;       MOVSB
;EVENWRT:
;       REP     MOVSW

;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
;       DS:SI-> Source within Transfer memory block.
;       ES:DI-> Destination within Buffer.

	rep	movsw			;Copy Transfer memory to Buffer.
	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	rep	movsb                   ;Copy last byte.
;M039

        POP     ES

;hkn; SS override
        LDS     BX,[CURBUF]
        Assert  ISBUF,<DS,BX>,"BufWrt/NOREAD"

        TEST    [BX.buf_flags],buf_dirty  ;LB. if already dirty                 ;AN000;
        JNZ     yesdirty                  ;LB.    don't increment dirty count   ;AN000;
        invoke  INC_DIRTY_COUNT           ;LB.                                  ;AN000;
        OR      [BX.buf_flags],buf_dirty
yesdirty:
        LEA     SI,[BX.BufInSiz]
        SUB     DI,SI                   ; Position in buffer

;M039
;       MOV     SI,DI
;       MOV     DI,BX
;       invoke  PLACEBUF
;       Assert  ISDPB,<ES,BP>,"BufWrt/EvenWrt"
;       CMP     SI,ES:[BP.dpb_sector_size]  ; Written last byte?
;       JB      WBUFPLACED              ; No, leave buf where it is
;       invoke  PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.

        Assert  ISDPB,<ES,BP>,"BufWrt/NOREAD"
        CMP     DI,ES:[BP.dpb_sector_size]  ; Written last byte?
        JB      WBUFPLACED                  ; No, leave buf where it is
        MOV	WORD PTR [BufferQueue],BX   ; Make it prime candidate for
                                            ; chucking even though it is MRU.
;M039

WBUFPLACED:
        CLC
	Context	<DS>
        return
EndProc BUFWRT

Break   <NEXTSEC -- Compute next sector to read or write>
;---------------------------------------------------------------------------
;
; Procedure Name : NEXTSEC
;
; Compute the next sector to read or write
; ES:BP Points to DPB
;
;---------------------------------------------------------------------------

procedure NEXTSEC,NEAR
	DOSAssume   <DS>,"NextSec"

	Assert	ISDPB,<ES,BP>,"NextSec"
	test	byte ptr Trans, -1 
        JZ      CLRET

        MOV     AL,[SECCLUSPOS]
        INC     AL
        CMP     AL,ES:[BP.dpb_cluster_mask]
        JBE     SAVPOS

        MOV     BX,[CLUSNUM]
        Invoke  IsEOF
        JAE     NONEXT

        invoke  UNPACK
        JC      NONEXT
clusgot:
        MOV     [CLUSNUM],DI
        INC     [LASTPOS]
        MOV     AL,0
SAVPOS:
        MOV     [SECCLUSPOS],AL
CLRET:
        CLC
        return
NONEXT:
        STC
        return
EndProc NEXTSEC

Break   <OPTIMIZE -- DO A USER DISK REQUEST WELL>
;----------------------------------------------------------------------------
;
; Procedure Name : OPTIMIZE
;
; Inputs:
;       BX = Physical cluster
;       CX = No. of records
;       DL = sector within cluster
;       ES:BP = Base of drives parameters
;       [NEXTADD] = transfer address
; Outputs:
;       AX = No. of records remaining
;       BX = Transfer address
;       CX = No. or records to be transferred
;       DX = Physical sector address            (LOW)
;       [HIGH_SECTOR] = Physical sector address (HIGH)
;       DI = Next cluster
;       [CLUSNUM] = Last cluster accessed
;       [NEXTADD] updated
;       Carry set if error (currently user FAILed to I 24)
; ES:BP unchanged. Note that segment of transfer not set.
;
;---------------------------------------------------------------------------

procedure OPTIMIZE,NEAR
	DOSAssume   <DS>,"Optimize"

	Assert	ISDPB,<ES,BP>,"Optimize"
        PUSH    DX
        PUSH    BX
        MOV     AL,ES:[BP.dpb_cluster_mask]
        INC     AL              ; Number of sectors per cluster
        MOV     AH,AL
        SUB     AL,DL           ; AL = Number of sectors left in first cluster
        MOV     DX,CX
        MOV     CX,0
OPTCLUS:
; AL has number of sectors available in current cluster
; AH has number of sectors available in next cluster
; BX has current physical cluster
; CX has number of sequential sectors found so far
; DX has number of sectors left to transfer
; ES:BP Points to DPB
; ES:SI has FAT pointer

do_norm3:
        invoke  UNPACK
        JC      OP_ERR
clusgot2:
	ADD	CL,AL
        ADC     CH,0
        CMP     CX,DX
        JAE     BLKDON
        MOV     AL,AH
        INC     BX
        CMP     DI,BX
        JZ      OPTCLUS
        DEC     BX
FINCLUS:
        MOV     [CLUSNUM],BX    ; Last cluster accessed
        SUB     DX,CX           ; Number of sectors still needed
        PUSH    DX
        MOV     AX,CX
        MUL     ES:[BP.dpb_sector_size]  ; Number of sectors times sector size
        MOV     SI,[NEXTADD]
        ADD     AX,SI           ; Adjust by size of transfer
        MOV     [NEXTADD],AX
        POP     AX              ; Number of sectors still needed
        POP     DX              ; Starting cluster
        SUB     BX,DX           ; Number of new clusters accessed
        ADD     [LASTPOS],BX
        POP     BX              ; BL = sector postion within cluster
        invoke  FIGREC
        MOV     BX,SI
	CLC
        return

OP_ERR:
        ADD     SP,4
	STC
        return

BLKDON:
        SUB     CX,DX           ; Number of sectors in cluster we don't want
        SUB     AH,CL           ; Number of sectors in cluster we accepted
        DEC     AH              ; Adjust to mean position within cluster
        MOV     [SECCLUSPOS],AH
        MOV     CX,DX           ; Anyway, make the total equal to the request
        JMP     SHORT FINCLUS
EndProc OPTIMIZE

Break   <FIGREC -- Figure sector in allocation unit>
;---------------------------------------------------------------------------
;
; Procedure Name : FIGREC
;
; Inputs:
;       DX = Physical cluster number
;       BL = Sector postion within cluster
;       ES:BP = Base of drive parameters
; Outputs:
;       DX = physical sector number           (LOW)
;       [HIGH_SECTOR] Physical sector address (HIGH)
; No other registers affected.
;
;---------------------------------------------------------------------------

procedure	FIGREC,NEAR

        Assert      ISDPB,<ES,BP>,"FigRec"
        PUSH    CX
        MOV     CL,ES:[BP.dpb_cluster_shift]
        DEC     DX
        DEC     DX

;hkn; SS override HIGH_SECTOR
        MOV     [HIGH_SECTOR],0              ;F.C. >32mb
        OR      CL,CL                        ;F.C. >32mb
        JZ      noshift                      ;F.C. >32mb
        XOR     CH,CH                        ;F.C. >32mb
rotleft:                                     ;F.C. >32mb
        CLC                                  ;F.C. >32mb
        RCL     DX,1                         ;F.C. >32mb
        RCL     [HIGH_SECTOR],1              ;F.C. >32mb
        LOOP    rotleft                      ;F.C. >32mb
noshift:

;       SHL     DX,CL
        OR      DL,BL
        ADD     DX,ES:[BP.dpb_first_sector]
        ADC     [HIGH_SECTOR],0              ;F.C. >32mb
        POP     CX
        return
EndProc FIGREC

Break   <ALLOCATE -- Assign disk space>
;---------------------------------------------------------------------------
;
; Procedure Name : ALLOCATE - Allocate Disk Space
;
;   ALLOCATE is called to allocate disk clusters.  The new clusters are
;   FAT-chained onto the end of the existing file.
;
;   The DPB contains the cluster # of the last free cluster allocated
;   (dpb_next_free).  We start at this cluster and scan towards higher
;   numbered clusters, looking for the necessary free blocks.
;
;   Once again, fancy terminology gets in the way of corrct coding.  When
;   using next_free, start scanning AT THAT POINT and not the one following it.
;   This fixes the boundary condition bug when only free = next_free = 2.
;
;       If we get to the end of the disk without satisfaction:
;
;           if (dpb_next_free == 2) then we've scanned the whole disk.
;               return (insufficient_disk_space)
;           ELSE
;               dpb_next_free = 2; start scan over from the beginning.
;
;   Note that there is no multitasking interlock.  There is no race when
;   examining the entrys in an in-core FAT block since there will be no
;   context switch.  When UNPACK context switches while waiting for a FAT read
;   we are done with any in-core FAT blocks, so again there is no race.  The
;   only special concern is that V2 and V3 MSDOS left the last allocated
;   cluster as "00"; marking it EOF only when the entire alloc request was
;   satisfied.  We can't allow another activation to think this cluster is
;   free, so we give it a special temporary mark to show that it is, indeed,
;   allocated.
;
;   Note that when we run out of space this algorithem will scan from
;   dpb_next_free to the end, then scan from cluster 2 through the end,
;   redundantly scanning the later part of the disk.  This only happens when
;   we run out of space, so sue me.
;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;                                                                          ;
;   The use of FATBYT and RESTFATBYT is somewhat mysterious.  Here is the
;   explanation:
;
;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
;   entry BX = 0.  What needs to be done in this case is to stuff the cluster
;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
;   complete.  THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED.  This is a side effect of
;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
;   errors.  This "stuff" is done by the call to PACK which is right before
;   the
;           LOOP    findfre         ; alloc more if needed
;   instruction when the first cluster is allocated to the nul file.  The
;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
;
;   This method is obviously useless (because it is non-reentrant) for
;   multitasking, and will have to be changed.  Storing the required value on
;   the stack is recommended.  Setting sf_firclus at the PACK of cluster 0
;   (instead of actually doing the PACK) is BAD because it doesn't handle
;   problems with INT 24 well.
;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;                                                                          ;
;       ENTRY   BX = Last cluster of file (0 if null file)
;               CX = No. of clusters to allocate
;               ES:BP = Base of drive parameters
;               [THISSFT] = Points to SFT
;
;       EXIT    'C' set if insufficient space
;                 [FAILERR] can be tested to see the reason for failure
;                 CX = max. no. of clusters that could be added to file
;               'C' clear if space allocated
;                 BX = First cluster allocated
;                 FAT is fully updated
;                 sf_FIRCLUS field of SFT set if file was null
;
;       USES    ALL but SI, BP

callmagic  proc near
        push    ds                              ;push segment of routine 
        push    OffsetMagicPatch                ;push offset for routine
        retf                                    ;simulate jmp far
                                                ;far return address is on
                                                ;stack, so far return from
                                                ;call will return this routine
callmagic  endp

PROCEDURE ALLOCATE,NEAR

	DOSAssume   <DS>,"Allocate"

	Assert	ISDPB,<ES,BP>,"Allocate"
;BEGIN MAGICDRV MODIFICATIONS
;
;7/5/92 scottq
;
;This is the disk compression patch location which allows
;the disk compression software to fail allocations if the
;FAT would allows allocation, but the free space for compressed
;data would not.
;        
;;;        call    far ptr MAGICPATCH
;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
;;; but we do know the segment and offset of the routine
;;; so simulate a far call to dosdata:magicpatch
;;; note dosassume above, so DS -> dosdata
        clc                                     ;clear carry so we fall through
                                                ;if no patch is present
	push	cs				;push segment for far return
        call    callmagic                       ;this is a near call
        jnc     Regular_Allocate_Path
        jmp     Disk_Full_Return
Regular_Allocate_Path:
;END MAGICDRV MODIFICATIONS

        PUSH    BX                      ; save (bx)
        XOR     BX,BX
        invoke  UNPACK
        MOV     [FATBYT],DI             ; save correct cluster 0 value
        POP     BX
        retc                            ; abort if error   [INTERR?]

        PUSH    CX
        PUSH    BX

        MOV     DX,BX
        Assert      ISDPB,<ES,BP>,"Allocate/Unpack"
        mov     bx,es:[bp.dpb_next_free]
        cmp     bx,2
        ja      findfre

;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
;   <2 or >dpb_max_clus.  Reset it and restart the scan

ads1:
        Assert      ISDPB,<ES,BP>,"Alloc/ads1"
        mov     es:[bp.dpb_next_free],2
        mov     bx,1                    ; Counter next instruction so first
                                        ;       cluster examined is 2

;   Scanning both forwards and backwards for a free cluster
;
;       (BX) = forwards scan pointer
;       (CX) = clusters remaining to be allocated
;       (DX) = current last cluster in file
;       (TOS) = last cluster of file

FINDFRE:
        INC     BX
        Assert      ISDPB,<ES,BP>,"Alloc/findfre"
        CMP     BX,ES:[BP.dpb_max_cluster]

;hkn; bad code! replace with ja.
	ja      ads7            ; at end of disk

;        JBE     aupk
;        jmp     ads7            ; at end of disk
;aupk:

        invoke  UNPACK          ; check out this cluster
        jc      ads4            ; FAT error             [INTERR?]
        jnz     findfre         ; not free, keep on truckin

;   Have found a free cluster.  Chain it to the file
;
;       (BX) = found free cluster #
;       (DX) = current last cluster in file

        mov     es:[bp.dpb_next_free],bx        ; next time start search here
        xchg    ax,dx           ; save (dx) in ax
        mov     dx,1            ; mark this free guy as "1"
        invoke  PACK            ; set special "temporary" mark
        jc      ads4            ; FAT error             [INTERR?]
        CMP     ES:[BP.dpb_free_cnt],-1 ; Free count valid?
        JZ      NO_ALLOC                ; No
        DEC     ES:[BP.dpb_free_cnt]    ; Reduce free count by 1
NO_ALLOC:
        xchg    ax,dx           ; (dx) = current last cluster in file
        XCHG    BX,DX
        MOV     AX,DX
        invoke  PACK            ; link free cluster onto file
                                ;  CAVEAT.. On Nul file, first pass stuffs
                                ;    cluster 0 with FIRCLUS value.
        jc      ads4            ; FAT error             [INTERR?]
        xchg    BX,AX           ; (BX) = last one we looked at
        mov     dx,bx           ; (dx) = current end of file
        LOOP    findfre         ; alloc more if needed

;   We've successfully extended the file.  Clean up and exit
;
;       (BX) = last cluster in file

        MOV     DX,0FFFFH
        invoke  PACK            ; mark last cluster EOF

;   Note that FAT errors jump here to clean the stack and exit.  this saves us
;   2 whole bytes.  Hope its worth it...
;
;       'C' set iff error
;       calling (BX) and (CX) pushed on stack

ads4:   POP     BX
        POP     CX              ; Don't need this stuff since we're successful
        retc
        invoke  UNPACK          ; Get first cluster allocated for return
                                ; CAVEAT... In nul file case, UNPACKs cluster 0.
        retc
        invoke  RESTFATBYT      ; Restore correct cluster 0 value
        retc
        XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
        OR      DI,DI           ; clear 'C'
        retnz                   ; we were extending an existing file

;   We were doing the first allocation for a new file.  Update the SFT cluster
;   info
dofastk:
        PUSH    DX
        MOV     DL,ES:[BP.dpb_drive]              ; get drive #

        PUSH    ES
        LES     DI,[THISSFT]
        Assert  ISSFT,<ES,DI>,"Allocate/ads4"
        MOV     ES:[DI.sf_firclus],BX
        MOV     ES:[DI.sf_lstclus],BX
do_norm5:
        POP     ES
        POP     DX
        return


;** we're at the end of the disk, and not satisfied.  See if we've scanned ALL
;   of the disk...

ads7:   cmp     es:[bp.dpb_next_free],2
	DLJNZ	ads1		; start scan from front of disk

;   Sorry, we've gone over the whole disk, with insufficient luck.  Lets give
;   the space back to the free list and tell the caller how much he could have
;   had.  We have to make sure we remove the "special mark" we put on the last
;   cluster we were able to allocate, so it doesn't become orphaned.
;
;       (CX) = clusters remaining to be allocated
;       (TOS) = last cluster of file (before call to ALLOCATE)
;       (TOS+1) = # of clusters wanted to allocate


        POP     BX              ; (BX) = last cluster of file
        MOV     DX,0FFFFH
        invoke  RELBLKS         ; give back any clusters just alloced
        POP     AX              ; No. of clusters requested
                                ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed, so proceed with return CX
                                ;   setup.
        SUB     AX,CX           ; AX=No. of clusters allocated
        invoke  RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed.
Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
;       fmt     <>,<>,<"$p: disk full in allocate\n">
        MOV     [DISK_FULL],1   ;MS. indicating disk full
        STC
        return

EndProc ALLOCATE

;-----------------------------------------------------------------------
;
; Procedure Name : RESTFATBYT
;
; SEE ALLOCATE CAVEAT
;       Carry set if error (currently user FAILed to I 24)
;-----------------------------------------------------------------------

procedure RESTFATBYT,NEAR
	DOSAssume   <DS>,"RestFATByt"

        PUSH    BX
        PUSH    DX
        PUSH    DI
        XOR     BX,BX
        MOV     DX,[FATBYT]
        invoke  PACK
        POP     DI
        POP     DX
        POP     BX
        return

EndProc RESTFATBYT


Break   <RELEASE -- DEASSIGN DISK SPACE>
;---------------------------------------------------------------------------
;
; Procedure Name : RELEASE
;
; Inputs:
;       BX = Cluster in file
;       ES:BP = Base of drive parameters
; Function:
;       Frees cluster chain starting with [BX]
;       Carry set if error (currently user FAILed to I 24)
; AX,BX,DX,DI all destroyed. Other registers unchanged.
;
;-----------------------------------------------------------------------------

procedure RELEASE,NEAR
	DOSAssume   <DS>,"Release"

        XOR     DX,DX
entry   RELBLKS
	DOSAssume   <DS>,"RelBlks"
        Assert      ISDPB,<ES,BP>,"RelBlks"

;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
;   and free the rest in the chain.

        invoke  UNPACK
	jc	RELEASE_flush
	jz	RELEASE_flush
        MOV     AX,DI
        PUSH    DX
        invoke  PACK
        POP     DX
	jc	RELEASE_flush
        OR      DX,DX
        JNZ     NO_DEALLOC              ; Was putting EOF mark
        CMP     ES:[BP.dpb_free_cnt],-1 ; Free count valid?
        JZ      NO_DEALLOC              ; No
        INC     ES:[BP.dpb_free_cnt]    ; Increase free count by 1
NO_DEALLOC:
        MOV     BX,AX
        dec     ax              ; check for "1"
	jz	RELEASE_flush	; is last cluster of incomplete chain
        Invoke  IsEOF
        JB      RELEASE         ; Carry clear if JMP not taken

RELEASE_flush:
	MOV	AL,ES:[BP.dpb_drive]
	push	si		; FLUSHBUF may trash these and we guarantee
	push	cx		;  them to be preserved.
	push	es
	push	bp
	invoke	FLUSHBUF		; commit buffers for this drive
	pop	bp
	pop	es
	pop	cx
	pop	si
RET12:
	return
EndProc RELEASE

Break   <GETEOF -- Find the end of a file>
;------------------------------------------------------------------------
;
; Procedure Name : GETEOF
;
; Inputs:
;       ES:BP Points to DPB
;       BX = Cluster in a file
;       DS = CS
; Outputs:
;       BX = Last cluster in the file
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;
;--------------------------------------------------------------------------

procedure GETEOF,NEAR
	DOSAssume   <DS>,"GetEOF"

	Assert	ISDPB,<ES,BP>,"GetEof"
        invoke  UNPACK
        retc
        PUSH    BX
        MOV     BX,DI
        Invoke  IsEOF
        POP     BX
        JAE     RET12           ; Carry clear if jmp
        MOV     BX,DI
        JMP     GETEOF

EndProc GETEOF

DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\rename.asm ===
TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
	NAME	DOS_RENAME
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Low level routine for renaming files
;
;	DOS_RENAME
;
;	Modification history:
;
;	    Created: ARR 30 March 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include find.inc
	include filemode.inc
	include mult.inc
	.cref
	.list

Installed = TRUE

	i_need	RENAMEDMA,BYTE
	i_need	AUXSTACK,BYTE
	i_need	DESTSTART,WORD
	i_need	DIRSTART,WORD
	i_need	CURBUF,DWORD
	I_need	NAME1,BYTE
	i_need	NAME2,BYTE
	i_need	WFP_START,WORD
	i_need	REN_WFP,WORD
	i_need	CURR_DIR_END,WORD
	i_need	DMAADD,DWORD
	i_need	THISCDS,DWORD
	i_need	THISDPB,DWORD
	i_need	THISSFT,DWORD
	i_need	CREATING,BYTE
	i_need	THISDRV,BYTE
	i_need	ATTRIB,BYTE
	i_need	FOUND_DEV,BYTE
	i_need	FAILERR,BYTE
	i_need	EXTERR_LOCUS,BYTE
	i_need	SAVE_BX,WORD


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RENAME
;
; Inputs:
;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Rename the specified file(s)
;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
; Outputs:
;	CARRY CLEAR
;	    OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			No match for source, or dest path invalid
;		error_not_same_device
;			Source and dest are on different devices
;		error_access_denied
;			Directory specified (not simple rename),
;			Device name given, Destination exists.
;			NOTE: In third case some renames may have
;			 been done if metas.
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;			SOURCE ONLY
;		error_bad_curr_dir
;			Bad path in current directory part of path
;			SOURCE ONLY
;		error_sharing_violation
;			Deny both access required, generates an INT 24.
; DS preserved, others destroyed
;
;----------------------------------------------------------------------------

	procedure   DOS_RENAME,NEAR

;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
;hkn; at this point to DOSDATA.

	DOSAssume   <DS>,"DOS_Rename"
	ASSUME	ES:NOTHING

	Invoke	TestNet
	JNC	LOCAL_RENAME

IF NOT Installed
	transfer NET_RENAME
ELSE
	MOV	AX,(multNET SHL 8) OR 17
	INT	2FH
	return
ENDIF

LOCAL_RENAME:
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	SI,[WFP_START]
	MOV	DI,[REN_WFP]
	MOV	AL,BYTE PTR [SI]
	MOV	AH,BYTE PTR [DI]
	OR	AX,2020H		; Lower case
	CMP	AL,AH
	JZ	SAMEDRV
	MOV	AX,error_not_same_device
	STC
	return

SAMEDRV:
	PUSH	WORD PTR [DMAADD+2]
	PUSH	WORD PTR [DMAADD]
	MOV	WORD PTR [DMAADD+2],DS

;hkn; RENAMEDMA is in DOSDATA
	MOV	WORD PTR [DMAADD],OFFSET DOSDATA:RENAMEDMA
	MOV	[Found_dev],0		; Rename fails on DEVS, assume not a dev
	EnterCrit   critDisk
	invoke	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
					;    points to entry
	JNC	Check_Dev
	CMP	AX,error_no_more_files
	JNZ	GOTERR
	MOV	AX,error_file_not_found
GOTERR:
	STC
RENAME_POP:
	POP	WORD PTR [DMAADD]
	POP	WORD PTR [DMAADD+2]
	LeaveCrit   critDisk
	return

Check_dev:
	MOV	AX,error_access_denied	; Assume error

	PUSH	DS			      ;PTM.				;AN000;
	LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir	;AN000;
	ADD	SI,find_buf_attr	      ;PTM.				;AN000;
	TEST	[SI.dir_attr],attr_directory  ;PTM.				;AN000;
	JZ	notdir			      ;PTM.				;AN000;
	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path	;AN000;
	invoke	Check_Pathlen2		      ;PTM.   length < 67		;AN000;
notdir:
	POP	DS			      ;PTM.				;AN000;
	JA	GOTERR			      ;PTM.				;AN000;

	CMP	[Found_dev],0
	JNZ	GOTERR
; At this point a source has been found.  There is search continuation info (a
; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
; directory entry found.
; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
; throughout the RENAME since it is known at this point that the source and
; destination are both on the same device.
; [SATTRIB] is also set.
	MOV	SI,BX
	ADD	SI,dir_first
	invoke	REN_DEL_Check
	JNC	REN_OK1
	MOV	AX,error_sharing_violation
	JMP	RENAME_POP

;------------------------------------------------------------------------------
; Check if the source is a file or directory.  If file, delete the entry
; from the Fastopen cache. If directory, rename it later
;------------------------------------------------------------------------------
REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PUSH	SI
	LDS	SI,[DMAADD]		      ;BN00X; PTM. chek if source a dir       ;AN000;
	ADD	SI,find_buf_attr	      ;;BN00XPTM.P5520				   ;AN000;
	TEST	[SI.dir_attr],attr_directory  ;;BN00XPTM.			      ;AN000;
	JZ	Not_dir1		      ;;BN00XPTM.			      ;AN000;
	POP	SI			      ;BN00X
	JMP	SHORT  SWAP_SOURCE	      ;BN00X

NOT_DIR1:				;;BN00X it is a file, delete the entry
	POP	SI
	invoke	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3

SWAP_SOURCE:
	MOV	AX,[WFP_START]		; Swap source and destination
	MOV	SI,[REN_WFP]		; Swap source and destination
	MOV	[WFP_START],SI		; WFP_START = Destination path
	MOV	[REN_WFP],AX		; REN_WFP   = Source path
	MOV	[CURR_DIR_END],-1	; No current dir on dest
	MOV	WORD PTR [CREATING],DIRFREE*256+0ffh  ; Creating, not DEL *.*
					; A rename is like a CREATE_NEW as far
					; as the destination is concerned.
	invoke	GetPathNoSet
;   If this Getpath fails due to file not found, we know all renames will work
;   since no files match the destination name.	If it fails for any other
;   reason, the rename fails on a path not found, or whatever (also fails if
;   we find a device or directory).  If the Getpath succeeds, we aren't sure
;   if the rename should fail because we haven't built an explicit name by
;   substituting for the meta chars in it.  In this case the destination file
;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
;   in the directory entry part.
	JC	NODEST
;;	JZ	BAD_ACC 		; Dest string is a directory		;AC000;
	OR	AH,AH			; Device?
	JNS	SAVEDEST		; No, continue
BAD_ACC:
	MOV	AX,error_access_denied
	STC
RENAME_CLEAN:
	PUSHF				; Save carry state
	PUSH	AX			; and error code (if carry set)
	MOV	AL,[THISDRV]
	invoke	FLUSHBUF
	POP	AX
	CMP	[FAILERR],0
	JNZ	BAD_ERR 		; User FAILed to I 24
	POPF
	JMP	RENAME_POP

BAD_ERR:
	POP	AX			; Saved flags
	MOV	AX,error_path_not_found
	JMP	GOTERR

NODEST:
	JNZ	BAD_PATH
	CMP	[FAILERR],0
	JNZ	BAD_PATH	; Search for dest failed because user FAILed on
				;	I 24
	OR	CL,CL
	JNZ	SAVEDEST
BAD_PATH:
	MOV	AX,error_path_not_found
	STC
	JMP	RENAME_POP

SAVEDEST:
	Context ES

;hkn; NAME1 & NAME2 is in DOSDATA
	MOV	DI,OFFSET DOSDATA:NAME2
	MOV	SI,OFFSET DOSDATA:NAME1

	MOV	CX,11
	REP	MOVSB			; Save dest with metas at NAME2
	MOV	AX,[DIRSTART]
	MOV	[DESTSTART],AX
BUILDDEST:
	Context ES			; needed due to JMP BUILDDEST below

;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
	MOV	BX,OFFSET DOSDATA:RENAMEDMA + 21   ; Source of replace chars
	MOV	DI,OFFSET DOSDATA:NAME1    ; Real dest name goes here
	MOV	SI,OFFSET DOSDATA:NAME2    ; Raw dest

ifdef DBCS
	mov	cx,8
	call	new_rename
	mov	cx,3
	call	new_rename
else
	MOV	CX,11
	CALL	NEW_RENAME		    ;IFS. replace ? chars		;AN000;
endif

	MOV	[ATTRIB],attr_all	; Stop duplicates with any attributes
	MOV	[CREATING],0FFH
	invoke	DEVNAME 		; Check if we built a device name
	ASSUME	ES:NOTHING
	JNC	BAD_ACC
	MOV	BX,[DESTSTART]
	LES	BP,[THISDPB]
	invoke	SetDirSrch		; Reset search to start of dir
	JC	BAD_ACC 		; Screw up
	invoke	FINDENTRY		; See if new name already exists
	JNC	BAD_ACC 		; Error if found
	CMP	[FAILERR],0
	JNZ	BAD_ACCJ		; Find failed because user FAILed to I 24
	MOV	AX,[DESTSTART]		; DIRSTART of dest
	CMP	AX,WORD PTR [RENAMEDMA + 15]	; DIRSTART of source
	JZ	SIMPLE_RENAME		; If =, just give new name

	MOV	AL,[RENAMEDMA + 21 + dir_attr]
	TEST	AL,attr_directory
	JNZ	BAD_ACCJ		; Can only do a simple rename on dirs,
					; otherwise the .  and ..  entries get
					; wiped.
	MOV	[ATTRIB],AL
	MOV	WORD PTR [THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	MOV	SI,OFFSET DOSDATA:AUXSTACK - SIZE SF_ENTRY
	MOV	WORD PTR [THISSFT],SI
	MOV	[SI].sf_mode,sharing_compat+open_for_both
	XOR	CX,CX			; Set "device ID" for call into makenode
	invoke	RENAME_MAKE		; This is in mknode
	JNC	GOT_DEST
BAD_ACCJ:
	JMP	BAD_ACC

GOT_DEST:
	SAVE	<BX>
	LES	DI,ThisSFT		; Rename_make entered this into sharing
	Invoke	ShareEnd		; we need to remove it.
	RESTORE <BX>
; A zero length entry with the correct new name has now been made at
;   [CURBUF+2]:BX.
	LES	DI,[CURBUF]
	Assert	ISBUF,<ES,DI>,"Got_Dest"

	TEST	ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	ES:[DI.buf_flags],buf_dirty
yesdirty:
	MOV	DI,BX
	ADD	DI,dir_attr		; Skip name

;hkn; RENAMEDMA is in DOSDATA
	MOV	SI,OFFSET DOSDATA:RENAMEDMA + 21 + dir_attr
	MOV	CX,(SIZE dir_entry) - dir_attr
	REP	MOVSB
	CALL	GET_SOURCE
	DLJC	RENAME_OVER
	MOV	DI,BX
	MOV	ES,WORD PTR [CURBUF+2]
	MOV	AL,DIRFREE
	STOSB				; "free" the source
	JMP	SHORT DIRTY_IT

SIMPLE_RENAME:
	CALL	GET_SOURCE		; Get the source back
	JC	RENAME_OVER
	MOV	DI,BX
	MOV	ES,WORD PTR [CURBUF+2]

;hkn; NAME1 is in DOSDATA
	MOV	SI,OFFSET DOSDATA:NAME1    ; New Name
	MOV	CX,11
	REP	MOVSB
DIRTY_IT:
	MOV	DI,WORD PTR [CURBUF]

	TEST	ES:[DI.buf_flags],buf_dirty  ;LB. if already dirty		;AN000;
	JNZ	yesdirty2		  ;LB.	  don't increment dirty count   ;AN000;
	invoke	INC_DIRTY_COUNT 	  ;LB.					;AN000;
	OR	ES:[DI.buf_flags],buf_dirty

;------------------------------------------------------------------------------
; Check if the source is a directory of file.  If directory rename it to the
; the new name in the Fastopen cache buffer.   If file name it has been
; previously deleted.
;------------------------------------------------------------------------------
Yesdirty2:
	PUSH	SI
	LDS	SI,[DMAADD]		      ;;BN00XPTM. chek if source a dir	     ;AN000;
	ADD	SI,find_buf_attr	      ;;BN00XPTM.P5520				   ;AN000;
	TEST	[SI.dir_attr],attr_directory  ;;BN00XPTM.			      ;AN000;
	JZ	Not_dir2		      ;;BN00XPTM.			      ;AN000;
	INVOKE	FASTOPEN_RENAME 	      ;;BN00X rename dir entry in fastopen
	POP	SI
	JMP	SHORT NOT_DIRTY1

NOT_DIR2:				      ;;BN00X it is a file, delete the entry
	POP	SI

NOT_DIRTY1:				      ;;BN00X

	Assert	ISBUF,<ES,DI>,"Dirty_it"
NEXT_SOURCE:

;hkn; RENAMEDMA is in DOSDATA
	MOV	SI,OFFSET DOSDATA:RENAMEDMA + 1    ;Name
;
; WARNING!  Rename_Next leaves the disk critical section *ALWAYS*.  We need
; to enter it before going to RENAME_Next.
;
	EnterCrit   critDisk
	MOV	[CREATING],0	; Correct setting for search (we changed it
				;   to FF when we made the prev new file).
	invoke	RENAME_NEXT
;
; Note, now, that we have exited the previous ENTER and so are back to where
; we were before.
;
	JC	RENAME_OVER
	LEA	SI,[BX].dir_First
	invoke	REN_DEL_Check
	JNC	REN_OK2
	MOV	AX,error_sharing_violation
	JMP	RENAME_CLEAN

;------------------------------------------------------------------------------
; Check if file or directory. If file, delete file from the Fastopen cache,
; if directory, rename directory name in the Fastopen cache.
;-----------------------------------------------------------------------------
REN_OK2:
	MOV	AL,[RENAMEDMA + 21 + dir_attr]	   ; PTR P5622
	TEST	AL,attr_directory	;;BN00X directory
	JZ	Ren_Directory		;;BN00X no - file, delete it
	INVOKE	FASTOPEN_DELETE 	;;BN00X delete dir info in fastopen DOS 3.3
	JMP	BUILDDEST		;;BN00X

Ren_Directory:
	INVOKE	FASTOPEN_RENAME 	;;BN00X delete dir info in fastopen DOS 3.3
	JMP	BUILDDEST

RENAME_OVER:
	CLC
	JMP	RENAME_CLEAN
;----------------------------------------------------------------------------
;
; Procedure: GET_SOURCE
;
; Inputs:
;	RENAMEDMA has source info
; Function:
;	Re-find the source
; Output:
;	[CURBUF] set
;	[CURBUF+2]:BX points to entry
;	Carry set if error (currently user FAILed to I 24)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

GET_SOURCE:
	DOSAssume   <DS>,"Get_Source"
	ASSUME	ES:NOTHING

	MOV	BX,WORD PTR [RENAMEDMA + 15]	; DirStart
	LES	BP,ThisDPB
	invoke	SetDirSrch
	JC	ret_label			; retc
	invoke	StartSrch
	MOV	AX,WORD PTR [RENAMEDMA + 13]	; Lastent
	invoke	GetEnt

ret_label:
	return

EndProc DOS_RENAME

;----------------------------------------------------------------------------
;
;Procedure: NEW_RENAME
;
;Input: DS:SI -> raw string with ?
;	ES:DI -> destination string
;	DS:BX -> source string
;Function: replace ? chars of raw string with chars in source string and
;	   put in destination string
;Output: ES:DI-> new string
;---------------------------------------------------------------------------

	ASSUME	ES:NOTHING
procedure   NEW_RENAME,NEAR
	DOSAssume   <DS>,"NEW_Rename"

ifdef DBCS				; ### if DBCS ###

	mov	ah,0			; reset DBCS flag
	mov	dl,cl			; reset counter
	mov	dh,cl			; save length to do
newren_loop:
	cmp	ah,1			; if it was lead byte
	jz	newren_dbcs
	mov	ah,0			; reset if it was single or tail byte
	mov	al,[bx]			; get source char
	invoke	testkanj
	jz	newren_load		; if not lead byte
newren_dbcs:
	inc	ah			; set dbcs flag
newren_load:
	lodsb				; get raw char
	cmp	al,'?'
	jnz	newren_store		; if not '?'
	cmp	ah,0
	jz	newren_conv		; if source is single
	cmp	ah,1
	jnz	newren_pass		; if source is not lead
	cmp	cl,dh
	jnz	newren_lead		; if this is not 1st char
	cmp	byte ptr [si],' '
	jz	newren_double		; if this is the end
newren_lead:
	cmp	byte ptr [si],'?'
	jnz	newren_pass		; if no '?' for tail byte
	cmp	cx,1
	jbe	newren_pass		; if no room for tail byte
newren_double:
	mov	al,[bx]
	stosb
	dec	dl
	inc	bx
	inc	si
	dec	cx
newren_conv:
	mov	al,[bx]
newren_store:
	stosb				; store in destination
	dec	dl			; decrese counter
newren_pass:
	inc	bx
	loop	newren_loop
	mov	cl,dl			; get stored length
	xor	ch,ch
	jcxz	newren_ret		; if all done
	mov	al,' '
	rep	stosb			; put sapce
newren_ret:
	return

else					; ### if Not DBCS ###

NEWNAM:
	LODSB
	CMP	AL,"?"
	JNZ	NOCHG
	MOV	AL,[BX] 		; Get replace char
NOCHG:
	STOSB
	INC	BX			; Next replace char
	LOOP	NEWNAM
	return
endif					; ### end if Not DBCS ###

EndProc NEW_RENAME


DOSCODE	ENDS
    END




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\scnam.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

SCnm_0	DB	"Abort",0
SCnm_1	DB	"Std_Con_Input",0
SCnm_2	DB	"Std_Con_Output",0
SCnm_3	DB	"Std_Aux_Input",0
SCnm_4	DB	"Std_Aux_Output",0
SCnm_5	DB	"Std_Printer_Output",0
SCnm_6	DB	"Raw_Con_IO",0
SCnm_7	DB	"Raw_Con_Input",0
SCnm_8	DB	"Std_Con_Input_No_Echo",0
SCnm_9	DB	"Std_Con_String_Output",0
SCnm_10	DB	"Std_Con_String_Input",0
SCnm_11	DB	"Std_Con_Input_Status",0
SCnm_12	DB	"Std_Con_Input_Flush",0
SCnm_13	DB	"Disk_Reset",0
SCnm_14	DB	"Set_Default_Drive",0
SCnm_15	DB	"FCB_Open",0
SCnm_16	DB	"FCB_Close",0
SCnm_17	DB	"Dir_Search_First",0
SCnm_18	DB	"Dir_Search_Next",0
SCnm_19	DB	"FCB_Delete",0
SCnm_20	DB	"FCB_Seq_Read",0
SCnm_21	DB	"FCB_Seq_Write",0
SCnm_22	DB	"FCB_Create",0
SCnm_23	DB	"FCB_Rename",0
SCnm_24 DB	"===24===",0
SCnm_25	DB	"Get_Default_Drive",0
SCnm_26	DB	"Set_DMA",0
SCnm_27	DB	"===27===",0
SCnm_28	DB	"===28===",0
SCnm_29	DB	"===29===",0
SCnm_30	DB	"===30===",0
SCnm_31	DB	"Get_Default_DPB",0
SCnm_32	DB	"===32===",0
SCnm_33	DB	"FCB_Random_Read",0
SCnm_34	DB	"FCB_Random_Write",0
SCnm_35	DB	"Get_FCB_File_Length",0
SCnm_36	DB	"Get_FCB_Position",0
SCnm_37	DB	"Set_Interrupt_Vector",0
SCnm_38	DB	"Create_Process_Data_Block",0
SCnm_39	DB	"FCB_Random_Read_Block",0
SCnm_40	DB	"FCB_Random_Write_Block",0
SCnm_41	DB	"Parse_File_Descriptor",0
SCnm_42	DB	"Get_Date",0
SCnm_43	DB	"Set_Date",0
SCnm_44	DB	"Get_Time",0
SCnm_45	DB	"Set_Time",0
SCnm_46	DB	"Set_Verify_On_Write",0
SCnm_47	DB	"Get_DMA",0
SCnm_48	DB	"Get_Version",0
SCnm_49	DB	"Keep_Process",0
SCnm_50	DB	"Get_DPB",0
SCnm_51	DB	"Set_CTRL_C_Trapping",0
SCnm_52	DB	"Get_InDOS_Flag",0
SCnm_53	DB	"Get_Interrupt_Vector",0
SCnm_54	DB	"Get_Drive_Freespace",0
SCnm_55	DB	"Char_Oper",0
SCnm_56	DB	"International",0
SCnm_57	DB	"MKDir",0
SCnm_58	DB	"RMDir",0
SCnm_59	DB	"CHDir",0
SCnm_60	DB	"Creat",0
SCnm_61	DB	"Open",0
SCnm_62	DB	"Close",0
SCnm_63	DB	"Read",0
SCnm_64	DB	"Write",0
SCnm_65	DB	"Unlink",0
SCnm_66	DB	"LSeek",0
SCnm_67	DB	"CHMod",0
SCnm_68	DB	"IOCtl",0
SCnm_69	DB	"XDup",0
SCnm_70	DB	"XDup2",0
SCnm_71	DB	"Current_Dir",0
SCnm_72	DB	"Alloc",0
SCnm_73	DB	"Dealloc",0
SCnm_74	DB	"Setblock",0
SCnm_75	DB	"Exec",0
SCnm_76	DB	"Exit",0
SCnm_77	DB	"WaitProcess",0
SCnm_78	DB	"Find_First",0
SCnm_79	DB	"Find_Next",0
SCnm_80	DB	"Set_Current_PDB",0
SCnm_81	DB	"Get_Current_PDB",0
SCnm_82	DB	"Get_In_Vars",0
SCnm_83	DB	"SetDPB",0
SCnm_84	DB	"Get_Verify_On_Write",0
SCnm_85	DB	"Dup_PDB",0
SCnm_86	DB	"Rename",0
SCnm_87	DB	"File_Times",0
SCnm_88	DB	"AllocOper",0
SCnm_89	DB	"GetExtendedError",0
SCnm_90	DB	"CreateTempFile",0
SCnm_91	DB	"CreateNewFile",0
SCnm_92	DB	"LockOper",0
SCnm_93	DB	"ServerCall",0
SCnm_94	DB	"UserOper",0
SCnm_95	DB	"AssignOper",0
SCnm_96	DB	"xNameTrans",0
SCnm_97	DB	"PathParse",0
SCnm_98	DB	"GetCurrentPSP",0
SCnm_99	DB	"ECS_CALL",0
SCnm_100 DB	"Set_Printer_Flag",0
SCnm_101 DB	"GetExtCntry",0
SCnm_102 DB	"GetSetCdPg",0
SCnm_103 DB	"ExtHandle",0
SCnm_104 DB	"Commit",0
SCnm_105 DB	"GetSetMediaID",0
SCnm_106 DB	"===106===",0
SCnm_107 DB	"IFS_IOCTL",0
SCnm_108 DB	"ExtOpen",0


scptrs	DW	offset DOSCODE:SCnm_0
	DW	offset DOSCODE:SCnm_1
	DW	offset DOSCODE:SCnm_2
	DW	offset DOSCODE:SCnm_3
	DW	offset DOSCODE:SCnm_4
	DW	offset DOSCODE:SCnm_5
	DW	offset DOSCODE:SCnm_6
	DW	offset DOSCODE:SCnm_7
	DW	offset DOSCODE:SCnm_8
	DW	offset DOSCODE:SCnm_9
	DW	offset DOSCODE:SCnm_10
	DW	offset DOSCODE:SCnm_11
	DW	offset DOSCODE:SCnm_12
	DW	offset DOSCODE:SCnm_13
	DW	offset DOSCODE:SCnm_14
	DW	offset DOSCODE:SCnm_15
	DW	offset DOSCODE:SCnm_16
	DW	offset DOSCODE:SCnm_17
	DW	offset DOSCODE:SCnm_18
	DW	offset DOSCODE:SCnm_19
	DW	offset DOSCODE:SCnm_20
	DW	offset DOSCODE:SCnm_21
	DW	offset DOSCODE:SCnm_22
	DW	offset DOSCODE:SCnm_23
	DW	offset DOSCODE:SCnm_24
	DW	offset DOSCODE:SCnm_25
	DW	offset DOSCODE:SCnm_26
	DW	offset DOSCODE:SCnm_27
	DW	offset DOSCODE:SCnm_28
	DW	offset DOSCODE:SCnm_29
	DW	offset DOSCODE:SCnm_30
	DW	offset DOSCODE:SCnm_31
	DW	offset DOSCODE:SCnm_32
	DW	offset DOSCODE:SCnm_33
	DW	offset DOSCODE:SCnm_34
	DW	offset DOSCODE:SCnm_35
	DW	offset DOSCODE:SCnm_36
	DW	offset DOSCODE:SCnm_37
	DW	offset DOSCODE:SCnm_38
	DW	offset DOSCODE:SCnm_39
	DW	offset DOSCODE:SCnm_40
	DW	offset DOSCODE:SCnm_41
	DW	offset DOSCODE:SCnm_42
	DW	offset DOSCODE:SCnm_43
	DW	offset DOSCODE:SCnm_44
	DW	offset DOSCODE:SCnm_45
	DW	offset DOSCODE:SCnm_46
	DW	offset DOSCODE:SCnm_47
	DW	offset DOSCODE:SCnm_48
	DW	offset DOSCODE:SCnm_49
	DW	offset DOSCODE:SCnm_50
	DW	offset DOSCODE:SCnm_51
	DW	offset DOSCODE:SCnm_52
	DW	offset DOSCODE:SCnm_53
	DW	offset DOSCODE:SCnm_54
	DW	offset DOSCODE:SCnm_55
	DW	offset DOSCODE:SCnm_56
	DW	offset DOSCODE:SCnm_57
	DW	offset DOSCODE:SCnm_58
	DW	offset DOSCODE:SCnm_59
	DW	offset DOSCODE:SCnm_60
	DW	offset DOSCODE:SCnm_61
	DW	offset DOSCODE:SCnm_62
	DW	offset DOSCODE:SCnm_63
	DW	offset DOSCODE:SCnm_64
	DW	offset DOSCODE:SCnm_65
	DW	offset DOSCODE:SCnm_66
	DW	offset DOSCODE:SCnm_67
	DW	offset DOSCODE:SCnm_68
	DW	offset DOSCODE:SCnm_69
	DW	offset DOSCODE:SCnm_70
	DW	offset DOSCODE:SCnm_71
	DW	offset DOSCODE:SCnm_72
	DW	offset DOSCODE:SCnm_73
	DW	offset DOSCODE:SCnm_74
	DW	offset DOSCODE:SCnm_75
	DW	offset DOSCODE:SCnm_76
	DW	offset DOSCODE:SCnm_77
	DW	offset DOSCODE:SCnm_78
	DW	offset DOSCODE:SCnm_79
	DW	offset DOSCODE:SCnm_80
	DW	offset DOSCODE:SCnm_81
	DW	offset DOSCODE:SCnm_82
	DW	offset DOSCODE:SCnm_83
	DW	offset DOSCODE:SCnm_84
	DW	offset DOSCODE:SCnm_85
	DW	offset DOSCODE:SCnm_86
	DW	offset DOSCODE:SCnm_87
	DW	offset DOSCODE:SCnm_88
	DW	offset DOSCODE:SCnm_89
	DW	offset DOSCODE:SCnm_90
	DW	offset DOSCODE:SCnm_91
	DW	offset DOSCODE:SCnm_92
	DW	offset DOSCODE:SCnm_93
	DW	offset DOSCODE:SCnm_94
	DW	offset DOSCODE:SCnm_95
	DW	offset DOSCODE:SCnm_96
	DW	offset DOSCODE:SCnm_97
	DW	offset DOSCODE:SCnm_98
	DW	offset DOSCODE:SCnm_99
	DW	offset DOSCODE:SCnm_100
	DW	offset DOSCODE:SCnm_101
	DW	offset DOSCODE:SCnm_102
	DW	offset DOSCODE:SCnm_103
	DW	offset DOSCODE:SCnm_104
	DW	offset DOSCODE:SCnm_105
	DW	offset DOSCODE:SCnm_106
	DW	offset DOSCODE:SCnm_107
	DW	offset DOSCODE:SCnm_108

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\share.asm ===
TITLE	SHARING ROUTINES - Routines for file Sharing
	NAME	SHARE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Share.asm - File Sharing Routines
;
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include dpb.inc
	.cref
	.list

AsmVars <IBM, Installed>

Installed = True

	i_need  THISDPB,DWORD
	i_need  EXTERR,WORD
	i_need  ReadOp,BYTE
	i_need  ThisSFT,DWORD
	i_need  ALLOWED,BYTE
	I_need  RetryCount,WORD
	i_need  JShare,DWORD

DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

; Inputs:
;       [THISSFT] Points to filled in local file/device SFT for new
;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
;       [WFP_START] has full path of name
;       [USER_ID] Set
;       [PROC_ID] Set
; Function:
;       Check for sharing violations on local file/device access
; Outputs:
;    Carry clear
;       Sharing approved
;    Carry set
;       A sharing violation detected
;           AX is error code
; USES    ALL but DS

	ASSUME  ES:NOTHING
procedure   SHARE_CHECK,NEAR
	DOSAssume   <DS>,"Share_Check"

if installed
	call    JShare + 1 * 4
else
	Call    MFT_Enter
endif
	return

EndProc SHARE_CHECK

; Inputs:
;       [THISDPB] Set
;       AX has error code
; Function:
;       Handle Sharing errors
; Outputs:
;       Carry set if user says FAIL, causes error_sharing_violation
;       Carry clear if user wants a retry
;
; DS, ES, DI preserved, others destroyed

	ASSUME  ES:NOTHING
procedure   SHARE_VIOLATION,NEAR
	DOSAssume   <DS>,"Share_Viol"

	PUSH    DS
	PUSH    ES
	PUSH    DI
	MOV     [READOP],0                      ; All share errors are reading
	MOV     [ALLOWED],allowed_FAIL + allowed_RETRY
	LES     BP,[THISDPB]
	MOV     DI,1                            ; Fake some registers
	MOV     CX,DI
	MOV     DX,ES:[BP.dpb_dir_sector]
	invoke  HARDERR
	POP     DI
	POP     ES
	POP     DS
	CMP     AL,1
	retz                    ; 1 = retry, carry clear
	STC
	return

EndProc SHARE_VIOLATION

;   ShareEnd - terminate sharing info on a particular SFT/UID/PID.  This does
;       NOT perform a close, it merely asserts that the sharing information
;       for the SFT/UID/PID may be safely released.
;
;   Inputs:     ES:DI points to an SFT
;   Outputs:    None
;   Registers modified: all except DS,ES,DI

	ASSUME  ES:NOTHING
procedure   ShareEnd,Near
	DOSAssume   <DS>,"ShareEnd"

if installed
	Call    JShare + 2 * 4
else
	Call    MFTClose
endif
	return

EndProc ShareEnd

break <ShareEnter - attempt to enter a node into the sharing set>

;
;   ShareEnter - perform a retried entry of a nodde into the sharing set.  If
;   the max number of retries is exceeded, we notify the user via int 24.
;
;   Inputs:     ThisSFT points to the SFT
;               WFP_Start points to the WFP
;   Outputs:    Carry clear => successful entry
;               Carry set => failed system call
;   Registers modified: all

	assume  es:nothing
Procedure   ShareEnter,NEAR
	DOSAssume   <DS>,"ShareEnter"

	SAVE	<CX>
retry:
	mov     cx,RetryCount
attempt:
	les     di,ThisSFT              ; grab sft
	XOR     AX,AX
	MOV     ES:[DI.sf_MFT],AX       ; indicate free SFT
	SAVE	<CX>
	call    Share_Check             ; attempt to enter into the sharing set
	RESTORE <CX>
	jnc     done                    ; success, let the user see this
	invoke  Idle                    ; wait a while
	loop    attempt                 ; go back for another attempt
	call    Share_violation         ; signal the problem to the user
	jnc     retry                   ; user said to retry, go do it
done:
	RESTORE <CX>
	return
EndProc ShareEnter

DOSCODE    ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\segcheck.asm ===
TITLE	SegCheck - internal consistency check
	NAME	SegCheck

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

	.xlist
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include dpb.inc
	include sf.inc
	include int2a.inc
	.list


AsmVars <NET, DEBUG>

DOSCODE SEGMENT
    ASSUME  CS:DOSCODE

if	DEBUG
	allow_getdseg


	BREAK	<SegCheck - validate segments in MSDOS>


zfmt    MACRO   fmts,args
local   a,b
	PUSH    AX
	PUSH    BP
	MOV     BP,SP
If (not sharef) and (not redirector)
DOSDATA	 segment
a	 db	 fmts,0
DOSDATA	 ends
	MOV	AX,OFFSET DOSDATA:a
else
	jmp     short b
a       db      fmts,0
if sharef
b:      mov     ax,offset share:a
else
b:      mov     ax,offset netwrk:a
endif
endif
	PUSH    AX
cargs = 2
IRP item,<args>
IFIDN   <AX>,<item>
	MOV     AX,[BP+2]
ELSE
	MOV     AX,item
ENDIF
	PUSH    AX
cargs = cargs + 2
ENDM
	invoke  PFMT
	ADD     SP,Cargs
	POP     BP
	POP     AX
ENDM


;**	SegCheck - assure that segments are correctly set up
;
;	calling sequence:
;		call Segcheck
;		jmp	short l1
;		DB	flags
;		DB	asciz error message string
;	   l1:
;
;	flag values:	04 - check ES
;			02 - check DS
;			01 - check SS
;
;	ENTRY	As above
;	EXIT	returns if OK, prints and traps if error
;	USES	none

Procedure   SegCheck,NEAR
	ASSUME	SS:NOTHING
	SAVE	<BP>
	MOV     BP,SP                   ; set up addressing
	PUSHF				; Following code depends upon this order
	SAVE	<AX,BX,CX,DX,DS>	;    "       "	   "      "    "
	GETDSEG DS
	mov	dx,ds			; (dx) = DOSDATA segment
	mov	bx,2[bp]		; (bx) = return address
	mov	al,cs:2[bx]		; (al) = flag byte
	add	bx,3
	TEST	AL,1
	JZ	schk5			; don't check SS
	mov	cx,ss
	cmp	cx,dx
	je	schk5			; OK
	zfmt	<"Assumed SS invalid $S\n">,<cs,bX>
	TRAP

schk5:	test	al,2			; see if DS to be checked
	jz	schk10			; don't check DS
	mov	cx,-12[bp]
	cmp	cx,dx
	je	schk10			; no problem
	zfmt	<"Assumed DS invalid $S\n">,<cs,bX>
	TRAP

schk10:	test	al,4			; see if ES to be checked
	jz	schk15			; don't check ES
	mov	cx,es
	cmp	cx,dx
	je	schk15			; no problem
	zfmt	<"Assumed ES invalid $S\n">,<cs,bX>
	TRAP

schk15: RESTORE <DS,DX,CX,BX,AX>
	POPF
	RESTORE <BP>
	ret

EndProc SegCheck


I_need  DPBHead,DWORD
I_need	BufferQueue,DWORD
I_need  sftFCB,DWORD
I_need  AuxStack,BYTE
I_need  IOStack,BYTE
I_need  renbuf,byte
I_need  CurrentPDB,WORD
I_need  User_In_AX,WORD

extrn   ECritDisk:NEAR

CritNOP label   byte
	RET

AstFrame    STRUC
Astbp       dw  ?
Astip       dw  ?
Astmes      dw  ?
Astarg      dd  ?
AstFrame    ENDS



;**	DPBCheck - Validate A DPB Pointer
;
;	DPBCheck checks to see if a supplied pointer points to a DPB
;	as it's supposed to.
;
;	ENTRY
;	EXIT	returns if OK, message and trap if error
;	USES	none

Procedure   DPBCheck,NEAR
	assume	SS:nothing
	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>
	GETDSEG DS
	LES     DI,DPBHead
	LDS     SI,[BP].Astarg
    ASSUME DS:nothing
DPBLoop:CMP     DI,-1
	JZ      DPBNotFound
	invoke  PointComp
	JZ      DPBRet
	LES     DI,ES:[DI.dpb_next_dpb]
	JMP     DPBLoop

DPBNotFound:
	MOV     AX,[BP].Astmes
	zfmt	<"DPB assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

DPBRet: RESTORE <DI,ES,SI,DS,BX,AX> ;	Done:
	POPF
	RESTORE <BP>
	RET     6

EndProc DPBCheck


;**	SFTCheck - Validate an SFT Pointer
;
;	SFTCheck verifies that a pointer points to an SFT
;
;	ENTRY	BUGBUG
;	EXIT	returns if no error, traps w/message if error
;	USES	none

Procedure   SFTCheck,NEAR
	assume	SS:nothing

	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>
	LDS     SI,[BP].Astarg
	XOR     BX,BX                   ;   i = 0;
SFTLoop:
	SAVE	<BX>
	invoke  SFFromSFN               ;   while ((d=SF(i)) != NULL)
	RESTORE <BX>
	JC      Sft1
	invoke  PointComp
	JZ      DPBRet                  ;               goto Done;
SFTNext:INC     BX                      ;           else
	JMP     SFTLoop                 ;               i++;


SFT1:	GETDSEG DS
	LES	DI,sftFCB
   ASSUME DS:nothing
	MOV     BX,ES:[DI.sfCount]
	LEA     DI,[DI.sfTable]
sft2:	invoke	PointComp
	JZ	    DPBRet
	ADD     DI,SIZE sf_entry
	DEC     BX
	JNZ     SFT2

;	The SFT is not in the allocated tables.  See if it is one of the static
;	areas.

	GETDSEG ES
	MOV	DI,OFFSET DOSDATA:AUXSTACK - SIZE SF_ENTRY
	Invoke  PointComp
	JZ      DPBRet
	MOV	DI,OFFSET DOSDATA:RenBuf
	Invoke  PointComp
	LJZ	DPBRet


	MOV     AX,[BP].Astmes
	zfmt	<"SFT assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

EndProc SFTCheck,NoCheck


;**	BUFCheck - Validate a BUF Pointer
;
;	BUFCheck makes sure that a supposed BUF pointer is valid.
;
;	ENTRY	BUGBUG
;	EXIT	returns if OK, traps if error
;	USES	none

Procedure   BUFCheck,NEAR
	assume	SS:nothing
	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>

;	CheckDisk - make sure that we are in the disk critical section...

	GETDSEG DS
	MOV     AL,BYTE PTR ECritDisk
	CMP     AL,CritNOP
	JZ      CheckDone
ifdef	NEVER		; BUGBUG - turn this back on sometime?
	MOV     AX,CurrentPDB

	CMP     SectPDB + 2 * critDisk,AX
	MOV     AX,[BP].astmes
	JZ      CheckRef
	zfmt    <"$p: $x $s critDisk owned by $x\n">,<User_In_AX,AX,SectPDB+2*critDisk>
CheckRef:
	CMP     SectRef + 2 * critDisk,0
	JNZ     CheckDone
	zfmt    <"$p: $x $s critDisk ref count is 0\n">,<User_In_AX,AX>
ENDIF
CheckDone:

	LES	DI,BufferQueue
	LDS     SI,[BP].Astarg
  ASSUME DS:nothing
BUFLoop:CMP     DI,-1
	JZ	BufNotFound
	invoke  PointComp
	LJZ	DPBRet
	mov	di,es:buf_next[di]
	JMP     BUFLoop

BufNotFound:
	MOV     AX,[BP].Astmes
	zfmt	<"BUF assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

 DPUBLIC <DPBLoop, DPBNotFound, DPBRet>
 DPUBLIC <SFTLoop, SFTNext, SFT1, sft2, BUFLoop, BufNotFound>
 DPUBLIC <schk5, schk10, schk15>

EndProc BUFCheck,NoCheck

ENDIF

DOSCODE	ENDS

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\shrprint.asm ===
TITLE	SHRPRINT - PRINTF at SHARE level
	NAME	SHRPRINT

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;   Modification history:
;
;	Created: MZ 16 June 1984
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	.cref
	.list

	I_Need	Proc_ID,WORD
	I_Need	User_ID,WORD

BREAK	<debugging output>

Share	SEGMENT PARA PUBLIC 'SHARE'
	ASSUME	SS:DOSGROUP,CS:SHARE




;	PFMT - formatted output.  Calling sequence:
;	  PUSH	  BP
;	  PUSH	  fmtstr
;	  MOV	  BP,SP
;	  PUSH	  args
;	  CALL	  PFMT
;	  ADD	  SP,n
;	  POP	  BP
;
; The format string contains format directives and normal output characters
; much like the PRINTF for C.  We utilize NO format widths.  Special chars
; and strings are:
;
;       $x      output a hex number
;       $s      output an offset string
;       $c      output a character
;       $S      output a segmented string
;       $p      output userid/processid
;       \t      output a tab
;       \n      output a CRLF
;
; The format string must be addressable via CS
;

Procedure PFMT,NEAR
	ASSUME	SS:nothing
	SAVE	<AX,BX,DS,SI>
	MOV     AX,8007h
	INT     2Ah
	GETDSEG DS
	SUB     BP,2
	Call    FMTGetArg
	MOV     SI,AX
FmtLoop:
	LODSB
	OR      AL,AL
	JZ      FmtDone
	CMP     AL,'$'
	JZ      FmtOpt
	CMP     AL,'\'
	JZ      FmtChr
FmtOut:
	CALL	fOut
	JMP     FmtLoop

fOut:
	call	putch			; put character on serial port
	return

FmtDone:
	MOV     AX,8107h
	INT     2Ah
	RESTORE <SI,DS,BX,AX>
	RET
;
; \ leads in a special character. See what the next char is.
;
FmtChr: LODSB
	OR      AL,AL                   ; end of string
	JZ      fmtDone
	CMP     AL,'n'                  ; newline
	JZ      FmtCRLF
	CMP     AL,'t'                  ; tab
	JNZ     FmtOut
	MOV     AL,9
	JMP     FmtOut
FmtCRLF:MOV     AL,13
	CALL	fOut
	MOV     AL,10
	JMP     FmtOut
;
; $ leads in a format specifier.
;
FmtOpt: LODSB
	CMP     AL,'x'                  ; hex number
	JZ      FmtX
	CMP     AL,'c'                  ; single character
	JZ      FmtC
	CMP     AL,'s'                  ; offset string
	JZ      FmtSoff
	CMP     AL,'S'                  ; segmented string
	JZ      FmtSseg
	CMP     AL,'p'
	JZ      FmtUPID
	JMP     FmtOut
FmtX:
	Call    FMTGetArg
	MOV     BX,AX
	CALL    MNUM
	JMP     FmtLoop
FmtC:
	Call    FmtGetArg
	CALL	fOut
	JMP     FmtLoop
FmtSoff:
	SAVE	<SI>
	Call    FmtGetArg
	MOV     SI,AX
	CALL    fmtsout
	RESTORE <SI>
	JMP     FmtLoop
FmtSSeg:
	SAVE	<DS,SI>
	CALL    FMTGetArg
	MOV     DS,AX
	CALL    FMTGetArg
	MOV     SI,AX
	CALL    fmtsout
	RESTORE <SI,DS>
	JMP     FmtLoop
FmtUPID:
	INTTEST
	SAVE	<DS>
	MOV     BX,0
	MOV     DS,BX
	INTTEST 		; what to hell is this 82h?
	MOV     DS,DS:[82h]
    ASSUME DS:DOSDATA
	MOV     BX,User_ID
	CALL    MNUM
	MOV     AL,':'
	CALL	fOUT
	MOV     BX,Proc_ID
	CALL    MNUM
	RESTORE <DS>
    Assume DS:NOTHING
	JMP     FmtLoop
EndProc PFMT

Procedure   FMTGetArg,NEAR
	MOV     AX,[BP]
	SUB     BP,2
	return
EndProc FMTGetArg

Procedure   FmtSOut,NEAR
	LODSB
	OR      AL,AL
	retz
	CALL	fOUT
	JMP     FmtSOut
EndProc FMTSout

;**	MOut - output a message via serial port
;
;	ENTRY	(cs:bx) = message
;	USES	bx

Procedure   MOut,Near
	ASSUME	ES:NOTHING
	PUSHF
	Save	<ds, si, AX>
	PUSH    CS
	POP     DS
	MOV     SI,BX
	Call    FMTSout
	Restore <AX,SI,DS>
	POPF
	return
EndProc MOut

;   MNum - output a number in BX
;   Inputs:     BX contains a number
;   Outputs:    number in hex appears on screen
;   Registers modified: BX

Procedure   MNum,NEAR
	ASSUME	SS:NOTHING
	PUSHF
	SAVE	<ES,DI,AX,BX,CX,SI,DS>
	PUSH    SS
	POP     ES
	SUB     SP,6
	MOV     DI,SP                   ;   p = MNumBuf;
	SAVE	<DI>
	MOV     CX,4                    ;   for (i=0; i < 4; i++)
DLoop:	SAVE	<CX>
	MOV     CX,4                    ;       rotate(n, 4);
	ROL     BX,CL
	RESTORE <CX>
	MOV     AL,BL
	AND     AL,0Fh
	ADD     AL,'0'
	CMP     AL,'9'
	JBE     Nok
	ADD     AL,'A'-'0'-10
Nok:    STOSB                           ;       *p++ = "0123456789ABCDEF"[n];
	LOOP    DLoop
	XOR     AL,AL
	STOSB                           ;   *p++ = 0;
	RESTORE <SI>
	PUSH    ES
	POP     DS
	CALL    FMTSOUT                 ;   mout (mNumBuf);
	ADD     SP,6
	RESTORE <DS,SI,CX,BX,AX,DI,ES>
	POPF
	return
EndProc MNum


comport EQU	03f8h	; default to COM1

;**	putch - put character
;
;	(al) = character to output


	Public	putch
putch	PROC	near
	push	dx

	cmp	al,7
	je	putch1
	cmp	al,0ah		; filter out some garbage characters
	je	putch1		; that %s can produce when we don't
	cmp	al,0dh		; have a null terminated string
	je	putch1
	cmp	al,20h
	jae	pch0
	mov	al,'.'
	jmp	putch1

pch0:	cmp	al,07fh
	jb	putch1
	mov	al,'.'

putch1:
	cmp	al,0ah
	jne	putch2
	call	putraw
	mov	al,0dh
putch2: call	putraw
	pop	dx
	ret

putch	ENDP


	DPUBLIC putraw
putraw	PROC	near

	mov	dx, comport + 03fdh-3f8h
	mov	ah,al
putr5:	in	al,dx
	and	al,020h
	jz	putr5
	mov	al,ah
	mov	dx, comport
	out	dx,al
	ret

putraw	ENDP



 DPUBLIC <FmtLoop, FmtOut, fOut, FmtDone, FmtChr, FmtCRLF, FmtOpt, FmtX>
 DPUBLIC <FmtC, FmtSoff, FmtSSeg, FmtUPID, DLoop, Nok, pch0, putch1, putch2, putr5>

SHARE	ENDS
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\romfind.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;SR; 5/31/89; 
;The routines :
;
;$ROM_FIND_FIRST --- Finds first occurrence of a name in ROM
;
;$ROM_FIND_NEXT ---  Finds succeeding occurrences of the same name
;
;$ROM_EXCLUDE --- Get/Set ROM scan start address & Rom exclude regions ; M078
;

;
;------------------------------------------------------------------------------
;
; M078 : Added ROM exclude API. And modified ROM find first & find next to
;		to consult ROM exclusion list before looking at ROMs
;
;------------------------------------------------------------------------------
;

include version.inc                             ; YI 09/05/89
include dossym.inc
include dosseg.inc
include dosmac.inc
include mi.inc
include	error.inc				; M078

ifdef ROMEXEC

ifdef      JAPAN                      ; YI 09/05/89
ROMSTARTSEG     EQU     0008H
ROMENDSEG       EQU     000AH
else
BDATA	segment at 70h
	extrn	ROMSTARTADDR:word
BDATA	ends
endif

		I_NEED RomExclRegPtr,WORD	; M078
		I_NEED DMAADD,DWORD

DOSCODE	SEGMENT	BYTE   PUBLIC	'CODE'		
	ASSUME	CS:DOSCODE,SS:DOSDATA,DS:NOTHING,ES:NOTHING

	extrn	BioDataSeg:word

		PUBLIC	$ROM_FIND_FIRST
		PUBLIC	$ROM_FIND_NEXT
		PUBLIC	$ROM_EXCLUDE
		PUBLIC	Check_ROM
                PUBLIC  Check_name
ifdef      JAPAN                                          ; YI 09/05/89
                PUBLIC  ROMSTARTSEG, ROMENDSEG
endif

;
;Procedure : $ROM_FIND_FIRST
;
;		Inputs:
;			ds:dx points to user string (zero terminated)
;
;		Outputs: DTA filled as follows if match found ---
;
;		Offset 0: Name that matched (Zero terminated)
;		Offset 15: Segment address of ROM that matched
;		Offset 13: Offset for start of next search
;		Offset 17: User pattern
;
$ROM_FIND_FIRST	PROC	NEAR
	mov	si,dx				;ds:si points to user string
	call	check_name			;check if any path specifiers
	jc	bad_path			;yes, bad path

        push    ds
        mov     ds, cs:[BioDataSeg]

ifdef      JAPAN                                   ; YI 09/05/89
        mov     ax, ds:[ROMSTARTSEG]
else
	mov	ax,ds:[ROMSTARTADDR]
endif
        pop     ds
        mov     es,ax
	xor	ax,ax				;es:ax points to ROM scan addr	
	call	check_ROM			;check if in ROM
	jc	not_fnd				;not found in ROM

	call	fill_DTA			;fill the DTA		
;
;All data for FIND_NEXT has been stored
;

	invoke	get_user_stack
	and	[SI.USER_F], NOT f_Carry
	ret
bad_path:
	mov	ax,error_path_not_found		;Invalid path		M078
	jmp	short first_done
not_fnd:
	mov	ax,error_file_not_found		;File not found		M078

first_done:
	invoke	get_user_stack
	mov	[SI.USER_AX], ax
	or	[SI.USER_F], f_Carry
	ret
$ROM_FIND_FIRST	ENDP

;
;Procedure : $ROM_FIND_NEXT
;
;		Inputs:
;			DTA filled by FIND_FIRST
;		Outputs:
;			Same as FIND_FIRST 
;
$ROM_FIND_NEXT	PROC	NEAR
	lds	si,[DMAAdd]			;get DTA
	les	ax,[si+13]			;get scan addr. in es:ax
	add	si,17				;get pattern in ds:si
	call	check_ROM			;check if in ROM
	jc	no_next

	call	fill_DTA			;fill up the DTA

	invoke	get_user_stack
	and	[SI.USER_F], NOT f_Carry
	ret
no_next:
	mov	ax, error_no_more_files		; M078
	invoke	get_user_stack
	mov	[SI.USER_AX], ax
	or	[SI.USER_F], f_Carry
	ret
$ROM_FIND_NEXT	ENDP

;Procedure : Check_name
;	Inputs: ds:si points to string
;
;	Function:
;		Check if string has path specifiers i.e. ':','\'
;	Outputs:
;		Carry set if path specifiers present
;		Carry clear if no path specifiers
;
	 
Check_name	PROC	NEAR
	push	si
scan_loop:
	cmp	BYTE PTR [si],0
	jz	name_done
	cmp	BYTE PTR [si],':'		;check if drive specifier
	jz	path_spec
	cmp	BYTE PTR [si],'\'		;check if path specifier
	jz	path_spec
	inc	si
	jmp	scan_loop
name_done:
	pop	si
	clc		;no path specifier found
	ret
path_spec:
	pop	si
	stc		;path specifier found
	ret
Check_name	ENDP

;
;Procedure : Check_ROM
;	Inputs: ds:si points to string
;		ax=0 --- start scan from beginning
;		ax>0 --- start scan from given address
;		         es:ax points to address to start scan
;	Function:
;		Check if string matches ROM name
;	Outputs:
;		Carry set if no match found
;		Carry clear if match found and
;		   es:ax contains address of jmp to program in ROM
;		   dx contains offset address of matched string	
;		   cx contains length of matched string	
;

ROMSIG	EQU	0AA55H

Check_ROM	PROC	NEAR

	SaveReg	<bp, bx, si, di>	; M078

	xor	di,di			; DI is offset to ROM header
	or	ax,ax
	jz	check_sig

; restart search at location specified in AX
	add	di,ax
	jmp	short restart_search

;
;es:di contains start addr for ROM header.  check for valid ROM.
;	
check_sig:	
	cmp	WORD PTR es:[di],ROMSIG		
	jz	valid_sig
	mov	bx,es
	add	bx,80h
	jc	rom_done		; jump if above FFFFFH	; M078

	call	CheckExclRegion					; M078
	jc	rom_done					; M078

        mov     es,bx   ;next 2K block

ifdef      JAPAN
	push    ds
        mov     ds, cs:[BioDataSeg]
        cmp     bx, ds:[ROMENDSEG]
        pop     ds
        jc      check_sig
else
	jmp	check_sig					; M078
endif

rom_done:
	RestoreReg <di, si, bx, bp>				; M078
	stc		;No match found
	ret

valid_sig:
	add	di,6			; advance past header to cmd table
restart_search:

	xor	cx, cx			; set max number of searches
	call	GetMaxExclOff		; Get max offset allowed in BP ; M078

valid_lp:
	mov	bx, cx			; save max number of searches in BX
	mov	cl,es:[di]		; get length byte
	or	cl,cl			; is it zero?
	jz	next_ROM		; end of header
	inc	di			; start of name
	xor	ch,ch			; clear upper byte of length
	mov	dx, di			; save pointer to cmd name in dx
;M078-begin
	add	di, cx
	dec	di			; offset of last byte in the name
	cmp	bp, di			; does it overflow into Exclude region ?
	jb	next_ROM		; yes, skip to next ROM
	mov	di, dx			; restore pointer to name
;M078-end
	push	si			; preserve pointer to name
	call	scan
	pop	si			; restore pointer to name
	jnc	rom_match		; matched,get address
	mov	di,dx			; restore pointer to cmd name
cont_chk_nam:
	add	di,cx			; skip over name
	add	di,3			; skip over jmp
	mov	cx, bx			; get max number of searches from BX
	loop	valid_lp

next_ROM:
	xor	di, di			; get offset of ROM header
	mov	al,es:[di+2]		; get no. of pages
;
;Round off to 2K boundary
;
	xor	ah, ah			; clear upper byte
	add	ax, 011B		; to round up to fourth page
	and	ax, not 011B		; this rounds off to fourth
	mov	cl, 5			; to mult by 512 bytes per page and...
	shl	ax, cl			; ...divide by 16 bytes per paragraph
	mov	bx,es
	add	bx,ax
	jc	rom_done
	call	CheckExclRegion		; M078
	jc	rom_done		; M078

	mov	es,bx

ifdef      JAPAN                           ; YI 09/05/89
        push    ds
        mov     ds, cs:[BioDataSeg]
        cmp     bx, ds:[ROMENDSEG]
        pop     ds
        jnc     rom_done
        jmp     check_sig
else
        jmp     check_sig
endif

rom_match:
	add	di,cx			;point di to the jump instrn.
	mov	ax,di			;address of jmp in ROM
	RestoreReg <di, si, bx, bp>	; M078
	clc
	ret
Check_ROM	ENDP

;
;Procedure : Fill_DTA
;	
;		Inputs:
;			es:ax = start address for next name in ROM
;			es:dx = start address for matched name
;			cx = length of matched name
;			DMAAdd = address of current DTA
;
;		Outputs:
;			DTA filled up with the above values.
;
fill_DTA	PROC	NEAR

	mov	bx,es
	les	di,[DMAAdd]			;get DTA
	mov	es:[di+15],bx			;Store segment address of ROM
	add	ax,3				;Start of next name
	mov	es:[di+13],ax			;Store start of next name for
						;FIND_NEXT
	push	si
	push	ds
	mov	si,dx
	mov	ds,bx
	rep	movsb				;Store matched name in DTA
	xor	al,al
	stosb					;Make name zero-terminated
	pop	ds
	pop	si

	mov	di,word ptr [DMAAdd]
	add	di,17				;Start of pattern save area
cont_pat:
	lodsb
	stosb
	or	al,al				;check if end of string
	jz	end_pat
	jmp	cont_pat
end_pat:
	ret
fill_DTA	ENDP


;
;	input parameters: DS:SI -> user string
;			  ES:DI -> rom string
;			  CX	=  length of rom string
;
;	output:
;			Carry clear
;			DTA contains matching ROM string
;
;			if error Carry Set
;
;
scan 	proc	near

	push	cx
	push	ax
	push	es
	push	ds
	push	si
	push	di

	mov	ax, cx		; length of ROM string in AX

	cld

next:	cmp	byte ptr [si], '?'
	jz	skip
	cmp	byte ptr [si], '*'
	jz	found
	call	cmpi			;do case insensitive compare
	jne	no_match
	dec 	cx
	jcxz	is_match
	jmp	next

skip:	cmp	byte ptr es:[di], '.'
	je	no_match
	call 	cmpi			;do case insensitive compare
	jmp	next


found:
;
;	inc si till '.' or NULL
;	if NULL
;		matched
;	else
;		inc di till '.' or CX Z
;		if CX Z
;			no match
;		else
;			goto next
;		endif
;     	endif

	cmp	byte ptr [si], '.'
	jz	src_ext
	cmp	byte ptr [si], 0
	jz	match
	inc	si
	jmp	found

src_ext:inc	si			; point to extension of source string

do_dst:	cmp	byte ptr es:[di], '.'
	jz	chk_ext
	dec 	cx
	jcxz	no_match
	inc	di
	jmp	do_dst

chk_ext:inc 	di
	jmp	next

is_match:
	cmp	byte ptr [si],0
	jnz	no_match
match:
	clc
	jmp	short scan_done

no_match:
	stc

scan_done:	pop	di
	pop	si
	pop	ds
	pop	es
	pop	ax
	pop	cx
	ret

scan	endp

;
;Procedure : Cmpi
;
;		Input: ds:si and es:di point to the chars to be compared
;
;		Output: Zero flag set if match
;			Both di and si advanced
;
cmpi	PROC	NEAR
	push	ax
	lodsb	  		;get one char
	cmp	al,byte ptr es:[di]
	jz	cmp_match
	xor	al,20h		;get opposite case
	cmp	al,byte ptr es:[di]
cmp_match:
	lea	di,[di+1]		;Increment without changing flags
	pop	ax
	ret
cmpi	ENDP

; M078 - BEGIN

;
; Procedure : CheckExclRegion
;
;	Input BX = segment value to be validated and bumped to the next
;			non-exclude region
;	Output : Carry clear -> BX contains new segment after skipping
;				exclude regions if any
;		 Carry set -> After skipping exclude regions we crossed
;				1Meg boundary

CheckExclRegion	proc	near
		push	cx
		push	si
		push	ds

		cld
		lds	si, dword ptr RomExclRegPtr

		mov	ax, ds
		or	ax, si			; ds:si == 0:0 ?
		jz	cer6			; yes, quit

		lodsw
		mov	cx, ax
		jcxz	cer6			; quit if number of entries=0
cer1:
		cmp	bx, [si]
		jb	cer5

		cmp	bx, [si+2]
		ja	cer5

		mov	bx, [si+2]
		jmp	short cer7
cer5:
		add	si, 4
		loop	cer1
cer6:
		pop	ds
		pop	si
		pop	cx
		jmp	short cer9s
cer7:
		pop	ds
		pop	si
		pop	cx
		cmp	bx, 0ffffh
		je	cer9f
		inc	bx
cer9s:
		clc
		ret
cer9f:
		stc
		ret
CheckExclRegion	endp


;
; Procedure : GetMaxExclOff
;
;	Input ES = segment value in which the max offset is to be found
;	Output : BP contains the max offset

GetMaxExclOff	proc	near
		push	bx
		push	cx
		push	si
		push	ds

		mov	bp, 1000h
		cld
		lds	si, dword ptr RomExclRegPtr

		mov	ax, ds
		or	ax, si			; ds:si == 0:0 ?
		jz	gme9			; yes, quit

		lodsw
		mov	cx, ax
		jcxz	gme9			; quit if number of entries=0
		mov	bx, es
gme1:
		cmp	[si], bx
		jb	gme5

		mov	ax, [si]
		sub	ax, bx
		cmp	ax, bp
		jae	gme5
		mov	bp, ax
gme5:
		add	si, 4
		loop	gme1
gme9:
		mov	cl, 4
		shl	bp, cl
		dec	bp

		pop	ds
		pop	si
		pop	cx
		pop	bx
		ret
GetMaxExclOff	endp



;
; Procedure : $ROM_EXCLUDE
;		To get/Set Rom scan start address and ROM exclude regions
;
;	Input : AL=0 -- Get Romscan start segment
;	Output: BX=Rom scan start segment
;
;	Input : AL=1 -- Set Romscan start segment
;		BX=New romscan start address
;	Output:	None
;
;	Input :	AL=2 -- Get pointer to rom exclude region list
;	Output:	ES:BX=pointer to rom exclude region list
;
;	Input : AL=3 -- Set pointer to rom exclude region list
;		DS:DX=new rom exclude region list
;	Output: None
;
;
$ROM_EXCLUDE	proc	near
		assume	ds:nothing, ss:dosdata
		cmp	al, 3		; is the command out of range ?
		ja	re9f		; yes, quit!

		xor	ah, ah		; ax = command code

		dec	ax
		js	re10		; Get rom scan start segment

		dec	ax
		js	re20		; Set romscan start segment

		dec	ax
		js	re30		; get rom exclude region ptr

;
; Set Rom exclude region list pointer
;
		mov	RomExclRegPtr, dx
		mov	RomExclRegPtr+2, ds
		jmp	short re9s
;
; Get Romscan start segment
;
re10:
	        mov     ds, cs:[BioDataSeg]

ifdef      JAPAN
	        mov     bx, ds:[ROMSTARTSEG]
else
		mov	bx,ds:[ROMSTARTADDR]
endif
 		jmp	short re9s
;
; Set Romscan start segment
;
re20:
	        mov     ds, cs:[BioDataSeg]

ifdef      JAPAN
	        mov     ds:[ROMSTARTSEG], bx
else
		mov	ds:[ROMSTARTADDR], bx
endif
 		jmp	short re9s

;
; Get pointer to ROM exclude region list
;
re30:
		les	bx, dword ptr RomExclRegPtr

;;		Note : fall thru

;
; Get back to the user with success (no carry)
;
re9s:
		invoke	get_user_stack
		xor	al, al
		mov	[SI.USER_BX], bx
		mov	[SI.USER_ES], es
		and	[SI.USER_F], NOT f_Carry
		ret

re9f:
		mov	al, error_invalid_function
		invoke	get_user_stack
		or	[SI.USER_F], f_Carry
		ret
$ROM_EXCLUDE	endp

;
; M078 - end
;
DOSCODE	ENDS

endif ; ROMEXEC

	END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\time.asm ===
TITLE	TIME - time and date functions
	NAME	TIME

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	TIME.ASM - System Calls and low level routines for DATE and TIME
;
;	$GET_DATE
;	$SET_DATE
;	$GET_TIME
;	$SET_TIME
;	DATE16
;	READTIME
;	DSLIDE
;	SETYEAR
;	DODATE
;	DSUM
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
; 	M048 - set up DS using getdseg in date16 as we do not want to make 
;	       any assumptions regarding SS
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	.cref
	.list


    i_need  DAY,BYTE
    i_need  MONTH,BYTE
    i_need  YEAR,WORD
    i_need  WEEKDAY,BYTE
    i_need  TIMEBUF,6
    i_need  BCLOCK,DWORD
    i_need  DAYCNT,WORD
    i_need  YRTAB,8
    i_need  MONTAB,12
    i_need  DATE_FLAG,WORD

    FOURYEARS = 3*365 + 366

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg


	BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>

;**	$GET_DATE - Get Current Date
;
;	ENTRY	none
;	EXIT	(cx:dx) = current date
;	USES	all

procedure   $GET_DATE,NEAR

	Context DS
	CALL	READTIME		;Check for rollover to next day
	MOV	AX,[YEAR]

;	WARNING!!!! DAY and MONTH must be adjacently allocated!

	MOV	BX,WORD PTR [DAY]	; fetch both day and month
	invoke	get_user_stack		;Get pointer to user registers
    ASSUME DS:NOTHING
	MOV	[SI.user_DX],BX 	;DH=month, DL=day
	ADD	AX,1980 		;Put bias back
	MOV	[SI.user_CX],AX 	;CX=year

;hkn; SS override
	MOV	AL,BYTE PTR [WEEKDAY]
	return

EndProc $GET_DATE



;**	$SET_DATE - Set Current Date
;
;	ENTRY	(cx:dx) = current date
;	EXIT	(al) = -1 iff bad date
;		(al) = 0 if ok
;	USES	all

procedure   $SET_DATE,NEAR	;System call 43

	MOV	AL,-1			;Be ready to flag error
	SUB	CX,1980 		;Fix bias in year
	retc				;Error if not big enough
	CMP	CX,119			;Year must be less than 2100
	JA	RET24
	OR	DH,DH
	retz
	OR	DL,DL
	retz				;Error if either month or day is 0
	CMP	DH,12			;Check against max. month
	JA	RET24

;hkn; 	ss is DOSDATA
	Context DS
	invoke	DODATE
RET24:	return

EndProc $SET_DATE


;**	$GET_TIME - Get Current Time
;
;	ENTRY	none
;	EXIT	(cx:dx) = current time
;	USES	all

procedure   $GET_TIME,NEAR	; System call 44

;hkn; 	ss is DOSDATA
	Context DS
	CALL	READTIME
	invoke	get_user_stack		;Get pointer to user registers
	MOV	[SI.user_DX],DX
	MOV	[SI.user_CX],CX
	XOR	AL,AL
RET26:	return

EndProc $GET_TIME



;**	$SET_TIME - Set Current Time
;
;	ENTRY	(cx:dx) = time
;	EXIT	(al) = 0 if 0k
;		(al) = -1 if invalid
;	USES	ALL

procedure   $SET_TIME,NEAR	;System call 45

	MOV	AL,-1			;Flag in case of error
	CMP	CH,24			;Check hours
	JAE	RET26
	CMP	CL,60			;Check minutes
	JAE	RET26
	CMP	DH,60			;Check seconds
	JAE	RET26
	CMP	DL,100			;Check 1/100's
	JAE	RET26
	PUSH	CX
	PUSH	DX

;hkn; 	ss is DOSDATA
	Context DS

;hkn;	TIMEBUF	is now in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	PUSH	BX
	invoke	SETREAD

;hkn;	DOSAssume   CS,<ES>,"TIME/SetRead"
;hkn;	DS can still be used to access BCLOCK

	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct day count
	POP	DS
	DOSAssume   <DS>,"Set_Time"
	POP	BX
	invoke	SETWRITE
	POP	WORD PTR [TIMEBUF+4]
	POP	WORD PTR [TIMEBUF+2]
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Set the time
	XOR	AL,AL
	return

EndProc $SET_TIME

SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
PAGE
;--------------------------------------------------------------------------
;
; Procedure Name : DATE16
;
; Date16 returns the current date in AX, current time in DX
;   AX - YYYYYYYMMMMDDDDD  years months days
;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
;
; DS = DOSGROUP on output
;
;--------------------------------------------------------------------------
procedure   DATE16,NEAR

;M048	Context DS		
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	getdseg	<ds>			; M048

	PUSH	CX
	PUSH	ES
	CALL	READTIME
	POP	ES
	SHL	CL,1			;Minutes to left part of byte
	SHL	CL,1
	SHL	CX,1			;Push hours and minutes to left end
	SHL	CX,1
	SHL	CX,1
	SHR	DH,1			;Count every two seconds
	OR	CL,DH			;Combine seconds with hours and minutes
	MOV	DX,CX

;	WARNING!  MONTH and YEAR must be adjacently allocated

	MOV	AX,WORD PTR [MONTH]	;Fetch month and year
	MOV	CL,4
	SHL	AL,CL			;Push month to left to make room for day
	SHL	AX,1
	POP	CX
	OR	AL,[DAY]
	return

EndProc DATE16

;----------------------------------------------------------------------------
;
; Procedure : READTIME
;
;Gets time in CX:DX. Figures new date if it has changed.
;Uses AX, CX, DX.
;
;----------------------------------------------------------------------------

procedure   READTIME,NEAR
	DOSAssume   <DS>,"ReadTime"

	MOV	[DATE_FLAG],0		; reset date flag for CPMIO
	PUSH	SI
	PUSH	BX

;hkn;	TIMEBUF is in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	invoke	SETREAD
	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct date and time
	POP	DS
	DOSAssume   <DS>,"ReadTime2"
	POP	BX
	POP	SI
	MOV	AX,WORD PTR [TIMEBUF]
	MOV	CX,WORD PTR [TIMEBUF+2]
	MOV	DX,WORD PTR [TIMEBUF+4]
	CMP	AX,[DAYCNT]		;See if day count is the same
	retz
	CMP	AX,FOURYEARS*30 	;Number of days in 120 years
	JAE	RET22			;Ignore if too large
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	CX
	PUSH	DX			;Save time
	XOR	DX,DX
	MOV	CX,FOURYEARS		;Number of days in 4 years
	DIV	CX			;Compute number of 4-year units
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1			;Multiply by 8 (no. of half-years)
	MOV	CX,AX			;<240 implies AH=0

;hkn;	YRTAB is in DOSDATA
	MOV     SI,OFFSET DOSDATA:YRTAB;Table of days in each year

	CALL	DSLIDE			;Find out which of four years we're in
	SHR	CX,1			;Convert half-years to whole years
	JNC	SK			;Extra half-year?
	ADD	DX,200
SK:
	CALL	SETYEAR
	MOV	CL,1			;At least at first month in year

;hkn;	MONTAB is in DOSDATA
	MOV     SI,OFFSET DOSDATA:MONTAB   ;Table of days in each month

	CALL	DSLIDE			;Find out which month we're in
	MOV	[MONTH],CL
	INC	DX			;Remainder is day of month (start with one)
	MOV	[DAY],DL
	CALL	WKDAY			;Set day of week
	POP	DX
	POP	CX
	POP	SI
RET22:	return
EndProc READTIME

;----------------------------------------------------------------------------
; Procedure : DSLIDE
;----------------------------------------------------------------------------

	procedure   DSLIDE,NEAR
	MOV	AH,0
DSLIDE1:
	LODSB				;Get count of days
	CMP	DX,AX			;See if it will fit
	retc				;If not, done
	SUB	DX,AX
	INC	CX			;Count one more month/year
	JMP	SHORT DSLIDE1
EndProc DSLIDE

;----------------------------------------------------------------------------
;
; Procedure : SETYEAR
;
; Set year with value in CX. Adjust length of February for this year.
;
; NOTE: This can also be called thru int 2f. If this is called then it will
;       set DS to DOSDATA. Since the only guy calling this should be the DOS
;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
;	preserve DS as CHKYR is also called as a routine.
;
;----------------------------------------------------------------------------

procedure   SETYEAR,NEAR

	GETDSEG DS

	MOV	BYTE PTR [YEAR],CL
CHKYR:
	TEST	CL,3			;Check for leap year
	MOV	AL,28
	JNZ	SAVFEB			;28 days if no leap year
	INC	AL			;Add leap day
SAVFEB:
	MOV	[MONTAB+1],AL		;Store for February
RET23:	return

EndProc SETYEAR

;---------------------------------------------------------------------------
;
; Procedure Name : DODATE
;
;---------------------------------------------------------------------------

procedure   DODATE,NEAR

	DOSAssume   <DS>,"DoDate"
	CALL	CHKYR			;Set Feb. up for new year
	MOV	AL,DH

;hkn;	MONTAB is in DOSDATA
	MOV     BX,OFFSET DOSDATA:MONTAB-1

	XLAT				;Look up days in month
	CMP	AL,DL
	MOV	AL,-1			;Restore error flag, just in case
	retc				;Error if too many days
	CALL	SETYEAR
;
; WARNING!  DAY and MONTH must be adjacently allocated
;
	MOV	WORD PTR [DAY],DX	;Set both day and month
	SHR	CX,1
	SHR	CX,1
	MOV	AX,FOURYEARS
	MOV	BX,DX
	MUL	CX
	MOV	CL,BYTE PTR [YEAR]
	AND	CL,3

;hkn;	YRTAB is in DOSDATA
	MOV	SI,OFFSET DOSDATA:YRTAB
	MOV	DX,AX
	SHL	CX,1			;Two entries per year, so double count
	CALL	DSUM			;Add up the days in each year
	MOV	CL,BH			;Month of year

;hkn;	MONTAB is in DOSDATA
	MOV	SI,OFFSET DOSDATA:MONTAB
	DEC	CX			;Account for months starting with one
	CALL	DSUM			;Add up days in each month
	MOV	CL,BL			;Day of month
	DEC	CX			;Account for days starting with one
	ADD	DX,CX			;Add in to day total
	XCHG	AX,DX			;Get day count in AX
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	BX
	PUSH	AX

;hkn;	TIMEBUF is in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	PUSH	BX
	invoke	SETREAD

;hkn;	DOSAssume   CS,<ES>,"DoDate/SetRead"
;hkn;	DS is still valid and can be used to access BCLOCK

	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct date and time
	POP	DS
	POP	BX
	DOSAssume   <DS>,"DoDate2"
	invoke	SETWRITE
	POP	WORD PTR [TIMEBUF]
	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Set the date
	POP	DS
	DOSAssume   <DS>,"DoDate3"
	POP	BX
	POP	SI
WKDAY:
	MOV	AX,[DAYCNT]
	XOR	DX,DX
	MOV	CX,7
	INC	AX
	INC	AX			;First day was Tuesday
	DIV	CX			;Compute day of week
	MOV	[WEEKDAY],DL
	XOR	AL,AL			;Flag OK
Ret25:	return

EndProc DODATE



;**	DSUM - Compute the sum of a string of bytes
;
;	ENTRY	(cx) = byte count
;		(ds:si) = byte address
;		(dx) = sum register, initialized by caller
;	EXIT	(dx) updated
;	USES	ax, cx, dx, si, flags

procedure   DSUM,NEAR

	MOV	AH,0
	JCXZ	dsum9

dsum1:	LODSB
	ADD	DX,AX
	LOOP	DSUM1
dsum9:	return

EndProc DSUM


DOSCODE	     ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\search.asm ===
TITLE	SEARCH - Directory scan system calls
	NAME	SEARCH

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Search.asm
;
;	Directory search system calls.	These will be passed direct text of the
;	pathname from the user.  They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff.  I/O specs are
;	defined in DISPATCH.	The system calls are:
;
;
;	$Dir_Search_First	  written
;	$Dir_Search_Next	  written
;	$Find_First	  written
;	$Find_Next		  written
;	PackName		  written
;
;	Modification history:
;
;	  Created: ARR 4 April 1983


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE fastopen.inc
	INCLUDE fastxxxx.inc
	.cref
	.list


	i_need	SEARCHBUF,53
	i_need	SATTRIB,BYTE
	I_Need	OpenBuf,128
	I_need	DMAAdd,DWORD
	I_need	THISFCB,DWORD
	I_need	CurDrv,BYTE
	I_need	EXTFCB,BYTE
	I_need	Fastopenflg,BYTE
	I_need	DOS34_FLAG,WORD

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	DOS_SEARCH_FIRST:NEAR
	EXTRN	DOS_SEARCH_NEXT:NEAR
	EXTRN	TransFCB:NEAR
	EXTRN	TransPathSet:NEAR

;----------------------------------------------------------------------------
; Procedure Name : $DIR_SEARCH_FIRST
;
; Inputs:
;	DS:DX Points to unopenned FCB
; Function:
;	Directory is searched for first matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

procedure $DIR_SEARCH_FIRST,NEAR
	ASSUME CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	MOV	WORD PTR THISFCB,DX
	MOV	WORD PTR THISFCB+2,DS
	MOV	SI,DX
	CMP	BYTE PTR [SI],0FFH
	JNZ	NORMFCB4
	ADD	SI,7			; Point to drive select byte
NORMFCB4:
	SAVE	<[SI]>			; Save original drive byte for later

;hkn; SS is DOSDATA
	Context ES			; get es to address DOSGroup

;hkn; 	OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
	JNC	SearchIt		; no error, go and look
	RESTORE <BX>		; Clean stack
;
; Error code is in AX
;
	transfer FCB_Ret_Err		; error

SearchIt:

;hkn; SS is DOSDATA
	Context DS			; get ready for search
	SAVE	<<WORD PTR DMAAdd>, <WORD PTR DMAAdd+2>>

;hkn; Searchbuf is in DOSDATA
	MOV	WORD PTR DMAAdd,OFFSET DOSDATA:SEARCHBUF
	MOV	WORD PTR DMAAdd+2,DS
	call	GET_FAST_SEARCH 	; search
	RESTORE <<WORD PTR DMAAdd+2>, <WORD PTR DMAAdd>>
	JNC	SearchSet		; no error, transfer info
	RESTORE <BX>		; Clean stack
;
; Error code is in AX
;
	transfer FCB_Ret_Err

;
; The search was successful (or the search-next).  We store the information
; into the user's FCB for continuation.
;
SearchSet:

;hkn; Searchbuf is in DOSDATA
	MOV	SI,OFFSET DOSDATA:SEARCHBUF
	LES	DI,THISFCB		; point to the FCB
	TEST	EXTFCB,0FFH		;
	JZ	NORMFCB1
	ADD	DI,7			; Point past the extension
NORMFCB1:
	RESTORE <BX>		; Get original drive byte
	OR	BL,BL
	JNZ	SearchDrv
	MOV	BL,CurDrv
	INC	BL
SearchDrv:
	LODSB				; Get correct search contin drive byte
	XCHG	AL,BL			; Search byte to BL, user byte to AL
	INC	DI
;	STOSB				; Store the correct "user" drive byte
					;  at the start of the search info
	MOV	CX,20/2
	REP	MOVSW			; Rest of search cont info, SI -> entry
	XCHG	AL,BL			; User drive byte back to BL, search
					;   byte to AL
	STOSB				; Search contin drive byte at end of
					;   contin info
	LES	DI,DMAAdd
	TEST	EXTFCB,0FFH
	JZ	NORMFCB2
	MOV	AL,0FFH
	STOSB
	INC	AL
	MOV	CX,5
	REP	STOSB
	MOV	AL,SATTRIB
	STOSB
NORMFCB2:
	MOV	AL,BL			; User Drive byte
	STOSB
 IFDEF  DBCS									;AN000;
	MOVSW				; 2/13/KK				;AN000;
	CMP	BYTE PTR ES:[DI-2],5	; 2/13/KK				;AN000;
	JNZ	NOTKTRAN		; 2/13/KK				;AN000;
	MOV	BYTE PTR ES:[DI-2],0E5H ; 2/13/KK				;AN000;
NOTKTRAN:				; 2/13/KK				;AN000;
	MOV	CX,15			; 2/13/KK				;AN000;
 ELSE										;AN000;
	MOV	CX,16			; 32 / 2 words of dir entry		;AN000;
 ENDIF										;AN000;
	REP	MOVSW
	transfer FCB_Ret_OK

EndProc $DIR_SEARCH_FIRST, NoCheck

;----------------------------------------------------------------------------
;
; Procedure Name : $DIR_SEARCH_NEXT
;
; Inputs:
;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
; Function:
;	Directory is searched for the next matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

procedure $DIR_SEARCH_NEXT,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	MOV	WORD PTR THISFCB,DX
	MOV	WORD PTR THISFCB+2,DS
	MOV	SATTRIB,0
	MOV	EXTFCB,0

;hkn; SS is DOSDATA
	Context ES

;hknl SEARCHBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:SEARCHBUF

	MOV	SI,DX
	CMP	BYTE PTR [SI],0FFH
	JNZ	NORMFCB6
	ADD	SI,6
	LODSB

;hkn; ss override
	MOV	SATTRIB,AL
	DEC	EXTFCB
NORMFCB6:
	LODSB				; Get original user drive byte
	SAVE	<AX>			; Put it on stack
	MOV	AL,[SI+20]		; Get correct search contin drive byte
	STOSB				; Put in correct place
	MOV	CX,20/2
	REP	MOVSW			; Transfer in rest of search contin info

;hkn; SS is DOSDATA
	Context DS

	SAVE	<<WORD PTR DMAAdd>, <WORD PTR DMAAdd+2>>

;hkn; SEARCHBUF is in DOSDATA
	MOV	WORD PTR DMAAdd,OFFSET DOSDATA:SEARCHBUF
	MOV	WORD PTR DMAAdd+2,DS
	call	DOS_SEARCH_NEXT 	; Find it
	RESTORE <<WORD PTR DMAAdd+2>, <WORD PTR DMAAdd>>
	JC	SearchNoMore
	JMP	SearchSet		; Ok set return

SearchNoMore:
	LES	DI,THISFCB
	TEST	EXTFCB,0FFH
	JZ	NORMFCB8
	ADD	DI,7			; Point past the extension
NORMFCB8:
	RESTORE <BX>		; Get original drive byte
	MOV	ES:[DI],BL		; Store the correct "user" drive byte
					;  at the right spot
;
; error code is in AX
;
	transfer FCB_Ret_Err

EndProc $DIR_SEARCH_NEXT

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_FIRST
; 
;   Assembler usage:
;	    MOV AH, FindFirst
;	    LDS DX, name
;	    MOV CX, attr
;	    INT 21h
;	; DMA address has datablock
;
;   Error Returns:
;	    AX = error_path_not_found
;	       = error_no_more_files
;---------------------------------------------------------------------------

procedure $FIND_FIRST,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	SI,DX			; get name in appropriate place

;hkn; SS override
	MOV	SATTRIB,CL		; Search attribute to correct loc

;hkn; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer

	call	TransPathSet		; convert the path
	JNC	Find_it 		; no error, go and look
FindError:
	error	error_path_not_found	; error and map into one.
Find_it:

;hkn; SS is DOSDATA
	Context DS

	SAVE	<<WORD PTR DMAAdd>, <WORD PTR DMAAdd+2>>

;hkn; SEARCHBUF is in DOSDATA
	MOV	WORD PTR DMAAdd,OFFSET DOSDATA:SEARCHBUF
	MOV	WORD PTR DMAAdd+2,DS
	call	GET_FAST_SEARCH 	; search
	RESTORE <<WORD PTR DMAAdd+2>, <WORD PTR DMAAdd>>
	JNC	FindSet 		; no error, transfer info
	transfer Sys_Ret_Err

FindSet:

;hkn; SEARCHBUF is in DOSDATA
	MOV	SI,OFFSET DOSDATA:SEARCHBUF
	LES	DI,DMAAdd
	MOV	CX,21
	REP	MOVSB
	PUSH	SI			; Save pointer to start of entry
	MOV	AL,[SI.dir_attr]
	STOSB
	ADD	SI,dir_time
	MOVSW				; dir_time
	MOVSW				; dir_date
	INC	SI
	INC	SI			; Skip dir_first
	MOVSW				; dir_size (2 words)
	MOVSW
	POP	SI			; Point back to dir_name
 IFDEF  DBCS									;AN000;
	PUSH	DI			; XXXX save dest name 2/13/KK		;AN000;
	CALL	PackName							;AN000;
	POP	DI			; XXXX Recover dest name 2/13/KK	;AN000;
	CMP	BYTE PTR ES:[DI],05H	; XXXX Need fix?	 2/13/KK	;AN000;
	JNZ	FNXXX			; XXXX No		 2/13/KK	;AN000;
	MOV	BYTE PTR ES:[DI],0E5H	; XXXX Yes, Fix 	 2/13/KK	;AN000;
FNXXX:					; 2/13/KK				;AN000;
 ELSE										;AN000;
	CALL	PackName
 ENDIF
	transfer    Sys_Ret_OK		; bye with no errors
EndProc $FIND_FIRST


;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_NEXT
;
;   Assembler usage:
;	; dma points at area returned by find_first
;	    MOV AH, findnext
;	    INT 21h
;	; next entry is at dma
;
;   Error Returns:
;	    AX = error_no_more_files
;---------------------------------------------------------------------------

procedure $FIND_NEXT,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS is DOSDATA
	Context ES

;hkn; SEARCHBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:SEARCHBUF

;hkn; SS override
	LDS	SI,DMAAdd

	MOV	CX,21
	REP	MOVSB			; Put the search continuation info
					;  in the right place

;hkn; SS is DOSDATA
	Context DS			; get ready for search
	SAVE	<<WORD PTR DMAAdd>, <WORD PTR DMAAdd+2>>

;hkn; SEARCHBUF is in DOSDATA
	MOV	WORD PTR DMAAdd,OFFSET DOSDATA:SEARCHBUF

	MOV	WORD PTR DMAAdd+2,DS
	call	DOS_SEARCH_NEXT 	; Find it
	RESTORE <<WORD PTR DMAAdd+2>, <WORD PTR DMAAdd>>
	JNC	FindSet 		; No error, set info
	transfer Sys_Ret_Err

EndProc $FIND_NEXT

	Break	<PackName - convert file names from FCB to ASCIZ>


;**	PackName - Convert name to ASCIZ format.
;
;	PackName transfers a file name from DS:SI to ES:DI and converts it to
;	the ASCIZ format.
;
;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
;		(ES:DI) = destination area (13 bytes)
;	EXIT	(ds:SI) and (es:DI) advancedn
;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)

Procedure PackName,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;	Move over 8 characters to cover the name component, then trim it's
;	trailing blanks.

	MOV	CX,8			; Pack the name
	REP	MOVSB			; Move all of it
main_kill_tail:
	CMP	BYTE PTR ES:[DI-1]," "
	JNZ	find_check_dot
	DEC	DI			; Back up over trailing space
	INC	CX
	CMP	CX,8
	JB	main_kill_tail
find_check_dot:
	CMP	WORD PTR [SI],(" " SHL 8) OR " "
	JNZ	got_ext 		; Some chars in extension
	CMP	BYTE PTR [SI+2]," "
	JZ	find_done		; No extension
got_ext:
	MOV	AL,"."
	STOSB
	MOV	CX,3
	REP	MOVSB
ext_kill_tail:
	CMP	BYTE PTR ES:[DI-1]," "
	JNZ	find_done
	DEC	DI			; Back up over trailing space
	JMP	ext_kill_tail
find_done:
	XOR	AX,AX
	STOSB				; NUL terminate
	return
EndProc PackName


procedure   GET_FAST_SEARCH,NEAR

;hkn; SS override
	OR	DOS34_FLAG,SEARCH_FASTOPEN  ;FO.trigger fastopen		;AN000;
	call	DOS_SEARCH_FIRST
	return

EndProc GET_FAST_SEARCH


DOSCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\util.asm ===
TITLE	UTIL - Handle utilities
	NAME	UTIL

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Handle related utilities for MSDOS 2.X.
;
;	pJFNFromHandle	written
;	SFFromHandle	written
;	SFFromSFN	written
;	JFNFree 	written
;	SFNFree 	written
;
;	Modification history:
;
;	    Created: MZ 1 April 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include pdb.inc
	include sf.inc
	include bugtyp.inc
	.cref
	.list


	I_need  CurrentPDB,WORD         ; current process data block location
	I_need  SFT_Addr,DWORD          ; pointer to beginning of table
	I_Need  PROC_ID,WORD            ; current process ID
	I_Need  USER_ID,WORD            ; current user ID


DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

	allow_getdseg

	BREAK	<pJFNFromHandle - return pointer to JFN table entry>


;**	pJFNFromHandle - Translate Handle to Pointer to JFN
;
;	pJFNFromHandle takes a file handle and turns that into a pointer to
;	the JFN entry (i.e., to a byte holding the internal file handle #)
;
;	NOTE:
;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;	  at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	(bx) = handle
;	EXIT	'C' clear if ok
;		  (es:di) = address of JFN value
;		'C' set if error
;		  (ax) = error code
;	USES	AX, DI, ES, Flags

procedure   pJFNFromHandle,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	getdseg	<es>			; es -> dosdata
	MOV	ES,CurrentPDB		; get user process data block
    ASSUME ES:NOTHING

	CMP	BX,ES:PDB_JFN_Length	; is handle greater than allocated
	JB	pjfn10			; no, get offset
	fmt     TypAccess,LevSFN,<"$p: Illegal JFN %x\n">,<BX>
	MOV     AL,error_invalid_handle ; appropriate error
ReturnCarry:
	STC                             ; signal error
	return                          ; go back

pjfn10: LES	DI,ES:PDB_JFN_Pointer	; get pointer to beginning of table
	ADD	DI,BX			; add in offset, clear 'C'
	return

EndProc pJFNFromHandle


BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
;---------------------------------------------------------------------------
;
; Procedure Name : SFFromHandle
;
; SFFromHandle - Given a handle, get JFN and then index into SF table
;
;   Input:      BX has handle
;   Output:     Carry Set
;                   AX has error code
;               Carry Reset
;                   ES:DI has pointer to SF entry
;   Registers modified: If error, AX,ES, else ES:DI
; NOTE:
;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;----------------------------------------------------------------------------

procedure   SFFromHandle,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	CALL    pJFNFromHandle          ; get jfn pointer
	retc                            ; return if error
	CMP     BYTE PTR ES:[DI],-1     ; unused handle
	JNZ     GetSF                   ; nope, suck out SF
	fmt     TypAccess,LevSFN,<"$p: Illegal SFN $x:$x\n">,<ES,DI>
	MOV     AL,error_invalid_handle ; appropriate error
	jump    ReturnCarry             ; signal it
GetSF:
	SAVE	<BX>			; save handle
	MOV     BL,BYTE PTR ES:[DI]     ; get SFN
	XOR     BH,BH                   ; ignore upper half
	CALL    SFFromSFN               ; get real sf spot
	RESTORE <BX>		    ; restore
	return                          ; say goodbye
EndProc SFFromHandle

BREAK <SFFromSFN - index into SF table for SFN>


;**	SFFromSFN - Get an SF Table entry from an SFN
;
;	SFFromSfn uses an SFN to index an entry into the SF table.  This
;	is more than just a simple index instruction because the SF table
;	can be made up of multiple pieces chained together.  We follow the
;	chain to the right piece and then do the index operation.
;
;   NOTE:
;	This routine is called from SFFromHandle which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	BX has SF index
;	EXIT	'C' clear if OK
;		  ES:DI points to SF entry
;		'C' set if index too large
;	USES	BX, DI, ES

procedure   SFFromSFN,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; address DOSDATA
	LES	DI,SFT_Addr		; (es:di) = start of SFT table
    ASSUME ES:NOTHING

sfsfn5:	CMP	BX,ES:[DI].SFCount	; is handle in this table?
	JB	sfsfn7			; yes, go grab it
	SUB     BX,ES:[DI].SFCount
	LES     DI,ES:[DI].SFLink       ; get next table segment
	CMP     DI,-1                   ; end of tables?
	JNZ	sfsfn5			; no, try again
	STC
	ret				; return with error, not found

sfsfn7: SAVE	<AX>
	MOV     AX,SIZE SF_Entry        ; put it in a nice place
	MUL	BL			; (ax) = offset into this SF block
	ADD	DI,AX			; add base of SF block
	RESTORE <AX>
	ADD	DI,SFTable		; offset into structure, 'C' cleared
	return				; return with 'C' clear

EndProc SFFromSFN

	BREAK <JFNFree - return a jfn pointer if one is free>

;**	JFNFree - Find a Free JFN Slot
;
;
;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if OK
;		  (bx) = new handle
;		  (es:di) = pointer to JFN slot
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, flags

procedure   JFNFree,NEAR
	DOSASSUME <ss>,"JFNFree"

	XOR	BX,BX			; (bx) = initial JFN to try
jfnf1:	CALL	pJFNFromHandle		; get the appropriate handle
	JC	jfnf5			; no more handles
	CMP     BYTE PTR ES:[DI],-1     ; free?
	je	jfnfx			; yes, carry is clear
	INC     BX                      ; no, next handle
	JMP	jfnf1			; and try again

;	Error.	'C' set

jfnf5:	MOV	AL,error_too_many_open_files

jfnfx:	return				; bye

EndProc JFNFree

	BREAK <SFNFree - Allocate a free SFN>


;**	SFNFree - Allocate a Free SFN/SFT
;
;	SFNFree scans through the sf table looking for a free entry
;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
;
;	The problem is that we want to mark the SFT busy so that other threads
;	can't allocate the SFT before we're finished marking it up.  However,
;	we can't just mark it busy because we may get blown out of our open
;	by INT24 and leave the thing orphaned.	To solve this we mark it
;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
;	an SFT with this value we look to see if it belongs to this user
;	and process.  If it does belong to us then it must be an orphan
;	and we reclaim it.
;
;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
;		over and over, but we could at least set a high water mark...
;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
;		even though this is not a frequently called routine - jgl
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if no error
;		  (bx) = SFN
;		  (es:di) = pointer to SFT
;		  es:[di].SFT_REF_COUNT = -1
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, se, Flags

Procedure SFNFree,NEAR
	DOSASSUME <SS>,"SFNFree"

	SAVE	<ax>
	xor	bx,bx			; (bx) = SFN to consider
sfnf5:	SAVE	<bx>
	call	SFFromSFN		; get the potential handle
	RESTORE <bx>
	DLJC	sfnf95			; no more free SFNs
	cmp	es:[DI.sf_Ref_Count],0	; free?
	je	sfnf20			; yep, got one
	cmp	es:[DI.sf_ref_count],sf_busy
	je	sfnf10			; special busy mark
sfnf7:	inc	bx			; try the next one
	jmp	sfnf5

;	The SFT has the special "busy" mark; if it belongs to us then
;	it was abandoned during a earlier call and we can use it.
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf10:	fmt	TypAccess,LevSFN,<"$p: SFT $x:$x($x)is busy, owner $x:$x\n">,<ES,DI,BX,es:[DI].sf_UID,es:[DI].sf_pid>
	mov	ax,User_ID
	cmp	es:[DI].SF_UID,ax
	jnz	sfnf7			; not ours
	mov	ax,Proc_ID
	cmp	es:[DI].SF_PID,ax
	jnz	sfnf7			; can't use this one, try the next

;	We have an SFT to allocate
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf20: fmt	TypAccess,LevSFN,<"$p: SFT $x:$x($x) marked busy\n">,<ES,DI,bx>
	mov	es:[DI.sf_ref_count],sf_busy	; make sure that this is allocated
	mov	ax,User_ID
	mov	es:[DI].SF_UID,ax
	mov	ax,Proc_ID
	mov	es:[DI].SF_PID,ax
	RESTORE <ax>
	clc
	return				; return with no error


;**	Error - no more free SFNs
;
;	'C' set
;	(TOS) = saved ax

sfnf95: pop	ax
	mov	al,error_too_many_open_files
	ret					; return with 'C' and error

EndProc SFNFree
DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\srvcall.asm ===
TITLE SRVCALL - Server DOS call
	NAME  SRVCALL

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	SRVCALL.ASM - Server DOS call functions
;
;
;	$ServerCall
;
;	Modification history:
;
;	    Created: ARR 08 August 1983


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include sf.inc
	.cref
	.list

AsmVars <Installed>

include dpl.asm

Installed = TRUE

	i_need	USER_ID,WORD
	i_need	PROC_ID,WORD
	i_need	SaveBX,WORD
	i_need	SaveDS,WORD
	i_need	SWAP_START,BYTE
	i_need	SWAP_ALWAYS,BYTE
	i_need	SWAP_END,BYTE
	I_Need	ThisSFT,DWORD
	I_need	fSharing,BYTE
	i_need	OpenBuf,128
	I_Need	ExtErr,WORD
	I_Need	ExtErr_Action,BYTE
	I_Need	ExtErrPt,DWORD
	I_Need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	i_need	JShare,DWORD
;SR;
; Win386 presence flag
;
	I_need	IsWin386,byte


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


BREAK <ServerCall -- Server DOS call>

;hkn; TABLE	SEGMENT
Public SRVC001S,SRVC001E
SRVC001S label byte

ServerTab	DW	DOSCODE:Server_Disp
SERVERLEAVE	DW	DOSCODE:ServerReturn
SERVER_DISP	DB	(SERVER_DISP_END-SERVER_DISP-1)/2
		DW	OFFSET DOSCODE:SRV_CALL	; 0
		DW	OFFSET DOSCODE:COMMIT_ALL	; 1
		DW	OFFSET DOSCODE:CLOSE_NAME	; 2
		DW	OFFSET DOSCODE:CLOSE_UID	; 3
		DW	OFFSET DOSCODE:CLOSE_UID_PID	; 4
		DW	OFFSET DOSCODE:GET_LIST	; 5
		DW	OFFSET DOSCODE:GET_DOS_DATA	; 6
		DW	OFFSET DOSCODE:SPOOL_OPER	; 7
		DW	OFFSET DOSCODE:SPOOL_OPER	; 8
		DW	OFFSET DOSCODE:SPOOL_OPER	; 9
		DW	OFFSET DOSCODE:$setExtendedError   ; 10
SERVER_DISP_END LABEL	BYTE

SRVC001E label byte

;hkn; TABLE	ENDS

;----------------------------------------------------------------------------
;
; Procedure Name : $ServerCall
;
; Inputs:
;	DS:DX -> DPL  (except calls 7,8,9)
; Function:
;	AL=0	Server DOS call
;	AL=1	Commit All files
;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
;	AL=3	Close all files for DPL_UID
;	AL=4	Close all files for DPL_UID/PID_PID
;	AL=5	Get open file list entry
;		    IN: BX File Index
;			CX User Index
;		    OUT:ES:DI -> Name
;			BX = UID
;		    CX = # locked blocks held by this UID
;	AL=6	Get DOS data area
;		    OUT: DS:SI -> Start
;			CX size in bytes of swap if indos
;			DX size in bytes of swap always
;	AL=7	Get truncate flag
;	AL=8	Set truncate flag
;	AL=9	Close all spool files
;	AL=10	SetExtendedError
;
;----------------------------------------------------------------------------

procedure   $ServerCall,NEAR
	CMP	AL,7
	JB	SET_STUFF
	CMP	AL,9
	JBE	NO_SET_ID		; No DPL on calls 7,8,9
SET_STUFF:
	MOV	SI,DX			; Point to DPL with DS:SI
	MOV	BX,[SI.DPL_UID]

;SR;
; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
; of USER_ID
;
	test	[IsWin386],1
	jnz	skip_win386

;hkn; SS override for user_id and proc_id
	MOV	[USER_ID],BX		; Set UID

skip_win386:

	MOV	BX,[SI.DPL_PID]
	MOV	[PROC_ID],BX		; Set process ID
NO_SET_ID:
	PUSH	SERVERLEAVE		; push return address
	PUSH	ServerTab		; push table address
	PUSH	AX
	Invoke	TableDispatch

;hkn; SS override
	MOV	EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus
	error	error_invalid_function
ServerReturn:
	return

; Commit - iterate through the open file list and make sure that the
; directory entries are correctly updated.

COMMIT_ALL:
ASSUME	DS:NOTHING,ES:NOTHING
	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
	Context DS
	EnterCrit   critSFT		; Gonna scan SFT cache, lock it down
CommitLoop:
	SAVE	<BX>
	Invoke	SFFromSFN
	JC	CommitDone
	CMP	ES:[DI].sf_Ref_Count,0	;	if (ThisSFT->refcount != 0)
	JZ	CommitNext
	CMP	ES:[DI].sf_Ref_Count,sf_busy  ; BUSY SFTs have god knows what
	JZ	CommitNext		      ;   in them.
	TEST	ES:[DI].sf_flags,sf_isnet
	JNZ	CommitNext		;  Skip Network SFTs so the SERVER
					;	doesn't deadlock
	MOV	WORD PTR ThisSFT,DI
	MOV	WORD PTR ThisSFT+2,ES
	Invoke	DOS_Commit		;	    DOSCommit ();
CommitNext:
	RESTORE <BX>
	INC	BX
	JMP	CommitLoop
CommitDone:
	LeaveCrit   critSFT
	RESTORE <BX>
	transfer    Sys_Ret_OK

CLOSE_NAME:
ASSUME	DS:NOTHING,ES:NOTHING

if installed

;hkn; SS override
	Call	JShare + 5 * 4
else
	Call	MFTcloN
endif
CheckReturns:
	JC	func_err
	transfer SYS_RET_OK
func_err:
	transfer SYS_RET_ERR

CLOSE_UID:
ASSUME	DS:NOTHING,ES:NOTHING

if installed
;hkn; SS override
	Call	JShare + 3 * 4
else
	Call	MFTclU
endif
	JMP	CheckReturns

CLOSE_UID_PID:
ASSUME	DS:NOTHING,ES:NOTHING

if installed
;hkn; SS override
	Call	JShare + 4 * 4
else
	Call	MFTCloseP
endif
	JMP	CheckReturns

GET_LIST:
ASSUME	DS:NOTHING,ES:NOTHING
if installed
;hkn; SS override
	Call	JShare + 9 * 4
else
	Call	MFT_get
endif
	JC	func_err
	invoke	get_user_stack
	MOV	[SI.user_BX],BX
	MOV	[SI.user_DI],DI
	MOV	[SI.user_ES],ES
SetCXOK:
	MOV	[SI.user_CX],CX
	transfer    SYS_RET_OK

SRV_CALL:
ASSUME	DS:NOTHING,ES:NOTHING
	POP	AX			; get rid of call to $srvcall
	SAVE	<DS,SI>
	invoke	GET_USER_STACK
	RESTORE <DI,ES>
;
; DS:SI point to stack
; ES:DI point to DPL
;
	invoke	XCHGP
;
; DS:SI point to DPL
; ES:DI point to stack
;
; We now copy the registers from DPL to save stack
;
	SAVE	<SI>
	MOV	CX,6
	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
	INC	DI
	INC	DI			; Skip user_BP
	MOVSW				; DS
	MOVSW				; ES
	RESTORE <SI>		; DS:SI -> DPL
	MOV	AX,[SI.DPL_AX]
	MOV	BX,[SI.DPL_BX]
	MOV	CX,[SI.DPL_CX]
	MOV	DX,[SI.DPL_DX]
	MOV	DI,[SI.DPL_DI]
	MOV	ES,[SI.DPL_ES]
	PUSH	[SI.DPL_SI]
	MOV	DS,[SI.DPL_DS]
	POP	SI

;hkn; SS override for next 3
	MOV	[SaveDS],DS
	MOV	[SaveBX],BX
	MOV	fSharing,-1		; set no redirect flag
	transfer REDISP

GET_DOS_DATA:
	ASSUME	DS:NOTHING,ES:NOTHING
	Context ES
	MOV     DI,OFFSET DOSDATA:SWAP_START
	MOV     CX,OFFSET DOSDATA:SWAP_END
	MOV     DX,OFFSET DOSDATA:Swap_Always
	SUB     CX,DI
	SUB     DX,DI
	SHR     CX,1                    ; div by 2, remainder in carry
	ADC     CX,0                    ; div by 2 + round up
	SHL     CX,1                    ; round up to 2 boundary.
	invoke  GET_USER_STACK
	MOV     [SI.user_DS],ES
	MOV     [SI.user_SI],DI
	MOV     [SI.user_DX],DX
	JMP     SetCXOK

SPOOL_OPER:
ASSUME	DS:NOTHING,ES:NOTHING
	CallInstall NETSpoolOper,multNet,37,AX,BX
	JC	func_err2
	transfer SYS_RET_OK
func_err2:
	transfer SYS_RET_ERR

Break	<$SetExtendedError - set extended error for later retrieval>
;--------------------------------------------------------------------------
;
; Procedure Name : $SetExtendedError
;
; $SetExtendedError takes extended error information and loads it up for the
; next extended error call.  This is used by interrupt-level proccessors to
; mask their actions.
;
;   Inputs: DS:SI points to DPL which contains all registers
;   Outputs: none
;
;---------------------------------------------------------------------------

$SetExtendedError:

;hkn; SS override for all variables used

	ASSUME	DS:NOTHING,ES:NOTHING
	MOV	AX,[SI].dpl_AX
	MOV	[EXTERR],AX
	MOV	AX,[SI].dpL_di
	MOV	WORD PTR ExtErrPt,AX
	MOV	AX,[SI].dpL_ES
	MOV	WORD PTR ExtErrPt+2,AX
	MOV	AX,[SI].dpL_BX
	MOV	WORD PTR [EXTERR_ACTION],AX
	MOV	AX,[SI].dpL_CX
	MOV	[EXTERR_LOCUS],AH
	return
EndProc $ServerCall, NoCheck

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\grbs\mono.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

;----------------------------------------------------------------------------;
; This has all the code needed for a very simple grabber to work on machines ;
; for which we do not have a regular grabber. For this to work the display   ;
; should always be in a text mode. All the assumptions/restrictions that are ;
; assumed are:								     ;
;									     ;
;            . Will work for mode 3 and mode 7 only			     ;
;	     . Display buffer is at 0B800H for mode 3 and 0B000H for mode 7  ;
;	     . It is OK to access the display buffer directly		     ;
;	     . Only the following 4 calls are supported:		     ;
;		     . InitScreen					     ;
;		     . InquireSave					     ;
;		     . SaveScreen					     ;
;		     . RestoreScreen					     ;
;		All other calls are stubbed out and return with carry flag   ;
;		set.							     ;
;	     . Saves and restores only the active page.			     ;
;	     . Assumes 80x25 screen resolution indirectly (page size of 4K is;
;	       assumed).						     ;
;									     ;
;        Wed Sept-11-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created. (Added the History legend)				     ;
;----------------------------------------------------------------------------;


_TEXT		segment byte	public	'CODE'
		assume	cs:_TEXT


;
; STANDARD FUNCTION DISPATCH TABLE
;
;	Since the grabbers are loaded by Winoldap as a binary image, Winoldap
;	transfers control to them via a jump table at offset 0 of the grabber
;	code segment. The format of this table MUST remain fixed and MUST 
;       reside at offset 0!
;
;	Winoldap computes the offset of the desired entrypoint using the
;	knowledge that a near jump is 3 bytes of opcode.  However, as Winoldap
;	will be making a far call to the jmp, we MUST return far even though
;	our functions are near.  Winoldap must always set ds equal to the
;	grabber's cs before making the jump.
;
		org	0

StdFuncTable	label	word
		jmp	ObsoleteFunction	;NOP
		jmp	ObsoleteFunction	;NOP
		jmp	ObsoleteFunction	;NOP
		jmp	ObsoleteFunction	;NOP
		jmp	InquireSave		;Func 00005h
		jmp	SaveScreen		;Func 00006h
		jmp	RestoreScreen		;Func 00007h
		jmp	InitScreen		;Func 00008h


;----------------------------------------------------------------------------;
; declare global variables.						     ;
;----------------------------------------------------------------------------;

BufSize		dw	?		;size of save buffer
AppsMode	db	?		;mode at switch time
AppsPage	db	?		;page at switch time
AppsTopCurLine	db	?		;start line of cursor
AppsBotCurLine	db	?		;end line of cursor
AppsRow		db	?		;current row
AppsCol		db	?		;current coloumn

;----------------------------------------------------------------------------;
; constants.								     ;
;----------------------------------------------------------------------------;

PAGE_SIZE	equ	4096
SEG_MONO	equ	0b000h
SEG_COLOR	equ	0b800h
MODE_COLOR	equ	3
MODE_MONO	equ	7

; more constants for the beep routine

; Define IBM PC port locations for the Intel 8243 Programmable Interval Timer
; chip

PIT_PORTA	=	040h
PIT_PORTB	=	041h
PIT_PORTC	=	042h
PIT_PORTD	=	043h

; Define IBM PC port locations for the Intel 8255 Programmable Peripheral
; Interface chip

PPI_PORTA	=	060h
PPI_PORTB	=	061h
PPI_PORTC	=	062h
PPI_PORTD	=	063h

; Define timimgs and divisors to make sounds via the PIT, PPI chips and the
; PC's speaker circuitry.

BEEP_TIME1	=	02400h
BEEP_TIME2	=	03400h
BEEP_TONE1	=	00533h
BEEP_TONE2	=	00633h

;----------------------------------------------------------------------------;
; InitScreen - initialize screen to a known mode for the oldap		     ;
;									     ;
;	This routine will be called by Winoldap once before the oldap starts ;
;	up.  Winoldap will also call this routine just before it returns     ;
;	control to the oldap after a context switch from Windows back to the ;
;	oldap.	The latter of these two cases is redundent,since the grabbers;
;	RestoreScreen routine will be called shortly thereafter torestore the;
;	application's display context.  However, since we cannot discernthese;
;	two cases, we always set the display to a known mode regardless.     ;
;									     ;
; ENTRY									     ;
;	ds	=  cs							     ;
;	ax 	=  number of lines perscreen. If >= 43, 43 lime mode is	     ;
;		   set, else 25 line mode is set.			     ;
; EXIT									     ;
;	none								     ;
; USES									     ;
;	none								     ;
;									     ;
; NOTES:								     ;
;	 Every thing is ignored and the current mode is set again just to    ;
;	 clear the screen.						     ;	
;----------------------------------------------------------------------------;
InitScreen	proc	far

		assume	ds:_TEXT
		mov	ah,0fh			;get mode call
		int	10h			;al=mode
		xor	ah,ah			;set mode call
		int	10h			;screen cleared
		ret

InitScreen	endp
;----------------------------------------------------------------------------;
;									     ;
; InquireSave - return size of screen save buffer needed		     ;
;									     ;
; ENTRY									     ;
;	ds	=  cs							     ;
;	ax	=  n							     ;
;									     ;
;	where n is either:						     ;
;		1	Inquire text save buffer size			     ;
;		2	Inquire graphics save buffer size		     ;
; EXIT									     ;
;	dx:ax	=  size in bytes for save buffer			     ;
; USES									     ;
;	ax, dx, flags							     ;
;----------------------------------------------------------------------------;
InquireSave	proc	far

		assume	ds:_TEXT
		mov	ax,PAGE_SIZE		;size of one page
		mov	BufSize,ax		;save it
		xor	dx,dx			;dx:ax has size
		ret
InquireSave	endp
;----------------------------------------------------------------------------;
; SaveScreen - save the current display context				     ;
;									     ;
; ENTRY									     ;
;	ax	=  size in bytes of screen save area			     ;
;	ds	=  cs							     ;
;	es:di	-> screen save area					     ;
; EXIT									     ;
;	cf	=  0	(screen was successfully saved)			     ;
; ERROR EXIT								     ;
;	cf	=  1	(unable to save screen)				     ;
; USES									     ;
;	all except bp							     ;
; NOTES									     ;
;	Winoldap guarantees that the offset portion of the screen save area  ;
;	will always be zero, so it is safe to omit di from references to this;
;	area.								     ;
;----------------------------------------------------------------------------;

SaveScreen	proc	far
		assume	ds:_TEXT

; check to see if buffer size is OK

	cmp	ax,BufSize		;enough ?
	jb	SaveScreenErr		;no.

; save the current mode, page, cursor position.

	mov	ah,0fh			;get mode
	int	10h			
	mov	AppsMode,al		;save mode
	mov	AppsPage,bh		;save active page

; if the mode is not a text mode we must fail the call.

	cmp	al,MODE_COLOR		;color text mode ?
	jz	SS_ModeOk		;yes.
	cmp	al,MODE_MONO		;mono text mode ?
	jnz	SaveScreenErr		;no, fail the call

SS_ModeOk:

	mov	ah,3			;cursor details
	int	10h
	mov	AppsRow,dh		;cursor row
	mov	AppsCol,dl		;apps column
	mov	AppsTopCurLine,ch	;top cursor line
	mov	AppsBotCurLine,cl	;bottom cursor line

; set up start screen address.

	push	ds
	mov	ax,SEG_COLOR		;assume segment for color
	xor	bh,bh
	mov	bl,AppsPage		;current page
	mov	cl,AppsMode		;get mode
	cmp	cl,MODE_COLOR		;is it color mode ?
	jz	@f			;yes
	mov	ax,SEG_MONO		;get mode for mono
@@:
	mov	ds,ax			;load screen segment
	mov	ax,PAGE_SIZE		;size of a page
	mul	bx   			;throw away dx
	mov	si,ax			;ds:si points to start
	mov	cx,PAGE_SIZE / 2 	;size of a page
	cld				;ready for move
	rep	movsw			;save in one go
	pop	ds			;restore ds

	clc				;successful
	jmp	short SaveScreenRet

SaveScreenErr:

	call	OEMBeep			;can't switch
	stc

SaveScreenRet:

	ret

SaveScreen endp
;----------------------------------------------------------------------------;
; RestoreScreen - restore the previously saved display context		     ;
;									     ;
; ENTRY									     ;
;	ax	=  size in bytes of screen save area			     ;
;	ds	=  cs							     ;
;	es:di	-> screen save area					     ;
; EXIT									     ;
;	cf	=  0	(screen was successfully restored)		     ;
; ERROR EXIT								     ;
;	cf	=  1	(unable to restore screen)			     ;
; USES									     ;
;	all except bp							     ;
; NOTES									     ;
;	Winoldap guarantees that the offset portion of the screen save area  ;
;	will always be zero, so it is safe to omit di from references to this;
;	area.								     ;
;----------------------------------------------------------------------------;
RestoreScreen	proc	far
		assume	ds:nothing

	cmp	ax,BufSize		;right size ?
	jb	RestoreScreenErr	;no.

; restore mode and page.

	xor	ah,ah			;set mode
	mov	al,AppsMode		;saved mode
	int	10h

	mov	ah,5			;set page
	mov	al,AppsPage		;save page
	int	10h			

	push	ds
	push	es
	mov	ax,SEG_COLOR		;assume segment for color
	xor	bh,bh
	mov	bl,AppsPage		;current page
	mov	cl,AppsMode		;get mode
	cmp	cl,MODE_COLOR		;is it color mode ?
	jz	@f			;yes
	mov	ax,SEG_MONO		;get mode for mono
@@:
	mov	si,di			;offset of saved buffer
	push	es
	pop	ds			;ds:si has source
	mov	es,ax			;load screen segment
	mov	ax,PAGE_SIZE		;size of a page
	mul	bx   			;throw away dx
	mov	di,ax			;ds:si points to start
	mov	cx,PAGE_SIZE / 2 	;size of a page
	cld				;ready for move
	rep	movsw			;save in one go
	pop	es			
	pop	ds			;restore


; restore cursor details.

	mov	ah,1			;set cursor size
	mov	ch,AppsTopCurLine	;start line
	mov	cl,AppsBotCurLine	;end line
	int	10h	

	mov	ah,2
	mov	bh,AppsPage		;saved page number
	mov	dh,AppsRow		;saved cursor row
	mov	dl,AppsCol		;saved col
	int	10h

	clc				;success
	jmp	short RestoreScreenRet	;done

RestoreScreenErr:

	call	OEMBeep			;can't restore
	stc

RestoreScreenRet:

	ret

RestoreScreen  endp
;----------------------------------------------------------------------------;
; OEMBeep:								     ;
;								             ;
; This routine taken from the grabber sources hoots the hooter.              ;
;----------------------------------------------------------------------------;

OEMBeep 	proc	near

	push	ax
	push	cx			;save registers to be destroyed
	mov	al,0B6H 		;select timer 2
	out	PIT_PORTD,al
	mov	ax,BEEP_TONE1		;divisor for tone 1
	out	PIT_PORTC,al		;write timer 2 count - lsb
	mov	al,ah
	out	PIT_PORTC,al		;write timer 2 count - msb
	in	al,PPI_PORTB		;get current setting of port
	mov	ah,al			;save setting
	or	al,00000011b		;turn speaker on
	out	PPI_PORTB,al
	mov	cx,BEEP_TIME1		;wait awhile
	loop	$
	mov	cx,BEEP_TONE2		;divisor for tone 2
	mov	al,cl
	out	PIT_PORTC,al
	mov	al,ch
	out	PIT_PORTC,al
	mov	cx,BEEP_TIME2		;wait again
	loop	$
	mov	al,ah
	out	PPI_PORTB,al
	pop	cx			
	pop	ax			;restore saved registers
	ret

OEMBeep 	endp

;----------------------------------------------------------------------------;
; ObsoleteFunction:							     ;
;									     ;
; This function traps the entry level functions that are no longer needed    ;
; in the version 3 of grabbers. It sets carry and does a RETF.		     ;
;----------------------------------------------------------------------------;
ObsoleteFunction proc near

	stc				;error, unsupported function

farp_dummy proc far			;want to have far ret
	ret
farp_dummy endp

ObsoleteFunction endp
;----------------------------------------------------------------------------;

_TEXT		ends
		end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\cgraphic.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	CW : Character Windows
	cgraphic.h : Graphic Drawing

	Yes, COW not only does Windows, but it does graphics too

	CC should be defined for compilation with Cmerge.

-- Created Fri Mar 23 11:35:04 1990 */ 

/* Primative Graphic Types */

#ifndef NOGD_GPT
typedef struct _gpoint
	{
	int	x;
	int	y;
	} GPT; /* GPOINT / Graphic Point */
#endif /*!NOGD_GPT*/

#ifndef NOGD_RECT
typedef struct _rect
	{
	int	xLeft;
	int	yTop;
	int	xRight;
	int	yBottom;
	} RECT;
#endif /*!NOGD_RECT*/

#ifndef NOGD_POLYGON
typedef struct _polygon
	{
	WORD	cbPolygon;
	RECT	rectBound;
	GPT	rggpt[1];
	} POLYGON;
#endif /*!NOGD_POLYGON*/

#define	cpenMax		41	/* maximum number of pens */
#define	icoMax		41	/* maximum ico number */

/* Device descriptor */
typedef struct _ingd
	{
	WORD	fingd;		/* flags -- see below			*/
	WORD	reserved2;	/* for future use			*/
	WORD	fingpSupported;	/* procedures supported -- see below	*/
	WORD	dimH;		/* horizontal size in twips		*/
	WORD	dimV;		/* vertical size in twips		*/
	WORD	dxScreen;	/* number of horizontal pixels		*/
	WORD	dyScreen;	/* number of vertical pixels		*/
	WORD	dimPenH;	/* horizontal pen size in twips		*/
	WORD	dimPenV;	/* vertical pen size in twips		*/
	BYTE	cpen;		/* number of pens available		*/
	BYTE	icoAvailMac;	/* number of colors available		*/
	BYTE	icoPrefMac;	/* number of preferred colors		*/
	BYTE	ipaLineMac;	/* number of line styles		*/
	BYTE	ipaAreaMac;	/* number of area fill patterns		*/
	BYTE	ccopln;		/* number of color planes or ribbons	*/

	WORD	rgcoAvail[cpenMax];
	WORD	rgcoPref[cpenMax];
	BYTE	rgpaLine[5];
	BYTE	rgpaArea[16];
	char	szName[40];
	} INGD;


/* FINGD : Flags for the options supported in INGD */
#define	fingdRstrVctr	0x0004	/* Raster : MUST BE SET */
#define	fingdRasterFonts 0x0040	/* can use raster fonts			*/
#define	fingdMultiColor	0x0100	/* device has infinite colors		*/
#define	fingdVirtualPen	0x0200	/* do not prompt for pen changes	*/
#define	fingdFilm	0x0400	/* film device				*/
#define	fingdVarPenSize	0x1000	/* device can vary the pen size		*/
#define	fingdNotAvailable 0x8000/* device does not support this DEV	*/

/* FINGP: GSD procedures supported */
#define	fingpSetAreaPat	0x0001	/* set the current area pattern		*/
#define	fingpSetLinePat	0x0002	/* set the current line pattern		*/
#define	fingpSetLineWeight 0x0004 /* set the current line weight	*/
#define	fingpSetColor	0x0008	/* set the current color		*/
#define	fingpText	0x0010	/* draw a text string			*/
#define	fingpRectangle	0x0020	/* draw or fill a rectangle		*/
#define	fingpArc	0x0040	/* draw or fill an arc			*/
#define	fingpPolygon	0x0080	/* draw or fill a polygon		*/
#define	fingpBitBlt	0x0100	/* copy a bitmap			*/
#define	fingpInitGraphics 0x0200 /* Init/Term/Move			*/
#define	fingpDraw	0x0400	/* draw					*/
#define	fingpSnapShot	0x0800	/* Capture TSR support		*/
#define	fingpBltBlock	0x1000	/* move a block	*/
#define	fingpSetDrawMode	0x2000	/* set the current draw mode	*/


extern BOOL PASCAL fPrinting;

/*****************************************************************************/
/* Graphic Drawing Procedures */

#define	FLoadGsd(sz)	(RerrLoadGsd(sz) == rerrOk)
#define	FLoadGpd(sz)	(RerrLoadGpd(sz) == rerrOk)

#ifndef	NOPROCS
WORD	FARPUBLIC RerrLoadGsd(char *);
WORD	FARPUBLIC RerrLoadGpd(char *);
VOID	FARPUBLIC FreeGsd(void);
VOID	FARPUBLIC FreeGpd(void);
VOID	FARPUBLIC SetPrinting(BOOL);

BOOL	FARPUBLIC FInitGraphics(VOID *, VOID FAR *);
VOID	FARPUBLIC TermGraphics(void);
VOID	FARPUBLIC Move(WORD, WORD);
VOID	FARPUBLIC Draw(WORD, WORD);
VOID	FARPUBLIC SetAreaPat(WORD);
VOID	FARPUBLIC SetLinePat(WORD);
VOID	FARPUBLIC SetLineWeight(WORD);
VOID	FARPUBLIC SetColor(WORD, WORD);
VOID	FARPUBLIC Text(char far *, WORD, WORD, WORD, int);
VOID	FARPUBLIC Rectangle(struct _rect far *);
VOID	FARPUBLIC Arc(struct _rect far *, int, int);
VOID	FARPUBLIC Polygon(struct _polygon far *);
VOID	FARPUBLIC BitBlt(struct _rect far *, BYTE far *, WORD, BOOL);
VOID	FARPUBLIC DrawXOR(WORD, WORD);		/* Capture TSR support */
VOID	FARPUBLIC BitRead(struct _rect far *, BYTE far *, WORD);
VOID	FARPUBLIC SetDrawMode(WORD);
VOID	FARPUBLIC BltBlock(WORD,WORD, WORD,WORD, WORD,WORD);

#ifdef KANJI
/* CPD Functions */
// REVIEW: to be documented and properly supported !!!
WORD	FARPUBLIC RerrLoadCpd(char *);
VOID	FARPUBLIC FreeCpd(void);
WORD	FARPUBLIC InitCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC TermCpd(void);
WORD	FARPUBLIC AdvVertCpd(WORD);
WORD	FARPUBLIC AdvHorizCpd(WORD);
WORD	FARPUBLIC AdvPageCpd(void);
WORD	FARPUBLIC PrintRgchCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC PrintHdrCpd(CPD_STRUCTURE far *);
WORD	FARPUBLIC CrLfCpd(void);
#endif	/*KANJI*/
#endif	/* !NOPROCS */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\common.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	common.h - standard include file for all shell modules
**
**   Date      Author	Modification
** --------   --------	------------------------------------------------
**  7/01/89   scottq	created file
**  7/31/89   t-jeffro	added "tmc" to ListBoxData.
*/

/* Standard defines */
typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;

#define NULL	0
#define STATIC static
#define DLG_CONST				/* near templates */

/* Following is the minimum version number(major) of DOS that is needed to have
 * the shell to come up.
 */
#define MIN_MAJOR_VERSION 5

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <string.h>
#include <cwindows.h>
#include <csdm.h>
#include <csdmtmpl.h>

/* for unreferenced formals -- To avoid warnings from the compiler!! */
#define UnReferenced(x) ((void) x)

#if 1
TMC		FARPUBLIC TmcDoDlgAxAy(VOID *, HCAB, AX, AY);
#define TmcDoDlg(pdlg, hcab)	TmcDoDlgAxAy(pdlg, hcab,(AX) ((PDLG)pdlg)->crcDlg.x,(AY) ((PDLG)pdlg)->crcDlg.y)
#endif

#include <cgraphic.h>
#include <cddefcol.h>
#include <..\iniparse\parse.h>
#include <..\iniparse\symbols.h>
#include <listbox.h>

/**** GLOBALS ****/
extern	      MSG     msg;
extern	      INST    ginst;
extern	      INGD    gingd;
extern	      INDV    gindv;
extern	      BOOL    gisgraph;
extern	      INCH    cinch;
extern	      WND     MainWind;


extern BOOL gisgraph;
extern INST    ginst;
extern INCH    cinch;

extern ListBoxData TreeList[2];
extern ListBoxData FileList[2];

#define SMALLHEIGHT 13	    // How many pixels/char to	user big bitmaps

#define CHECKBOX_LEFTCHAR ((char) '[')
#define CHECKBOX_CHECKCHAR ((char) 'X')
#define CHECKBOX_RIGHTCHAR ((char) ']')


#define isaWhiteOnBlack 21
#define isaBlackOnWhite 22
#define isaTitlebar	23
#define isaDriveicon 24
#define isaDrivebox  25
#define isaSelect  26
#define isaBorders  27
#define isaHotLink  28
#define isaShellMouse  29
#define isaMessagebar  30


/* for exiting with loader */
#define VOODOOOFFSET  (2+2+2)
#define EXITPTROFFSET (0)

#define Shell_Beep() if (gBeeps_On) \
						Beep()
/* All Cancel buttons should map to tmcCancel so escape will work */
#define tmcgroupcancel	tmcCancel
#define tmcpaddcancel	tmcCancel
#define tmcassoccancel	tmcCancel
#define tmcassoc2cancel	tmcCancel
#define tmcattrcancel	tmcCancel
#define tmccopycancel	tmcCancel
#define tmccreatdircancel tmcCancel
#define tmcdelfilescancel tmcCancel
#define tmcdispcancel	  tmcCancel
#define tmcerrcancel	  tmcCancel
#define tmcfileoptscancel tmcCancel
#define tmclocatecancel   tmcCancel
#define tmcproccancel	  tmcCancel
#define tmcproccancel	  tmcCancel
#define tmcrenamecancel   tmcCancel
#define tmcshowinfocancel tmcCancel
#define tmcusercancel	  tmcCancel
#define tmccolor5nothing  tmcCancel
#define tmcpaddCB		  tmcCancel
#define tmcoutofmementer  tmcCancel
#define tmcpasswordCB	  tmcCancel
#define tmchelpEB		  tmcCancel
#define tmcrunCB		  tmcCancel
#define tmcnewCB		  tmcCancel
#define tmcuserCB		  tmcCancel
#define tmccolorcancel tmcCancel
#define tmcscreencancel tmcCancel

/* hid's for dialogs */

#define hidRUN			'A'
#define hidADDGROUP	    'B'
#define hidUSER 	    'C'
#define hidASSOCIAT	    'D'
#define hidATTR0	    'E'
#define hidMOVE 	    'F'
#define hidCREATDIR	    'G'
#define hidDELITEM		'H'
#define hidCRIT 		'I'
#define hidDELFILES	    'J'
#define hidDELGROUP	    'K'
#define hidDISPOPT	    'L'
#define hidERR		    'M'
#define hidFILEOPTS	    'N'
#define hidLOCATE	    'O'
#define hidOUTOFMEM	    'P'
#define hidPROG 	    'Q'
#define hidRENAME	    'R'
#define hidNEW			'S'
#define hidMOUSECONFIRM	'T'
#define hidDELETECONFIRM 'U'
#define hidREPLACECONFIRM 'V'
#define hidCOLOR	    'W'
#define hidSCREEN	    'X'
#define hidSHOWINFO	    'Y'
#define hidHELP 	    'Z'
#define hidPASSWORD	    '1'
#define hidADDDIAL	    '2'
#define hidADDPROG	    '3'
#define hidATTR 		'4'
#define hidASSOC2		'5'
#define hidABOUT		'6'
#define hidADDDIALO		'7'
#define hidADVANCED		'8'

/* These are for dialogs that get used for more than one thing */
#define hidCOPY			'9'
#define hidCHANGEGROUP	'0'
#define hidCHANGEPROG	':'

extern TMC gCurrentTMC;
extern char gErrHelpId ;

extern WORD gFocus ;
#define WhoHasGlobalFocus() (glob.FocusId)

typedef BYTE MyBOOL ;

#define MANIP_MOVE 1
#define MANIP_COPY 2
#define MANIP_RUN  3

/* Following is the data structure used by the screen mode manager to store
 * relevant information about acceptable screen modes for the adpater
 * on which we are running. "Res_Ordinal" is the one field that needs more
 * description: Suppose we had several modes within a given resolution, say
 * we had several HIGH res graphics modes (numlines > 50 in graphics mode),
 * the first one will be 1, the next 2, etc -- used to print the string in
 * the screen mode changing dialog's listbox!
 */	
struct S_Mode {
	BYTE	ModeInd ; 	/* The value of screen mode passed to set screen mode	*/
	BYTE	Res_Ordinal;/* Ordinal value within each resolution					*/
	BYTE	NumLines ;	/* Num. of screen lines supported in this screen mode	*/
	MyBOOL	fIsGraphicsMode ; /* Is this mode a graphics mode? */
} ;


/* Graphics definitions we need that are not defined in cgraphic.h */
#define CWIDTH	 ginst.inft.dxChar
#define CHEIGHT  ginst.inft.dyChar
typedef struct BITMAP
{
    char far *lrgb;
    WORD  cbRow;
    RECT rectBound;
}BITMAP;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\cddefcol.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	COW : Character Oriented Windows

	color.h : color info header file

*/

typedef struct _sa
	{
	union
		{
		struct
			{
			BYTE caMono;		/* initial B/W COLOR */
			BYTE caColor;		/* initial COLOR */
			} init;
		struct
			{
			BYTE bFiller;
			BYTE caSa;		/* the actual drawing ca */
			} draw;
		BYTE *rgcaFill;		/* special fill mode array */
		} u;
	} SA;		/* screen attribute */

typedef struct COLORTABLEENTRY
	{
	    ISA background;
	    ISA foreground;
	}COLORTABLEENTRY;


#define coBlack			0x0
#define coBlue			0x1
#define coGreen			0x2
#define coRed			0x4
#define coCyan			(coBlue + coGreen)
#define coMagenta		(coBlue + coRed)
#define coYellow		(coRed + coGreen)
#define coWhite			(coRed + coGreen + coBlue)


#define caMake(bg, fg, blink, hi) (fg | (blink << 7) | (bg << 4) | (hi << 3))

#define	caNull	   0	/* invalid ca */

#define	caBlackW	caMake(coWhite, coBlack, 0, 0)	/* Black on white */
#define	caBlue		caMake(coBlack, coBlue, 0, 0)
#define	caGreen		caMake(coBlack, coGreen, 0, 0)
#define	caRed		caMake(coBlack, coRed, 0, 0)
#define	caCyan		caMake(coBlack, coCyan, 0, 0)
#define	caMagenta	caMake(coBlack, coMagenta, 0, 0)
#define	caYellow	caMake(coBlack, coYellow, 0, 0)
#define	caWhite		caMake(coBlack, coWhite, 0, 0)
#define caBrightWhite	caMake(coBlack, coWhite, 0, 1)
#define caGrey		caMake(coBlack, coBlack, 0, 1)

#define isBright 8

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\csdm.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	CW : Character Windows

	csdm.h : SDM global exports
-- Created Fri Mar 23 11:33:58 1990 */ 

typedef WORD TMC;		/* iTeM Codes */
typedef WORD DLM;		/* Dialog Messages */
typedef WORD TMM;		/* Control proc Messages */

/* standard item codes (tmc) */
#define	tmcNull		((TMC) 0)
#define	tmcOK		((TMC) 1)
#define	tmcOk		tmcOK
#define	tmcCancel	((TMC) 2)
#define	tmcSysMin	((TMC) 0x10)
#ifdef HELP_BUTTON
#define tmcHelp 	((TMC) tmcSysMin-1)
#endif
#define	tmcSysMax	((TMC) 0x100)
#define	ftmcGrouped	0x8000		/* OR'd to specify whole group
					  as opposed to first button */
#define	tmcUserMin	tmcSysMax
#define	tmcUserMax	((TMC) ftmcGrouped)



/* special ninch (No Input, No CHange) values */
#define	wNinch		(-32767)	/* ints */
#define	uNinch		(0xffff)	/* unsigned */
#define	iszNinchList	uNinch		/* listboxes */
#define	uNinchList	uNinch		/* other name */
#define	uNinchRadio	uNinch		/* radio groups */
#define	uNinchCheck	2		/* check boxes */
#define	wNinchCheck	uNinchCheck	/* old name */

/* special parse error values */
#define	wError		(-32766)	/* ints */
#define	uError		(0xfffe)	/* unsigneds */


/* command argument block header */
typedef struct _cabh
	{
	WORD	cwData;			/* total size of CAB less CABH */
	WORD	cagHandle;		/* # of handles */
	} CABH;

typedef void **HCAB;		/* CAB is just a concept, no real type */
typedef	void *PCAB;		/* pointer to CAB */

typedef	struct _dlg *PDLG;	/* Dialog pointer */

/* minimum CAB size : header + SAB */
#define	cwCabMin	((sizeof(CABH) + sizeof(WORD)) / sizeof(WORD))

/* Dialog Messages */
#define	dlmInit 	0	/* do custom initialization */
#define	dlmClick	1	/* item clicked */
#define	dlmChange	2	/* edit control may have changed */
#define	dlmKey		3	/* any untrapped key */
#define	dlmDblClk	4	/* double click in listbox/radio */

#define	dlmSetFocus	5	/* set focus */
#define	dlmKillFocus	6	/* lose focus */

#define	dlmTerm 	7	/* termination request for one of many reasons */
#define	dlmIdle		8	/* idle for dialogs */

#define	dlmUnclick	9	/* item unclicked */

#define	dlmClientMouse	10	/* mouse click within dialog box */
#define	dlmNonClientMouse	11	/* mouse click outside dialog box */

#define	dlmSuspend	12	/* dialog suspended pending subdialog */
#define	dlmResume	13	/* dialog resumed */
#define	dlmRepaint	14
#define	dlmExit	15	/* the dialog is exiting (last dlm before termination) */

#define	dlmUserMin	16	/* for user extensions */


/* ListboxProc (pfnTm) messages */
#define	tmmCount	0	/* return number of items in listbox */
#define	tmmText 	1	/* return text associated with n'th item in listbox */
#define	tmmEditText	2	/* like msgText for Combo listboxes */

#define	cszUnknown	((WORD) -1)	/* return to tmmCount if unknown */

#define bNoArg		((WORD) -1)	/* put in bArg field if not used */

/* ParseProc (pfnTm) messages */
#define	tmmFormat	0	/* format data */
#define	tmmParse	1	/* parse data */
#define	tmmCwVal	2	/* return size of data in words */

/* RenderProc (pfnTm) messages */
#define	tmmPaint	0	/* paint yourself */


#define	tmmUserMin	16	/* for user extensions */

/* Control Procedure */
typedef WORD	(FARPUBLIC *PWFN_CTL)(WORD, char *, WORD, TMC, WORD, WORD);


/* default no help */
#define	hidDlgNull	0	/* for no help */


/* macro to get void pointer to general CAB arg */
#define	PvParseArg(hObj, bArg) ((VOID *) (*((WORD *)(hObj)) + (bArg)))


/* Iag macro
   returns iag corresponding to field fld in application structure str
*/
#define Iag(str, fld)	((WORD)((int)&(((str *)0)->fld) / sizeof(int) - cwCabMin))


/* Globally Exported Function Definitions */
#ifdef CC

#ifndef	NOPROCS
TMC		FARPUBLIC TmcDoDlg(VOID *, HCAB);
TMC		FARPUBLIC TmcDoDlgAxAy(VOID *, HCAB, AX, AY);	/*OPTIONAL*/
VOID		FARPUBLIC GetDlgArc(PDLG, PARC);		/*OPTIONAL*/
HCAB		FARPUBLIC HcabAlloc(WORD);
VOID		FARPUBLIC FreeCab(HCAB);
VOID		FARPUBLIC FreeCabData(HCAB);
VOID		FARPUBLIC SzToCab(HCAB, char *, WORD);
char *	FARPUBLIC SzFromCab(HCAB, char *, WORD, WORD);
VOID		FARPUBLIC PszToCab(HCAB, char **, WORD);	/*OPTIONAL*/

VOID		FARPUBLIC EnableTmc(TMC, BOOL);
BOOL		FARPUBLIC FEnabledTmc(TMC);
VOID		FARPUBLIC SetTmcVal(TMC, WORD);
WORD		FARPUBLIC GetTmcVal(TMC);
VOID		FARPUBLIC SetTmcSel(TMC, WORD, WORD);
VOID		FARPUBLIC GetTmcText(TMC, char *, WORD);
VOID		FARPUBLIC SetTmcText(TMC, char *);
VOID		FARPUBLIC SetFocusTmc(TMC);
VOID		FARPUBLIC RedisplayListBox(TMC);
VOID		FARPUBLIC RedisplayListBoxOriented(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC GetTmcListBoxOrientation(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC GetListBoxEntry(TMC, WORD, char *, WORD);	/*OPTIONAL*/
VOID		FARPUBLIC RedisplayTmc(TMC);
VOID		FARPUBLIC SetDefaultTmc(TMC);
VOID		FARPUBLIC SzFromInt(char *, int);
WORD		FARPUBLIC ParseInt(WORD, char *, HANDLE, TMC, WORD, WORD); /*OPTIONAL*/
VOID		FARPUBLIC SetTmcListWidth(TMC, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetTmcEditWidth(TMC, WORD);		/*OPTIONAL*/

VOID		FARPUBLIC InitCab(HCAB, WORD);
VOID		FARPUBLIC ReinitCab(HCAB, WORD);

PWND		FARPUBLIC PwndOfTmc(TMC);

TMC		FARPUBLIC TmcDoDlgExt(VOID *, HCAB, WORD, DWORD);	/* OPTIONAL */
#endif	/* !NOPROCS */

#endif /*CC*/

#define	PwndOfListbox(tmc)	PwndOfTmc(tmc)
#define	TmcListBoxResetcontent(tmc)	\
	SendMessage(PwndOfListbox(tmc), LB_RESETCONTENT, 0, 0L)
#define	TmcListBoxAddstring(tmc,isa,sz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_ADDSTRING, (WORD) sz, MAKELONG(fRedraw,isa))
#define	TmcListBoxInsertstring(tmc,isaT,szT,isz,fRedraw)	\
	{						\
	SZI	szi;					\
							\
	szi.sz = szT;					\
	szi.isa = isaT;					\
	SendMessage(PwndOfListbox(tmc), LB_INSERTSTRING,(WORD)&szi, MAKELONG(fRedraw,isz)); \
	}
#define	TmcListBoxDeletestring(tmc,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_DELETESTRING, 0, MAKELONG(fRedraw,isz))
#define	TmcListBoxReplacestring(tmc,isa,sz,isz)	\
	SendMessage(PwndOfListbox(tmc), LB_REPLACESTRING, (WORD) sz, MAKELONG(isa,isz))
#define TmcListBoxRepaint(tmc)	\
	SendMessage(PwndOfListbox(tmc), WM_PAINT, 0, 0L)
#define TmcGetClientRrc(tmc,prrc)	\
	GetClientRrc(PwndOfListbox(tmc), prrc)


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\edit.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#define MAXLINELENGTH 30

typedef struct editline
{
    struct editline far *next;
    BYTE length;
    char text[MAXLINELENGTH];
}editline;

typedef struct editstruct
{
    int curline;
    int curoffset;
    int numlines;
    int width;
    struct editline far *head;
}editstruct;


extern editstruct gEdit;
extern long Get_Num_Lines(editstruct *e);
extern BOOL InsertChar(editstruct *e,char c);
extern BOOL Get_Ith_Line(editstruct *e,char *dest,int ith,int len);
extern BOOL Init_EditStruct(editstruct *e,int width);
extern VOID InitEdit();
extern BOOL InsertLine(editstruct *e);
extern BOOL BackLine(editstruct *e);
extern BOOL ForwardLine(editstruct *e);
extern BOOL BackArrow(editstruct *e);
extern BOOL ForwardArrow(editstruct *e);
extern BOOL DeleteChar(editstruct *e);
extern BOOL DeleteLine(editstruct *e);
extern BOOL Home(editstruct *e);
extern BOOL End(editstruct *e);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\cwindows.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	CW : Character Windows
	cwindows.h

	CC should be defined for compilation with Cmerge.

    If defined, the following flags inhibit definition
      of the indicated constants.

    NOALL		Defines all the following:
    NOCOLOR		colors or ISA's
    NODRAW		drawing macros / constants
    NOMB		MB_* & ID's
    NOMEMMGR		LMEM_*
    NOMENUS		menus
    NOMINMAX		Macros min(a,b) and max(a,b)
    NOMSG		typedef MSG
    NOPROCS		procedure definitions (always for CS)
    NORECT		typedefs ARC, RRC
    NOSCROLL		SB_*
    NOSUBSTYLES		BS_*, LBS_*, ES_*
    NOSWAP		non-swapped version (currently only for small model)
    NOVIRTUALKEYCODES	VK_*
    NOWINMESSAGES	WM_*
    NOWINSTYLES		WS_*
    NOWND		WND / PWND typedef's or macros
    NOWNDMACROS		window creation macros

-- Created Fri Mar 23 11:33:10 1990 */ 

#ifdef NOALL
#define NOCOLOR
#define NODRAW
#define NOKEYSTATE
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMINMAX
#define NOMSG
#define NOPROCS
#define NORECT
#define NOSCROLL
#define NOSUBSTYLES
#define NOSWAP
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOWND
#define NOWNDMACROS
#endif /*NOALL*/


#ifdef OS2_INCLUDED
/* defined in OS2.H */
#undef	CHAR
#endif	/* OS2_INCLUDED */


#ifndef CC
/* -- Pcode Specific Definitions -- */
#ifndef EXPORT
#define	EXPORT	export
#endif
#ifndef NATIVE
#define	NATIVE	native
#endif
#else
/* -- Cmerge Compiler -- */
#ifndef CDECL
#define CDECL cdecl
#endif
#endif /*CC*/


#ifndef PASCAL
#define	PASCAL pascal
#endif

#define	FALSE	0
#define	TRUE	1
#define	NULL	0

#ifndef VAP_API
#define	FAR	far
#else
#define	FAR	near
#endif

#define	LONG	long
#define	VOID	void
#ifdef CC
#define	NEAR	near
#else
#define NEAR
#endif

#define FARPUBLIC	FAR PASCAL		/* all interfaces FAR */

#ifndef OS2_INCLUDED
/* defined in OS2.H */
typedef unsigned char	BYTE;
typedef int		BOOL;
typedef int	(FARPUBLIC *PFN)();		/* General Procedure */
#endif	/* !OS2_INCLUDED */

typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef BOOL	(FARPUBLIC *PFFN)();		/* BOOL Procedure */
typedef VOID	(FARPUBLIC *PVFN)();		/* Void Procedure */
typedef WORD	(FARPUBLIC *PWFN)();		/* Word Procedure */
typedef DWORD	(FARPUBLIC *PLFN)();		/* DWORD Procedure */
typedef VOID	(FARPUBLIC *LPFN)();		/* explicit FAR procedure */
typedef BYTE FAR *	(FARPUBLIC *LPFN_LPB)();
typedef WORD		HANDLE;
typedef unsigned	BIT;
typedef unsigned	BITS;

/* special type for WndProc pointers */
typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(struct _wnd *, WORD, WORD, DWORD);

/* BYTE/WORD types */
#ifndef CC	/* Pcode => WORD */
typedef WORD		AX;
typedef WORD		AY;
typedef WORD		RX;
typedef WORD		RY;
typedef WORD		ISA;
#else
typedef BYTE		AX;
typedef BYTE		AY;
typedef BYTE		RX;
typedef BYTE		RY;
typedef BYTE		ISA;
#endif /*CC*/

typedef	struct szi_
	{
	char *	sz;
	ISA	isa;
	} SZI;

typedef char FAR	*LPSTR;
typedef int  FAR	*LPINT;

#ifndef NOMINMAX
#define	max(a,b)	((a) > (b) ? (a) : (b))
#define	min(a,b)	((a) < (b) ? (a) : (b))
#endif

#ifndef OS2_INCLUDED
/* defined in OS2.H */
#define	MAKELONG(l, h)	((long)(((unsigned)(l)) | ((unsigned long)((unsigned)(h))) << 16))
#define	LOBYTE(w)	((BYTE) ((w) & 0xff))
#define	HIBYTE(w)	((BYTE)(((WORD)(w) >> 8) & 0xff))
#endif	/* !OS2_INCLUDED */

#define MAKEWORD(l, h)	((WORD)(((BYTE)(l)) | ((WORD)((BYTE)(h))) << 8))
#define	LOWORD(l)	((WORD)(l))
#define	HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xffff))

/* DCHAR = Double Byte Character */
typedef	WORD		DCHAR;
/* CHAR = unsigned char */
typedef unsigned char	CHAR;

/* ACHAR = either a DCHAR or a CHAR */
#ifdef KANJI
typedef	DCHAR		ACHAR;
extern BOOL PASCAL fKanaAccel;	/* set by application to choose accelerators */
#else
typedef	CHAR		ACHAR;
#endif

/*****************************************************************************/

#ifndef NORECT
typedef struct _rrc
	{
	BYTE	rxLeft;
	BYTE	ryTop;
	BYTE	rxRight;
	BYTE	ryBottom;
	} RRC;
typedef RRC *PRRC;
typedef struct _arc
	{
	BYTE	axLeft;
	BYTE	ayTop;
	BYTE	axRight;
	BYTE	ayBottom;
	} ARC;
typedef ARC *PARC;
typedef struct _box
	{
	char	chTopLeftCorner;
	char	chTopRightCorner;
	char	chBottomLeftCorner;
	char	chBottomRightCorner;
	char	chTopSide;
	char	chBottomSide;
	char	chLeftSide;
	char	chRightSide;
	} BOX;
extern BOX PASCAL boxSingle, PASCAL boxDouble;
extern BOX PASCAL boxActiveWnd;
extern BOX PASCAL boxInactiveWnd;
extern BYTE PASCAL axMac;
extern BYTE PASCAL ayMac;
/* all CW applications should work with screens up to 254x254 */
#define axMax 254
#define ayMax 254

#endif /*!NORECT*/

#ifndef NOWND

#ifndef cwExtraWnd
#ifdef CC
/* -- for CC compiler : fixed length */
#define cwExtraWnd 1 
#else
/* -- for CS compiler : variable length */
#define cwExtraWnd
#endif
#endif

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	ARC	arcWindow;
	ARC	arcClipping;
#ifndef REVIEW	/* size issue */
	RRC	rrcInvalid;			/* overlap update info */
#endif
	PLFN_WNDPROC pfnWndProc;		/* Medium Model */
	struct _wnd *pwndParent;
	struct _wnd *pwndSibling;
	struct _wnd *pwndChild;
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef NO_WNDEXTRA
	WORD	rgwExtra[cwExtraWnd];
#endif
	} WND;

#ifndef	REVIEW	/* size issue */ /* for wnd static window construction macros */
#define	rrcInvalidStd	{0, 0, 0, 0},
#else
#define	rrcInvalidStd
#endif

typedef WND *PWND;
#endif /*!NOWND*/


extern BYTE	PASCAL	fMousePresent;		/* valid after init */

#ifndef	NOPROCS

VOID		FARPUBLIC GetProgDir(char *);			/*OPTIONAL*/

BOOL		FARPUBLIC FInitCow(void);			/*OPTIONAL*/
VOID		FARPUBLIC LeaveCow(BOOL);			/*OPTIONAL*/
VOID		FARPUBLIC BackToCow(BOOL);			/*OPTIONAL*/
VOID		FARPUBLIC EndCow(BOOL);				/*OPTIONAL*/

/* Swapped Cow exit */
#ifndef	NOSWAP
#ifdef	CC
VOID		FAR CDECL exit(int);				/*OPTIONAL*/
#endif
#endif

#endif	/* NOPROCS */


/*** mcb - mouse cursor block */
typedef struct mcb
	{
	WORD	colHot;			/* Hot Spot for			     */
	WORD	rowHot;			/*   graphics mouse cursor.	     */
	WORD	rgwAndMaskGfx[16];	/* Bit map masks for		     */
	WORD	rgwXorMaskGfx[16];	/*   graphics mouse cursor.	     */
	WORD	wAndMaskText;		/* Character and Attribute masks for */
	WORD	wXorMaskText;		/*   text mouse cursor.		     */
	} MCB; 

/*** mcb - mouse conditional off block */
typedef struct mcob
	{
	WORD	xLeft;
	WORD	yTop;
	WORD	xRight;
	WORD	yBottom;
	} MCOB; 

/* Key state masks for mouse messages (in wParam) */
#define	MK_LBUTTON		0x0001
#define	MK_RBUTTON		0x0002
#define	MK_SHIFT		0x0004
#define	MK_CONTROL		0x0008
#define	MK_MBUTTON		0x0010
#define	MK_NONCLIENT		0x0060	/* either X or Y outside */
#define	MK_NONCLIENT_X		0x0020
#define	MK_NONCLIENT_Y		0x0040
#define	MK_MENU			0x8000

#ifndef	NOPROCS
BOOL		FARPUBLIC FEnableMouse(BOOL);
VOID		FARPUBLIC SetMouseCursor(MCB FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC MouseConditionalOff(PARC);		/*OPTIONAL*/
VOID		FARPUBLIC SetMousePos(WORD, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetMouseDoubleSpeed(WORD);		/*OPTIONAL*/
BOOL		FARPUBLIC SwapMouseButton(BOOL);		/*OPTIONAL*/
WORD		FARPUBLIC CbSizeMouseState(void);		/*OPTIONAL*/
VOID		FARPUBLIC SaveMouseState(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC RestoreMouseState(BYTE FAR *);	/*OPTIONAL*/
#endif	/* !NOPROCS */



typedef	struct _gheap {
	/* FGlobalHeapInfo */
	WORD	cpDataTotal;	/* Sum of all Data blocks */
	WORD	cpCodeTotal;	/* Sum of all Code blocks below fence */
	WORD	cpFreeTotal;	/* Size of all Free blocks below fence */
	WORD	cpFreeMac;	/* Size of largest Free below fence */
	WORD	cpReserve;	/* Size of codefence reserve area */
	} GHEAP;

extern BYTE PASCAL	fShellPresent;		/* DOS 3 : SHELL.EXE hook */

#ifndef	NOPROCS
HANDLE		FARPUBLIC GlobalAlloc(WORD, DWORD);		/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalFree(HANDLE);			/*OPTIONAL*/
LPSTR		FARPUBLIC GlobalLock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalHandle(HANDLE);			/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalReAlloc(HANDLE, DWORD, WORD);	/*OPTIONAL*/
BOOL		FARPUBLIC GlobalUnlock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalCompact(DWORD);			/*OPTIONAL*/

BOOL		FARPUBLIC FSetCodeReserve(WORD *); 		/*OPTIONAL*/
BOOL		FARPUBLIC FGlobalHeapInfo(GHEAP FAR *); 		/*OPTIONAL*/

DWORD		FARPUBLIC RerrExec(char *, char *, char *, BOOL, BOOL); /*OPTIONAL*/
								/*OPTIONAL*/
BYTE FAR *	FARPUBLIC LpbAppDataUnpack(void);		/*OPTIONAL*/
VOID		FARPUBLIC DosIdle(void);			/*OPTIONAL*/
VOID		FARPUBLIC BindSegment(PFN, BOOL);		/*OPTIONAL*/
VOID		FARPUBLIC AccessSwapFile(BOOL);			/*OPTIONAL*/
#endif	/* !NOPROCS */

/* GlobalAlloc flags */
#define GMEM_MOVEABLE	    0x0002
#define GMEM_ZEROINIT	    0x0040


/* rerr return values */

#define	rerrOk			0			/* must be zero! */

#define	rerrBadFile		2
#define	rerrBadPath		3
#define	rerrAccessDenied	5
#define	rerrNoMemory		8

#define	rerrBadEnv		10
#define	rerrBadFormat		11

#define	rerrBadRead		30

#define	rerrBadVersion		90
#define	rerrBadMemReq		91
#define	rerrMemUnstable		92
#define	rerrNoService		93
#define	rerrTSR			94

/* Key state masks for keyboard messages (in HIWORD(lParam)) */
#define	KK_EXTENDED		0x8000	/* from extended keypad usually */
/* shifts */
#define	KK_CAPLOCK		0x4000
#define	KK_NUMLOCK		0x2000
#define	KK_SCRLOCK		0x1000
#define	KK_ALT			0x0800
#define	KK_CONTROL		0x0400
#define	KK_SHIFT		0x0200

/* for WM_CHAR */
#define	KK_VK			0x01ff	/* mask to get untranslated VK_ */

/* for WM_KEYUP / WM_KEYDOWN */
#define	KK_SC			0x00ff	/* mask to get scan code */

#define KJ_SC			0xff00
#define KJ_KANA 		0x0080
#define KJ_OTHER		0x0040
#define KJ_KK			0x00b0
#define KJ_COUNT		0x003f

#define	abAbortNone	0
#define	abAbortESC	1
#define	abAbortBRK	2

extern BOOL PASCAL abAbort;			/* normal Abort */
extern BOOL PASCAL fPollKeyboard;		/* Poll the keyboard ? */
extern BYTE PASCAL fKeyIsUp, PASCAL fKeyWasUp;	/* Key transitions */
extern WORD PASCAL wRateKeyRepeat;		/* repeat rate */

#ifndef	NOPROCS
DWORD	FARPUBLIC EnableKeyboard(BOOL);
VOID	FARPUBLIC PollKeyboard(void);
VOID	FARPUBLIC PollPhysicalKeyboard(void);
VOID	FARPUBLIC SetShiftKk(WORD);
VOID	FARPUBLIC DisableExtendedKeyboard(void);
VOID	FARPUBLIC SetTsrProtocol(WORD, BYTE, BYTE);
#endif	/* !NOPROCS */

/*****************************************************************************/
/* Extra Font info */

typedef	struct _inft
	{
	/* character/font size */
	BYTE	dxChar;			/* width of character in pixels */
	BYTE	dyChar;			/* height of character in pixels */

	BYTE	dyBaseLine;		/* base line height */
	BYTE	ifont;			/* font index */
	} INFT;

typedef	struct _cib
	{
	/* CSD info block */
	WORD	flags;
	WORD	coImbue1;
	} CIB;

typedef	struct _cdi
	{
	/* CSD Default Information */
	WORD	cwcib;			/* length of rgw */
	CIB	cib;			/* info words */
	} CDI;


/*****************************************************************************/
/* font variations */

#ifdef KANJI
typedef	DWORD	FFONT;			/* 32 bit FFONT for Kanji */
#else
typedef	WORD	FFONT;			/* 16 bits normal FFONT */
#endif


#define	ffontNormal		0x0000	/* normal attributes */

#define	ffontUnderline		0x0001
#define	ffontDoubleUnderline	0x0002
#define	ffontOrUnderline	0x0003	/* ... underline */
#define	ffontStrikeThrough	0x0004	/* horizontal strike through */
#define	ffontBold		0x0008
#define	ffontSubscript		0x0010
#define	ffontSuperscript	0x0020
#define	ffontMiniCap		0x0030	/* mini capital */
#define	ffontItalic		0x0040
#define	ffontOrCharacter	0x0080	/* extra field => font extension */
#define	ffontReservedBits	0x0F00
#define	ffontExtraMask		0xf000	/* one of 16 extra items */
#define	ffontOrUnderlineSupport	0x1000

#ifdef KANJI
/* 32-bit ffont extension for Kanji support */
#define	ffontVgrid		0x000F0000
#define	ffontHgrid		0x00F00000
#define	ffontShadeType		0x03000000
#define	ffontDoubleWidth	0x04000000
#define	ffontDoubleHeight	0x08000000
#define	ffontDoubleRight	0x10000000
#define	ffontDoubleLower	0x20000000
#define	ffontDwLeft		(ffontDoubleWidth)
#define	ffontDwRight		(ffontDoubleWidth | ffontDoubleRight)
#define	ffontDhUpper		(ffontDoubleHeight)
#define	ffontDhLower		(ffontDoubleHeight | ffontDoubleLower)
#define	ffontReserved		0xC0000000
#endif /*KANJI*/


/* CSD flags */
#define	CSD_FORCERESET	0x0001	/* force the CSD to do a BIOS reset */
#define	CSD_SNOW		0x0002	/* use snow protection */

/*****************************************************************************/
/* Installable state */

typedef WORD	FINST;
#define	finstText		0x0001	/* text mode */
#define	finstGraphics		0x0002	/* graphics mode */
#define	finstMonochrome		0x0004	/* monochrome mode */
#define	finstAlternate		0x0008	/* alternate adapter (2nd screen) */
#define	finstFont		0x0010	/* supports fonts */
#define	finstAttrFont		0x0020	/* map Font calls into attribute info */
#define	finstExtendedMono	0x0040	/* EGA and VGA mono */
#define	finstGraphicArc		0x0080	/* Save/Restore Graphics Arc support */
#define	finstBltArcCsd		0x0100	/* Specific BltArcCsd available */
#define finstSizeable		0x0200	/* app can specify size when mode is
					   initialized */
#define	finstDisableMouse	0x1000	/* gfx w/o mouse support (hercules,os/2) */
#define	finstFastScroll		0x2000	/* fast scroll (BltArc) for gfx text */
#define	finstQuestionable	0x4000	/* questionable mode selection */
#define	finstAvailable		0x8000	/* available with current hardware */


typedef struct _inst
	{
	FINST	finst;
	BYTE	axMac;
	BYTE	ayMac;

	/* color palette info */
	BYTE	coMac;			/* maximum color index */
	BYTE	covMac;			/* maximum color value (palette) */
	WORD	coiMac;			/* maximum color intensity */

	/* Extra information */
	WORD	imode;			/* video mode */

	INFT	inft;			/* font info (pointers may be NULL) */
	WORD	ffontSupported;		/* valid ffont values */
					/* non-grid line styles */

	/* buffers (if non-zero then do not need to be allocated */
	WORD	psPrim;			/* primary screen buffer */
	WORD	psSec;			/* secondary screen buffer */

	WORD	cwExtra;		/* requested extra size */
	WORD	psExtra;		/* extra screen buffer (driver's use) */

	/* CW internal info */
	BIT	fAllocPrim:1;
	BITS	filler:15;

	/* Driver specific info */
	WORD	wDriver1;
	WORD	reserved2[7];
	} INST;

/* Special IMODEs */
#define	imodeUnknown	0xffff	/* unknown mode */

/*****************************************************************************/
/* Installable characters */

typedef struct _inch
	{
	/* Single Line Box */
	char	_chTopLeftCorner1;
	char	_chTopRightCorner1;
	char	_chBottomLeftCorner1;
	char	_chBottomRightCorner1;
	char	_chTopSide1;
	char	_chBottomSide1;
	char	_chLeftSide1;
	char	_chRightSide1;

	/* other single line */
	char	_chMiddleLeft1;
	char	_chMiddleRight1;

	/* Double Line Box */
	char	_chTopLeftCorner2;
	char	_chTopRightCorner2;
	char	_chBottomLeftCorner2;
	char	_chBottomRightCorner2;
	char	_chTopSide2;
	char	_chBottomSide2;
	char	_chLeftSide2;
	char	_chRightSide2;
	/*note: no middles */

	/* Arrows */
	char	_chUpArrow;
	char	_chDownArrow;
	char	_chLeftArrow;
	char	_chRightArrow;

	/* Misc */
	char	_chBullet;			/* for menu */
	char	_chMiddleDot;			/* for edit */
	char	_chScrollbar;			/* for scroll bar */
	char	_chElevator;			/* for scroll bar */
	char	_chShadowInit;			/* b&w shadow character */

	/* For Overlapping windows */
	char	_chClose;			/* Close box */
	char	_chZoomIn;			/* Zoom in */
	char	_chZoomOut;			/* Zoom out */
	char	_chUpDownArrow;			/* double arrow */
	char	_chLeftRightArrow;		/* double arrow */

	WORD	reserved[16];
	} INCH;

/*****************************************************************************/
/* screen save info */

typedef WORD	FVIDS;			/* flags */
#define	fvidsChAttr	1		/* video buffer is in form ch:attr */

typedef	struct _vids
	{
	BYTE	mode;			/* screen mode */
	BYTE	page;			/* page # */
	FVIDS	fvids;			/* flags for saved state */
	WORD	cwVidData;		/* # of bytes of screen data */
	WORD	cwExtra;		/* # of extra bytes for mode info */
	WORD	rgwExtra[1];		/* actually rgwExtra[cwExtra] */
	} VIDS;	/* Video state */

/*****************************************************************************/

#define	fmemFixed	1		/* always set !! */
#define	fmemNear	2		/* allocate near */

/* limit of near space / driver service */
#define	cbNearMemServiceMax	128

/* INDT: Driver Service Types */			/* Extension and Owner/Initiator */
#define	indtNil			0
#define	indtKeyboard		1			/* .KBD	CW */
#define	indtCharacterScreen	2			/* .CSD	CW */
#define	indtGraphicScreen	3			/* .GSD	CW */
#define	indtCharacterPrinter	4			/* .PRD	? */
#define	indtGraphicPrinter	5			/* .GPD	CW */
#define	indtSystem		6			/* .SYD	CW */
#define	indtSerialComm		7			/* .SCD	EBU */
#define	indtCellPrinter		8			/* .CPD	MSKK */
#define	indtMachineData		9			/* .MDD	MSKK */
#define	indtKkcInterface	10			/* .KID	MSKK */
#define	indtPseudoPrinter	11			/* .PPD MSKK */
/* ... others to be defined ... */

typedef struct _indv
	{
	/* input values */
	BYTE	indt;				/* service wanted */
	BYTE	filler;				/* reserved */
	LPFN *	rglpfn;				/* where to put vectors */
	WORD	cpfnNeedMin;			/* # entries needed */
	WORD	cpfnNeedMac;			/* # entries wanted */
	/* return values */
	WORD	psLoaded;			/* != 0 => loaded */
	WORD	cpfnLoaded;			/* # entries loaded */
	} INDV;

#ifndef	NOPROCS
WORD	FARPUBLIC RerrLoadDrv(char *, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrv(char *);		/* OPTIONAL */
WORD	FARPUBLIC RerrLoadDrvFd(WORD, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrvFd(WORD);		/* OPTIONAL */
VOID	FARPUBLIC FreeDrv(INDV *, WORD);		/* OPTIONAL */
VOID	FARPUBLIC FreeCwDrv(void);			/* OPTIONAL */
#endif	/* !NOPROCS */


extern INST PASCAL instCur;
extern INCH PASCAL inch;		/* near buffer for characters */
extern BOOL PASCAL fFontAvailable;	/* extra "ffont" drawing available ? */

/* name aliases for the actual characters */
#define	chTopSide1		(inch._chTopSide1)
#define	chBottomSide1		(inch._chBottomSide1)
#define	chLeftSide1		(inch._chLeftSide1)
#define	chRightSide1		(inch._chRightSide1)
#define	chTopLeftCorner1	(inch._chTopLeftCorner1)
#define	chTopRightCorner1	(inch._chTopRightCorner1)
#define	chBottomLeftCorner1	(inch._chBottomLeftCorner1)
#define	chBottomRightCorner1	(inch._chBottomRightCorner1)
#define chMiddleLeft1		(inch._chMiddleLeft1)
#define chMiddleRight1		(inch._chMiddleRight1)
#define	chTopSide2		(inch._chTopSide2)
#define	chBottomSide2		(inch._chBottomSide2)
#define	chLeftSide2			(inch._chLeftSide2)
#define	chRightSide2		(inch._chRightSide2)
#define	chTopLeftCorner2	(inch._chTopLeftCorner2)
#define	chTopRightCorner2	(inch._chTopRightCorner2)
#define	chBottomLeftCorner2	(inch._chBottomLeftCorner2)
#define	chBottomRightCorner2	(inch._chBottomRightCorner2)
#define	chUpArrow		(inch._chUpArrow)
#define	chDownArrow		(inch._chDownArrow)
#define	chRightArrow		(inch._chRightArrow)
#define	chLeftArrow		(inch._chLeftArrow)
#define	chBullet		(inch._chBullet)
#define	chMiddleDot		(inch._chMiddleDot)
#define	chScrollbar		(inch._chScrollbar)
#define	chElevator		(inch._chElevator)
#define	chShadowInit		(inch._chShadowInit)

/* for overlapping windows */
#define	chClose			(inch._chClose)
#define	chZoomIn		(inch._chZoomIn)
#define	chZoomOut		(inch._chZoomOut)
#define	chUpDownArrow		(inch._chUpDownArrow)
#define	chLeftRightArrow	(inch._chLeftRightArrow)

/*****************************************************************************/
/* Screen Procedures */

typedef WORD FAR *	(FAR PASCAL *LPFN_DRV_ALLOC)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_DRV_FREE)(WORD FAR *);

#ifndef	NOPROCS
WORD	FARPUBLIC ImodeGuessCurrent(void);			/*OPTIONAL*/
BOOL	FARPUBLIC FQueryInst(INST *, WORD);			/*OPTIONAL*/
BOOL	FARPUBLIC FAllocInstBuffers(INST *, LPFN_DRV_ALLOC, BOOL); /*OPTIONAL*/
VOID	FARPUBLIC FreeInstBuffers(INST *, LPFN_DRV_FREE);	/*OPTIONAL*/

BOOL	FARPUBLIC FAllocOverlapTable(INST *, LPFN_DRV_ALLOC);	/*OPTIONAL*/
VOID	FARPUBLIC FreeOverlapTable(LPFN_DRV_FREE);		/*OPTIONAL*/

BOOL	FARPUBLIC FInitScreen(INST *, WORD);				/*OPTIONAL*/
VOID	FARPUBLIC EndScreen(BOOL);				/*OPTIONAL*/

BOOL	FARPUBLIC FGetColorPalette(WORD, WORD *, WORD *);	/*OPTIONAL*/
VOID	FARPUBLIC SetColorPalette(WORD, WORD, WORD *);		/*OPTIONAL*/

VOID	FARPUBLIC MoveHwCursCsd(AX, AY, WORD);			/*OPTIONAL*/

BOOL	FARPUBLIC FQueryInft(INFT *, WORD);			/*OPTIONAL*/

WORD	FARPUBLIC CbSizeVids(void);				/*OPTIONAL*/
BOOL	FARPUBLIC FSaveVids(VIDS *, INST *);			/*OPTIONAL*/
BOOL	FARPUBLIC FRestoreVids(VIDS *);				/*OPTIONAL*/
VOID	FARPUBLIC SaveVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC RestoreVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC EnableVidsMonitor(BOOL);			/*OPTIONAL*/

VOID	FARPUBLIC GetCSDDefaultInfo(CDI *);			/*OPTIONAL*/
VOID	FARPUBLIC SetCSDDefaultInfo(CDI *);			/*OPTIONAL*/

#ifdef KANJI
VOID	FARPUBLIC GetCharMap(INFT *, WORD, BYTE *);
#else /*!KANJI*/
VOID	FARPUBLIC GetCharMap(INFT *, BYTE, BYTE *);
#endif /*KANJI*/
#endif	/* !NOPROCS */


WORD		FARPUBLIC MessageBox(char *, char *, char *, WORD);
WORD		FARPUBLIC MessageBoxAxAy(char *, char *, char *, WORD, AX, AY);
VOID		FARPUBLIC SetDialogCaption(HANDLE, char *);
VOID		FARPUBLIC HiliteDialogAccel(void);
BOOL		FARPUBLIC EndDlgTmc(WORD);

/* Message Box Definitions */

#ifndef NOMB
#define	IDDEFAULT		10
#define IDOK	  		1
#define IDCANCEL  		2
#define IDABORT   		3
#define IDRETRY   		4
#define IDIGNORE  		5
#define IDYES	  		6
#define IDNO	  		7
#ifdef	HELP_BUTTON
#define IDHELP			8
#endif	// HELP_BUTTON
#define	MB_OK			1
#define	MB_YESNOCANCEL		2
#define	MB_RETRYCANCEL		3
#define	MB_OKCANCEL		4
#define	MB_ABORT		5
#define MB_YESNO		6
#define MB_RETRY		7
#define	MB_TYPE			0x0f		/* message type */
#define MB_BEEP			0x10
#define MB_CAPTION		0x20		/* 1st param is caption */
#define	MB_BUTTON		0x0300	/* button mask */
#define	MB_DEFBUTTON1	0X0000	/* initial button to get focus */
#define	MB_DEFBUTTON2	0X0100
#define	MB_DEFBUTTON3	0X0200
#ifdef	HELP_BUTTON
#define	MB_DEFBUTTON4	0X0300
#define MB_NOHELP		0x8000
#endif	// HELP_BUTTON
#endif /*!NOMB*/

/* for Special MessageBox */
extern BYTE FAR * PASCAL lpbWorkTemp;	/* App should never use directly */

#define	InitSpecialMessageBox(lpbBuff)	\
	{				\
	Assert(lpbWorkTemp == NULL);	\
	lpbWorkTemp = (lpbBuff);	\
	}

#define	EndSpecialMessageBox()		\
	{				\
	Assert(lpbWorkTemp != NULL);	\
	lpbWorkTemp = NULL;		\
	}

/* so that rspAppIdle can determine where the current msg box dialog is */
extern PWND	pwndDlg;		/* Again, app should never use */

#define PwndDlgCur()		pwndDlg


#ifndef NOWNDMACROS

#ifndef	REVIEW	/* fBorder=True not support */
#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT, \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{ax, ay, ax+dax, ay+day}, \
	rrcInvalidStd	\
	(PLFN) InternalEditWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 cchMax}}
#else
#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT | (fBorder ? WS_BORDER : 0), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{((fBorder) ? ax+1 : ax), (fBorder ? ay+1 : ay), \
	 ((fBorder) ? ax+dax-1 : ax+dax), (fBorder ? ay+day-1 : ay+day)}, \
	rrcInvalidStd	\
	(PLFN) InternalEditWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 cchMax}}
#endif

/* InternalEditWndProc must be forward defined for CS compiler */
DWORD 		FARPUBLIC InternalEditWndProc(PWND, WORD, WORD, DWORD);

#endif /* !NOWNDMACROS */

/* for selection (SetTmcSel) */
#define	ichSelectEnd	(0x7fff)		/* select to end */


VOID		FARPUBLIC SetEditText(PWND, char *, BOOL);
VOID		FARPUBLIC SetEditWidth(PWND, WORD);	/* OPTIONAL */
WORD		FARPUBLIC GetEditText(PWND, char *, WORD);
DWORD		FARPUBLIC EditWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC DefaultEditMgrInit(VOID);	/* OPTIONAL */

#define EN_CHANGE			0x0300
#define EN_CURSORMOVED			0x0301


#ifndef NOMSG
/* Message structure */
typedef struct _msg
	{
	PWND	pwnd;
	WORD	message;
	WORD	wParam;
	DWORD	lParam;
	DWORD	time;
	} MSG;

typedef MSG *PMSG;

#ifndef	OS2_INCLUDED
#define	HSEM	DWORD
#endif	/* !OS_INCLUDED */

#ifndef OS2
extern BOOL PASCAL fMessage;
#ifdef DUAL
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((HSEM) (DWORD FAR *) &semaMessage)
#endif /*DUAL*/
#else
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((HSEM) (DWORD FAR *) &semaMessage)
#endif
#endif /*!NOMSG*/

typedef BOOL (FARPUBLIC *PBFN_KBDMSG)(WORD, WORD, DWORD);

#ifndef NOWINMESSAGES
/* Window Messages */
#define	WM_NULL			0x0000
#define	WM_CREATE		0x0001
#define	WM_WANTFOCUS		0x1005
#define	WM_MAKEACTIVE		0x1006
#define	WM_SETFOCUS		0x0007
#define	WM_KILLFOCUS		0x0008
#define	WM_REPAINT		0x100e
#define	WM_PAINT		0x000f
#define	WM_QUIT			0x0012

#define	repModeReset	0		/* handled by RepaintScreen */
#define	repRedraw		1		/* handled by RepaintScreen */    
#define	repGraphic	2		/* app should redraw GSD graphic */

/* Non-client (for Overlap only) */
#define	WM_NCLBUTTONDOWN	0x00a1

#define	WM_KEYFIRST		0x0100
#define WM_KEYLAST		0x0102

#define	WM_KEYDOWN		0x0100
#define	WM_KEYUP		0x0101
#define	WM_CHAR			0x0102

#define	WM_CUT			0x0300

#define	WM_COPY			0x0301
#define	WM_PASTE		0x0302
#define	WM_INSERT		0x1303

#define	WM_MENUIDLE		0x1110		/* Menu Idle */
#define	WM_MENUINACTIVE		0x1111		/* Menu inactive */
#define	WM_COMMAND		0x0111
#define	WM_MENUSELECT		0x0112		/* selecting a menu item */
#define	WM_MENUSTART		0x0113		/* starting a menu action */
#define	WM_HSCROLL		0x0114
#define	WM_VSCROLL		0x0115
#define	WM_INITMENUPOPUP	0x0117
#define	WM_ALARM		0x1118
#define WM_DISABLEDCOMMAND	0x0119

#define WM_MESSAGEBOX_START	0x0120
#define WM_MESSAGEBOX_END	0x0121

#define	WM_MOUSEFIRST		0x0200
#define	WM_LMOUSELAST		0x0203	/* last of Left mouse actions */
#define	WM_MOUSELAST		0x0209

#define	WM_MOUSEMOVE		0x0200	/* mouse related constants */
#define	WM_LBUTTONDOWN		0x0201
#define	WM_LBUTTONUP		0x0202
#define	WM_LBUTTONDBLCLK	0x0203
#define	WM_RBUTTONDOWN		0x0204
#define	WM_RBUTTONUP		0x0205
#define	WM_RBUTTONDBLCLK	0x0206

/* Edit Wnd Proc Messages */
#define EM_SETSEL		0x0400
#define EM_GETSEL		0x0401

/* Debugging Message */
#define WM_TRACEOUT		0x0500
#define WM_TRACETAG_REGISTER	0x0501

/* Overlap Wnd Proc Messages */
#define WM_ACTIVATE		0x0006
#define WM_ZOOM			0x0321
#define WM_CLOSE		0x0010
#define WM_MOVE			0x0003
#define WM_SIZE			0x0005


/* WM_ACTIVATE response codes */
#define	rspActiveLive		((DWORD) 2)	/* pass activating event on */
#define	rspActive			((DWORD) 1)	/* eat activating event */
#define	rspActiveDecline	((DWORD) 0)	/* [de]activation declined */


/* Dialog related messages */
#define WM_DIALOGINACTIVE	0x0360

/*WM-DIALOG is actually private (and LB_SETWIDTH)*/
#define WM_DIALOG		0x0380

#define WM_DIALOGIDLE 0x0382

/* Listbox Proc Messages */
#define WM_LISTBOX_COMMAND	WM_DIALOG
#define LB_RESETCONTENT		0x0340
#define LB_ADDSTRING		0x0341
#define LB_DELETESTRING		0x0342
#define LB_SETCURSEL		0x0343
#define LB_GETCURSEL		0x0344
#ifdef LISTBOX_HORIZ
#define LB_SETWIDTH		0x0345
#endif /*LISTBOX_HORIZ*/
#define LB_GETTEXT		0x0346
#define LB_GETCOUNT		0x0347
#define LB_REPLACESTRING	0x0348
#define LB_INSERTSTRING		0x0349
#define LB_HILITECURSEL		0x0350

/* VAP Request for application to handle */
#define WM_VAP_REQUEST		0x0390

/* Kkc converter message for application to handle */
#define	WM_KKCONVERT	0x03f0

#define	WM_KKENABLE	0x03f7
#define	WM_KKDISABLE	0x03f8

/* private window messages start here */
#define	WM_USER			0x0400
#endif

/* Window's aliases for KK_ states */
#define	KK_MENU			KK_ALT
#define	KK_CAPITAL		KK_CAPLOCK

/* HELP */
#define	VK_HELP_KEY		VK_F1

/* listbox notification codes */
#define LBN_SELCHANGE		0
#define LBN_DBLCLK		1
#define LBN_SELECT_DONE		2


/* List Box Selection Codes */
#define lbrCause		0xf
#define lbrNone			0
#define lbrMouse		1
#define lbrScroll		2
#define lbrKeys			3
#define lbrSpace		4
#define lbrOther		5
#define flbrReselect		0x10


/* help types/contexts */
#define	hemMenu			1
#define	hemMenuItem		2
#define	hemMbox			3
#define	hemDialog		4
#define	hemUserMin		0x10		/* For Application contexts */

/* help id's for message boxes */
#ifndef NOMB
#define	hidMboxOk		MB_OK
#define	hidMboxYesNoCancel	MB_YESNOCANCEL
#define	hidMboxRetryCancel	MB_RETRYCANCEL
#define	hidMboxOkCancel		MB_OKCANCEL
#define	hidMboxAbort		MB_ABORT
#define hidMboxYesNo		MB_YESNO
#define hidMboxRetry		MB_RETRY
#endif /*!NOMB*/

VOID		FARPUBLIC SetAlarm(PWND, WORD);
VOID		FARPUBLIC KillAlarm(void);
#ifndef REVIEW /* should UndoRepeat be exported? */
VOID		FARPUBLIC UndoRepeat(WORD, DWORD);
#endif
VOID		FARPUBLIC UngetMessage(PMSG);
BOOL		FARPUBLIC PeekMessage(PMSG);
BOOL		FARPUBLIC FNextMsg(PMSG);
PWND		FARPUBLIC GetFocus(void);
PWND		FARPUBLIC SetFocus(PWND);
VOID		FARPUBLIC FlushAbort(void);
PWND		FARPUBLIC SetCapture(PWND);
VOID			FARPUBLIC ReleaseCapture(void);
DWORD		FARPUBLIC DispatchMessage(PMSG);
BOOL		FARPUBLIC PostMessage(PWND, WORD, WORD, DWORD);
DWORD		FARPUBLIC SendMessage(PWND, WORD, WORD, DWORD);
WORD		FARPUBLIC SetDoubleClickTime(WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SynthesizeShiftKeys(WORD, WORD);	/*OPTIONAL*/
VOID		FARPUBLIC HookKeyboardMessage(BOOL, PBFN_KBDMSG);
VOID		FARPUBLIC HookKeyboardPoll(BOOL, LPFN);
BOOL		FARPUBLIC InsertKeyboardMessage(WORD, WORD, DWORD);
WORD		FARPUBLIC CmsgKeyboardQueueEntry(WORD, PMSG);

#ifndef NOCOLOR

/*	* General colors */
#define	isaNil			((ISA) -1)

#define	isaBackground		0

#define	isaHilite		1		/* hilite / inversion */
#define	isaGreyed		2		/* not currently used */
#define	isaEnabled		3
#define	isaDisabled		4
#define	isaAlert		5

/*	* Dialog elements :	*/
#define	isaDialogBox		6	/* the actual dialog box */
#define	isaStatic		isaDialogBox	/* static text */
#define	isaButton		isaDialogBox	/* radio/check buttons */
#define	isaPushButton		7		/* push buttons */
#define	isaButtonDown		8		/* pushed button */
#define	isaListBox		9		/* listbox background */
#define	isaEdit			isaDialogBox

/*	* Scroll Bars :		*/
#define	isaScrollbar		10
#define	isaElevator		11

/*	* Menus :		*/
#define	isaMenuBox		12		/* box around pull downs */
#define	isaMenu			13		/* non-selected MENU */
#define	isaMenuSelected		14		/* selected menu item */
#define	isaMenuHilite		15		/* hilited character */
/* hilited character under selection */
#define	isaMenuHiliteSel	16		/* for menu titles */
#define	isaItemHiliteSel	17		/* for menu items */

#define	isaDialogAccel		18		/* dialog accelerators */
#define	isaDialogAccelBor	19		/* dialog accelerator border */

/*	* Shadows :		*/
#define	isaShadow		20

/* User Colors :		*/
#define	isaUserMin		21
#define	isaUserMax		(isaUserMin+16)
#define	isaMax			isaUserMax

#ifdef KANJI
#define	ffontNil	((FFONT)0L)
#else
#define	ffontNil	((FFONT)0)
#endif	/*KANJI*/

#endif /*!NOCOLOR*/

#ifndef NOMENUS
/* hack for nameless unions in CC */
#ifdef CC
#define CC_USZ u
#define CC_URG u
#define cwExtraMenu 1
#else
#define CC_USZ
#define CC_URG
#define cwExtraMenu 0
#endif

/* Menu Modes : HIWORD(lParam) for WM_COMMAND / WM_MENUSELECT messages */
#define	mmdItem		0		/* dropdown item */
#define	mmdAccel	1		/* keyboard accelerator */
#define	mmdMenu		2		/* dropdown not item */
#define mmdString	3		/* WM_MENUSELECT contains string */

/* Help Line codes for wParam WM_MENUSELECT (lParam == 0) */
#define	enClear		0		/* clear must be zero */
#define	enCommand	1		/* prepare help line for command */


typedef struct _mpvkeyid
	{
	WORD	vkey;
	WORD	idItem;
	} MPVKEYID;
#define VkeyOfVkKk(vk, kk)	((vk) | (kk))

#ifndef SMM			/* Old menu structures */

typedef struct _menuitem
	{
	WORD	idItem;			/* id for menuitem */
	BITS	fEnabled:1;		/* TRUE => enabled, FALSE => greyed */
	BITS	fChecked:1;		/* TRUE => checked */
	BITS	fSeparator:1;		/* TRUE => separator */
	BITS	fHandle:1;		/* TRUE => use pszItem, else szItem */
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	bParamUser:8;		/* available for application use */
	union
		{
		char *szItem;
		char **pszItem;
		} CC_USZ;
	WORD	wParamUser;		/* available for application use */
#ifdef KANJI
	WORD	chKanaAccel;		/* Kana Accelerators */
#endif /*KANJI*/
	} MENUITEM;
typedef struct _menu
	{
	WORD	idMenu;
	BITS	rxTitle:8;
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	fHandle:1;
	BITS	fEnabled:1;		/* is menu 'enabled' (not greyed) */
	BITS	filler:2;
	WORD	cchTitle;
	char	*pchTitle;
	WORD	citem;
	WORD	cchitemMax;
	union
		{
		MENUITEM *rgmenuitem;
		MENUITEM **prgmenuitem;
		} CC_URG;
	WORD	wParamUser;		/* available for application use */
#ifdef KANJI
	WORD	chKanaAccel;		/* Kana Accelerators */
#endif /*KANJI*/
	} MENU;
typedef struct _menubar
	{
	WORD	cmenu;
	MENU	*rgmenu;
	MPVKEYID *rgmpvkeyid;
	} MENUBAR;

typedef MENU *PMENU;
typedef MENUITEM *PMENUITEM;
typedef MENUBAR *PMENUBAR;

/* menu item define macros :
	D => disabled
	H => string handle
	X => with index (otherwise default to 0)
*/

#ifndef KANJI
/* enabled simple item */
#define menuitem(mid, sz, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemD(mid, sz, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemDH(mid, psz, w) {(mid), FALSE, FALSE, FALSE, TRUE,\
	0, 0, {(char *)(psz)}, (WORD)(w)},
#define menuitemX(mid, sz, ich, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
#define menuitemDX(mid, sz, ich, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
/* separator */
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0},

#else	/* KANJI - 1 extra value needed for Kana Accelerator */
	/* Accelerator should always be at start */

#define menuitem(mid, sz, chKana, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},
#define menuitemD(mid, sz, chKana, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0, 0},

#endif /*KANJI*/

#else // SMM			/* New menu structures */

typedef struct _mtm
	{
	WORD	id;
	BYTE	bFlags;
/*	BITS	fDisabled:1;
	BITS	fChecked:1;
	BITS	fSeparator:1;
	BITS	fString:1;
	BITS	fHelp:1;
	BITS	fMenuBreak:1;
	BITS	fSubMenu:1;
	BITS	filler:1;	*/
	BYTE	cwTotal;
	union
		{
		WORD	sid;
		WORD	iwString;
		} CC_USZ;
	WORD	rgwExtra[cwExtraMenu];
	} MTM, *PMTM;

typedef struct _mnu
	{
	struct _mnu **hmnuNext;
	WORD	cmtm;
	struct _mtm grmtm;
	} MNU, **HMNU;

#define MM_DISABLED	0x01
#define MM_CHECKED	0x02
#define MM_SEPARATOR	0x04
#define MM_STRING	0x08
#define MM_HELP		0x10
#define MM_MENUBREAK	0x20
#define MM_SUBMENU	0x40

/* defaults: */

#define MM_ENABLED	0
#define MM_UNCHECKED	0
#define MM_SID		0

/* special ID#'s */

#define idNil		((WORD) 0)
#define idSysMenu	((WORD) -1)

#define cbMTM (sizeof(MTM)-cwExtraMenu*sizeof(WORD))
#define cwMTM (cbMTM/sizeof(WORD))
#define cbMNU (sizeof(MNU)-sizeof(MTM))

#define HmnuFromPmtm(pmtm) ((HMNU) pmtm->rgwExtra[pmtm->cwTotal-1])
#define SzFromPmtm(pmtm) ((CHAR *) &(pmtm->rgwExtra[pmtm->u.iwString]))

#endif // SMM

#endif /*!NOMENUS*/

#ifndef	NOPROCS
BOOL		FARPUBLIC FEnableMenuBar(BOOL);
VOID		FARPUBLIC EnableMenuItem(WORD, BOOL);
VOID		FARPUBLIC CheckMenuItem(WORD, BOOL);
BOOL		FARPUBLIC FMenuItemChecked(WORD);
VOID		FARPUBLIC DrawMenubar(VOID);
VOID		FARPUBLIC SetMenuKeys(WORD, WORD);	/*OPTIONAL*/
VOID		FARPUBLIC OpenMenu(WORD);		/*OPTIONAL*/
VOID		FARPUBLIC DeAltMenu(VOID);		/*MACROS ONLY*/

#ifndef SMM			/* Old functions */

VOID		FARPUBLIC InitMenu(PWND, PMENUBAR);
PMENUITEM	FARPUBLIC FindMenuItem(WORD);
VOID		FARPUBLIC EnableMenu(WORD, BOOL);

#else // SMM

				/* Replacements for above */
VOID		FARPUBLIC InitMenubar(PWND, HMNU, PARC, WORD);	/*OPTIONAL*/
PMTM		FARPUBLIC PmtmFindId(HMNU, WORD, BOOL); 	/*OPTIONAL*/

				/* New functions */

VOID		FARPUBLIC OpenMenuPopup(PWND, HMNU, PARC, BOOL);	/*OPTIONAL*/
HMNU            FARPUBLIC HmnuNewMenu(void);            /*OPTIONAL*/
PMTM		FARPUBLIC PmtmAddItem(HMNU, WORD, WORD, CHAR *, HMNU, WORD, BYTE);	/*OPTIONAL*/
VOID		FARPUBLIC DeleteItem(HMNU, WORD);	/*OPTIONAL*/
VOID            FARPUBLIC DeleteMenu(HMNU, BOOL);       /*OPTIONAL*/
WORD            FARPUBLIC CchGetMenuString(HMNU, WORD, CHAR *, WORD); /*OPTIONAL*/
VOID		FARPUBLIC AddAccelTable(MPVKEYID **);	/*OPTIONAL*/
VOID		FARPUBLIC DeleteAccelTable(MPVKEYID **);	/*OPTIONAL*/

#endif // SMM

#endif	/* !NOPROCS */


#ifndef NOCOLOR
#define	DiMake(dm, isa)		((WORD) ((dm) | (isa)))

/*	-- non-special modes --	*/
#define	dmNormal		0
#define	DiNormal(isa)		((WORD) dmNormal | (isa))
#define	dmText			0x100
#define	dmTextOnly		dmText
#define	dmForeBack		0x200
#define	dmAttrOnly		dmForeBack
#define	dmFore			0x300
#define	dmBack			0x400
#define	dmTextFore		0x500
#define	dmTextBack		0x600

/*	-- special modes --	*/
#define	dmSpecialMin		0x700
#define	dmTextMapB		0x700
#define	dmTextMapF		0x800
#define	dmMapB			0x900
#define	dmMapF			0xA00

#define	dmFfontOnly		0xB00

/* special FFONT control */
#define	fdmKeepFfont	0x8000

#ifdef 	KANJI

/* kanji gridline support */
#define	dmGridOnly		0xC00
#define	fdmKeepGrid		0x4000

#endif	/*KANJI*/

#endif /*!NOCOLOR*/

extern BYTE PASCAL fMonochrome;		/* TRUE => monochrome screen */
extern char PASCAL chShadow;		/* shadow character */
extern WORD PASCAL diShadow;		/* shadow draw mode, 0 => no shadow */

#ifndef	NOPROCS
VOID		FARPUBLIC SetCursorBlock(BOOL);
VOID		FARPUBLIC SetCursorBlink(BOOL);
VOID		FARPUBLIC RepaintScreen(BOOL);
#endif	/* !NOPROCS */

VOID		FARPUBLIC SetGraphicArc(PARC, BOOL);


#ifndef NOSUBSTYLES
/* Scroll bar constants */
#define	SBS_HORZ			0
#define	SBS_VERT			1
#endif /*!NOSTYLES*/


#ifndef NOSCROLL

/* Scroll Commands */
#define	SB_LINEUP		0
#define	SB_LINEDOWN		1
#define	SB_PAGEUP		2
#define	SB_PAGEDOWN		3
#define	SB_THUMBPOSITION	4
#define	SB_THUMBTRACK		5
#define	SB_TOP			6
#define	SB_BOTTOM		7
#define SB_ENDSCROLL		8
/* define SB_UPCLICK 15 (private message) */
#endif /*!NOSCROLL*/


#ifndef NOWNDMACROS

DWORD		FARPUBLIC ScrollBarWndProc(PWND, WORD, WORD, DWORD);

#ifdef CC
#ifndef cwExtraWnd
#define cwExtraWnd 5
#endif /*no extra size*/
#endif /*CC*/
#define wndScrollBar(id, fVert, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, ctickRep) { \
	id, WS_CHILD | WS_SCROLL | (fVert ? SBS_VERT : SBS_HORZ), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, {ax, ay, ax+dax, ay+day}, \
	rrcInvalidStd	\
	(PLFN) ScrollBarWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{ctickRep, 0, 0, 1, 1}}

#endif /* !NOWNDMACROS */

#ifndef	NOPROCS
short		FARPUBLIC SetScrollPos(PWND, short, BOOL);
short		FARPUBLIC GetScrollPos(PWND);
VOID		FARPUBLIC SetScrollRange(PWND, short, short, BOOL);
#endif	/* !NOPROCS */


#ifndef	NOPROCS
VOID		FARPUBLIC AddChild(PWND, PWND);
VOID		FARPUBLIC RemoveChild(PWND);
VOID		FARPUBLIC EnableWindow(PWND, BOOL);
VOID		FARPUBLIC GetClientRrc(PWND, RRC *);
VOID		FARPUBLIC SetWindowStyle(PWND, WORD);
VOID		FARPUBLIC SetWindowSize(PWND, BYTE, BYTE);
VOID		FARPUBLIC DrawWindow(PWND);
VOID		FARPUBLIC TextOut(PWND, RX, RY, char *, short, WORD);
VOID		FARPUBLIC DrawBorder2(PWND, BOX *, WORD, WORD, char *);
VOID		FARPUBLIC DrawBorderAlign(PWND, BOX *, WORD, WORD, char *, BOOL);
VOID		FARPUBLIC CharOut(PWND, RX, RY, ACHAR, WORD);
VOID		FARPUBLIC CharOutBorder(PWND, RX, RY, ACHAR, WORD);
VOID		FARPUBLIC FillRrc(PWND, PRRC, ACHAR, WORD);
VOID		FARPUBLIC BltRrc(PWND, RX, RY, BYTE, BYTE, RX, RY);
VOID		FARPUBLIC BltRrcTop(PWND, RX, RY, BYTE, BYTE, RX, RY);	/*OPTIONAL*/
VOID		FARPUBLIC BeginPaint(PWND, VOID FAR *);
VOID		FARPUBLIC EndPaint(PWND, VOID FAR *);
VOID		FARPUBLIC DrawBox(PWND, PRRC, BOX *, WORD);
VOID		FARPUBLIC SaveRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC RestoreRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC EnableCursor(PWND, BOOL);
VOID		FARPUBLIC MoveCursor(PWND, RX, RY);
VOID		FARPUBLIC MoveWindow(PWND, AX, AY);
BOOL		FARPUBLIC IntersectRect(PRRC, PRRC, PRRC);
VOID		FARPUBLIC UnionRect(PRRC, PRRC, PRRC);
BOOL		FARPUBLIC IsRectEmpty(PRRC);
VOID		FARPUBLIC SetRect(PRRC, RX, RY, RX, RY);
BOOL		FARPUBLIC PtInRect(PRRC, RX, RY);
WORD		FARPUBLIC CwSizeRrc(PRRC);
VOID		FARPUBLIC ShadowArc(PARC);
/*	* for overlap windows */
VOID		FARPUBLIC EnableOverlap(BOOL, PWND, WORD);			/*OPTIONAL*/
VOID		FARPUBLIC AddChildHead(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC AddChildTail(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC RethinkDisplay(void);			/*OPTIONAL*/
VOID		FARPUBLIC WindowToTop(PWND);            	/*OPTIONAL*/
VOID		FARPUBLIC RedrawDamagedRegions(void);		/*OPTIONAL*/
VOID		FARPUBLIC InvalidateRrc(PWND,PRRC);		/*OPTIONAL*/
BOOL		FARPUBLIC FMoveSizeWithKeyboard(PWND, BOOL);	/*OPTIONAL*/
BOOL		FARPUBLIC FIsTopWindow(PWND);			/*OPTIONAL*/
PWND		FARPUBLIC PwndGetTopWindow(PWND);		/*OPTIONAL*/
VOID		FARPUBLIC DrawOverlapShadow(PWND);		/*OPTIONAL*/
VOID		FARPUBLIC MoveSizeOverlap(PWND, AX, AY, BYTE, BYTE); /*OPTIONAL*/
/*	Listbox routines */
DWORD		FARPUBLIC ListBoxWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC InitListBox(PWND, PWFN);		/*OPTIONAL*/
VOID		FARPUBLIC InitListBoxOriented(PWND, PWFN, WORD *, WORD *);/*OPTIONAL*/
VOID		FARPUBLIC GetListBoxOrientation(PWND, WORD *, WORD *);/*OPTIONAL*/
/*	Dropdown Listbox routines */
DWORD		FARPUBLIC DropDownWndProc(PWND, WORD, WORD, DWORD);	/*OPTIONAL*/
DWORD		FARPUBLIC DropHolderWndProc(PWND, WORD, WORD, DWORD);	/*OPTIONAL*/
DWORD		FARPUBLIC DropListBoxWndProc(PWND, WORD, WORD, DWORD);	/*OPTIONAL*/
DWORD		FARPUBLIC DropEditWndProc(PWND, WORD, WORD, DWORD);	/*OPTIONAL*/
DWORD		FARPUBLIC DropButtonWndProc(PWND, WORD, WORD, DWORD);	/*OPTIONAL*/
VOID		FARPUBLIC AddDropWindow(PWND, PWND, PWND, PWND, PWND, PWND, BOOL); /*OPTIONAL*/
VOID		FARPUBLIC RemoveDropWindow(PWND);			/*OPTIONAL*/
#endif	/* !NOPROCS */

#define	OV_NOSHADOW	0x0001

#define	axNil	255
#define	ayNil	255
#define	rxNil	255
#define	ryNil	255

#define FMoveOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,TRUE);
#define FSizeOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,FALSE);
#define MoveWindowOverlap(pwnd, ax, ay) MoveSizeOverlap(pwnd, ax, ay, rxNil, ryNil)
#define SizeWindowOverlap(pwnd, drx, dry) MoveSizeOverlap(pwnd, axNil, ayNil, drx, dry)
#define CloseWindowOverlap(pwnd) MoveSizeOverlap(pwnd, axNil, ayNil, rxNil, ryNil)
#define DrawBorder(pwnd, pbox, di, sz)	DrawBorder2(pwnd, pbox, di, di, sz)

#ifndef NORECT
#define CopyRect(prrcDest, prrcSrc) {*(prrcDest) = *(prrcSrc) }
#define SetRectEmpty(prrc) {*((long *) prrc) = 0; }
#endif /*!NORECT*/


#ifndef NOWNDMACROS

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0,

#define wndGenericCursor(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs) { \
	id, style, TRUE, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs,
		
#define endWndGeneric }

#define wndListBox(id,fBorder,fSorted,fEnabled,ax,ay,dax,day,pfnWndProc,pwndParent,pwndSibling,pwndChild,color,isaHilite,ctickRep) { \
	id, (WS_CHILD | WS_LISTBOX | WS_VSCROLL | \
             (fSorted ? LBS_SORT : 0) | (fBorder ? WS_BORDER : 0)), \
	TRUE, fEnabled, {ax, ay, ax+dax, ay+day},                   \
	{ (fBorder ? ax+1 : ax),                                    \
	  (fBorder ? ay+1 : ay),                                    \
	  ((TRUE)  ? ax+dax-1 : ax+dax),                      \
	  (fBorder ? ay+day-1 : ay+day)     }, \
	rrcInvalidStd	\
	(PLFN) pfnWndProc, pwndParent, pwndSibling,      \
	pwndChild, \
        (fBorder ? ax+2 : ax+1), 1 \
 	,{0,0,0,0,0,0,0,0,0,0,1,0,0,color,isaHilite,ctickRep,0} }

#define wndDropDown(id,fEnabled,fCombo) { \
	id, (WS_CHILD | WS_CLIPOUT), FALSE, TRUE, \
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) DropDownWndProc, NULL, NULL, NULL, 0, 0, \
	{ 0, (fCombo ? 1 : 0), NULL, NULL, NULL, NULL, \
		NULL, NULL, NULL, NULL } }

#define wndDropDownButton(id, fEnabled, ax, ay) { \
	id, WS_CHILD | WS_CLIPOUT, 0, fEnabled, \
	{ ax, ay, ax + 1, ay + 1 }, \
	{ ax, ay, ax + 1, ay + 1 }, \
	rrcInvalidStd \
	(PLFN) DropButtonWndProc, \
	NULL, NULL, NULL, 0, 0 }

#define wndDropDownHolder() { \
	0, 0, 0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, \
	rrcInvalidStd \
	(PLFN) NULL, NULL, NULL, NULL, 0, 0, { NULL } }

#define	GetWindowProc(pwnd) ((pwnd)->pfnWndProc)
#define	SetWindowProc(pwnd, pfn) {(pwnd)->pfnWndProc = pfn;}
#define	GetWindowWord(pwnd, iw) ((pwnd)->rgwExtra[(iw)])
#define	SetWindowWord(pwnd, iw, w) {(pwnd)->rgwExtra[(iw)] = (w);}
#define	PwndParent(pwnd) ((pwnd)->pwndParent)
#define	PwndChild(pwnd) ((pwnd)->pwndChild)
#define	PwndSibling(pwnd) ((pwnd)->pwndSibling)

#endif /*NOWNDMACROS*/

#ifndef NODRAW
/* Window Drawing support */
#define	AxOfRx(pwnd,rx) ((pwnd)->arcClipping.axLeft+(rx))
#define	AyOfRy(pwnd,ry) ((pwnd)->arcClipping.ayTop+(ry))
#define	RxOfAx(pwnd,ax) ((ax)-(pwnd)->arcClipping.axLeft)
#define	RyOfAy(pwnd,ay) ((ay)-(pwnd)->arcClipping.ayTop)
#define CbSizeRrc(prrc) (CwSizeRrc(prrc) << 1)
#endif /*!NODRAW*/

#ifndef NOWINSTYLES
/* Window styles */
#define	WS_TILED		0x0000
#define	WS_CHILD		0x0000	/* note : no distinction */

#define	WS_BORDER		0x0100
#define	WS_VSCROLL		0x0200
#define	WS_HSCROLL		0x0400
#define WS_SUBSTYLE		0x001f

#define WS_BEENDIRTIED		0x0020
#define WS_OVERLAP		0x0040
#define WS_CLIPOUT		0x0080

#define WS_TYPE 		0x3800	/* type mask */
#define WS_EDIT			0x0800
#define WS_LISTBOX		0x1000
#define WS_BUTTON		0x1800
#define WS_STATIC		0x2000
#define WS_DIALOG		0x2800
#define WS_SCROLL		0x3000
#define WS_STATIC_NOACCEL	0x3800

#define LBS_SORT		0x0001
#endif /*!NOWINSTYLES*/

/* codes for listbox item indices */
#define	iszMin	((WORD)	0)
#define	iszNil	((WORD)	-1)		/* invalid isz */

/* special edit window specific isa's */
#define IsaEdit(pwnd)	((pwnd)->rgwExtra[3])
#define IsaSelEdit(pwnd)	((pwnd)->rgwExtra[4])
#define IsaDisabledEdit(pwnd)	((pwnd)->rgwExtra[13])

/* special listbox window specific isa's */
#define IsaListbox(pwnd)	((pwnd)->rgwExtra[13])
#define IsaHiliteListbox(pwnd)	((pwnd)->rgwExtra[14])


/*****************************************************************************/
/* System Specifics */
#ifndef	NOPROCS
VOID		FARPUBLIC DoSound(WORD,WORD);
DWORD		FARPUBLIC ClockTicks(void);
BYTE		FARPUBLIC GetPrinterTimeOut(BYTE);
VOID		FARPUBLIC SetPrinterTimeOut(BYTE,BYTE);
WORD		FARPUBLIC PrinterCmd(BYTE,BYTE,BYTE);
WORD		FARPUBLIC ComCmd(BYTE,BYTE,BYTE);
#endif	/* !NOPROCS */


extern BYTE PASCAL	fSingleFloppy;	/* TRUE => 1 floppy system */
extern BYTE PASCAL	fInt24Error;	/* Set if INT 24 error detected */

/* Sound Facilities */
#define	Beep()		DoSound(3,1400)
#define	Click()		DoSound(2,700)

BOOL		FARPUBLIC FValidDrive(char);

/* File find info; it's the DOS 3 structure, emulated in OS/2. */
typedef struct _fde
	{
	char	reserved[21];	/* MSDOS requires this	*/
	char	atr;		/* File attribute	*/
	WORD	wTime;		/* File time of last write */
	WORD	wDate;		/* File date of last write */
	DWORD	cbFile;		/* File size in bytes	*/
#ifndef OS2
	char	szName[13];	/* File name packed	*/
#else	
	char	szName[256];	/* File name packed	*/
#endif
	} FDE;	/* Find directory entry */

typedef FDE *PFDE;

BOOL		FARPUBLIC FFindFirst(PFDE, char *, WORD);
BOOL		FARPUBLIC FFindNext(PFDE);
BOOL		FARPUBLIC FindClose(void);
#ifndef NOVIRTUALKEYCODES	
#define	VK_MIN		0x100

#define	VK_LBUTTON	0x101
#define	VK_RBUTTON	0x102
#define	VK_CANCEL	0x103
#define	VK_MBUTTON	0x104	/* NOT contiguous with L & RBUTTON */
#define	VK_BACK		0x108
#define	VK_TAB		0x109
#define	VK_CLEAR	0x10C
#define	VK_RETURN	0x10D
#define	VK_SHIFT	0x110
#define	VK_CONTROL	0x111
#define	VK_ALT		0x112
#define	VK_PAUSE	0x113
#define	VK_CAPLOCK	0x114

/* special VK_s for Kanji and Kana-Kanji conversion */
#define	VK_KANA		0x115
#define	VK_ROMAJI	0x116
#define	VK_ZENKAKU	0x117
#define	VK_HIRAGANA	0x118
#define	VK_KANJI	0x119
/* note: hole for 1A and 1B */
#define	VK_CONVERT	0x11C
#define	VK_NONCONVERT	0x11D
#define	VK_ACCEPT	0x11E
#define	VK_MODECHANGE	0x11F

#define	VK_ESCAPE	0x11B
#define	VK_SPACE	0x120

#define	VK_PRIOR	0x121
#define	VK_NEXT		0x122
#define	VK_END		0x123
#define	VK_HOME		0x124
#define	VK_LEFT		0x125
#define	VK_UP		0x126
#define	VK_RIGHT	0x127
#define	VK_DOWN		0x128

#define	VK_0		0x130
/* 1..8 */
#define	VK_9		0x139
#define	VK_A		0x141
/* B..Y */
#define	VK_Z		0x15A

#define	VK_SELECT	0x129
#define	VK_PRINT	0x12A
#define	VK_EXECUTE	0x12B
#define	VK_INSERT	0x12D
#define	VK_DELETE	0x12E
#define	VK_HELP		0x12F

#define	VK_NUMPAD0	0x160
#define	VK_NUMPAD1	0x161
#define	VK_NUMPAD2	0x162
#define	VK_NUMPAD3	0x163
#define	VK_NUMPAD4	0x164
#define	VK_NUMPAD5	0x165
#define	VK_NUMPAD6	0x166
#define	VK_NUMPAD7	0x167
#define	VK_NUMPAD8	0x168
#define	VK_NUMPAD9	0x169
#define	VK_MULTIPLY	0x16A
#define	VK_ADD		0x16B
#define	VK_SEPARATOR	0x16C
#define	VK_SUBTRACT	0x16D
#define	VK_DECIMAL	0x16E
#define	VK_DIVIDE	0x16F

#define	VK_F1		0x170
#define	VK_F2		0x171
#define	VK_F3		0x172
#define	VK_F4		0x173
#define	VK_F5		0x174
#define	VK_F6		0x175
#define	VK_F7		0x176
#define	VK_F8		0x177
#define	VK_F9		0x178
#define	VK_F10		0x179
#define	VK_F11		0x17A
#define	VK_F12		0x17B
#define	VK_F13		0x17C
#define	VK_F14		0x17D
#define	VK_F15		0x17E
#define	VK_F16		0x17F

#define VK_OAX		0x180

#define	VK_NUMLOCK	0x190
#define	VK_SCRLOCK	0x191

#define VK_RESIZE	0x1A0

/* alternative names */
#define	VK_MENU		VK_ALT
#define	VK_CAPITAL	VK_CAPLOCK
#define	VK_OEM_NUMBER	VK_NUMLOCK
#define	VK_OEM_SCROLL	VK_SCRLOCK
#define	VK_SEPARATER	VK_SEPARATOR

#endif /*!NOVIRTUALKEYCODES*/	

#ifndef	NOPROCS
BOOL		FARPUBLIC FIsDbcsChar(ACHAR);		/* OPTIONAL */
WORD		FARPUBLIC CchLenDbcs(unsigned char *);		/* OPTIONAL */
char *		FARPUBLIC PchNextDbcs(unsigned char *);		/* OPTIONAL */
char *		FARPUBLIC PchPrevDbcs(unsigned char *, unsigned char *);	/* OPTIONAL */
WORD		FARPUBLIC CtOfDbcsChar(unsigned char *, unsigned char *);	/* OPTIONAL */
WORD		FARPUBLIC CtOfDbcsCharX(unsigned char far *, unsigned char far *);	/* OPTIONAL */
VOID		FARPUBLIC TextOutAttrX(PWND, RX, RY, PRRC, unsigned char far *, unsigned char far *, short, short);	/* OPTIONAL */
#endif	/* !NOPROCS */


/* Character Types */
#define	ctSNG	0	/* single byte character */
#define	ctDB1	1	/* 1st byte of double byte character */
#define	ctDB2	2	/* 2nd byte of double byte character */


#define	SetSysColor(isa, coBack, coFore, fBlink, fHilite) \
	SetIsaColor(isa,				\
 	    (coFore) + ((fHilite) ? 8 : 0),	\
 	    (coBack) + ((fBlink) ? 8 : 0))

#ifndef	NOPROCS
VOID		FARPUBLIC SetIsaColor(ISA, WORD, WORD);
VOID		FARPUBLIC GetIsaColor(ISA, WORD *, WORD *);
VOID		FARPUBLIC SetIsaRgca(ISA, BYTE *);
VOID		FARPUBLIC SetIsaFfont(ISA, FFONT);		/*OPTIONAL*/
# ifdef KANJI
FFONT		FARPUBLIC GetIsaFfont(ISA);			/*OPTIONAL*/
# endif /* KANJI */
#endif	/* !NOPROCS */



/* LszPromptSwapDisk */

#define	rpsdNULL	-1
#define	rpsdNotFound	1
#define	rpsdLocked	2
#define	rpsdLoadError	3


/* RspAppIdle */

#define	rspSleep	1		/* sleep some more */
#define	rspContinue	2		/* check for new events */
#define	rspAbort	3		/* abort from the current context */

#define	cnxNull		0		/* context is not given */

#define	cnxMenu		1		/* context is Menu */
#define	cnxDialog	2		/* context is Dialog */
#define	cnxMBox		3		/* context is Message Box */

#define	cnxMacro		4		/* context is Key Macro library */
#define	cnxVAP		5		/* context is VAP interface */

#define	cnxMoveSize	6		/* context is overlap window move/size */


#ifndef NOPROCS
CHAR FAR *	FARPUBLIC LszPromptSwapDisk(char far *, WORD, WORD);	/* OPTIONAL */
WORD		FARPUBLIC RspAppIdle(WORD, DWORD);		/* OPTIONAL */
BOOL		FARPUBLIC FHelpMsg(PMSG, WORD);		/* OPTIONAL */
#endif	/* !NOPROCS */



#define fKkcOn		0x0001		/* kana-kanji converter on */
#define fKkcScreen	0x0002		/* screen input mode */
#define fKkcEnScreen	0x0003		/* enable screen input mode */

BOOL FARPUBLIC FKKCInit(void);					/*OPTIONAL*/
VOID FARPUBLIC KKCEnd(void);					/*OPTIONAL*/
BOOL FARPUBLIC FKKCActive(void);				/*OPTIONAL*/
VOID FARPUBLIC KKCEnable(BOOL);					/*OPTIONAL*/
WORD FARPUBLIC FKKCGetMode(void);				/*OPTIONAL*/
VOID FARPUBLIC KKCSetMode(WORD);				/*OPTIONAL*/
VOID FARPUBLIC KKCWindowPos(BYTE, BYTE, BYTE, BYTE, BYTE);	/*OPTIONAL*/
BOOL FARPUBLIC FKKCMsg(PMSG);					/*OPTIONAL*/


/* CPD_STRUCTURE: as yet undocumented CPD structure */
typedef	void	CPD_STRUCTURE;		//REVIEW: define and document this !


/*****************************************************************************/
/* default machine data group/element ID code */
#define mdEidDir	0			/* directory element (all) */

#define mdGidGeneral	0			/* general group */
#define mdEidGenName	1			/* machine name element */

#define mdGidScreen	1			/* screen group */

#define mdGidKey	2			/* key group */

/*****************************************************************************/
/* System Specifics */
#ifndef	NOPROCS
BOOL		FARPUBLIC FInitMachineDataMdd(VOID);	/*OPTIONAL*/
WORD		FARPUBLIC CbMachineDataMdd(BYTE, BYTE); /*OPTIONAL*/
WORD		FARPUBLIC CbGetMachineDataMdd(BYTE, BYTE, WORD, BYTE FAR *);/*OPTIONAL*/
#endif	/* !NOPROCS */


#define	sopsFreeze	0
#define	sopsThaw		1

#define	serrOk		0
#define	serrNoMem	1
#define	serrBadSops	2

typedef	struct _csdc
	{
	WORD	cFreeze;
	WORD	psPrimOld;			/* old primary screen buffer */
	BYTE	axCursCur;
	BYTE	ayCursCur;
	VOID FAR *	lpfnFInit;
	VOID FAR *	lpfnMoveHwCurs;
	VOID FAR *	lpfnPrepUpdate;
	VOID FAR *	lpfnDoUpdate;
	VOID FAR *	lpfnDoneUpdate;
	VOID FAR *	lpfnBltArc;
	} CSDC;

WORD	FARPUBLIC	SerrScreenCtrl(WORD, CSDC FAR *, VOID FAR *);


/*****************************************************************************/
/* Pseudo Printer Specifics */
#ifndef	NOPROCS
WORD		FARPUBLIC RerrLoadPpd(char *);			/*OPTIONAL*/
VOID		FARPUBLIC FreePpd(void);			/*OPTIONAL*/
BOOL		FARPUBLIC FInitPpd(DWORD);			/*OPTIONAL*/
VOID		FARPUBLIC TermPpd(VOID);			/*OPTIONAL*/
BOOL		FARPUBLIC FPrintChPpd(WORD);			/*OPTIONAL*/
#endif	/* !NOPROCS */


/*****************************************************************************/
/* KKC Interface specifics (OPTIONAL) */

/* kkret = KK converter return value */

#define	kkretSuccess		0
#define	kkretFailure		(-1)
#define	kkretThrough		1

/* kkpos = Conversion position */

#define	kkposFree		0
#define	kkposBottom		1
#define	kkposCursor		2

/* Structure to communicate with KID */

#define	cbReservedKkcv		34

typedef struct _kkcv
	{
	WORD		wType;		/* Data type of wAscii */
	WORD		wScan;		/* Key scan code */
	WORD		wAscii;		/* Ascii code */
	WORD		wShift;		/* Shift key status */
	WORD		wExShift;	/* Extended Shift key status */

	WORD		cchResult;	/* Length of Result string */
	char FAR *	lpchResult;	/* Pointer to Result string buffer */

	WORD		cchMode;	/* Length of Mode string */
	char FAR *	lpchMode;	/* Pointer to Mode string buffer */
	char FAR *	lpattrMode;	/* Pointer to System attribute buffer */

	WORD		cchSystem;	/* Length of System string */
	char FAR *	lpchSystem;	/* Pointer to System string buffer */
	char FAR *	lpattrSystem;	/* Pointer to System attribute buffer */

	WORD		cchBuf;		/* Length of Display string */
	char FAR *	lpchBuf;	/* Pointer to Display string buffer */
	char FAR *	lpattrBuf;	/* Pointer to Display attribute buffer*/
	WORD		cchBufCursor;	/* Cursor position in Display buffer */                                                                                 
	char		rgbReserved[cbReservedKkcv];
	} KKCV;	/* KK Converter interface structure */


#ifndef NOPROCS
int		FARPUBLIC KKOpen(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKClose(VOID);			/*OPTIONAL*/
int		FARPUBLIC KKJoin(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKFree(VOID);				/*OPTIONAL*/
int		FARPUBLIC KKInOut(KKCV FAR *);			/*OPTIONAL*/
int		FARPUBLIC KKPosGet(VOID);			/*OPTIONAL*/
int		FARPUBLIC KKPosSet(KKCV FAR *, WORD);		/*OPTIONAL*/
BOOL		FARPUBLIC FKKMode(void);			/*OPTIONAL*/
int		FARPUBLIC KKSetMode(KKCV FAR *, BOOL);		/*OPTIONAL*/
#endif /* !NOPROCS */


#ifdef TRACES_ENABLED

/* leave space for null at end */
#define cchWord		7

/* tag structure */
#define cchTagId	12
#define cchOwner	12
#define cchDesc		36

#define FTAG		WORD

typedef struct _tag
	{
	WORD	id;
	CHAR	szTagId[cchTagId];
	CHAR	szOwner[cchOwner];
	CHAR	szDesc[cchDesc];
	FTAG	ftag;
	} TAG;

#define LPTAG		TAG FAR *
#define LSZ		CHAR FAR *

/* CW-defined ftags (the rest are for application use) */
#define ftagMaskOn	0x00ff
#define ftagRegistered	0x8000

/* data passed to application for trace */
typedef struct _tod
	{
	LPTAG		lptag;
	LSZ		lsz;
	LONG		lParam;
	} TOD;

/* function prototypes */
#ifndef NO_PROCS
VOID FARPUBLIC InitCWTraceTags();
PWND FARPUBLIC PwndSetPwndTrace(PWND);
VOID FARPUBLIC TraceTagRegister(LPTAG, WORD);
VOID FARPUBLIC CWTrace(LPTAG, LSZ, LONG);
VOID FARPUBLIC AppendSzToSz(CHAR *, CHAR **);
#endif	/* !NO_PROCS */

/* tracing on/off */
extern PWND PASCAL	pwndTrace;

#define FTracingOn()	(pwndTrace != NULL)

#define FTraceTagOn(tag) \
			(FTracingOn() && ((tag).ftag & ftagMaskOn))
#define FTraceTagRegistered(tag) \
			((tag).ftag & ftagRegistered)

/* full tracing macros */
#define Trace(tag)	if (FTraceTagOn(tag)) CWTrace((LPTAG) &(tag), NULL, 0L)

#define TraceSz(tag, sz) \
			if (FTraceTagOn(tag)) CWTrace((LPTAG) &(tag),	\
							(LSZ) sz, 0L)

#define TraceAssert(fCond, tag, sz) \
	 		if (FTraceTagOn(tag) && fCond)			\
				CWTrace((LPTAG) &(tag), (LSZ) sz, 0L)

#define TraceWord(tag, wParam)  \
			if (FTraceTagOn(tag))				\
				{					\
				CHAR	szWord[cchWord];		\
				SzFromInt(szWord, wParam);		\
				CWTrace((LPTAG) &(tag), (LSZ) szWord,	\
							(LONG) wParam);	\
				}

#define BeginTraceSz(tag) \
			if (FTraceTagOn(tag))				\
				{					\
				CHAR	_szTrace[cchSzTrace];		\
				CHAR *	_pchEnd = _szTrace;

/* MUST exist only within BeginTraceSz and EndTraceSz */
#define AppendSzToSzTrace(sz) \
				AppendSzToSz(sz, &_pchEnd)

#define AppendWordToSzTrace(wParam, fform) \
				SzFromInt(_pchEnd, wParam);		\
				_pchEnd += cchWord;

/* MUST follow previous BeginTraceSz() "call" */
#define EndTraceSz(tag) \
				Assert(_pchEnd - _szTrace < cchSzTrace);\
				CWTrace((LPTAG) &(tag), (LSZ) _szTrace, 0L);\
				}

#define DoBenchMark(tag, stmt) \
			{						\
			LONG	lTimeStart;				\
			WORD	wTimeElapsed;				\
			lTimeStart = ClockTicks();			\
			stmt;						\
			wTimeElapsed = (WORD) (ClockTicks() - lTimeStart); \
			TraceWord(tag, wTimeElapsed);			\
			}

#define Repeat(stmt, crep) \
			{ 						\
			REGISTER WORD	irep;				\
			for (irep = 0; irep < crep; irep++)		\
				stmt;					\
			}

#else	/* TRACES_ENABLED */

#define InitCWTraceTags()
#define PwndSetPwndTrace(pwnd)
#define TraceTagRegister(rgtag, ctag)
#define Trace(tag)
#define TraceSz(tag, sz)
#define TraceAssert(fCond, tag, sz)
#define TraceWord(tag, wParam, fform)
#define BeginTraceSz(tag)
#define AddSzToTraceSz(sz)
#define AddWordToTraceSz(sz)
#define EndTraceSz(tag)
#define DoBenchMark(tag, stmt)
#define Repeat(stmt, crep)

#endif	/* !TRACES_ENABLED */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\csdmtmpl.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	CW : Character Windows

	csdmtmpl.h : SDM template header (include for .sdm files only)				CS Compiled only !!

-- Created Fri Mar 23 11:34:19 1990 */ 

#define	SDM_COW		1


/* Compact Rectangle */
typedef struct _crc
	{
	BYTE	x, y, dx, dy;		/* order critical */
	} CRC;		/* Compact Rectangle */

/* -- defined Dialog Item */
typedef struct _tm
	{
	BITS	tmtBase:6;	/* item type */
	BIT	filler:1;	/* fThinBdr */
	BIT	fAction:1;
#ifdef SDM_ENGINE		/*CW's internal representation */
	BIT	f1:1;
	BIT	f2:1;
	BIT	f3:1;
	BIT	f4:1;
	BIT	f5:1;
	BIT	f6:1;
	BIT	f7:1;
	BIT	f8:1;
#else
	BITS	bitSlot:8;	/* misc flags */
#endif /*SDM_ENGINE*/

#ifdef CC
	WORD	bpString;	/* based pointer or wParam */
#else
	char	sz[];		/* string or wParam */
#endif /*!CC*/

	LONG	l;		/* compact rectangle or PFN */
	} TM;


/* Dialog Proc Type */
typedef BOOL	(FARPUBLIC *PFFN_DLG)(WORD, TMC, WORD, WORD, WORD);


/* dialog header */
typedef struct _dlg
	{
	CRC	crcDlg;			/* Compact Rectangle */
	WORD	hid;			/* dialog help id */
	TMC	tmcSelInit;		/* initial selection */
#ifdef VAP_API
	DWORD	pfnDlg; 		/* dialog function */
#else
	PFFN_DLG pfnDlg; 		/* dialog function */
#endif
	WORD	ctmBase;		/* # of base SDMTMs */
	WORD	filler;			/* bdr */

/* title string : based pointer */
#ifdef CC
	WORD bpTitle;			/* based pointer to title */
#else
	char szTitle[];		/* dialog title */
#endif /*!CC*/


#ifndef CC
	TM	rgtm[];			/* variable length for CS */
#else
#ifdef SDM_ENGINE
	TM	rgtm[1];		/* array starts here */
#endif
#endif /*CC*/
	} DLG;	/* Dialog Template */

/*****************************************************************************/

/* instances of tmtBase  (basic tm types) */
#define	tmtNull			0
#define	tmtEnd			0
#define	tmtStaticText		1
#define	tmtFormattedText	2

#define	tmtGroupBox		3

#define	tmtPushButton		4
#define	tmtCheckBox		5
#define	tmtRadioButton		6


#define	tmtEdit			7
#define	tmtListBox		8

#define	tmtDummyText		9		/* dummy static text */
#define	tmtGeneralPicture	10		/* with Render Proc */

#define	tmtDropList		11			/* drop down list box */

#define	tmtNormalMax		12

#define	tmtUserMin		16
/* App / future  extensions (32 types) */
#define	tmtUserMax		48

#define	tmtSpecialMin		48
/* Special Records */
#define	tmtConditional		48

/* Extension Records (still Special) */
#define	tmtExtensionMin		61

#define	tmtExt1			61
#define	tmtExt2			62

#define	tmtSpecialMax		64

#define	tmtMax			64		/* 6 bits */



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\groups.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

extern struct ListBoxData ProgramList;
extern TOKEN gGroupLevel;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\icons.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	icons.h - declarations for gloabally accessible icons
**
**   Date      Author	Modification
** --------   --------	------------------------------------------------
**  7/18/89   scottq	Created icons
*/

extern BITMAP bigUpArrow;
extern BITMAP bigDownArrow;
extern BITMAP bigProgramIcon;
extern BITMAP bigProgramIconInvert;
extern BITMAP bigFileIcon;
extern BITMAP bigFileIconInvert;

extern BITMAP bigFloppyIcon;
extern BITMAP bigFloppyIconInvert;

extern BITMAP bigHDIcon;
extern BITMAP bigHDIconInvert;

extern BITMAP bigRemoteIcon;
extern BITMAP bigRemoteIconInvert;

extern BITMAP bigRamDriveIcon;
extern BITMAP bigRamDriveIconInvert;

extern BITMAP bigCDRomIcon;
extern BITMAP bigCDRomIconInvert;

extern BITMAP bigRadioButtonUnSel;
extern BITMAP bigRadioButtonSel;

extern BITMAP bigDirExpansionIcon;
extern BITMAP bigDirCollapseIcon;
extern BITMAP bigDirNoZoomIcon;

extern BITMAP smallUpArrow;
extern BITMAP smallDownArrow;
extern BITMAP smallProgramIcon;
extern BITMAP smallProgramIconInvert;
extern BITMAP smallFileIcon;
extern BITMAP smallFileIconInvert;

extern BITMAP smallFloppyIcon;
extern BITMAP smallFloppyIconInvert;

extern BITMAP smallHDIcon;
extern BITMAP smallHDIconInvert;

extern BITMAP smallRemoteIcon;
extern BITMAP smallRemoteIconInvert;

extern BITMAP smallRamDriveIcon;
extern BITMAP smallRamDriveIconInvert;

extern BITMAP smallCDRomIcon;
extern BITMAP smallCDRomIconInvert;


extern BITMAP  smallRadioButtonUnSel;
extern BITMAP  smallRadioButtonSel;


extern BITMAP smallDirExpansionIcon;
extern BITMAP smallDirCollapseIcon;
extern BITMAP smallDirNoZoomIcon;

extern struct BITMAP	bigProgManIcon;
extern struct BITMAP	bigProgManIconInvert;
extern struct BITMAP	smallProgManIcon;
extern struct BITMAP	smallProgManIconInvert;
#define GroupIcon		(CHEIGHT > SMALLHEIGHT?&bigProgManIcon:&smallProgManIcon)
#define GroupIconInvert	(CHEIGHT > SMALLHEIGHT?&bigProgManIconInvert:&smallProgManIconInvert)

#define UpArrow 	    (CHEIGHT > SMALLHEIGHT?&bigUpArrow:&smallUpArrow)
#define DownArrow	    (CHEIGHT > SMALLHEIGHT?&bigDownArrow:&smallDownArrow)
#define ProgramIcon	    (CHEIGHT > SMALLHEIGHT?&bigProgramIcon:&smallProgramIcon)
#define ProgramIconInvert   (CHEIGHT > SMALLHEIGHT?&bigProgramIconInvert:&smallProgramIconInvert)
#define FileIcon	    (CHEIGHT > SMALLHEIGHT?&bigFileIcon:&smallFileIcon)
#define FileIconInvert	    (CHEIGHT > SMALLHEIGHT?&bigFileIconInvert:&smallFileIconInvert)
#define FloppyIcon	    (CHEIGHT > SMALLHEIGHT?&bigFloppyIcon:&smallFloppyIcon)
#define FloppyIconInvert    (CHEIGHT > SMALLHEIGHT?&bigFloppyIconInvert:&smallFloppyIconInvert)
#define HDIcon		    (CHEIGHT > SMALLHEIGHT?&bigHDIcon:&smallHDIcon)
#define HDIconInvert	    (CHEIGHT > SMALLHEIGHT?&bigHDIconInvert:&smallHDIconInvert)
#define RemoteIcon	    (CHEIGHT > SMALLHEIGHT?&bigRemoteIcon:&smallRemoteIcon)
#define RemoteIconInvert    (CHEIGHT > SMALLHEIGHT?&bigRemoteIconInvert:&smallRemoteIconInvert)
#define RamDriveIcon		(CHEIGHT > SMALLHEIGHT?&bigRamDriveIcon:&smallRamDriveIcon)
#define RamDriveIconInvert	  (CHEIGHT > SMALLHEIGHT?&bigRamDriveIconInvert:&smallRamDriveIconInvert)
#define CDRomIcon		(CHEIGHT > SMALLHEIGHT?&bigCDRomIcon:&smallCDRomIcon)
#define CDRomIconInvert	  (CHEIGHT > SMALLHEIGHT?&bigCDRomIconInvert:&smallCDRomIconInvert)

#define RadioButtonUnSel	(CHEIGHT > SMALLHEIGHT?&bigRadioButtonUnSel:&smallRadioButtonUnSel)
#define RadioButtonSel	    (CHEIGHT > SMALLHEIGHT?&bigRadioButtonSel:&smallRadioButtonSel)
#define DirExpansionIcon	(CHEIGHT > SMALLHEIGHT?&bigDirExpansionIcon:&smallDirExpansionIcon)
#define DirCollapseIcon     (CHEIGHT > SMALLHEIGHT?&bigDirCollapseIcon:&smallDirCollapseIcon)
#define DirNoZoomIcon	    (CHEIGHT > SMALLHEIGHT?&bigDirNoZoomIcon:&smallDirNoZoomIcon)


#define ProgManIcon ProgramIcon
#define ProgManIconInvert ProgramIconInvert


#if 0
/* ZZZZZZZZZZZZZZZZZZZZZZZZZZZ Unused icons ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ */

extern BITMAP bigRightArrow;
extern BITMAP bigLeftArrow;
extern BITMAP bigColorLeft;
extern BITMAP bigColorRight;

extern BITMAP  smallRightArrow;
extern BITMAP  smallLeftArrow;

extern BITMAP bigPgUpIcon;
extern BITMAP bigPgDnIcon;
extern BITMAP  smallPgUpIcon;
extern BITMAP  smallPgDnIcon;

#define RightArrow		(CHEIGHT > SMALLHEIGHT?&bigRightArrow:&smallRightArrow)
#define LeftArrow	    (CHEIGHT > SMALLHEIGHT?&bigLeftArrow:&smallLeftArrow)
#define ColorLeft	    (CHEIGHT > SMALLHEIGHT?&bigColorLeft:&bigColorLeft)
#define ColorRight	    (CHEIGHT > SMALLHEIGHT?&bigColorRight:&bigColorRight)
#define PgUpIcon	    (CHEIGHT > SMALLHEIGHT?&bigPgUpIcon:&smallPgUpIcon)
#define PgDnIcon	    (CHEIGHT > SMALLHEIGHT?&bigPgDnIcon:&smallPgDnIcon)

/* ZZZZZZZZZZZZZZZZZZZZZZZZZZZ Unused icons ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\help.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* This is unused #define HELP_SKIPDELDIR 		'B' */
/* This is unused #define HELP_READONLYDEL		'C' */
/* This is unused #define HELP_SKIPDELFILE		'D' */
#define	HELP_NOSELFCOPY 		'E'
/* This is unused #define HELP_REPLACEFILE		'F' */
#define HELP_DISKFULL			'G'
/* This is unused #define HELP_INVALIDASSOCEXT	'H' */
#define HELP_VIEWEMPTYFILE		'I'
#define HELP_ERRSETFILEATTR		'J'
#define HELP_ERRCREATEDIR		'K'
#define HELP_ERRFINDCREATEDIR	'L'
#define HELP_ERRDELDIR			'M'
#define HELP_ERRGETATTR 		'N'
#define HELP_ERRSETATTR 		'O'
#define HELP_ERROPENSRC			'P'
#define HELP_ERRCREATEDEST		'Q'
#define HELP_ERRREADSRC 		'R'
#define HELP_ERRWRITEDEST		'S'
#define HELP_ERRRENAME			'T'
#define HELP_ERRDISKFREE		'U'
#define HELP_DISKLOADFILES		'V'
#define HELP_VIEWOPEN			'W'
#define HELP_VIEWREAD			'X'
#define HELP_PRINTERR			'Y'
#define HELP_ERRDELFILE			'Z'

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\kkcfltr.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
	CW : Character Oriented Windows

	kkcfltr.h : Kana Kanji Conveter Filter
*/

/***BEGIN_PUBLIC***/

/* Public variables for kkc filter */

extern BOOL PASCAL fKkcAvailable;	/* TRUE -> kkif drv. initialized */
extern BOOL PASCAL fKkcEnabled;		/* TRUE -> kkc enabled */
extern KKCV PASCAL kkcv;			/* Common area for kid and kkc filter */
extern BOOL PASCAL fKkcMessage;		/* TRUE -> converted string pending */


/* kkc filter mode */

#define	kkmodeNil		0
#define	kkmodeLYR		1		/* layer displays undetermined string */
#define	kkmodeAPP		2		/* ap displays undetermined string */


#ifndef NOPROCS
BOOL FARPUBLIC FInitKkc(PWND);
VOID FARPUBLIC TermKkc(VOID);
BOOL FARPUBLIC SetModeKkc(WORD);
BOOL FARPUBLIC FSuspendKkc(BOOL);
BOOL FARPUBLIC FEnableKkc(BOOL);
BOOL FARPUBLIC FActivateKkc(BOOL);
BOOL FARPUBLIC FActiveKkc(VOID);
BOOL FARPUBLIC FSetPosKkc(WORD);
BOOL FARPUBLIC GetPosKkc(VOID);
BOOL FARPUBLIC FFlushKkc(VOID);
VOID FARPUBLIC SetWindowKkc(PRRC);
VOID FARPUBLIC SetCursorKkc(RX, RY);
VOID FARPUBLIC TextOutAttrX(PWND, RX, RY, PRRC, CHAR FAR *, CHAR FAR *, short, short);
#endif /* !NOPROCS */

/***END_PUBLIC***/


//BOOL FARPRIVATE FKKCMsg(PMSG);
//BOOL FARPRIVATE KKCFilter(PMSG);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\filemgr.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	filemgr.h - common header file for all file manager modules
**
**   Date      Author	Modification
** --------   --------	------------------------------------------------
**  8/08/89   t-jeffro	created header, made treehdr.CurDirBranch an array.
**  9/22/89   harikris	Modified formatting, added prototypes, SORT fileds.
*/

/*
**								Constants
*/

#ifndef EOS
  #define EOS		'\0'	/* end-of-string marker	*/
#endif

#define PATHCHAR	'\\'	/* path component separator */

//  BEGIN IPG - Different thousands separator for GER/FRN/SPA/POR/DUT/ITN/SWE
#if defined(GER) || defined(FRN) || defined(SPA) || defined(POR) || defined(ITN) || defined(DUT)
  #define DIGITSEP	  '.'		  /* The character seperating digits in a number */
#else
  #if defined(SWE)
      #define DIGITSEP	  ' '
  #else
      #define DIGITSEP	  ','
  #endif
#endif
//  END IPG - Different thousands separator for GER/FRN/SPA/POR/DUT/ITN/SWE

/* This takes care of stuff like I:\  etc where after true name expansion
 * this path could be pretty long in case we allow 66 for directories of
 * the form I:\sdgd\dhh...
 */
#define MAX_PATH	101	/* max path length	*/

/* TMC values for scottq-style listboxes.
*/
#define tmcFileList0	0
#define tmcTreeList0	0
#define tmcFileList1	1
#define tmcTreeList1	1

#define LISTBOXTOP		6
#define SCREENEXTRAWIDTH  (axMac-80)
#define TREEBOXWIDTH	(36+SCREENEXTRAWIDTH)
#define FILEBOXWIDTH	44
#define FLATLEFTWIDTH	(28+SCREENEXTRAWIDTH)
#define FLATRIGHTWIDTH	52
#define SEARCHLEFT 0
#define SEARCHWIDTH (80+SCREENEXTRAWIDTH)

/* Size of some tree elements
*/
#define BITSPERWORD	(8*sizeof(unsigned)) /* number of bits in a WORD */
#define MAXNODE		33	/* max depth of directory tree+1*/
#define NAMELEN 	8	/* filename length w/o EOS		*/
#define EXTLEN  	3	/* file extension len w/o EOS	*/
#define PAGESIZE	256	/* files per page: should be a	*/
				/* multiple of BITSPERWORD		*/

/* modes for pattern matching routine */
#define FULLNAME	1
#define	EXTENSION	2

/* Used by CountBranch()
*/
#define CB_NORMAL  1		/* search for files		*/
#define CB_SUBDIR  2		/* search for directories	*/
#define CB_DESCEND 4		/* search in subtrees		*/

/* Global Focus Values */
#define MENUFOCUS 0
#define DRIVELIST0 1
#define TREE0  2	/* first tree list box (single or multiple modes) */
#define FILE0  3	/* first file list box, or flat display list box  */
#define DRIVELIST1 4
#define GROUPBOX 4
#define TREE1  5	/* second tree list box, multiple mode only */
#define TASKBOX 5
#define FILE1  6	/* secon file tree list box, multiple mode only */
/* Tree modes: single tree, double tree, or system (treeless)
*/
#define TR_SINGLE 1
#define TR_DOUBLE 2
#define TR_SYSTEM 3

#define TR_SEARCH 4

#ifndef NOGROUPINFILE
#define  TR_SHARE 5
#endif

// operation types for DoFileOp()
#define OP_COPY		1
#define OP_DELETE	2
#define OP_MOVE		3
#define OP_RENAME	4
#define OP_VIEW		5
#define OP_CHANGE	6
#define OP_PRINT	7
#define OP_ASSOCIATE	8

// Types of message box in GetResponse()
#define BT_QUIT			 1
#define BT_SKIPQUIT		 2
#define BT_RETRYSKIPQUIT 3 
#define BT_MODIFYATTRS	 5
#define BT_SKIPRETRY	 7
#define BT_FILESKIPQUIT	 9
#define BT_FILERETRYSKIPQUIT	10
#define BT_UNUSED3	 4 
#define BT_UNUSED1	 6
#define BT_UNUSED2	 8

// result codes from GetResponse()
#define ACT_OK		1
#define ACT_FORCE	2
#define ACT_RETRY	3
#define ACT_SKIP	4
#define ACT_CANCEL	5
#define ACT_NOMEM	6

#define ACT_ALL		10
#define ACT_SINGLE	11

/* Codes for SortKey in glob_t data structure */
/* Don't change these codes -- this is the order in which they occur in the
	display options dialog box and their item codes are used directly in the
	dialog procedure display options.									*/
#define SORT_NAME	0
#define SORT_EXT	1
#define SORT_DATE	2
#define SORT_SIZE	3
#define SORT_DISK	4

#define DRIVESPERLINE 13
#define NUMDRIVELISTS 26 /* A ... Z*/

/* (X, Y) co-ordinate of the first drive icon to be displayed on screen --
 * This is drive icon "A".
 */
#define DRIVEICONSTARTX 1
#define DRIVEICONSTARTY 3

/* This the lateral shift (X shift) between adjacent drive icons. */
#define DRIVESHIFT	6


#define RECALCNUMMATCHES 0xFFFF /* nummatches field in tree is invalid */

// Funny characters
#ifdef JAPAN
#define MIDLEFT		0x0e	/* looks like |-			*/
#define HORIZLINE	0x08	/* horizontal line			*/
#define VERTLINE	0x09	/* vertical line			*/
#define SELCHAR		0x1f	/* selection character			*/
#define ESCAPE		27	/* Escape Character */
#define LLCORNER	0x0d /* lower left corner */
#else
#define MIDLEFT		195	/* looks like |-			*/
#define HORIZLINE	196	/* horizontal line			*/
#define VERTLINE	179	/* vertical line			*/
#define SELCHAR		'\020'	/* selection character			*/
#define ESCAPE		27	/* Escape Character */
#define LLCORNER	192 /* lower left corner */
#endif

// Collapse dir mode characters
#define COLLAPSE_LCHAR	'['
#define COLLAPSE_RCHAR	']'
#define EXPANSION_CHAR	'+'
#define COLLAPSE_CHAR	'-'
#define NOZOOM_CHAR		' '

#define FMGRSB		2	/* screen line of current dir	*/
#define TABSIZE		8	/* # of spaces in a tab		*/
#define MAXCOLS		90	/* number of cols in widest screen mode */
#define MAXROWS		60	/* number of rows in highest screen res */

/* WARNING !! these numbers should be anything but 0. The function
	 driveexists returns this code & 0 if drive doen't exist.	*/
#define FLOPPY_TYPE		1
#define REMOTE_TYPE		2
#define HARDDISK_TYPE	3
#define RAMDRIVE_TYPE	4
#define CDROM_TYPE   5

/*
**								Structures
*/

/* Names for some of the bit fields in structure below to improve readability */
#define  LASTDIR			xb.db.lastdir
#define  FIRSTFILEFOUND	xb.db.firstfilefound
#define  EXPANDED			xb.db.expanded
#define  DISPLAYED		xb.db.displayed
#define  HASSUBDIRS		xb.db.hassubdirs
#define  DIRSORTED		xb.db.dirsorted

#define  SELECTED			xb.fb.selected
#define  MATCHESPATTERN	xb.fb.matchespattern
#define  FIRSTDIRFILE	xb.fb.firstdirfile
#define  LASTDIRFILE		xb.fb.lastdirfile
#define  DELMARKER		xb.fb.delmarker
#define  FILEOPMARKER	xb.fb.fileopmarker

/*	file tree node */
/* ZZZZ */
/* Note that in the following the bit field 'displayed' for directories is */
/* probably not needed as it is equivalent to finding out if its parent is */
/* expanded or not. Finding the parent of a node involves walking the entire*/
/* sibling chain as we don't have a parent pointer -- might be expensive!! */

typedef struct fi_t {
	unsigned char	 name[NAMELEN+EXTLEN];		// name of file w/o EOS
	union {
	    struct{
			unsigned date;		// last modify date (file!)
			unsigned time;		// last modify time (file!)
	    } dt;
	    struct{
			BYTE	    level;	// depth of directory (5 bits max...)
			BYTE	  unused1;	// unused-you are free to define it
			WORD	  unused2;	// unused-you are free to define it
	    } lx;
	}dtlx;

	/* The reason for using "unsigned attribs:8" instead of "BYTE attribs"	*/
	/* is to save a byte in this structure. 'unsigned' bit fields by		*/
	/* default use up a word (size of an unsigned!). This way we use up a	*/
	/* total of 2 bytes instead of 1+2=3.									*/
	unsigned	attribs	: 8;	// file attributes -- 1 BYTE.

	unsigned nosib		: 1;	// no further siblings

	union {
		struct {
			unsigned lastdir		: 1; // last directory of its siblings?
			unsigned firstfilefound : 1; // first file of a directory found?
										 // implies dir has atleast 1 file
			unsigned expanded		: 1; // dir expanded?
			unsigned displayed		: 1; //	dir displayed in collapsed mode?
			unsigned hassubdirs		: 1; // dir has atleast 1 sub-dir?
			unsigned dirsorted		: 1; // has dir been sorted?
		} db ; /* directory bit fields */
		struct {
			unsigned selected		: 1; // file selected?
			unsigned matchespattern : 1; // name matches file name filter?
												  // Filter is "MatchPat" as well as the
												  // glob.DisplayHiddenFiles
			unsigned firstdirfile	: 1; // first file in directory in
										 // appropriate sorted order?
			unsigned lastdirfile	: 1; // similar to above but for 'last'
			unsigned delmarker		: 1; // used to temporarily mark a file
										 // as deleted for directory sort!
			unsigned fileopmarker : 1; // used to temporarily mark a file
												// to indicate whether to perform fileop
												// on it or not!
		} fb ; /* file bit fields */
	} xb ; /* mutually exclusive bit fields between files & dirs */

	unsigned unused1	: 1;	// unused-you are free to define it

	struct fi_t far *sibling;	// ptr to next sibling
	union {
		struct {
			long size;			// size of file
			struct fi_t far *snext;	// next in sort order
		} f;
		struct {
			struct fi_t far *child;	// first child dir
			struct fi_t far *dnext;	// next directory
		} d;
	} x;
} fileinfo;

typedef fileinfo far *PENTRY;

typedef struct fp_t {
	fileinfo files[PAGESIZE];			// current directory
	struct fp_t far  *next;			// next page
} filepage;

typedef filepage far *PPAGE;

#define LABELLENGTH 12   /* Volume label for each tree 11 characters + Null*/
/* Tree structure
*/
typedef struct th_t {
	char root[4];				// string: root path
																
	PENTRY head;				// head of tree

	PPAGE pagehead;				// addr of 1st page
	PPAGE pagetail;				// addr of last page
	unsigned int freeind;		// index into pagetail of first free PENTRY
	unsigned int holecount;		// number of holes -- caused by deleting 
								// files or directories.

	struct find_t finds[MAXNODE]; // state of each dir srch

	PENTRY FirstDirectory;		// first directory in sort order
	PENTRY LastDirectory;		// last directory found found on disk
	PENTRY FirstFile;			// head of file linked list

	PENTRY LastFile;		// hack to just stick files to the end
								// of the snext chain.
	
	// 'Diskfilecount' != 'filecount' iff tree is in compact mode.
	WORD	Diskfilecount;		// number of files actually on the disk
	WORD	filecount;			// number of files in tree

	WORD	DirCount;			// # of directories in tree

	WORD	VisibleDirCount;	// # of directories visible in collapsed tree.

	unsigned Started	  : 1;	// we've begun reading in tree
	unsigned Compacted	  : 1;	// contains only dir's and files displayed dir
	unsigned ContinueTree	  : 1;  // tree not completely read in  yet

	unsigned fdiskinfoknown	  : 1;	// disk size info known or not!
	unsigned SortRequired	  : 1;	// to prevent background sorting!

	unsigned DisplayHiddenFiles : 1; // whether hidden/system files displayed!
	unsigned unused2		  : 1;
	unsigned unused3		  : 1;

	struct th_t far *next;		// next tree in drive list

	/* These items are used by AddFile(), akin to static var's.
	*/
	PENTRY parent;			// last directory searched
	PENTRY lastlink;		// last entry added by AddFile (only)
	int level;				// its tree depth

	int DriveType ;	// Drive type -- remote, local removable/not

	/* information about the drive -- useful for system mode & show-info */
	char VolLabel[LABELLENGTH] ;
	unsigned long SizeTotal ;
	unsigned long SizeAvail ;

	char mpat[NAMELEN+EXTLEN+2] ; /* for match pattern used by this tree */
	WORD nummatches;	      /* number of items in the tree which
					 match mpat. RECALCNUMMATCHES if this
					 should be recalculated before used */
	int skey ; /* sort key used by this tree */
	int tmode ; /* tree mode in which sort was done */

	unsigned int NumSel ; /* Number of files in the tree that are selected */
	unsigned long SizeSel ; /* Sum of sizes of files selected */

							// We have 2 of each of the following because we can
							// have upto 2 listboxes.
	PENTRY SelDir;	// directory that is selected -- cwd for this tree.
	WORD SelLine;  // line with the checkmark in tree -- selected dir above
	
} treehdr;

typedef treehdr far *PTREE;

typedef struct
{
	BYTE IconX;
	BYTE IconY;
	PTREE tree;
} driveinfo;

typedef driveinfo drivelist[26];

typedef struct {
	unsigned UpdateDrives : 1;	// need to update the drive icons
	unsigned UpdateTree   : 1;	// need to update the tree display
	unsigned UpdateFiles  : 1;	// need to update the file display
	PENTRY files;			// directory being displayed
	PTREE tree;			// tree being displayed
} filelistinfo;

/*
**								Variables
*/

typedef struct {
	unsigned InFileMgr		: 1;	// tree etc is onscreen
	unsigned MaxTree		: 1;	// max valid idx of Tree
	unsigned FocusBox		: 1;	// idx of listbox with focus
	unsigned CrossDirSel	: 1;	// Cross-dir selection enabled
	unsigned VerifyDelete	: 1;	// verify each deletion
	unsigned VerifyOverwrite: 1;	// verify file overwrites
	unsigned SelRepInd: 1;	// Index of tree to be replaced -- We actually
							// only retain the selections of 2 trees in mem.
							// this field is related to SelTree[2] below.
	unsigned DisplayHiddenFiles: 1 ; // should hidden/system files be displayed
	unsigned MouseConfirm	: 1 ;	// whether to confirm on mouse copy/moves */
	unsigned unused1			: 1 ;
	unsigned unused2			: 1 ;
	unsigned unused3			: 1 ;
	unsigned unused4			: 1 ;
	unsigned unused5			: 1 ;
	unsigned unused6			: 1 ;
	unsigned unused7			: 1 ;
	
	int	TreeMode;	// see top of file for choices
	PTREE drives;		// list of treehdrs, one for each
				// extant drive
	int DriveCount;		// number of extant drives
	int SortKey;		/* key for sorting -- name, ext, date, etc */

	/* Following word is used as storage to store and restore the
	 * flag "gDescendingOrder" to/from Swap file. The field "gDescendingOrder"
	 * is present for optimizing the string compare functions!
	 */
	WORD TempDescendingOrder ; 
	WORD FocusId ;
	/* Following are for saving/restoring file list box focus attributes */
	WORD TempFileListFocusItem[2]; // focus line of swapped out file lists
	WORD TempFileListScrolled[2];  // number of lines scrolled

	char MatchPat[NAMELEN+EXTLEN+2] ; /* global file match pattern */

	/*
	 * These next are two element arrays because there are
	 * two trees (when in two tree mode!)
	 */
	WORD lineselected[2] ; //line with the checkmark

	PTREE SelTree[2] ; // the two trees that have selections being shown in
					//	system tree mode
	
} global_t;

extern global_t glob;

extern filelistinfo listinfo[2];	// info to associate listbox to tree

extern char *gpszFileOpCaption ; /* caption for the file op being performed */

extern int (*SortFnArr[])(PENTRY, PENTRY) ;
extern int (*SortCmp)(PENTRY, PENTRY) ; /* pointer to function that does the
									 compare based on the selected sort key */

/* storage to save current tree-mode, sort-order, match-pat before entering	*/
/* search mode.																*/
extern char gSavedMatchPat[] ;
extern int gSavedTreeMode ; 
extern int gSavedSortOrder ; 
extern WORD gSavedGlobalFocus ; 

extern BOOL gfSearchDisk ; /* whether to search entire disk or not! */

/* Status line stuff - under development by scott */
#define FMGRSTATUSMAX 92
extern char gFMGRStatus[FMGRSTATUSMAX];

/* Currently set up so that a status line won't get truncated on the largest
 * screen size of 90 columns too!
 */
#define STATUS_LEN	91	// max status line length in GetResponse, ViewFile, etc 

extern BOOL gBeeps_On ; /* Whether to beep on error, etc or simply ignore it */

/* 'gfStatusMsgUp' states whether a status message specifying a fileop is
	being performed has been put up. */
extern BOOL gfStatusMsgUp ;

/* whether flatleft info has been drawn as yet in system tree mode. */
extern BOOL gfFlatLeftInfoDrawn ;

#define DOTTED_LINE	3

#define m_fPerformingViewFile() (gpszFileOpCaption == szViewFileCaption)


#define KEY_TAB		9
#define KEY_BS		8


/* The maximum length allowable for a directory name including drive letters */
#define ALLOWED_PATH 66
// maximum path text allowable; allowed path+'\'+8+'.'+3
#define USERS_MAX_TYPEABLE_PATH (ALLOWED_PATH + 13)

/* This mask is used to change a -1 to a 1 and a 1 to a -1. If one XOR's this
 * mask with the values this happens! Actually this trick can be used to
 * exchange any value to any other -- MASK = A xor B.
 */
#define MAGIC_XCHG_MASK	0xFFFE

/* Flag specifying what the sort order is -- Ascending/Descending order
 * A value of 0 implies ascending order and 0xFFFE (MAGIC_XCHG_MASK) means
 * descending order.
 */
extern WORD gDescendingOrder ;

/* How often to update the files/dirs read count. A value of 25 means that
 * every time a total of 25 entries (files+dirs) is read in, the screen will
 * be updated.
 */
#define DEFAULT_READ_UPDATE_FREQ 25



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\menus.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#ifndef OLDCW
typedef HMNU MENUINFO;

#else

#define MAXITEMS 70    /* maximum number of menu items */
#define MAXMENUS 15    /* maximum number of menus      */
#define MENUSPACE 4    /* number of spaces between menu headers */

typedef struct _menuinfo{
	MENUBAR   bar;
	MENU	  themenu[MAXMENUS];
	MENUITEM  theitem[MAXITEMS];
	MPVKEYID  thekey[MAXITEMS];
	int	  (*menuproc[MAXITEMS])();
	WORD	  nummenus;
	WORD	  numitems;
	WORD	  menudx;
	} MENUINFO;

extern MENUINFO *curbar;
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\listbox.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#define tmmSetFocus tmmUserMin
#define tmmDrawItem tmmUserMin+1
#define tmmSelect   tmmUserMin+2
#define tmmActivate tmmUserMin+3
#define tmmToggleSelect tmmUserMin+4
#define tmmDeselect tmmUserMin+5
#define tmmDeselectAll tmmUserMin+6
#define tmmPickUp tmmUserMin+7
#define tmmDrop   tmmUserMin+8
#define tmmExplicit	 tmmUserMin+9
#define tmmImplicit	 tmmUserMin+10
#define tmmGetItemString tmmUserMin+11
#define tmmQuerySelect tmmUserMin+12
#define tmmDeSelect tmmUserMin+13

#define WM_MOUSEIDLE     WM_USER
#define WM_DISPLAYDRIVES WM_USER+1
#define WM_SETVIEWFILE   WM_USER+2

#define TF_ISFOCUS  1
#define TF_ICONONLY 2

#define ISRANGESELECT -1
typedef struct ScrollBarData
{
    ARC rect;
    int value;
    int maxvalue;
    BOOL dragging;
    BOOL inited;
    BOOL doupdate;
    WORD mouseoffset;
}ScrollBarData;

typedef struct ListBoxData
{
    int numlinesonscreen;
    int nextlinetoupdate;
    int numlinesscrolled;
    int focusitem;
    BOOL update;
    PWND pwd;
    ARC rect;
    ScrollBarData scroll;
    BOOL inited;
	WORD (*ListProc) (WORD tmm, char *sz, WORD isz, TMC tmc,
										WORD x, WORD y, WORD bArg) ;
    WORD LastClicked;
    BOOL blank;
    char *title;
    BOOL halted;
    WORD tmc;
    BOOL stupid; /* no scroll bar or boundaries */
    BOOL hasglobalfocus;
    WORD drawahead;
    WORD drawbehind;
    WORD anchor;
    BOOL mode;	    /* implicit = TRUE;explicit = FALSE */
    BOOL alwaysexplicit; /* if cannot go into implicit mode */
	 ISA  color;
	 BYTE lastmouseX;
	 BYTE lastmouseY;
	 BYTE lastmousestate;
}ListBoxData;

#define Get_List_Focus(listbox) ((listbox)->focusitem)
#define Get_List_Window(listbox) ((listbox)->pwd)
#define Get_List_Rect(listbox) ((listbox)->rect)
#define Is_List_Captured(listbox) ((listbox)->scroll.dragging)
#define ReInit_ListBox(listbox) ((listbox)->inited=FALSE)
#define Not_Blank(listbox) ((listbox)->blank=FALSE)
#define Set_Anchor(listbox,value) (listbox)->anchor = (value)
#define Always_Explicit(listbox) {(listbox)->alwaysexplicit = TRUE; (listbox)->mode = FALSE;}
#define Set_Explicit(listbox) ((listbox)->mode = 0)
#define Halt_Listbox(listbox) ((listbox)->halted = 1)
#define UnHalt_Listbox(listbox) ((listbox)->halted = 0)
#define Set_List_Color(listbox,value) ((listbox)->color = (value))
#define Get_List_Scrolled(listbox) ((listbox)->numlinesscrolled)
#define Set_List_Focus(listbox,value) ((listbox)->focusitem = value)
#define Set_List_Scrolled(listbox,value) ((listbox)->numlinesscrolled=value)

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\iniparse\parse.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
** PARSE.H
**
**  This file defines and structures used by lex.c and iniparse.c
**
**   Date      Author	Modification
** --------   --------	------------------------------------------------
**  8/10/89   scottq	written
**
*/
/*
 * This is the definition of a TOKEN
 */
typedef int TOKEN;

/*
 * look-ahead value used by the lex.c function "match"
 */
extern TOKEN gLookahead;

/*
 * external functions
 */
char far * Get_Token_Identifier(TOKEN token);
BOOL match(TOKEN token);

void Init_ParseText(int, char far *, unsigned int, unsigned int);
TOKEN String_To_Token(char far *string,int length);
TOKEN Get_KeyWord_Assignment(TOKEN section,TOKEN variable);
TOKEN Get_Identifier_Assignment(TOKEN section,char far *identifier);
TOKEN Set_Identifier_Assignment(TOKEN section,char far *identifier,TOKEN value);
TOKEN Set_KeyWord_Assignment(TOKEN section,TOKEN variable,TOKEN value);
void Append_Symbol(TOKEN list,TOKEN entry);
TOKEN SubClassSymbol(TOKEN type);
int Get_List_Length(TOKEN list);
TOKEN Get_Ith_Element(TOKEN list,int ith);
TOKEN New_Symbol(char far *text,int length);

BOOL Write_Ini_File(char *);

#ifdef DBCS
int	IsDBCSLeadByte(unsigned char);
int	CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\prot.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

extern  VOID FARPUBLIC Shell_SetTmcText(TMC tmc, char *text);
extern  PENTRY AddFile(PTREE tree);
extern  int GetNextFile(char *path,PTREE tree,PENTRY rptr,int first, int ParentPathLength);
extern  int AddLateFile(char *path,struct fi_t far *rec,struct th_t far *tree,struct fi_t far *parent,int idx);
extern  void UpdateSiblings(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *prev,struct fi_t far *rptr);
extern  void DelFileEntry(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *node);
extern  int ChangeAttributes(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  void MakeAttrLine(unsigned char x,unsigned char y,unsigned short isz,unsigned short bArg);
extern  unsigned short pascal ListProcAttrList(unsigned short tmm,char *sz,unsigned short isz,unsigned short tmc,unsigned short x,unsigned short y,unsigned short bArg);
extern  int pascal far FDlgattr(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  int pascal far FDlguser(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void Append_Command(char far *str);
extern  void GetDialogParam(void );
extern  void UserDialog(void );
extern  void GetNextCmd(void );
extern  void ParseCmds(char far *commands);
extern  void DoCommand(char far *commands, char *startdir);
extern  unsigned char far MapToken2Color(int token,unsigned char def);
extern  void far DoSetColor(unsigned char set,int fore,int back);
extern void SelectColorGroup(int ColorSelection) ;
extern void ParseCommandLine(void);
extern  void far ColorBox(void );
extern  int pascal far FDlgcolor(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void DoCopyFiles(void );
extern  void DoMoveFiles(void );
extern  void DoRenameFiles(void );
extern  void DoDelFiles(void );
extern  void DoViewFile(void );
extern  void DoChangeAttributes(void );
extern  void DoPrintFiles(void );
extern  void DoCreateDirectory(void );
extern  int GetDestPath(char *path);
extern  int pascal far FDlgCopyFiles(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void DoFileOp(int type,char *path);
extern  void FormSelFileList(char *files,unsigned int buflen);
extern  int DisplayedFilesOk(void );
extern  int pascal far FDlgdelfiles(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void com1(char *str);
extern  void com1i(int i);
extern  void FlopMsg(unsigned short dlm);
extern  void DumpBranch(struct fi_t far *walk,int indent);
extern  void DumpSel(void );
extern  int SelCountCheck(struct th_t far *tree);
extern  int CreateDirectory(PTREE tree,PENTRY parent,char *name, BOOL fRealCreation);
extern  int PromptAndCreateDir(struct th_t far *tree,struct fi_t far *parent);
extern  int pascal far FDlgcreatdir(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  int FindAndDelDirectory(void );
extern  int DelDirectory(struct fi_t far *deldir,struct th_t far *tree,int verify);
extern  void DisplayOptions(void);
extern  int pascal far FDlgdispopt(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  BOOL MarkAllTreeMatches(struct th_t far *tree,int doit);
extern  char *MakePatWellFormed(char *pat);
extern  int PatternsEquiv(char far *pat1,char far *pat2);
extern  unsigned short pascal ListProcCritList(unsigned short tmm,char *sz,unsigned short isz,unsigned short tmc,unsigned short x,unsigned short y,unsigned short bArg);
extern  int pascal far FDlgcrit(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  int CriticalDialog(void );
extern  BOOL FDelItemDialog(char * );
extern  unsigned int shell_findfirst(char *path,unsigned int attributes,struct find_t *buffer);
extern  void DoSingleTree(void );
extern  void DoDoubleTree(void );
extern  void DoFlatDisplay(void );
extern  void DoShareMode(void );
extern  int AreAllMatchedSelected(struct fi_t far *dir,struct th_t far *tree);
extern  void EnableDisableFileOps(void );
extern  unsigned int CountTreeSelMatFiles(struct th_t far *tree);
extern  unsigned int CountDirSelMatFiles(struct fi_t far *dir,struct th_t far *tree);
extern  unsigned short pascal ListProcErrList(unsigned short tmm,char *sz,unsigned short isz,unsigned short tmc,unsigned short x,unsigned short y,unsigned short bArg);
extern  int pascal far FDlgerr(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  int GetResponse(char *statusline,char *msg,int boxtype,unsigned int helpid);
extern  int DOSErrorBox(char *statusline,unsigned short err,unsigned int helpid);
extern  char *DOSErrorMsg(int errcode,int *box);
extern  void MessageBar(char *message, ISA isa,WORD force);
extern  void FileMgrStatusBar(struct th_t far *tree,struct fi_t far *node);
extern  void InitFileMgr(void );
extern  void InitIconCache(void );
extern  void SetUpScreen(void );
extern  void DoFileMgr(void );
extern  void ExitFileMgr(void );
extern  int FileMgrIdle(void );
extern BOOL StartProgramsIdle(void);
extern  void UpdateFileTree(int set);
extern  void DrawDrive(unsigned short list,unsigned short drive, ISA highlight);
extern  struct th_t far *HighlightDrive(unsigned short list,unsigned short drive, ISA highlight);
extern  BYTE GetSelectedDrive(unsigned short list);
extern  void SelectDrive(unsigned short list,unsigned short drive);
extern  void UpdateDrives(void );
extern  void DriveListKey(unsigned short list,unsigned short key, WORD state);
extern  int DriveMouse(unsigned short mx,unsigned short my,unsigned short msg);
extern  int DeleteFile(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  int KillFile(char *statusline,char *path);
extern  int CopyFile(struct th_t far *tree,struct fi_t far *node,char *path,int count,int total,int verify);
extern  int CopyIt(struct th_t far *tree,struct fi_t far *node,char *dest,int count,int total);
extern  int MoveFile(struct th_t far *tree,struct fi_t far *node,char *path,int count,int total,int verify);
extern  int pascal far FDlgFileOpts(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void DoFileOptions(void );
extern  void DoSelectAll(void );
extern  void DeselectTree(struct th_t far *tree);
extern  void DeselectDir(PENTRY, PTREE);
extern  void DoDeselectAll(void );
extern  int RenameFile(struct th_t far *tree,struct fi_t far *node,char *prognew,int count,int total,int ask);
extern  int PrintFile(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  int pascal far FDlgRename(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void DispFlatLeft(struct fi_t far *node,struct th_t far *tree,struct _wnd *pwnd,unsigned char XTopLeft,unsigned char YTopLeft,ISA isa);
extern  void CopyNameForTextOut(char *dest,char far *src);
extern  char *CopyNumberForTextOut(char *dest,unsigned long val, BOOL fFillBlanks);
extern  int GetDiskInfo(PTREE tree,char far *disklabel,unsigned long far *disksize,
											unsigned long far *diskavail) ;
extern  unsigned int GetTreeSelectedInfo(struct th_t far *tree,unsigned long far *psize);
extern  void PlotBmp(struct BITMAP *bmp,unsigned short x,unsigned short y,ISA color);
extern  void GetBmp(struct BITMAP *bmp,unsigned short x,unsigned short y);
extern  void AllocScreen(void );
extern  void ShellSaveScreen(void );
extern  void ShellRestoreScreen(void );
extern  void FrameCharRect(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right, WORD linepat, ISA color);
extern  void FrameDialog(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right);
extern  void brokenFrameButton(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right);
extern  void NewFrameButton(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right);
extern  void FrameButton(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right);
extern  void FrameCharRectInset(unsigned short top,unsigned short left,unsigned short bottom,unsigned short right,unsigned short inx,unsigned short iny,ISA color);
extern  void EasyDrawBox(struct _wnd *pwd,unsigned char top,unsigned char left,unsigned char bottom,unsigned char right, ISA isa);
extern  void EasyDrawLine(unsigned char x1,unsigned char y1,unsigned char x2,unsigned char y2,int fdec);
extern  int RemoveQuotes(char *temp,char far *str);
extern  int AddQuotes(char *temp,char far *str);
extern  int BuildOutString(char *temp,char far *str);
extern  void InitMemory(void );
extern  unsigned short GetHandle(void );
extern  unsigned short pascal far HelpAlloc(unsigned short bytes);
extern  void pascal far HelpDeAlloc(unsigned short h);
extern  char far *pascal far HelpLock(unsigned short h);
extern  void pascal far HelpUnlock(unsigned short h);
extern  int pascal far OpenFileOnPath(char *fname,int fWrite);
extern  unsigned long pascal far ReadHelpFile(int fhandle,unsigned long fpos,char far *pData,unsigned short cbBytes);
extern  void pascal far CloseFile(int fhandle);
extern  int setupcontext(char far *constr);
extern  void HistPrev(void );
extern  void TopicPrev(void );
extern  void Next(void );
extern  void Index(void );
extern  void Contents(void );
extern  void DoNothing(void );
extern  void AccelerateInd(unsigned short code);
extern  int Tree2Path(PTREE tree,PENTRY node,char *str, int *plength);
extern  struct fi_t far *FindParent(struct fi_t far *node);
extern  int FindLastComponent(char *path);
extern  void catfname(char *dest,struct fi_t far *rcd);
extern  void FillRecName(char *path,struct fi_t far *rec);
extern  struct th_t far *FindTree(char *path, BYTE *driveind);
extern int FindNode(PTREE tree, char path[], PENTRY *theparent, PENTRY *thenode,
																	BOOL fForceFind) ;
extern  PENTRY File2Node(PTREE tree, PENTRY dir,char *file);
extern  int LoadCompactDir(PTREE tree, PENTRY new);
extern  int Internal2Normal(char far *dest,char far *src);
extern  void Normal2Internal(char far *dest,char far *src);
extern  void ScrunchFileName(char *dest,char *src, BOOL fSpecial) ;
extern  void FormCountStatusLine(char *statusline,char *szopstr,char *path,unsigned int count,unsigned int total, int indexofcnt);
extern  void Formxxofxx(char *str,int count,int total);
extern  void FormStringStatusLine(char *statusline,char *str1,char *str2, int maxlen);
extern  void far InitHistory(char *szcontext);
extern  void far AddToHistory(char *szcontext);
extern  void far InitCColor(void );
extern  void far InitGColor(void );
extern  int SetScreenMode(unsigned short mode);
extern  int far SelectScreenMode(struct _inst *inst);
extern  unsigned short far GetTheScreenMode(void );
extern  int InitializeScreen(void );
extern  void DoExit(void );
extern  int InitializeShell(void );
extern  int fstrncmp(char const far *nstr,char const far *fstr,int len);
extern  void fstrncpy(unsigned char far *d,unsigned char far *s,unsigned int len);
extern  void LaunchProgram(char far *programname,char far *parameters,int magiccookie);

extern  void far AddProgram(void);
extern  void far DelGroup(void);
extern  void far AddGroup(void);
extern  void far LaunchBox(void);
extern  void far DeleteProgram(void);
extern  void far StartAProgram(void);
extern  void far DoAssociateBox(void);
extern  void far ChangeGroup(void);
extern  void far ChangeProgram(void);
extern  void far HelpBox(void);

extern  unsigned long pascal far Pfnlaunch(unsigned short dlm,char *oof,unsigned short zong,unsigned short tmc,unsigned short wOld,unsigned short wParam);
extern  int pascal far FDlglaunch(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  unsigned short pascal far ListProcTreeList(unsigned short tmm,char *sz,unsigned short isz,unsigned short tmc,unsigned short x,unsigned short y,unsigned short bArg);
extern  unsigned short pascal far ListProcFileList(unsigned short tmm,char *sz,unsigned short isz,unsigned short tmc,unsigned short x,unsigned short y,unsigned short flags);
extern  int MakeTreeLine(struct _wnd *pwd,struct th_t far *tree,int line,unsigned char x,unsigned char y,int isfocus,int ischecked);
extern  int MakeFileLine(struct _wnd *pwnd,struct fi_t far *node,unsigned char x,unsigned char y,unsigned short flags,struct th_t far *tree);
extern  void DisplayNoFilesMsg(struct _wnd *pwd,unsigned short tmc,unsigned char xval,unsigned short y,unsigned short isz,unsigned short flags,struct th_t far *tree);
extern  PENTRY AllocTreeEntry(PTREE tree) ;
extern  PENTRY AllocTreeEntryCompactIfNeeded(PTREE tree) ;
extern  struct fi_t far *FindOpenSlot(struct th_t far *tree);
extern  unsigned int CountDirFiles(struct fi_t far *dir,struct th_t far *tree);
extern  unsigned int CountDirMatchedFiles(struct fi_t far *dir,struct th_t far *tree);
extern  void ResetTreeOptimizations(void );
extern  unsigned int CountTreeMatchedFiles(struct th_t far *tree);
extern  struct fi_t far *GetNthMatchedFile(struct fi_t far *dir,int count,struct th_t far *tree);
extern  struct fi_t far *GetNthFlatMatchedFile(struct th_t far *tree,int count);
extern  struct fi_t far *GetNthVisibleDir(struct th_t far *tree,int count);
extern  struct fi_t far *GetNthDir(struct th_t far *tree,int count);
extern unsigned GetDirInfo(PENTRY dir, PTREE tree, unsigned long *psize,
																unsigned int *pNumSelFiles) ;
extern  void JunkTree(PTREE tree);
extern  int CompactifyTree(PTREE tree,int sel);
extern  void ClobberFiles(PTREE tree);
extern  void ClobberDir(PTREE tree, PENTRY dir);
extern  void ClobberSel(PTREE tree, PENTRY parent, PENTRY curr);
extern  void PackDirs(PTREE tree);
extern  int CompactOne(int sel);
extern  void CompactAll(void );
extern  unsigned int GetIndexVisibleDir(struct fi_t far *dir,struct th_t far *tree);
extern  void SetSelectedDirFocus(void) ;

extern  unsigned int CountFilesToOperateOn(void );

extern  VOID ListBoxInit(ListBoxData *TestList,WORD (*ListProc)(),
	PWND pwd,WORD top,WORD left,WORD bottom,WORD right,char *title, 
	WORD tmc,WORD startfocusabsolute,WORD startfocusrelative);
extern  void CalcBarRect(struct ListBoxData *TestList,struct _rect *br);
extern  void CalcThumbRect(struct ListBoxData *TestList,struct _rect *tr);
extern  void DrawScrollBar(struct ListBoxData *TestList,int init);
extern  void DrawScrollBarArrow(struct ListBoxData *TestList,int UporDown);
extern  void UpdateScrollBar(struct ListBoxData *TestList,int value,int maxvalue);
extern BOOL PASCAL ScrollBarMouse(ListBoxData *TestList, WORD message);
extern  int GetNumItems(struct ListBoxData *TestList);
extern  void DoSetTitle(struct ListBoxData *TestList,char *title);
extern  void DoDrawTitle(struct ListBoxData *TestList);
extern  void SetTitle(struct ListBoxData *TestList,char *title);
extern  void FrameListBox(struct ListBoxData *TestList);
extern  void MakeListStupid(struct ListBoxData *TestList);
extern  void ListBoxHalt(struct ListBoxData *TestList);
extern  int DrawListItem(struct ListBoxData *TestList,unsigned short isz,int isfocus);
extern  void GlobalFocusBox(struct ListBoxData *TestList,int yesorno);
extern  void DoUpdateListBox(struct ListBoxData *TestList,unsigned short nlines);
extern  void QuickRedisplayList(struct ListBoxData *TestList);
extern  void DoRedisplayList(struct ListBoxData *TestList);
extern  void DoScrollListBox(struct ListBoxData *TestList,int amt,int updatenow);
extern  void FocusLineChange(struct ListBoxData *TestList,int amt);
extern  void PageDown(struct ListBoxData *TestList);
extern  void PageUp(struct ListBoxData *TestList);
extern  unsigned short Get_Focus_Line(struct ListBoxData *TestList);
extern  int ListMouse(struct ListBoxData *TestList,unsigned short x,unsigned short y,unsigned short message,int state);
extern  void InsertListItem(struct ListBoxData *TestList,unsigned short isz);
extern  void ListKey(struct ListBoxData *TestList,unsigned short key, unsigned short state);
extern  void UpdateListBox(struct ListBoxData *TestList);
extern  int ListBoxIdle(struct ListBoxData *TestList);



extern  int pascal far FDlglocate(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void far FileLocateBox(void );
extern BOOL FAR Get_Date_and_Time_Strings(unsigned int theDate, unsigned int theTime,
	  char *datestr, char *timestr, BOOL force) ;
extern  void StatusBar(struct _wnd *Wind,int init);
extern  void UpdateMainTitleBar(char *szTitle);
extern  void PauseBeforeScreenErase(void );
extern  void far SetUpStartUpDirectory(void );
extern  void cdecl main(int argc,char * *argv);
extern  void pascal far Exit(int ex);
extern  void pascal far OutOfMemory(void );
extern  void *pascal far PbAllocWork(unsigned short cb);
extern  void pascal far FreeWork(void *pv);
extern  void far *pascal far LpbAllocWorkFar(unsigned short cb);
extern  void pascal far FreeWorkFar(void far *lpb);
extern  void far * far pascal AllocFarNormalized(WORD cb) ;
extern  void far PASCAL FreeFarNormalized(VOID FAR *lpb) ;
extern  void * *pascal far PpvAllocCb(unsigned short sb,unsigned short cb);
extern  void pascal far FreePpv(unsigned short sb,void * *ppv);
extern  void mstrncpy(unsigned char *d,unsigned char *s,unsigned int len);
extern  unsigned short pascal far cbSizePpv(unsigned short sb,void * *ppv);
extern  int pascal far Fcheckhandle(unsigned short sb,void * *ppv);
extern  void * *pascal far FReAllocPpv(unsigned short sb,unsigned short * *ppv,unsigned short size);
extern  void pascal far addchildhead(void );
extern  unsigned short far *pascal far LpwAllocDriverMem(unsigned short cw,unsigned short fmem);
extern  void pascal far FreeDriverMem(unsigned short far *lpw);
extern  struct _mtm *pascal far PmtmAddItem(struct _mnu * *hmnu,unsigned short idBefore,unsigned short idNew,unsigned char *sid,struct _mnu * *hmnuSub,unsigned short cwExtra,unsigned char bFlags);
extern  void initbar(struct _mnu * * *amenu);
extern  void easyitem(struct _mnu * * *amenu,char *name,int keyequiv,int (far *theproc)());
extern  void makefakemenu(struct _mnu * * *amenu,char *name,int keyequiv,int ishelp);
extern  void makeamenu(struct _mnu * * *amenu,char *name,int keyequiv);
extern  void easyseparator(struct _mnu * * *amenu);
extern  void easyenable(struct _mnu * * *amenu,int (far *theproc)(),int doenable);
extern  void setmenubar(struct _mnu * * *amenu,struct _wnd *towind);
extern  void MenuCommand(struct _wnd *pwnd,unsigned short mid);
extern  void FrameMenu(struct _wnd *pwnd,unsigned short mid);
extern  void FrameMenuBar(struct _wnd *pwnd);
extern  void DoInitMenus(void );
extern  void InitGlobalFocus(unsigned short focusstart);
extern  void NextGlobalFocus(void );
extern  void PrevGlobalFocus(void );
extern  void FileManagerKey(unsigned short key,unsigned short state);
extern  void MouseIdle(void );
extern  long pascal far WindProc(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  void InitWindows(BOOL fFirstTime);
extern  void ScreenBox(void );
extern  void ShellSetCaption(char *sz);
extern  void DialogIsAlert(int set);
extern  unsigned long pascal far Pfndialog(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  unsigned long pascal far Pfnpanel(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  unsigned long pascal far Pfnbutton(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  unsigned long pascal far Pfneditbox(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  unsigned long pascal far Pfnfakeeditbox(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  void DrawRadios(WORD, BOOL);
extern  unsigned long pascal far Pfnradiobutton(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  unsigned long pascal far Pfnradiogroup(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long LParam);
extern  void SetUpDialog(unsigned short tmcchild,char *title);
extern  void SetUpButtonForGraphics(unsigned short tmc);
extern void SetUpCheckBox(TMC tmc) ;
extern  void SetUpEditBox(unsigned short tmc, BOOL fRealOrNot, WORD maxcount, BOOL fHasInitialFocus);
extern  void SetUpRadioGroupForGraphics(unsigned short group, TMC prevtmc, TMC nexttmc);
extern  void SetUpRadiobuttonForGraphics(unsigned short tmc,int index);
extern  void SetUpPanelForGraphics(unsigned short tmc);
extern  void SetUpNothingButton(TMC tmc) ;
extern  WORD PrevScreenMode(INST *inst,WORD curmode) ;
extern  WORD NextScreenMode(INST *inst,WORD curmode) ;

extern  int pascal far FDlgscreen(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void ShowInfo(void);
extern  int pascal far FDlgshowinfo(unsigned short dlm,unsigned short tmc,unsigned short wNew,unsigned short wOld,unsigned short wParam);
extern  void Updatesnext(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *fil,
																	BOOL fDoSortedInsertion);
extern  void snextRootNotFirstUpdate(struct th_t far *tree,struct fi_t far *fil);
extern  void snextDirFirstUpdate(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *fil);
extern  void snextDirNotFirstUpdate(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *fil);
extern  struct fi_t far *GetLeftBrother(struct th_t far *tree,struct fi_t far *dir);
extern  struct fi_t far *PrevDFSDir(struct th_t far *tree,struct fi_t far *dir);
extern  struct fi_t far *PrevSibAndDFSDir(struct th_t far *tree,struct fi_t far *dir,struct fi_t far * *prev_dfs_dir);
extern  struct fi_t far *GetLastDirFile(struct fi_t far *dir);
extern  struct fi_t far *GetFirstDirFile(struct fi_t far *dir);
extern  struct fi_t far *GetLastRootFile(struct th_t far *tree);
extern  struct fi_t far *GetFirstRootFile(struct th_t far *tree);
extern  void InsertSystemOrder(struct th_t far *tree,struct fi_t far *fil);
extern  void InsertNotRootFirst(struct th_t far *tree,struct fi_t far *fil);
extern  void InsertNotDirFirst(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *fil);
extern  void InsertAfter(struct fi_t far *fil,struct fi_t far *prev);
extern  void UpdateLatesnext(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *fil,struct fi_t far *prev, 
																	BOOL fDoSortedInsertion);
extern  void HandleDeletesnext(PTREE tree, PENTRY parent, PENTRY node);
extern  void Marklastdir(PTREE tree);
extern  int HasNoSubDir(PTREE tree, PENTRY parent);
extern  void WalkDirsnext(struct th_t far *tree,struct fi_t far *dir);
extern  void FormDirectoryOrder(struct th_t far *tree,int doit);
extern void SetUpTreeForSort(PTREE tree) ;
extern  void SystemSort(PTREE tree, int doit);
extern void SortDirectory(PTREE tree, PENTRY dir) ;
extern  int date_cmp(struct fi_t far *a,struct fi_t far *b);
extern  int size_cmp(struct fi_t far *a,struct fi_t far *b);
extern  int disk_cmp(struct fi_t far *a,struct fi_t far *b);
extern  struct fi_t far *merge(struct fi_t far *a,struct fi_t far *b);
extern  struct fi_t far *isort(PENTRY head);
extern  struct fi_t far *mergesort(PENTRY c,unsigned short n);
extern  void strfcpy(char far *dst,char far *src);
extern  void strfncpy(char far *dst,char far *src,unsigned int cnt);
extern  int pmatch(char far *pat,char far *str,unsigned char mode);
extern  void get_comspec(char *buffer);
extern  int Printable(unsigned char c);
extern  unsigned int far AllocClosestTo1K(unsigned char far * *buffer,unsigned int lowend,unsigned int highend);
extern  int ViewFile(struct th_t far *tree,struct fi_t far *node,char *unused1,int unused2,int unused3,int unused4);
extern  void far WrapUpView(void );
extern  long pascal far ViewWindProc(struct _wnd *pwnd,unsigned short message,unsigned short wParam,unsigned long lParam);
extern  long VerifyPage(long line,int ascii);
extern  long SeekFwd(long bufpos,long lines);
extern  void DisplayPage(long bufpos,unsigned char lines,int ascii);
extern  void DisplayHeader(char *file);
int name_cmp(PENTRY entry1,PENTRY entry2);
int ext_cmp(PENTRY entry1,PENTRY entry2);
int quick_name_cmp(PENTRY entry1,PENTRY entry2);
int quick_ext_cmp(PENTRY entry1,PENTRY entry2);
extern BOOL translate_name(char far *src,char far *dest);
BOOL path_len_check(char *src, PENTRY dir, int len_diff) ;

extern void SetCriticalsToFail(void);
extern int  getdrivetype(int driveno);
extern int  Check_Spooler(void) ;
extern int  a_print_file(char far *name) ;
extern int FDoQuickCompare(void) ;
extern void SetCollatingTable(void) ;

extern unsigned char far * far cdecl GET_COMMAND_PTR(void);
extern unsigned char far * far cdecl GET_ARGS_PTR(void);
extern unsigned char far cdecl GET_WAIT_FLAG(void);
extern char far *realdma_ptr;
extern char far * cdecl GET_STARTUP_NAME(VOID);

extern  void List(int parent);
extern  int Assignment(void );
extern  void SectionBody(int section);
extern  void Section(void );
extern  void inifile(void );
extern  void parse(void );
extern  int Read_Ini_File(char *inifilename);
extern  unsigned int myfstrlen(unsigned char far *s);
extern  void indent(int fhandle,int level);
extern  void write_list(int fhandle,int token,int level);
extern  void cdecl main(int argc,char * *argv);
extern  int New_Symbol(char far *text,int length);
extern  int SubClassSymbol(int type);
extern  void Append_Symbol(int list,int new);

extern TOKEN Delete_Ith_Element(TOKEN list,int ith);

extern  int Get_Ith_Element(int list,int ith);
extern  int Get_List_Length(int list);
extern  int SetGet_KeyWord_Assignment(int section,int variable,int value,int set);
extern  int Get_KeyWord_Assignment(int section,int variable);
extern  int Set_KeyWord_Assignment(int section,int variable,int value);
extern  int Get_Identifier_Assignment(int section,char far *identifier);
extern  int Set_Identifier_Assignment(int section,char far *identifier,int value);
extern  void seektoendoflexeme(void );
extern  int lexeme_cmp(char far *src,int length,char far *lexeme);
extern  int String_To_Token(char far *string,int length);
extern  int lex(void );
extern  int match(int token);
extern  int SymbolAlloc(unsigned int size);
int name_cmp(PENTRY entry1,PENTRY entry2);
int ext_cmp(PENTRY entry1,PENTRY entry2);

extern void SetCriticalsToFail(void);
extern int  getdrivetype(int driveno);
extern int  Check_Spooler(void) ;
extern int  a_print_file(char far *name) ;

extern VOID FEnableMouseNest(BOOL onoroff) ;
extern VOID FInitMouseNest(void) ;

extern void InitializeStartPrograms(void);
extern int GetAttrResponse(void);
extern VOID PutUpBusyDialog(int ith);
extern VOID TakeDownBusyDialog(int ith);
extern VOID FAR DoSearchDisplay(BOOL fInitialize) ;
extern  int MakeSearchLine(struct _wnd *pwnd,struct fi_t far *node,unsigned char x,unsigned char y,unsigned short flags,struct th_t far *tree);
extern void HandleSearchQuit(void) ;
extern BOOL PromptAndCreateDir(PTREE tree, PENTRY parent) ;
extern void FormSelFileList(char *files, unsigned buflen) ;
extern unsigned CountTotalFilesSelected(void) ;
extern int DelDirectory(PENTRY deldir, PTREE tree, BOOL verify) ;
extern void FormPseudoPathName(char *path, PENTRY node, PTREE tree) ;
extern void EnableDisableForSearchMode(BOOL doenable1, BOOL doeanble2) ;
extern void EnableDisableTreeMenu(void) ;
extern void FlushMessages(void) ;
extern BOOL IsTreeBeingBuilt(void) ;
extern void CrippleFileMenuBar(void) ;

extern BOOL AreThereSubDirs(PTREE tree, PENTRY dir) ;
extern void ExpandDirVisibility(PTREE tree, PENTRY dir, BOOL fAllLevels) ;
extern void CollapseDirVisibility(PTREE tree, PENTRY dir) ;
extern unsigned char GetCollapseChar(PTREE tree, PENTRY dirnode) ;
extern void DrawDirIcon(PWND pwd, RX x, RY y, char ch, ISA isa) ;

extern void InsertDir(PTREE tree, PENTRY parent, PENTRY dir);

extern void DoExpand1Level(void);
extern void DoExpandBranch(void) ;
extern void DoExpandAll(void) ;
extern void DoCollapse(void) ;

extern BOOL initswapin(void) ;
extern BOOL initswapout(void) ;
extern VOID DoSwapIn(void) ;
extern VOID DoSwapOut(void) ;
extern VOID endswapin(void) ;
extern VOID endswapout(void) ;
extern VOID get_temp_dir(char *buffer,BOOL UseTemp) ;

// extern BYTE FAR * NEAR PASCAL LpbSaveGraphicArc(LPFN_LPB, WORD, AX, AY, AX, AY);
// extern VOID NEAR PASCAL RestoreGraphicArc(LPFN, AX, AY, AX, AY, BYTE FAR *);

/* The following commented out line was the prototype before CW Beta 5 */
// extern BYTE FAR * FAR PASCAL LpbSaveGraphicArc(LPFN_LPB, WORD, AX, AY, AX, AY);
extern BYTE FAR * FAR PASCAL LpbSaveGraphicArc(LPFN_LPB, AX, AY, AX, AY);
extern VOID FAR PASCAL RestoreGraphicArc(LPFN, AX, AY, AX, AY, BYTE FAR *);

extern BYTE FAR *MyLpbSaveGraphicArc(LPFN_LPB pfn, WORD cbSGA, AX left, AY top,
						  AX right, AY bottom) ;
extern VOID MyRestoreGraphicArc(LPFN pfn, AX left, AY top, AX right, AY bottom,
						  BYTE FAR *lpbSGA) ;
VOID PutUpStatusMessage(char *msg, int count) ;
BOOL TakeDownStatusMessage(int count, int total) ;

extern void DrawFocusMarker(PWND pwnd, RX rxText, RY ryText, RX rxGraphics,
				RY ryGraphics, WORD len, BOOL isfocus, BOOL issel, ISA isa) ;


BOOL AllocateHcabForOutOfMem(void) ;

extern void cdecl FormStringWithoutPlaceHolders(char far *dest, char far *src, ...) ;

extern int UnixChdir(char *path) ;

extern int cdecl chdir(char *path);
extern int cdecl mkdir (char *path) ;
extern int cdecl rmdir (char *path) ;


extern void HelpBox(void);
VOID FAR PASCAL Help(WORD hem, WORD hid,VOID *pv,WORD kk);
int PASCAL TextLineLen(char far *lpText, int nMaxLen, char cEndChar);

extern TMC  MyTmcDoDlg(VOID *pdlg, HCAB hcab) ;
extern VOID ShellMessageBox(char *messagetitle, char *message) ;
extern void Convert2AbsolutePath(char *dest, char *src) ;

extern void RepeatMove(char far *dest, char far *src, unsigned int cnt);

#ifdef DBCS
extern int  IsDBCSLeadByte(unsigned char);
extern int  CheckDBCSTailByte(unsigned char *,unsigned char *);
extern unsigned char    *DBCSstrupr(unsigned char *str);
extern unsigned char    *DBCSstrchr(unsigned char *str,unsigned char c);
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\iniparse\lex.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
** LEX.C
**
**      This file holds the low-level source for a lexical analyzer.
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  8/10/89   scottq    written
**  8/13/89   scottq    re-wrote to compensate for new SYMBOL_TABLE_ENTRY
**                      definition, took out some of the stupidness,added
**                      lots of comments
**
*/

#include <common.h>
#include <assert.h>
#include <dos.h>

//#define HASHHITTEST  0
#define MAXTEXT_IN_K (2)
#define MAXTEXT (MAXTEXT_IN_K << 10)

#ifdef DBCS
unsigned char far *gParseText;  /* global pointer to text currently being parsed     */
#else
char far *gParseText;   /* global pointer to text currently being parsed     */
#endif
unsigned int gOffset;   /* this is the global text cursor in gParseText      */
unsigned int gSize;     /* gSize defines the logical EOF for gParseText      */
int gFileHandle;        /* gFileHandle is the handle to the file being read  */
TOKEN gLookahead;       /* gLookahead is the next symbol in the TOKEN stream */
BOOL gIsSpecial;
int gNumWhiteSpaces; // used to determine how much white space was skipped

char far *gTempString=NULL; /* gTempString is used if symbol table is full   */
int gTempSize = 0;      /* gTempSize is the size of gTempString              */

extern void strfcpy(char far *dst, char far *src) ;
extern void strfncpy(char far *dst, char far *src, unsigned cnt) ;
extern  void far *pascal far LpbAllocWorkFar(unsigned short cb);
extern  void pascal far FreeWorkFar(void far *lpb);
extern void RepeatMove(char far *dest, char far *src, unsigned int cnt);

#ifdef HASHHITTEST
int ghashhits = 0;
int ghashmisses = 0;
int ghashnotpresent = 0;
int gnohashnotpresent = 0;
#endif

extern  unsigned int myfstrlen(unsigned char far *s);

extern BOOL fgSymbolTableModified; /* see iniparse.c */
int lexeme_cmp(char far *src,int length,char far *lexeme);

/* INTERNATIONALIZE HERE!
    Note the following macros which may need to change.
    Be sure to try it out, since this can be kind of touchy.
*/

#define EOS '\0'
#define isEOF() (gOffset >= gSize)
#define isEOL() ((gParseText[gOffset] == '\r') || (gParseText[gOffset]=='\n'))
#define isEos(c) (c == EOS)
#define isQuote() (gParseText[gOffset] == '"')

/*
 * this macro defines characters which should be ignored as
 * equivalent to a space
 */
#ifdef DBCS
#define isWhiteSpace() (gParseText[gOffset] <= ' ')
#else
#define isWhiteSpace() ((unsigned char)gParseText[gOffset] <= ' ')
#endif

/*
 * this macro defines character which are separator characters to the lexer--
 * see "seektoendoflexeme" for effect of separators
 */
#if 0
#define isSeparator() (((gParseText[gOffset] < 'A') && (gParseText[gOffset] > '9')) || \
		       ((gParseText[gOffset] > 'Z') && (gParseText[gOffset] < 'a')) || \
		       ((gParseText[gOffset] > 'z') || (gParseText[gOffset] < '0')))
#endif
#define isSeparator() ((gParseText[gOffset] == '=') || (gParseText[gOffset] == '%') || \
((gParseText[gOffset] > 'z') && (gParseText[gOffset] <= '~')) || ((gParseText[gOffset] >= '/')&&(gParseText[gOffset] <= ':') || (gParseText[gOffset] == '\\')) || \
(gParseText[gOffset] <= ' ') || (gParseText[gOffset] == '[')|| (gParseText[gOffset] == ']'))


/*
 * this macro moves the global text cursor (gOffset) to the first
 * non-white space in the text (or EOF)
 */
#define eatWhiteSpace() while((!isEOF()) && isWhiteSpace()) ++gOffset;

#define PRIMEHASHBYTES 1061

WORD HashTable[PRIMEHASHBYTES] ;

/* Accepts a string and calculates a HASH value based on it. length is the
 * length of the string passed in. If it is -1, it implies that the string
 * is NULL-terminated.
 * This function was stolen from the DRAGON-BOOK! -- fn haspjw()
 */
WORD Hash(char far *lexeme,int length)
{
	int i;
	WORD retval;

	i = 0;
	retval = 2053;
	if(length == -1)
		length = 32000;

	while(lexeme[i] && i < length)
	{
		retval += (lexeme[i]);
		++i;
	}
	return(retval % PRIMEHASHBYTES);
} /* Hash */

/* This function accepts a HASH-index and sets/gets (depending on "setorget")
 * the symbol table index for this HASH-index.
 * The value "SymbolTableInd" is used only when we want to add this index
 * to the Hash Table.
 * Also, if more than 1 lexeme has the
 * same HashInd and this function is called to perform a "set", only
 * the first entry gets into the symbol table!
 */
int Set_Get_HashBin(int HashInd, BOOL setorget,int SymbolTableInd)
{
	int retval;

	assert(HashInd < PRIMEHASHBYTES) ;

	retval = (int) HashTable[HashInd];

	if ((setorget) && (retval == -1))
	   retval = HashTable[HashInd] = SymbolTableInd;

	return(retval);
} /* MarkHashBin */

/* Mark the Bit hash table with only lexemes that are initially present in
 * "symbols.c"
 */
void Init_Symbol_Hash(void)
{
	int i;
	static BOOL fInited = FALSE;

	if(fInited)
		return;
	fInited = TRUE;

	for (i = 0 ; i < PRIMEHASHBYTES ; i++)
		HashTable[i] = -1 ;

	for(i=0;i<Get_Num_Tokens();i++)
    {
		/*
		 * we only check the symbols who own their own lexmes--
		 * symbols which are not a subclass of another symbol
		 */
		if (Get_Symbol_Type(Token_To_Symbol(Ith_Token(i))) == Ith_Token(i))
		{
		   Set_Get_HashBin(Hash(Get_Token_Identifier(Ith_Token(i)),-1), TRUE,Ith_Token(i));
		}
    }

} /* Init_Symbol_Hash */

/*  NAME
 *      New_Symbol
 *  DESCRIPTION
 *      Create a new symbol in the symbol table for the lexeme at
 *  text. The lexeme will include all character in text up to length.
 *  ARGUMENTS
 *      text is a far pointer to a string. The string does not have
 *  to be null terminated.
 *      length is the length of the string at text.
 *  RETURN VALUE
 *      returns a TOKEN belonging to the new symbol--this token is used
 *  to reference the new symbol.
 *  EFFECTS
 *      calls external function SymbolAlloc to allocate far memory for the
 *  new symbol.
 *  STATE
 *  COMMENTS
 *      This is mainly an internal routine used by "lex" when it needs to
 *  create a new symbol.
 *  WARNINGS
 *      Be sure to set the type before getting a pointer to the lexeme, since
 *  Get_Symbol_Lexeme uses the type to determine the actual lexeme.
 *      Length may not be less than 1!
 *  HACKS
 */
TOKEN New_Symbol(char far *text,int length)
{
    SYMBOL_TABLE_ENTRY far *NewEntry; /* temporary pointer to new symbol     */
    TOKEN retval;                     /* return value is the symbol's token   */
    char far *lexeme;                 /* pointer to lexeme inside the symbol */


    /* first allocate the symbol, get a pointer to it */
    retval = SymbolAlloc(sizeof(SYMBOL_TABLE_ENTRY) + length + 2);
    NewEntry = Token_To_Symbol(retval);

    /* if the new symbol allocation succeeded, set its lexeme and initialize
     * it's type, value, and next fields
     */
    if(retval == TK_NOTHING) {
        if(gTempSize <= length) {
            if(gTempString)
                FreeWorkFar(gTempString);
            if(!(gTempString=(char far *)LpbAllocWorkFar(length+1))) {
                gTempSize = 0;
                return(retval);
            }
            gTempSize = length + 1;
        }

        RepeatMove(gTempString, text, length);
        gTempString[length] = EOS;
    } else {
       /* all newly allocated symbols with unique lexemes should have
	* a type equal to itself--type defines the symbol which holds
	* its lexeme's text
	*/
       Set_Symbol_Type(NewEntry,retval);
       /*
	* Value is set to TK_NOTHING to indicate no value initially
	*/
       Set_Symbol_Value(NewEntry,TK_NOTHING);
       /*
	* The Next field should be set to TK_NOTHING as well to indicate
	* that this symbol is not now a list.
	*/
       Set_Symbol_Next(NewEntry,TK_NOTHING);

       /* WARNING: do not get_symbol_lexeme without first setting type! */
       lexeme = Get_Symbol_Lexeme(NewEntry);
        RepeatMove(lexeme, text, length);
	   lexeme[length] = EOS;

	   Set_Get_HashBin(Hash(lexeme,length), TRUE,retval) ;
	}

    /* If we get here, we failed to allocate a new symbol, reflected by
     * retval's value == TK_NOTHING
	*/
    return(retval);
}

/*  NAME
 *      SubClassSymbol
 *  DESCRIPTION
 *      Creates a new new symbol with a type field equal to "type".
 *  Thus, a subclass of the symbol belonging to "type" is created.
 *  ARGUMENTS
 *      type is a TOKEN that belongs to the symbol being subclassed.
 *  RETURN VALUE
 *      a TOKEN belonging to the newly allocated symbol.
 *  EFFECTS
 *  EFFECTS
 *      calls external function SymbolAlloc to allocate far memory for the
 *  new symbol.
 *  STATE
 *      none
 *  COMMENTS
 *      This call is used by external routines to create two(or more)
 *  symbols each with the same lexeme, but different values. Used for
 *  member of lists.
 *  WARNINGS
 *  HACKS
 */
TOKEN SubClassSymbol(TOKEN type)
{
    SYMBOL_TABLE_ENTRY far *NewEntry;   /* temporary pointer to new symbol   */
    TOKEN retval;                       /* return value is the symbol's token */

     /* first allocate the symbol, get a pointer to it */
    retval = SymbolAlloc(sizeof(SYMBOL_TABLE_ENTRY)+2);
    NewEntry = Token_To_Symbol(retval);
    /* if the new symbol allocation succeeded, set its lexeme and initialize
     * it's type, value, and next fields
     */
    if (retval != TK_NOTHING)
    {
       /*
	* Type is set to the value passed in--the new symbol will have
	* lexeme of the type
	*/
       Set_Symbol_Type(NewEntry,type);
       /*
	* Value is set to TK_NOTHING to indicate no value initially
	*/
       Set_Symbol_Value(NewEntry,TK_NOTHING);
       /*
	* The Next field should be set to TK_NOTHING as well to indicate
	* that this symbol is not now a list.
	*/
       Set_Symbol_Next(NewEntry,TK_NOTHING);
    }
    /* If we get here, we failed to allocate a new symbol, reflected by
     * retval's value == TK_NOTHING
	 */
	fgSymbolTableModified = TRUE;
    return(retval);
}

/*  NAME
 *      Append_Symbol
 *  DESCRIPTION
 *      Appends a symbol to a list (or atomic symbol if not already a list).
 *  ARGUMENTS
 *      list is a TOKEN belonging to the list which is being appended to
 *      new is a TOKEN belonging to the symbol which is being appended
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      This is used by external routines to add a symbol element to a list.
 *  Note that the list may be an atomic element--appending to one of these
 *  turns the atomic element into a list by changing it's next field to
 *  be the "new" token.
 *  WARNINGS
 *  HACKS
 */
void Append_Symbol(TOKEN list,TOKEN new)
{
   SYMBOL_TABLE_ENTRY far *entry;   /* temporary pointer to list symbol   */

   entry = Token_To_Symbol(list);   /* Get a pointer to list's symbol     */
   /*
    * 'seek' to the end of the list--ie, find the first link with a next
    * field of TK_NOTHING
    */
   while( (Get_Symbol_Next(entry) != TK_NOTHING))
   {
       /*
	* set entry to the next of entry--until next is TK_NOTHING
	*/
       entry = Token_To_Symbol(Get_Symbol_Next(entry));
   }
   /*
    * put the "new" symbol onto the end of the list by setting the
    * last element in the list's next field to the new TOKEN
    */
   Set_Symbol_Next(entry,new);
   fgSymbolTableModified = TRUE;
}

/*
 * Recursively duplicate the symbols belonging to a token, and
 * return a new token to that list
 */
TOKEN Duplicate_Token(TOKEN tkSrc)
{
    TOKEN tkSrcVal, tkDst, tkDstNew, tkDstLast;
    SYMBOL_TABLE_ENTRY far *sySrc; 
    SYMBOL_TABLE_ENTRY far *syDst1;

    if((tkDst=SubClassSymbol(tkSrc)) < 0)
	goto Error1;
    tkDstLast = tkDst;

    sySrc = Token_To_Symbol(tkSrc);
    while((tkSrc=Get_Symbol_Next(sySrc)) != TK_NOTHING) {
	sySrc = Token_To_Symbol(tkSrc);
	tkSrcVal = Get_Symbol_Value(sySrc);
	if((tkDstNew=SubClassSymbol(tkSrc)) < 0)
	    return(TK_NOTHING);

	syDst1 = Token_To_Symbol(tkDstNew);
	if(tkSrcVal>0 && Get_List_Length(tkSrcVal) > 1) {
	    Set_Symbol_Value(syDst1, Duplicate_Token(tkSrcVal));
	} else {
	    Set_Symbol_Value(syDst1, tkSrcVal);
	}
	Set_Symbol_Type(syDst1, Get_Symbol_Type(sySrc));

	Append_Symbol(tkDstLast, tkDstNew);
	tkDstLast = tkDstNew;
    }

    fgSymbolTableModified = TRUE;
Error1:
    return(tkDst);
}

void Insert_Symbol(TOKEN list,TOKEN new,int i)
{
   int n;
   SYMBOL_TABLE_ENTRY far *entry;   /* temporary pointer to list symbol   */

   entry = Token_To_Symbol(list);   /* Get a pointer to list's symbol     */
   /*
    * 'seek' to the end of the list--ie, find the first link with a next
    * field of TK_NOTHING
	*/
   for(n=0;n<i;n++)
   {
		if (Get_Symbol_Next(entry) == TK_NOTHING)
			return;
       /*
		* set entry to the next of entry--until next is TK_NOTHING
		*/
       entry = Token_To_Symbol(Get_Symbol_Next(entry));
   }
   /*
    * put the "new" symbol onto the end of the list by setting the
    * last element in the list's next field to the new TOKEN
    */
   Set_Symbol_Next(Token_To_Symbol(new),Get_Symbol_Next(entry));
   Set_Symbol_Next(entry,new);
   fgSymbolTableModified = TRUE;
}


#ifdef ALLOWRELEASE
/*  NAME
 *      FreeList
 *  DESCRIPTION
 *      Frees all symbols in the list
 *  ARGUMENTS
 *      TOKEN to a list
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      frees global memory
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *      This routine does not remove the list from other lists; future
 *  references to list will be bogus!
 *      This routine is recursive!
 *  HACKS
 *      Does not free things with strings in them; should keep track
 *  of reference count so we can do this
 */
void FreeList(TOKEN list)
{
   SYMBOL_TABLE_ENTRY far *entry;   /* temporary pointer to list symbol   */
   SYMBOL_TABLE_ENTRY far *next;   /* temporary pointer to list symbol   */
   TOKEN tokenlast = list;

   if(list > 0)
   {
      entry = Token_To_Symbol(list);   /* Get a pointer to list's symbol     */
      while( (Get_Symbol_Next(entry) > 0))
      {
	  next = entry;
	  tokenlast = Get_Symbol_Next(entry);
	  entry = Token_To_Symbol(tokenlast);
	  FreeList(next);
      }
       /* if type is the same as this token, the the symbols has a string
       that might be referenced somewhere, so don't really delete it*/
	  if(tokenlast == Get_Symbol_Type(entry))
	 fgSymbolTableModified = TRUE;
	 FreeSymbol(entry);
   }
}
#else
#define FreeList(list)
#endif

/*  NAME
 *      Get_Ith_Element
 *  DESCRIPTION
 *      given a list, return the i'th element in the list
 *  ARGUMENTS
 *      list is a TOKEN belonging to the head of a list
 *  RETURN VALUE
 *      TOKEN value of the i'th element in list.
 *      If ith==0 then return list
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      Used by external functions to access the (effective) linked list
 *  in an array-style fashion.
 *  WARNINGS
 *      List begin with element number 1, not 0!
 *  HACKS
 */
TOKEN Get_Ith_Element(TOKEN list,int ith)
{
      int i;
      SYMBOL_TABLE_ENTRY far *entry; /* temporary pointer to list symbol   */

      if (list <= 0)
	    return(TK_NOTHING);
      if(ith == 0)
	return(list);
      /* get a pointer to the list's symbol */
      entry = Token_To_Symbol(list);
      /* 'seek' to the i'th element */
      for(i=1;i < ith;i++)
      {
	  /* set entry to its next symbol */
	  entry = Token_To_Symbol(Get_Symbol_Next(entry));
	  /* if we reach the end of the list before we reach
	   * the i'th one, return TK_NOTHING
	   */
	  if (Get_Symbol_Next(entry) < 0)
	    return(TK_NOTHING);
      }
      /*
       * We have 'seeked' to the i'th element, which is in
       * next of the temporary 'entry'
       */
      return(Get_Symbol_Next(entry));
}

/*  NAME
 *      Delete_Ith_Entry
 *  DESCRIPTION
 *      Deletes the ith element of a list
 *  ARGUMENTS
 *      TOKEN list is the list, ith is the index of the element to be deleted
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      frees global memory
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
TOKEN Delete_Ith_Element(TOKEN list,int ith)
{
      TOKEN preventry;
      TOKEN thisentry;
      TOKEN nextentry;

      if((list > 0)&&(ith>0))
      {
	 preventry = Get_Ith_Element(list,ith-1);
	 if(preventry > 0)
	 {
	       thisentry = Get_Symbol_Next(Token_To_Symbol(preventry));
	       if(thisentry > 0)
	       {
		  nextentry = Get_Symbol_Next(Token_To_Symbol(thisentry));
		  Set_Symbol_Next(Token_To_Symbol(preventry),nextentry);
		  fgSymbolTableModified = TRUE;
		  FreeList(thisentry);
	       }
	 }
     }
     return(TK_NOTHING);
}


/*  NAME
 *      Get_List_Length
 *  DESCRIPTION
 *      returns the number of elements in the list
 *  ARGUMENTS
 *      list is a TOKEN to a list of symbols
 *  RETURN VALUE
 *      number of elements in the list
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *      This code does an infinite loop which breaks when
 *  the end of a list is found.
 *  HACKS
 */
int Get_List_Length(TOKEN list)
{
      int i = 0;
      SYMBOL_TABLE_ENTRY far *entry;  /* temporary pointer to list symbol   */

       /* get a pointer to the list's symbol */
      if((entry = Token_To_Symbol(list)) < 0)
				return(0);

		if(Get_Symbol_Next(entry) < 0) // no next
				return(0);

      do
      {
			++i;
			/* traverse the list until we get to the end--next is TK_NOTHING
		 * return how many times we went through this loop
		 */
			if (entry < 0)
				return 0 ;
			entry = Token_To_Symbol(Get_Symbol_Next(entry));
			if (Get_Symbol_Next(entry) == TK_NOTHING)
			return(i);
      }
      while(TRUE);  /* go forever!!! */

}

extern char *NullString;
/*  NAME
 *       Init_ParseText
 *  DESCRIPTION
 *       Sets up global structure for parsing text
 *  ARGUMENTS
 *       size is the length of the text
 *       text is a far point to the beginning of the text to be parsed
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      changes globals used by parsing routines
 *  STATE
 *  COMMENTS
 *      gOffset is a cursor used to indicate how far we have
 *      scanned into the text
 *  WARNINGS
 *      Since the parsing routines use these globals, the parse code
 *      cannot be re-entrant!
 *  HACKS
 */
void Init_ParseText(int fHandle, char far *text,
        unsigned int offset, unsigned int size)
{
    gFileHandle = fHandle;
    gParseText = text;
    gOffset = offset;
    gSize   = size;

    Init_Symbol_Hash() ;
}

#if 0
/*  NAME
 *      Get_Token_Identifier
 *  DESCRIPTION
 *      Given a token, returns the lexeme associated with it.
 *  ARGUMENTS
 *      token in question
 *  RETURN VALUE
 *      far pointer to the lexeme text (null terminated)
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      The grunt work is done in external routine 'Get_Symbol_Lexeme'
 *  WARNINGS
 *      Does not check to see if token is really a list! Lists return
 *  undefined strings!
 *  HACKS
 */
char far * Get_Token_Identifier(TOKEN token)
{
	if((token >=0) && (token <Get_Num_Tokens()))
	{
	   return(Get_Symbol_Lexeme(Token_To_Symbol(token)));
	}
	Beep();
	return(NullString);
}
#endif
extern BOOL fIsSpecialToken(TOKEN section, TOKEN tok) ;

/*  NAME
 *      SetGet_KeyWord_Assignment
 *  DESCRIPTION
 *      returns the value assignment to a token in list section;
 *      will set the value if set is TRUE, returns same.
 *      if section is TK_NOTHING, returns global assignment of the variable
 *      subclass.
 *  ARGUMENTS
 *      section is a token to a list of symbols to look for "variable" elements
 *      variable is the subclass (see SubClassSymbol) of in section we are
 *      looking for
 *  RETURN VALUE
 *      the value of the variable symbol in section list
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      This is a common engine to several calls which manipulate the
 *  value of symbols
 *  WARNINGS
 *      This code has an infinite loop in it.
 *  HACKS
 */
TOKEN SetGet_KeyWord_Assignment(TOKEN section,TOKEN variable,TOKEN value,int set)
{
    SYMBOL_TABLE_ENTRY far *entry; /* temporary pointer to symbols */
    SYMBOL_TABLE_ENTRY far *preventry; /* temporary pointer to symbols */
    TOKEN newsym;
    /*
     * if we are looking for the value of a subclassed variable
     */
    if ((section != TK_NOTHING))
    {
	  /* get a pointer to the section's list head */
	  preventry = entry = Token_To_Symbol(section);
	  /*
	   * walk the list until we find an element with the
	   * same type as what we are looking for--return it's value
	   */
	  do
	  {
	      if (Get_Symbol_Type(entry) == variable)
	      {
		  /*
		   * we have found the right element, now set the
		   * value if appropriate
		   */
		  if (set)
		  {
			 if(value==TK_UNKNOWN && preventry!=entry) {
/* Remove the symbol from the list */
				Set_Symbol_Next(preventry, Get_Symbol_Next(entry));
				fgSymbolTableModified = TRUE;
			 } else if(Get_Symbol_Value(entry) != value)
			 {
				/* If variable, is a special variable, it is a candidate
				 * that would be modified several times but one that
				 * could eventually end up with the same value it had at
				 * start up. We check for these changes at the time we try to
				 * write INI file out!
				 */
				if (!fIsSpecialToken(section, variable))
					fgSymbolTableModified = TRUE;
				Set_Symbol_Value(entry,value);
			 }
		  }
		  /*
		   * return the value of the symbol found
		   */
		  return(Get_Symbol_Value(entry));
	      }
	      /*
	       * check to see if we have reached the end of the list--
	       * if so, we cannot find the variable so return TK_UNKNOWN
	       */
	      if (Get_Symbol_Next(entry) == TK_NOTHING)
	      {
		   if(set && value!=TK_UNKNOWN)
		   {
			newsym = SubClassSymbol(variable);
			if(newsym)
			{
				Set_Symbol_Value(Token_To_Symbol(newsym),value);
				Append_Symbol(section,newsym);
				fgSymbolTableModified = TRUE;
				return(newsym);
			}
		   }
		   return(TK_UNKNOWN);
	      }
	      /*
	       * set entry to point to the next symbol in the list
	       */
	      preventry = entry;
	      entry = Token_To_Symbol(Get_Symbol_Next(entry));
	  }
	  while(TRUE);
    }
    else
    {
	/* The value is not a subclassed variable--find the global value */
       entry = Token_To_Symbol(variable);
       /*
	* set the value if approprate
	*/
       if (set)
	  Set_Symbol_Value(entry,value);
       /*
	* return the value of the entry
	*/
       return(Get_Symbol_Value(entry));
    }
}

/*  NAME
 *      Get_KeyWord_Assignment
 *  DESCRIPTION
 *      Given a list and a subclass, find the value of the the subclassed
 *      variable in the list.
 *  ARGUMENTS
 *      section is a token to the list
 *      variable is the token of the subclassed symbol we are looking for
 *  RETURN VALUE
 *      value of the variable
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      this should probably be a macro, since it just calls one funcion.
 *  WARNINGS
 *  HACKS
 */
TOKEN Get_KeyWord_Assignment(TOKEN section,TOKEN variable)
{
      return(SetGet_KeyWord_Assignment(section,variable,TK_NOTHING,FALSE));
}

/*  NAME
 *      Set_KeyWord_Assignment
 *  DESCRIPTION
 *      Given a list and a subclass, set the value of the the subclassed
 *      variable in the list.
 *  ARGUMENTS
 *      section is a token to the list
 *      variable is the token of the subclassed symbol we are looking for
 *  RETURN VALUE
 *      new value of the variable
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      this should probably be a macro, since it just calls one funcion.
 *  WARNINGS
 *  HACKS
 */
TOKEN Set_KeyWord_Assignment(TOKEN section,TOKEN variable,TOKEN value)
{
      return(SetGet_KeyWord_Assignment(section,variable,value,TRUE));
}

/*  NAME
 *      Get_Identifier_Assignment
 *  DESCRIPTION
 *      Given a token to a list, find a the value of a symbol in
 *      the list with a lexeme the same as "*identifier"
 *  ARGUMENTS
 *      section is a token to a list
 *      identifier is a far pointer to a string which is the lexeme we
 *      are looking for
 *  RETURN VALUE
 *      a token value of the subclass of the identifier
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *     The grunt work of this code is done in "Get_KeyWord_Assignment"
 *  WARNINGS
 *     See warnings on Get_Keyword_Assignment!
 *  HACKS
 */
TOKEN Get_Identifier_Assignment(TOKEN section,char far *identifier)
{
    TOKEN identtoken;
    identtoken = String_To_Token(identifier,-1);
    if (identtoken != TK_UNKNOWN)
    {
       return(Get_KeyWord_Assignment(section,identtoken));
    }
    return(TK_UNKNOWN);
}

TOKEN Get_Identifier_Token(char far *identifier)
{
#if 0
	TOKEN identtoken;
#endif

	int identlen;

	identlen = myfstrlen(identifier);
		if(identlen <= 0)
			return(TK_NOTHING);


#if 1
	return New_Symbol(identifier, identlen) ;
#else
   identtoken = String_To_Token(identifier,-1);
	if(identtoken >= 0)
	{                                                                                                                       
		/* bug bug this was once required..?? */
		//if(lexeme_cmp(identifier,identlen,Get_Token_Identifier(identtoken)))
		//{             
				return(SubClassSymbol(identtoken));
		//}else
		//      Beep();
	}
	identtoken = New_Symbol(identifier,identlen);
	return(identtoken);
#endif
}

/*  NAME
 *      seektoendoflexeme
 *  DESCRIPTION
 *      moves the text cursor to the end of the lexeme it is currently
 *      positions at
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      changes gOffset, the text cursor
 *  STATE
 *  COMMENTS
 *      this is used by "lex" to find lexemes
 *      a lexeme is defined here to be anything between
 *      quotes, or from the cursor to the next separator character,
 *      or simply one separator character if the cursor is at a separator
 *  WARNINGS
 *      this code is not able to be re-entrant
 *  HACKS
 */
void seektoendoflexeme(void)
{
	/* special case for variables that end at a line boundary  only */
	if(gIsSpecial)
	{
	   while((!isEOF()) && !isEOL())
	       ++gOffset;
	}
	else
	/*
	 * if the cursor is at a separation character, treat that
	 * character as a lexeme of it's own
	 */

	if (isSeparator())
	{
	    /* just skip over the separtor */
	    ++gOffset;
	    return;
	}
	else
	/* scan along until we find a separator character or EOF */
	{
	   while((!isEOF()) && !isSeparator() )
#ifdef DBCS
	   {
		if (IsDBCSLeadByte(gParseText[gOffset]))
			++gOffset;
		++gOffset;
	   }
#else
	       ++gOffset;
#endif
	}
}

/*
 * length of -1 means string is null terminated
 */

/*  NAME
 *     lexeme_cmp
 *  DESCRIPTION
 *     compares two strings to see if they are equal. one string
 *     is null terminated (the lexeme), the other (src) has a length
 *     of length, or is null-terminated if length is -1
 *  ARGUMENTS
 *     src is a pointer to a string
 *     length is the length of the src string, -1 if src is null-terminated
 *     lexeme is a null-terminated string
 *  RETURN VALUE
 *     TRUE if strings are equal, FALSE otherwise
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *     The code is divided into to segments for speed--one if src is
 *     null terminated, the other if length is not -1
 *  WARNINGS
 *  HACKS
 */
int lexeme_cmp(char far *src,int length,char far *lexeme)
{
	 int i;

    if (length == -1)
    {
	/*
	 * basic string compare
	 */
	while(*src == *lexeme)
	{
	    if (*src == EOS)
		return(TRUE);
	    ++src;
	    ++lexeme;
	}
	return(FALSE);
    }
    else
    {
		if(lexeme[length] == 0)
		{
			for(i=length-1;i>=0;i--)
			{
				if(src[i] != lexeme[i])
					return(FALSE);
			}
			return(TRUE);
		}
		return(FALSE);
#if 0
	/*
	 * strncmp with a twist: we must be at the end of
	 * lexeme so we are sure src is not just a sub-string
	 * of lexeme
	 */
	while (length && (*src == *lexeme))
	{
	   length--;
	   ++src;
	   ++lexeme;
	}
	return((!length) && (*lexeme == EOS));
#endif
    }
}


/*
 * length of -1 means string is null terminated
 */
/*  NAME
 *      String_To_Token
 *  DESCRIPTION
 *      Given a string of length "length", or null-terminated if length = -1,
 *      returns a token to the a symbol with a lexeme equal to string
 *  ARGUMENTS
 *      string is a far string, null-terminated if length = -1
 *      length is the length of string, or -1 if string is null-terminated
 *  RETURN VALUE
 *      a TOKEN belong to a symbol whose lexeme is the same as string
 *      TK_UNKNOWN if no symbol has a lexeme equal to string
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *      This routine is used internally by "lex", but may also be used
 *      by external routines
 *  WARNINGS
 *  HACKS
 */
TOKEN String_To_Token(char far *string,int length)
{
   int i,j;
	int NumTokens;
	int hashind;
	char far *identifier;

#ifdef HASHHITTEST
	char nearstr[100] ;
	if (length == -1)
		strfcpy(nearstr, string) ;
	else
	{
		strfncpy(nearstr, string, length) ;
		nearstr[length] = '\0' ;
	}
#endif
    if((length ==0) || (*string == '\r') || (*string == '\n'))
	return(TK_NOTHING);
    /*
     * query external symbol table function for the number of tokens
     * in the symbol table
     */
    NumTokens = Get_Num_Tokens();
    /*
     * for each token which has it's own type (has a lexeme defined
     * within its symbol instead of being subclassed), check to
     * see if it's lexeme is the same as string
	 */
	hashind = Set_Get_HashBin(Hash(string,length), FALSE,-1);

	if(hashind != -1)
	{
		/* Check if this string is same as string, In case of collisions
		 * on the hash this could fail.
		 */

			identifier = Get_Token_Identifier(Ith_Token(hashind));
			if(identifier[length] == 0)
		   {
				for(j=length-1;j>=0;j--)
				{
					if(string[j] != identifier[j])
						goto hashmiss;
				}
#ifdef HASHHITTEST
				++ghashhits;
#endif
				return(Ith_Token(hashind));
			}
	}
	else
	{

#ifdef HASHHITTEST
			++ghashnotpresent;
#endif
		/* this item does not map to a filled-in hash entry.
		 * if the total number of items < PRIMEHASHBYTES then
		 * the item just don't exist in the table at all.
		 */
		return(TK_UNKNOWN);
	}
hashmiss:
#ifdef HASHHITTEST
	++ghashmisses;
#endif
	/* If we are here, the HASH failed, so search the whole list */
	for(i=0;i<NumTokens;i++)
	{
		/*
		 * we only check the symbols who own their own lexmes--
		 * symbols which are not a subclass of another symbol
		 */
		if (Get_Symbol_Type(Token_To_Symbol(Ith_Token(i))) == Ith_Token(i))
		{
			identifier = Get_Token_Identifier(Ith_Token(i));
			if(identifier[length] == 0)
		   {
				for(j=length-1;j>=0;j--)
				{
				if(string[j] != identifier[j])
					goto wrongo;
				}
				return(Ith_Token(i));
			}
		}
wrongo:
		;
	}

    /*
     * could not find a symbol which lexeme equal to string
     */
#ifdef HASHHITTEST
	++gnohashnotpresent;
#endif
    return(TK_UNKNOWN);
}

/*  NAME
 *      lex
 *  DESCRIPTION
 *      retuns a token for the next lexeme in the text, and moves up
 *      the text cursor.
 *      if the lexeme encounter has no existing symbol, lex creates
 *      a symbol for it and returns its TOKEN
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      a TOKEN value for the lexeme encountered
 *  EFFECTS
 *      moves the text cursor
 *  STATE
 *  COMMENTS
 *      lex is called by "match"
 *  WARNINGS
 *      this code may not go re-entrant!
 *  HACKS
 */
TOKEN lex(void)
{
    TOKEN rettoken;
    int start;

/* Check if we are near the end of what we have read from the text file,
 * and we have not hit EOF, and there is a file
 */
    if(gOffset>gSize-MAXTEXT && gSize>MAXTEXT && gFileHandle) {
        gSize -= MAXTEXT;
        gOffset -= gSize;

/* Move high memory low, and refill high memory from the file */
        RepeatMove(gParseText, gParseText+gSize, MAXTEXT);
        if(_dos_read(gFileHandle, gParseText+MAXTEXT, gSize, &gSize))
            gSize = MAXTEXT;
        else
            gSize += MAXTEXT;
    }

    /*
     * skip text cursor over all white space before the next valid lexeme
     */
    if(!gIsSpecial)
    {
		/* remember how many white spaces we skipped */
		 gNumWhiteSpaces  = gOffset;
       eatWhiteSpace();
		 gNumWhiteSpaces        = gOffset - gNumWhiteSpaces;
    }
    else
    {
	/*
	 * Things after '=' can be a newline, indicating nothing value
	 */
	while((!isEOF()) && (isWhiteSpace() && !isEOL()))
	 ++gOffset;

/* Skip a beginning quote */
        if(isQuote())
            ++gOffset;
    }

    if (!isEOF())
    {
	/*
	 * text cursor gOffset is at the beginning of a lexeme--remember
	 * location
	 */
	start = gOffset;
	/*
	 * move text cursor to end of this lexeme
	 */
	seektoendoflexeme();
	/*
	 * look up a symbol with the same lexeme
	 */
	rettoken = String_To_Token(&gParseText[start],gOffset-start);
	/*
	 * if we found a symbol for this lexeme, return it's TOKEN
	 */
	if (rettoken != TK_UNKNOWN)
	{
	    return(rettoken);
	}
	else
	{
	    /*
	     * make a new symbol for this lexeme
	     */
	    return(New_Symbol(&gParseText[start],gOffset-start));
	}
    }
    else
    {
	/*
	 * we have reach the End-Of-File, so return special
	 * EOF TOKEN
	 */
	return(TK_EOF);
    }
}

/*  NAME
 *      match
 *  DESCRIPTION
 *      checks to see if the next lexeme in is the same as "token".
 *      if so, peeks ahead for the next lexeme, otherwise just returns
 *  ARGUMENTS
 *      token value of the next lexeme to match
 *  RETURN VALUE
 *      TRUE if the token is matched
 *      FALSE if the token is no matched
 *  EFFECTS
 *      when token is matched, moves global text cursor gOffset
 *  STATE
 *  COMMENTS
 *      this is basically the canonical match function
 *      the very first call to match should be with a token
 *      of TK_WILD which forces a match. This is because
 *      match has to look ahead a token
 *  WARNINGS
 *  HACKS
 */
BOOL match(TOKEN token)
{
    /*
     * if we have found the token we expect, eat it and continue
     * always match the TK_WILD token
     */
    if ((token == gLookahead) || (token == TK_WILD))
    {
     /* special case for variables that end only at eol */
	if(token == TK_EQUALS)
	    gIsSpecial = TRUE;
	else
	    gIsSpecial = FALSE;
	gLookahead = lex();
	return(TRUE);
    }
    /* failed to find the token we expect! */
    return(FALSE);
}

#ifdef DBCS
/*
	Test if the character is DBCS lead byte

	input:  c = character to test
	output: TRUE if leadbyte
*/

int     IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;

	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;

	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;           /* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return FALSE;
}


/*
	Check if the character point is at tail byte

	input:  *str = strart pointer of the string
		*point = character pointer to check
	output: TRUE if at the tail byte
*/

int     CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\iniparse\symbols.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
** SYMBOLS.H
**
**  This file holds token values for the symbol table in symbols.h
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  8/10/89   scottq    written
**  8/13/89   scottq    made new definition of SYMBOL_TABLE_ENTRY
**
*/

/*
 * The following are special tokens with special meanings
 * WARNING! do not alter these values unless you really know whats up
 */
#define TK_EOF     -1    /* End-Of-File token */
#define TK_UNKNOWN -2    /* Lexeme encountered is not in the symbol table */
#define TK_WILD    -3    /* Automatic match token */
#define TK_NOTHING -4    /* Nothing token */
#define TK_LISTHEAD -5   /* variable is head of a list */

/*
 * the following are pre-defined internal keyword tokens.
 * WARNING! do not change these values, as they are indexes into
 * the symbol table in symbol.c--see symbol.c for more info
 */
#define TK_LEFTBRACKET  0
#define TK_RIGHTBRACKET 1
#define TK_EQUALS       2
#define TK_SAVESTATE    3
#define TK_SCREENMODE   4
#define TK_GRAPHICS     5
#define TK_TEXT         6
#define TK_STARTUP      7
#define TK_FILEMGR      8
#define TK_STARTPGRMS   9
#define TK_FILEMGRMODE  10
#define TK_SINGLETREE   11
#define TK_TWOTREE      12
#define TK_SYSTEMTREE   13
#define TK_PROGRAMSTARTER 14
#define TK_HELP         15
#define TK_TITLE        16
#define TK_PROGRAMLIST  17
#define TK_EXPLICITSEL  18
#define TK_GROUP        19
#define TK_PROGRAM      20
#define TK_COMMAND      21
#define TK_LEFTCURLY    22
#define TK_RIGHTCURLY   23
#define TK_ENABLED      24
#define TK_DISABLED     25
#define TK_PASSWORD     26
#define TK_SORTKEY      27
#define TK_NAME         28
#define TK_EXT          29
#define TK_DATE         30
#define TK_SIZE         31
#define TK_DISKORDER    32
#define TK_COMMANDSEP   33
#define TK_VARSENTINEL  34
#define TK_SLASH        35
#define TK_T            36
#define TK_P            37
#define TK_D            38
#define TK_R            39
#define TK_L            40
#define TK_M            41
#define TK_C            42
#define TK_POUND        43
#define TK_AT           44

#define TK_BLACK        45
#define TK_BLUE         46
#define TK_GREEN        47
#define TK_RED          48
#define TK_CYAN         49
#define TK_MAGENTA      50
#define TK_YELLOW       51
#define TK_WHITE        52

#define TK_COLOR        53
#define TK_BASE         54
#define TK_HIGHLIGHT    55
#define TK_ALERT        56
#define TK_SHADOW       57
#define TK_MENU         58
#define TK_MENUTEXT     59
#define TK_DIALOG       60
#define TK_BUTTON       61
#define TK_SELECTION    62
#define TK_BACKGROUND   63
#define TK_FOREGROUND   64

#define TK_LTBLACK      65
#define TK_LTBLUE       66
#define TK_LTGREEN      67
#define TK_LTRED        68
#define TK_LTCYAN       69
#define TK_LTMAGENTA    70
#define TK_LTYELLOW     71
#define TK_LTWHITE      72

#define TK_ASSOCIATIONS 73
#define TK_ASSOCIATION  74

#define TK_SCROLLBAR    75
#define TK_TITLEBAR     76
#define TK_ELEVATOR     77

#define TK_RESOLUTION   78
#define TK_LOWRES       79
#define TK_MEDIUMRES    80
#define TK_HIGHRES      81
#define TK_VERYHIGHRES  82

#define TK_CURRENTCOLOR 83
#define TK_DRIVEBOX     84
#define TK_CURSOR       85
#define TK_SWAPMOUSE    86
#define TK_VIDEODIR     87
#define TK_PROMPT       88
#define TK_INFO         89
#define TK_DEFAULT      90
#define TK_PAUSE        91
#define TK_DIRECTORY    92
#define TK_PARAMETER    93
#define TK_BEEP         94
#define TK_DRIVEICON    95
#define TK_SPECIAL      96
#define TK_BORDERS      97
#define TK_SHARED       98
#define TK_LISTKEYDELAY 99
#define TK_FORCEMONO 100
#define TK_SWITCHING 101
#define TK_TASKLIST 102
#define TK_DCONFIRM 103
#define TK_RCONFIRM 104
#define TK_CROSSDIRSEL 105
#define TK_KBREQUIRED 106
#define TK_XMSREQUIRED 107
#define TK_XMSLIMIT 108
#define TK_ALTTAB 109
#define TK_ALTESC 110
#define TK_CTRLESC 111
#define TK_SHORTCUT 112
#define TK_SHORTCUTCODE 113
#define TK_RESERVETEMP 114
#define TK_MCONFIRM 115
#define TK_SORTORDER 116
#define TK_DISPHIDDENFILES 117
#define TK_DESCENDING 118
#define TK_ASCENDING 119
#define TK_PREVENT 120
#define TK_LOAD 121
#define TK_RUN 122
#define TK_MOUSEINFO 123
#define TK_IGNORE 124
#define TK_READUPDATEFREQ 125
#define TK_TANDY1000 126
#define TK_SWAPDISK 127 		/* M010 */
#define NUMKEYWORDS     128	/* M010 */


/*
 * WARNING WARNING! The MAXSYMBOLS defines the maximum number of
 * symbols which can be allocated!
 */
#define MAXSYMBOLS   2000

/*
 * SYMBOL_TABLE_ENTRY is a template for a symbol in the symbol table
 * Note that lexeme a variable string of bytes--not a pointer!
 *
 * type field is a TOKEN belonging to the SYMBOL_TABLE_ENTRY which
 * has the lexeme field which should be used for this symbol
 * Keywords and non-subclassed symbols will have a type field equal
 * to themselves
 *
 * value field holds a TOKEN value for this symbol--it can be anything
 * really, but is usually another TOKEN in the symbol table
 *
 * next field is TK_NOTHING for atomic symbols, and a TOKEN to the
 * next token in the list if the symbol represents a list of symbols
 *
 * WARNING! SYMBOL_TABLE_ENTRY is really a dynamic length structure
 * with the "lexeme" field being used simply as a name placeholder
 */
typedef struct SYMBOL_TABLE_ENTRY
{
	TOKEN   type;
	TOKEN   value;
	TOKEN   next;
	char    lexeme; /* ...*/

}SYMBOL_TABLE_ENTRY;

/*
 * the symbol table exists in symbols.c
 */
extern SYMBOL_TABLE_ENTRY far *gSymbolTable[MAXSYMBOLS];
extern char far *gTempString;

/*
 * The next macros access fields of a SYMBOL_TABLE_ENTRY
 * Macros should always be used to shield code from symbol table
 * definition changes!
 */
#define Get_Symbol_Type(entry) (entry->type)
#define Set_Symbol_Type(entry,value) entry->type = value

#define Get_Symbol_Value(entry) (entry->value)
#define Set_Symbol_Value(entry,vvalue) entry->value = vvalue

#define Get_Symbol_Next(entry) (entry->next)
#define Set_Symbol_Next(entry,value) entry->next = value


#define Get_Token_Identifier(token) ((token)==TK_NOTHING && gTempString ? gTempString : (char far *)(Get_Symbol_Lexeme(Token_To_Symbol(token))))
/*
 * Since a symbol's lexeme is within the symbols allocated space,
 * we generate the address of the placeholder "lexeme" to generate
 * a pointer to the entire lexeme (which must be null terminated!)
 *
 * Each symbol has a type field which defines the (a TOKEN belonging to)
 * symbol which holds this symbols lexeme name.
 * So here we get the name indirectly by looking at the type's name
 * Keywords and the like have a type equal to their own TOKENs
 */
#define Get_Symbol_Lexeme(entry)   &((Token_To_Symbol(entry->type))->lexeme)

/*
 * extern definitons for routines in symbols.c
 */
TOKEN SymbolAlloc(unsigned int size);
extern int gNumTokens;
#define Get_Num_Tokens() (gNumTokens)
#define Ith_Token(mi) (mi)
#define Token_To_Symbol(mtoken)  (gSymbolTable[mtoken])
#define FreeSymbol(x)   0
#define FreeToken(mtoken)  0

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inc\tasklist.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* WARNING this is a hardcoded number for the number of bytes in the SFT
 */
#define DOS5SFTSIZE 0x3B

#define ER_NO_MEMORY            1
#define ER_NO_LIST_MEMORY  2
#define ER_LOW_MEMORY      3
#define ER_COMM_NOLOAD     4
#define ER_NO_XMS_DRV      5
#define ER_LOW_XMS_MEM     6
#define ER_WND_SWAP_OUT    8
#define ER_RELOCATE        9
#define ER_GRABBER_LOAD    11   
#define ER_WND_SWAP_IN     12
#define ER_APP_SWAP_OUT    13   
#define ER_APP_SWAP_IN     14   
#define ER_LIST_SWAP            15
#define ER_EXEC_FAILS      16
#define ER_WINOLDAP_ACTIVE 17
#define ER_BAD_INIT_DIR    18
#define ER_ANOTHER_SW_ACTIVE  19
#define ER_TOO_MANY_SWITCHERS 20
#define ER_APP_NOT_STARTED_YET 21       

#define ER_SWAPI_CREATE_FAILS 80

#define MAX_PROGRAM_LENGTH 80
#define MAX_TITLE  30

#define MAX_NUM_PROGRAMS 16


#define F_NO_SWITCH    1
#define F_GRAPHICS     2
#define F_NO_PAUSE     4
#define F_NO_ALT_TAB      256
#define F_NO_ALT_ESC      512
#define F_NO_CTRL_ESC  1024
#define F_FREE                    0x8000

//BUG BUG zero based, but should it be total 16?
#define MAXTASKS 13

#define FSHELL 64

typedef struct Switch_Entry
{
    char Program_Name[MAX_PROGRAM_LENGTH];
    char Program_Title[MAX_TITLE];
    WORD Conv_Req;
    WORD XMS_Req;
	 WORD XMS_Want;
	 BYTE HK_Scan_Code_1;
	 BYTE HK_Scan_Code_2;
	 BYTE HK_Shift_State;
    WORD Program_Flags;
    BYTE Next_In_List;
    WORD Program_Id;
    BYTE Path_Id;
	 WORD Shell_Cookie;
}Switch_Entry;

typedef struct Switch_Info
{
	BYTE Switcher_Id;
	WORD CPU_Type;
	WORD SFT_Size;
	char Parameters[130];
	char Grabber_Name[80];
	char Swap_Path1[68];
	char Swap_Path2[68];
	WORD Min_Path1; 
	WORD Min_Path2;
	WORD XMS_Handle;
	DWORD XMS_Size;
	WORD Int_15_Users_Id;
	WORD Id_Serial;
	WORD Exit_Code;
	BYTE Num_Lines;
	BYTE Global_Flags;
	BYTE Screen_Back;
	BYTE Title_Fore;        
	BYTE Title_Back;
	BYTE Num_Programs;
	BYTE First_In_List;
	Switch_Entry Program_list[MAX_NUM_PROGRAMS];
}Switch_Info;

extern void far cdecl C_INIT_PROGRAM_LIST(void);
extern void far cdecl C_GO_NEXT(void);
extern void far cdecl C_GO_Z_NEXT(void);
extern Switch_Entry far * far cdecl C_GET_ITH_ENTRY_DATA(int i);
extern char far cdecl C_GET_LIST_LENGTH(void);
extern char far * far cdecl C_GET_ITH(int i);

extern Switch_Info far * far cdecl C_GET_GLOBAL_SWITCH_DATA(void);
extern unsigned far cdecl C_GET_EXITCODE (void) ;
extern void far cdecl C_DELETE_PROGRAM(int i);
extern BOOL RunningUnderMStasker(void);


extern void far cdecl C_ADD_PROGRAM(char far *s);
extern void far cdecl C_ADD_PARAMS(char far *s,int length);
extern void far cdecl C_GO_Z_NEXT(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\iniparse\iniparse.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
** PARSE.H
**
**  This file defines and structures used by lex.c and iniparse.c
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  8/10/89   scottq    written
**  8/13/89   scottq    redid quite a bit to account for new symbol table
**
*/
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <errno.h>

BOOL fgSymbolTableModified = FALSE;
long glStartIni;

extern unsigned gWriteErrs;
extern unsigned FlushBufferedWrite(int fhandle);
extern unsigned Buffered_dos_write(int fhandle,char far *str, unsigned count,
										unsigned *pbytes) ;

#ifdef CONVERT_UTILITY
#include <malloc.h>
#endif

TOKEN Assignment();

/*  NAME
 *      List
 *  DESCRIPTION
 *      Builds a list from the lexemes in the text, attatching list to
 *      parent
 *  ARGUMENTS
 *      parent TOKEN is the symbol whose value will become the list
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *      This code matches all lists, so is recursive in Assignent
 *  WARNINGS
 *      No error checking/recover is provide for
 *  HACKS
 *      NO ERROR CHECKING !!!!!!!!!
 */
void List(TOKEN parent)
{
    TOKEN temp;

    /*
     * We need a symbol, so we subclass it
     * its parameter "parent" will end up being ignored
     */
    temp = SubClassSymbol(parent);

    /*
     * contiute to parse this list until we get to the end of
     * the list (or EOF)
     */
    while( (gLookahead != TK_EOF) && (gLookahead != TK_RIGHTCURLY))
    {
       /*
	* newly allocated symbol is a list of assigned variables,
	* so we append the assignments found
	*/
       Append_Symbol(temp,Assignment());
    }
    /*
     * Set the parent to have a value of the new list
     */
    Set_Symbol_Value(Token_To_Symbol(parent),temp);
    /*
     * there should be a "}" next in the text, or perhaps EOF
     */
    match(TK_RIGHTCURLY);
}

/*  NAME
 *      Assignment
 *  DESCRIPTION
 *      Parses a <lexeme> = <lexeme> pair, and builds symbols for them
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      a TOKEN to the variable (new symbol) being assigned
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *      This code matches all assignments, so is recursive in List
 *  WARNINGS
 *      No error checking/recover is provide for
 *  HACKS
 *      NO ERROR CHECKING !!!!!!!!!
 */
TOKEN Assignment()
{
    TOKEN temp;
    BOOL hitnewline;
    hitnewline = FALSE;
    /*
     * create a new subclassed symbol for the up-coming lexeme
     */
    temp = SubClassSymbol(gLookahead);
    match(gLookahead);
    match(TK_EQUALS);
    while(gLookahead == TK_NOTHING)
    {
	hitnewline = TRUE;
	match(TK_NOTHING);
    }
    /*
     * an assignment can be to a list of assignments or a single assignment
     */
    if (gLookahead == TK_LEFTCURLY)
    {
	/*
	 * we are assigning a list to the new symbol
	 */
	match(TK_LEFTCURLY);
	List(temp);
    }
    else
    {
	if(!hitnewline)
	{
	/*
	 * we are only assigning an atom to the symbol
	 */
	Set_Symbol_Value(Token_To_Symbol(temp),gLookahead);
	match(gLookahead);
	}
	else
	{
	  Set_Symbol_Value(Token_To_Symbol(temp),TK_NOTHING);
	}

    }
    return(temp);
}

/*  NAME
 *      SectionBody
 *  DESCRIPTION
 *      Parses all assignments in a section (after [<?>])
 *  ARGUMENTS
 *      section is a TOKEN to the name of the section being parsed
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *      No error checking/recover is provide for
 *  HACKS
 *      NO ERROR CHECKING !!!!!!!!!
 */
void SectionBody(TOKEN section)
{
    /*
     * Keep matching Assignments until we get to another Section
     */
    while( (gLookahead != TK_EOF) && (gLookahead != TK_LEFTBRACKET))
    {
       Append_Symbol(section,Assignment());
    }
}

/*  NAME
 *      Section
 *  DESCRIPTION
 *      matches the header of a section ([<?>])
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *      No error checking/recover is provide for
 *  HACKS
 *      NO ERROR CHECKING !!!!!!!!!
 */
void Section()
{
    TOKEN temp;
    /*
     * match "[<sectionname>]"
     */
    match(TK_LEFTBRACKET);
    temp = gLookahead;
    match(gLookahead);
    match(TK_RIGHTBRACKET);
    /*
     * parse the body of the Section
     */
    SectionBody(temp);
    /*
     * each section is really a list of its assignments,
     * there is a special token value for list headers TK_LISTHEAD
     */
    Set_Symbol_Value(Token_To_Symbol(temp),TK_LISTHEAD);
}

/*  NAME
 *      inifile
 *  DESCRIPTION
 *      parses an inifile
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
void inifile()
{
    /*
     * keep parsing sections until EOF is reached
     */
    while(gLookahead != TK_EOF)
    {
	Section();
    };
}

/*  NAME
 *      parse
 *  DESCRIPTION
 *      start parsing
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
void parse()
{
    /*
     * the lexer needs to be kick started by matching TK_WILD token
     */
    match(TK_WILD);
    inifile();
}

/* Saves the value of a few tokens that get modified but typically get
 * reset back to their value at start up. For example: the value of
 * "startup" could be "startprograms" initially, and when we get to the
 * filemanager it becomes "filemanager" and then if we exit via the program
 * manager, it gets back its original value, so we don't need to save
 * ini file.
 */
TOKEN gtk_startup = TK_UNKNOWN ;
TOKEN gtk_explicitsel = TK_UNKNOWN ;
TOKEN gtk_filemgrmode = TK_UNKNOWN ;

BOOL fIsSpecialToken(TOKEN section, TOKEN tok)
{
	if ( ((section == TK_SAVESTATE) && (tok == TK_STARTUP)) ||
		 ((section == TK_SAVESTATE) && (tok == TK_EXPLICITSEL)) ||
		 ((section == TK_SAVESTATE) && (tok == TK_FILEMGRMODE))
	   )
		return TRUE ;

	return FALSE ;
} /* fIsSpecialToken */

void InitWriteIniFileOpt(void)
{
	gtk_startup = Get_KeyWord_Assignment(TK_SAVESTATE,TK_STARTUP) ;
	gtk_explicitsel = Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL);
	gtk_filemgrmode = Get_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE);

}  /* InitWriteIniFileOpt */

BOOL fNoEffectiveChange(void)
{
	if ( (gtk_startup == Get_KeyWord_Assignment(TK_SAVESTATE,TK_STARTUP)) &&
		 (gtk_explicitsel == Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL)) &&
		 (gtk_filemgrmode == Get_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE))
	   )
		return TRUE ;

	return FALSE ;

}  /* fNoEffectiveChange */

/*      NAME
 *      Read_IniFile
 *  DESCRIPTION
 *      Read in an ini file and parse it
 *  ARGUMENTS
 *      inifile's name
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

#define MAXTEXT_IN_K (2)

#ifdef CONVERT_UTILITY
#define IniAlloc(s, x) (x = x>0xfff0L ? 0xfff0L : x, s = _fmalloc(x))
#define IniFree(s) _ffree(s)
#else
#define IniAlloc(s, x) (x=AllocClosestTo1K(&s, 2*MAXTEXT_IN_K, x>=0xfc00L ? 0x003f : (unsigned)(x>>10)+1))
#define IniFree(s) FreeWorkFar(s)
#endif

extern char szDefaultIni[];

/*
 * Read in ini file at inifilename. If inifilename is NULL, use defaults
 *
 */
BOOL Read_Ini_File(char *inifilename)
{
    int fhandle;
    long lSize, lSaveSize;
    unsigned int size;
    char cLBrack;
    char far *buffer;
    char far *saveBuffer = NULL;
	 BOOL fFileOpened = FALSE ; // whether INI file was opened or not

    glStartIni = 0;

/* open the file */
    if(inifilename == NULL)
    {
defaultini:
	/* initialize lexer globals */
		Init_ParseText(0, szDefaultIni, 0, strlen(szDefaultIni));

    }
    else
    if(_dos_open(inifilename, O_RDONLY, &fhandle)) 
    {
	return (FALSE);
    } 
    else 
    {
		  fFileOpened = TRUE ;

/* get the size of the file by seeking to the end */
	lSize = lSaveSize = lseek(fhandle, 0L, SEEK_END);
/* seek back to the start and read in the file */
	lseek(fhandle, 0L, SEEK_SET);

/* allocate memory for the file contents we are about to read in */
	if(!IniAlloc(saveBuffer, lSize))
	    goto defaultini;

/* HACK!! Seek to the first [ so we can put comments at the start of the file */
	cLBrack = *Get_Token_Identifier(TK_LEFTBRACKET);
	size = 1;

	while(TRUE) {
	    if(_dos_read(fhandle, saveBuffer, (int)lSize, &size) || !size)
		goto defaultini;
	    lSize = size;

	    buffer = saveBuffer;
	    while(size>0 && *buffer!=cLBrack) {
		--size;
		++buffer;
	    }
	    glStartIni += (unsigned int)(buffer - saveBuffer);
	    if(*buffer == cLBrack)
		break;
	}

	if(lSaveSize-glStartIni < 3)
	    goto defaultini;

/* initialize lexer globals */
	Init_ParseText(fhandle, saveBuffer,
		(unsigned int)(buffer-saveBuffer), (unsigned int)lSize);
    }
    parse();

/* set global var indicating we have not modified the symbol table */
    fgSymbolTableModified = FALSE;

    if(saveBuffer)
	IniFree(saveBuffer);

    InitWriteIniFileOpt() ;

	 /* close the INI file in case it was opened by us! */
	 if (fFileOpened)
		_dos_close(fhandle) ;

    return(TRUE);
}


unsigned int myfstrlen(s)
unsigned char far *s;
	{
	int i = 0;

	while (*s++)
		i++;
	return(i);
	}
void indent(int fhandle,int level)
{
    int i,size;
    for(i=0;i<level;i++)
    {
	 Buffered_dos_write(fhandle,"     ",4,&size);
    }
}

void write_list(int fhandle,TOKEN token,int level)
{
     int size;
     char far *str;
     SYMBOL_TABLE_ENTRY far *temp;

     while(token != TK_NOTHING)
     {
	 temp = Token_To_Symbol(token);
	 token = Get_Symbol_Next(temp);

	 if (token != TK_NOTHING)
	 {
	    str = Get_Token_Identifier(token);
	    size = myfstrlen(str);
	    indent(fhandle,level);

	    Buffered_dos_write(fhandle,str,size,&size);
	    Buffered_dos_write(fhandle," = ",3,&size);

	    temp = Token_To_Symbol(token);
	    if(Get_Symbol_Value(temp) != TK_NOTHING)
	    {
		temp = Token_To_Symbol(Get_Symbol_Value(temp));
		if(Get_Symbol_Next(temp) != TK_NOTHING)
		{
		     Buffered_dos_write(fhandle,"\r\n",2,&size);
		      indent(fhandle,level);
		     Buffered_dos_write(fhandle,"{",1,&size);
		     Buffered_dos_write(fhandle,"\r\n",2,&size);
		     write_list(fhandle,Get_Symbol_Value(Token_To_Symbol(token)),level+1);
		      indent(fhandle,level);
		     Buffered_dos_write(fhandle,"}",1,&size);

		 }
		 else
		 {
		     str = Get_Token_Identifier(Get_Symbol_Value(Token_To_Symbol(token)));
	    if(*str=='"' || (unsigned char)(*str)<=' ')
			Buffered_dos_write(fhandle,"\"",1,&size);
		     size = myfstrlen(str);
		    Buffered_dos_write(fhandle,str,size,&size);
		 }

	     }
	     Buffered_dos_write(fhandle,"\r\n",2,&size);

	   }
       }
}

#define TEMPNAMECHAR '#'

BOOL Write_Ini_File(char *szFileName)
{
    int fhandle, fold;
    int maxtoks, i, nExt;
    char far *str;
    SYMBOL_TABLE_ENTRY far *cursymbol;
    unsigned int size;
    char szTempName[MAX_PATH+1];

	i = FindLastComponent(szFileName) ;
	if (szFileName[i] == PATHCHAR)
		i++ ;

	/* Copy the drive of the ini file */
    RepeatMove(szTempName, szFileName, i);

/* Create a temp name: #.n, where n is a hex number between 0 and 0xfff */
    szTempName[i] = TEMPNAMECHAR;
    szTempName[i+1] = '.';
    for(nExt=0; ; ++nExt) {
	if(nExt == 0x1000)
	    goto Error1;
	itoa(nExt, szTempName+i+2, 16);
	if(_dos_creatnew(szTempName, _A_NORMAL, &fhandle)) {
	    if(errno == EEXIST)
		continue;
	    else
		goto Error1;
	} else
	    break;
    }

/* Reset the number of write errors and then write the ini comments */
    gWriteErrs = 0;
    if(glStartIni>0 && !_dos_open(szFileName, O_RDONLY, &fold)) {
	long lTotal, lSize;

	lSize = glStartIni;
	if(!IniAlloc(str, lSize))
	    goto Error2;

/* Copy to where we found the first left bracket when reading the file */
	for(lTotal=glStartIni; lTotal>0 &&
		!_dos_read(fold, str, (int)lSize, &size) && size;
		lTotal -= size) {
	    Buffered_dos_write(fhandle, str,
		    lTotal>(long)size ? size : (int)lTotal, &nExt);
	}

	FreeWorkFar(str);
Error2:
	_dos_close(fold);
    }

/* Write the ini information */
    maxtoks = Get_Num_Tokens();
    for(i=0; i<maxtoks; ++i) {
	cursymbol = Token_To_Symbol(Ith_Token(i));
	if(Get_Symbol_Value(cursymbol) == TK_LISTHEAD) {
	    Buffered_dos_write(fhandle,"[",1,&size);
	    str = Get_Token_Identifier(Ith_Token(i));
	    size = myfstrlen(str);
	    Buffered_dos_write(fhandle,str,size,&size);
	    Buffered_dos_write(fhandle,"]",1,&size);
	    Buffered_dos_write(fhandle,"\r\n",2,&size);

	    write_list(fhandle,Ith_Token(i),0);
	}
    }

/* Flush the output, close the file, and delete the old ini file */
    FlushBufferedWrite(fhandle);
    if(_dos_close(fhandle) || gWriteErrs>0)
	goto Error3;

    unlink(szFileName);
    if(!rename(szTempName, szFileName))
	return(TRUE);

/* on error, delete the temp file and return FALSE */
Error3:
    unlink(szTempName);
Error1:
    return(FALSE);
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\iniparse\trans.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <malloc.h>

#include "transtxt.h"

extern void _CDECL exit(int);
extern	int Read_Ini_File(char *inifilename);
extern  int Write_Ini_File(char *inifilename);


#define HELP_OFFSET	   (0x139)
//#define HELP_LEN	     (0x318-HELP_OFFSET)
#define HELP_LEN	   (30*16-1)
#define JUNK1_OFFSET	   (HELP_OFFSET+HELP_LEN)
#define JUNK1_LEN	   (7*16+20)
#define TITLE_OFFSET	   (HELP_OFFSET+HELP_LEN)
#define TITLE_LEN	   (40)
#define JUNK2_OFFSET	   (TITLE_OFFSET+TITLE_LEN)
#define JUNK2_LEN	   (15)
#define COMMAND_OFFSET	   (JUNK2_OFFSET+JUNK2_LEN)
#define COMMAND_LEN	   (31*16+6)

void fatal(char *message)
{
	puts(message);
	putchar(7);
	exit(-1);
}

char buffer[10];
/*
**				Main program
*/
void cdecl main(void)
{
	int fhandle;
	unsigned int size;
	unsigned int rsize;
	char far *buffer;
	unsigned int offset;
	int i;

	Read_Ini_File("shell.ini");

	/*
	 * open the file
	 */
	if ((_dos_open("test.meu",O_RDONLY,&fhandle)) != 0)
		fatal(szCantOpen);
	size = (int) lseek(fhandle,0L,SEEK_END);
	if(!size)
	{
		_dos_close(fhandle);
		fatal(szZeroLength);
	}
	lseek(fhandle,0L,SEEK_SET);
	/*
	 * allocate memory for the file contents we are about to read in.
	 */
	if (buffer = (char far *) _fmalloc(size))
	{
		/* read in the file */
		if ( (_dos_read(fhandle, buffer, (int) size, &rsize) == 0) && 
															(rsize == size) )
		{
			offset = HELP_OFFSET;
			i = 0;
			while(offset < size)
			{
				if(buffer[offset]==0)
					buffer[offset] = ' ';
				printf("HELP (%x) = %Fs\n",offset,&buffer[offset]);
				if(++i == 1)
					offset+=JUNK1_LEN;

				offset+=TITLE_OFFSET-HELP_OFFSET;
				if(buffer[offset]==0)
					buffer[offset] = ' ';
				printf("TITLE (%x) = %Fs\n",offset,&buffer[offset]);
				offset+=COMMAND_OFFSET-TITLE_OFFSET;
				if(buffer[offset]==0)
					buffer[offset] = ' ';
				printf("COMMAND (%x) = %Fs\n",offset,&buffer[offset]);
				offset+=COMMAND_LEN;
			}

		}
		else
		{
			_dos_close(fhandle);
			fatal(szReadError);
		}
		_dos_close(fhandle);
	}
	else
	{
		_dos_close(fhandle);
		fatal(szOutOfMemory);
	}

	Write_Ini_File("shell.out");
} /* main */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\loader\shell.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

extrn __astart:FAR

stderr	equ 2		     ; standard error
cr	equ 0dh 	     ; ASCII carriage return
lf	equ 0ah 	     ; ASCII linefeed
VOODOO	equ 02h
cseg	segment para public 'CODE'
;
; ----	Set up DS, ES, and SS:SP to run as .COM  ----
;
	assume	cs:cseg
start	proc	far
;;;	Get my PSP to look at command line

	mov	ax,es
	mov	cs:myPSP,ax
	mov	bx,82h
	mov	al,BYTE PTR es:[bx+4]
	cmp	al,VOODOO
	je	do_cshell
	jmp	do_resident
	;;;; run the shell interface program
	;;;; the parameters indicate where to place the data for the
	;;;; next program to launch--client_name
do_cshell:
	mov	ax,WORD PTR es:[bx]
	mov	WORD PTR cs:dma_ptr[0],ax	    ;; offset
	mov	ax,WORD PTR es:[bx+2]
	mov	WORD PTR cs:dma_ptr[2],ax	     ;; segment
	jmp    __astart
main_loop:

	;;;	setup dma location (offset,segment)
	mov	ax,cs:myPSP
	mov	es,ax
	mov	BYTE PTR es:[0C0h+0],5h
	mov	WORD PTR es:[0C0h+2],80h
	mov	WORD PTR es:[0C0h+4],ax
	mov	BYTE PTR es:[0C0h+6],VOODOO

	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	dx,offset cseg:shell_name
	mov	bx,offset cseg:par_blk
	mov	ax,4b00h	; AX = EXEC/run program
	int	21h		; carry = EXEC failed

	mov	ax,cs:myPSP
	mov	es,ax

	;mov	 BYTE PTR es:[0C0h+0],0h
	;mov	 BYTE PTR es:[0C0H+2],cr
	;mov	 BYTE PTR es:[0C0h+6],not VOODOO

	;;exit
	    mov al, BYTE PTR es:[080h+0]
	    cmp al,0FFh
	    jne dont_go_away
	    mov ax,04C00h
	    int 21h
	;;
 dont_go_away:

	mov	ax,cs
	mov	es,ax
	mov	bx,offset cs:par_blk
	mov	dx,80h
	mov	ax,cs:myPSP
	mov	ds,ax

	mov	ax,4b00h	; AX = EXEC/run program
	int	21h		; carry = EXEC failed
cant_load_second:
cant_load:
	jmp	main_loop	; execute forever
start	endp


; ----	Program resident data area  ----
;
shell_name  db	'.\SHELL.EXE',0
dma_ptr     dd	0
PUBLIC dma_ptr

myPSP	    dw	?

par_blk  dw	0		; use current environment
	 dw	0C0h		 ; command-line address
cmd_seg  dw	0		; fill in at initialization
	 dw	offset fcb1	; default FCB #1
fcb1_seg dw	0		; fill in at initialization
	 dw	offset fcb2	; default FCB #2
fcb2_seg dw	0		; fill in at initialization

fcb1	 db	0
	 db	11 dup (' ')
	 db	25 dup ( 0 )
fcb2	 db	0
	 db	11 dup (' ')
	 db	25 dup ( 0 )

	 dw	25 dup ( 0 )   ; program stack area
stk	 dw	0

last	 equ	$		; last address used

do_resident:
	mov	ax,cs		; set up segment registers
	mov	ds,ax
	mov	ss,ax		; set up stack pointer
	mov	sp,offset cs:stk
	assume cs:cseg,ds:cseg,ss:cseg
seg_size equ (((offset last) - (offset start)) + 10fh)/16
	mov	ax,cs:myPSP	; ES = segment to shrink
	mov	es,ax
	mov	bx,seg_size	; BX = new segment size
	mov	ah,4ah		; AH = modify memory block
	int	21h		; free excess memory
	mov	ax,cs:myPSP
	mov	cmd_seg,ax	; setup segments in
	mov	fcb1_seg,ds	; parameter block for EXEC
	mov	fcb2_seg,ds
	mov	dx,offset main_loop
	mov	ax,2523h	; AX = set Control-C handler
	int	21h		; set handler to DS:DX
	mov	dx,offset main_loop
	mov	ax,2524h	; AX = set critical error handler
	int	21h		; set handler to DS:DX
				; Note: DS is equal to CS

	jmp	main_loop

_GET_COMMAND_PTR proc far
	mov dx,WORD PTR cs:dma_ptr[2]
	mov ax,WORD PTR cs:dma_ptr[0]
	ret
_GET_COMMAND_PTR endp
PUBLIC _GET_COMMAND_PTR

_GET_ARGS_PTR proc far
	mov dx,WORD PTR cs:dma_ptr[2]
	mov ax,WORD PTR cs:dma_ptr[0]
	add ax,40h
	ret
_GET_ARGS_PTR endp
PUBLIC _GET_ARGS_PTR



cseg	 ends
	 end	start

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\loader\swtch_tr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;;;
;;; This file contains C interface routines to the 
;;; global int2f switcher functions.
;;; All they do is preserve registers, set up parameters, and call out
;;;
;;; See swtch_re.inc for parameters/return values
_C_GET_LIST_LENGTH proc far
	push bp
	push ds
	push es
	push di
	push si

	mov ax,4a05h
	mov si,CGET_LIST_LENGTH
	int 2fh

	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_GET_LIST_LENGTH endp
PUBLIC _C_GET_LIST_LENGTH



 _C_GET_ITH proc far
	push bp
	mov bp,sp
	push ds
	push es
	push di
	push si

	mov bx,[bp+6]

	mov ax,4a05h
	mov si,CGET_ITH_PROGRAM_STRING
	int 2fh

	mov dx,es
	mov ax,si

	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_GET_ITH endp
PUBLIC _C_GET_ITH

_C_ADD_PARAMS proc far
	push bp
	mov  bp,sp
	push ds
	push es
	push di
	push si
	push ax
	push dx

	mov es,[bp+8]
	mov bx,[bp+10]
	mov bp,[bp+6]


	mov ax,4a05h
	mov si,CADD_PARAMS
	int 2fh
	pop dx
	pop ax
	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_ADD_PARAMS endp
PUBLIC _C_ADD_PARAMS

_C_GET_EXITCODE proc far
	push bp
	mov  bp,sp
	push ds
	push es
	push di
	push si

	mov ax,4a05h
	mov si,CGET_EXITCODE
	int 2fh
	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_GET_EXITCODE endp
PUBLIC _C_GET_EXITCODE


_C_ADD_PROGRAM proc far
	push bp
	mov  bp,sp
	push ds
	push es
	push di
	push si
	push ax
	push dx

	mov es,[bp+8]
	mov bp,[bp+6]

	mov ax,4a05h
	mov si,CADD_PROGRAM_TO_LIST
	int 2fh
	pop dx
	pop ax
	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_ADD_PROGRAM endp
PUBLIC _C_ADD_PROGRAM


_C_DELETE_PROGRAM proc far
	push bp
	mov  bp,sp
	push ds
	push es
	push di
	push si

	mov bx,[bp+6]

	mov ax,4a05h
	mov si,CDELETE_PROGRAM_FROM_LIST
	int 2fh

	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_DELETE_PROGRAM endp
PUBLIC _C_DELETE_PROGRAM


_C_INIT_PROGRAM_LIST proc far
	push bp
	push ds
	push si
	push di
	push es

	mov ax,4a05h
	mov si,CINIT_PROGRAM_LIST
	int 2fh

	pop es
	pop di
	pop si
	pop ds
	pop bp
     retf
_C_INIT_PROGRAM_LIST endp
PUBLIC _C_INIT_PROGRAM_LIST


_C_GO_Z_NEXT proc far
	push bp
	push ds
	push si
	push di
	push es

	mov ax,4a05h
	mov si,CGO_Z_NEXT
	int 2fh

	pop es
	pop di
	pop si
	pop ds
	pop bp
	retf
_C_GO_Z_NEXT endp
PUBLIC _C_GO_Z_NEXT

_C_GO_Z_PREV proc far
	push ds
	push si
	push di
	push es

	mov ax,4a05h
	mov si,CGO_Z_PREV
	int 2fh

	pop es
	pop di
	pop si
	pop ds
       retf
_C_GO_Z_PREV endp
PUBLIC _C_GO_Z_PREV

_C_GO_NEXT proc far
	push ds
	push si
	push di
	push es

	mov ax,4a05h
	mov si,CGO_NEXT
	int 2fh

	pop es
	pop di
	pop si
	pop ds
	retf
_C_GO_NEXT endp
PUBLIC _C_GO_NEXT


_C_GET_GLOBAL_SWITCH_DATA proc far
	push ds
	push si
	push di
	push es

	mov ax,4a05h
	mov si,CGET_GLOBAL_SWITCH_DATA
	int 2fh
	;;; out put in dx:ax
	;mov dx,es
	;mov ax,di

	pop es
	pop di
	pop si
	pop ds
	retf
_C_GET_GLOBAL_SWITCH_DATA endp
PUBLIC _C_GET_GLOBAL_SWITCH_DATA

_C_GET_ITH_ENTRY_DATA proc far
	push bp
	mov  bp,sp
	push ds
	push es
	push di
	push si

	mov bx,[bp+6]

	mov ax,4a05h
	mov si,CGET_ITH_ENTRY_DATA
	;;; output in es:di
	int 2fh
	mov dx,es
	mov ax,di

	pop si
	pop di
	pop es
	pop ds
	pop bp
	retf
_C_GET_ITH_ENTRY_DATA endp
PUBLIC _C_GET_ITH_ENTRY_DATA

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\loader\loader.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

seg_size equ (((offset last) - (offset start)) + 10fh)/16
seg_swtch_size equ (((offset last_switcher) - (offset start)) + 10fh)/16

SWITCHER EQU 0FFFFh
;;;QLOADER EQU 0FFFFh
;;;
;;;This is the start-up code for the shell.
;;;
IFNDEF QLOADER
extrn __astart:FAR               ;;; address of C startup
ENDIF
MULTMULT_INT equ 4A05h            ; interrupt 2f interface
stderr  equ 2                ; standard error
cr      equ 0dh              ; ASCII carriage return
lf      equ 0ah              ; ASCII linefeed
VOODOO  equ 02h              ; voodoo character that cannot be typed at command
DOPAUSE equ 01h              ; pause before erasing screen?
COMMANDLINEIN equ 80h        ; offset of command line passed in (PSP)
;;;COMMANDLINEOUT equ 0C0h      ; offset of the command line passed to shell
COMMANDLINEOUT equ 080h      ; offset of the command line passed to shell

COMMANDMAXLENGTH equ 121

EXITOFFSET equ 0
DMAOFFOFFSET equ EXITOFFSET+2
DMASEGOFFSET  equ DMAOFFOFFSET+2
VOODOOOFFSET equ DMASEGOFFSET+2
PAUSEOFFSET  equ VOODOOOFFSET+1

cseg    segment para public 'CODE'

	assume  cs:cseg
IFDEF QLOADER
	org 100h
ENDIF
start   proc
;;;     PROGRAM EXECUTION BEGINS HERE
;;;     ES:0 is the PSP
;;;     Get my PSP to look at command line
	mov     ax,es
	mov     cs:myPSP,ax
	;;; scoot the command line over
	call scoot_command

	;;; remember our start-up name
	call find_startup_name
	;;; remember our allocation strategy (for UMB support)
	mov ax,5800h    ; Get allocation Strategy ;output in ax
	int 21h
	mov WORD PTR cs:myAllocationStrategy,ax
	mov ax,5802h    ; Get link state; output in ax
	int 21h
	mov WORD PTR cs:myUmbLinkState,ax

IFDEF QLOADER
	call startup_to_exe
ENDIF
	mov     bx,COMMANDLINEIN
	mov     al,BYTE PTR es:[bx+VOODOOOFFSET]
	cmp     al,VOODOO
IFNDEF QLOADER
	je      do_cshell
ENDIF
	call print_copyright
	jmp     do_resident
IFNDEF QLOADER
	;;;; run the shell interface program
	;;;; the parameters indicate where to place the data for the
	;;;; next program to launch--client_name
do_cshell:
	mov     al,BYTE PTR es:[bx+PAUSEOFFSET]       ; put pause byte into global
	mov     cs:WaitBeforeErase,al
	mov     ax,WORD PTR es:[bx+DMAOFFOFFSET]
	mov     WORD PTR cs:dma_ptr[0],ax           ;; offset
	mov     ax,WORD PTR es:[bx+DMASEGOFFSET]
	mov     WORD PTR cs:dma_ptr[2],ax            ;; segment
	jmp    __astart
ENDIF
main_loop:
	;;;     re-exec the shell interface
	;;; grow the resident back to max size
	mov     ax,cs:myPSP     ; ES = segment to shrink
	mov     es,ax
	mov     bx,seg_swtch_size     ; BX = new segment size
	mov     ah,4ah          ; AH = modify memory block
	int     21h             ; grab excess memory
	cmp     cs:reinitswitchervars,1
	jne     dontreinitswitchervars
	mov     cs:gresSwitchInfo.Global_Flags,0        ;dosshell will resinit switcher data
	mov     cs:reinitswitchervars,0
dontreinitswitchervars:
	;;;Restore our Allocation Strategy
	mov     cs:inShell,0    ;;not yet in shell (for ctrl+c,etc)
	mov     ax,5801h ;Set Allocation Strategy
	mov     bx,cs:myAllocationStrategy
	int     21h
	mov     ax,5803h ;Set Link state
	mov     bx,cs:myUmbLinkState
	;;;BUG BUG shouldn't need to do this harishn!
	xor     bh,bh
	int     21h

	mov     cs:cmd_loc,COMMANDLINEIN
	;;;     setup dma location (offset,segment)
	mov     ax,cs:myPSP
	mov     es,ax
	mov     BYTE PTR es:[COMMANDLINEOUT],127
	mov     BYTE PTR es:[COMMANDLINEOUT+EXITOFFSET],0
	mov     WORD PTR es:[COMMANDLINEOUT+DMAOFFOFFSET],COMMANDLINEIN
	mov     WORD PTR es:[COMMANDLINEOUT+DMASEGOFFSET],ax
	mov     BYTE PTR es:[COMMANDLINEOUT+VOODOOOFFSET],VOODOO
	cmp     BYTE PTR cs:dopauseflag,1
	mov     BYTE PTR es:[COMMANDLINEOUT+PAUSEOFFSET],0
	jne     dontpause
	mov     BYTE PTR es:[COMMANDLINEOUT+PAUSEOFFSET],DOPAUSE
dontpause:
	mov     BYTE PTR cs:dopauseflag,1

	mov     ax,cs
	;mov     ds,ax
	mov     es,ax
	mov     dx,cs:startup_name_off
	mov     ds,cs:startup_name_seg
	;mov     dx,offset cseg:shell_name
	mov     bx,offset cseg:par_blk
	mov     ax,4b00h        ; AX = EXEC/run program
	mov     cs:inShell,1
	int     21h             ; carry = EXEC failed
	mov     cs:inShell,0
	jc      cant_load_shell
	mov     ax,cs:myPSP
	mov     es,ax

	;;exit
	mov al, BYTE PTR es:[COMMANDLINEIN+EXITOFFSET]
	cmp al,0FFh
	jne dont_go_away

go_away:
	cmp     cs:isBallPoint,1
	je      nohookspresent
	call    Mouse_Unhook33
	call    Mouse_Unhook15
nohookspresent:
IF SWITCHER
	;;;***
	call    Switcher_UnHook

	;;; We need to exit entirely, set magic EXIT field!
	mov BYTE PTR es:[COMMANDLINEIN+EXITOFFSET], 0FFh
	;;;***
ENDIF
	mov ax,04C00h
	int 21h
	;;
 dont_go_away:
	;;; we are running somebody else now
	;;; we always turn off UMBs for launching because the
	;;; switcher cannot be loaded in a UMB, and command.com
	;;; doesn't need it. Users can still load programs in UMBS,
	;;; however they need to turn this on explicitely for each
	;;; application.
	mov     bx,cs:myAllocationStrategy
	and     bl,07Fh  ;mask off high bit to mean turn off high allocs
	mov     ax,5801h         ;Set Allocation Strategy input in BX
	int     21h
	mov     ax,5803h         ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	xor     bx,bx
	int     21h
	;;; is command line magic switcher command?
	cmp     BYTE PTR es:[COMMANDLINEOUT+42h],0FEh
	je      continueexec
	call    shrink_resident_size
continueexec:

	mov     cs:cmd_loc,COMMANDLINEIN+40h
	push    cs
	pop     es
	;mov     ax,cs
	;mov     es,ax
	mov     bx,offset cs:par_blk
	mov     dx,COMMANDLINEIN
	mov     ax,cs:myPSP
	mov     ds,ax

	mov     ax,4b00h        ; AX = EXEC/run program
	int     21h             ; carry = EXEC failed
	jc      unable_to_launch
cant_load_second:
cant_load:
	jmp     main_loop       ; execute forever
unable_to_launch:
	mov     dx, offset Cant_Run_It
	call    Get_User_Response
	or      ax,ax
	jz      cant_load_second
	jmp     short dont_go_away
cant_load_shell:
	mov     dx, offset Query_string
	call    Get_User_Response
	or      ax,ax
	;;;     0 = no
	jz      go_away
	jmp     short cant_load

start   endp

shrink_resident_size proc near
	;;; shrink the resident back to min size
	mov     ax,cs:myPSP     ; ES = segment to shrink
	mov     es,ax
	mov     bx,seg_size     ; BX = new segment size
	mov     ah,4ah          ; AH = modify memory block
	int     21h             ; free excess memory
	mov     BYTE PTR cs:reinitswitchervars,1
	ret
shrink_resident_size endp

;; input dx is message

Get_User_Response proc near

doquery:
	mov     ah, 09h
	push    cs
	pop     ds
	int     21h

	; flush all characters from keyboard queue
FlushKbdLoop:
	mov     ah,1            ; command code for check status
	int     16h             ; Is there a char in the key board buffer?
	jz      FlushDone       ; No, Flush complete

	xor     ah,ah           ; Remove the character from Keyboard buffer
	int     16h             ; Get char
	jmp     FlushKbdLoop

FlushDone:
	mov     ax, 0c01h
	int     21h
	cmp     al, NO_KEY         
	je      user_said_no
	cmp     al, YES_KEY        
	je      user_said_yes
	jmp short doquery
user_said_yes:
	mov     ax,1
	ret
user_said_no:
	mov     ax,0
	ret

Get_User_Response endp

;;;Ctrl_C handler; jumped to--no return!
Ctrl_C proc
	cmp cs:inShell,1
	jne reload_shell        ; near jump out of range
	iret                    ; are in the shell-startup-window so ignore
reload_shell:
	jmp main_loop           ; re-load shell
Ctrl_C endp


;;;; Fail all criticals during startups
fail_crit proc
    mov     al,3                ;;; fail the int21 call
    iret
fail_crit endp

num_inits db 0
int33ret dd ?
saveax dw ?


chain_int33 DD  ?
chain_int15 DD  ?

ifdef JAPAN

COPYRIGHT_LEN   =       40

ms_copyright    db      COPYRIGHT_LEN dup (0)

endif

;;; BUG BUG BUG  BUG BUG this is evil code as it bypasses
;;; hardware initialization! This is done because the
;;; initialization is toooo slow on switches; we allow init
;;; to happen once, then assume its okay. 
;;;  
;;; This is a hook on the mouse int 33 chain that keeps track of
;;; when function 0 (hard reset) occurs
handle_33 proc far
    cmp ax,0                            ; function 0?
    je  special_33
chain_33:
    jmp DWORD PTR [chain_int33]         ; chain back onto the chain
special_33:                             ; keep track of num inits (roll over at 512!)
    pushf
    call DWORD PTR[chain_int33]         ; call through -- we must see return
    or  ax,ax                           ; ax=0 if no driver
    jz special_cleanup  
    inc cs:num_inits                    ;
special_cleanup:
    iret
handle_33 endp

;;; handle_15
;;; This is a hook on the int 15 chain that blows off calling
;;; the first 6 hardware mouse functions when we are in the mouse
;;; function 33 hard reset. We do this because these functions
;;; are unacceptably slowwww.
handle_15 proc far
    cmp ax,0c200h                       ;is one of the six main mouse calls?
    jae possible_mouse                  ;usually fall through
chain_15:
    jmp DWORD PTR [chain_int15]         ;chain onto the chain
reset_mouse_hacks:
    mov cs:num_inits,0
    jmp short chain_15
possible_mouse:
    cmp ax,0c206h                       ;is it one of the six mouse calls?
    ja  chain_15                        ; if not, chain on
    ;else fall through to special case

special_15:
    ;;;enhanced mode windows needs these bacause it needs to turn
    ;;;off i/o since it is virtualizing i/o
    push    ax
    mov     ax,1600h ;enhanced mode callout
    int     2fh
    test    al,7fh   ;if not low bits set 
    pop     ax
    jnz reset_mouse_hacks

    cmp al,02                           ; function two we let through
					; twice because mouse is detecting
					; ballpoint mouse every function 0
    je  chain_15
    cmp cs:num_inits,1                  ; and we have already inited once
    ja  skip_hardware_reset             ;
    jmp short chain_15                  ;

skip_hardware_reset:                    ; then don't chain on
    clc                                 ; clear errors
    xor bh,bh                           ;
    mov ah,bh                           ; and return to caller (int 33 function 0)
    iret        
handle_15 endp


Mouse_UnHook33 proc
    push ds
    push cs
    pop ds
    lds dx, chain_int33
    mov  ax, 2533h
    int  21h         ; Restore old int 33 handler
    pop ds
    ret
Mouse_UnHook33 endp

Mouse_UnHook15 proc
    push ds
    push cs
    pop ds
    lds dx, chain_int15
    mov  ax, 2515h
    int  21h         ; Restore old int 15 handler
    pop ds
    ret
Mouse_UnHook15 endp


IF SWITCHER

;;;***
include swtch_re.inc
;;;***
ENDIF
; ----  Program resident data area  ----
;

include resmsg.inc

startup_name_seg dw ?
startup_name_off dw ?

dma_ptr     dd  0
PUBLIC dma_ptr
dopauseflag     db  0
reinitswitchervars db 0         ; set if switcher globals are invalidated

myPSP       dw  ?

myAllocationStrategy dw ?  ;initial results from int 21 ah = 5800
myUmbLinkState       dw ?  ;initial results from int 21 ah = 5803

inShell db      0          ;in shell Ctrl-C startup window?
isBallPoint     db 0          ;detected a ballpoint mouse?

par_blk  dw     0               ; use current environment
cmd_loc  dw     COMMANDLINEOUT  ; command-line address
cmd_seg  dw     0               ; fill in at initialization
	 dw     offset fcb1     ; default FCB #1
fcb1_seg dw     0               ; fill in at initialization
	 dw     offset fcb2     ; default FCB #2
fcb2_seg dw     0               ; fill in at initialization

fcb1     db     0
	 db     11 dup (' ')
	 db     25 dup ( 0 )
fcb2     db     0
	 db     11 dup (' ')
	 db     25 dup ( 0 )

	 dw     25 dup ( 0 )   ; program stack area
stk      dw     0

last equ $
gresSwitchInfo db SIZE Switch_Info DUP(?)
;;last equ $
last_switcher equ $             ; last address used if switcher present

;;;** transient data/code **
WaitBeforeErase db 0
PUBLIC WaitBeforeErase
include transmsg.inc
do_resident:
IF SWITCHER

;
;   Determine if this is a ballpoint mouse.  If so, don't do funky
;   mouse hacks
;   NOTE this detection code came from window's 386 (with modifcations!)
       mov     cs:IsBallPoint,1 

       mov     ax,0c200h         ;check for error if we
       mov     bh,0             ;try to disable the mouse
       int     15h              ;we do this because on some
       jc      not_ballpoint    ;machines c202,bh=0 done twice locks the keyboard
				;if no mouse driver is loaded.  This call
				;will return carry 

       mov     ax, 0C202h
       mov     bh, 0
       Int     15h                             ; Set to 10hz
       jc      not_ballpoint
 
       mov     ax, 0C202h
       mov     bh, 2              ; Set it back to 40hz
       Int     15h
       jc      not_ballpoint
 
       mov     ax, 0C204h
       Int     15h
       jc      not_ballpoint
       cmp     bh, 2
       je      is_ballpoint
not_ballpoint:

       mov     cs:isBallPoint,0
	call Mouse_Hook15
	call Mouse_Hook33
is_ballpoint:
	;;;***
	call    Switcher_Hook
	;;;***
	;;;***
	;;;this is now done at shell launch time 
	;mov ax,4a05h
	;mov si,CINIT_PROGRAM_LIST
	;int 2fh
	;;;***
ENDIF
	mov     ax,cs           ; set up segment registers
	mov     ds,ax
	mov     ss,ax           ; set up stack pointer
	mov     sp,offset cs:stk
	assume cs:cseg,ds:cseg,ss:cseg

	mov     ax,cs:myPSP     ; ES = segment to shrink
	mov     es,ax
	mov     bx,seg_swtch_size     ; BX = new segment size
	mov     ah,4ah          ; AH = modify memory block
	int     21h             ; free excess memory
	mov     ax,cs:myPSP
	mov     cmd_seg,ax      ; setup segments in
	mov     fcb1_seg,ds     ; parameter block for EXEC
	mov     fcb2_seg,ds
	mov     dx,offset Ctrl_C
	mov     ax,2523h        ; AX = set Control-C handler
	int     21h             ; set handler to DS:DX
	mov     dx,offset fail_crit
	mov     ax,2524h        ; AX = set critical error handler
	int     21h             ; set handler to DS:DX
				; Note: DS is equal to CS
	jmp     main_loop

_GET_COMMAND_PTR proc
	mov dx,WORD PTR cs:dma_ptr[2]
	mov ax,WORD PTR cs:dma_ptr[0]
	retf
_GET_COMMAND_PTR endp
PUBLIC _GET_COMMAND_PTR

_GET_ARGS_PTR proc
	mov dx,WORD PTR cs:dma_ptr[2]
	mov ax,WORD PTR cs:dma_ptr[0]
	add ax,40h
	retf
_GET_ARGS_PTR endp

PUBLIC _GET_ARGS_PTR

_GET_WAIT_FLAG proc
	mov ax,WORD PTR cs:WaitBeforeErase
	retf
_GET_WAIT_FLAG endp
PUBLIC _GET_WAIT_FLAG

_GET_STARTUP_NAME proc
	mov dx,WORD PTR cs:startup_name_seg
	mov ax,WORD PTR cs:startup_name_off
	retf
_GET_STARTUP_NAME endp
PUBLIC _GET_STARTUP_NAME

;;; es is segment of psp on entry,
;;; scoots the command line down a bit so we can put our stuff in front
;;; WARNING assumes that COMMANDMAXLENGTH is even
scoot_command proc near
	;;; we do this backwards so we can do it in place
	std
	push ax
	push ds
	push cx
	mov cx,COMMANDMAXLENGTH    ;; we are moving words
	mov ax,es                    ;; from psp to psp
	mov ds,ax
	mov si,COMMANDLINEIN+COMMANDMAXLENGTH
	;;WARNING WARNING we are tromping on an extra 3 bytes!
	mov di,COMMANDLINEIN+129
	rep movsb
	pop cx
	pop ds
	pop ax
	ret
scoot_command endp

;; on entry cs:startup_name points to the start up name.
;; one exit, the startup name is modified to be a .exe instead
;; of a .com
startup_to_exe proc near
    push es
    push di
    mov es,cs:startup_name_seg
    mov di,cs:startup_name_off
    xor ax,ax
    repnz scasb
    ;now es:di points to null terminated "..\dosshell.com"
    sub di,4
    mov BYTE PTR es:[di],'e'
    inc di
    mov BYTE PTR es:[di],'x'
    inc di
    mov BYTE PTR es:[di],'e'
    pop di
    pop es
    ret
startup_to_exe endp

ENVSEGOFFSETINPSP equ 02Ch

;;; es is segment of psp on entry,
;;; sets globals startup_name_seg and startup_name_off
;;; kills ax,cx,di
find_startup_name proc near
	push es
	cld
	;;; we get the segment of the environment...
	mov ax,es:ENVSEGOFFSETINPSP
	mov es,ax
	;;; whose offset is 0...
	xor ax,ax
	mov di,ax
	mov cx,-1
keep_looking:
	;;; and scan to the end of it to find the start-up name
	repnz scasb
	;;;repnz scasw puts di one farther than first non-match
	;;;also a zero here?
	cmp es:[di],al
	jz  found
	loop keep_looking
found:
	add di,3 ;;;1 for zero,2 for initial word in front of name
	;;;es:di points to startup name
	;;;save it
	mov cs:startup_name_seg,es
	mov cs:startup_name_off,di
	pop es
	ret
find_startup_name endp

Mouse_Hook33 proc
    push ds
    push cs
    pop ds
    mov ax,3533h                 ; save interrupt 33
    int 21h
    mov WORD PTR chain_int33,bx
    mov ax,es
    mov WORD PTR chain_int33[2],ax

ifdef JAPAN
	cld
	push    ds
	push    es
	mov     ds,ax
	mov     ax,cs
	mov     es,ax
	mov     si,bx
	sub     si,COPYRIGHT_LEN
	lea     di,ms_copyright
	mov     cx,COPYRIGHT_LEN
	rep     movsb                   ; copy copyright string
	pop     es
	pop     ds
endif

    mov dx,offset handle_33             ;patch interrupt 33 with
    mov ax,2533h                        ;our own routine
    int 21h
    pop ds
    ret
Mouse_Hook33 endp


Mouse_Hook15 proc
    push ds
    push cs
    pop ds
    mov ax,3515h                 ; save interrupt 15
    int 21h
    mov WORD PTR chain_int15,bx
    mov ax,es
    mov WORD PTR chain_int15[2],ax
    mov dx,offset handle_15             ;patch interrupt 15 with
    mov ax,2515h                        ;our own routine
    int 21h
    pop ds
    ret
Mouse_Hook15 endp


;;;***
IF SWITCHER
IFNDEF QLOADER
include swtch_tr.inc
ENDIF
;;;***
ENDIF

print_copyright proc near
	push ax
	push ds
	push dx
	mov     ah, 09h
	push    cs
	pop     ds
	mov     dx, offset Startup_string
	int     21h
	mov     ah, 09h
	push    cs
	pop     ds
	mov     dx, offset Copyright_string
	int     21h
	pop dx
	pop ds
	pop ax
	ret
print_copyright endp

cseg     ends
	 end    start

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\loader\tstshell.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>

unsigned char far *realdma_ptr;
char temp[256];
char command[256];
char parameters[256];

extern void fstrncpy(unsigned char far *d,unsigned char far *s,unsigned int len);
extern unsigned char far * far cdecl GET_COMMAND_PTR(void);
extern unsigned char far * far cdecl GET_ARGS_PTR(void);
extern unsigned char far cdecl GET_WAIT_FLAG(void);
void far cdecl C_INIT_PROGRAM_LIST(void);
void far cdecl C_GO_Z_NEXT(void);
void far cdecl C_GO_Z_PREV(void);
void far cdecl C_GO_NEXT(void);
void far cdecl C_ADD_PARAMS(char far *s,int length);
void far cdecl C_ADD_PROGRAM(char far *s);
unsigned far cdecl C_GET_EXITCODE () ;
void far cdecl C_DELETE_PROGRAM(int i);
char far * far cdecl C_GET_GLOBAL_SWITCH_DATA(void);
char far * far cdecl C_GET_ITH_ENTRY_DATA(int i);
char far * far cdecl C_GET_ITH(int i);
char far cdecl C_GET_LIST_LENGTH(void);

void cdecl main()
{
    int i,len;
    int c;
	 unsigned ec ;

	    /* if there has been an error, display the error code and info */
		 ec = C_GET_EXITCODE () ;
		 if (ec)
		 {
		   printf ("\nError = 	%x : ** %Fs ** \n", ec, C_GET_ITH (0)) ;
	      C_DELETE_PROGRAM(0);
		 }


       printf("\nCurrent Task List\n");
       len = C_GET_LIST_LENGTH();
       for(i=0;i<=len;i++)
       {
	    printf("** %Fs **\n",C_GET_ITH(i));
       }
       printf("hit a key: 1=Next Z 2 = Prev 3 = Next 4 = delete top 5 = Top \n, other cont.");
       while(!kbhit())
	  ;
       c= getch();
       if(c == '1')
	   C_GO_Z_NEXT();
       if(c == '2')
	   C_GO_Z_PREV();
       if(c == '3')
	   C_GO_NEXT();
       if(c == '4')
	   C_DELETE_PROGRAM(0);

    realdma_ptr = GET_COMMAND_PTR();
    if ((c>= '1') && (c<='5') && len >= 0) goto RestartApp ;

    printf("RUNNING THE SHELL INTERFACE NOW>>>\n");
    printf("Run...: ");
    gets(command);
    /* exit means leave */
    if ((command[0] == 'e') && (command[1] == 'x'))
    {
	printf("EXITING!\n");
	realdma_ptr[0] = 0xFF;
	return;
    }
    printf("Parameters: ");
    gets(parameters);
    C_ADD_PROGRAM((char far *) command);
    C_ADD_PARAMS((char far *) parameters,strlen(parameters));

RestartApp:

    fstrncpy((char far *)realdma_ptr,(char far *) "winoldap.exe",13);
    realdma_ptr = GET_ARGS_PTR();
    realdma_ptr[6] = ' '; /* be sure it is not equal to VOODOO */
    fstrncpy((char far *)realdma_ptr+2,(char far *)parameters,53);
    realdma_ptr[0] = (char) strlen(parameters)+1;
    realdma_ptr[1] = ' ';
    realdma_ptr[strlen(parameters)+2] = '\r';
    /* exit to launch */
}

/* fstrncpy() -
**
** DESCRIPTION
**	Copies exactly len bytes from far null-terminated source string 
**	to destination string.
*/
void fstrncpy(d, s, len)
unsigned char far *d;
unsigned char far *s;
unsigned int	len;
	{
	while (len--)
		*d++ = *s++;
	}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\asmutils.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; ZZZZZZ Are there bugs with offset calculations?? Is DGROUP the right
; assume for DS? I am unable to access variable DoQuickCompare from 'C'
; The offset is off by 64 bytes!!

?WIN = 0                ;Not windows;
?PLM = 1                ;DO use pl/m
include cmacros.inc

DOS_NAMETRANS   EQU             60h

sBegin data
	crlf    db  0dh, 0ah, '$'
sEnd data

sBegin code
    assumes cs, code
    assumes ds, DGROUP

int10chain dd 0         ;; int 10 chain pointer 


;;;XMS calls are hear so dosshell can delete XMS when
;;;user deletes an app in tasklist
xmscallptr dd  0
;;; initialized XMS
;;; returns 0 if no XMS
;;; otherwise returns 1 and sets global ptr
cProc InitXMS, PUBLIC, <si,di>
cBegin InitXMS
	mov ax,4300h
	int 2fh
	cmp al,80h
	jne notinstalled
	mov ax,4310h    ;; 
	int 2fh
	mov WORD PTR xmscallptr[0],bx
	mov WORD PTR xmscallptr[2],es
	mov ax,1
	jmp short isinstalled
notinstalled:
	xor ax,ax
isinstalled:
	
cEnd

cProc FreeXMSHandle, PUBLIC, <si,di>
parmW handle
cBegin FreeXMSHandle
	;; unlock first
	mov     ah,0Dh
	mov     dx,handle
	call    DWORD PTR [xmscallptr]
	mov     ah,0Ah
	mov     dx,handle
	call    DWORD PTR [xmscallptr]
cEnd FreeXMSHandle

cProc  Get_CWD, PUBLIC,  <si,di>
parmW   destination
cBegin Get_CWD
	;;; first get current drive
	mov ah,19h
	int 21h
	;;; al has drive letter zero based; 

	mov dl,al      ; save drive letter
	add al,'A'
	mov si,destination
	mov [si],al
	inc si
	mov BYTE PTR [si],':'
	inc si
	mov BYTE PTR [si],'\'
	inc si
	
	inc dl          ;next calls wants one based drive letter
	mov ah,47h      ;getcwd
	int 21h

cEnd Get_CWD

cProc  Dos_Version, PUBLIC,  <si,di>
cBegin Dos_Version
	mov ax,3000h
	int 21h
	xor ah,ah
cEnd  Dos_version

;
; This call replaces the puts C function.
;
;
cProc  Shell_TTY_Out, PUBLIC,  <si,di,ds,es>
parmW  outstring
cBegin Shell_TTY_Out
	push    ds
	pop     es

	xor     al,al
	mov     dx,outstring
	mov     di,dx   
	mov     cx,-1
	cld
	repne scasb
	dec     di
	mov     BYTE PTR [di],'$'
	mov     ah,09h
	int     21h
	mov     BYTE PTR [di],0
	lea     dx,crlf
	;mov    ah,09h
	int     21h

cEnd   Shell_TTY_Out


;;;
;;;BUG BUG BUG HACK HACK HACK
;;;Standard hook/unhook code, see int10hook below
;;;
cProc  HookISR10, PUBLIC,  <si,di,ds,es>
cBegin HookISR10
	    push cs
	    pop  ds

	    mov ax,3510h                 ; save interrupt 10 location
	    int 21h

	    mov WORD PTR cs:int10chain,bx
	    mov ax,es
	    mov WORD PTR cs:int10chain[2],ax

	    mov dx,offset Int10Hook      ;patch interrupt 10 vector with
	    ;;; ds already holds code segment
	    mov ax,2510h                 ;our own routine
	    int 21h
cEnd  HookISR10

cProc  UnHookISR10, PUBLIC,  <si,di,ds,es>
cBegin UnHookISR10

	    mov dx,WORD PTR cs:int10chain        ;patch interrupt 10 vector with
	    mov ds,WORD PTR cs:int10chain[2]
	    mov ax,2510h                 ;the old handler
	    int 21h
nothooked:
cEnd  UnHookISR10

;;;BUG BUG BUG HACK HACK HACK
;;;We were having problems with graphics drawing when the mouse was
;;;loaded.  We traced the problem down to int10 function FA; the device
;;;drivers call this to get mouse info. However, we turn off the mouse
;;;before all calls to the driver, so it doesn't need to know.
;;;the drivers mouse code calls the ROM BIOS that is pathetically slow from hell.
;;;If we lie to the device drivers, graphics performance is enhanced
;;;significantly since the BIOS calls are no longer made.
;;;Note we only need to bracket the driver initialization with this hook
;;;as the drivers set internal flags
Int10Hook proc far
	cmp     ah,0FAh
	je      mousehack
	jmp     DWORD PTR cs:[int10chain]
mousehack:
	xor     bx,bx
	iret
Int10Hook endp


;;;;  BOOL translate_name(char far *src, dest) ;
;;;;  returns 0 if call succeeds, else 1.
cProc  translate_name, PUBLIC,  <si,di,ds,es>
parmW src_segment
parmW src_offset
parmW dest_segment
parmW dest_offset
cBegin  translate_name
    mov di, dest_offset
    mov es, dest_segment

    mov si, src_offset
    mov ds, src_segment
    assumes     ds,nothing

	mov     ah, DOS_NAMETRANS
	int     21h
	
	mov ax, 0       ; Zero out ax without affecting CY flag.
	rcl ax, 1

cEnd  translate_name

;;;; This function returns TRUE (AX = 1) if the two ALT keys should be
;;;; treated differently by CW, else it returns FALSE. We want to treat
;;;; the left ALT key and the right ALT key (also known as ATL-GR)
;;;; differently if KEYB is installed and the country is other than
;;;; US and we are on the other side of the "fence" (i.e., in the
;;;; Ctrl+Alt+F2 side).
;;;;
cProc  FTreatAltsDifferently, PUBLIC,  <si,di,ds,es>
cBegin FTreatAltsDifferently
	mov	ax, 0ad80h
	int	2fh	; see if KEYB is installed, return value of AL=0ffh
	inc	al	; means KEYB installed, else AL remains 80h
	jnz	FTADTreatSame
	
	; If we are here, it means that KEYB is installed
	cmp	WORD PTR es:[di+16h], 'SU'	; Is it US?
	jz	FTADTreatSame

	; If we are here, KEYB is loaded and the country is not US!
	mov	ax, 0ad83h	; ah is not 0adh any more!
	int	2fh		; If COUNTRY_FLAG is enabled, BL=0ffh, else
	inc	bl		; BL=00 meaning it is in a Ctrl+Alt+F1'd state.
	jnz	FTADTreatSame

	mov	al, 01
	jmp 	short FTADDone

FTADTreatSame:
	xor	al, al

FTADDone:
	xor	ah, ah
cEnd  FTreatAltsDifferently


;---------------------------------------------
; RepeatMove - very fast repeat move with long args
;       Syntax   RepeatMove(char far *dest, char far *src, cnt)
;---------------------------------------------
cProc   RepeatMove,<PUBLIC,FAR>,<di,si>
	parmD   lpDest
	parmD   lpSrc
	parmW   cnt
cBegin
	push    ds
	les     di,lpDest
	lds     si,lpSrc
	mov     cx,cnt
	mov     BX,CX
;see which is bigger
	cmp     SI,DI           ;is source bigger than dest?
	ja      repm1           ;this is only a 16 bit guess, but...
				;if they differ in segments it should be
				;irrelevant
	std
	add     si,cx
	add     di,cx
	dec     si
	dec     di
	shr     BX,1
	jnc     repm0a
	movsb
repm0a:
	shr     CX,1
	jcxz    repm2
	dec     si
	dec     di
	rep     movsw
	jmp     short repm2
;move upwards
repm1:
	cld
	shr     CX,1
	jcxz    repm1a
	rep     movsw
repm1a:
	shr     BX,1
	jnc     repm2
	movsb
repm2:
	cld
	pop     ds
cEnd



.386
;******************************************************************************
;   DetectProcessor - return type of processor (386/486 vs. 8088/86/286).
;       This routine relies on Intel-approved code that takes advantage
;       of the documented behavior of the high nibble of the flag word
;       in the REAL MODE of the various processors.  The MSB (bit 15)
;       is always a one on the 8086 and 8088 and a zero on the 286 and
;       386/486.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
;       always zero on the 286, but can be set on the 386.
;
;       For future compatibility of this test, it is strongly recommended
;       that this specific instruction sequence be used.  The exit codes
;       can of course be changed to fit a particular need.
;
;       CALLABLE FROM REAL MODE ONLY 
;
;       this routine was stolen from EMM/386 source code
;
;   ENTRY:  (none)
;
;   EXIT:   0 = 8086/8088
;           2 = 286
;           3 = 386
;          -4 = >=486
;------------------------------------------------------------------------------
CPU086088       equ     0
CPU186          equ     1       ;not detected here
CPU286          equ     2
CPU386          equ     4
CPU486ORABV     equ     8

cProc DetectProcessor, PUBLIC <si,di,ds,es>
cBegin DetectProcessor
	pushf                           ; save entry flags

	xor     ax, ax                  ; 0000 into AX
	push    ax
	popf                            ; try to put that in the flags
	pushf
	pop     ax                      ; look at what really went into flags
	test    ax, 08000h              ;Q: was high bit set ?
	jnz     short cpu_is_8086       ;  Y: 8086/8088
	mov     ax, 07000h              ;  N: try to set the NT/IOPL bits
	push    ax
	popf                            ;      ... in the flags
	sti                             ; (for VDMM/IOPL0)
	pushf
	pop     ax                      ; look at actual flags
	popf                            ; restore entry flags
	test    ax, 07000h              ; Q: any high bits set ?
	jz      short cpu_is_286        ; N: 80286
    ;
    ; 386 or 486? See if we can set the AC (Alignment check) bit in Eflags
    ;   Need to insure stack is DWORD aligned for this to work properly
    ;
	push    cx
	xor     cx,cx                   ; Assume stack aligned
	mov     ax,sp
	and     ax,000011B
	jz      short NoStkAdj          ; Stack is aligned
	mov     cx,ax                   ; set "pop" count
	sub     sp,ax                   ; Move to DWORD aligned
NoStkAdj:
	pushfd                          ; save entry flags (DWORD)
	push    dword ptr 40000h        ; AC bit
	popfd
	pushfd
	pop     eax
	popfd                           ; Recover entry flags (DWORD)
	test    eax,40000h              ; Did AC bit set?
	jnz     short cpu_is_486        ; Yes, 486
	inc     ax                      ; Make AX non-zero
	add     sp,cx                   ; pop off alignment bytes
	pop     cx                      ; Entry cx
	mov     ax,CPU386               ; 386 detected
	jmp     short donedetection

cpu_is_486:
	add     sp,cx                   ; pop off alignment bytes
	pop     cx                      ; Entry cx
	mov     ax,CPU486ORABV          ; 486 detected
	jmp short donedetection

cpu_is_8086:
	popf                            ; restore flags
	mov ax,CPU086088                ; 8086/8088 detected
	jmp short donedetection
cpu_is_286:
	mov ax,CPU286                   ; 286 detected
	;;jmp short donedetection fall through
donedetection:
	;debug int 3
cEnd DetectProcessor
	

;; for profiler
;
;cProc  ClockOn, PUBLIC,        <si,di,ds,es>
;cBegin ClockOn
;       push ax
;       mov ax,1
;       int 3
;       pop ax
;cEnd  ClockOn
;
;cProc  ClockOff, PUBLIC,       <si,di,ds,es>
;cBegin ClockOff
;       push ax
;       mov ax,0
;       int 3
;       pop ax
;cEnd  ClockOff

;;;WARNING .386 is still on!

sEnd   code

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\loader\swtch_re.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

MAX_NUM_PROGRAMS equ 16
MAX_PROGRAM_LENGTH equ 80
MAX_TITLE  equ 30

; DONOT CHANGE THE SIGNIFICANCE OF THE BIT FLAGS WITHOUT MAKING CORRESPONDING
; CHANGES IN THE SWITCHER INCLUDE FILE WOAPIF.INC

F_NO_SWITCH        equ 0000000000000001b ;program can not be switched away from
F_GRAPHICS         equ 0000000000000010b ;graphics mode
F_NO_PAUSE         equ 0000000000000100b ;Pause after exit
;F_DTS_API_INITED   equ 0000000000001000b ;1=>The DTS init has been posted;set by shell
;F_SWAP_NOT_OK      equ 0000000000010000b ;1=>external tasker incompatible;set by shell
F_UNUSED_3         equ 0000000010000000b ;
F_UNUSED_4         equ 0000000000100000b ;
F_SHELL            equ 0000000001000000b ;program is the shell

F_NO_ALT_TAB       equ 0000000100000000b ;ALT+TAB to be ignored
F_NO_ALT_ESC       equ 0000001000000000b ;ALT+ESC to be ignored
F_NO_CTRL_ESC      equ 0000010000000000b ;CTRL+ESC to be ignored
F_UNUSED_5         equ 0000100000000000b ;
F_UNUSED_6         equ 0001000000000000b ;
F_UNUSED_7         equ 0010000000000000b ;
F_UNUSED_8         equ 0100000000000000b ;
F_FREE             equ 1000000000000000b ;free program slot

; equates for global flags

GF_INT_6F_TOBE_DONE     equ     00000001b ;INT 6f to be done
GF_IRQ9_GLOBAL          equ     00000010b ;IRQ 9 to be globally handled
GF_NET_ASYNC_SWITCH_OK  equ     00000100b ;OK to switch out on async net request

GF_DTS_API_INITED   equ 0000000000001000b ;1=>The DTS init has been posted;set by shell
GF_SWAP_NOT_OK      equ 0000000000010000b ;1=>external tasker incompatible;set by shell

;GF_UNUSED_1             equ     00001000b ;
;GF_UNUSED_2             equ     00010000b ;
GF_UNUSED_3             equ     00100000b ;
GF_UNUSED_4             equ     01000000b ;
GF_UNUSED_5             equ     10000000b ;

Switch_Entry   STRUC
       Program_Name    db MAX_PROGRAM_LENGTH  DUP(?); Program name
       Program_Title   db MAX_TITLE DUP (?)      ; switcher screen title
       Conv_Req        dw ?                      ; min conv mem required
       XMS_Req         dw ?                      ; XMS required
       XMS_Want        dw ?                      ; XMS desired
       HK_Scan_Code_1  db ?                      ; 1st directed hot key scan code
       HK_Scan_Code_2  db ?                      ; 2nd directed hot key scan code
       HK_Shift_State  db ?                      ; ALT/CTRL/SHIFT states
       Program_Flags   dw ?                      ; Special flags for program
       Next_In_List    db ?                      ; Next program in Z order list
       Program_Id      dw ?                      ; internal program ID
       Path_Id         db ?                      ; internal id of swap path
       Shell_Cookie    dw ?                      ; magic cookie for shell
Switch_Entry   ENDS

Switch_Info    STRUC
       Switcher_Id     db   ?                    ; low nibble is unique id
       CPU_Type        dw   ?                    ; CPU type flag bits
       SFT_Size        dw   ?                    ; SFT SIZE
       Parameters      db   130 dup (?)          ; parameters to the program
       Grabber_Name    db   80 dup (?)           ; grabber path and name
       Swap_Path1      db   68 dup (?)           ; first swap drive and path 
       Swap_Path2      db   68 dup (?)           ; second swap drive & path
       Min_Path1       dw   ?                    ; min k space to be left on drv1
       Min_Path2       dw   ?                    ; min k space to be left on drv2
       XMS_Handle      dw   ?                    ; Handle of locked XMS block
       XMS_Size        dd   ?                    ; size of block in bytes
       Int_15_Users_Id dw   ?                    ; ID of app using INT 15 memory
       Id_Serial       dw   ?                    ; running app serial number
       Exit_Code       dw   ?                    ; switcher exit code
       Num_Lines       db   ?                    ; start up screen lines
       Global_Flags    db   ?                    ; various global descisions
       Screen_Back     db   ?                    ; back ground screen color
       Title_Fore      db   ?                    ; Title text color
       Title_Back      db   ?                    ; Title back ground color
       Num_Programs    db   ?                    ; number of programs in the list
       First_In_List   db   ?                    ; first program in Z order list
       Program_List    db SIZE Switch_Entry *MAX_NUM_PROGRAMS DUP(?)
Switch_Info    ENDS

;; THIS IS DECLARED IN LOADER.ASM NOW gresSwitchInfo db SIZE Switch_Info DUP(?)

GlobalSwitcherId dw ?

GET_DATA proc
;;;BUG BUG WHY WAS THIS    mov ax,CSEG
    mov ax,cs
    mov ds,ax
    ret
GET_DATA endp

;;;
;;; INPUT
;;; ds:di -> Switch_Info struct
;;; bl = index to the program array
;;; OUTPUT
;;;  ds:si -> bl'th program entry
;;;  ax is toasted
DoGet_Ith_Program_Entry proc
;;get bl'th guy in array -> si
     mov al,SIZE Switch_Entry
     mul bl    ; ax now holds offset in program list of first entry
     lea si,[di].Program_List
     add si,ax  ; ds:si bl'th first entry in list
     ret
DoGet_Ith_Program_Entry endp

;;;
;;; INPUT
;;; ds:di -> Switch_Info struct
;;; bl = index to the program in the linked list
;;; OUTPUT
;;;  ds:si -> bl'th program entry
;;;  ax,cx are toasted
Get_Ith_List_Program_Entry proc
;;get bl'th guy in list -> si
      xor ch,ch
      mov cl,bl
      mov bl,[di].First_In_List
      call DoGet_Ith_Program_Entry
      or cx,cx
      jz got_ith
walk_link:
      mov bl,[si].Next_In_List
      call DoGet_Ith_Program_Entry
      loop walk_link
got_ith:
     ret
Get_Ith_List_Program_Entry endp

PUBLIC _ToTop_Ith_List_Program_Entry
;;;
;;; INPUT
;;; ds:di -> Switch_Info struct
;;; bl = index to the program in the linked list
;;; OUTPUT
;;;  es:si -> bl'th program entry and that is moved to the top
;;;  ax,dx is toasted
_ToTop_Ith_List_Program_Entry proc 

      push bx                           ;save logical node number
      or   bl,bl                        ;is it already at top ?
      jz   totop_exit                   ;yes, not much to do 

      cmp  bl,[di].Num_Programs         ;last in the list ?
      jnz  neither_first_nor_last       ;no.
      dec  bl                           ;previous node
      call Get_Ith_List_Program_Entry   ;DS:SI -> previous node.
      mov  al,[si].Next_In_List         ;node # of node we wanna move to top
      mov  [di].First_In_List,al        ;new top node all other links OK
      xor  bl,bl                        ;need pointer to top node
      jmp  short totop_exit             ;done

neither_first_nor_last:

      push bx                           ;save
      mov  bl,[di].Num_Programs         ;last node in list
      call Get_Ith_List_Program_Entry   ;DS:SI -> last node in the list
      mov  dx,si                        ;save pointer
      pop  bx                           ;restore
      push dx                           ;save pointer to last node

; get a pointer to the desired node.

      push bx                           ;save
      call Get_Ith_List_Program_Entry   ;DS:SI -> node we want to move to top
      pop  bx                           ;get back node number
      mov  al,[si].Next_In_List         ;get the node following it

; link the previous node to the next node.

      push si                           ;save the pointer to the node.
      push ax                           ;al has pointer to next node
      dec  bl                           ;prev node, can't be < 0
      call Get_Ith_List_Program_Entry   ;ptr to prev node
      pop  ax                           ;get back saved ptr to next node
      mov  ah,[si].Next_In_List         ;get the physical node num of this node
      mov  [si].Next_In_List,al         ;link prev to next, skiping this node

; make the desired node the head of the list.

      mov  al,ah                        ;save desired nodes physical index
      xchg [di].First_In_List,ah        ;point start to this node

; chain the desired node to the original top of the list

      pop  si                           ;get back ptr to this node
      mov  [si].Next_In_List,ah         ;chain to the original top node

; make last node point to the desired node.

      pop  si                           ;was pushed into DX, ptr to last node
      mov  [si].Next_In_List,al         ;last points to new first

; need pointer to top node.

      xor  bl,bl                        ;now the node is at top

totop_exit:

      call Get_Ith_List_Program_Entry   ;get back a pointer to the top node
      pop  bx                           ;restore original node number
      mov  dx,ds                        ;get the ptr to the node in dx:ax
      mov  ax,si
      ret

_ToTop_Ith_List_Program_Entry endp


PUBLIC _GET_ITH_PROGRAM_STRING
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;     es:si -> Program string of Ith list entry
_GET_ITH_PROGRAM_STRING proc
      call Get_Ith_List_Program_Entry
      lea si,[si].Program_Name
      push ds
      pop es
     ret
_GET_ITH_PROGRAM_STRING endp


PUBLIC _GET_FREE_ENTRY
; returns in bl index of free entry, -1 if none
_GET_FREE_ENTRY proc
     mov cx,MAX_NUM_PROGRAMS-1
continue_find_free:
     mov bl,cl
     call DoGet_Ith_Program_Entry
     test [si].Program_Flags,F_FREE
     jne found_one
     loop continue_find_free
no_free:
     mov bl,-1
     stc
     ret
found_one:
     clc
     ret
_GET_FREE_ENTRY endp

PUBLIC _ADD_PROGRAM_TO_LIST
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;;     es:bp-> program name (first char for now!)
;;;
_ADD_PROGRAM_TO_LIST proc

     call _GET_FREE_ENTRY
     jnc  @f
     jmp  too_many_programs
@@:
     inc [di].Num_Programs
     mov cl,[di].First_In_List
     call DoGet_Ith_Program_Entry
;;; si -> new entry
     mov [si].Next_In_List,cl 
     mov [si].Program_Flags,0

     ;set various other variables that are essential
     mov [si].Conv_Req,0                ;0k conventional memory needed
     mov [si].Xms_Req,0                 ;XMS memory needed
     mov [si].Xms_Want,0                ;XMS memory desired

     mov [si].HK_Scan_Code_1,0          ;1st directed hot key scan code
     mov [si].HK_Scan_Code_2,0          ;2nd directed hot key scan code
     mov [si].HK_Shift_State,0          ;directed hot key shift state


     push si
     xchg si,bp
     xchg bp,di
     mov ax,es
     mov dx,ds
     mov ds,ax
     mov es,dx
     mov cx,MAX_PROGRAM_LENGTH
     cld
     rep movsb
     mov  ds,dx
     mov  es,ax
     mov  di,bp
     pop  si
  
;; copy the file name part of the program name as the title.

     push di
     lea  di,[si].Program_Title
     lea  si,[si].Program_Name
     mov  dx,si

; get to the end of the string first.

@@:
	lodsb
	or      al,al
	jnz     @b
	dec     si
	dec     si
;
; now walk back till '\', ':' or dx

@@:
	cmp     si,dx
	jbe     pt_2
	mov     al,[si]
	cmp     al,':'
	je      pt_1
	cmp     al,'\'
	je      pt_1
	dec     si
	jmp     @b
pt_1:
ifdef DBCS
	call	CheckDBCSTailByte	; start-DX, current-SI
	jnz	@f			; if this is not DBCS tail byte
	dec	si
	jmp	short @b		; search next
@@:
endif
	inc     si
pt_2:

; now copy the title over.

@@:
	lodsb   
	mov     [di],al
	inc     di
	inc     cx
	or      al,al
	jnz     @b
	pop     di

     mov [di].First_In_List,bl

     ; set that last guy to point to front
     push bx
     mov bl, [di].Num_Programs
     call Get_Ith_List_Program_Entry
     pop dx
     mov [si].Next_In_List,dl

     clc
     ret
too_many_programs:
     ret
_ADD_PROGRAM_TO_LIST endp

ifdef DBCS	; ### if DBCS ###
;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
	cmp	word ptr cs:DBCSLeadByteTable+2,0
	jnz	idlb_check		; if table is already set
	push	ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	pop	ax
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp

;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:dx = start address of the string
;		ds:si = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	si
	mov	cx,si			; save character position
cdtb_check:
	cmp	si,dx
	jz	cdtb_next		; if at the top
	dec	si			; go back
	mov	si,[bx]			; get character
	call	IsDBCSLeadByte
	jz	cdtb_check		; if DBCS lead byte do next
	inc	si			; adjust
cdtb_next:
	sub	cx,si			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	si
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif		; ### end if DBCS ###


PUBLIC _GO_Z_NEXT
;;; Reorder the program list such that the next Z order program is
;;; brought to front and the Z order is maintained.
;;; ie first in list is second and second is first
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;     NO CY
;;;     ds:di -> Switch_Info struct
;;;     CY
;;;         Less than two programs in list
;;;     ax,bx,cx,dx are toasted
_GO_Z_NEXT proc
	cmp [di].Num_Programs,1
	jb  outofhere
	mov bl,[di].First_In_List
	call DoGet_Ith_Program_Entry
;HEAD -> first->Second->Third
	mov bl,[si].Next_In_List ;
	mov al,SIZE Switch_Entry
	mul bl   ;ax now holds offset in program list of second entry
	lea bp,[di].Program_List
	add bp,ax  ; ds:bp holds second entry in list
	xchg si,bp
	mov cl,[si].Next_In_List
	xchg si,bp
	mov dl,[si].Next_In_List
	mov [si].Next_In_List,cl
;HEAD -> SI=First->third ; BP=Second->third
	mov al,[di].First_In_List
	xchg si,bp
	mov [si].Next_In_List,al
	xchg si,bp
;HEAD -> SI=First->third ; BP=Second->First
	mov [di].First_In_List,dl
	clc
;HEAD=Second -> SI=First->third ;
	;; set that last guy to point to front
	mov bl, [di].Num_Programs
	push dx
	call Get_Ith_List_Program_Entry
	pop dx
	mov [si].Next_In_List,dl
outofhere:
	ret
_GO_Z_NEXT endp


PUBLIC _DELETE_PROGRAM_FROM_LIST
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;;     bl is which element in list order
;;;
_DELETE_PROGRAM_FROM_LIST proc
    or bl,bl
    jz special
    dec bl
dodelete:
    call Get_Ith_List_Program_Entry
    mov bl,[si].Next_In_List
    mov bp,si
    call DoGet_Ith_Program_Entry
    mov dl,[si].Next_In_List
    mov [si].Program_Flags,F_FREE
    mov word ptr [si].Program_Id,0
    mov byte ptr [si].Path_Id,0
    mov si,bp
    mov [si].Next_In_List,dl
    dec [di].Num_Programs
    ret
special:
    call _GO_Z_NEXT
    mov bl,0
    jmp short dodelete
_DELETE_PROGRAM_FROM_LIST endp

PUBLIC _GO_Z_PREV
;;; Reorder the program list such that the previous Z order program is
;;; brought to front and the Z order is maintained.
;;; ie last goes to first
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;     NO CY
;;;     ds:di -> Switch_Info struct
;;;     CY
;;;         Less than two programs in list
;;;     ax,bx,cx,dx are toasted
_GO_Z_PREV proc
    mov bl,[di].Num_Programs
    cmp bl,1
    jb prevout
    dec bl
    mov dl,[di].First_In_List
    call Get_Ith_List_Program_Entry
    mov bl,[si].Next_In_List
    mov [di].First_In_List,bl
    ;;call DoGet_Ith_Program_Entry
    ;;mov [si].Next_In_List,dl
    clc
prevout:
    ret
_GO_Z_PREV endp

PUBLIC _GO_NEXT
;;; Reorder the program list such that the previous Z order program is
;;; brought to front and the Z order is maintained.
;;; ie last goes to first
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;     NO CY
;;;     ds:di -> Switch_Info struct
;;;     CY
;;;         Less than two programs in list
;;;     ax,bx,cx,dx are toasted
_GO_NEXT proc
       mov cl,[di].Num_Programs
       cmp cl,1
       jb nextout
       mov bl,[di].First_In_List
       call DoGet_Ith_Program_Entry
       mov al,[si].Next_In_List
       mov [di].First_In_List,al
nextout:
    ret
_GO_NEXT endp

PUBLIC _GET_LIST_LENGTH
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;;    ax = number of items in list (zero based,  -1 == 0)
_GET_LIST_LENGTH proc
       xor ax,ax
       mov al,[di].Num_Programs
       ret
_GET_LIST_LENGTH endp

PUBLIC _GET_GLOBAL_SWITCH_DATA
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;    dx:ax -> global data structure
_GET_GLOBAL_SWITCH_DATA proc
       ;;; This was set-up on entry. Swap ds and get out
       mov dx,ds
       mov ax,di        
       ret
_GET_GLOBAL_SWITCH_DATA endp

PUBLIC _GET_ITH_ENTRY_DATA
_GET_ITH_ENTRY_DATA proc
      call Get_Ith_List_Program_Entry
      push ds
      pop es
     ret
_GET_ITH_ENTRY_DATA endp

PUBLIC _ADD_PARAMS
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;;     es:bp -> command line parameters
;;;     bl = command line length
;;; OUTPUT
;;;
_ADD_PARAMS proc
       mov [di].Parameters,bl
       inc BYTE PTR [di].Parameters
       mov [di].Parameters+1,' '
       xor cx,cx
       mov cl,bl
       push es
       push ds
       pop  es
       pop  ds
       lea di,[di].Parameters+2
       mov si,bp
       cld
       rep movsb
       mov WORD PTR es:[di],0Dh
       ret
_ADD_PARAMS endp

PUBLIC _ADD_PARAMS
;;; INPUT
;;;     ds:di -> Switch_Info struct
;;; OUTPUT
;;;     ax    -> exit code
_GET_EXITCODE proc
       mov ax,[di].Exit_Code
       ret
_GET_EXITCODE endp
PUBLIC _GET_EXITCODE


csShell    db 'MS-DOS Shell',0
;;;           db 67 dup (0) 
;csGrabName db 'd:\vgacolor.gr2',0
;csSwap1Path db 'd:\',0
;csSwap2Path db 'c:\',0

PUBLIC _INIT_PROGRAM_LIST
;;; INPUT
;;;     ds:di -> Switch_Info struct
_INIT_PROGRAM_LIST proc

     ;;mov [di].Commands,1     ; NULL command
     ;;bug bug mov [di].Commands,0     ; NULL command
     mov [di].Num_Programs,-1 ; No Programs

;; copy the grabber name 

;     push       es
;     push       ds
;     push       ds
;     pop        es
;     push       cs
;     pop        ds
;     push       di
;     add        di,Grabber_Name
;     mov        cx,80
;     lea        si,csGrabName
;@@:
;     lodsb
;     stosb
;     or         al,al
;     jnz        @b
;
;     pop        di
;     push       di
;     add        di,Swap_Path1
;     mov        cx,80
;     lea        si,csSwap1Path
;@@:
;     lodsb
;     stosb
;     or         al,al
;     jnz        @b
;
;     pop        di
;     push       di
;     add        di,Swap_Path2
;     mov        cx,80
;     lea        si,csSwap2Path
;@@:
;     lodsb
;     stosb
;     or         al,al
;     jnz        @b
;
;     pop        di
;     pop        ds
;     pop        es
     mov        [di].Id_Serial,0
     mov        [di].Int_15_Users_Id,0
     mov        [di].Num_Lines,25
     mov        [di].Global_Flags,0
     mov        [di].Screen_Back,70h
     mov        [di].Title_Fore,0
     mov        [di].Title_Back,30h
     mov        [di].Num_Lines,25 
     ;;;  BUG BUG this following assumes we get called only after dts inited!
     mov        [di].Global_Flags,GF_IRQ9_GLOBAL OR GF_DTS_API_INITED
;     mov        [di].SFT_Size,53        ;; SFT size (!bug !bug)
;     mov        [di].CPU_Type,0         ;; (!bug !bug)
;     mov        [di].Min_Path1,50       
;     mov        [di].Min_Path2,150      
     mov        [di].XMS_Handle,0
     mov        word ptr [di][0].XMS_Size,0
     mov        word ptr [di][2].XMS_Size,0


     ;;; mark all entries as freee
     mov cx,MAX_NUM_PROGRAMS-1
initnext:
     mov bx,cx
     call DoGet_Ith_Program_Entry
     mov [si].Program_Flags,F_FREE
     mov [si].Program_Id,0
     mov [si].Path_Id,0
     loop initnext
     mov [di].First_In_List,0; First program is zero'th

; now add the shell to the list.

     push es
     push bp
     push cs
     pop  es
     lea  bp,csShell
     call _ADD_PROGRAM_TO_LIST
     pop  es
     pop  bp

; get the top program and set the F_SHELL flag

     mov bl,[di].First_In_List
     call DoGet_Ith_Program_Entry
     or  [si].Program_Flags,F_SHELL

     ret
_INIT_PROGRAM_LIST endp




chain_int2f DD  ?

Switcher_Hook proc
    push ds
    push cs

;;; hook int2f so we can handle switcher stuff
    pop ds
    mov ax,352Fh                 ; save interrupt 2f
    int 21h
    mov WORD PTR chain_int2f,bx
    mov ax,es
    mov WORD PTR chain_int2f[2],ax
    mov dx,offset handle_lists          ;patch interrupt 2f with
    mov ax,252fh                        ;our own routine
    int 21h

;;;  DTS API indicates that we must get a unique ID for our switcher
;;;  If no-one is around to answer, we have to ourselves become the
;;;  Id handler
    mov ax,4b03h
    xor bx,bx 
    mov es,bx
    mov di,bx
    mov cx,0D055h 
    int 2fh ;; allocate switcher id
    or bx,bx
    jnz Idsalreadyhandled
    ;;; we have to make ourselves a new id, and handle IDs from now on
    mov BYTE PTR cs:gresSwitchInfo.Switcher_Id,1  ;; we are ID 1
    mov cs:GlobalSwitcherId,1
    jmp short doneswitcherhooks
idsalreadyhandled:
    mov cs:gresSwitchInfo.Switcher_Id,bl
    mov cs:GlobalSwitcherId,0
doneswitcherhooks:
    pop ds
    ret
Switcher_Hook endp

Switcher_UnHook proc
    push ds
    push cs
;;; first we de-allocate our switcher_id, if we have one
    cmp GlobalSwitcherID,0
    jnz noIDfree  ;; we were handling IDs
    push es
    push di
    push bx
    mov ax,4b04h ;; Free_Switcher_ID
    xor bx,bx
    mov es,bx
    mov di,bx
    mov bl,cs:gresSwitchInfo.Switcher_Id
    int 2fh    ;; do free_switcher id
    pop bx
    pop di
    pop es
noIDfree:
    pop ds
    lds dx, chain_int2f
    mov  ax, 252fh
    int  21h         ; Restore old int 2f handler
    pop ds
    ret
Switcher_UnHook endp

CINIT_PROGRAM_LIST        equ 0
CADD_PROGRAM_TO_LIST      equ 1
CGO_Z_NEXT                equ 2
CGO_Z_PREV                equ 3
CDELETE_PROGRAM_FROM_LIST equ 4
CGO_NEXT                  equ 5
CGET_ITH_PROGRAM_STRING   equ 6
CGET_LIST_LENGTH          equ 7
CGET_GLOBAL_SWITCH_DATA   equ 8
CGET_ITH_ENTRY_DATA       equ 9
CADD_PARAMS               equ 10
CGET_EXITCODE             equ 11
CTOTOP_ITH_LIST_PE        equ 12
MAX_HANDLER_CALL          equ 12

;extrn _INIT_PROGRAM_LIST:NEAR

TaskListHandler LABEL WORD
	DW          _INIT_PROGRAM_LIST
	DW          _ADD_PROGRAM_TO_LIST
	DW          _GO_Z_NEXT
	DW          _GO_Z_PREV
	DW          _DELETE_PROGRAM_FROM_LIST
	DW          _GO_NEXT
	DW          _GET_ITH_PROGRAM_STRING
	DW          _GET_LIST_LENGTH
	DW          _GET_GLOBAL_SWITCH_DATA
	DW          _GET_ITH_ENTRY_DATA
	DW          _ADD_PARAMS
	DW          _GET_EXITCODE
	DW          _TOTOP_ITH_LIST_PROGRAM_ENTRY
handle_lists proc far
    cmp ax,4a05h ; MULTI_PURPOSE multmultallocchma+1
    je  do_handleit
    cmp ax,4b03h ; Dos Switcher API alloc ID
    je  alloc_id
    cmp ax,4b04h  ; Dos Switcher API free ID
    je  free_id
chain_on:
    jmp DWORD PTR[chain_int2f]
do_handleit:
    cmp si,MAX_HANDLER_CALL
    ja  chain_on
    push bx
    push cx
    push ds
    push bp

    call GET_DATA
    lea di,gresSwitchInfo
    shl si,1
    call cs:TaskListHandler[si]

    ;;; ds:di returns gresSwitchInfo
    ;;; es:bp returns far string

    pop bp
    pop ds
    pop cx
    pop bx
    iret
alloc_id:
    cmp cs:GlobalSwitcherId,0
    je  chain_on  ;;; we arent' handling them
    call Alloc_Switcher_Id
    jmp short APIExit
free_id:
    cmp cs:GlobalSwitcherId,0
    je  chain_on  ;;; we arent' handling them
    call Free_Switcher_Id
APIexit:
    xor ax,ax  ; carry cleared
    iret        
       
handle_lists endp

;;; INPUT 
;;;    none
;;; OUTPUT bx = new id (or zero if none allocated)
;;; AX modified
Alloc_Switcher_Id proc near
    push dx

    mov ax,GlobalSwitcherId
    cmp ax,0FFFFh       ;; are there any free ids?
    je  no_free_ids     ;; no, error out

    mov dx,1 
    mov bx,dx  ;; bx is the id counter; 1 is our ID!
next_id:

    shl dx,1    ;;NOTE we do this up front because we are ID 1
    inc bx      ;;NOTE we do this up front because we are ID 1
    test ax,dx
    jz do_alloc_id
    jmp short next_id
do_alloc_id:
    or ax,dx
    mov cs:GlobalSwitcherId,ax
    ;;; bx holds return ID
done_alloc_id:
    pop dx
    ret       
no_free_ids:
    xor bx,bx
jmp short done_alloc_id         
Alloc_Switcher_Id endp

;;; INPUT 
;;;     bx ID to free
;;; OUTPUT
;;;     bx zero if ID freed
;;;     bx -1 if ID not freed
;;; Ax modified    
Free_Switcher_Id proc near
    push dx
    cmp bx,1   ;; id 1 is us!
    jbe invalid_id
    
    cmp bx,16
    ja  invalid_id ;; only 16 valid ids

    mov ax,GlobalSwitcherId
    mov dx,1
skip_id:
    dec bx     ;; up front since we know that bx is not 1 (our id)
    jz  dofree_id
    shl dx,1
    jmp short skip_id
dofree_id:
    test ax,dx
    jz invalid_id ;; this is was not set!
 
    not dx      ;; make a mask
    and ax,dx
    xor bx,bx   
done_free:
    pop dx
    ret
invalid_id:
    mov bx,-1
    jmp short done_free
Free_Switcher_Id endp

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\add.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	file add.c: routines to find files and add them to the tree.
**	    AddFile is called to locate the next file on a drive and add it
**	to the tree.  One file is found and attached to the tree in each call;
**	when there are no more files the fn returns FALSE.
**	GetNextFile is called only by AddFile. AddLateFile is called to add a
**  file to a tree that has been already built. It is called when fileops
**	create new files. DelFileEntry is called to delete a dir/file entry
**	from the tree structure. It is called when fileops delete entries.
**  It would be great to have the tightest possible code for functions in
**  this file, as they are used extensively.
**
**    Date	Name	Modification
**  --------  --------	---------------------------------------------------
**   7/12/89  t-jeffro	zeros all unused struct elts
**   7/13/89  t-jeffro	AddFile stable again.
**   7/27/89  t-jeffro	Knows about _A_NOSIB.
**   8/14/89  t-jeffro	Added DelFileEntry
**   10/18/89 harikris	rewrote almost whole of fn. AddLateFile
**   10/??/89 harikris	Modified DelFileEntry drastically to handle snext, etc.
**   11/03/89 harikris	DelFileEntry now doesn't update dnext's.
*/

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <assert.h>

extern char szStarDotStar[] ;
extern MarkMatchesBit(PENTRY fil) ;

/* ZZZZZZZ */
/*  The assembly routines name_cmp, ext_cmp return -1, 0, or 1 for less than,
	equal to, and greater than respectively. But in our case we are interested
	only in > and <= -- so a BOOL would have been sufficient. But the current
	method is useful if we are later going to use a secondary key to sort
	in case the primary key doesn't distinguish the entries.				*/

/* Array of pointers to sort functions */
int (*SortFnArr[]) (PENTRY, PENTRY) = { quick_name_cmp, quick_ext_cmp, date_cmp,
#ifdef NDEBUG
/* There is no fn like disk_cmp -- we use different algorithm for disk order.
 * For safety, we have assigned the date_cmp routine for it.
 */
										size_cmp, date_cmp } ;
#else
										size_cmp, disk_cmp } ;
#endif

int (*SortCmp)(PENTRY, PENTRY) ; /* pointer to function that does the
									 compare based on the selected sort key */

/****	AddFile - Get next file in tree and add to tree
**		This fn is called in a loop from the application.  One file is 
**	found and attached to the tree in each call; when there are no more 
**	files the fn returns FALSE.
**
**	ENTRY
**		tree - file tree to append to
**	EXIT
**		address of record added; NULL if no more files.
**	WARNING:
**		tree->root must be initialized with something like "C:\"
**	before this fn is called.  If the tree is empty, its pointers should
**	be NULL.
**	EFFECTS:
**	    Updates tree, modifies find_t structs in tree.
*/
PENTRY AddFile(tree)
PTREE tree;
{
	PENTRY prev;				// previous sibling
	PENTRY ret;					// address of record in tree
	BOOL found;					// TRUE if a file was found
	BOOL first;					// TRUE if 1st srch in given dir
	BOOL newtree=FALSE;			// TRUE if tree is empty
	char path[MAX_PATH+1];		// path to search for file
	int  ParentPathLength;		// Path length of parent dir of file to be added
	int dummylen ;
	
#ifndef NOCONSISTENCY
	if (!tree)
	{
		printf("AddFile*** tree is NULL\n") ;
		exit(0) ;
	}
#endif

	/* Add the record to the tree; this is simpler to do here than after	*/
	/* 	locating the next file.														*/
	ret = AllocTreeEntryCompactIfNeeded(tree) ;
	if (!ret)
		return NULL;

	/* For empty tree, search for files at root level.  If lastlink is a	*/
	/* directory, look for children. If lastlink is a file, look for siblings.*/
	
	if (!tree->head)
	{
		/* We are just beginning to read in the tree */
		first  = TRUE;
		tree->parent = NULL;
		tree->level  = 0;
		strfcpy(path, tree->root);
		ParentPathLength = 3 ;
		newtree= TRUE;
		prev = NULL;
	} else if (tree->lastlink->attribs & _A_SUBDIR)
	{
		/* The last entry we added to the tree was a directory -- Since */
		/*	we do a DFS, we should look for entries in this directory.  */
		first  = TRUE;
		tree->parent = tree->lastlink;
		tree->level  = Tree2Path(tree, tree->lastlink, path, &ParentPathLength);
		prev = NULL;
	} else
	{
		/* The last entry we added to the tree was a file and not a dir! */
		/* ZZZZZZ Speed up following code-path as we do a Tree2Path only to
		 * find the length of parent path name. This is needed to handle cases
		 * when we, say, handle OS/2 servers etc that allow path lengths > 66.
		 * We could do some cache-ing to figure out ParentPathLength, as this
		 * will be done for each file in tree!
		 */
		first = FALSE;
		Tree2Path(tree, tree->parent, path, &ParentPathLength);
		prev = tree->lastlink;
 	}

	/* Search for files at given level; if there aren't any then go up a*/
	/* level and try again.  Repeat until a file is found or the root 	*/
	/* directory is exhausted. 											*/
	do {
		found = GetNextFile(path, tree, ret, first, ParentPathLength);
		first = FALSE;
		
		if (!found)								// no file found
		{
			/* Didn't find a file at root level or any of its children. */
			if (tree->level <= 0)
				return NULL; /* We have exhausted the tree on the drive */

			prev = NULL;
			tree->level--;
			path[ParentPathLength = FindLastComponent(path)] = EOS;
			tree->parent = FindParent(tree->parent);
		}
		/* Now check to see if we are in Compact mode. In this case, */
		/* we don't add normal files even if it is in displayed directory */
		/* We only add directories. LoadCompactDir later loads these files */
		else 
			if ( (tree->Compacted) && (!(ret->attribs & _A_SUBDIR)) )
			{
				/* This file is not added to the tree but still we increment
				 * the following count as this file belongs to this disk.
				 */
				tree->Diskfilecount++;

				found = FALSE ;
			}
	} while (!found);
	
	tree->lastlink = ret;

	if (!tree->head)
		tree->head = ret;
						
	/* If ret has a previous sibling, update its sibling ptr. If 	*/
	/* not, update its parent's child ptr.  If it is the first		*/
	/* file in the tree, skip the whole thing.						*/
	if (prev)
	{
		ret->sibling = prev->sibling;
		prev->sibling = ret;
		prev->nosib = FALSE;
	} else if (tree->parent && !tree->parent->x.d.child)
	{
		tree->parent->x.d.child = ret;
		ret->sibling = tree->parent;
	} else if (newtree)
	{
		ret->sibling = NULL;
	} else 
	{
		/* If parent, first sibling is its child ptr. If no parent, */
		/*  first sibling is tree->head.  							*/
		if (tree->parent)
			prev = tree->parent->x.d.child;
		else
			prev = tree->head;
		
		while (!(prev->nosib))
			prev = prev->sibling;
		prev->sibling = ret;
		prev->nosib = FALSE;

		/* ret is the last sibling in the chain -- So make its sibling ptr	*/
		/* point to its parent 												*/
		ret->sibling = tree->parent;
	}

	ret->nosib = TRUE;

	if (ret->attribs & _A_SUBDIR)
	{
		tree->DirCount++;

		/*  set the level of the directory--used for 'LASTDIR' setting */
		/* ZZZZZZ Can I use tree->level+1 or something like that */
	    ret->dtlx.lx.level = (BYTE) Tree2Path(tree, ret, path, &dummylen) ;

		/* This is the first time we are seeing this directory. Obviously*/
		/* we haven't seen any files belonging to it yet. 				*/
		ret->FIRSTFILEFOUND = FALSE ;

		/* Now mark the collapsed directory bits */
		// No directory is expanded initially (except root (NULL))
		ret->EXPANDED = FALSE ;

		/* If a child dir is found later, this will be set to TRUE then. */
		ret->HASSUBDIRS = FALSE ; 

		/* directory's files are not sorted -- as we haven't seen any files
		 * belonging to directory 'ret' yet!! */
		ret->DIRSORTED = FALSE ;

		// since 'ret' is a directory, mark its parent as having a sub-dir!
		if (tree->parent)
			tree->parent->HASSUBDIRS = TRUE ;

		/* The assignments above like HASSUBDIRS need to be done before this
		 * InsertDir call as this function looks at this to do complex
		 * operations -- needed when renaming directories.
		 */
		InsertDir(tree, tree->parent, ret) ;

		/* This is used in CompactifyTree! */
		tree->LastDirectory = ret ;

		// Initially only directories at level 1 are displayed.
		if (ret->dtlx.lx.level == 1)
		{
			ret->DISPLAYED = TRUE ;
			tree->VisibleDirCount++ ;
		}
		else
			ret->DISPLAYED = FALSE ;

	} else
	{
		tree->Diskfilecount++;

		tree->filecount++; // another file to be added to the tree.

 		if (!tree->FirstFile)
 			/* file head needs initialization */
 		    tree->FirstFile = ret;
 		else
			/* link up all files in the order seen -- sorting done later */
 		    tree->LastFile->x.f.snext = ret;
 		tree->LastFile = ret;
 		ret->x.f.snext = NULL;

		/* assume matching pattern to be "*.*" */
		ret->MATCHESPATTERN = TRUE ;

		/* field used to delete files from snext chain is FALSE by default */
		ret->DELMARKER = FALSE ; 
	}
		
	return ret;
} /* proc AddFile */

/****	GetNextFile - fill a record w/directory info of next file in tree
**	This fn is called by AddFile to get the next file and the stats
**	stored in its directory entry.
**
**	ENTRY
**		path     - path to search, only needed if first == TRUE
**		tree	 - find_t to pass to findfirst/next is got using
**				 - tree->finds[tree->level].
**		rptr     - fileinfo to put data in
**		first    - TRUE = run findfirst, FALSE = run findnext
**	EXIT
**		TRUE  = found file, *rptr has data
**		FALSE = no more files in path.
**	WARNING:
**		Does NOT update ptrs in other records, like the child ptr in
**		the parent record.
**
**	EFFECTS:
**		Changes findinfo data.
*/
BOOL GetNextFile(char path[], PTREE tree, PENTRY rptr, BOOL first,
														int ParentPathLength)
{
	struct find_t findinfo;
	char searchpath[MAX_PATH];		// search mask for _dos_findxxx
	BOOL ignore;					// TRUE = pretend file doesn't exist
	int i, ret;						// junk integers

	/* copy from far memory to near memory -- so that we can make the calls
	   to _dos_findfirst, _dos_findnext which accept only near pointers!! */
	findinfo = tree->finds[tree->level] ;

	do {
		if (first)
		{
			/* Don't change the contents of 'path' -- caller uses it later */
			strcpy(searchpath, path);
			i = ParentPathLength ;

			searchpath[i++] = PATHCHAR ;

			/* Most of the time this 'if' will fail -- It will succeed only */
			/* when path happens to be the root, ex: "C:\". So we don't pay */
			/* the penalty of retracting 'i' most of the time!!				*/
#ifdef DBCS
			if (searchpath[i-2] == PATHCHAR &&
					!CheckDBCSTailByte(searchpath,&searchpath[i-2]))
#else
			if (searchpath[i-2] == PATHCHAR)
#endif
				i-- ;

			/* We don't return directory paths exceeding 66! -- see code below
			 * So, the caller should not invoke us with a path length > this
			 * allowed length!
			 */
			assert(ParentPathLength <= ALLOWED_PATH) ;

			strcpy(searchpath+i, szStarDotStar) ;

			ret = shell_findfirst(searchpath, _A_HIDDEN | _A_SYSTEM | _A_SUBDIR,
								 &findinfo);
			first = FALSE;
		} else
			ret = _dos_findnext(&findinfo);

		if (ret)
			break ;

		/* ret == 0 => An entry was found!! Skip '.' and '..' */
		ignore =  (!ret) && (*(findinfo.name) == '.') ;

		/* The maximum path length allowed for a directory in DOS is 66. We
		 * ignore any directories we encounter beyond this path length.
		 * However, files can be present in a directory with path length 66!
		 */
		/* ZZZZZ should we warn user about this ignoring we do! */
		 /* Note that path length check is enough and we need not check for
		  * directory nesting level > 32! It is a superset check!
		  */
		 if (ParentPathLength >= ALLOWED_PATH)
			ignore = (ignore || (findinfo.attrib & _A_SUBDIR)) ;
		 else
			/* If parent path length is 54 or greater then there is a likelihood
			 * that the new directory name could exceed the 66 character
			 * limit for directories as a PATH_CHAR and 8.3 name could cross
			 * the limit.
			 */
			/* The first check is present to avoid the "strlen()" call! */
			if (ParentPathLength >= (ALLOWED_PATH-NAMELEN-EXTLEN-1))
				if ( (findinfo.attrib & _A_SUBDIR) &&
					 ((ParentPathLength+strlen(findinfo.name)+1) > ALLOWED_PATH)
				   )
				   ignore = TRUE ;

	} while (!ret && ignore);
		
	if (!ret)
	{
		/* A File/directory entry has been found. Copy common information.  */
		rptr->attribs = findinfo.attrib;
		rptr->nosib = rptr->SELECTED = rptr->LASTDIR = 0;
		rptr->sibling = NULL;

		Normal2Internal(rptr->name, findinfo.name);	/* put in name & ext */
		
		if (rptr->attribs & _A_SUBDIR)
		{
			rptr->x.d.child = NULL;
			rptr->x.d.dnext = NULL;

			/* rptr->LASTDIR will be marked after whole tree has been read in*/
			/* using function MarkLastDir. 									*/
		} else
		{
			/* time & date are not stored for directories. These entries	*/
			/* are 'union'ized with directories 'level' info.				*/
			rptr->dtlx.dt.time = findinfo.wr_time;
			rptr->dtlx.dt.date = findinfo.wr_date;

			rptr->x.f.size = findinfo.size;
		}
	} /* end of processing entry found */

	/* Copy info back to far memory -- to pass back to caller */
	tree->finds[tree->level] = findinfo ;

	/* return TRUE if file found, else FALSE */
	return (!ret);
} /* proc GetNextFile */

/****	AddLateFile - add a file to a tree after the tree has been built
**		File operations will typically call this fn by giving the path and the
**	record containing the file's attributes etc.  The fn will determine the
**	proper destination tree and other info.
**		LoadCompactDir, because of its need for speed, will call this fn with
**	path=NULL, and instead put correct values into tree, parent, and idx.
**	Since tree and parent do not change through the course of the LoadCompactDir
**	call and idx is merely incremented each time this fn is called, much time
**	is saved.
**
**	ENTRY
**		either:
**				path - fully qualified path of file to add
**				rec  - its vital info
**		or:
**				path   - NULL
**				rec    - file's vital info
**				tree   - tree to add file to
**				parent - parent of file to add
**				idx    - index in directory (first = 0) of file
**	EXIT
**			TRUE if successful, FALSE if not
**	WARNING
**		The path must reference a valid drive.
**	NOTE
**		If path != NULL, and the tree is compacted, the fn will only add the
**	file if its parent is being displayed onscreen.
**		If path == NULL, various consistency checks are not performed since
**	the caller is assumed to know what it's doing.
*/
BOOL AddLateFile(char *path, PENTRY rec, PTREE tree, PENTRY parent, int idx)
{
	int i;
	BOOL ok;
	BOOL first;								// use findfirst
	int ret;								// return from dos call
	
	PENTRY rptr;							// record in the tree
	PENTRY prev;							// previous sibling
	PENTRY prevfil;							// previous sibling that was a file

	struct find_t findinfo;					// search struct 
	char spath[MAX_PATH+1];					// search path
	char NormalizedName[NAMELEN+EXTLEN+2] ;
	BYTE dummy ;
	PENTRY filenode ;

#ifndef NOCONSISTENCY
	if (rec->attribs & _A_SUBDIR)
	{
		printf("AddLateFile called to add a directory entry\n") ;
		exit(0) ;
	}
#endif

	if (path)
	{
		// If the tree has not been built yet, don't add.
		tree = FindTree(path, &dummy);

		/* A file will be added to this tree -- So, disk avail, disk free size,
		*	will change. They will have to be read in when 'show info' is done
		*  later.
		*/
		tree->fdiskinfoknown = FALSE ;
		
#ifndef NOCONSISTENCY
		if (!tree)
		{
			/* Path specified not any drive hooked up!! */
			/* Display an error message  -- this function shouldn't be called */
			printf("*** wrong drive\n") ;
			return TRUE; /* dummy value */
		}
#endif

		/* Not added, if we have not started reading in 'tree' into memory */
		if (!tree->Started)
			return TRUE;

		/* Consider case when 'tree' has been partially read in and 		*/
		/* we are adding to it. This new file may conflict with AddFile,	*/
		/* GetNextFile. To handle this case, we just junk 'tree'. It 'tree	*/
		/* is to read in later, it will be started afresh. Actually this 	*/
		/* scenario won't occur often to worry about it!					*/
		if (tree->ContinueTree)
		{
			JunkTree(tree) ;
			return TRUE ;
		}

		i = FindNode(tree, path, &parent, &filenode, TRUE);
#ifndef NOCONSISTENCY
		if (!i)
		{
			printf("*** BUG! parent directory doesn't exist\n") ;
			exit(0) ;
			return TRUE;
		}
#endif
		if (i == 2)
		{
			DelFileEntry(tree, parent, filenode);
		}

		/* If the tree is compacted, add only if the file is in a displayed */
		/* directory.  														*/
		if (tree->Compacted)
		{
			ok = FALSE;
			for (i=0; i <= glob.MaxTree; i++)
			{
				if (listinfo[i].tree == tree && listinfo[i].files == parent)
					ok = TRUE;
			}
			if (!ok)
				return TRUE;
		}

		/* Locate the file's position in its directory -- i.e., find its	*/
		/* order in the disk among its siblings.							*/
		idx = 0;
		strcpy(spath, path);				// move to scratch area
		i = FindLastComponent(spath);
		if (spath[i] == PATHCHAR)
			i++;
		strcpy(spath+i, szStarDotStar) ;

		/* When called from CopyFile, MoveFile, etc name might not be
		 * normalized, i.e., we might not have name_lens <= 8, ext_lens <= 3
		 */
		ScrunchFileName(NormalizedName, path+i, FALSE) ;

		ok = FALSE;
		first = TRUE;
		do 
		{
			if (first)
			{
				ret = shell_findfirst(spath, _A_HIDDEN | _A_SYSTEM | _A_SUBDIR,
									 &findinfo);
				first = FALSE;
			} else
				ret = _dos_findnext(&findinfo);

			/* In case there was an error in this FindFirst or FindNext
			 * we assume that the file is the first in DISK-ORDER - default
			 * order.
			 */
			if (ret)
				break ;

			/* ignore '.', '..' entries */
			if (*findinfo.name == '.')
				/* Do Nothing */ ;
			else
			if (strcmpi(NormalizedName, findinfo.name))
				idx++;						// not our file
			else
				ok = TRUE;					// found its index
		} while (!ok);
	} /* if (path) */

	/* Locate file's position in directory tree. */
	if (idx)
	{
		prev = parent ? parent->x.d.child : tree->head ;
		/* We know that prev can't be NULL as idx > 0 */
		prevfil = (prev->attribs & _A_SUBDIR) ? NULL : prev ;
		idx-- ;
	}
	else
	{
		prev = prevfil = NULL;
	}
	while ( (idx > 0) && !(prev->nosib) )
	{
		prev = prev->sibling;
		if (!(prev->attribs & _A_SUBDIR))
			prevfil = prev ;
		idx-- ;
	}

#ifndef NOCONSISTENCY
	if (idx)
	{
		printf("idx is positive, in-memory tree doesn't extend far enough\n");
		exit(0) ;
	}
#endif

	rptr = AllocTreeEntryCompactIfNeeded(tree) ;
	if (!rptr)
	{
		/* Note that we might be in this routine when performing
		 * a LoadCompactDir, when user is in program manager.
		 * So, we don't want to affect his screen in that case.
		 */
		if (glob.InFileMgr)
		{
			OutOfMemory() ;
		}
		return FALSE ; // AddLateFile can't succeed as there is no mem
	}

	*rptr = *rec ;

	/* link 'rptr' with its parent, siblings -- i.e., sibling, child ptrs */
	UpdateSiblings(tree, parent, prev, rptr) ;

	/* Set rptr->MATCHESPATTEN correctly! */
	MarkMatchesBit(rptr) ;

	rptr->SELECTED = FALSE ;

	tree->filecount++ ;

	rptr->FIRSTDIRFILE = rptr->LASTDIRFILE = FALSE ; /* default values */

	/* link up in the 'snext' chain correctly */
	UpdateLatesnext(tree, parent, rptr, prevfil, FALSE) ;

	return TRUE;
} /* proc AddLateFile */


/****	UpdateSiblings -
** The following function updates the sibling pointers, child pointer of
** parent and if necessary tree->head. It is invoked when a new file or
** directory is created.
**
**	ENTRY
**				tree - tree to add to.
**				parent - parent of record 'rptr'.
**				prev - the sibling that is the predecessor of rptr in diskorder
**				rptr - the file/directory entry to be added to the tree.
**	EXIT
**			Function will always be succesful -- no mem alloc, etc!
*/
void UpdateSiblings(PTREE tree, PENTRY parent, PENTRY prev, PENTRY rptr)
{
	if (prev)
	{
		rptr->sibling = prev->sibling;
		prev->sibling = rptr;
		rptr->nosib = prev->nosib;
		prev->nosib = FALSE;
	} 
	else
	{
		if (parent)
		{
			if (parent->x.d.child)
			{
				rptr->sibling = parent->x.d.child;
			 	rptr->nosib = FALSE;
			} else
			{
				rptr->sibling = parent;
				rptr->nosib = TRUE;
			}
			parent->x.d.child = rptr;
		} 
		else
		{ 
			/* file is part of root directory, as parent is NULL */

			rptr->nosib = (tree->head == NULL) ;

			/* OK even when tree->head is NULL, rptr->sibling points to NULL
				which is the OK, as parent is Root directory */
			rptr->sibling = tree->head;

			tree->head = rptr;
		}
	} /* prev == NULL */
} /* UpdateSiblings */

/****	DelFileEntry - delete entry from file tree. Doesn't handle the
** 'dnext' chain if node is a directory -- It is the caller's responsibility
** to do that!
**
**	ENTRY
**			tree - tree to delete from
**			node - node to delete
**			parent - parent of node to delete (NULL if in root directory)
**	EXIT
**		Just like AddLateFile, it will always be succesful!
**	WARNING
**		If any of the tree pointer chains have been damaged, the function
**	will never exit.  The node must exist in the tree.
*/
VOID DelFileEntry(tree, parent, node)
PTREE tree;
PENTRY parent;
PENTRY node;
{
	PENTRY prev;						// previous node in chain

	/* A file will be deleted from this tree -- So, disk avail, disk free size,
	*	will change. They will have to be read in when 'show info' is done
	*  later.
	*/
	tree->fdiskinfoknown = FALSE ;

	/* Handle file sort chain. Directory chains aren't handled here.
	* It is the caller's responsibility to handle dnext chains and
	* decrement tree->DirCount!
	*/
	if (!(node->attribs & _A_SUBDIR))
	{
		HandleDeletesnext(tree, parent, node) ;
		tree->filecount-- ;
	}

	/* Handle parent-child pointers */
	/* ZZZZZZ There is some duplicate code below -- while loop and next
		couple of statements. I wonder if its removal will make good code
		savings!
	*/
	if (parent)
	{
		if (parent->x.d.child == node)
			parent->x.d.child = (node->nosib) ? NULL : node->sibling ;
		else
		{
			prev = parent->x.d.child;
			while (prev->sibling != node)
				prev = prev->sibling;
			prev->sibling = node->sibling;
			prev->nosib = node->nosib;
		}
	} 
	else
	{
		/* parent is the root directory */
		if (tree->head == node)
			tree->head = node->sibling;	// if nosib, parent = NULL which is ok
		else
		{
			prev = tree->head;
			while (prev->sibling != node)
				prev = prev->sibling;
			prev->sibling = node->sibling;
			prev->nosib = node->nosib;
		}
	}
	
	node->name[0] = EOS; /* Officially mark node as deleted */
	tree->holecount++ ; /* one extra hole in page entry pool */
} /* proc DelFileEntry */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\busydlg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>

/* The Width and Height of the BusyDialog -- rectangular region that
 * displays the number of files/directories read so far (at startup time).
 */
// this is now defined in text.h for international #define BUSYWIDTH  40
#define BUSYHEIGHT  6

extern WORD gCnx;
extern BOOL IsMenuDown(void);

#if defined(SWE)||defined(RUS)
  extern VOID CopyNumberYST(char *CountStr, unsigned long l, BOOL t, int maxcount);
#endif

VOID PutUpBusyDialog(int ith);
BOOL isup[2] = {FALSE,FALSE};
WORD b_x[2],b_y[2];
int ReadCount[2] ;
int gReadUpdateFreq ;


VOID PutUpBusyDialog(int ith)
{
	RRC drect;
	int len;
	WORD top, bottom;
	extern unsigned char gNUMDIRSREADLEN ;

	/* If the menu is down and we haven't yet put up our busy dialog
	 * banner, son't chomp on menu. Else, the updating we do of the
	 * number of files/dirs readin does not affect the pulled down menu.
	 */
	if ( (IsMenuDown()) && (!isup[ith]) )
		return;

	if(!isup[ith])
	{
		/* Initialize update freq count variable. Using a value of 1
		 * will force screen update the very first time.
		 */
		ReadCount[ith] = 1 ;

		isup[ith] = TRUE;
		top    = Get_List_Rect(&TreeList[ith]).ayTop;
		bottom = Get_List_Rect(&TreeList[ith]).ayBottom;

		Not_Blank(&TreeList[ith]);
		Not_Blank(&FileList[ith]);
		DoRedisplayList(&TreeList[ith]);
		DoRedisplayList(&FileList[ith]);
		UpdateListBox(&TreeList[ith]);
		UpdateListBox(&FileList[ith]);

		FEnableMouseNest(FALSE);
		drect.rxLeft = axMac/2-BUSYWIDTH/2;
		drect.rxRight = axMac/2+BUSYWIDTH/2;
		drect.ryTop = (BYTE) (top+(bottom-top)/2- (WORD)BUSYHEIGHT/2);
		drect.ryBottom = (BYTE) (top+(bottom-top)/2+ BUSYHEIGHT/2);
		FillRrc(&MainWind,&drect,' ',isaDialogBox);
		len=strlen(szReadingDisk);
		b_x[ith] = drect.rxLeft+(drect.rxRight-drect.rxLeft)/2 - len/2;
		b_y[ith] = drect.ryTop +(drect.ryBottom-drect.ryTop)/2 - 2;
		TextOut(&MainWind,(RX) b_x[ith],(RY) b_y[ith],szReadingDisk,-1,isaDialogBox);
		TextOut(&MainWind,(RX) b_x[ith],(RY) b_y[ith]+2,szNumFilesRead,-1,isaDialogBox);
		TextOut(&MainWind,(RX) b_x[ith],(RY) b_y[ith]+3,szNumDirsRead,-1,isaDialogBox);
		if(gisgraph)
		{
		FrameCharRect(drect.ryTop,drect.rxLeft,drect.ryBottom,drect.rxRight, 1,isaBorders);
		}
		else
		{
		EasyDrawBox(&MainWind, drect.ryTop, drect.rxLeft, drect.ryBottom,
						 drect.rxRight, isaDialogBox);
		}
		FEnableMouseNest(TRUE);
   }
#ifdef JAPAN
	else if(gCnx < cnxMenu) /* not a dialog up, not pull-down menu */
#else
	else if(gCnx <= cnxMenu) /* not a dialog up */
#endif
	{

		/* If this counter has not reached 0, we don't update the screen */
		if (--ReadCount[ith])
			return ;

		ReadCount[ith] = gReadUpdateFreq ;

	   // Disabling & then enabling mouse causes too much flashing!!
	   // FEnableMouseNest(FALSE) ;
	   #if defined(SWE)|| defined(RUS)
	     CopyNumberYST(&szCountStr[MAXCOUNTLEN-2],
				(unsigned long)listinfo[ith].tree->Diskfilecount, TRUE, MAXCOUNTLEN-2) ;
	   #else
	     CopyNumberForTextOut(&szCountStr[MAXCOUNTLEN-2],
				(unsigned long)listinfo[ith].tree->Diskfilecount, TRUE) ;
	   #endif

	   TextOut(&MainWind,(RX) b_x[ith]+gNUMDIRSREADLEN,
					(RY) b_y[ith]+2,szCountStr+1,-1,isaDialogBox);

	   /* The "+1" in count below is to account for the Root Directory */
	   #if defined(SWE)|| defined(RUS)
	     CopyNumberYST(&szCountStr[MAXCOUNTLEN-2],
				(unsigned long) listinfo[ith].tree->DirCount+1, TRUE, MAXCOUNTLEN-2) ;
	   #else
	     CopyNumberForTextOut(&szCountStr[MAXCOUNTLEN-2],
				(unsigned long)listinfo[ith].tree->DirCount+1, TRUE) ;
	   #endif
	   
	   TextOut(&MainWind,(RX) b_x[ith]+gNUMDIRSREADLEN,
					(RY) b_y[ith]+3,szCountStr+1,-1,isaDialogBox);

	   // FEnableMouseNest(TRUE) ;
	}
}


VOID TakeDownBusyDialog(ith)
{
    RRC drect;
    WORD top,bottom;
    /*
     * don't take down dialog if a menu or dialog is above it!
     */
    if (gCnx == cnxNull)
    {
       if(isup[ith])
       {
	  top    = Get_List_Rect(&FileList[ith]).ayTop;
	  bottom = Get_List_Rect(&FileList[ith]).ayBottom;
	  drect.rxLeft = axMac/2-BUSYWIDTH/2;
	  drect.rxRight = axMac/2+BUSYWIDTH/2;
	  drect.ryTop = (BYTE) (top+(bottom-top)/2- BUSYHEIGHT/2) ;
	  drect.ryBottom = (BYTE) (top+(bottom-top)/2+ BUSYHEIGHT/2) ;


	  FillRrc(&MainWind,&drect,' ',isaBackground);
	  Not_Blank(&TreeList[ith]);
	  Not_Blank(&FileList[ith]);

	  /* The scroll bar region is screwed up when we do the "FillRrc()" above,
      * draw it afresh! In system tree mode, we don't have to worry about
		* this!
		*/
	  if (glob.TreeMode != TR_SYSTEM)
		  DrawScrollBar(&TreeList[ith], TRUE) ;
	
	  if (glob.TreeMode != TR_SYSTEM)
	  {
		DoRedisplayList(&TreeList[ith]);
		UpdateListBox(&TreeList[ith]);
	  }
	  DoRedisplayList(&FileList[ith]);
	  UpdateListBox(&FileList[ith]);
       }

		 ReadCount[ith] = 1 ; // back to default state

       isup[ith] = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\attr.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   attr.c - functions relating to changing file attributes.
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  11/08/89  harikris  Created file
*/
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <help.h>
#include <attr.hs>
#include <attr.sdm>

extern BYTE ErrorCrit ;

extern void ResetTreeMatchedFilesOpt(PTREE tree) ;
extern void MarkMatchesBit(PENTRY fil) ;

/* re-use of variable used by FDlgErr in errbox.c */
extern char *QStatus ;

#define MAXATTRIBUTES 4 /* Warning! 4 is the number of strings in
			   pszAttrStrings[] of text.c -- they need to tally */
BYTE gAttrChar[MAXATTRIBUTES] ;

int gAttr_Change_Mode ;

/* On Exit returns value got from GetResponse() */
int ChangeAttributes(PTREE tree, PENTRY node, char *placeholder, 
												int count, int total, BOOL verify)
{
	int action;
	char path[MAX_PATH+1] ;
	TMC tmc ;
	HCABattr h ;
	unsigned attributes ;
	int code ;
	char statusline[STATUS_LEN];
	BOOL fPrevHiddenOrSystem ;
	BOOL fNowHiddenOrSystem ;
	int dummylen ;

	UnReferenced(placeholder) ;
	UnReferenced(verify) ;

	/* First time through -- so we find the info as to whether to
	 * handle files one at a time or as a whole.
	 */
	if (count == 1)
	{
		/* If more than 1 file selected, we prompt the user whether to modify
		 * singly or all at once.
		 */
		if (total > 1)
		{
			action = GetAttrResponse();
			switch (action)
			{
				case ACT_CANCEL:
						return action ; /* return ACT_CANCEL and do nothing here */

				case ACT_ALL:
						gAttr_Change_Mode = action      /* same as ACT_ALL */ ;
						break ;

				case ACT_SINGLE:
				default:
						gAttr_Change_Mode = ACT_SINGLE ;
						break;
			}
		}
		else
		{
			/* Only 1 file has been selected totally */
			gAttr_Change_Mode = ACT_SINGLE ;
		}
	} /* count == 1  and more than 1 file selected */

	h = HcabAlloc(cabiCABattr);

	if (!h)
	{
		OutOfMemory() ;
		return ACT_NOMEM ;
	}
	InitCab(h, cabiCABattr) ;

	/* Handle the change Attributes section of that node */
	/* If it is ACT_SINGLE, then each time ask for the new settings
	   after displaying the old settings. Otherwise ask for the settings
	   when count == 1 only, later just use the settings */

	Tree2Path(tree, node, path, &dummylen) ;
	FormCountStatusLine(statusline, szStFile, path, count, total,
												STATUS_COUNT_START) ;
	action = ACT_OK ;
	/* In the case of ACT_ALL only when (count == 1) we will do this */
	if ( (count == 1) || (gAttr_Change_Mode == ACT_SINGLE) )
	{
		/* Warning! Assuming order of Attributes in display */
		gAttrChar[0] = (BYTE) ( ( (gAttr_Change_Mode == ACT_SINGLE) && 
								(node->attribs & _A_HIDDEN) ) ? SELCHAR : ' ') ;
		gAttrChar[1] = (BYTE) ( ( (gAttr_Change_Mode == ACT_SINGLE) && 
								(node->attribs & _A_SYSTEM) ) ? SELCHAR : ' ') ;
		gAttrChar[2] = (BYTE) ( ( (gAttr_Change_Mode == ACT_SINGLE) && 
								(node->attribs & _A_ARCH) ) ? SELCHAR : ' ') ;
		gAttrChar[3] = (BYTE) ( ( (gAttr_Change_Mode == ACT_SINGLE) && 
								(node->attribs & _A_RDONLY) ) ? SELCHAR : ' ') ;
		QStatus = (gAttr_Change_Mode != ACT_SINGLE) ? NullString : statusline ;

		SzToCab(h, szEnterButton, Iag(CABattr, pszattrEB));
		SzToCab(h, szCancelButton, Iag(CABattr, pszattrCB));
		SzToCab(h, szHelpButton, Iag(CABattr, pszattrHB));

		tmc = MyTmcDoDlg(&dlgattr,  h);
		if (tmc == tmcCancel)
		{
			FreeCab(h) ;
			return ACT_CANCEL;
		}
	}
	/* Now we have the attribute settimgs in gAttrChar,use it to set the
	   files attributes on the disk */

	attributes = node->attribs ;

	/* zero out the hidden, system, archive, and read-only bits */
	attributes &= (~ (_A_HIDDEN | _A_SYSTEM | _A_ARCH | _A_RDONLY) ) ; 

	/* Note: index 0=>hidden, 1=>read-only, 2=>archive */
	/* Set the three attributes mentioned above based on gAttrChar */
	/* Following code avoids jumps, but is almost un-readable */
	attributes |=  ( (-(gAttrChar[0] == SELCHAR)) & _A_HIDDEN ) ;
	attributes |=  ( (-(gAttrChar[1] == SELCHAR)) & _A_SYSTEM ) ;
	attributes |=  ( (-(gAttrChar[2] == SELCHAR)) & _A_ARCH ) ;
	attributes |=  ( (-(gAttrChar[3] == SELCHAR)) & _A_RDONLY ) ;

	PutUpStatusMessage(statusline, count) ;

	if (node->attribs == (BYTE) attributes) 
		/* ZZZZ should I still try to write it, as I might be using old
			info and things might have changed! */
		/* Specified attributes are the same as before. It is
			terrible to unnecessarily hit the disk. This is where the floopy
			line status monitor will come in handy */
		; /* Do Nothing! */
	else
	{
		do
		{
			ErrorCrit = 0xFF ;
			code = _dos_setfileattr(path, attributes) ;
			if (code)
			{
				/* Did a critical error occur? -- say, disk write protected! */
				if (ErrorCrit != 0xFF)
					action = GetResponse(statusline, 
										szCriticalMessages[ErrorCrit], 
										BT_FILERETRYSKIPQUIT, HELP_ERRSETATTR);
				else
					action = DOSErrorBox(statusline, code, HELP_ERRSETFILEATTR) ;
			}
			else
			{
				/* If we changed the attributes of the file so that it's
				 * hidden/system attributes have changed, we need to figure
				 * out if it is visible now!
				 */
				fPrevHiddenOrSystem = node->attribs & (_A_HIDDEN | _A_SYSTEM) ;
				fNowHiddenOrSystem = attributes & (_A_HIDDEN | _A_SYSTEM) ;

				node->attribs = (BYTE) attributes ;
				action = ACT_OK ;

				if (fNowHiddenOrSystem ^ fPrevHiddenOrSystem)
				{
					MarkMatchesBit(node) ;
					ResetTreeMatchedFilesOpt(tree) ;
				}

			}
		} while (action == ACT_RETRY) ;
	}

	TakeDownStatusMessage(count, total) ;

	FreeCab(h);
	return action;
} /* proc ChangeAttributes */


ListBoxData AttrList;

void  MakeAttrLine(RX x, RY y, WORD isz, WORD bArg)
{
	unsigned char messagestr[40]; /* 40 > max lenth of any message */
	int i;
	int len;
	RX rxGraphics ;
	RY ryGraphics ;

	/* the '-2' handles the scroll bar width even though it is a stupid lbox */
    len = Get_List_Rect(&AttrList).axRight-Get_List_Rect(&AttrList).axLeft-2;

	*messagestr = ' ' ;
    for(i=1;pszAttrStrings[isz][i-1];i++)
    {
		messagestr[i] = pszAttrStrings[isz][i-1];
    }
	/* 1 character width has been taken up by the SELCHAR at the start of line*/
    for(;i<len-1;i++)
    {
		messagestr[i] = ' ';
    }
	CharOut(AttrList.pwd, x, y,gAttrChar[isz], isaDialogBox) ;


	TextOut(AttrList.pwd, x+1, y,messagestr, len-1,
				(bArg & TF_ISFOCUS) ? isaHilite : isaDialogBox);

	/* Graphics is done relative to top of screen -- i.e. in absolute
	 * co-ordinates and not wrt to a window!!
	 */
	rxGraphics = AttrList.pwd->arcWindow.axLeft + x + 1 ;
	ryGraphics = AttrList.pwd->arcWindow.ayTop + y  ;

#if 0
	/* In case of a mouse click, we want to temporarily change focus from
	 *      say one of the dialog buttons to the listbox and then go back!
	 */
	if (bArg & TF_ISFOCUS)
		SetFocus(AttrList.pwd) ;
#endif
	/* The FALSE in the param list forces fn DrawFocusMarker to always draw
	 * the focus box in graphics mode!!
	 */
	DrawFocusMarker(AttrList.pwd, x-2, y, rxGraphics, ryGraphics,
								len-1, bArg & TF_ISFOCUS, FALSE, isaDialogBox) ;

} /* MakeAttrLine */


WORD PASCAL ListProcAttrList(WORD tmm, char *sz, WORD isz, TMC tmc, 
																WORD x, WORD y, WORD bArg)
{
	RX xval;

	UnReferenced(tmc) ;
	UnReferenced(x) ;

	xval = Get_List_Rect(&AttrList).axLeft;
	switch (tmm) {
		case tmmCount:
			return(MAXATTRIBUTES) ;
		case tmmGetItemString:
			if (isz < MAXATTRIBUTES)
				strcpy(sz, pszAttrStrings[isz]);
			else
				*sz = '\0' ;
			break ;

		case tmmSelect:
		case tmmToggleSelect:
			/* Never draw on a select, only mark selections! */
			if (isz < MAXATTRIBUTES)
				gAttrChar[isz] = (BYTE)((gAttrChar[isz] == ' ') ? SELCHAR : ' ');

			break ;

		case tmmDrawItem:
		    if(isz < MAXATTRIBUTES)
			  MakeAttrLine((RX) xval, (RY) y+1, isz, bArg) ;
			break;
		case tmmDeselectAll:
		case tmmSetFocus:
		default:
			break;
	}
	return TRUE;
}

LONG FAR PASCAL pfnAttrList(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	UnReferenced(pwnd) ;

    switch(message)
    {
	case WM_CHAR:
		if ( (wParam == VK_ESCAPE) || (wParam == ESCAPE) ||
			  (wParam == '\t') || (wParam == '\r') )
			return(FALSE);

		ListKey(&AttrList,wParam, HIWORD(LParam));
		break;

	case WM_KILLFOCUS:
		GlobalFocusBox(&AttrList,FALSE);
		break;

	case WM_SETFOCUS:
		GlobalFocusBox(&AttrList,TRUE);
		break;

	case WM_PAINT:
		UpdateListBox(&AttrList);
		break;
	} /* switch */
    return(TRUE);
}


BOOL FAR PASCAL FDlgattr(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	PWND  dwind, lwind;
	WORD  mx,my;

	UnReferenced(tmc) ;

	dwind = PwndParent(PwndOfListbox(tmcOK));
	switch(dlm)
	{
	    case dlmInit:
			SetUpDialog(tmcOK,szChangeFileCaption);
			SetUpButtonForGraphics(tmcOK);
			SetUpButtonForGraphics(tmcCancel);
			SetUpButtonForGraphics(tmcattrhelp);
	       /* The next few lines initialize a listbox. The list
			* box will hang just below, and have the same x coordinates
			* as tmcattrlist
			*/
		   lwind = PwndOfListbox(tmcattrlist);

		   /* We don't want to draw focus cursor in the attr listbox window */
		   EnableCursor(lwind, FALSE) ;

		   SetWindowProc(lwind,pfnAttrList);

	       ListBoxInit(&AttrList,ListProcAttrList,dwind,
			lwind->arcWindow.ayTop -dwind->arcWindow.ayTop,
			lwind->arcWindow.axLeft-dwind->arcWindow.axLeft,
			lwind->arcWindow.ayTop-dwind->arcWindow.ayTop+MAXATTRIBUTES+1,
			lwind->arcWindow.axRight-dwind->arcWindow.axLeft+1,
			NullString, tmcattrlist,0,0);
		   MakeListStupid(&AttrList);

		   /* Initially the focus is not in listbox - It is on the OK button */
		   GlobalFocusBox(&AttrList,FALSE);
			gCurrentTMC = tmcOK;

			Shell_SetTmcText(tmcattrstatus, QStatus);
			Shell_SetTmcText(tmcattrmsg1, szAttrLine1) ;
			Shell_SetTmcText(tmcattrmsg2, szAttrLine2) ;
		break;

		case dlmIdle:
			ListBoxIdle(&AttrList);
		break;

		case dlmClientMouse:
			dwind = PwndParent(PwndOfListbox(tmcOK));
			my = HIBYTE(wParam)-1;
			mx = LOBYTE(wParam);
			if(ListMouse(&AttrList,mx,my,wNew,wOld))
				SetFocusTmc(tmcattrlist);
			break;


	case dlmClick:
		 if(tmc == tmcattrhelp)
			Help(hemDialog, hidATTR, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;
	} /* switch */
	return(TRUE);
} /* FDlgAttr */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\color.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include "color.hs"
#include "color.sdm"
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>
#include <assert.h>

extern VOID Set_DefaultColors(void) ;
extern VOID FAR InitCColor(void);
extern VOID FarToNearsz(char *temp,char far *str,int max);
VOID RefreshStartPrograms(VOID);
extern VOID MainIdle(void) ;
extern VOID FAR ColorDialog(void) ;

extern MENUINFO MainMenuBar;

extern BOOL gisgraph;
extern WND MainWind;
extern WORD gscreenmode; /* mode the screen is in now */

#define COLORCANCEL -3
#define COLOROK -2
#define COLORPREVIEW -1
/* We set gContinueColors to the listbox scroll if we are previewing.
 * 0 is a special value that says to scroll the current selection into view
 */
int gContinueColors; /* Whether to keep putting up the color manager boxes */
int gNthColorGroup = 1;  /* color scheme the screen is in now */
WORD gColorListInd ; /* Index in the Color Scheme listbox (0 based) that
									* we want to switch to.
									*/

/* The total number of color schemes in the INI file */
int gNumColorSchemes;

ListBoxData ColorList ;
BOOL gNotMonochrome;

ISA FAR MapToken2Color(TOKEN token,ISA def)
{
     switch(token)
     {
		case TK_LTBLACK:
				if(fMonochrome && gisgraph)
					gNotMonochrome = TRUE;
		case TK_BLACK:

			return(coBlack);
		break;

		case TK_BLUE:
		case TK_LTBLUE:
			gNotMonochrome = TRUE;
			return(coBlue);
		break;

		case TK_GREEN:
		case TK_LTGREEN:
			gNotMonochrome = TRUE;
			return(coGreen);
		break;

		case TK_RED:
		case TK_LTRED:
			gNotMonochrome = TRUE;
			return(coRed);
		break;

		case TK_CYAN:
		case TK_LTCYAN:
			gNotMonochrome = TRUE;
			return(coCyan);
		break;

		case TK_MAGENTA:
		case TK_LTMAGENTA:
			gNotMonochrome = TRUE;
			return(coMagenta);
		break;

		   case TK_YELLOW:
		case TK_LTYELLOW:
			gNotMonochrome = TRUE;
			return(coYellow);
		break;
		case TK_LTWHITE:
				if(fMonochrome && gisgraph)
					gNotMonochrome = TRUE;
		
		case TK_WHITE:

			return(coWhite);
		default:
		{
		
#ifdef DBGBEEP
	Beep();
#endif
			return(def);
		}
     }
}

VOID FAR DoSetColor(ISA set,TOKEN fore,TOKEN back)
{
     ISA ffore,bback;

     bback = MapToken2Color(back,-1);
     ffore = MapToken2Color(fore,-1);
     if((bback == -1) || (ffore == -1))
	return;

      SetSysColor(set,
	bback,
	ffore,
	back >= TK_LTBLACK,fore >= TK_LTBLACK);
}

int GetUserColorSelection(void)
{
     TOKEN tokencolor;
     TOKEN tokentc;
     TOKEN colortitle;
     int ithscheme;
     int numschemes;
     TOKEN schemetitle;



     colortitle = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_CURRENTCOLOR);
     if(colortitle < 0)
	return(0);

     tokencolor = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_COLOR);
     if(tokencolor < 0)
	return(0);
     numschemes = Get_List_Length(tokencolor);
     if(numschemes<0)
	return(0);
     for(ithscheme=1;ithscheme<=numschemes;ithscheme++)
     {
	  tokentc = Get_Symbol_Value(Token_To_Symbol(
	  Get_Ith_Element(tokencolor,ithscheme)));
	  if(tokencolor<0)
	    break;
	  schemetitle = Get_KeyWord_Assignment(tokentc,TK_TITLE);
	  if(schemetitle == colortitle)
	    return(ithscheme);
     }
     return(0);

}

#define MAXCOLORBOXTITLE 60
#define MAXCOLORTITLE   36

/* pointer into gColorBoxTitle, where the title of the current color scheme
 * is stored.
 */
char *gCurrentColorTitle ;

/* This is the storage for the title used in the color manager listbox */
char gColorBoxTitle[MAXCOLORBOXTITLE] ;
void SetUserColorSelection(int selection)
{
     TOKEN tokencolor;
     TOKEN tokentc;
     int numschemes;
     TOKEN schemetitle;

     tokencolor = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_COLOR);
     if(tokencolor < 0)
	return;
     numschemes = Get_List_Length(tokencolor);
     if(numschemes<selection)
	return;
     tokentc = Get_Symbol_Value(Token_To_Symbol(
	 Get_Ith_Element(tokencolor,selection)));
     if(tokentc<0)
	   return;
     schemetitle = Get_KeyWord_Assignment(tokentc,TK_TITLE);
     if(schemetitle > 0)
     {
	  Set_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_CURRENTCOLOR,schemetitle);
	  FarToNearsz(gCurrentColorTitle,Get_Token_Identifier(schemetitle),MAXCOLORTITLE);
     }
	  gNthColorGroup = selection ;
     return;
}
VOID  SelectColorGroup(int ColorSelection)
{
	TOKEN tokencolor;
		TOKEN tokenback, tokenfore;
		ISA forecolor, backcolor,savecolor, tkSaveBack, tkSaveFore;


		if(Get_KeyWord_Assignment(TK_SAVESTATE, TK_FORCEMONO) == TK_ENABLED)
		{
			fMonochrome = TRUE;
		}


		gNotMonochrome = FALSE;

	tokencolor = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_COLOR);
	if(tokencolor < 0)
			return;
     tokencolor = Get_Symbol_Value(Token_To_Symbol(
	  Get_Ith_Element(tokencolor,ColorSelection)));
     tokenback = Get_KeyWord_Assignment(tokencolor,TK_BACKGROUND);
     tokenfore = Get_KeyWord_Assignment(tokencolor,TK_FOREGROUND);

	 tkSaveBack = backcolor = (ISA) Get_KeyWord_Assignment(tokenback,TK_BASE);
	 tkSaveFore = forecolor = (ISA) Get_KeyWord_Assignment(tokenfore,TK_BASE);
     DoSetColor(isaBackground,forecolor,backcolor);
     if(!gisgraph)
     {

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_SHADOW);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_SHADOW);
	 if((backcolor > 0) && (backcolor < NUMKEYWORDS)) //be sure valid
	 {
		DoSetColor(isaShadow,forecolor,backcolor);
	}
	else
	{
		if(backcolor == TK_WHITE)
			DoSetColor(isaShadow,TK_BLACK,TK_LTBLACK);
		else
		DoSetColor(isaShadow,TK_LTBLACK,TK_WHITE);
	}
     }

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_HIGHLIGHT);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_HIGHLIGHT);
    DoSetColor(isaHilite,forecolor,backcolor);
    DoSetColor(isaMenuSelected,forecolor,backcolor);
	 savecolor = backcolor;//save for accelerator

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_ALERT);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_ALERT);
     DoSetColor(isaAlert,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_DIALOG);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_DIALOG);
     DoSetColor(isaDialogBox,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_BUTTON);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_BUTTON);
     DoSetColor(isaPushButton,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_MENU);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_MENU);

     if(forecolor==tkSaveFore && backcolor==tkSaveBack)
	 DoSetColor(isaMessagebar,
		     Get_KeyWord_Assignment(tokenfore, TK_TITLEBAR),
		     Get_KeyWord_Assignment(tokenback, TK_TITLEBAR));
     else
	 DoSetColor(isaMessagebar, forecolor, backcolor);

     if(gisgraph)
     {
       DoSetColor(isaMenuBox,backcolor,backcolor);
		DoSetColor(isaMenuHiliteSel,forecolor,backcolor);
     }
     else
     {
			/* be sure the shadow is not the same color as the menu */
			if(backcolor == TK_WHITE)
			DoSetColor(isaShadow,TK_BLACK,TK_LTBLACK);
			if(backcolor == TK_BLACK)
		DoSetColor(isaMenuBox,TK_WHITE,backcolor);
		   else
		DoSetColor(isaMenuBox,TK_BLACK,backcolor);
     }
     DoSetColor(isaMenu,forecolor,backcolor);
	  if(gisgraph) //underline is used instead of color
	  {
		DoSetColor(isaMenuHilite,forecolor,backcolor);
  
	  }
	  // else will be set in tk_menutext

	  DoSetColor(isaEnabled,forecolor,backcolor);

	 forecolor =    (ISA) Get_KeyWord_Assignment(tokenfore,TK_DISABLED);
	 backcolor =    (ISA) Get_KeyWord_Assignment(tokenback,TK_DISABLED);
	 DoSetColor(isaDisabled,forecolor,backcolor);

	 forecolor =    (ISA) Get_KeyWord_Assignment(tokenfore,TK_CURSOR);
	 backcolor =    (ISA) Get_KeyWord_Assignment(tokenback,TK_CURSOR);
	 DoSetColor(isaShellMouse,forecolor,backcolor);

	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_MENUTEXT);
	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_MENUTEXT);
	 if(!gisgraph) //must use color to show accelerators
	 {
		DoSetColor(isaMenuHilite,forecolor,backcolor);
	 }
	 DoSetColor(isaHotLink,forecolor,backcolor);

	 DoSetColor(isaMenuHiliteSel,forecolor,savecolor);     
    DoSetColor(isaItemHiliteSel,forecolor,savecolor);


    DoSetColor(isaDialogAccel,forecolor,backcolor);
    DoSetColor(isaDialogAccelBor,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_SCROLLBAR);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_SCROLLBAR);
     DoSetColor(isaScrollbar,forecolor,backcolor);
	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_ELEVATOR);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_ELEVATOR);
     DoSetColor(isaElevator,forecolor,backcolor);
	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_TITLEBAR);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_TITLEBAR);
     DoSetColor(isaTitlebar,forecolor,backcolor);
	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_DRIVEBOX);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_DRIVEBOX);
     DoSetColor(isaDrivebox,forecolor,backcolor);
	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_DRIVEICON);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_DRIVEICON);
     DoSetColor(isaDriveicon,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_SELECTION);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_SELECTION);
     DoSetColor(isaSelect,forecolor,backcolor);

	 backcolor =  (ISA) Get_KeyWord_Assignment(tokenback,TK_BORDERS);
	 forecolor =  (ISA) Get_KeyWord_Assignment(tokenfore,TK_BORDERS);
     DoSetColor(isaBorders,forecolor,backcolor);
#if 0
		// now same as accelerator
	/* isaHotLink is background of dialog, and forground of selection */
	GetIsaColor(isaDialogBox,&forecolor,&backcolor);
	GetIsaColor(isaSelect,&forecolor2,&backcolor2);
	SetIsaColor(isaHotLink,forecolor2,backcolor);
#endif
	if(fMonochrome && gNotMonochrome)
	{
	  Set_DefaultColors();
   }
   SetUserColorSelection(ColorSelection);
}

/* This function re-paints the screen afresh! */
void DrawScreen(void)
{
	if(glob.InFileMgr)
		DoFileMgr();
	else
		InitializeStartPrograms();

	MainIdle();
} /* DrawScreen */


/* The total number of color schemes present in the INI file. */
#define GetNumColorSchemes() (gNumColorSchemes)


/* This is the function that gets control when user selects the Change Colors
 * menu item!
 */
VOID ColorBox(void)
{
	WORD savedcolor;

	/* If there was no INI file or there were no color schemes and we are
	 * using our internal color selection scheme, the user can't change
	 * colors. Sorry!!
	 */
	if (GetNumColorSchemes() <= 0)
	{
		Shell_Beep() ;
		return ;
	}

	gContinueColors = COLORPREVIEW;

	savedcolor = gNthColorGroup;

/* Loop until user selects OK or CANCEL button in the color manager dialog.
 * The fn ColorDialog() modifies the global variable gContinueColors.
 */
	while(gContinueColors >= COLORPREVIEW)
	{
		/* Put up color manager dialog and set the global "gContinueColors"
		 * Also, sets the variable "gColorListInd" indicating the
		 * color scheme that the user wants to be put into.
		 */
	   ColorDialog();

		/* Draw the screen based on the user's chosen color scheme. Do this if
		 * user didn't choose CANCEL.
		 */
		/* Note that gNthColorGroup is 1 based and gColorListInd is 0 based */
	   if(gContinueColors>=COLOROK && gNthColorGroup!=(gColorListInd+1))
	   {
			SelectColorGroup(gColorListInd+1) ;
			InitWindows(FALSE);
			DrawScreen() ;
	   }
	}

	/* Did the user select "Cancel" to skip the color change? If so, put
	 * him back in the original color scheme that he started the Change
	 * colors dialog in.
	 */
	if(gContinueColors == COLORCANCEL)
	{
		/* if the color scheme has changed, restore the original color scheme */
		if (savedcolor != gNthColorGroup)
		{
			SelectColorGroup(savedcolor);
			InitWindows(FALSE);
			DrawScreen() ;
		}
	}
} /* ColorBox */

/* This function puts up the color manager dialog box and depending on the
 * user's response (OK, CANCEL or direct color selection) sets the global
 * variable "gContinueColors" that is used by its caller to decide whether
 * to dismiss the color manager dialogs or perform appropriate actions.
 */
VOID FAR ColorDialog(void)
{
	TMC tmc;
	HCABcolor h = HcabAlloc(cabiCABcolor) ;

	if (!h)
	{
	    OutOfMemory() ;
	    return ;
	}
	InitCab(h,cabiCABcolor);

	SzToCab(h, szEnterButton, Iag(CABcolor, pszcolorEB));
	SzToCab(h, szCancelButton, Iag(CABcolor, pszcolorCB));
	SzToCab(h, szPreviewButton, Iag(CABcolor, pszcolorPB));

	tmc= MyTmcDoDlg(&dlgcolor,  h);

	switch (tmc)
	{
		case tmcOK:
			gContinueColors = COLOROK ;
			break ;

		case tmcCancel:
			gContinueColors = COLORCANCEL ;
			break ;

		// case tmccolorpreview:
		default:
/* gContinueColors has already been set to the scroll of the listbox ( >= 0 ) */
			break ;
	} /* switch */

	FreeCab(h);
} /* ColorDialog */

/* The number of color scheme titles that will be visible at any point of
 * time in the color listbox.
 */
#define COLORWINDOWSIZE 4

/*
 * fill in string "szColorScheme" with the ith color-scheme-title 
 * of the INI file.
 */ 
VOID GetNthColorString(int isz,char *szColorScheme)
{
	int colorind;
	TOKEN t_color, t_subcolor, t_title ;

	/* The parsed INI file is stored as 1 based */
	colorind = isz+1 ;

	t_color = Get_KeyWord_Assignment(TK_PROGRAMSTARTER, TK_COLOR) ;
	
	/* ZZZZZZZZZZZZZZZ */
	/* Note that even when there is no color entry in INI file, we set up
	 * a default color setting and this is/should be added to memory data
	 * structure by the parser.
	 */
	assert(t_color >= 0) ;

	t_subcolor = Get_Symbol_Value(Token_To_Symbol(
												Get_Ith_Element(t_color, colorind))) ;

	assert(t_subcolor >= 0) ;       
	
	t_title = Get_KeyWord_Assignment(t_subcolor, TK_TITLE) ;

	assert(t_title >= 0) ;

	FarToNearsz(szColorScheme, Get_Token_Identifier(t_title), MAXCOLORTITLE) ;
} /* GetNthColorString */


/* This function draws the Color scheme title string in the listbox. The
 * 'isz'th string (0 based) is to be drawn at (x, y) with color attribute
 * specified by 'bArg'.
 */
void  MakeColorLine(RX x, RY y, WORD isz, WORD bArg)
{
	int i, len ;
	RX rxGraphics ;
	RY ryGraphics ;
	unsigned char ColorString[50] ; /* 50 > max length of any color scheme name */
	char szColorScheme[MAXCOLORTITLE+1] ;

	GetNthColorString(isz,szColorScheme);

	/* the '-2' handles the scroll bar width */
   len = Get_List_Rect(&ColorList).axRight-Get_List_Rect(&ColorList).axLeft-2;


	/* Form the color scheme string "ColorString" padded nicely with blanks */
	 *ColorString = ' ' ;
    for(i=1; szColorScheme[i-1]; i++)
    {
		ColorString[i] = szColorScheme[i-1];
    }
	
	/* pad with blanks! */
	for(; i < len-3; i++)
	{
		ColorString[i] = ' ';
	}

	TextOut(ColorList.pwd, x+2, y, ColorString, len-3,
				(bArg&TF_ISFOCUS) ? isaHilite : isaDialogBox);

	/* Graphics is done relative to top of screen -- i.e. in absolute
	 * co-ordinates and not wrt to a window!!
	 */
	rxGraphics = ColorList.pwd->arcWindow.axLeft + x + 2 ;
	ryGraphics = ColorList.pwd->arcWindow.ayTop + y ;

	/* The FALSE in the param list forces fn DrawFocusMarker to always draw
	 * the focus box in graphics mode!!
	 */
	DrawFocusMarker(ColorList.pwd, x+1, y, rxGraphics, ryGraphics,
								len-3, bArg & TF_ISFOCUS, FALSE, isaDialogBox) ;

} /* MakeColorLine */


WORD PASCAL ListProcColorList(WORD tmm, char *sz, WORD isz, TMC tmc, 
																WORD x, WORD y, WORD bArg)
{
	RX xval;

	UnReferenced(tmc) ;
	UnReferenced(x) ;

	xval = Get_List_Rect(&ColorList).axLeft;
	switch (tmm) {
		case tmmCount:
			return GetNumColorSchemes() ;

		case tmmGetItemString:
			GetNthColorString(isz,sz);
			break ;

		case tmmDrawItem:
			if (isz < GetNumColorSchemes())
			{
				if (bArg & TF_ISFOCUS)
				{
					gColorListInd = isz ;
				}
				MakeColorLine((RX) xval, (RY) y, isz, bArg) ;
			}
			break;

		case tmmActivate:
			if (isz >= GetNumColorSchemes())
				return 0 ; /* garbage value */

			gColorListInd = isz ;
										
			EndDlgTmc(tmcOK) ;
			break ;

		case tmmSetFocus:
			// be sure we update the previous line, since we draw the focus
			// ignoring the bArg field!
			// start at zero, since mouse clicks can be discontigous!
			InsertListItem(&ColorList, 0);
			break ;

		case tmmSelect:
		case tmmToggleSelect:
			/* Never draw on a select, only mark selections! */

		case tmmDeselectAll:
		default:
			break;
	}
	return TRUE;
} /* ListProcColorList */


/* The PfnFunction that first sees the characters, etc when focus is on the
 * "picture" item of the dialog box (our listbox)
 */
LONG FAR PASCAL pfnColorList(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	UnReferenced(pwnd) ;

    switch(message)
    {
		case WM_CHAR:
			/* pass on the special characters to CW -- returning FALSE does this*/
			if ( (wParam == '\t') || (wParam == ESCAPE) || (wParam == VK_ESCAPE) )
				return(FALSE);

			ListKey(&ColorList,wParam, HIWORD(LParam));
			break;

      case WM_KILLFOCUS:
		GlobalFocusBox(&ColorList,FALSE);
			break;
				
		case WM_SETFOCUS:
		GlobalFocusBox(&ColorList,TRUE);
		   break;
						
    case WM_PAINT:
	UpdateListBox(&ColorList);
	break;
	} /* switch */

	return(TRUE);
} /* pfnColorList */
		
		
/* Dialog procedure for the color manager. */
BOOL FAR PASCAL FDlgcolor(WORD dlm, TMC tmc, WORD wNew,
												WORD wOld, WORD wParam)
{
	PWND dwind, lwind ;
	WORD mx, my ;
	static BOOL fListBoxInited ;

	UnReferenced(tmc) ;

	dwind = PwndParent(PwndOfListbox(tmcOK));

	switch (dlm)
	{
		case dlmInit:
			/* Initially focus is on the enter button! */
			gCurrentTMC = tmcOK ;

			fListBoxInited = FALSE ;

			SetUpDialog(tmcOK, szChangeColorsCaption);

			SetUpButtonForGraphics(tmcOK);
			SetUpButtonForGraphics(tmcCancel);
			SetUpButtonForGraphics(tmccolorpreview);
				
			lwind = PwndOfListbox(tmccolorlist) ;
		   /* We don't want to draw focus cursor in the attr listbox window */
		   EnableCursor(lwind, FALSE) ;

			/* Initially set focus on the listbox */
			SetFocusTmc(tmccolorlist) ;

		   SetWindowProc(lwind,pfnColorList);

			gColorListInd = gNthColorGroup - 1;

	       ListBoxInit(&ColorList,ListProcColorList,dwind,
				lwind->arcWindow.ayTop -dwind->arcWindow.ayTop,
			lwind->arcWindow.axLeft-dwind->arcWindow.axLeft,
				lwind->arcWindow.ayTop-dwind->arcWindow.ayTop+COLORWINDOWSIZE+1,
			lwind->arcWindow.axRight-dwind->arcWindow.axLeft+1,
			gColorBoxTitle, tmccolorlist, gNthColorGroup-1, gNthColorGroup-1);

			Set_List_Color(&ColorList, isaDialogBox) ;

			/* Prevent drawing of the list box until dialog is put up! */
			Halt_Listbox(&ColorList) ;

		   /* Initially the focus is in  the listbox */
		   GlobalFocusBox(&ColorList, TRUE);
			break ;

		case dlmIdle:
			if (!fListBoxInited)
			{
				fListBoxInited = TRUE ;
				UnHalt_Listbox(&ColorList) ;
				if(gContinueColors != COLORPREVIEW)
					DoScrollListBox(&ColorList,
						gContinueColors-Get_List_Scrolled(&ColorList), FALSE);
				ListBoxIdle(&ColorList) ;
			}
			ListBoxIdle(&ColorList);
		break;

		case dlmSetFocus:
			gCurrentTMC = tmc;
			break ;

		case dlmClientMouse:
			dwind = PwndParent(PwndOfListbox(tmcOK));
			my = HIBYTE(wParam);
			mx = LOBYTE(wParam);
			if (ListMouse(&ColorList, mx, my, wNew, wOld))
			{
				/* If user clicked on the listbox, make it the focus */
				SetFocusTmc(tmccolorlist);
			}
			break;

		case dlmTerm:
			gContinueColors = Get_List_Scrolled(&ColorList);
			break;

	} /* switch */

   return(TRUE);
} /* FDlgcolor */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\compare.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; ZZZZZZ Are there bugs with offset calculations?? Is DGROUP the right
; assume for DS? I am unable to access variable DoQuickCompare from 'C'
; The offset is off by 64 bytes!!

?WIN = 0                ;Not windows;
?PLM = 1                ;DO use pl/m
include cmacros.inc

USA_CODE        EQU             001

sBegin data
      EXTRN gDescendingOrder: WORD

       CollStruc struc
			CollInfoId      db  ?
			CollInfoPtr     dd  ?
       CollStruc ends

       CountryBuffer struc
			Date_Format     db  2 dup(?)
			Currency_Symbol db  5 dup(?)
			Thousands_Sep   db  2 dup(?)
			Decimal_Sep     db  2 dup(?)
			Date_Sep        db  2 dup(?)
			Time_Sep        db  2 dup(?)
			Currency_Pos    db  ?
			Num_Decimals    db  ?
			Time_Format     db  ?
			Case_Mapping    dd  ?
			Data_Sep        db  2 dup(2)
			Reserved        db 10 dup(?)
			;;;;size of structure must be at least 34 bytes!!
       CountryBuffer ends

       CollInfo         CollStruc <>
       EXTRN NationData:  BYTE

	   DoQuickCompare       db       0 ; Will be set to 1, if USA or
					   ; no collating table avail.
	   PUBLIC       DoQuickCompare
sEnd data

sBegin code

    assumes cs, code
    assumes ds, DGROUP

;;;; This function gets the International data into global NationData
;;;; Effects:
;;;;    Fills in NationData global
;;;;   DoQuickCompare set to 1, if country is USA, else unchanged.
;
; BOOL GetInternationalData(void)
;
cProc  GetInternationalData, PUBLIC,    <si,di,ds,es>
cBegin  GetInternationalData
	lea     dx, NationData          ; DS:DX points to NationBuffer
	mov ax,3800h                    ; Get Current Country info
	int 21h                         ; If success, Carry clear and BX = country code

	mov ax,0                        ;
	cmc                             ;
	rcl ax,1                        ; value return to C-caller (1 on success, else 0)

	;; Now set the DoQuickCompare field
	cmp     bx, USA_CODE            ; Is current country USA?
	jne     GIDNotQuick

GIDQuick:
	mov     DoQuickCompare, 1       ; QuickCompare is possible

	;;; DoQuickCompare remains 0 if country is not USA.

GIDNotQuick:
cEnd  GetInternationalData

;;;; This function sets up the character collating table for sorting
;;;; Effects:
;;;;   CollInfoId set to 6 if collating table is found, else 0.
;;;;   CollInfoPtr points to collating table found.
;;;;   DoQuickCompare set to 1, if no collating table avail, else unchanged.
;
; void SetCollatingTable(void)
;
cProc  SetCollatingTable, PUBLIC,  <si,di,ds,es>
cBegin  SetCollatingTable
	assumes ds, DGROUP

	lea     di, CollInfo    
	push    ds                              
	pop     es                      ; ES:DI points to CollInfo buffer

	mov     ax, 6506h               ; DOS function get extended country Info
					; subfunc get pointer to collating sequence table
	
	mov     bx, -1                  ; BX = code page of interest (active CON = -1)
	mov     cx, 5                   ; CX = length of buffer to receive info
	mov     dx, bx                  ; DX = country ID (default = -1)

	int     21h
	jnc     SCTRet                  ; Success, CollInfoId = 6 is set by DOS.

;       The call failed. Set CollInfoInd = 0 to signal no collating table.

	mov     CollInfo.CollInfoId, 0
	mov     DoQuickCompare, 1       ; QuickCompare can be done as no coll table avail

SCTRet:
cEnd  SetCollatingTable

; Invoked from a c-routine. Returns TRUE, if we can use a non-collating compare
; That is whether a straight ASCII compare can be done.
cProc  FDoQuickCompare, PUBLIC, <si,di,ds,es>
cBegin  FDoQuickCompare
	assumes ds, DGROUP
	xor     ah, ah
	mov     al, DoQuickCompare
cEnd  FDoQuickCompare


;;;; This function compares two strings using the collating table if avail.
;;;; ENTRY      DS:SI = ptr to string1
;;;;            ES:DI = ptr to string2
;;;;            CX = length of string to be compared
;;;;
;;;; EXIT       Depending on >, <, ==, the processor flags are set.
;;;;            direction flag cleared.
;;;;            destroys AX, BX, CX, DX, DI, SI
str_cmp proc
	cld                             ; for lodsb, repe instructions to inc addresses

	push    bp                      ; preserve BP
	mov             bp,     ds      ; save string1's seg as we need DS for collating stuff
	mov             ax, DGROUP
	mov             ds, ax
	assumes ds,DGROUP

	lds     bx, CollInfo.CollInfoPtr  ; DS:BX = ptr to collating table
	assumes ds,nothing

	mov             dx, ds:[bx]     ; DX = collating table length
	add             bx, 2           ; DS:BX = ptr to collating values

	dec             dx              ; dl holds length of table - 1
SC_nextchar:
	mov             al, es:[di]     ; AL = AX = char from string2
	inc             di                      ; ES:DI = ptr to next char in string2

;;; BUGBUG -- maybe I should avoid these collating length compares in the loop?
	cmp             al,dl
	ja              @F              ; in the table?
SC_xlat1:
	xlat
@@:
	mov             ah, al          ; store char in ah

	push            ds              ; save DS
	mov             ds, bp          ; DS = seg address of string1
	lodsb                           ; AL = DS:[SI++] = char from string1
	pop             ds                      ; restore DS = seg of collating table

	cmp             al, dl          ; compare char to length of collating table
	ja              @F
SC_xlat2:
	xlat
@@:
	cmp             al, ah          ; compare char from string1 with that from string2

ifdef DBCS
	loope   @f
	jmp     short SC_not_same       ; if not same
@@:
	mov     al,es:[di-1]
	call    IsDBCSLeadByte
	jnz     SC_nextchar             ; if this is not lead byte
	mov     ah,es:[di]              ; get tail byte
	inc     di
	push    ds
	mov     ds,bp
	lodsb
	pop     ds
	cmp     al,ah                   ; compare tail byte
	loope   SC_nextchar     ; loop until unequal or no more left
SC_not_same:
else

	loope   SC_nextchar     ; loop until unequal or no more left
endif

	mov             ds, bp          ; DS = value on entry to this routine

	pop             bp                      ; restore BP
	ret
str_cmp endp

;;;; This function compares the names of files for sorting using collating table
;;;; The extension is always at offset 8.
;;;; The short names/extensions are assumed to be padded by NULL/same chars.
;;;; If the names are the same, compare extensions also.
;;;; Returns -1 if one < two
;;;;          0 if equal
;;;;          1 if one > two
;
; int pascal name_cmp(char far* string_one,char far* string_two)
;
cProc  name_cmp, PUBLIC,  <si,di,ds,es>
parmW string_one_segment
parmW string_one_offset
parmW string_two_segment
parmW string_two_offset
cBegin  name_cmp
	
    mov di,string_two_offset
    mov es,string_two_segment

    mov si,string_one_offset
    mov ds,string_one_segment
    assumes ds,nothing

    mov cx,8
    call str_cmp                        ; sets the >, <, == flags

    ja short nc_1_is_bigger

    
    jne short nc_1_is_lesser; if we get here, one is <= two

    ;;; here we compare the extensions as names match
    mov di,string_two_offset
    add di,8                            ; add 8 to get to extension

    mov si,string_one_offset
    add si,8                            ; add 8 to get to extension

    mov cx,3
    call str_cmp                        ; sets the >, <, == flags

    mov ax, 0                           ; set ret status to mean equal strings

    ja short nc_1_is_bigger
    je short NameC_end

nc_1_is_lesser:
    mov ax,-1
    jmp short NameC_Toggle

nc_1_is_bigger:
    mov ax,1

NameC_Toggle:

    ; Based on the sort order exchange the values -1 and 1. Note that the
    ; flag "gDescendingOrder" will have a value of FFFE or 0!

    mov bx, DGROUP
    mov ds, bx
    assumes ds, DGROUP

    xor ax, gDescendingOrder

NameC_end:
cEnd  name_cmp


;;;; This function compares the names of files for sorting, with bias
;;;; on the extension name using collating table!!
;;;; The extension is always at offset 8.
;;;; Short names/extensions are assumed to be padded by NULL/same chars.
;;;; If the extensions are the same, compare names also.
;;;; The name is either null terminated or 8 characters long and begins
;;;; at offset 0.
;;;; Returns -1 if one < two
;;;;          0 if equal
;;;;          1 if one > two

;
; int pascal ext_cmp(char far* string_one,char far* string_two)
;
cProc  ext_cmp,  PUBLIC,  <si,di,ds,es>
parmW string_one_segment
parmW string_one_offset
parmW string_two_segment
parmW string_two_offset
cBegin  ext_cmp
	
	
    mov di,string_two_offset
    mov es,string_two_segment

    add di,8                            ; add 8 to get to extension

    mov si,string_one_offset
    mov ds,string_one_segment
    assumes ds,nothing
    
    add si,8                            ; add 8 to get to extension

    mov cx,3
    call str_cmp                        ; sets the >, <, == flags

    ;;; ax is zero now
    ja short ec_1_is_bigger
    jne short ec_1_is_lesser

    ;;; extensions are the same -- so compare names.
    mov di,string_two_offset
    
    mov si,string_one_offset

    mov cx,8
    call str_cmp                        ; sets the >, <, == flags

    mov ax, 0                           ; set ret status to mean equal strings

    ja short ec_1_is_bigger

    ;;; if we get here, one is <= two
    je short ExtC_end

ec_1_is_lesser:
    mov ax,-1
    jmp short ExtC_Toggle

ec_1_is_bigger:
    mov ax,1

ExtC_Toggle:

    ; Based on the sort order exchange the values -1 and 1. Note that the
    ; flag "gDescendingOrder" will have a value of FFFE or 0!

    mov bx, DGROUP
    mov ds, bx
    assumes ds, DGROUP

    xor ax, gDescendingOrder

ExtC_end:
cEnd  ext_cmp

;;;; function similar to name_cmp but with direct ASCII values!!
cProc  quick_name_cmp, PUBLIC,  <si,di,ds,es>
parmW string_one_segment
parmW string_one_offset
parmW string_two_segment
parmW string_two_offset
cBegin  quick_name_cmp

    assumes ds, DGROUP
    mov bx, gDescendingOrder    ; store the ascending/descending order flag
				; in 'bx'
    cld

    mov di,string_two_offset
    mov es,string_two_segment

    mov si,string_one_offset
    mov ds,string_one_segment
    assumes     ds,nothing

    mov cx, 11          ; size of name+extension
    xor ax, ax          ; mark return value as 0 - will be used later

    repe cmpsb

    ;;; ax is zero now
    je  short QNameC_end

    ;;; if we get here, one is <> two!
    ja short qnc_1_is_bigger

qnc_1_is_lesser:
    dec ax              ; ax = -1       
    dec ax              ; ax = -2
			; Flow thru now makes ax = -1 for return value

qnc_1_is_bigger:
    inc ax

    ;;; Based on the Sort Order -- whether we want to sort by ascending
    ;;; order or descending order we want to return 1, 0, -1 instead of
    ;;; the respective values of -1, 0, 1 for less, equal and greater resp.
      
    xor ax, bx          ; xor with sort order flag to xchg -1 and 1.
    
QNameC_end:
cEnd  quick_name_cmp

;;;; function similar to ext_cmp but with direct ASCII values!!
cProc  quick_ext_cmp,  PUBLIC,  <si,di,ds,es>
parmW string_one_segment
parmW string_one_offset
parmW string_two_segment
parmW string_two_offset
cBegin  quick_ext_cmp

    assumes ds, DGROUP
    mov bx, gDescendingOrder    ; store the ascending/descending order flag
				; in 'bx'
    cld

    mov di, string_two_offset
    mov es, string_two_segment
    ;;; add 8 to get to extension
    add di, 8

    mov si, string_one_offset
    mov ds, string_one_segment
    assumes ds, nothing
    ;;; add 8 to get to extension
    add si, 8

    mov cx, 3

    xor ax, ax                  ; mark return value as 0 - will be used later

    repe cmpsb

    ja  short qec_1_is_bigger

    jne short qec_1_is_lesser

    ;;; extensions are the same -- so compare names.
    mov di, string_two_offset

    mov si, string_one_offset

    mov cx, 8

    repe cmpsb

    ;;; ax is zero now
    je short QExtC_end

    ;;; if we get here, string one is <> string two
    ja short qec_1_is_bigger

qec_1_is_lesser:
    dec ax              ; ax = -1       
    dec ax              ; ax = -2
			; Flow thru now makes ax = -1 for return value

qec_1_is_bigger:
	inc ax

    ;;; Based on the Sort Order -- whether we want to sort by ascending
    ;;; order or descending order we want to return 1, 0, -1 instead of
    ;;; the respective values of -1, 0, 1 for less, equal and greater resp.
	
    xor ax, bx          ; xor with sort order flag to xchg -1 and 1.

QExtC_end:
cEnd  quick_ext_cmp


; THIS FUNCTION IS NOT USED
; int pascal strnzcmp(char far* string_one,char far* string_two, word)
;
;cProc  strnzcmp, PUBLIC , <si,di,ds,es>
;parmW string_one_segment
;parmW string_one_offset
;parmW string_two_segment
;parmW string_two_offset
;parmW len
;cBegin  strnzcmp
;    mov es,string_two_segment
;    mov di,string_two_offset
;    cld
;    xor ax,ax
;    mov bx,len
;    mov cx,bx
;    repne scasb ;;; find length of string 2 but don't look for EOS beyond len
;
;    sub bx,cx
;    mov cx,bx
;    sub di,bx
;    mov ds,string_one_segment
;    mov si,string_one_offset
;    repe cmpsb
;
;    ;;; ax is zero now
;    ja short str_one_is_bigger
;    ;;; if we get here, one is <= two
;    je StrC_end
;
;str_one_is_lesser:
;        mov ax,-1
;        jmp short StrC_end
;
;str_one_is_bigger:
;    mov ax,1
;
;StrC_end:
;cEnd  strnzcmp

ifdef DBCS
;
;       Test if the character is DBCS Lead Byte
;
;       input:  AL = character to check
;       outpit: ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable       dd      0

IsDBCSLeadByte          proc    near
	push    ax
	push    si
	push    ds
	lds     si,cs:DBCSLeadByteTable
	cmp     word ptr cs:DBCSLeadByteTable+2,0
	jnz     idlb_check              ; if table is already set
	push    ax
	mov     ax,6300h
	int     21h                     ; get DBCS lead byte table
	pop     ax
	mov     word ptr cs:DBCSLeadByteTable,si
	mov     word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp     word ptr [si],0
	jz      idlb_not                ; if end of table
	cmp     al,[si]
	jb      idlb_next               ; if below low value
	cmp     al,[si+1]
	jbe     idlb_yes                ; if below high value
idlb_next:
	add     si,2                    ; do next
	jmp     short idlb_check
idlb_not:
	or      al,1                    ; reset ZF
	jmp     short idlb_end
idlb_yes:
	and     al,0                    ; set ZF
idlb_end:
	pop     ds
	pop     si
	pop     ax
	ret
IsDBCSLeadByte          endp
endif

sEnd   code


end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\cmdlan.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <process.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <user.hs>
#include <user.sdm>
#include <text.h>
#include <tasklist.h>
#include <help.h>

int BatchOff;
char far *BatchFile;
extern VOID FarToNearsz(char *temp,char far *str,int max);
extern BOOL AddTask(char far *programname, char far *parameters,char far *defaulttitle,TOKEN properties,WORD magiccookie);
extern void PASCAL CabToVariable(HCAB, WORD, TOKEN, TOKEN);
extern BOOL PASCAL VariableToCab(TOKEN, TOKEN, HCAB, WORD);
extern void PASCAL VariableToString(TOKEN, TOKEN, char *, int);
extern TOKEN GetParamDialog(TOKEN list, int param);
extern BOOL gSwitchingEnabled;
extern WORD gEditBoxModifier;
extern BOOL gLoadEqualsProcessed;

#define MAXUSERTITLE 30
#define MAXUSERINSTRUCTIONS 106
#define MAXUSERPROMPT 18
#define MAXUSERDEFAULT 64
#define MAXUSERCOMMAND 256

#define MAXPARAM 10
#define MAXUSERPASSWORD 20
char userTitle[MAXUSERTITLE];
char userInstructions[MAXUSERINSTRUCTIONS];
char userPrompt[MAXUSERCOMMAND];
char userDefault[MAXUSERDEFAULT];
char userCommand[MAXUSERCOMMAND];
char userPassword[MAXUSERPASSWORD];
int gthisparam;
char userParam[MAXPARAM][MAXUSERDEFAULT];
BOOL gfUserCanceled;
BOOL FAR PASCAL FDlguser(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	PWND twind ;
	int tlen, textlen ;
	int i, lastind  ;
	char tempstr[90] ;

	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

    switch(dlm)
    {
	case    dlmInit:
	{
		 twind = PwndOfListbox(tmcinstructions1);
		 tlen = twind->arcWindow.axRight - twind->arcWindow.axLeft + 1 ;
		 textlen = strlen(userInstructions) ;
		 lastind = tlen ;
		 for (i = 0 ; i < min(tlen, textlen) ; i++)
		 {
			 if (userInstructions[i] == ' ')
				lastind = i ;
			 tempstr[i] = userInstructions[i] ;
		 }
		 if(i >= tlen)
		 {
			tempstr[lastind] = '\0' ;
			/* BUG BUG 1 could clip */
			Shell_SetTmcText(tmcinstructions2, &userInstructions[lastind+1]);
		 }
		 else
		 {
			tempstr[textlen] = 0;
		 }

		 Shell_SetTmcText(tmcinstructions1, tempstr);
		 Shell_SetTmcText(tmcprompt, userPrompt);
		 if(userTitle[0] == 0)
		 {
			 strncpy(userTitle,userCommand,MAXUSERTITLE-1);
			 userTitle[MAXUSERTITLE-1] = 0;
			 if(strlen(userTitle) >= MAXUSERTITLE-5) //ellipses
			 {
				userTitle[MAXUSERTITLE-5] = 0;
				strcat(userTitle,szEllipses);
			 }
		 }
	    SetUpDialog(tmcprompt,userTitle);
		 SetUpButtonForGraphics(tmcOK);
		 SetUpButtonForGraphics(tmcCancel);
		 SetUpButtonForGraphics(tmcuserHB);

		 SetUpEditBox(tmcuserquery, TRUE,MAXUSERCOMMAND, TRUE);

	}
	case dlmTerm:
	{
		GetTmcText(tmcuserquery,userPrompt,MAXUSERDEFAULT);
		strcpy(userParam[gthisparam],userPrompt);
	}
	break;
	case dlmSetFocus:
	{
		gCurrentTMC = tmc;
	}
	break;

	case dlmClick:
		 if(tmc == tmcuserHB)
			Help(hemDialog, hidUSER, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;
    }
    return(TRUE);
}

extern TOKEN gNext_Task_Info;
extern char gNext_Task_Name[];

void DoUserDialog(void)
{
    HCABuser h;
    TOKEN thistoken;
    int thisparam;
    BOOL bSaveDef = FALSE;

    if(gfUserCanceled)
	return;

    if(!(h=HcabAlloc(cabiCABuser))) {
	OutOfMemory() ;
	return ;
    }
    InitCab(h, cabiCABuser);

    if(gNext_Task_Info > 0) {
	thisparam = *Get_Token_Identifier(gLookahead) - '0';
	if((thistoken=GetParamDialog(gNext_Task_Info, thisparam)) > 0) {
	    VariableToString(thistoken, TK_TITLE, userTitle, MAXUSERTITLE);
	    VariableToString(thistoken, TK_INFO,
		    userInstructions, MAXUSERINSTRUCTIONS);
	    VariableToString(thistoken, TK_PROMPT, userPrompt, MAXUSERCOMMAND);
	    VariableToString(thistoken, TK_DEFAULT, userDefault,MAXUSERDEFAULT);

/* INTERNATIONALIZE here: 'F' and 'L' in the switch below */
	    if(userDefault[0]=='%' && !userDefault[2]) {
		switch(toupper(userDefault[1])) {
		case 'F':
/* This inserts the File that has the focus in the file list
 * into the dialog box as a default value
 */
		    if(glob.InFileMgr)
#if 0
			FormSelFileList(userDefault, MAXUSERDEFAULT-13);
#else
			ListProcFileList(tmmGetItemString, userDefault,
				FileList[0].focusitem, 0, 0, 0, 0);
#endif
		    else
			*userDefault = '\0';
		    break;

		case 'L':
/* This inserts the Last string that was used as a parameter
 * for this dialog box
 */
		    VariableToString(thistoken, TK_STARTUP,
			    userDefault, MAXUSERDEFAULT);
		    bSaveDef = TRUE;
		    break;
		}
	    }

#define ALLMODS (KK_ALT|KK_SHIFT|KK_CONTROL)
#define SKIPBOXMODS (KK_SHIFT|KK_CONTROL)
	    if((!gLoadEqualsProcessed && !GET_WAIT_FLAG()) ||
		    (gEditBoxModifier&ALLMODS)==SKIPBOXMODS) {
/* Accept default without prompt if SHIFT and CONTROL down
 * or if we are doing initial loading
 */
		strcpy(userPrompt, userDefault);
		strcpy(userParam[thisparam], userPrompt);
		goto DoAppend;
	    }

	    SzToCab(h, userDefault, Iag(CABuser, pszuserquery));
	}
    }

    SzToCab(h, szEnterButton, Iag(CABuser, pszuserEB));
    SzToCab(h, szCancelButton, Iag(CABuser, pszuserCB));
    SzToCab(h, szHelpButton, Iag(CABuser, pszuserHB));

    if(MyTmcDoDlg(&dlguser,h) == tmcOK) {
DoAppend:
	Append_Command(userPrompt);
	if(bSaveDef)
	    CabToVariable(h, Iag(CABuser, pszuserquery), thistoken, TK_STARTUP);
    } else
	gfUserCanceled = TRUE;

    FreeCab(h);
}

VOID Append_Command(char far *str)
{
    int i;
    i = 0;
    while(str[i])
    {
	BatchFile[BatchOff] = str[i];
	i++;
	BatchOff++;
    }
    BatchFile[BatchOff] = '\0';
}

VOID GetDialogParam()
{
    switch(gLookahead)
    {
	case TK_T:
	{
	    match(gLookahead);
	    FarToNearsz(userTitle,Get_Token_Identifier(gLookahead),MAXUSERTITLE);
	    match(gLookahead);

	}
	break;
	case TK_P:
	{
	    match(gLookahead);
	    FarToNearsz(userPrompt,Get_Token_Identifier(gLookahead),MAXUSERCOMMAND);
	    match(gLookahead);
	}
	break;
	case TK_D:
	{
	    match(gLookahead);
	    FarToNearsz(userDefault,Get_Token_Identifier(gLookahead),MAXUSERDEFAULT);
	    match(gLookahead);

	}
	break;
	case TK_R:
	case TK_L:
	case TK_M:
	case TK_C:
	break;
    }
}

VOID UserDialog()
{
    userTitle[0] = NULL;
    userInstructions[0] = NULL;
    userPrompt[0] = NULL;
    userDefault[0] = NULL;

    while((gLookahead != TK_EOF) && (gLookahead != TK_RIGHTBRACKET))
    {
	switch (gLookahead)
	{
	    case TK_SLASH:
	    {
		match(gLookahead);
		GetDialogParam();
	    }
	    break;
	    default:
		match(gLookahead);
	}
    }
    match(TK_RIGHTBRACKET);
    DoUserDialog();
}

extern int gNumWhiteSpaces;
extern BOOL gfInRun;

VOID GetNextCmd()
{
	 int param;
	 char temp[3]; 
	 int i;

    switch (gLookahead)
    {
		case TK_EOF:
	   break;
		case TK_COMMANDSEP:
		{
			Append_Command(szNewCmd);
			Append_Command(szStartCmd);
			match(gLookahead);
		}
		break;
		case TK_LEFTBRACKET:
		{
			//Append_Command("\r\n");
			/* if we are in the run dialog box,
			 * we should ignore the language stuff
			 */
			if(gfInRun)
			{
				goto defaultcase;
			}
			else
			{
				match(gLookahead);
				UserDialog();
			}
		}
		break;
		case TK_VARSENTINEL:
			match(gLookahead); // %
			if(gLookahead != TK_EOF)
			{
				FarToNearsz(temp,Get_Token_Identifier(gLookahead),2);
				param = temp[0] - '0';
			}
			else
			{
				param = 0;
			}
			if((param > 0) &&(param < 10))
			{
				gthisparam = param;
				/* if this param has already been prompted for */
				if(userParam[param][0])
					Append_Command(userParam[param]);
				else
				   DoUserDialog();
				match(gLookahead); // number
			}
			else
			{
				Append_Command("%");
			}
			for(i=0;i<gNumWhiteSpaces;i++)
				Append_Command(" ");

		break;


		default:
		{
defaultcase:
			Append_Command(Get_Token_Identifier(gLookahead));

			match(TK_WILD);
			for(i=0;i<gNumWhiteSpaces;i++)
				Append_Command(" ");

		}
		break;
    };

}


/*  NAME
 *      ParseCmds
 *  DESCRIPTION
 *      start parsing the command
 *  ARGUMENTS
 *      none
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      memory allocation, new symbols, the works
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
void ParseCmds(char far *commands)
{
    WORD size;
	 int i;
	
    BatchOff = 0;
    BatchFile[0] = 0;
    size = myfstrlen(commands);

    Init_ParseText(0, commands, 0, size);

	 gthisparam = 0;
	 for(i=0;i<MAXPARAM;i++)
		userParam[i][0] = 0;
    /*
     * now we use @ on every line
     * Append_Command("@echo off");
     */
    Append_Command(szStartCmd);
    /*
     * the lexer needs to be kick started by matching TK_WILD token
     */
    match(TK_WILD);
    /*
     * keep parsing until EOF is reached
     */
    while(gLookahead != TK_EOF)
    {
	GetNextCmd();
    };
}

#define BATCHSIZE 512

extern char gStartUpDir[65];
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */

extern void Set_Task_Name(char far *name);
extern void Set_Task_Info(TOKEN list);


/*
 * fill in name with name of command batch file for this process
 * magiccookie is a random number used as a prefix to the batchfile.
 * this number can be used as a global identifier for the batchfile.
 * (We use it in the global structure to identify the batch file
 * on a process after it exits.)
 */
VOID GetBatchName(char *name,int *magiccookie)
{
		int ind;
		static BYTE magiccounter = 0;

		get_temp_dir(name,TRUE);
		ind = strlen(name) ;
#ifdef DBCS
		if (name[ind-1] != '\\' || CheckDBCSTailByte(name,&name[ind-1]))
#else
		if (name[ind-1] != '\\')
#endif
		{
		    name[ind++] = '\\' ;
		}
		
		if(!*magiccookie) // if cookie wasnt passed in, make one
		{
			/* if tasking is not being done, we use PID since
			 * it will be unique, and we can retrieve it later!
			 */
			if(!gSwitchingEnabled)
			{
				*magiccookie = getpid();
			}
			else
			{
				/* The magic cookie should be unique, as
				* we use it to delete the file later (deletebatchfile)
				* You cannot only use ClockTicks, as two batches could 
				* be made in that about of time(load=), so we use a counter 
				* also. Note that the counter alone also won't work, as
				* multiple shells could be running.
				*/
				*magiccookie = (int) (ClockTicks()+magiccounter++) ;
			}
		}
		itoa((int) *magiccookie,name+ind,16);
		strcat(name,szCmdBat);
}

/*
 * Delete the batch files
 */
VOID DeleteBatchFile(void)
{
	char name[91];
	Switch_Info far *switchdata;
	int i;
	int magiccookie;
	int ind;

	if(gSwitchingEnabled)
	{
		switchdata = C_GET_GLOBAL_SWITCH_DATA();
		for(i=0;i<MAX_NUM_PROGRAMS;i++)
		{
			/* If its a free entry, and has a cookie.. */
			if((magiccookie=switchdata->Program_list[i].Shell_Cookie) &&
				(switchdata->Program_list[i].Program_Flags & F_FREE))
			{

				get_temp_dir(name,TRUE);
				ind = strlen(name) ;
#ifdef DBCS
				if (name[ind-1] != '\\' || CheckDBCSTailByte(name,&name[ind-1]))
#else
				if (name[ind-1] != '\\')
#endif
				{
					name[ind++] = '\\' ;
				}
				itoa(magiccookie,name+ind,16);
				strcat(name,szCmdBat);  
				 _dos_setfileattr(name, 0); /* remove any read-only attrib on file */
				unlink(name);

			//switchdata->Program_list[i].Shell_Cookie = 0;
			}
		}
	}                                      
	else
	{
		magiccookie = getpid();
		get_temp_dir(name,TRUE);
		ind = strlen(name) ;
#ifdef DBCS
		if (name[ind-1] != '\\' || CheckDBCSTailByte(name,&name[ind-1]))
#else
		if (name[ind-1] != '\\')
#endif
		{
			name[ind++] = '\\' ;
		}
		itoa(magiccookie,name+ind,16);
		strcat(name,szCmdBat);  
		unlink(name);

	}
}

VOID GetCommandString(char *commandstring,char *parameters,char *batname,int *magiccookie)
{
		if(commandstring) //!NULL
		get_comspec(commandstring);
		strcpy(parameters,szCmdBatRun);

		GetBatchName(batname,magiccookie);      
		strcat(parameters,batname);
	 
}

BOOL SetupCommand(char far *commands, char *startdir,BOOL dolaunch,TOKEN info)
{
   int fhandle;
   int size;
   char commandcom[128];
   char batname[91];
   char commandstring[256];
	int magiccookie;
	int ret ;
	int action ;
	char *tempcaption ;



   /* commands == NULL implies we want to launch command.com by itself! */
   if(commands!= NULL)
   {
	  
		BatchFile = LpbAllocWorkFar(BATCHSIZE);
		if (!BatchFile)
	      return(FALSE);

		gfUserCanceled = FALSE;
		ParseCmds(commands);
/* We didn't really change the ini file here, just made some temp symbols */
		if(gfUserCanceled)
			return(FALSE);

		magiccookie = 0; // we need a new unique cookie
		GetCommandString(commandcom,commandstring,batname,&magiccookie);
		
		do
		{
			action = ACT_OK ;

			if ((_dos_creat(batname,_A_NORMAL,&fhandle)) != 0)
			{
				_dos_setfileattr(batname, 0); /* remove any read-only attrib */
				if ((ret = _dos_creat(batname,_A_NORMAL,&fhandle)) != 0)
				{
					/* Put the drive letter in the message */
					szErrCreatTmpFile[DRIVEOFFSET_szErrCreatTmpFile] = batname[0];

					tempcaption = gpszFileOpCaption ;
					gpszFileOpCaption = szErrorCaption ;
					action = DOSErrorBox(szErrCreatTmpFile, ret,
																		HELP_ERRCREATEDEST) ;
					gpszFileOpCaption = tempcaption ;
				}
			}
		} while (action == ACT_RETRY) ;

		if (action != ACT_OK)
			return(FALSE) ;

		_dos_write(fhandle,BatchFile,myfstrlen(BatchFile),&size);
		_dos_close(fhandle);
		FreeWorkFar(BatchFile);
		if(dolaunch)
		{
			if (startdir && (startdir[0]))
				UnixChdir(startdir) ;
			LaunchProgram(commandcom,commandstring,magiccookie);
		}
		else
		{
			if(gSwitchingEnabled)
			{
				AddTask(commandcom,commandstring,gNext_Task_Name,info,magiccookie);
			}
		}
   }
   else
   {
		/* Launch command.com!! -- We don't want  to prompt user on
		* exiting command.com, so set global wait state to disabled -- Will be
		* written out in DOSSHELL.INI file!
		*/
	get_comspec(commandcom);

		Set_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE,TK_DISABLED);

		/* place the user in correct startup directory before launching his prog */
		if (startdir && (startdir[0]))
			UnixChdir(startdir) ;
	Set_Task_Name(szCommand); 
		Set_Task_Info(TK_NOTHING);
		LaunchProgram(commandcom,"",0);
   }
	return(TRUE);
}

/* User is placed in startdir if startdir is non-NULL, else the start up
 * directory has already been set by the caller
 */
extern WORD gEditBoxModifier;
extern ListBoxData TaskList;

VOID DoCommand(char far *commands, char *startdir)
{
		/* hack for Ericst; don't actually launch if the shift key
       * is held down..
       */
		if((gSwitchingEnabled) && (gEditBoxModifier & KK_SHIFT))
		{
			SetupCommand(commands, startdir, FALSE,gNext_Task_Info);
		   gNext_Task_Info=TK_NOTHING; //be sure
			InsertListItem(&TaskList,0);
		}
		else
			SetupCommand(commands, startdir, TRUE ,TK_NOTHING);

}

VOID DoUserCommand(char *startdir)
{
	DoCommand(userCommand, startdir);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\confirm.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <assert.h>

#include <mconfirm.hs>
#include <mconfirm.sdm>

#include <dconfirm.hs>
#include <dconfirm.sdm>

#include <rconfirm.hs>
#include <rconfirm.sdm>

extern VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen) ;
extern char * PASCAL MySetMessageText(TMC tmc, char *message, int nWid) ;
extern void cdecl FormStringWithoutPlaceHolders(char far *dest, char far *src, ...) ;

extern BYTE gManipType;

/* Used by fn DeleteConfirmationDialog() */
char *gpszDeleteConfirmCaption ;        // Delete Directory/File Confirmation
char *gpszDeleteConfirmMsg ;            // message text

/* Used by fn ReplaceConfirmationDialog() */
char *gReplaceSrcPath ;
char *gReplaceDestPath ;
char *gpszReplaceSrcInfo ;
char *gpszReplaceDestInfo ;
BOOL gfDestIsReadOnly ;

/* Used by fn MouseConfirmationDialog() */
char *gpszMouseConfirmMsg ;     // message text
char *gConfirmationPath ;               // dest for copy/move by direct manipulating

/* Dialog procedure for the MouseConfirmation Dialog for Move/Copy/Launch       */
/* gCurrentTMC is being set in this function so that "Help" can be                      */
/* provided when user hits "F1"                                                                                                                 */
BOOL FAR PASCAL FDlgmouseconfirm(WORD dlm, TMC tmc,
											WORD wNew, WORD wOld, WORD wParam)
{
	PWND lwind ;
	int  itemwidth ;
	char CompressedPath[60] ;
	char Message[256] ;
	char *pszTempMsg ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	/* Actually help is the only case to be handled here. Otherwise,
	   we just dismiss the dialog and caller looks at the tmc value on exit */
	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK, szMouseConfirmCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);

		/* we assume that all three 3 tmc text's have same width, so we just
		 * calculate the width of the first one and use it for all three.
		 */
		lwind = PwndOfTmc(tmcmouseconfirmMsg1);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;

		/* If it is not a Launch (Run) operation, we need to put in the
		 * destination path (directory) after compressing it.
		 */
		if (gManipType != MANIP_RUN)
		{
			/* use -2 so that we can put in the '?' char and NULL. INTERNATIONALIZE!!!
			 * here if that language does not have a '?' or has a longer
			 * question mark sequence.
			 */
			MakeDirNameFit(gConfirmationPath, NULL, CompressedPath, itemwidth-2) ;
			FormStringWithoutPlaceHolders(Message, gpszMouseConfirmMsg,
					(char far *)CompressedPath) ;
			gpszMouseConfirmMsg = Message ;
		}

		/* It is OK even if message is not wide enuf for 2/3 lines. The
		 * remaining lines will remain blank.
		 */
		pszTempMsg = MySetMessageText(tmcmouseconfirmMsg1,
														gpszMouseConfirmMsg, itemwidth) ;
		pszTempMsg = MySetMessageText(tmcmouseconfirmMsg2,
														pszTempMsg, itemwidth) ;

		MySetMessageText(tmcmouseconfirmMsg3, pszTempMsg, itemwidth) ;

		gCurrentTMC = tmcOK;
	}
	else
	if (dlm == dlmSetFocus)
	{
	    gCurrentTMC = tmc;
	}

	return TRUE ;
} /* FDlgmouseconfirm */


/* This function puts up the mouse confirmation dialog before performing
 * a move or copy or launch operation.
 *
 * INPUT:
 *              message:        the message to be displayed in the dialog box.
 *              dpath:  the destination path to which copy/move is done.
 *
 * OUTPUT: boolean to indicate whether user chose YES or not!
 */
int MouseConfirmationDialog(char *message, char *dpath)
{
	HCABmouseconfirm hcab ;
	TMC tmc ;

	hcab = HcabAlloc(cabiCABmouseconfirm) ;

	/* ZZZZZ Do I put up an outofmemory dialog now?? */
	if (!hcab)
	{
		OutOfMemory() ;
		return FALSE ;
	}
	InitCab(hcab, cabiCABmouseconfirm) ;

	SzToCab(hcab, szYesButton, Iag(CABmouseconfirm, pszmouseconfirmYB));
	SzToCab(hcab, szNoButton, Iag(CABmouseconfirm, pszmouseconfirmNB));

	gpszMouseConfirmMsg = message ;

	/* Store the destination path pointer in this variable. Will be used
	 * by the fn FDlgMouseConfirm() as we can't pass in params to it.
	 */
	gConfirmationPath = dpath ;

	tmc = MyTmcDoDlg(&dlgmouseconfirm, hcab) ;

	FreeCab(hcab) ;

	return (tmc == tmcOK) ;
} /* MouseConfirmationDialog */

/* Dialog procedure for the DeleteConfirmation Dialog for Delete directory      */
/* or Delete file.                                                                                                                                                      */
/* gCurrentTMC is being set in this function so that "Help" can be                      */
/* provided when user hits "F1"                                                                                                                 */
BOOL FAR PASCAL FDlgdeleteconfirm(WORD dlm, TMC tmc,
											WORD wNew, WORD wOld, WORD wParam)
{
	PWND lwind ;
	int  itemwidth ;
	char CompressedPath[60] ;
	char FormattedText[70] ; // this has the  '?' character or whatever!
	int nlen ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	/* Actually help is the only case to be handled here. Otherwise,
	   we just dismiss the dialog and caller looks at the tmc value on exit */
	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK, gpszDeleteConfirmCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcdeleteconfirmNo);
		SetUpButtonForGraphics(tmcCancel);

		Shell_SetTmcText(tmcdeleteconfirmMsg, gpszDeleteConfirmMsg) ;

		lwind = PwndOfTmc(tmcdeleteconfirmPath);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;

		/* get the length of the message less 2 for the %1 in the message */
		nlen = strlen(szDeleteConfirm) - 2 ;

		MakeDirNameFit(gConfirmationPath, NULL, CompressedPath,
																	itemwidth-nlen) ;
		FormStringWithoutPlaceHolders(FormattedText, szDeleteConfirm,
																(char far *)CompressedPath) ; 

		Shell_SetTmcText(tmcdeleteconfirmPath, FormattedText) ;

		gCurrentTMC = tmcOK;
	}
	else
	if (dlm == dlmSetFocus)
	{
	    gCurrentTMC = tmc;
	}

	return TRUE ;
} /* FDlgdeleteconfirm */


/* This function puts up the delete confirmation dialog before performing
 * a delete operation (of file/directory)
 *
 * INPUT:
 *              dpath:          the full path of the file/dir to be deleted
 *              fIsDelFile:     Whether is a Delete File or Delete Directory dialog
 *              Message:                Any message to be put up in the dialog
 *
 * OUTPUT: 
 *              ACT_FORCE, if the user selected the YES button.
 *              ACT_SKIP, if the user selected the NO button.
 *              ACT_CANCEL, if the user selected the CANCEL button.
 */
int DeleteConfirmationDialog(char *dpath, BOOL fIsDelFile, char *Message)
{
	HCABdeleteconfirm hcab ;
	TMC tmc ;
	int ret ;

	hcab = HcabAlloc(cabiCABdeleteconfirm) ;

	/* ZZZZZ DO I put up an outofmemory dialog now?? */
	if (!hcab)
	{
		OutOfMemory() ;
		return FALSE ;
	}
	InitCab(hcab, cabiCABdeleteconfirm) ;

	SzToCab(hcab, szYesButton, Iag(CABdeleteconfirm, pszdeleteconfirmYB));
	SzToCab(hcab, szNoButton, Iag(CABdeleteconfirm, pszdeleteconfirmNB));
	SzToCab(hcab, szCancelButton, Iag(CABdeleteconfirm, pszdeleteconfirmCB));

	/* Store the deleted path pointer in this variable. Will be used
	 * by the fn FDlgdeleteconfirm() as we can't pass in params to it.
	 */

	gConfirmationPath = dpath ;

	gpszDeleteConfirmMsg = Message ;
	gpszDeleteConfirmCaption = fIsDelFile ? szDelFileConfirmCaption :
														 szDelDirConfirmCaption ;

	tmc = MyTmcDoDlg(&dlgdeleteconfirm, hcab) ;

	FreeCab(hcab) ;

	switch (tmc)
	{
		case tmcOK:
			ret = ACT_FORCE ;
			break ;

		case tmcdeleteconfirmNo:
			ret = ACT_SKIP ;
			break ;
		
		case tmcCancel:
		default:
			ret = ACT_CANCEL ;
	} /* switch */

	return ret ;
} /* DeleteConfirmationDialog */


/* Dialog procedure for the ReplaceConfirmation Dialog for file copy/move       */
/* gCurrentTMC is being set in this function so that "Help" can be                      */
/* provided when user hits "F1"                                                                                                                 */
BOOL FAR PASCAL FDlgreplaceconfirm(WORD dlm, TMC tmc,
											WORD wNew, WORD wOld, WORD wParam)
{
	PWND lwind ;
	int  itemwidth ;
	char Temp[70] ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	/* Actually help is the only case to be handled here. Otherwise,
	   we just dismiss the dialog and caller looks at the tmc value on exit */
	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK, szReplaceFileConfirmCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcreplaceconfirmNo);
		SetUpButtonForGraphics(tmcCancel);

		FormStringWithoutPlaceHolders(Temp, szReplaceFile, (char far *)
								(gfDestIsReadOnly ? szReadOnlyInParens : szBlank) ) ;
		Shell_SetTmcText(tmcReplaceFile, Temp) ;

		lwind = PwndOfTmc(tmcReplacePath);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;

		/* Make Temp hold the CompressedReplacePath */
		MakeDirNameFit(gReplaceDestPath, NULL, Temp, itemwidth) ;               
		Shell_SetTmcText(tmcReplacePath, Temp) ;

		Shell_SetTmcText(tmcReplaceInfo, gpszReplaceDestInfo) ;
	
		Shell_SetTmcText(tmcWithFile, szWithFile) ;
		lwind = PwndOfTmc(tmcWithPath);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;
		/* Make Temp hold the CompressedWithPath */
		MakeDirNameFit(gReplaceSrcPath, NULL, Temp, itemwidth) ;                
		Shell_SetTmcText(tmcWithPath, Temp) ;

		Shell_SetTmcText(tmcWithInfo, gpszReplaceSrcInfo) ;

		gCurrentTMC = tmcOK;
	}
	else
	if (dlm == dlmSetFocus)
	{
	    gCurrentTMC = tmc;
	}

	return TRUE ;
} /* FDlgreplaceconfirm */

#define MAXSIZESIZE 30


/* This function puts up the replace confirmation dialog before performing
 * a file replace on move/copy file operation.
 *
 * INPUT:
 *
 * OUTPUT: 
 *              ACT_FORCE, if the user selected the YES button.
 *              ACT_SKIP, if the user selected the NO button.
 *              ACT_CANCEL, if the user selected the CANCEL button.
 */
int ReplaceConfirmationDialog(char *srcpath, char *destpath, PENTRY srcnode,
															struct find_t destfindinfo)
{
	HCABreplaceconfirm hcab ;
	TMC tmc ;
	int ret ;
	char szSrcInfo[65] ;
	char szDestInfo[65] ;
	int i, j ;
	char szSize[MAXSIZESIZE] ;

	hcab = HcabAlloc(cabiCABreplaceconfirm) ;

	/* ZZZZZ DO I put up an outofmemory dialog now?? */
	if (!hcab)
	{
		OutOfMemory() ;
		return FALSE ;
	}

	gfDestIsReadOnly = destfindinfo.attrib & _A_RDONLY ;

	/* Set the following globals so that the dialog procedure can access these
	 * values to display in the dialog box.
	 */
	gReplaceSrcPath = srcpath ;
	gReplaceDestPath = destpath ;

   Get_Date_and_Time_Strings(srcnode->dtlx.dt.date, 0, szSrcInfo, NULL, 0);
   i = 8;
	szSrcInfo[i++] = (char) ' ' ;
	szSrcInfo[i++] = (char) ' ' ;
	szSrcInfo[i++] = (char) LBRACKET_CHAR ;

	/* pad with blanks to start with -- used by fn CopyNumberForTextOut()! */
	for (j = 0 ; j < MAXSIZESIZE ; j++)
		szSize[j] = ' ' ;
 
	CopyNumberForTextOut(szSize+MAXSIZESIZE-1, srcnode->x.f.size, FALSE) ;

	/* locate the start of the string that holds the formatted number! */
	j = 0 ;
	while (szSize[j] == ' ')
		j++ ;

	/* copy the formatted number string into our Info String */
	for( ; j < MAXSIZESIZE ; )
		szSrcInfo[i++] = szSize[j++] ;

	szSrcInfo[i++] = (char) ' ' ;   

	/* Copy the word bytes into our Info string */
	strcpy(szSrcInfo+i, szBytes) ;
	i += strlen(szBytes) ;

	szSrcInfo[i++] = (char) RBRACKET_CHAR ;
	szSrcInfo[i] = '\0' ;

	Get_Date_and_Time_Strings(destfindinfo.wr_date, 0, szDestInfo, NULL, 0);
	i = 8 ;
	szDestInfo[i++] = (char) ' ' ;
	szDestInfo[i++] = (char) ' ' ;
	szDestInfo[i++] = (char) LBRACKET_CHAR ;

	CopyNumberForTextOut(szSize+MAXSIZESIZE-1, destfindinfo.size, TRUE) ;

	/* locate the start of the string that holds the formatted number! */
	j = 0 ;
	while (szSize[j] == ' ')
		j++ ;

	/* copy the formatted number string into our Info String */
	for( ; j < MAXSIZESIZE ; )
		szDestInfo[i++] = szSize[j++] ;

	szDestInfo[i++] = (char) ' ' ;  

	/* Copy the word bytes into our Info string */
	strcpy(szDestInfo+i, szBytes) ;
	i += strlen(szBytes) ;

	szDestInfo[i++] = (char) RBRACKET_CHAR ;
	szDestInfo[i] = '\0' ;

	gpszReplaceSrcInfo = szSrcInfo;
	gpszReplaceDestInfo = szDestInfo;

	InitCab(hcab, cabiCABreplaceconfirm) ;

	SzToCab(hcab, szYesButton, Iag(CABreplaceconfirm, pszreplaceconfirmYB));
	SzToCab(hcab, szNoButton, Iag(CABreplaceconfirm, pszreplaceconfirmNB));
	SzToCab(hcab, szCancelButton, Iag(CABreplaceconfirm, pszreplaceconfirmCB));


	tmc = MyTmcDoDlg(&dlgreplaceconfirm, hcab) ;

	FreeCab(hcab) ;

	switch (tmc)
	{
		case tmcOK:
			ret = ACT_FORCE ;
			break ;

		case tmcreplaceconfirmNo:
			ret = ACT_SKIP ;
			break ;
		
		case tmcCancel:
		default:
			ret = ACT_CANCEL ;
	} /* switch */

	return ret ;
} /* ReplaceConfirmationDialog */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\delprog.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <prot.h>
#include <groups.h>
#include <icons.h>

WORD GetIthGroupOrProgramIndex(TOKEN group, int isz);
int Num_Items_In_Group(TOKEN token);
VOID DeleteTask(void);
BOOL FDelItemDialog(char *theMessage);

extern struct ListBoxData ProgramList;
extern TOKEN gGroupLevel;
extern BOOL gTaskListEnabled;
extern ListBoxData TaskList;

static VOID NEAR PASCAL DoDelete(void)
{
    int element;
    TOKEN group;
    BOOL doorpresent;

    if(gGroupLevel == TK_PROGRAMSTARTER) {
        group = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
        doorpresent = FALSE;
    } else {
        group = gGroupLevel;
        doorpresent = TRUE;
    }

    element = Get_List_Focus(&ProgramList) - (int)doorpresent;
    if(element >= 0) {
        element = GetIthGroupOrProgramIndex(group, element);
        Delete_Ith_Element(group, element);
    }
    InsertListItem(&ProgramList, 0);
    InitIconCache();
}

VOID FAR DeleteProgram(void)
{
    TOKEN token, token2;
    BOOL doorpresent;
    int i;
    char tstr[256];

    if(gTaskListEnabled && TaskList.hasglobalfocus) {
        DeleteTask();
    } else { /* Confirm if user wants to delete the item */
        if(gGroupLevel == TK_PROGRAMSTARTER) {
            token = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
            doorpresent = FALSE;
        } else {
            token = gGroupLevel;
            doorpresent = TRUE;
        }
        if(token<0 || (i=Get_List_Focus(&ProgramList)-doorpresent)<0 ||
 				(Num_Items_In_Group(token) <= 0 ) ) {
            Shell_Beep();
            return;
        }

        token2 = Get_Ith_Element(token, GetIthGroupOrProgramIndex(token, i));
        token = Get_Symbol_Value(Token_To_Symbol(token2));
        if(Get_Symbol_Type(Token_To_Symbol(token2))==TK_GROUP &&
                Num_Items_In_Group(token)) {
            ShellMessageBox(szDelGroupTitle, szDelGroupLine1);
            return;
        }

        if((token = Get_KeyWord_Assignment(token, TK_PASSWORD)) > 0)
            strfcpy(tstr, Get_Token_Identifier(token));
        else
            tstr[0] = 0;

        if(FDelItemDialog(*tstr ? szPasswordProtected : NullString)) {
            DoDelete();
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\critical.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;;; This is the critical error handler.
;;; It is really dumb--all critical errors are Failed
;;; It is up to the Int21 caller to figure out what went wrong.

?WIN = 0		;Not windows;
?PLM =	  1		;DO use PL/M calling conventions

include cmacros.inc

extrn ErrorCrit:BYTE
sBegin code
    assumes cs, code
    assumes ds, DGROUP

FailCriticalError proc far
    push    ax
    push    ds
    mov     ax,DGROUP
    mov     ds,ax
    mov     ax,di
    mov     ErrorCrit,al	;;; save error code
    pop     ds
    pop     ax
    mov     al,3		;;; fail the int21 call
				;;; the caller is expected to look at
				;;; ErrorCrit
    iret
FailCriticalError endp

cProc  SetCriticalsToFail, PUBLIC , <si,di,ds,es>
cBegin SetCriticalsToFail
    ;;;     ds:dx must point to the critical error handler for set vector
    mov     ax,cs
    mov     ds,ax
    mov     dx,offset cs:FailCriticalError
    mov     ax,2524h
    int     21h
cEnd SetCriticalsToFail
sEnd code

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\copy.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   copy.c - "copy destination" dlg box fns; file operation dispatcher
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  7/21/89   t-jeffro  created file
**  7/31/89   t-jeffro  Now supports 2-tree display.
**      8/09/89   t-jeffro      uses generic error dialogue box
*/
#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <text.h>

#include <copy.hs>                              /* files for copy destination dialogue */
#include <copy.sdm>                             /* ... */

#include <delfiles.hs>                  /* files to verify selction of deleted files*/
#include <delfiles.sdm>                 /* ... */

extern VOID ListBoxPath(treehdr far *tree,PENTRY node,int whichtree) ;
extern void ForceSortDirectory(PTREE tree, PENTRY dir) ;
extern void SortDirectory(PTREE tree, PENTRY dir) ;
extern BOOL FPerformDirOperation(void) ;
extern BOOL FPerformOpOnDirFilesAlone(void) ;
extern void HandleEmptyFileListBoxes(void) ;
extern  unsigned int CountFilesToOperateOn(void );
extern void MarkFilesBeforeFileOp(void) ;
extern BOOL DeselectUnMatchedFiles(PTREE tree);

/* Note that unless we are in "DoFileOp" this should be NULL - default */
PENTRY gNextFileNode = NULL ;                   /* next node using snext in DoFileOp */

char *gpszDestPath ; // Destination path to perform file copy/move to.

/* In debug mode, with no loader the compiler chokes on this file!!! */
// #if 0
#ifndef NOLOADER
#include <prot.h>
#include <errno.h>
#else
extern void FormSelFileList(char *files, unsigned buflen) ;
extern  int MoveFile(struct th_t far *tree,struct fi_t far *node,char *path,int count,int total,int verify);
extern  int CopyFile(struct th_t far *tree,struct fi_t far *node,char *path,int count,int total,int verify);
extern  int DeleteFile(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  int ChangeAttributes(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  int PrintFile(struct th_t far *tree,struct fi_t far *node,char *placeholder,int count,int total,int verify);
extern  int ViewFile(struct th_t far *tree,struct fi_t far *node,char *unused1,int unused2,int unused3,int unused4);
extern int cdecl chdir(char *path);
extern  void DoFileOp(int type,char *path);
extern  int GetDestPath(char *path);
extern  int PromptAndCreateDir(struct th_t far *tree,struct fi_t far *parent);
extern  void InsertListItem(struct ListBoxData *TestList,unsigned short isz);
extern  void FocusLineChange(struct ListBoxData *TestList,int amt);
extern void CollapseDirVisibility(PTREE tree, PENTRY dir) ;
extern void ExpandDirVisibility(PTREE tree, PENTRY dir, BOOL fAllLevels) ;
extern  unsigned int GetIndexVisibleDir(struct fi_t far *dir,struct th_t far *tree);
extern  int Tree2Path(struct th_t far *tree,struct fi_t far *node,char *str, int *plength);
extern  void pascal far OutOfMemory(void );
extern TMC      MyTmcDoDlg(VOID *pdlg, HCAB hcab) ;
extern  void SetUpDialog(unsigned short tmcchild,char *title);
extern  void SetUpButtonForGraphics(unsigned short tmc);
extern  void SetUpEditBox(unsigned short tmc, BOOL fRealOrNot, WORD maxcount, BOOL fHasInitialFocus);
VOID FAR PASCAL Help(WORD hem, WORD hid,VOID *pv,WORD kk);
extern  int FindLastComponent(char *path);
extern  char *DOSErrorMsg(int errcode,int *box);
extern  int DOSErrorBox(char *statusline,unsigned short err,unsigned int helpid);
extern  struct th_t far *FindTree(char *path, BYTE *driveind);
extern  int RenameFile(struct th_t far *tree,struct fi_t far *node,char *prognew,int count,int total,int ask);
extern  void com1(char *str);
extern  void com1i(int i);
extern  int FindAndDelDirectory(void );
extern  unsigned int GetTreeSelectedInfo(struct th_t far *tree,unsigned long far *psize);
extern  void FileMgrStatusBar(struct th_t far *tree,struct fi_t far *node);
extern  struct fi_t far *GetNthVisibleDir(struct th_t far *tree,int count);
extern  int Internal2Normal(char far *dest,char far *src);
extern  void DeselectTree(struct th_t far *tree);
BOOL TakeDownStatusMessage(int count, int total) ;
extern  int CompactifyTree(struct th_t far *tree,int sel);
#define ENOENT 2
#endif

BOOL DestIsDir;

VOID FAR DoCopyFiles(void)
{
	char path[MAX_PATH+1];                          // destination path

	gpszFileOpCaption = szCopyFileCaption ;
	((PDLG)&dlgCopyFiles)->hid = hidCOPY;

	if (GetDestPath(path))
		DoFileOp(OP_COPY, path);
}

VOID FAR DoMoveFiles(void)
{
	char path[MAX_PATH+1];                          // destination path

	gpszFileOpCaption = szMoveFileCaption ;
	((PDLG)&dlgCopyFiles)->hid = hidMOVE;

	if (GetDestPath(path))
		DoFileOp(OP_MOVE, path);
}

VOID FAR DoRenameFiles(void)
{
	/* Rename can be Rename Directory or Rename File. By default we
	   set it to RenameFile. It will be set by Rename Directory guy
	   if that happens to be the operation! */

	gpszFileOpCaption = szRenameFileCaption ;

	DoFileOp(OP_RENAME, NULL);
}

extern BOOL DisplayedFilesOk(void) ;   /* actually a forward declarartion */
extern int AssociateBox(PTREE tree,PENTRY node,char *path, int count, int total, BOOL verify);

VOID FAR DoDelFiles(void)
{
	/* Delete can be Delete Directory or Delete File. By default we
	   set it to DeleteFile. It will be set by Delete Directory guy
	   if that happens to be the operation! */

	gpszFileOpCaption = szDelFileCaption ;
	DoFileOp(OP_DELETE, NULL);                 // NULL is unused arg
}

VOID FAR DoViewFile(void)
{
	gpszFileOpCaption = szViewFileCaption ;
	DoFileOp(OP_VIEW, NULL);
}

VOID FAR DoChangeAttributes(void)
{
	gpszFileOpCaption = szChangeFileCaption ;
	DoFileOp(OP_CHANGE, NULL);
}

VOID FAR DoPrintFiles(void)
{
	gpszFileOpCaption = szPrintFileCaption ;
	DoFileOp(OP_PRINT, NULL);
}

VOID FAR DoCreateDirectory(void)
{
	PTREE tree ;
	PENTRY parent ;
	int dirlinefocus, dirlineother ;

	tree = listinfo[glob.FocusBox].tree ;
	parent = listinfo[glob.FocusBox].files ;

	dirlinefocus = glob.lineselected[glob.FocusBox] ;
	dirlineother = glob.lineselected[1-glob.FocusBox] ;

	gpszFileOpCaption = szCreateDirCaption ;

	if (PromptAndCreateDir(tree, parent))
	{
		/* Directory succesfully created */
		if (glob.TreeMode != TR_SYSTEM)
		{
			InsertListItem(&TreeList[glob.FocusBox], 0) ;
			if ( (glob.TreeMode == TR_DOUBLE) && 
						(listinfo[1-glob.FocusBox].tree == tree) )
			{
				/* Because, we have created a new dir, did the previously
				 * selected directory move down by 1 line? If so move the
				 * focus back to it.
				 */
				if (dirlineother > dirlinefocus)
					FocusLineChange(&TreeList[1-glob.FocusBox], +1) ;

				InsertListItem(&TreeList[1-glob.FocusBox], 0) ;
			}
		}

	}
} /* DoCreateDirectory */

void DoExpand1Level(void)
{
	PTREE tree ;
	PENTRY dir ;

	tree = listinfo[glob.FocusBox].tree ;
	dir = listinfo[glob.FocusBox].files ;

	/* ZZZZZZ */
	CollapseDirVisibility(tree, dir) ;
	ExpandDirVisibility(tree, dir, FALSE) ;

	InsertListItem(&TreeList[glob.FocusBox], glob.lineselected[glob.FocusBox]);

	/* Update the other listbox also correctly */
	if ((glob.TreeMode == TR_DOUBLE) && (tree == listinfo[1-glob.FocusBox].tree))
		InsertListItem(&TreeList[1-glob.FocusBox], 0);

} /* DoExpand1Level */

void DoExpandBranch(void)
{
	PTREE tree ;
	PENTRY dir ;

	tree = listinfo[glob.FocusBox].tree ;
	dir = listinfo[glob.FocusBox].files ;

	/* ZZZZZZ */
	CollapseDirVisibility(tree, dir) ;
	ExpandDirVisibility(tree, dir, TRUE) ;
	InsertListItem(&TreeList[glob.FocusBox], glob.lineselected[glob.FocusBox]);

	/* Update the other listbox also correctly */
	if ((glob.TreeMode == TR_DOUBLE) && (tree == listinfo[1-glob.FocusBox].tree))
		InsertListItem(&TreeList[1-glob.FocusBox], 0);

} /* DoExpandBranch */
	
void DoExpandAll(void)
{
	PTREE tree ;

	tree = listinfo[glob.FocusBox].tree ;

	/* ZZZZZZ */
	CollapseDirVisibility(tree, NULL) ;
	ExpandDirVisibility(tree, NULL, TRUE) ;
	glob.lineselected[glob.FocusBox] =
					GetIndexVisibleDir(listinfo[glob.FocusBox].files,
									   listinfo[glob.FocusBox].tree);
	InsertListItem(&TreeList[glob.FocusBox], 0);

	/* Update the other listbox also correctly */
	if ((glob.TreeMode == TR_DOUBLE) && (tree == listinfo[1-glob.FocusBox].tree))
		InsertListItem(&TreeList[1-glob.FocusBox], 0);

} /* DoExpandAll */

void  DoCollapse(void)
{
	PTREE tree ;
	PENTRY dir ;

	tree = listinfo[glob.FocusBox].tree ;
	dir = listinfo[glob.FocusBox].files ;

	CollapseDirVisibility(tree, dir) ;
	InsertListItem(&TreeList[glob.FocusBox], glob.lineselected[glob.FocusBox]);

	/* Update the other listbox also correctly */
	if ((glob.TreeMode == TR_DOUBLE) && (tree == listinfo[1-glob.FocusBox].tree))
		InsertListItem(&TreeList[1-glob.FocusBox], 0);

}

/* The following is the number of characters that will be displayed in
   the dialog box that requests a destination path name to copy/move files */

#define MAXFILELIST 256

/****   GetDestPath - get destination path for copy or move
**
**      ENTRY
**              path - place to store path
**      EXIT
**              TRUE if successful, else FALSE.
*/
BOOL GetDestPath(char *path)
{
	HCABCopyFiles hcab;                             // needed for dialogue box
	TMC tmc;                                                // return value of dialogue box
	BOOL ret;                                               // return value
	int dummylen ;

	/* space for MAXFILELIST chars + NULL + an extra name + BLANK */
	char FileList[MAXFILELIST+1+(NAMELEN+EXTLEN+1)+1] ;
	char DefaultPath[MAX_PATH+1] ;

	// Init dlg box with empty string.
	hcab = HcabAlloc(cabiCABCopyFiles);
	if (!hcab)
	{
		OutOfMemory() ;
		return FALSE;
	}
	InitCab(hcab, cabiCABCopyFiles);
	FormSelFileList(FileList, MAXFILELIST) ;

	Tree2Path(listinfo[glob.FocusBox].tree, listinfo[glob.FocusBox].files, 
								DefaultPath, &dummylen) ;
	SzToCab(hcab, FileList, Iag(CABCopyFiles, szCopyFileList));
	SzToCab(hcab, DefaultPath, Iag(CABCopyFiles, szCopyDest));
	
	SzToCab(hcab, szEnterButton, Iag(CABCopyFiles, pszcopyEB));
	SzToCab(hcab, szCancelButton, Iag(CABCopyFiles, pszcopyCB));
	SzToCab(hcab, szHelpButton, Iag(CABCopyFiles, pszcopyHB));

	/* This is the location where the dialog call below will place the
	 * DestPath (absolute path).
	 */
	gpszDestPath = path ;

	// Run dlg box.
	tmc = MyTmcDoDlg(&dlgCopyFiles, hcab);
	if (tmc == tmcOK)
	{
		// SzFromCab(hcab, path, MAX_PATH, Iag(CABCopyFiles, szCopyDest));
		/* The path from dialog box has been pre-processed and converted to
		 * an absolute path including the drive letter in gpszDestPath.
		 * It will also be in upper case.
		 */
		// strupr(gpszDestPath);
		ret = TRUE;
	} else
		ret = FALSE;
	FreeCab(hcab);
	return ret;
} /* proc GetDestPath */

/****   FDlgCopyFiles - FDlg procedure to get destination path
**          The dialogue box handled by this procedure asks for the
**      destination path of a copy.
**
**      ENTRY
**              see SDM API v.2.0 doc's
**      EXIT
**              see SDM API doc's
**      WARNING:
**              The verification of the path should be done by looking at the disk,
**      not by examining the in-memory tree, because we need to be able to copy
**      and move files to disks whose trees are not currently in memory.
**      EFFECTS:
**
*/
BOOL FAR PASCAL FDlgCopyFiles(WORD dlm, TMC tmc,
									WORD wNew, WORD wOld, WORD wParam)
{
	int result;                                                             // dos call return value
	BOOL ret;                                                               // fn return value
	int count;                                                              // number of selected files
	char dlg_path[1+MAX_PATH];                              // full path of file
	unsigned attr;                                                  // file's attributes
	int temp ;
	int len ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch (dlm)
	{
	case dlmSetFocus:
	    gCurrentTMC = tmc;
		break ;

	case dlmInit:
		SetUpDialog(tmcOK,gpszFileOpCaption);

		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmccopyhelp);

		/* The user should not be able to edit this */
		SetUpEditBox(tmcCopyFileList, FALSE,255, FALSE);

		SetUpEditBox(tmcCopyDest, TRUE, USERS_MAX_TYPEABLE_PATH, TRUE);

		SetDefaultTmc(tmcOK);
		SetFocusTmc(tmcCopyDest);
		break ;

	case dlmClick:
		 if(tmc == tmccopyhelp)
			Help(hemDialog, ((PDLG)&dlgCopyFiles)->hid,NULL,0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;

	case dlmTerm:
		if (tmc == tmcOK)
		{
			ret = FALSE ; /* default value */

			/* On exit, verify path. */
			GetTmcText(tmcCopyDest, dlg_path, MAX_PATH);

			Convert2AbsolutePath(gpszDestPath, dlg_path) ;

			if (gpszDestPath[1] != ':')                                     // no drive specifier
			{
				Shell_SetTmcText(tmcCopyMsg, szNeedDrive);
			} else if ((len = strlen(gpszDestPath)) < 3)            // not long enough to be valid
			{
				Shell_SetTmcText(tmcCopyMsg, szNeedPath);
			} else if (gpszDestPath[3] == EOS)                      // root path
			{
				if (chdir(gpszDestPath))
				{
					Shell_SetTmcText(tmcCopyMsg, szPathNotFound);
				} else
				{
					DestIsDir = TRUE;
					ret = TRUE;
				}
			}
			// If it is not a root path, we should not have a '\\' at the end!
#ifdef DBCS
			else if (gpszDestPath[len-1] == '\\' && !CheckDBCSTailByte(gpszDestPath,&gpszDestPath[len-1]))
#else
			else if (gpszDestPath[len-1] == '\\')
#endif
			{
				Shell_SetTmcText(tmcCopyMsg, szPathNotFound) ; 
			}
			else            // something else
			{
				result = _dos_getfileattr(gpszDestPath, &attr);
				if (!result)
				{
					/* Determine copy type. */
					if (attr & _A_SUBDIR)
					{
						DestIsDir = TRUE;
						ret = TRUE;
					} else
					{
						DestIsDir = FALSE;
// We don't check for ReadOnly anymore, as we have ReplaceConfirmationDialog
// that would be always put up even if we had confirmation turned off!
#if 0
						if (attr & _A_RDONLY)
							Shell_SetTmcText(tmcCopyMsg, szReadOnly);
						else
#endif
							ret = TRUE;
					}
				} else if (result == ENOENT)            // file not found
				{
					char replaced_char ;

					/* Not found - try parent */
					temp = FindLastComponent(gpszDestPath) ;

					replaced_char = gpszDestPath[temp] ; // store char before replacing with NULL
					gpszDestPath[temp] = EOS;

					/* Is parent the ROOT dir? If so, _dos_getfileattr call
					 * fails on it. We avoid making this call as we know that
					 * the root is always a valid directory!
					 */
					if (gpszDestPath[temp-1] == PATHCHAR)
					{
						DestIsDir = FALSE;
						ret = TRUE ;
					}
					else
					{
						result = _dos_getfileattr(gpszDestPath, &attr);
						if (!result)
						{
							/* sz doesn't exist but its parent does, so he's
							 * asking to copy stuff to the *file* in sz.
							 */
							DestIsDir = FALSE;
							ret = TRUE;
						} 
						else
						{
							/* Parent wasn't found, either. He'd better try again. */
							Shell_SetTmcText(tmcCopyMsg, DOSErrorMsg(result,NULL));
						}
					}

					gpszDestPath[temp] = replaced_char ; // put back the replaced char
				} 
				else
					Shell_SetTmcText(tmcCopyMsg, DOSErrorMsg(result, NULL));
			}
	
			if (ret && !DestIsDir)
			{
				count = CountFilesToOperateOn() ;
	
				if (count > 1)
				{
					/* He's trying to copy > 1 file to a file; chastise him.
					*/
					Shell_SetTmcText(tmcCopyMsg, szTooManyFiles);
					ret = FALSE;
				}
			}
			return ret;
		}
	default:
		break ;
	} /* switch */

	return TRUE;
} /* proc FDlgCopyFiles */

/****   DoFileOp - Perform appropriate fileop
**              This fn handles copying and deletion of selected files.
**
**      ENTRY
**                      type - operation type: OP_COPY, OP_MOVE, or OP_DELETE.
**                      path - OP_DELETE: scratch buffer, must be (MAX_PATH+1) long
**                                 OP_MOVE/OP_COPY, one file selected: destination filespec
**                                 OP_MOVE/OP_COPY, multiple files: destination directory
**      EXIT
**                 none
**      WARNING
**          There must be room in 'path' to add another character for move or copy.
**      Each function which can be called through 'filefn' must have the given
**      number and type of formal parms.
**
**      NOTE
**              The file operation functions should return one of the following:
**                      ACT_OK          if the operation succeeded
**                      ACT_NOMEM       if the fn ran out of memory (be able to retry)
**                      ACT_SKIP        if user chose "Skip file & continue" from error dbox
**                      ACT_CANCEL      if the entire operation should be aborted.
**              Note that ACT_FORCE should not be returned; coerce it to ACT_OK.
*/
VOID DoFileOp(int type, char *path)
{
	int pathlen;                                                    // length of path w/o file
	treehdr far *tree;
	PENTRY node;                                                    // current source file
	int ret;                                                                        // return value of fileop.
	int total;                                                              // number of selected files
	int count;                                                              // number of processed files
	int i ;
	int (*filefn)(treehdr far *, PENTRY, char *, int, int, WORD) ;
	WORD flags;                                                             // flags to pass to fileop fn
	BOOL retry;

	total = CountFilesToOperateOn() ;

	if (FPerformDirOperation())
	{
		tree = listinfo[glob.FocusBox].tree ;
		node = listinfo[glob.FocusBox].files ;

		if (!node)
		{
			/* Can't rename/delete the ROOT dir. Actually, the menu should
			 * be disabled at this time.
			 */
			Beep() ;
			return ;
		}

		switch (type)
		{
			case OP_RENAME:

			/* The new path name should be found by Rename so ask is set
			   to TRUE (last param) and passed in path is NULL (param 3)! */

				gpszFileOpCaption = szRenameDirCaption ;

				/* We pass 0, 0 for count & total resp., to inform
					RenameFile that it is renaming a dir & not a file */
				if (RenameFile(tree, node, NULL, 0, 0, TRUE) == ACT_OK)
				{
					/* After renaming a directory the focus goes to the root.
					 * This is windows behaviour too.
					 */
					glob.lineselected[glob.FocusBox] = tree->SelLine = 0 ;
					listinfo[glob.FocusBox].files = NULL ;

					if (tree->Compacted)
					{
						ClobberDir(tree, node) ;
						LoadCompactDir(tree, NULL) ;
					}

					/* The directory that was renamed could have files selected
					 * in it -- We don't want these to remain so as the user
					 * will now be looking at the ROOT directory and can
					 * accidentally delete these other files.
					 */
					if (!glob.CrossDirSel)
						DeselectTree(tree) ;

				FileMgrStatusBar(tree, NULL ) ;
					ListBoxPath(tree, NULL, glob.FocusBox) ;
					Set_List_Focus(&TreeList[glob.FocusBox], 0);
					FocusLineChange(&TreeList[glob.FocusBox], 0);
					listinfo[glob.FocusBox].UpdateFiles = TRUE ;
					InsertListItem(&TreeList[glob.FocusBox], 0) ;

					/* If in Dual Tree mode and same tree in both listboxes,
					 * update that box too.
					 */
					if ( (glob.TreeMode == TR_DOUBLE) &&
						  (listinfo[0].tree == listinfo[1].tree) )
					{
						glob.lineselected[1-glob.FocusBox] = 0 ;
						listinfo[1-glob.FocusBox].files = NULL ;
						ListBoxPath(tree, NULL, 1-glob.FocusBox) ;

						Set_List_Focus(&TreeList[1-glob.FocusBox], 0    );
						FocusLineChange(&TreeList[1-glob.FocusBox], 0);
						listinfo[1-glob.FocusBox].UpdateFiles = TRUE ;
						
						InsertListItem(&TreeList[1-glob.FocusBox], 0) ;
					}
				}
				break ;

			case OP_DELETE:
		
				/* ZZZZZ No  error checks done!! */
				gpszFileOpCaption = szDelDirCaption ;
				ret = FindAndDelDirectory() ;
				/* The following is done on succesful deletion by callee!*/
				// InsertListItem(&TreeList[glob.FocusBox], 0) ;
				break ;

#ifndef NOCONSISTENCY
			default:
				printf("**** ???? req on non-root dir -> 0 selections\n") ;
				exit(0) ;
#endif
		} /* switch */
		return ;
	} /* Perform Directory Operation */

	switch (type)
	{
		case OP_DELETE :
			/* we are trying to delete a bunch of files. Make sure the list is
		 * what the user expects. If (total == 1), we don't have to do this.
			 * We can move to the Delete File operation promptly.
			 */
			if ( (total > 1) && (!DisplayedFilesOk()) )
				return ;

			filefn = DeleteFile;
			// flags = glob.VerifyDelete;
			// Fn DeleteFile() will look at glob.VerifyDelete if this is TRUE!
			flags = TRUE ;
			break ;

		case OP_MOVE:
		case OP_COPY:
		/* If we are copying a single file, path contains the full 
			destination. If more than one file, path contains only the
			destination directory. */
			pathlen = strlen(path);

			/* Append backslash to path if there isn't one already. */
			if (total > 1 || !chdir(path))
			{
#ifdef DBCS
				if (path[pathlen-1] != PATHCHAR ||
					CheckDBCSTailByte(path,&path[pathlen-1]))
#else
				if (path[pathlen-1] != PATHCHAR)
#endif
				{
					path[pathlen] = PATHCHAR;
					pathlen++;
					path[pathlen] = EOS;
				}
			}
			filefn = (type == OP_MOVE) ? MoveFile : CopyFile;
			flags = glob.VerifyOverwrite;
			break ;

		case OP_VIEW:
			filefn = ViewFile;
			flags = 0;                              // no flags to consider
			break;

		case OP_RENAME:
			filefn = RenameFile;
			flags = TRUE;                   // prompt for new filespec
			break;

		case OP_CHANGE:
			filefn = ChangeAttributes ;
			flags = 0 ; /* no flags to consider */
			break ;

		case OP_PRINT:
			filefn = PrintFile ;
			flags = 0 ; /* no flags to consider */
			break ;
		case OP_ASSOCIATE:
			filefn = AssociateBox;
			flags = 0;                              // no flags to consider
			break ;
	} /* switch */

	ret = ACT_OK;
	count = 0;

	tree = listinfo[glob.FocusBox].tree;
	node = tree->FirstFile;

	MarkFilesBeforeFileOp() ;

	for ( ; node && (ret != ACT_CANCEL) && (count < total) ; node = gNextFileNode )
	{
		/* The reason we do so here instead of at the end of the
			loop is because the file operations delete and add to snext
			in appropriate order. Also 'node' could be deleted */
		gNextFileNode = node->x.f.snext ;

		if (node->FILEOPMARKER)
		{
			/*  'count' of 'total' */
			count++ ;

			if ( (type == OP_COPY)  || (type == OP_MOVE) )
			{
					/* create the new destination path */
					if (DestIsDir)
					{
						Internal2Normal(path+pathlen, node->name);
					}
			}

			retry = TRUE;
			while (retry)
			{
				retry = FALSE;

				ret = (*filefn)(tree, node, path, count, total, flags);

				if (ret == ACT_NOMEM)
				{
					PTREE thetree;
					BOOL ok;

					/* Ran out of memory.  Compact a non-displayed tree
					** and try again.
					*/
					for (thetree=glob.drives; thetree && !retry; thetree=thetree->next)
					{
						ok = TRUE;
						if (listinfo[0].tree == thetree)
							ok = FALSE;
						if (glob.TreeMode == TR_DOUBLE)
							if (listinfo[1].tree == thetree)
								ok = FALSE;
						if (ok)
							retry = CompactifyTree(thetree, FALSE);
					}
				}
			} /* while (retry) */
		} /* node->FILEOPMARKER is TRUE */
	} /* for loop across all file nodes */

	/* Put it back to default state - fn HandleDeletesnext() looks at it */
	gNextFileNode = NULL ;

	/* Actually, the following boolean will be TRUE only if the user hit the*/
	/* CANCEL button before the file-operation could be attempted on the last*/
	/* of a bunch of selected files.                                                                                */
	if (gfStatusMsgUp)
	{
		/* If I call following fn with both arguments same, it will take        */
		/* down the status message box.                                                                         */
		TakeDownStatusMessage(total, total) ;
	}

	if (ret != ACT_CANCEL)
	{
		/* Everything finished ok, clear the selected lists. */
		// DeselectTree(listinfo[glob.FocusBox].tree) ;

		/* Operations were completed succesfully -- Toggle back to
		 * Implicit selection mode in case the user is in Explicit
		 * Selection Mode for these file listboxes.
		 */
		if (!FileList[glob.FocusBox].mode)
		{
			FileList[glob.FocusBox].mode = TRUE ;
			FileList[glob.FocusBox].ListProc(tmmImplicit, NULL,0,
										FileList[glob.FocusBox].tmc,0,0,0);
		}
	} /* everything finished OK */

	/* actually assumes that glob.MaxTree is either 0 or 1 */
	for (i = 0 ; i <= glob.MaxTree ; i++)
	{
		if ( (i != 1) || (listinfo[0].tree != listinfo[1].tree) )
			listinfo[i].tree->NumSel = GetTreeSelectedInfo(listinfo[i].tree,
												&(listinfo[i].tree->SizeSel)) ;

		/* In SYSTEM tree mode, files are already inserted in correct
		 * sorted order.
		 */
		if (glob.TreeMode != TR_SYSTEM)
			SortDirectory(listinfo[i].tree, listinfo[i].files) ;

		InsertListItem(&FileList[i], 0) ;
	}

	/* Send select message to focus item in file listbox if in Implicit
	 * selection mode and no files are selected now.
	 */
	if ( (FileList[glob.FocusBox].mode) && (CountFilesToOperateOn() == 0) )
	{
		ListKey(&FileList[glob.FocusBox], ' ', 0) ;
	}

	HandleEmptyFileListBoxes() ;

	/* Operations like File.ChangeAttributes with say "Display Hidden/System
	 * files" turned OFF can potentially leave some files selected that
	 * are visible to the user. Deselect these!
	 */
	if (DeselectUnMatchedFiles(listinfo[glob.FocusBox].tree))
	{
		listinfo[glob.FocusBox].UpdateFiles = TRUE ;
		if ( (glob.TreeMode == TR_DOUBLE) &&
					(listinfo[0].tree == listinfo[1].tree) )
			listinfo[1-glob.FocusBox].UpdateFiles = TRUE ;
	}

} /* proc DoFileOp */


/* Forms name-list of selected files in the buffer 'files'. The caller needs
   a maximum of 'buflen' non-null characters in this buffer.
   File names are separated by a blank, and 'files' is null terminated.

WARNING! 'files' is assumed to have storage for buflen + 1 (for NULL) +
		 12 bytes for an extra file name */

void FormSelFileList(char *files, unsigned buflen)
{
	unsigned total, count ;
	int len ;
	char *filebound ;
	PENTRY node ;
	PTREE tree ;

	total = CountFilesToOperateOn() ;

	if (total > 0)
	{
		filebound = files + buflen ;
		count = 0 ;

		MarkFilesBeforeFileOp() ;
		tree = listinfo[glob.FocusBox].tree ;

		/* Locate all files to operate on and append upto buflen charecters */
		for (node = tree->FirstFile ; node && (count < total) ;
																	node = node->x.f.snext )
		{
			/* Has file been marked to perform the file-op? */
			if (node->FILEOPMARKER)
			{
				count++ ;
				len = Internal2Normal(files, node->name) ;                                                              
				files += len ;

				*(files++) = ' ' ;

				if (files >= filebound)
				{
					*filebound = '\0' ;
					return ;
				}
			} /* if */
			/* else just skip to next file */
		} /* node for loop */
	} /* total > 0 */       

	*files = '\0' ;

} /* FormSelFileList */

/* ZZZZZ */
/* This function is be very similar to GetDestPath -- maybe they can be
   combined to reduce code size!! */
BOOL DisplayedFilesOk()
{
	HCABdelfiles hcab ;
	TMC tmc ;

	char FileList[MAXFILELIST+1+(NAMELEN+EXTLEN+1)+1] ;

	hcab = HcabAlloc(cabiCABdelfiles) ;
	if (!hcab)
	{
		OutOfMemory() ;
		return FALSE ;
	}
	InitCab(hcab, cabiCABdelfiles) ;
	FormSelFileList(FileList, MAXFILELIST) ;

	SzToCab(hcab, FileList, Iag(CABdelfiles, szdelfilelist));
	SzToCab(hcab, szEnterButton, Iag(CABdelfiles, pszdelfilesEB));
	SzToCab(hcab, szCancelButton, Iag(CABdelfiles, pszdelfilesCB));
	SzToCab(hcab, szHelpButton, Iag(CABdelfiles, pszdelfilesHB));

	tmc = MyTmcDoDlg(&dlgdelfiles, hcab) ;

	FreeCab(hcab) ;

	return (tmc == tmcOK) ;

} /* DisplayedFilesOk */

BOOL FAR PASCAL FDlgdelfiles(WORD dlm, TMC tmc,
											WORD wNew, WORD wOld, WORD wParam)
{
	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	/* Actually help is the only case to be handled here. Otherwise,
	   we just dismiss the dialog and caller looks at the tmc value on exit */
	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK,szDelFileCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcdelfileshelp);

		/* The user should not be able to edit this list! */
		SetUpEditBox(tmcdelfilelist, FALSE, 256, FALSE);

		gCurrentTMC = tmcOK;
	}
	else
	if (dlm == dlmSetFocus)
	{
	    gCurrentTMC = tmc;
	}
	else
	if (dlm == dlmClick)
	{
		if(tmc == tmcdelfileshelp)
			Help(hemDialog, ((PDLG)&dlgdelfiles)->hid,NULL,0);

		SetFocusTmc(tmcOK) ;
	}


	return TRUE;
} /* proc FDlgdelfiles */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\debug.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <bios.h>
#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <stdio.h>

#undef FILE1
#define COM1 foo

extern WORD ReturnScreenMode;
extern BOOL gfSwapHandlerInstalled;

void com1(str)
char *str;

{
#ifdef COM1
	long l;

	_bios_serialcom(_COM_INIT, 0, _COM_CHR8 | _COM_STOP1 | _COM_NOPARITY |
			_COM_9600);
	while (*str)
	{
		_bios_serialcom(_COM_SEND, 0, (unsigned) (*str));
		if (*str == '\n')
		{
			_bios_serialcom(_COM_SEND, 0, (unsigned) '\r');
			for (l=0; l < 10000; l++)
				;
		}
		str++;
	}
#endif
#ifdef FILE1
	static FILE *fp = NULL;

	if (!fp)
	{
		fp = fopen("data", "w");
	}
	fputs(str, fp);
	flushall();
#endif
}

VOID com1i(i)
int i;

{
	char str[15];
	
	itoa(i, str, 10);
	strcat(str, " ");
	com1(str);
}

void PrintAndExit(char *s, int i)
{
	SetUpExitToDos();
	if (gfSwapHandlerInstalled)
		RemoveSwapHandler() ;

	SetScreenMode(ReturnScreenMode);

  	EndScreen(TRUE);
  	EndCow(TRUE);

	printf("%s = %d\n", s, i) ;
	
	DTS_API_Exit();
	exit(0);
}

VOID FlopMsg(dlm)
WORD dlm;

{
	static WORD lastdlm = 0;
	char *s;
	
	switch (dlm)
	{
		case dlmKey: s = "dlmKey"; break;
		case dlmInit: s = "dlmInit"; break;
		case dlmIdle: s = "dlmIdle"; break;
		case dlmTerm: s = "dlmTerm"; break;
		case dlmClick: s = "dlmClick"; break;
		case dlmChange: s = "dlmChange"; break;
		case dlmDblClk: s = "dlmDblClk"; break;
		case dlmUnclick: s = "dlmUnclick"; break;
		case dlmSetFocus: s = "dlmSetFocus"; break;
		case dlmKillFocus: s = "dlmKillFocus"; break;
		case dlmClientMouse: s = "dlmClientMouse"; break;
		case dlmNonClientMouse: s = "dlmNonClientMouse"; break;
		default: s = "Unknown"; break;
	}
	if (dlm == dlmIdle && lastdlm == dlmIdle)
	{
	} else
	{
		com1(s);
		com1("\n");
	}
	lastdlm = dlm;
}

/****	catfname - appends name of file in record to a string
**	This exists because the strings in a record are in far memory, hence
**	the medium-model strxxx fns won't work.
**
**	ENTRY
**		dest - string to append to
**		rcd  - record to fetch name from
**	EXIT
**		dest - has the filename appended to it.
*/
void catfname(dest, rcd)
char dest[];
PENTRY rcd;
{
	int spos;								// position in src
	int dpos;								// position in dest
	
	spos = 0;
	dpos = 0; 
	while (dest[dpos])
		dpos++;
	
	while (spos < NAMELEN && rcd->name[spos])
	{
		dest[dpos] = rcd->name[spos];
		dpos++;
		spos++;
	}
		
	if (rcd->name[NAMELEN])
	{
		dest[dpos++] = '.';

		spos = NAMELEN;
		while (spos < NAMELEN+EXTLEN && rcd->name[spos])
		{
			dest[dpos] = rcd->name[spos];
			dpos++;
			spos++;
		}
		dest[dpos] = EOS;
	} else
	{
		dest[dpos] = EOS;
	}
	return;
} /* proc catfname */

/****
**
**
**	ENTRY
**
**	EXIT
**
**	WARNING:
**
**	EFFECTS:
**
*/
void DumpBranch(walk, indent)
PENTRY walk;
{
	char str[255];
	int i;
	
	if (!walk)
	{
		com1("   -- none --\n");
		return;
	}
	
	while (walk)
	{
		str[0] = EOS;
		for (i=1; i <= indent; i++)
			strcat(str, "   ");
		
		catfname(str, walk);

		if (walk->LASTDIR)
			strcat(str, " LAST");
		if (walk->nosib)
			strcat(str, " NOSIB");
		if (walk->attribs & _A_SUBDIR)
			strcat(str, " DIR");

		strcat(str, "\t");
		
		if (walk->nosib)
		{
			strcat(str, " parent: ");
			if (walk->sibling)
				catfname(str, walk->sibling);
			else
				strcat(str, "--");
		} else
		{
			strcat(str, " sib: ");
			if (walk->sibling)
				catfname(str, walk->sibling);
			else
				strcat(str, "--");
		}
		
		if (walk->attribs & _A_SUBDIR)
		{
			strcat(str, " child: ");
			if (walk->x.d.child)
				catfname(str, walk->x.d.child);
			else
				strcat(str, "--");
			strcat(str," dnext: ");
			if (walk->x.d.dnext)
				catfname(str, walk->x.d.dnext);
			else
				strcat(str, "--");
			strcat(str, "\n");
			com1(str);

			if (walk->x.d.child)
				DumpBranch(walk->x.d.child, indent+1);
		} else
		{
			strcat(str, " snext: ");
			if (walk->x.f.snext)
				catfname(str, walk->x.f.snext);
			else
				strcat(str, "--");
			strcat(str, "\n");
			com1(str);
		}
		
		if (walk->nosib)
			walk = NULL;
		else
			walk = walk->sibling;
	}
} /* proc DumpBranch */

VOID DumpSel()
{
	DumpBranch(listinfo[glob.FocusBox].tree->head, 0);
}

int  SelCountCheck(PTREE tree)
{
	int temp ;
	unsigned long sizesel ;

	temp = GetTreeSelectedInfo(tree, &sizesel) ;
	if (temp != tree->NumSel)
	{
		printf("*** SelCount error! tree->numsel=%d, count=%d\n",
					tree->NumSel, temp) ;
		exit (0) ;
	}
}

int NumTreeFiles(PTREE tree)
{
	PENTRY fil ;
	int cnt = 0 ;

	for (fil = tree->FirstFile ; fil ; fil = fil->x.f.snext)
		cnt++ ;

	if (cnt != tree->filecount)
	{
		Beep() ; Beep() ; Beep() ;
	}
	return cnt ;
}

void DumpsnextChain(char *title, PTREE tree)
{
	/* ZZZZZ */
	char a[13] ;
	PENTRY parent, node ;

	com1(title) ;
	for (node = tree->FirstFile ; node ; node = node->x.f.snext)
	{
		Internal2Normal(a, node->name) ;
		com1("file name: ") ; com1(a) ;
		if (node->FIRSTDIRFILE)
			com1(" first") ;

		if (node->LASTDIRFILE)
			com1(" last") ;

		parent = FindParent(node) ;
		if (parent)
		{
			Internal2Normal(a, parent->name) ;
			if (parent->DIRSORTED)
				com1(" sorted ") ;
		}
		else
		{
			strcpy(a, "d:\\") ;
			if (!tree->SortRequired)
				com1(" sorted ") ;
		}
		com1("  parent name: ") ; com1(a) ;
		com1("\n") ;
	}
	com1("Leaving Dumpsnextchain()\n") ;
} /* DumpsnextChain */

void Shelldumpsnext(void)
{
	PTREE temptree ;
	BYTE t ;
	int cnt ;

	temptree = FindTree("D:\\", &t) ;
	DumpsnextChain("----------------\n", temptree) ;
	cnt = NumTreeFiles(temptree) ;
	com1("Number of tree files = ") ; com1i(cnt) ; com1("\n") ;
	
} /* Shelldumpsnext */

#if 0
void PrintList(TOKEN tkList)
{
    char tstr[256];
    TOKEN tkTemp;
    SYMBOL_TABLE_ENTRY far *syTemp;

    if(tkList <= 0)
        return;

    syTemp = Token_To_Symbol(tkList);
    while((tkList=Get_Symbol_Next(syTemp)) > 0) {
        fprintf(stdaux, "%Fs = ", Get_Token_Identifier(tkList));

        syTemp = Token_To_Symbol(tkList);
        if((tkTemp=Get_Symbol_Value(syTemp)) == TK_NOTHING) {
            fprintf(stdaux, "No Value");
        } else {
            if(Get_Symbol_Next(Token_To_Symbol(tkTemp)) == TK_NOTHING) {
                fprintf(stdaux, "%Fs", Get_Token_Identifier(tkTemp));
            } else {
                fprintf(stdaux, "List");
            }
        }
        fprintf(stdaux, "\n\r");
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\dir.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <help.h>
#include "creatdir.hs"
#include "creatdir.sdm"

#define EXCEED_PATHLEN_ERR 5

extern BYTE ErrorCrit ;

extern char * PASCAL MySetMessageText(TMC tmc, char *message, int nWid) ;
extern void InsertDirAndMarkLastDirBits(PTREE tree, PENTRY parent, PENTRY newdir) ;
extern PENTRY HandleDeletednext(PTREE tree, PENTRY deldir) ;
extern int DeleteConfirmationDialog(char *dpath, BOOL fIsDelFile, char *Message) ;
extern VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen) ;

int  CreateDirectory(PTREE tree, PENTRY parent, char *name, BOOL fRealCreation)
{
	PENTRY rptr ;
	char curpath[MAX_PATH+1] ;
	char parpath[MAX_PATH+1] ;
#ifdef TRUENAME_LIMIT
	 char TrueName[128] ;
#endif
	int code, ret ;
	struct find_t findinfo ;
	char statusline[STATUS_LEN] ;
	int action ;
	int dummylen ;

	rptr = AllocTreeEntryCompactIfNeeded(tree) ;
	if (!rptr)
	{
		OutOfMemory() ;
		return ACT_CANCEL ;
		// return ACT_NOMEM ;
	}       /* while */

	if (fRealCreation)
	{
	/* allocation of rptr was done succesfully! It was better to check for
	    *   memory availability before touching the disk .
		 */
		Tree2Path(tree, parent, parpath, &dummylen) ;
		strcpy(curpath, parpath) ;
	if (parent)
			strcat(curpath, "\\") ;

	/* ZZZZZ if name is already in upper case then remove following!! */
#ifdef DBCS
	DBCSstrupr(name) ;
#else
	strupr(name) ;
#endif
	strcat(curpath, name) ;

	FormStringStatusLine(statusline, szStDir, curpath, STATUS_LEN) ;

		/* Check to make sure that the new dir does not exceed the 66 char
		 * limit in DOS -- needed for Novell networks, 3+Open, etc.
		 * I don't check for the "TrueName" anymore because command.com
		 * seems to not do this and lets the net server see if it can handle
		 * longer than 66 char path names. However, DOS can't copy files, etc
		 * from a directory this deep.
		 */
#ifdef TRUENAME_LIMIT
		if (translate_name(curpath, TrueName))
			strcpy(TrueName, curpath) ;

		ErrorCrit = 0xFF ; // set to default non-critical error value.

		if (strlen(TrueName) > ALLOWED_PATH)
#else
		if (strlen(curpath) > ALLOWED_PATH)
#endif
		{
			/* This one causes the Access denied message, F1=Help can be used
			 * to figure out what error it is.
			 */
			ret = -1 ;
			_doserrno = EXCEED_PATHLEN_ERR ;
		}
		else
		{
		ret = mkdir(curpath) ;
		}

	if (ret)
	{
			/* Directory creation error */
			/* We had allocated one slot but we don't use it!! */
			/* ZZZZZ Similar stuff should be done anywhere we allocate but don't 
			 * use the allocated node!!
			 */
			tree->holecount++ ;

			/* Did a critical error occur? -- say, disk write protected, etc! */
			if (ErrorCrit != 0xFF)
				action = GetResponse(statusline, szCriticalMessages[ErrorCrit],
														BT_SKIPRETRY, HELP_ERRCREATEDIR);
			else
				action = DOSErrorBox(statusline, _doserrno, HELP_ERRCREATEDIR) ;

			return action ;
	}

		/* Directory has been successfully created. Disk Avail Size, etc
		 *      would have changed. So, a showinfo should reread available size
		 */
		tree->fdiskinfoknown = FALSE ;
		 
		/* We could just get a find attributes here!! as wr_time isn't used
	    * anyway
		 */
		/* ZZZZ Following has a BUG in case following call fails? We have created
		 * the directory but we can't read attributes, so tree not updated, but
	    * disk has new directory
		 */
		do
		{
		code = _dos_findfirst(curpath, _A_SUBDIR, &findinfo) ;
			ret = (code) ? DOSErrorBox(statusline, code, HELP_ERRFINDCREATEDIR) :
																							ACT_OK ;
		} while (ret == ACT_RETRY) ;

		if (ret != ACT_OK)
			return ACT_CANCEL ;

		Normal2Internal(rptr->name, (char far *) findinfo.name) ;

		/* ZZZ time actually not needed */
		rptr->dtlx.dt.time = findinfo.wr_time ;
		rptr->attribs = findinfo.attrib ;
	}
	else
	{
		Normal2Internal(rptr->name, (char far *) name) ;

		/* ZZZ time actually not needed -- use garbage*/
		rptr->dtlx.dt.time = 0 ;
		rptr->attribs = (_A_HIDDEN | _A_SUBDIR | _A_SYSTEM) ;
	}
	rptr->dtlx.lx.level = (parent) ? parent->dtlx.lx.level+1 : 1 ;

	rptr->FIRSTFILEFOUND = 0 ;
	/* There are no files belonging to 'dir' as it has just been created. So,
	 * trivially its files (0 of them) are in sorted order.
	 */
	rptr->DIRSORTED = TRUE ; 

	tree->DirCount++ ;

	/* prev to rptr is NULL as we insert this new directory entry as the
	 *  very first subdirectory of parent.
	 */
	UpdateSiblings(tree, parent, NULL, rptr) ;

	rptr->x.d.child = NULL ;

	/* For non-root directory, mark its parent as having a sub-dir! */
	if (parent)
		parent->HASSUBDIRS = TRUE ;

	/* Mark the collapse dir bits correctly for rptr now! */
	rptr->HASSUBDIRS = FALSE ;
	rptr->EXPANDED = FALSE ;

#ifdef DONT_DO_ANY_INSERTION_SORT
	rptr->LASTDIR = HasNoSubDir(tree, parent) ;

	if (parent)
	{
		rptr->x.d.dnext = parent->x.d.dnext ;
		parent->x.d.dnext = rptr ;
	}
	else
	{
		rptr->x.d.dnext = tree->FirstDirectory ;
		tree->FirstDirectory = rptr ;
	}
#else
	/* Insert directory 'rptr' in the 'dnext' chain (after 'parent') in
	 * alphabetical order of 'parent' files.
	 */
	InsertDirAndMarkLastDirBits(tree, parent, rptr) ;
#endif

	/* Note that "tree->VisibleDirCount" does not include the root dir */
	if ( ((!parent) && (tree->VisibleDirCount > 0)) ||
		  (parent && (parent->EXPANDED)))
	{
		rptr->DISPLAYED = TRUE ;
		tree->VisibleDirCount++ ;
	}
	else
	{
		/* We have just created a dir -- The user would like to be able to
		 *  see the new entry added. So we expand 'parent' by 1 level indicated
		 *  by passing FALSE as the last argument.
		 */
		ExpandDirVisibility(tree, parent, FALSE) ;
	}

	return ACT_OK ;
} /* CreateDirectory */

static char *gsParDirName; /* parent dir name when creating a new directory */

BOOL PromptAndCreateDir(PTREE tree, PENTRY parent)
{
     HCABcreatdir  h;
     char newdirname[NAMELEN+EXTLEN+2] ;
	  char tempname[MAX_PATH+1] ;
	  char newtempname[MAX_PATH+1] ;
	  int ret ;
	  int dummylen ;

	  Tree2Path(tree, parent, tempname, &dummylen) ;

	  // FormPseudoPathName(pardirname, parent, tree) ;
     gsParDirName = tempname ;

		do
		{
	h = HcabAlloc(cabiCABcreatdir);

			if (!h)
			{
				OutOfMemory() ;
				return FALSE ;
			}

			InitCab(h, cabiCABcreatdir) ;

			SzToCab(h, NullString, Iag(CABcreatdir, pszcreatdirnew));

			SzToCab(h, szEnterButton, Iag(CABcreatdir, pszcreatdirEB));
			SzToCab(h, szCancelButton, Iag(CABcreatdir, pszcreatdirCB));
			SzToCab(h, szHelpButton, Iag(CABcreatdir, pszcreatdirHB));

	if (MyTmcDoDlg(&dlgcreatdir,  h) == tmcOK)
	{
				/* The reason we use "newtempname" and not just re-use "tempname"
				 * is because we might do this loop more than once and in that
				 * case we want gsParDirName (i.e., "tempname") to remain
				 * the same.
				 */
				SzFromCab(h,newtempname,MAX_PATH,Iag(CABcreatdir,pszcreatdirnew));
				ScrunchFileName(newdirname, newtempname, FALSE) ;

				// The following upper case translation is done in CreateDirectory
				// strupr(newdirname) ;
				ret = CreateDirectory(tree, parent, newdirname, TRUE) ;
	}
	/* else he used cancel=>no directory creation needs to be done! */
	else 
				ret = ACT_CANCEL ;

			FreeCab(h) ;
		} while (ret == ACT_RETRY) ;
		return (ret == ACT_OK) ;
} /* PromptAndCreateDir */


BOOL FAR PASCAL FDlgcreatdir(WORD dlm, TMC tmc, WORD wNew,
												WORD wOld, WORD wParam)
{
	PWND lwind ;
	int nWid ;
	char *msg ;
	int  itemwidth ;
	char TempStr[MAX_PATH+1] ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch (dlm) {

	case dlmInit:
		SetUpDialog(tmcOK,szCreateDirCaption) ;
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmccreatdirhelp);
		SetUpEditBox(tmccreatdirnew, TRUE,NAMELEN+EXTLEN+1, TRUE);

		/* Make TempStr have the compressed parent dir name */
		lwind = PwndOfTmc(tmccreatdirold);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;
		MakeDirNameFit(gsParDirName, NULL, TempStr, itemwidth) ;
		Shell_SetTmcText(tmccreatdirold, TempStr);
		break;

	case dlmTerm:
		if (tmc == tmcOK)
		{
			GetTmcText(tmccreatdirnew, TempStr, MAX_PATH);

			/* Did the user not type any name? If so don't dismiss dialog */
			if (!(*TempStr))
			{
				Shell_Beep() ;
				return FALSE ;
			}

			/* check to see if the user is trying to use nested names */
#ifdef DBCS
			if (DBCSstrchr(TempStr, PATHCHAR))
#else
			if (strchr(TempStr, PATHCHAR))
#endif
			{
				lwind = PwndOfTmc(tmccreatdirerr1) ;
			nWid = lwind->arcWindow.axRight - lwind->arcWindow.axLeft + 1;

				msg = MySetMessageText(tmccreatdirerr1, szNoPathCharsInCreatDir,
																						nWid) ;
				/* Warning! Assuming that both these edit items have same width */
				MySetMessageText(tmccreatdirerr2, msg, nWid) ;
				return FALSE ; /* Don't dismiss dialog -- invalid name */
			}

		}
		break ;

	case dlmSetFocus:
		gCurrentTMC = tmc;
		break ;

	case dlmClick:
		 if(tmc == tmccreatdirhelp)
			Help(hemDialog, ((PDLG)&dlgcreatdir)->hid, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;

	default: /* do nothing */ ;
	}
	return(TRUE);
} /* FDlgcreatdir */

/* Find out which directory is to be deleted based on list box focus and
*   delete it.
*/
int FindAndDelDirectory(void)
{
	PENTRY deldir ;
	PTREE tree ;

	deldir = listinfo[glob.FocusBox].files ;
	tree = listinfo[glob.FocusBox].tree ;

	/* Note that 'deldir' can't be NULL as the root directory can't be deleted
	 * The menu would have been disabled and this fn won't be called
	 * on the root directory.
	 */

	/* If the directory is non-empty, tell the user it can't be deleted */
	if (deldir->x.d.child)
	{
		ShellMessageBox(szDelGroupTitle, szDelDirLine1) ;
		return ACT_CANCEL ;
	}
	else
		return DelDirectory(deldir, tree, glob.VerifyDelete) ;
} /* FindAndDeleteDirectory */

int DelDirectory(PENTRY deldir, PTREE tree, BOOL verify)
{
	char dirpath[MAX_PATH+1];                       // old file path
	PENTRY prev_dfs_dir ;
	PENTRY parent ;
	char rootdir[4] ; /* for "?:\" */
	int action, code ;
	char statusline[STATUS_LEN] ;
	PENTRY dir0, dir1 ;
	int dirlinefocus, dirlineother ;
	int dummylen ;

#ifndef NOCONSISTENCY
	if (!deldir)
	{
	    printf("*** request to delete root!! menu not disabled! \n") ;
	    exit(0) ;
	}
#endif
	/* Store the directories being displayed in the two listboxes. Store
	 *      also their line numbers (indices in dir listbox). This will be used
	 *      when we try to re-paint the listboxes. These will change when we
	 * delete the directory.
	 */
	dir0 = listinfo[0].files ;
	dirlinefocus = glob.lineselected[glob.FocusBox] ;

	/* In case we are not in double tree mode, these might be meaningless! */
	dir1 = listinfo[1].files ;
	dirlineother = glob.lineselected[1-glob.FocusBox] ;

	Tree2Path(tree, deldir, dirpath, &dummylen) ;

	FormStringStatusLine(statusline, szStDir, dirpath, STATUS_LEN) ;

	if (verify)
	{
		/* We will get back ACT_OK, ACT_SKIP or ACT_CANCEL! */ 
		action = DeleteConfirmationDialog(dirpath, FALSE, NullString) ;

		if (action == ACT_SKIP)
			action = ACT_CANCEL ;
		else
		if (action == ACT_FORCE)
			action = ACT_OK ;
	}
	else
		action = ACT_OK ;
		
	if (action != ACT_OK)
	{
		return action ;
	}

	/* ZZZ We could check for its child field being NULL before issuing
	   a disk operation! But in compact mode, this will create problems */
	/* ZZZZ cwd is dirpath, we won't be able to delete it -- warn user! */
	/* Right now -- we fix it by changing directories to root! */
	strfcpy(rootdir, tree->root) ;
	UnixChdir(rootdir) ;

	do
	{
		code = rmdir(dirpath) ;
		action = (code) ? DOSErrorBox(statusline, _doserrno, HELP_ERRDELDIR) : ACT_OK ;
	} while (action == ACT_RETRY) ;

	if ( (action != ACT_FORCE) && (action != ACT_OK) )
		return action ;

    parent = FindParent(deldir) ;

    /* We succesfully deleted 'deldir' => it had no children. It
     *  thus saves us the trouble of updating its children, etc
	  */

	 /* remove the entry 'deldir' from the 'dnext' chain of 'tree' */
	 prev_dfs_dir = HandleDeletednext(tree, deldir) ;

    tree->DirCount-- ;

    /* Now update child pointer of 'parent' and siblings of 'deldir' */
    DelFileEntry(tree, parent, deldir) ;
    /*  we need to update the directory and file list box
       displays correctly here. DelFileEntry only handles normal
       files.
    */
	/* Now set parent dir's collapse bits. Note that to be able to delete
	 * a directory, 'dir' and its parent should have been visible in list box.
	 */
	if (parent)
	{
		parent->HASSUBDIRS = parent->EXPANDED = AreThereSubDirs(tree, parent) ;
	}
	tree->VisibleDirCount-- ;

#ifndef NOCONSISTENCY
	if (!glob.lineselected[glob.FocusBox])
	{
		printf("*** check mark can't have been at line 0\n") ;
		exit(0) ;
	}
#endif

    /* selection focus (check mark) shifts to 'prev_dfs_dir' */
    listinfo[glob.FocusBox].files = prev_dfs_dir ;

	 if (tree->Compacted)
	 {
		LoadCompactDir(tree, prev_dfs_dir);
	 }

	/* Selected dir (one with check mark) now will be the dir above the deleted
		one.
	*/
	/* Sending Select Message to directory listbox fixes lots of problems
	 * like reading in parent dir's files in case of compact dir mode, sorting
	 * its files in case it has not been done yet, etc.
	 */
	ListProcTreeList(tmmSelect, NULL, glob.lineselected[glob.FocusBox]-1,
												TreeList[glob.FocusBox].tmc, 0, 0, 0) ;
	listinfo[glob.FocusBox].UpdateFiles = TRUE ;

	/* If we are in Double tree mode and same tree in other box too, repaint
	 * that set of boxes correctly too. Note that we are sending Select Messages
	 * So, the non-focus listbox needs to be handled first as the top of
	 * FM which displays the current directory should be set right!
	 */
	if ( (glob.TreeMode == TR_DOUBLE) &&
			(listinfo[0].tree == listinfo[1].tree) )
	{
		/* following check is same as (dirlinefocus == dirlineother) */
		if (dir0 == dir1)
		{
			ListProcTreeList(tmmSelect,NULL,glob.lineselected[1-glob.FocusBox]-1,
											TreeList[1-glob.FocusBox].tmc, 0, 0, 0) ;
			listinfo[1-glob.FocusBox].UpdateFiles = TRUE ;

			/* See comment below for focuslinechange as to why this check
			 * is done.
			 */
			if ( tree->VisibleDirCount != (glob.lineselected[glob.FocusBox]) )
				FocusLineChange(&TreeList[1-glob.FocusBox], -1) ;
		}
		else
		{
			/* In case the selected dir in other listbox is earlier, then we
			 * don't have to modify focus but just repaint the dir list box.
			 */
			if (dirlineother < dirlinefocus)
			{
				InsertListItem(&TreeList[1-glob.FocusBox], 0) ;
			}
			else
			{
				/* the selected dir is displayed later than the deleted directory
				 * the directory moves 1 above its previous location. So update
				 * the focus to be 1 above. Repaint after this.
				 */
				FocusLineChange(&TreeList[1-glob.FocusBox], -1) ;
				InsertListItem(&TreeList[1-glob.FocusBox], 0) ;
			}
		}
	}

	/* Note that the listbox will still keep the focus at the same line
	 *      as before. We need to move it 1 line up. If last directory is
	 *      being deleted, the listbox automatically moves it one up, so
	 *      we don't do it here.
	 */
	if ( tree->VisibleDirCount != (glob.lineselected[glob.FocusBox]) )
		FocusLineChange(&TreeList[glob.FocusBox], -1) ;

	InsertListItem(&TreeList[glob.FocusBox], 0) ;

	return ACT_OK ;
} /* fn DelDirectory */



#if 0
/************************** Unused function ******************************/
/* Forms a pseudo path name for node -- It makes it of the form "?:name" */
void FormPseudoPathName(char *path, PENTRY node, PTREE tree)
{
	if (node)
	{
		path[0] = tree->root[0] ;
		path[1] = ':' ;
      Internal2Normal(path+2, node->name) ;
	}
	else
	{
		strfcpy(path, tree->root) ;
	}
} /* FormPseudoPathName */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\disp.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* Changing display options -- SORT Order or PATTERN should affect all
  trees and not just the trees being displayed!! So we might want to mark
  this information with each tree. Initialize this info in InitFileMgr too*/

#include <ctype.h>
#include "common.h"
#include "menus.h"
#include "filemgr.h"
#include "prot.h"
#include "dispopt.hs"
#include "dispopt.sdm"
#include "text.h"

BOOL pat_change = FALSE;
BOOL disp_hidden_change = FALSE;

extern VOID ListBoxPath(treehdr far *tree,PENTRY node,int whichtree) ;
extern void HandleEmptyFileListBoxes(void) ;


VOID DisplayOptions(VOID)
{
	HCABdispopt	  h;
	char tempname[MAX_PATH+1] ;
	TMC tmc ;

	h = HcabAlloc(cabiCABdispopt);

	if (!h)
	{
		OutOfMemory() ;
		return ;
	}
	InitCab(h, cabiCABdispopt) ;
	/* print the current file filter options here */
	SzToCab(h, glob.MatchPat, Iag(CABdispopt, pszdisppattern));

	SzToCab(h, szEnterButton, Iag(CABdispopt, pszdispEB));
	SzToCab(h, szCancelButton, Iag(CABdispopt, pszdispCB));
	SzToCab(h, szHelpButton, Iag(CABdispopt, pszdispHB));

	if ( (tmc = MyTmcDoDlg(&dlgdispopt, h)) == tmcCancel)
		return ;

	if (pat_change || disp_hidden_change)
	{
	    /* pattern changed -- so take care of all trees --
	       This routine only handles the tree(s) being displayed
	       in the listbox(es)!
	    */
	    SzFromCab(h,tempname,MAX_PATH,Iag(CABdispopt, pszdisppattern));

		/* ZZZ order of MakePatWellFormed, Scrunching not OK?? */
		ScrunchFileName(glob.MatchPat, tempname, TRUE) ;

		/* ZZZZ Probably not needed if dialog box takes care of it! */
#ifdef DBCS
		DBCSstrupr(glob.MatchPat) ;
#else
		strupr(glob.MatchPat) ;
#endif

		strcpy(glob.MatchPat, MakePatWellFormed(glob.MatchPat)) ;

		if (MarkAllTreeMatches(listinfo[0].tree, disp_hidden_change))
		{
			/* When Display Spec. changes, according to the spec from
			 * ericst, we want to deselect all tree files.
			 */
			DeselectTree(listinfo[0].tree) ;

			/* MatchPattern has changed, Set new tile for File listbox0 */
			listinfo[0].UpdateFiles = TRUE ;

			/* New and improved title code! (see lbox.c) */
			ListBoxPath(listinfo[0].tree,listinfo[0].files,0);
			if (glob.MaxTree == 1) 
			{
				if (listinfo[1].tree != listinfo[0].tree)
				{
					/* When Display Spec. changes, according to the spec from
					 * ericst, we want to deselect all tree files.
					 */
					DeselectTree(listinfo[1].tree) ;

					/* Note: If pat has changed for tree0 it has for tree1 too
						as all displayed trees are marked on same pattern */
					MarkAllTreeMatches(listinfo[1].tree, TRUE) ;
				}
				
				/* MatchPattern has changed, Set new title for File listbox1 */
				listinfo[1].UpdateFiles = TRUE ;
				ListBoxPath(listinfo[1].tree,listinfo[1].files,1);
			}
			HandleEmptyFileListBoxes() ;
		}
		/* else pattern hasn't changed -- file listbox(es) needn't be redrawn */
	}
	/* else pattern is same -- File listbox(es) needn't be redrawn */
	FreeCab(h);

}

BOOL FAR PASCAL FDlgdispopt(WORD dlm, TMC tmc, WORD wNew,
										WORD wOld, WORD wParam)
{
	int t ;
	int t2 ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;
	switch (dlm) {
	case dlmInit:
	{
		SetTmcVal(tmcgroupname, glob.SortKey) ;
		SetTmcVal(tmcDisplayHiddenFiles, glob.DisplayHiddenFiles) ;
		SetTmcVal(tmcDescendingOrder, (gDescendingOrder == MAGIC_XCHG_MASK)) ;

		SetUpDialog(tmcOK,szDisplayOptionsCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcdisphelp);
		SetUpEditBox(tmcdisppattern, TRUE,NAMELEN+EXTLEN+1, TRUE);
		SetUpCheckBox(tmcDisplayHiddenFiles) ;
		SetUpCheckBox(tmcDescendingOrder) ;

		if (gisgraph)
		{
			/* pass in also the TMCs of the two items that need to get focus
			 * when using Shift+TAB and TAB respectively!
			 */
		   SetUpRadioGroupForGraphics(tmcgroupname, tmcDescendingOrder, tmcOK);

		   SetUpRadiobuttonForGraphics(tmcradioname,0);
		   SetUpRadiobuttonForGraphics(tmcradioext,1);
		   SetUpRadiobuttonForGraphics(tmcradiodate,2);
		   SetUpRadiobuttonForGraphics(tmcradiosize,3);
		   SetUpRadiobuttonForGraphics(tmsradiodisk,4);
		}

		pat_change = FALSE ;
		disp_hidden_change = FALSE ;
		SetFocusTmc(tmcdisppattern) ;
	}
		break;

	case dlmTerm:
		switch(tmc) {
		case tmcOK :
			/* If pattern or sort order has changed, the file list box	*/
			/* will, in general, change. So, we need to trash the 		*/
			/* File Icon cache.											*/

		   t = GetTmcVal(tmcgroupname) ;
			t2 = GetTmcVal(tmcDescendingOrder) ;

			/* Set our sort order flag to the mask value to indicate sort in
			 * descending order in case this check box is checked!
			 */
			if (t2)
				t2 = MAGIC_XCHG_MASK ;

			if ( (t != glob.SortKey) || (t2 != gDescendingOrder) )
		    {
				InitIconCache() ;
				
				/* store sort order flag -- used by the sort routines */
				gDescendingOrder = t2 ; 

				SortCmp = SortFnArr[glob.SortKey = t] ;
				if (glob.TreeMode == TR_SYSTEM)
					SystemSort(listinfo[0].tree, TRUE) ;
				else
				{
					/* Actually we need to only sort the directories we
					 * are viewing in the file listboxes & not entire tree
					 * and mark that directory as being sorted and mark all
					 * other directories as being unsorted.
					 * This will speed up the sort tremendously.
					 */
#ifdef OLDCOMPLETETREESORT
					FormDirectoryOrder(listinfo[0].tree, TRUE) ;
#else
					SetUpTreeForSort(listinfo[0].tree) ;
					SortDirectory(listinfo[0].tree, NULL) ;
					SortDirectory(listinfo[0].tree, listinfo[0].files) ;
#endif
					/* Check to see if we are in doubletree mode & the tree
						being displayed in second listbox is not the same as
						the one in the first one */
					if ( (glob.MaxTree == 1) && 
								(listinfo[1].tree != listinfo[0].tree) )
					{
#ifdef OLDCOMPLETETREESORT
						FormDirectoryOrder(listinfo[1].tree, TRUE) ;
#else
						SetUpTreeForSort(listinfo[1].tree) ;
						SortDirectory(listinfo[1].tree, NULL) ;
						SortDirectory(listinfo[1].tree, listinfo[1].files) ;
#endif
						listinfo[1].UpdateFiles = TRUE ;
					}
				} /* Non System Ordering */

				/* System mode or Singletree mode do update files in box 0 */
				listinfo[0].UpdateFiles = TRUE ;
			}

			/* ZZZZZ Should I look at tree's DisplayHiddenFiles bit? */
			if (glob.DisplayHiddenFiles != GetTmcVal(tmcDisplayHiddenFiles))
			{
				glob.DisplayHiddenFiles = !glob.DisplayHiddenFiles ;
				disp_hidden_change = TRUE ;
			}
		   break;

		case tmcCancel :
		    pat_change = FALSE ;
			 disp_hidden_change = FALSE ;
		    break;

		}
		break ;

	case dlmChange:
		pat_change = TRUE ;
		break ;

	case dlmSetFocus:
		gCurrentTMC = tmc;
		break ;

	case dlmClick:
		 if(tmc == tmcdisphelp)
			Help(hemDialog, ((PDLG)&dlgdispopt)->hid, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;

	default: /* do nothing */ ;
	}
	return(TRUE);
}

extern void ResetTreeMatchedFilesOpt(PTREE tree) ;
extern void MarkMatchesBit(PENTRY fil) ;

/* returns TRUE iff the tree's file nodes were re-checked for pat matches! */
BOOL MarkAllTreeMatches(PTREE tree, BOOL doit)
{
	PENTRY fil ;
	char temp[NAMELEN+EXTLEN+2] ;
	BOOL fOldTreeDisplay ;

/* ZZZZZZ We don't  handle trees not yet completely read
	in as the files are not displayed until whole tree is read in!! */
	if (tree->ContinueTree)
		return FALSE ;

/* If speed is desired these two strcpy's could be removed!! Doing the
	following makes the tree->mpat be syntactically equal to MatchPat
	rather than just semantically */

	strfcpy(temp, tree->mpat) ;
	strfcpy(tree->mpat, glob.MatchPat) ;
	fOldTreeDisplay = tree->DisplayHiddenFiles ;
	tree->DisplayHiddenFiles = glob.DisplayHiddenFiles ;

	if (doit || (!PatternsEquiv(temp, glob.MatchPat)) || 
		         (fOldTreeDisplay != glob.DisplayHiddenFiles) )
	{
		for ( fil= tree->FirstFile ; fil ; fil = fil->x.f.snext)
		{
			MarkMatchesBit(fil) ;
		}

		ResetTreeMatchedFilesOpt(tree) ;
		return TRUE ;
	}
	/* else patterns equivalent -- so markings are correct as it is */
	return FALSE ;
}


/* ZZZ Function could be made more space efficient! */
char *MakePatWellFormed(char *pat)
{
	char *p ;

	/* Change null pattern into "*.*" */
	if (!*pat)
		return "*.*" ;
	else
	{
		/* there is at least 1 non-null character in the pattern */
		/* remove all trailing white spaces */
		p = strchr(pat, '\0') - 1 ; /* point to last non-null char */
		while ( isspace(*p) && (p != pat) )
			p-- ;

		if (isspace(*p)) /* pattern has only white spaces */
			return "*.*" ;
		else
		{
			*(p+1) = '\0' ;

			/* Now strip all leading white spaces -- we know pattern has
				atleast one non-white character !! */
			p = pat ;
			while (isspace(*p))
				p++ ;

			return p ;
		}
	}
} /*  MakePatWellFormed */

/* ZZZZ Returns whether pattern pat1 is equivalent to pat2 logically.
	Actually it is supposed to say that "*" equivalent to "*.*" but
	now it checks for syntax equivalence rather than semantics. Both pat1
	and pat2 are assumed to be null terminated */
BOOL PatternsEquiv(char far *pat1, char far *pat2)
{
	while (*(pat1++) == *(pat2++)) 
	{
		if (!*(pat1-1)) /* We have reached the NULL character in both */
			return TRUE ;
	}

	return FALSE ; /* patterns not equivalent */
} /* PatternsEquiv */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\dosintf.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <prot.h>

BYTE ErrorCrit;
extern BOOL gfFMBeingInited ;

#if 0
/ZZZZZ removed!! *****************************/
#include <crit.hs>
#include <crit.sdm>
 /*
 *
 */
extern char *szCriticalAction[];

ListBoxData CritList;
BYTE critline;

WORD PASCAL ListProcCritList(tmm, sz, isz, tmc, x, y, bArg)
WORD tmm;
char *sz;
WORD isz;
TMC tmc;
WORD x, y, bArg;
{
	RX xval;
	char messagestr[50];
	int i;
	int len;

	xval = Get_List_Rect(&CritList).axLeft +1;
	switch (tmm) {
		case tmmCount:
			return(2);
		case tmmSetFocus:
			/* ignore this message! */
		     break;
		case tmmSelect:
		     critline = isz;
		     EndDlgTmc(tmccritenter);
		     break;
		case tmmDrawItem:
		{
		    if(isz < 2)
		    {
		      len = Get_List_Rect(&CritList).axRight -
			    Get_List_Rect(&CritList).axLeft - 4;
		      messagestr[0] = '1'+isz;
		      for(i=1;szCriticalAction[isz][i-1];i++)
		      {
			   messagestr[i] = szCriticalAction[isz][i-1];
		      }
		      for(;i<len;i++)
		      {
			  messagestr[i] = ' ';
		      }
		      TextOut(CritList.pwd, xval+1, y+1,messagestr, len, bArg);
		    }
		}
			break;
		default:
			break;
	}
	return TRUE;
}


BOOL FAR PASCAL
FDlgcrit(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
	PWND  dwind;
	PWND  lwind;
	WORD  mx,my;
	int   i;
	char str[15];

	dwind = PwndParent(PwndOfListbox(tmccritcancel));
	switch(dlm)
	{
	    case dlmInit:
	    {
	       SetUpDialog(tmccritenter,szCritWarning);
	       //if(gisgraph)
	       //{
		SetupButtonForGraphics(tmccritenter);
		SetupButtonForGraphics(tmccritcancel);
		SetupButtonForGraphics(tmccrithelp);
	       //}
	       /* The next few lines initialize a listbox. The list
		  box will hang just below, and have the same x coordinates
		  as tmccritlist
	       */
	       lwind = PwndOfListbox(tmccritlist);
	       ListBoxInit(&CritList,ListProcCritList,dwind,
		    lwind->arcWindow.ayTop -dwind->arcWindow.ayTop,
		    lwind->arcWindow.axLeft-dwind->arcWindow.axLeft,
		    lwind->arcWindow.ayTop-dwind->arcWindow.ayTop+5,
		    lwind->arcWindow.axRight-dwind->arcWindow.axLeft,
		    "",0,0,0);
		MakeListStupid(&CritList);
		Shell_SetTmcText(tmccritmessage,szCriticalMessages[ErrorCrit]);
	    }
	    break;
	    case dlmIdle:
	    {
		ListBoxIdle(&CritList);
	    }
	    break;
	    case dlmClientMouse:
	    {
		dwind = PwndParent(PwndOfListbox(tmccritcancel));
		my = HIBYTE(wParam)-1;
		mx = LOBYTE(wParam);
		ListMouse(&CritList,mx,my,wNew,wOld);
	    }
	    break;
	    case dlmKey:
	    {
		ListKey(&CritList,wNew, 0);
	    }
	    break;
	}
	return(TRUE);

}

/*
 * RETURNS TRUE if call should be aborted,
 * FALSE if call should be retried
 */
BOOL CriticalDialog()
{
	BOOL retval;
	HCABcrit        h;

	h = HcabAlloc(cabiCABcrit);
	if (!h)
	{
	    OutOfMemory() ;
	    return ;
	}
	InitCab(h, cabiCABcrit) ;
	critline = 0;
	if(MyTmcDoDlg(&dlgcrit,h) == tmccritenter)
	{
	    retval = (critline != 0);
	}
	else
		retval = TRUE ;
	FreeCab(h);
	return(retval);
}
/ZZZ above code removed!! *********************************************/
#endif

unsigned shell_findfirst(path,attributes,buffer)
char *path;
unsigned attributes;
struct find_t *buffer;
{
    unsigned ret;
    while(1)
    {
       ErrorCrit = 0xFF;
       ret = _dos_findfirst(path,attributes,buffer);
       if ( (ErrorCrit != 0xFF) && (!gfFMBeingInited) )
       {
		if (CriticalDialog())
				break;
       }
       else
			break;
    }
    return(ret);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\dotrees.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <prot.h>

extern MENUINFO FileMgrMenuBar;
extern BOOL gTaskListEnabled;
extern BOOL gSwitchingEnabled;

extern BOOL ginitial ;
extern BOOL gNeedToUpdateFileList[2];

VOID InitStartProgramList(WORD top,WORD left,WORD bottom,WORD right) ;
VOID InitTaskMan(WORD top,WORD left,WORD bottom,WORD right);
VOID ListBoxPath(treehdr far *tree,PENTRY node,int whichtree);

VOID FAR DoSingleTree()
{
	AY lboxbottom;
	AY i; 					  /* junk int  */
	int temp ;

#ifndef NOCONSISTENCY
	/* The following check is now not needed as we can disable the
	   appropriate arrange menu item. */
	if (glob.InFileMgr && glob.TreeMode == TR_SINGLE && !ginitial)
	{
		printf("*** error -- DoSingleTree not disabled\n" ) ;
		exit (0) ;
	}
#endif

	TakeDownBusyDialog(0);
	TakeDownBusyDialog(1);

	/* ZZZZ This following statement needed only if we can get to 
	   this function from menu. Do we disable 'Arrange' options in Search-Mode?
	   If so, we can remove this statement. Similar case in DoDouble.., DoFlat..
	*/
	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;
	else
		/* Are we switching from system tree mode to this mode using menu? */
		if (glob.TreeMode == TR_SYSTEM && !ginitial)
			SetSelectedDirFocus() ; // set up so that tick mark is drawn right 

	temp = glob.TreeMode ;
	glob.TreeMode = TR_SINGLE ;

	easyenable(&FileMgrMenuBar, DoSingleTree, FALSE) ;

	/* If ginitial is false, this function has been invoked from menu! */
	if (!ginitial)
	{
		/* We are changing either from DoubleTree mode or System Tree Mode */ 
		if (temp == TR_SYSTEM)
		{
			easyenable(&FileMgrMenuBar, DoFlatDisplay, TRUE) ;
			easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
		}
		else /* Changing from DoubleTree mode */
		{
			easyenable(&FileMgrMenuBar, DoDoubleTree, TRUE) ;
			/* ShowInfo is already turned on in DoubleTreeMode */
		}
	}
	/* else by default all menus are turned on at start up! */

	/* WARNING! Assumption: following will happen only when switching modes
	   from system tree mode. If (ginitial) then it will fail as then
	   (temp == TR_SINGLE) will be true */
	if ( (temp == TR_SYSTEM) && (glob.SortKey != SORT_DISK))
#ifdef OLDCOMPLETETREESORT
		FormDirectoryOrder(listinfo[0].tree, TRUE) ;
#else
{
		SetUpTreeForSort(listinfo[0].tree) ;
		SortDirectory(listinfo[0].tree, NULL) ;
		SortDirectory(listinfo[0].tree, listinfo[0].files) ;
}
#endif

	lboxbottom = ayMac - 1;

	// i = (AY) LISTBOXTOP + (glob.DriveCount - 1)/DRIVESPERLINE;
	i = (AY) LISTBOXTOP ;

	ListBoxInit(&TreeList[0],ListProcTreeList,&MainWind,i,0,lboxbottom,
				TREEBOXWIDTH,szDirectoryTree,tmcTreeList0,
				glob.lineselected[0],glob.lineselected[0]) ;
	gNeedToUpdateFileList[0] = FALSE;
	Always_Explicit(&TreeList[0]);
	ListBoxInit(&FileList[0],ListProcFileList,&MainWind,i,TREEBOXWIDTH,
				lboxbottom,TREEBOXWIDTH+FILEBOXWIDTH,
				glob.MatchPat,tmcFileList0,
				/* If tree mode has changed, use 0 for the focuses, else
				 * don't change focus -- pass in the magic value -1.
				 */
				-(temp == glob.TreeMode),-(temp == glob.TreeMode));
	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL) ==
														   TK_ENABLED)
		Set_Explicit(&FileList[0]) ;

	SetUpScreen();
	FileMgrStatusBar(listinfo[0].tree,listinfo[0].files);
	
	listinfo[0].UpdateDrives = TRUE;
	
	glob.MaxTree = 0;							// one tree is active

	/* Was this routine called from the menu - that is did tree mode change? */
	if (	(temp != glob.TreeMode) ||
			(	(WhoHasGlobalFocus() != DRIVELIST0) &&
				(WhoHasGlobalFocus() != TREE0) &&
				(WhoHasGlobalFocus() != FILE0)
			)
		)
	{
		InitGlobalFocus(DRIVELIST0);
	}
	else
	{
		InitGlobalFocus(WhoHasGlobalFocus()) ;
	}

	/* Make sure files don't remain selected in other directories
	 * in the tree without the user being aware of it!
	 */
	if (	(	(temp == TR_SYSTEM) ||
				((temp == TR_DOUBLE) && (listinfo[0].tree == listinfo[1].tree))
			) &&
			!ginitial && !glob.CrossDirSel
		)
	{
		DeselectTree(listinfo[0].tree) ;
		listinfo[0].UpdateFiles = TRUE ;
	}

	// listinfo[0].UpdateFiles = TRUE ;

	ListBoxPath(listinfo[0].tree,listinfo[0].files,0);
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE,TK_SINGLETREE);

} /* proc DoSingleTree */

VOID FAR DoDoubleTree()
{
	AY size;					/* vertical size of list box	*/
	AY i;
	int temp ;
	int size2;

#ifndef NOCONSISTENCY
	if (glob.InFileMgr && glob.TreeMode == TR_DOUBLE && !ginitial)
	{
		printf("*** error -- DoDoubleTree not disabled\n" ) ;
		exit (0) ;
	}
#endif
	TakeDownBusyDialog(0);
	TakeDownBusyDialog(1);

	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;
	else
		/* Are we switching from system tree mode to this mode using menu? */
		if (glob.TreeMode == TR_SYSTEM && !ginitial)
		{
			SetSelectedDirFocus() ; // set up so that tick mark is drawn right

			/* If the tree in listbox 2 also is displaying the same tree,
			 * the fn SetSelectedDirFocus() could have expanded some
			 * directories and hence glob.lineselected[1] might not be
			 * correct now.
			 */
			if (listinfo[1].tree == listinfo[0].tree)
				glob.lineselected[1] =
						GetIndexVisibleDir(listinfo[1].files, listinfo[1].tree) ;
		}

	temp = glob.TreeMode ;
	glob.TreeMode = TR_DOUBLE ;

	easyenable(&FileMgrMenuBar, DoDoubleTree, FALSE) ;


	/* If ginitial is false, this function has been invoked from menu! */
	if (!ginitial)
	{
		/* We are changing either from DoubleTree mode or System Tree Mode */ 
		if (temp == TR_SYSTEM)
		{
			easyenable(&FileMgrMenuBar, DoFlatDisplay, TRUE) ;
			easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
		}
		else /* Changing from SingleTree mode */
		{
			easyenable(&FileMgrMenuBar, DoSingleTree, TRUE) ;
			/* ShowInfo is already turned on in SingleTree mode */
		}
	}
	/* else by default all menus are turned on at start up! */


	/* WARNING! Assumption: following will happen only when switching modes
	   from system tree mode. If (ginitial) then it will fail as then
	   (temp == TR_DOUBLE) will be true */
	if ( (temp == TR_SYSTEM) && (glob.SortKey != SORT_DISK))
#ifdef OLDCOMPLETETREESORT
		FormDirectoryOrder(listinfo[0].tree, TRUE) ;
#else
	{
		SetUpTreeForSort(listinfo[0].tree) ;
		SortDirectory(listinfo[0].tree, NULL) ;
		SortDirectory(listinfo[0].tree, listinfo[0].files) ;
		if (	(listinfo[1].tree == listinfo[0].tree) &&
				(listinfo[1].files != listinfo[0].files)
			)
		{
			SortDirectory(listinfo[1].tree, listinfo[1].files) ;
		}
	}
#endif

	/* If SortRequired is TRUE, the tree has not been sorted even once, 	*/
	/* So, the tree is probably not yet read in completely. It will be sorted*/
	/*	in the list box code, just before displaying the files.				*/
	if ( (!ginitial) && (listinfo[1].tree != listinfo[0].tree) && 
				(!listinfo[1].tree->SortRequired) )
#ifdef OLDCOMPLETETREESORT
		FormDirectoryOrder(listinfo[1].tree, FALSE) ;
#else
	{
		/* The sort key could have been changed between the last time we
		 * sorted this tree and now. We are doing following for safety!
		 */
		SetUpTreeForSort(listinfo[1].tree) ;
		SortDirectory(listinfo[1].tree, NULL) ;
		SortDirectory(listinfo[1].tree, listinfo[1].files) ;
	}
#endif

	/* Compute max listbox size.
	*/

	// i = (AY) LISTBOXTOP + (glob.DriveCount - 1)/DRIVESPERLINE;
	i = (AY) LISTBOXTOP;
	size = (ayMac - i)/2 - 2;

	ListBoxInit(&TreeList[0], ListProcTreeList, &MainWind,
				i, 0, i+size, TREEBOXWIDTH, szDirectoryTree, tmcTreeList0,
				glob.lineselected[0],glob.lineselected[0]) ;
	gNeedToUpdateFileList[0] = FALSE;
	Always_Explicit(&TreeList[0]);

	ListBoxInit(&FileList[0], ListProcFileList, &MainWind,
				i, TREEBOXWIDTH, i+size, TREEBOXWIDTH+FILEBOXWIDTH,
				glob.MatchPat, tmcFileList0,
				/* If tree mode has changed, use 0 for the focuses, else
				 * don't change focus -- pass in the magic value -1.
				 */
				-(temp == glob.TreeMode),-(temp == glob.TreeMode));
	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL) ==
														   TK_ENABLED)
		Set_Explicit(&FileList[0]) ;


	i += (AY) 4;
	size2 = size << 1;
	if (i+size2 >= ayMac)
	    --size2;

	ListBoxInit(&TreeList[1], ListProcTreeList, &MainWind,
				i+size, 0, i + size2,TREEBOXWIDTH, szDirectoryTree, tmcTreeList1,
				glob.lineselected[1],glob.lineselected[1]) ;
	gNeedToUpdateFileList[1] = FALSE;
	Always_Explicit(&TreeList[1]);

	ListBoxInit(&FileList[1], ListProcFileList, &MainWind,
				i+size, TREEBOXWIDTH, i+size2, TREEBOXWIDTH+FILEBOXWIDTH,
				glob.MatchPat, tmcFileList1,
				/* If tree mode has changed, use 0 for the focuses, else
				 * don't change focus -- pass in the magic value -1.
				 */
				-(temp == glob.TreeMode),-(temp == glob.TreeMode));

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL) ==
														   TK_ENABLED)
		Set_Explicit(&FileList[1]) ;


	/* Should really clear all listbox wnds, but they are all the same
	** right now.
	*/
    SetUpScreen();
    FileMgrStatusBar(listinfo[0].tree,listinfo[0].files);
	 ListBoxPath(listinfo[0].tree,listinfo[0].files,0);
	 ListBoxPath(listinfo[1].tree,listinfo[1].files,1);


	/* Cause DriveMouse to recalc where it thinks the drive icons are.
	*/
	listinfo[0].UpdateDrives = TRUE;
	listinfo[1].UpdateDrives = TRUE;

#ifdef DISPLAY_DIFFERENT_TREES_IF_POSS
	listinfo[1].tree = (glob.SelTree[1] != listinfo[0].tree) ? 
								glob.SelTree[1] : glob.SelTree[0] ;
	/* ZZZZZ we have to set the lineselected stuff right too */
#endif

	glob.MaxTree = 1;						/* both trees active		*/

	/* Was this routine called from the menu - that is did tree mode change? */
	if (temp != glob.TreeMode)
	{
		InitGlobalFocus(DRIVELIST0);
	}
	else
	{
		InitGlobalFocus(WhoHasGlobalFocus()) ;
	}

	/* If changing from System Tree mode, deselect tree. Else files may remain
	 * selected in other directories without the user being aware of it!
	 */
	if (temp == TR_SYSTEM && !ginitial && !glob.CrossDirSel)
	{
		DeselectTree(listinfo[0].tree) ;
		listinfo[0].UpdateFiles = TRUE ;
		listinfo[1].UpdateFiles = TRUE ;
	}

	// listinfo[0].UpdateFiles = listinfo[1].UpdateFiles = TRUE ;


	Set_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE,TK_TWOTREE);

} /* proc DoDoubleTree */

BOOL gfFlatLeftInfoDrawn = FALSE ;

VOID FAR DoFlatDisplay()
{
	AY lboxbottom;
	AY i; 					  /* junk int						  */
	int temp ;

#ifndef NOCONSISTENCY
	if (glob.InFileMgr && glob.TreeMode == TR_SYSTEM && !ginitial)
	{
		printf("*** error -- DoFlatDisplay not disabled\n" ) ;
		exit (0) ;
	}
#endif

	gfFlatLeftInfoDrawn = FALSE ;

	TakeDownBusyDialog(0);
	TakeDownBusyDialog(1);

	/* If tree is in compact mode, we can't go into System Tree Mode! */
	if (listinfo[0].tree->Compacted)
	{
		OutOfMemory() ;
		return ;
	}

	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;

	temp = glob.TreeMode ;
	glob.TreeMode = TR_SYSTEM ;

	easyenable(&FileMgrMenuBar, DoFlatDisplay, FALSE) ;

	/* ShowInfo shouldn't be enabled in System Tree Mode!! */
	easyenable(&FileMgrMenuBar, ShowInfo, FALSE) ;

	if (!ginitial)
	{
		if (temp == TR_DOUBLE)
			easyenable(&FileMgrMenuBar, DoDoubleTree, TRUE) ;
		else
			easyenable(&FileMgrMenuBar, DoSingleTree, TRUE) ;
	}
	/* else all menus are turned on by default */

	/* We don't want to start off at initial stage. Tree will get sorted
	   as soon as the whole tree is read in -- see filemgr.c! */
	if (!ginitial)
		SystemSort(listinfo[0].tree, FALSE) ;


	lboxbottom = ayMac - 1 ;

	// i = (AY) LISTBOXTOP+ (glob.DriveCount - 1)/DRIVESPERLINE;
	i = (AY) LISTBOXTOP;

	/* The TreeList is initialized here because the DriveMouse routine uses
	   the TreeList[0]....rect.aytop, etc to draw drives */

	ListBoxInit(&TreeList[0],ListProcTreeList,&MainWind,i,0,lboxbottom,
				TREEBOXWIDTH,szDirectoryTree,tmcTreeList0,0,0);
	gNeedToUpdateFileList[0] = FALSE;
	Always_Explicit(&TreeList[0]);

	ListBoxHalt(&TreeList[0]) ;
	ListBoxInit(&FileList[0],ListProcFileList,&MainWind,i,FLATLEFTWIDTH,
				lboxbottom,FLATLEFTWIDTH+FLATRIGHTWIDTH,
				glob.MatchPat,tmcFileList0,
				/* If tree mode has changed, use 0 for the focuses, else
				 * don't change focus -- pass in the magic value -1.
				 */
				-(temp == glob.TreeMode),-(temp == glob.TreeMode));

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL) ==
														   TK_ENABLED)
		Set_Explicit(&FileList[0]) ;


	SetUpScreen();

	listinfo[0].UpdateDrives = TRUE;
	// listinfo[1].UpdateDrives = TRUE;
	
	glob.MaxTree = 0;							// one tree is active

	/* Was this routine called from the menu - that is did tree mode change? */
	if (	(temp != glob.TreeMode) ||
			(	(WhoHasGlobalFocus() != DRIVELIST0) &&
				(WhoHasGlobalFocus() != FILE0)
			)
		)
	{
		InitGlobalFocus(DRIVELIST0);
	}
	else
	{
		InitGlobalFocus(WhoHasGlobalFocus()) ;
	}


	Set_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE,TK_SYSTEMTREE);

	// listinfo[0].UpdateFiles = TRUE ;

	/* The directory with the focus -- in system tree mode! */
	listinfo[0].files = 
		(listinfo[0].tree->FirstFile) ? 
						FindParent(listinfo[0].tree->FirstFile) : NULL ;
	/* The directory line with check mark will by default be OK!! */


} /* proc DoFlatDisplay */

extern VOID FAR DoAssociateBox();

VOID FAR DoSearchDisplay(BOOL fInitialize)
{
	AY lboxbottom;
	AY lboxtop;

	/*
	 * be sure to draw all icons the first time
	 * through!
	 */
	if(gisgraph)
	{
	    InitIconCache();
	}

	/* This function can be invoked from within SearchMode itself if
	 * the user chose a Repaint Screen in the Search Mode display.
	 */
	if (glob.TreeMode != TR_SEARCH)
	{
		/* Save tree mode, sort key so we can restore the filemgr state
		 * we exit the search mode.
		 */
		gSavedTreeMode = glob.TreeMode ;
		gSavedSortOrder = glob.SortKey ;
		gSavedGlobalFocus = WhoHasGlobalFocus() ;
	}

	/* The Sort routine uses the value in glob.SortKey, glob.TreeMode */
	/* We want to give the user the directory order -- sorted by name */
	glob.TreeMode = TR_SINGLE ;
	SortCmp = SortFnArr[glob.SortKey = SORT_NAME] ;

	FormDirectoryOrder(listinfo[0].tree, FALSE) ;

	/* Clear all selections before entering Search Mode -- 1 reason: Items	*/
	/* like 'view' etc can't be reached if > 1 file selected and the user	*/
	/* once into Search Tree Mode can't operate on (ex: deselect) files not	*/
	/* shown in Search Window.												*/
	if ((fInitialize) && (listinfo[0].tree->NumSel > 0))
		DeselectTree(listinfo[0].tree) ;

	/* We have cheated the sort routine. Now set the TreeMode to TR_SEARCH, so
		that the listbox code can handle the file line display correctly */
	glob.TreeMode = TR_SEARCH ;

	glob.MaxTree = 0 ;

	/* In System Tree mode showinfo is disabled, so enable it now! */ 
	if (gSavedTreeMode == TR_SYSTEM)
		easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
		
	/* Make some of the menu-items non-reachable in Search Mode */
	EnableDisableForSearchMode(FALSE, FALSE) ;

	lboxbottom = ayMac - 1 ;
	lboxtop = 3 ;

	if (fInitialize)
	{
		/* The TreeList is initialized here because the DriveMouse routine uses
	    * the TreeList[0]....rect.aytop, etc to draw drives.
		 */
		ListBoxInit(&TreeList[0],ListProcTreeList,&MainWind,lboxtop,0,
						lboxbottom,TREEBOXWIDTH,szDirectoryTree,tmcTreeList0,
						glob.lineselected[0], glob.lineselected[0]);
		gNeedToUpdateFileList[0] = FALSE;
		Always_Explicit(&TreeList[0]);

		ListBoxHalt(&TreeList[0]) ;

		/* Reusing FileList[0] for SearchFor ListBox! */
		strcpy(szSearchLboxTitle+SEARCH_PAT_IND, glob.MatchPat) ;
		ListBoxInit(&FileList[0],ListProcFileList,&MainWind,lboxtop,
				SEARCHLEFT, lboxbottom,SEARCHLEFT+SEARCHWIDTH, szSearchLboxTitle,
				0,0,0);

		listinfo[0].UpdateFiles = TRUE ;
	}
	else
	{
		ListBoxInit(&FileList[0],ListProcFileList,&MainWind,lboxtop,
				SEARCHLEFT, lboxbottom,SEARCHLEFT+SEARCHWIDTH, szSearchLboxTitle,
				/* Use -1, -1 to leave focus in the same location as before! */
				0,-1,-1);
	}

	/* Clear the listbox area to give it a clean slate!! */
	/* Actually Get_List_Rect gives an absolute rect struct, but it is OK
		in our case, as abs/relative rectangles are isomorphic in structure */
	FillRrc(&MainWind,(PRRC)&(Get_List_Rect(&FileList[0])),' ',isaBackground);

	InitGlobalFocus(FILE0);

	if (!fInitialize)
		UpdateListBox(&FileList[0]) ;

	MessageBar(szSearchMessage, isaMenu,TRUE) ;

} /* proc DoSearchDisplay */

/* Are all files in the whole tree that match MatchPat in a selected state */
BOOL AreAllTreeMatchedSelected(PTREE tree)
{
	PENTRY temp ;

	for (temp = tree->FirstFile ; temp ; temp = temp->x.f.snext)
		if ( (temp->MATCHESPATTERN) && (!(temp->SELECTED)) )
				return (FALSE) ;
	return (TRUE) ;
} /*  AreAllTreeMatchedSelected */

/* Are all files in 'dir' of tree that match MatchPat in a selected state */
BOOL AreAllDirMatchedSelected(PENTRY dir, PTREE tree)
{
	PENTRY temp ;

	/* dir == NULL implies root directory */
	temp = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!temp)
		return TRUE ; /* No files in directory -- trivial case! */

	while (TRUE)
	{
		/* temp is guaranteed to be non-null within this loop! */
		if ( (temp->MATCHESPATTERN) && (!(temp->SELECTED)) )
			return FALSE ;

		if (!temp->LASTDIRFILE)	
			temp = temp->x.f.snext ;
		else
			return TRUE ;
	}
} /*  AreAllDirMatchedSelected */

/* Are all files in the file list box with focus in a selected state -- This
*  is used to determine whether to disable/enable the menu item "Select All" */
AreAllMatchedSelected(PENTRY dir, PTREE tree)
{
	if ( (glob.TreeMode == TR_SYSTEM) || (glob.TreeMode == TR_SEARCH) )
		return AreAllTreeMatchedSelected(tree) ;
	else
		return AreAllDirMatchedSelected(dir, tree) ;
}


/* Returns TRUE iff tree being displayed has been fully read in. This
*  is used to determine if the menu should be disabled in the normal manner
*  (based on files selected) or whether to disable everything except the
*	'exit' file menu (and possibly enter single tree mode?).
*/
BOOL IsTreeBeingBuilt(void)
{
	/* ZZZZ We let the user do anything only if tree 0 has been fully built */
	/* Because changing to/from system-tree mode, search mode, etc operate  */
	/* on tree 0 (i.e., the one in the top list box).						*/
	/* The only restriction this causes is in double tree mode when the tree*/
	/* in box 1 has been read in but the one in box 0 is still being read in */
	/* The user will not be allowed to perform operations in this case.		*/
	return  (listinfo[0].tree->ContinueTree) ;
} /* IsTreeBeingBuilt */

#if 0
/* !!!!!!!!!	     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
/** ZZZZ following functions are unused!! */
unsigned CountTreeSelMatFiles(PTREE tree)
{
	unsigned count ;
	PENTRY temp ;
	
	if (!tree)
		return 0 ;

	for (temp = tree->FirstFile, count = 0 ; temp ; temp = temp->x.f.snext)
		if ((temp->MATCHESPATTERN) && (temp->SELECTED))
			count++ ;

	return count;
}  /* CountTreeSelMatFiles */

unsigned CountDirSelMatFiles(PENTRY dir, PTREE tree)
{
	unsigned count ;
	PENTRY temp ;
	
	/* dir == NULL implies that we want to count files in the root directory */
	temp = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!temp)
		return 0;

	count = ( (temp->MATCHESPATTERN) && (temp->SELECTED) ) ? 1 : 0 ;
	
	while (!temp->LASTDIRFILE)
	{
		temp = temp->x.f.snext ;
		if ( (temp->MATCHESPATTERN) && (temp->SELECTED) )
			count++ ;
	}

	return count;
}  /* CountDirSelMatFiles */
#endif



#ifndef NOGROUPINFILE
VOID FAR DoShareMode(void)
{
	AY size;					/* vertical size of list box	*/
	AY i;
	int temp ;
	int size2;

	TakeDownBusyDialog(0);
	TakeDownBusyDialog(1);

	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;
	else
		/* Are we switching from system tree mode to this mode using menu? */
		if (glob.TreeMode == TR_SYSTEM && !ginitial)
			SetSelectedDirFocus() ; // set up so that tick mark is drawn right 
	temp = glob.TreeMode ;
	glob.TreeMode = TR_SHARE;

	easyenable(&FileMgrMenuBar, DoDoubleTree, TRUE) ;
	easyenable(&FileMgrMenuBar, DoSingleTree, TRUE) ;
	easyenable(&FileMgrMenuBar, DoFlatDisplay, TRUE) ;

	/* If ginitial is false, this function has been invoked from menu! */
	if (!ginitial)
	{
		/* If we are changing from System Tree Mode re-enable ShowInfo menu */ 
		if (temp == TR_SYSTEM)
		{
			easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
		}
	}
	/* else by default all menus are turned on at start up! */

	/* WARNING! Assumption: following will happen only when switching modes
	   from system tree mode. If (ginitial) then it will fail as then
	   (temp == TR_DOUBLE) will be true */
	if ( (temp == TR_SYSTEM) && (glob.SortKey != SORT_DISK))
#ifdef OLDCOMPLETETREESORT
		FormDirectoryOrder(listinfo[0].tree, TRUE) ;
#else
	{
		SetUpTreeForSort(listinfo[0].tree) ;
		SortDirectory(listinfo[0].tree, NULL) ;
		SortDirectory(listinfo[0].tree, listinfo[0].files) ;
	}
#endif

	/* Compute max listbox size.
	*/

	i = (AY) LISTBOXTOP;
	size = (ayMac - i)/2;

	ListBoxInit(&TreeList[0], ListProcTreeList, &MainWind,
				i, 0, i+size, TREEBOXWIDTH, szDirectoryTree, tmcTreeList0,
				glob.lineselected[0],glob.lineselected[0]) ;
	gNeedToUpdateFileList[0] = FALSE;
	Always_Explicit(&TreeList[0]);

	ListBoxInit(&FileList[0], ListProcFileList, &MainWind,
				i, TREEBOXWIDTH, i+size, TREEBOXWIDTH+FILEBOXWIDTH,
				glob.MatchPat, tmcFileList0,
				/* If tree mode has changed, use 0 for the focuses, else
				 * don't change focus -- pass in the magic value -1.
				 */
				-(temp == glob.TreeMode),-(temp == glob.TreeMode));

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL) ==
			 TK_ENABLED)
	{
		Set_Explicit(&FileList[0]) ;
	}

	i += (AY) 1;
	size2 = size << 1;
	if (i+size2 >= ayMac)
	    size2 = ayMac-i-1;
#ifndef NOSWITCHER
#define TASKADJ2 4
   if(gTaskListEnabled)
	{
		/*
		 * Use axmac-40 so the task list will line up with file list,
		 * even in 90 col
	    */
      InitStartProgramList(i+size,0,i+size2,axMac-40-TASKADJ2);
      InitTaskMan(i+size,axMac-40-TASKADJ2,i+size2,axMac);
	}
	else
#endif
	{
	   InitStartProgramList(i+size,0,i+size2,axMac);
	}
   SetUpScreen();
   FileMgrStatusBar(listinfo[0].tree,listinfo[0].files);
	ListBoxPath(listinfo[0].tree,listinfo[0].files,0);

   /* Cause DriveMouse to recalc where it thinks the drive icons are.
   */
   listinfo[0].UpdateDrives = TRUE;

   glob.MaxTree = 0;

	/* Was this routine called from the menu - that is did tree mode change? */
	if (	(temp != glob.TreeMode) ||
			(	(WhoHasGlobalFocus() != DRIVELIST0) &&
				(WhoHasGlobalFocus() != TREE0) &&
				(WhoHasGlobalFocus() != FILE0) &&
				(WhoHasGlobalFocus() != GROUPBOX) &&
				(WhoHasGlobalFocus() != TASKBOX)
			)
		)
	{
		InitGlobalFocus(DRIVELIST0);
	}
	else
	{
		InitGlobalFocus(WhoHasGlobalFocus()) ;
	}

	/* Make sure files don't remain selected in other directories
	 * in the tree without the user being aware of it!
	 */
	if (	(	(temp == TR_SYSTEM) ||
				((temp == TR_DOUBLE) && (listinfo[0].tree == listinfo[1].tree))
			) &&
			!ginitial && !glob.CrossDirSel
		)
	{
		DeselectTree(listinfo[0].tree) ;
		listinfo[0].UpdateFiles = TRUE ;
	}

   // listinfo[0].UpdateFiles = TRUE ;
   Set_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE,TK_SHARED);

} /* proc DoShareMode */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\errbox.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   errbox.c - file mgr generic error & message boxes
**      
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  08/07/89  t-jeffro  created file
**  11/01/89  scottq    rewrote most of this to use listbox code
**  11/08/89  harikris  made changes to GetResponse, DosErrrBox -- param
**                      list different and handles ChangeAttribute.
**  12/06/89  harikris  wrote functions GetAttrResponse, CriticalDialog.
**  12/06/89  harikris  Fixed uses of the listbox code (Inits, len, etc).
**      03/29/90  harikris  wrote function FDelItemDialog
*/
#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>
#include <err.hs>                                  /* files for dialogue box               */
#include <err.sdm>                                 /* ...*/
#include <assert.h>

extern VOID FInitMouseNest(void) ;

/* WARNING! 'attr0's and 'critnew's, delitem's tmcs should be the same as 'err's
	    tmcs as they both use the same dialog handler 'FDlgerr' */

#define tmcattr0help        tmcerrhelp
#define tmcattr0status      tmcerrstatus
#define tmcattr0msg             tmcquerymsg
#define tmcattr0list        tmcerrlist

#include <attr0.hs>
#include <attr0.sdm>

#define tmccritnewhelp     tmcerrhelp
#define tmccritnewstatus        tmcerrstatus
#define tmccritnewmsg      tmcquerymsg
#define tmccritnewlist     tmcerrlist

#include <critnew.hs>
#include <critnew.sdm>

#define tmcdelitemhelp      tmcerrhelp
#define tmcdelitemstatus        tmcerrstatus
#define tmcdelitemmsg       tmcquerymsg
#define tmcdelitemlist      tmcerrlist

#include <delitem.hs>
#include <delitem.sdm>


/*              Note that all the following "globals" are static because no other
**              modules should need to examine or change them.
*/

/* We currently have a maximum of 3 lines in the choices we give user!
	example: BT_RETRYQUIT below! */
static struct {
	char *msg;            // message for that line
	int retval;           // we return this if selected
} lines[3];                   // one rec for each msg line

static int maxline;           // last valid index in lines[]

static int curline;           // selected line

/* The following three are global and are reused in fn ChangeAttributes */
char *QStatus;                // Status line in GetResponse box.

char *QMessage;              // the error msg to respond to

ListBoxData ErrList;


/*
*  This routine handles the case of a listbox (without scroll bars - 'stupid')
*  within a dialog box. This is typically called when an error has occured, etc
*  and the user is required to choose one of several options.
*  The user's selection is communicated to the caller using the global variable
*  'curline' -- Example: If there are 3 choices, curline will be set to 0, 1, or
*       2 (i.e., the base is 0). The global variable 'ErrList' has the listbox
*  coordinates. The caller takes responsibility to initialize this before
*  control passes to this routine.
*/
WORD PASCAL ListProcErrList(WORD tmm, char *sz, WORD isz, TMC tmc,
											WORD x, WORD y, WORD bArg)
{
	RX xval;
	unsigned char messagestr[60]; /* 60 >= max length of any message */
	int i;
	ISA isa ;
	int len;

	UnReferenced(tmc) ;
	UnReferenced(x) ;

	xval = Get_List_Rect(&ErrList).axLeft;
	switch (tmm) {
		case tmmCount:
			return(maxline+1);

		case tmmGetItemString:
			/* Note that at this time we don't have > 10 items */
			assert(isz < 10) ;

			/* Return character '1' for item 0, '2' for item 1, etc  */
			/* This enables moving thru choices without having to use*/
			/* the up/down arrow keys. One can use the appr. digit.  */
			*sz = (char) isz + '1' ;
			*(sz+1) = '\0' ;
			break ;

		case tmmSetFocus:
		case tmmSelect:
			/* ignore these messages! */
		   break;

		case tmmActivate:
		     if ( (maxline <  0) || (isz > maxline) )
					return 0 ; /* garbage value!! -- Bad select message */
		     curline = isz;
		     EndDlgTmc(tmcOK);
		     break;

		case tmmDrawItem:
			/* The '-2' in the following line takes care of the scrollbar
				width even though it is a 'stupid' listbox */
		len = Get_List_Rect(&ErrList).axRight - xval - 2;
		    if ( (maxline >= 0) && (isz <= maxline) )
		    {
		      messagestr[0] = (BYTE) ' ' ;
		      messagestr[1] = (BYTE) '1'+isz;
		      for(i=2;lines[isz].msg[i-2];i++)
		      {
			   messagestr[i] = lines[isz].msg[i-2];
		      }
		      for(;i<len;i++)
		      {
			  messagestr[i] = ' ';
		      }
			  if (bArg & TF_ISFOCUS)
			  {
				 curline = isz ; /* this is the line with focus!! -- So if the
									user types enter this what he desires */
				 isa = (ISA) bArg ;
			  }
			  else
				isa = isaDialogBox ;
		      TextOut(ErrList.pwd,(RX) xval,(RY) y+1,messagestr,len,isa);
		    }
			break;

		default:
			break;
	}
	return TRUE;
} /* ListProcErrList */

char *gpszFileOpCaption ; /* File Operation caption in the dialog box */

LONG FAR PASCAL pfnErrList(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    UnReferenced(pwnd);
    UnReferenced(wParam);
    UnReferenced(LParam);

    switch(message) {
    case WM_PAINT:
	UpdateListBox(&ErrList);
	break;

    default:
	return(FALSE);
    } /* switch */

    return(TRUE);
}

/* Warning! that this dialog is not re-entrant as it uses global variables like
	gpszFileOpCaption, curline, ErrList, etc. So Dialog boxes that use this
	function should be mutually exclusive (no two of them should be active
	at the same time). Currently critnew, attr0, err, use this function! */
BOOL FAR PASCAL FDlgerr(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	PWND  dwind;
	PWND  lwind;

	UnReferenced(tmc) ;

	dwind = PwndParent(PwndOfListbox(tmcOK));
	switch(dlm)
	{
	    case dlmInit:
		   SetUpDialog(tmcOK,gpszFileOpCaption) ;

		   SetUpButtonForGraphics(tmcOK) ;
		   SetUpButtonForGraphics(tmcCancel) ;
		   SetUpButtonForGraphics(tmcerrhelp) ;

	       /* The next few lines initialize a listbox. The list
		  box will hang just below, and have the same x coordinates
		  as tmcerrlist
	       */
	       lwind = PwndOfListbox(tmcerrlist);
		   SetWindowProc(lwind, pfnErrList);
	       ListBoxInit(&ErrList,ListProcErrList,dwind,
							lwind->arcWindow.ayTop-dwind->arcWindow.ayTop,
							lwind->arcWindow.axLeft-dwind->arcWindow.axLeft,
							lwind->arcWindow.ayTop-dwind->arcWindow.ayTop+4,
							lwind->arcWindow.axRight-dwind->arcWindow.axLeft+1,
							NullString,0,0,0);
	       MakeListStupid(&ErrList);

	       Shell_SetTmcText(tmcerrstatus, QStatus);
	       Shell_SetTmcText(tmcquerymsg, QMessage);

	    if(((PDLG)&dlgerr)->hid == hidERR ||
		    ((PDLG)&dlgerr)->hid == hidCRIT)
			    gCurrentTMC = tmcerrhelp;
		   break;

	    case dlmIdle:
			ListBoxIdle(&ErrList);
			break;

	    case dlmClientMouse:
			ListMouse(&ErrList, LOBYTE(wParam), HIBYTE(wParam)-1, wNew, wOld);
			break;

	    case dlmKey:
			/* ZZZZZZ shift state right?? */
			ListKey(&ErrList,wNew, 0);
			break;

		case dlmSetFocus:
			gCurrentTMC = tmc;
			break ;

		case dlmClick:
			if(tmc == tmcerrhelp)
				Help(hemDialog, ((PDLG)&dlgerr)->hid, NULL, 0);

			 SetFocusTmc(gCurrentTMC) ;
			 break ;

	}
	return(TRUE);
}

/* Set up the various options and ask the user to select one of the many
*  options displayed to him. This routine gets the response of the user */
int GetResponse(char *statusline, char *msg, int boxtype, unsigned helpid)
{
	HCABerr h = HcabAlloc(cabiCABerr);
	TMC tmc;

	if (!h)
	{
		OutOfMemory() ;
		return ACT_NOMEM ;
	}

	gErrHelpId = (char) helpid ;
	((PDLG)&dlgerr)->hid = hidERR;

	InitCab(h, cabiCABerr) ;

	SzToCab(h, szEnterButton, Iag(CABerr, pszerrEB));
	SzToCab(h, szCancelButton, Iag(CABerr, pszerrCB));
	SzToCab(h, szHelpButton, Iag(CABerr, pszerrHB));

	/* Init "list box" lines -- i.e., the various choices. */
	switch (boxtype)
	{
		case BT_SKIPQUIT:
			lines[0].msg = szSkipLine;
			lines[0].retval = ACT_SKIP;
			lines[1].msg = szCancelLine;
			lines[1].retval = ACT_CANCEL;
			maxline = 1;
			break;
		case BT_RETRYSKIPQUIT:
			lines[0].msg = szRetryLine;
			lines[0].retval = ACT_RETRY;
			lines[1].msg = szSkipLine;
			lines[1].retval = ACT_SKIP;
			lines[2].msg = szCancelLine;
			lines[2].retval = ACT_CANCEL;
			maxline = 2;
			break;
		case BT_SKIPRETRY:
			lines[0].msg = szSkipLine;
			lines[0].retval = ACT_SKIP;
			lines[1].msg = szRetryLine;
			lines[1].retval = ACT_RETRY;
			maxline = 1;
			break;
		case BT_FILESKIPQUIT:
			lines[0].msg = szSkipFileLine;
			lines[0].retval = ACT_SKIP;
			lines[1].msg = szCancelLine;
			lines[1].retval = ACT_CANCEL;
			maxline = 1;
			break;
		case BT_FILERETRYSKIPQUIT:
			lines[0].msg = szRetryFileLine;
			lines[0].retval = ACT_RETRY;
			lines[1].msg = szSkipFileLine;
			lines[1].retval = ACT_SKIP;
			lines[2].msg = szCancelLine;
			lines[2].retval = ACT_CANCEL;
			maxline = 2;
			break;
		case BT_QUIT:
		default:
			maxline = -1;
			break;
	} /* switch boxtype */

	QStatus = statusline ;
	QMessage = msg;

	curline = 0;

	/* Re-enable the mouse as it could have been disabled when we put up
	 * the status message.
	 */
	FInitMouseNest() ;

	tmc = MyTmcDoDlg(&dlgerr,  h); /* causes execution of FDlgErr */

	FreeCab(h);

	if ( (tmc == tmcOK) && (curline >= 0) && (curline <= maxline) )
		return lines[curline].retval;
	else
		return ACT_CANCEL;

} /* GetResponse */


/****   DOSErrorBox     - pops up dlg in response to given DOS error.
**
**      ENTRY
**                      statusline  -  The status message like Copying File...
**                      err   - DOS error code
**                      helpid- help id to pass to GetResponse()
**      EXIT
**                      action code, see GetResponse() for enumeration
**      EFFECTS
*/

int DOSErrorBox(char *statusline, WORD err, unsigned helpid)
{
	int boxtype;                                            // which form of listbox to use
	char *msg;                                                      // error message to display

	msg = DOSErrorMsg(err, &boxtype);
	return GetResponse(statusline, msg, boxtype, helpid);
} /* proc DOSErrorBox */

char *DOSErrorMsg(int errcode, int *box)
{
	int boxtype;
	char *msg;

	switch (errcode)
	{
		case 1: case 4: case 6: case 7: case 9:
		case 10:	case 11: case 16:
		case 18: case 35: case 36: case 38:
					msg = szConfused;	boxtype = BT_QUIT;	break;

		case 2: msg = szFileNotFound;   boxtype = BT_SKIPQUIT;	break;
		case 3: msg = szPathNotFound;   boxtype = BT_SKIPRETRY;	break;

		case 5: case 13: case 17:
			msg = szAccessDenied;	boxtype = BT_SKIPRETRY;	break;

		case 8: case 12:
			msg = szOutOfMemory;    boxtype = BT_QUIT;	break;

		case 14: msg = szUnknown;	boxtype = BT_QUIT;	break;
		case 15: msg = szInvalidDrive;   boxtype = BT_SKIPQUIT;          break;
		case 19: msg = szWriteProtect;   boxtype = BT_RETRYSKIPQUIT; break;

		case 20: case 22: case 23: case 24: case 25: case 26: case 27: case 31:
					msg = szBadDisk; boxtype = BT_RETRYSKIPQUIT; break;

		case 21: msg = szDriveNotReady;  boxtype = BT_RETRYSKIPQUIT; break;

		case 28: case 29:
			msg = szWriteError; boxtype = BT_RETRYSKIPQUIT; break;

		case 30:msg = szReadError; boxtype = BT_RETRYSKIPQUIT; break;

		case 32: case 33:
					msg = szFileLocked; boxtype = BT_RETRYSKIPQUIT; break;

		case 34:msg = szWrongDisk; boxtype = BT_RETRYSKIPQUIT; break;

		case 37:
		default: msg = szUnknown;                boxtype = BT_RETRYSKIPQUIT;     break;
	}
	if (box)
		*box = boxtype;
	return msg;
} /* proc DOSErrorMsg */

int GetAttrResponse(void)
{
	HCABattr0 h = HcabAlloc(cabiCABattr0);
	TMC tmc;

	if (!h)
	{
		OutOfMemory() ;
		return ACT_NOMEM ;
	}

	((PDLG)&dlgerr)->hid = hidATTR0;
	InitCab(h, cabiCABattr0) ;

	SzToCab(h, szEnterButton, Iag(CABattr0, pszattr0EB));
	SzToCab(h, szCancelButton, Iag(CABattr0, pszattr0CB));
	SzToCab(h, szHelpButton, Iag(CABattr0, pszattr0HB));

	lines[0].msg = szModifySingly;
	lines[0].retval = ACT_SINGLE;
	lines[1].msg = szModifyTogether;
	lines[1].retval = ACT_ALL;
	maxline = 1;

	QStatus = NullString ;
	QMessage = NullString ;

	curline = 0;

	tmc = MyTmcDoDlg(&dlgattr0,  h); /* Actually executes FDlgErr */

	FreeCab(h);

	if (tmc == tmcOK)
		return lines[curline].retval;
	else
		return ACT_CANCEL;

} /* GetAttrResponse */

extern BYTE ErrorCrit ;

BOOL CriticalDialog()
{
	HCABcritnew     h;
	TMC tmc ;
    char *fcaption ;

	/* Save the FileOp Caption -- so that we can restore it once this critical
		error dialog is done. This global (gpsz...) is used by FDlgerr */
	fcaption = gpszFileOpCaption ;
	gpszFileOpCaption = szCritWarning ;

	h = HcabAlloc(cabiCABcritnew);
	if (!h)
	{
	    OutOfMemory() ;
	    return 1 ; /* garbage value -- return don't read disk again!! */
	}
	DialogIsAlert(TRUE) ;
	((PDLG)&dlgerr)->hid = hidCRIT;

	InitCab(h, cabiCABcritnew) ;

	SzToCab(h, szEnterButton, Iag(CABcritnew, pszcritnewEB));
	SzToCab(h, szCancelButton, Iag(CABcritnew, pszcritnewCB));
	SzToCab(h, szHelpButton, Iag(CABcritnew, pszcritnewHB));

	lines[0].msg = szCritDoRead ;
	lines[0].retval = 0;
	lines[1].msg = szCritDontRead ;
	lines[1].retval = 1;
	maxline = 1;

	QStatus = szCriticalMessages[ErrorCrit] ;
	QMessage = NullString ;

	curline = 0;

	tmc = MyTmcDoDlg(&dlgcritnew,h) ; /* Actually executes FDlgErr */

	FreeCab(h);

	/* restore fileop caption */
	gpszFileOpCaption = fcaption ;

	DialogIsAlert(FALSE) ;

	if (tmc == tmcOK)
		return lines[curline].retval;
	else
		return 1; /* Don't retry */
} /* CriticalDialog */

/* Puts up a dialog box & confirms whether to delete the item or not.
 * Returns a BOOL of TRUE iff the user says OK to delete.
 */
BOOL FDelItemDialog(char *theMessage)
{
	HCABdelitem     h;
	TMC tmc ;

	gpszFileOpCaption = szDeleteItemCaption ;

	h = HcabAlloc(cabiCABdelitem);
	if (!h)
	{
	    OutOfMemory() ;
	    return FALSE ;      /* do not delete item -- don't know what user wants! */
	}
	InitCab(h, cabiCABdelitem) ;
	((PDLG)&dlgerr)->hid = hidDELITEM;

	SzToCab(h, szEnterButton, Iag(CABdelitem, pszdelitemEB));
	SzToCab(h, szCancelButton, Iag(CABdelitem, pszdelitemCB));
	SzToCab(h, szHelpButton, Iag(CABdelitem, pszdelitemHB));

	lines[0].msg = szDeleteItem ;
	lines[0].retval = TRUE ;
	lines[1].msg = szDontDeleteItem ;
	lines[1].retval = FALSE ;
	maxline = 1;

	QStatus = NullString ;
	QMessage = theMessage ;

	curline = 0;

	tmc = MyTmcDoDlg(&dlgdelitem, h) ; /* Actually executes FDlgErr */

	FreeCab(h);

	if (tmc == tmcOK)
		return lines[curline].retval;
	else
		return FALSE ;
} /* FDelItemDialog */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\drive.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

?WIN = 0                ;Not windows;
?PLM =	  1		;DO use PL/M calling conventions

FLOPPY_TYPE EQU 1
REMOTE_TYPE EQU 2
HARDDISK_TYPE  EQU 3
RAMDRIVE_TYPE EQU 4
CDROM_TYPE EQU 5
include cmacros.inc

sBegin code
    assumes cs, code
    assumes ds, DGROUP

;
; int getdrivetype(int driveno)
;
cProc  getdrivetype, PUBLIC,  <si,di,ds,es>
parmW driveno
cBegin	getdrivetype
    ;;;; first check is for CDROM
    mov ax,0150bh
    xor bx,bx
    mov cx,driveno
    dec cx
    int 2fh
    cmp bx,0ADADh
    jne notCDROM
    cmp ax,0
    je notCDROM
    mov ax,CDROM_TYPE
    jmp dt_end
notCDROM:
    ;;;;

    mov ax, 4409h
    mov bx, driveno
    int 21h
    jc dt_not_found
    and dh, 10h
    jz	dt_local_check

    mov ax, REMOTE_TYPE
    jmp short dt_end

dt_local_check:
    mov ax, 4408h
    int 21h
    ; ZZZZ
    ; WARNING!! assuming that drive is non-removable as call 1 succeeded!
    ; WINDOWS FM seems to do the same!
    ; jc	dt_not_found
    jc	dt_nonremovable
    or	ax, ax
    jz	dt_removable

dt_nonremovable:
    mov ax, HARDDISK_TYPE
    jmp short	dt_end

dt_removable:
    mov ax, FLOPPY_TYPE
    jmp short dt_end

dt_not_found:
    xor ax, ax

dt_end:

cEnd  getdrivetype

sEnd   code


end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\filemgr.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	filemgr.c - file mgr proc's called from main() and from menus
**
**   Date      Author	Modification
** --------   --------	------------------------------------------------
**  7/17/89   t-jeffro	Moved from main.c
*/
#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <icons.h>
#include <assert.h>

#ifdef KANJI
#include <kkcfltr.h>
#endif

// Lets you compile in debug mode without running out of near heap
//  #define DEBUG  
#ifndef DEBUG
#include <prot.h>
#else
extern BOOL FAR Get_Date_and_Time_Strings(unsigned int theDate, unsigned int theTime,
      char *datestr, char *timestr, BOOL force) ;
extern VOID FEnableMouseNest(BOOL onoroff) ;
extern  int Tree2Path(PTREE tree,PENTRY node,char *str, int *plength);
extern  void InitFileMgr(void );
extern  void far *pascal far LpbAllocWorkFar(unsigned short cb);
extern  void pascal far OutOfMemory(void );
extern  void DoExit(void );
extern  void strfcpy(char far *dst,char far *src);
extern  int GetDiskInfo(PTREE tree,char far *disklabel,unsigned long far *disksize,
											unsigned long far *diskavail) ;
extern	int fstrncmp(char const far *nstr,char const far *fstr,int len);
extern int	Check_Spooler(void) ;
extern	void UpdateMainTitleBar(char *szTitle);
extern  void setmenubar(struct _mnu * * *amenu,struct _wnd *towind);
extern  void FrameMenuBar(struct _wnd *pwnd);
extern  void InitIconCache(void );
extern VOID PutUpBusyDialog(int ith);
extern VOID TakeDownBusyDialog(int ith);
extern  void UpdateListBox(struct ListBoxData *TestList);
extern unsigned char far cdecl GET_WAIT_FLAG(void);
extern VOID DoSwapIn(void) ;
extern  void DoSingleTree(void );
extern  void DoDoubleTree(void );
extern  void DoFlatDisplay(void );
extern void EnableDisableForSearchMode(BOOL doenable1, BOOL doeanble2) ;
extern  BOOL MarkAllTreeMatches(struct th_t far *tree,int doit);
extern  void DeselectTree(struct th_t far *tree);
extern void SetUpTreeForSort(PTREE tree) ;
extern	void SystemSort(PTREE tree, int doit);
extern void SortDirectory(PTREE tree, PENTRY dir) ;
extern  void ExitFileMgr(void );
extern void InitializeStartPrograms(void);
extern	int FileMgrIdle(void );
extern  void UpdateFileTree(int set);
extern  void UpdateDrives(void );
extern  void DoRedisplayList(struct ListBoxData *TestList);
extern	int ListBoxIdle(struct ListBoxData *TestList);
extern	void ListKey(struct ListBoxData *TestList,unsigned short key, unsigned short state);
extern  int GetNextFile(char *path,PTREE tree,PENTRY rptr,int first, int ParentPathLength);
extern  int LoadCompactDir(PTREE tree, PENTRY new);
extern  void Marklastdir(PTREE tree);
extern  void InsertListItem(struct ListBoxData *TestList,unsigned short isz);
extern	void PlotBmp(struct BITMAP *bmp,unsigned short x,unsigned short y,ISA color);
extern  void FocusLineChange(struct ListBoxData *TestList,int amt);
extern  void JunkTree(PTREE tree);
extern  void InitGlobalFocus(unsigned short focusstart);
extern  PENTRY AddFile(PTREE tree);
#endif
#include <errno.h>

extern void  Get_CWD(char *);
extern void InvalidateIconCache(AX axLeft, AY ayTop, AX axRight, AY ayBottom);
extern VOID ListBoxPath(PTREE tree,PENTRY node,int whichtree) ;
extern VOID RefreshStartPrograms(VOID);
extern void MarkGlobalFocus(WORD focus) ;
extern void HandleSpecialCaseNovell(PTREE tree) ;
extern void RefreshViewFileScreen(BOOL fClearAndRedraw) ;
extern VOID MySetColor(WORD color);
extern BOOL IsMenuDown(void) ;
extern void SetGlobalFocusBox(WORD GlobalFocus) ;

extern BOOL gMouseDown;
extern int gNumHelps; /* number of times help has been re-entered */
extern GlobalIdle(void);
extern char far *gIconCache;
extern BOOL gfRepaintonidle;

/*
**							  Global variables
*/
global_t glob;						
char gFMGRStatus[FMGRSTATUSMAX];
extern struct ListBoxData ProgramList;
BOOL PDisable ; // Whether print.com has been run or not.
BOOL gfFMVisited = FALSE ; // says whether the FM was ever visited by the user.

/* Flag specifying whether sorts are by ascending/descending order. */
WORD gDescendingOrder ;

/* List boxes */
struct ListBoxData TreeList[2];
struct ListBoxData FileList[2];

filelistinfo listinfo[2];	 /* binds tree to list box -- 1 extra for Search */

drivelist    gDriveList[NUMDRIVELISTS];
BYTE	     gHighlightedDrive[2];
BYTE	     gSelectedDrive[2];

/* Menu stuff for DoFileMgr
*/
extern MENUINFO MainMenuBar;
extern MENUINFO FileMgrMenuBar;

extern BOOL gfFileMgrStartUp ; /*whether user starts up in FileMgr mode or not*/

extern WORD gCnx;

/* Message Bar text displayed at bottom of screen. This is used to restore 
 * screen in case we put up a swap floppy message and destroy it.
 */
char *gpszNonSwap ;

BOOL gfFMBeingInited ;

/*Number of spaces to the right of the ADD mode msg at the bottom of screen*/
#define ADD_MSG_RSIDE_SPACES 10 
#define TIME_STR_LEN 6

extern WORD gMouseY;
/* Displays the message 'message' at bottom of screen in the color 'isa'. In
 * graphics mode, a box is also drawn at the bottom row.
 */
VOID MessageBar(char *message, ISA isa,WORD force)
{
	WORD i;
	WORD j;
	char datestring[12];
	static char timestring[12];
	char padded[92] ; // shell won't run in any mode > 90 col mode!!
	BOOL turnmouseoff;
	int ADDMessageLen ;

	if(isa == isaMenu)
		isa = isaMessagebar;

	ADDMessageLen = strlen(szAdd) ;

#ifdef KANJI
	if ( ((force==-1) ||
		 Get_Date_and_Time_Strings(0, 0, datestring,timestring,force))
		 && (!fKkcEnabled || !FActiveKkc()) )
#else
	if ((force==-1) ||
		 Get_Date_and_Time_Strings(0, 0, datestring,timestring,force))
#endif
    {
       for(i=0; (message[i] && (i < axMac)); i++)
		   padded[i]=message[i];

	  for(j=i;j<axMac-ADD_MSG_RSIDE_SPACES-ADDMessageLen;j++)
		      padded[j] = ' ';

	  // implicit/explicit (ADD mode) state of focused list box
	  switch(WhoHasGlobalFocus())
	  {
			case FILE0:
			case FILE1:
				// Explicit or Add mode
				if(FileList[WhoHasGlobalFocus() == FILE1].mode == 0)
				{
					strncpy(padded+j, szAdd, ADDMessageLen) ;
					padded[j+ADDMessageLen] = ' ' ; // put a trailing blank
					j += (ADDMessageLen+1) ;
					break;
				}
				// else fall through

			default:
	  			for(;j<=axMac-ADD_MSG_RSIDE_SPACES;j++)
		      	padded[j] = ' ';

	  }
     padded[j++] = ' ';
	  i = j;
	  for(; j<i+TIME_STR_LEN; j++)
			  padded[j] = timestring[j-i];
     padded[j++] = ' ';
	  i = j;

     for(;i<axMac;i++)
		   padded[i] = ' ';

	   if (message != szSwapDiskMessage)
		   gpszNonSwap = message ; // gpszNonSwap is used by TakeDownSwapMsg

		if(gMouseY >=ayMac-2)
		{
		   turnmouseoff = TRUE;
         FEnableMouseNest(FALSE);
		}
		else
		{
			turnmouseoff = FALSE;
		}
#if 1
		 /* In order to reduce screen flicker, we draw each character
        * one at a time, and draw the line above it before continuing
		  */
       if (gisgraph)
       {
            WORD fore, back;

		   	SetAreaPat(0);
		   	SetLinePat(1);
            GetIsaColor(isaBackground, &fore, &back);
            MySetColor(fore);
       }
		 for(i=0;i<axMac;i++)
		 {
#ifdef KANJI
			if (IsDBCSLeadByte(padded[i]))
			{
				CharOut(&MainWind,(RX) i,(RY) ayMac-1,(padded[i]&0xff)|(padded[i+1]<<8),isa);
				i++;
			}
			else
				CharOut(&MainWind,(RX) i,(RY) ayMac-1,padded[i],isa);
#else
			CharOut(&MainWind,(RX) i,(RY) ayMac-1,padded[i],isa);
#endif
       	if (gisgraph)
       	{
	   		if(CHEIGHT > SMALLHEIGHT)
	   		{
		   		Move(i*CWIDTH,((ayMac-2)+1)*CHEIGHT);
		   		Draw((i+1)*CWIDTH,((ayMac-2)+1)*CHEIGHT);
	   		}
       	}
		 }
#endif
#if 0
       TextOut(&MainWind,0,(RY) ayMac-1,padded,axMac,isa);

       /* Draw box around message bar at bottom of screen. */
       if (gisgraph)
       {
	   	if(CHEIGHT > SMALLHEIGHT)
	   	{
		   	SetAreaPat(0);
		   	SetLinePat(1);
		   	SetColor(0,0x7FFF);
		   	Move(0,((ayMac-2)+1)*CHEIGHT);
		   	Draw((axMac)*CWIDTH,((ayMac-2)+1)*CHEIGHT);
	   	}
       }
#endif
		 if(turnmouseoff)
          FEnableMouseNest(TRUE);
    }
} /* MessageBar */

/* This routine is called from assembly with stack pointing to a local
 * stack of 256 bytes only!! So, don't use too many locals or have too
 * many nested function calls!!
 */
void PutUpSwapMsg(int swapdrive)
{
	extern unsigned char gDriveLetterOffset ; /* offset of drive letter ('?') in str */

	/* low byte of  'swapdrive' specifies the code for new drive  */
	/* high byte of 'swapdrive' specifies the code for disk in drive */
	szSwapDiskMessage[gDriveLetterOffset] = (uchar)('A' + (swapdrive & 0x0F)) ;

	/* ZZZZZ should this be Beep() ? If beeps disabled, it will
	 *  probably not attract user attention
	 */
	Shell_Beep() ;

	/* -1 as last param specifies not to make DOS call to get time */
	MessageBar(szSwapDiskMessage, isaAlert, -1) ;
	Shell_Beep() ;
}

void TakeDownSwapMsg(void)
{
	/* -1 as last param specifies not to make DOS call to get time */
	MessageBar(gpszNonSwap, isaMenu, -1) ;
}

#ifdef YUKKY
VOID DriveMessage(char *message)
{
    char padded[256];
    int i;
    for(i=0;((message[i]) && (i<axMac));i++)
	padded[i]=message[i];
    for(;i<axMac;i++)
    {
	padded[i] = ' ';
    }
    TextOut(&MainWind,(RX) 0,(RY) 2,padded,axMac,isaDrivebox);
}
#endif

/****	FileMgrStatusBar - display current directory in status bar
**
**	ENTRY
**		tree - tree of current directory
**		node - node of current directory
**	EXIT
**		none
*/
VOID FileMgrStatusBar(PTREE tree, PENTRY node)
{
    WORD i;
	 static BYTE lastlen=255;
    BYTE len;
    char padded[256];
	 int dummylen ;

	 if (!IsMenuDown())
	 {
    	padded[0] = ' ';
    	padded[1] = ' ';
    	Tree2Path(tree, node, &padded[2], &dummylen);
    	len = (BYTE) strlen(padded);
    	for(i=len;i<min(axMac,lastlen);i++)
			padded[i]=' ';
	 	lastlen = len;
    	FEnableMouseNest(FALSE);
    	TextOut(&MainWind,0,(RY) FMGRSB,padded,i,isaDrivebox);
    	FrameMenuBar(&MainWind);
    	FEnableMouseNest(TRUE);
	 }
}

VOID CalcDriveIconPositions(void)
{
   BYTE    IconX;
	BYTE	IconY;
	int 	i;

    IconX = DRIVEICONSTARTX;
    IconY = DRIVEICONSTARTY;

		for(i=0;i<glob.DriveCount;i++)
		{
			gDriveList[0][i].IconX = IconX;
			gDriveList[0][i].IconY = IconY;
			gDriveList[1][i].IconX = IconX;
			gDriveList[1][i].IconY = IconY+ (ayMac-LISTBOXTOP)/2 + 2 ;

			IconX += DRIVESHIFT;
			if(i== (DRIVESPERLINE-1) )
			{
				IconX = DRIVEICONSTARTX;
				++IconY;
			}
		}
 }



/*
 * Given a drive number 0 = default, 1 = A, 2 = B, etc. returns the drive
 * type FLOPPY_TYPE, or REMOTE_TYPE, or HARDDISK_TYPE, or 0 for 
 * non-existence.
 * USES intdos function!!
 * if intdos function was unsuccesful returns drivetype of 0.
*/
int getdrivetype(int driveno) ; /* function written in assembly */


/*
**							     Procedures
*/
/****	InitFileMgr - one-time initialization of file manager structures
**
**
**	ENTRY
**		none
**	EXIT
**		none
**	EFFECTS:
**	    voluminous.
*/
VOID InitFileMgr()
{
	char c;
	char test[1+MAX_PATH];
	treehdr far *tree;
	treehdr far *lasttree = NULL;
	int typ;
	BYTE	whichdriveicon;
	int token ;

	gfFMBeingInited = TRUE ;

	// Set lists focus to 0 as default; may get reset later if swap in
	Set_List_Focus(&FileList[0],0);
	Set_List_Focus(&FileList[1],0);

	strcpy(test, "A:\\");
    glob.DriveCount = 0;
	/*
	 * WARNING! Assumes Token order of sortkeys!!!!
	 */
	glob.SortKey = Get_KeyWord_Assignment(TK_SAVESTATE,TK_SORTKEY)-
			 TK_NAME;
	if ((glob.SortKey < SORT_NAME) || ( glob.SortKey > SORT_DISK))
	    glob.SortKey = SORT_NAME ;
	SortCmp = SortFnArr[glob.SortKey] ;

    for (c='A'; c <= 'Z'; c++)
    {
	    test[0] = c;
#if 0
		/* We don't make any such assumptions anymore, previously, we
		 * used to hit the floppy to figure out what it was!
		/* If c == 'A' or 'B' we assume its presence and is local-removable */
	    if (c < 'C')
			typ = FLOPPY_TYPE;
		else
#endif
		/* translate 'A' to 1, 'B' to 2, etc. */
		if (!(typ = getdrivetype(c - 'A' +1)))
			continue; /* This drive letter doesn't exist so, check next one */

		/* drive exists, add to list.  */
		tree = LpbAllocWorkFar(sizeof(treehdr));
		// printf("tree struct size=%d\n", sizeof(treehdr)) ; 
		if (!tree)
		{
			OutOfMemory();
			DoExit();
#ifdef DEBUG
			printf("*** Couldn't read drives\n") ;
			exit(0) ;
#endif
		}

		gDriveList[0][glob.DriveCount].tree = tree;
		gDriveList[1][glob.DriveCount].tree = tree;

		glob.DriveCount++;

		if (lasttree)
			lasttree->next = tree;
		else
			glob.drives = tree;
		lasttree = tree;
		
		/* Init tree structure.
		*/
		strfcpy(tree->root, test);
		strcpy(glob.MatchPat, szStarDotStar);
		tree->next = NULL;
		tree->head = NULL;
		tree->pagehead = NULL;
		tree->pagetail = NULL;
		tree->freeind = PAGESIZE ; /* will mean no free entry in page */
		tree->holecount = 0 ; /* Initially no holes are present */
		tree->DirCount = 0;
		tree->VisibleDirCount = 0;
		tree->filecount = 0;
		tree->Diskfilecount = 0;
		tree->FirstFile = NULL;
		tree->LastFile = NULL;
		tree->FirstDirectory = NULL;
		tree->LastDirectory = NULL;
		tree->Started = FALSE;
		tree->Compacted = FALSE;
		tree->fdiskinfoknown = FALSE ;
		tree->SortRequired = TRUE ;

		tree->SelDir = NULL ; // Initial default directory for each drive is
									 // its root directory.
		tree->SelLine = 0 ;	 // Root directory will be the first line (0).

	 	/* Default value for mpat */
		strfcpy(tree->mpat, szStarDotStar) ;
		tree->nummatches = RECALCNUMMATCHES;
		tree->skey = tree->tmode = -1 ; /* Garbage - Non-Sort order/tree mode */
		
		/* Initially, the initialization to "matchespattern" bit for each file
		 * is set to TRUE, hence this is equivalent to being TRUE for the 
		 * tree!
		 */
		tree->DisplayHiddenFiles = TRUE ;

	   tree->NumSel = 0 ; /* Initially no file in tree is selected */
		tree->SizeSel = 0 ;
		/*
		 * We only get this information here&now so we can check the volume
		 * label to see if it is the Microsoft Ramdrive (c)...We don't have
		 * a reliable way to detect any other ramdisk
		 */

		if(typ == HARDDISK_TYPE)
		{
		   if (GetDiskInfo(tree, tree->VolLabel, &tree->SizeTotal,
																			&tree->SizeAvail))
		   {
			   tree->fdiskinfoknown = TRUE ;
			   if (	(fstrncmp(tree->VolLabel, szMSRamdrive,
																strlen(szMSRamdrive)) == 0) ||
			   		(fstrncmp(tree->VolLabel, szVDisk, strlen(szVDisk)) == 0) ||
			   		(fstrncmp(tree->VolLabel, szRDv, strlen(szRDv)) == 0)
					)
					typ = RAMDRIVE_TYPE;
		   }
		}
		tree->DriveType = typ;
		     
	}

	Get_CWD(test); //internal getcwd command
   c = test[0];
	tree = glob.drives;

	CalcDriveIconPositions();
	whichdriveicon = 0;
	while (tree && tree->root[0] != c)
	{
		++whichdriveicon;
		tree = tree->next;
	}
    
	// Init globals. 
	gHighlightedDrive[0] = whichdriveicon;
	gHighlightedDrive[1] = whichdriveicon;
	gSelectedDrive[0] = whichdriveicon;
	gSelectedDrive[1] = whichdriveicon;

	/* Initialize the two trees to have default as ROOT dir & 1st file of it */
	listinfo[0].tree = listinfo[1].tree = tree;
	listinfo[0].files = listinfo[1].files = NULL;

	/* The trees in the queue of length 2 (last 2) that retain selections
	   even when trees are switched for display */
	glob.SelTree[0] = glob.SelTree[1] = tree ;
	glob.SelRepInd = 0 ;
    
	/* ZZZZ At start up time don't allow starting in System Tree Mode unless
	 * we are coming back from a program launching from the shell. In this
	 * case we succesfully had been in system tree mode. This is because
	 * we could run into compact tree mode!!
	 */

	/* WARNING! Assumes ordering and the numbers 1 thru 3 */
	glob.TreeMode = Get_KeyWord_Assignment(TK_SAVESTATE,TK_FILEMGRMODE) - 
					     TK_SINGLETREE + 1 ;
	/* Maps it to a number 1 thru 3 which are TR_SINGLE thru TR_SYSTEM */
#ifndef NOGROUPINFILE
	if ( (glob.TreeMode < TR_SINGLE) || (glob.TreeMode > TR_SYSTEM) )
		glob.TreeMode = TR_SHARE;
#else
	if ( (glob.TreeMode < TR_SINGLE) || (glob.TreeMode > TR_SYSTEM) )
		glob.TreeMode = TR_SINGLE ;
#endif

	/* glob.MaxTree will be set right when we get into the correct tree mode */
	glob.FocusBox = glob.MaxTree = 0; 
	MarkGlobalFocus(DRIVELIST0) ;

	/* Safe value is glob.VerifyOverwrite = TRUE; */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_RCONFIRM) ;
	if (token == TK_DISABLED)
		glob.VerifyOverwrite = FALSE ;
	else
		glob.VerifyOverwrite = TRUE ;

	/* Safe value is glob.VerifyDelete = TRUE; */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_DCONFIRM) ;
	if (token == TK_DISABLED)
		glob.VerifyDelete = FALSE ;
	else
		glob.VerifyDelete = TRUE ;

	/* Safe value is glob.CrossDirSel = FALSE; */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_CROSSDIRSEL) ;
	if (token == TK_ENABLED)
		glob.CrossDirSel = TRUE ;
	else
		glob.CrossDirSel = FALSE ;

	/* Safe value is glob.MouseConfirm = TRUE; */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_MCONFIRM) ;
	if (token == TK_DISABLED)
		glob.MouseConfirm = FALSE ;
	else
		glob.MouseConfirm = TRUE ;

	/* By default, do not display hidden/system files */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_DISPHIDDENFILES) ;
	if (token == TK_ENABLED)
		glob.DisplayHiddenFiles = TRUE ;
	else
		glob.DisplayHiddenFiles = FALSE ;

	/* By default, we sort in ascending order */
	token = Get_KeyWord_Assignment(TK_SAVESTATE, TK_SORTORDER) ;
	if (token == TK_DESCENDING)
		gDescendingOrder = MAGIC_XCHG_MASK ;
	else
		gDescendingOrder = 0 ;


	/* Select root directory & its first file by default */
	glob.lineselected[0] = glob.lineselected[1] = 0 ;

	PDisable = Check_Spooler() ;

	gfFMBeingInited = FALSE ;

} /* proc InitFileMgr */

void AddFileManAccelerators(void);
/*
 * Sets up the File Manager window for use by drawing menu,title,messages
 * and erasing content region
 */
VOID SetUpScreen(void)
{
	RRC rrcClient;
	ISA isa ;

	/* The sequence here is important, so drawing will look good
    * even when going slowly
    */
	UpdateMainTitleBar(szDOSShellTitle);
#ifndef NOGROUPINFILE
	if ( (glob.TreeMode == TR_SHARE) && (WhoHasGlobalFocus() == GROUPBOX) )
	{
		 setmenubar(&MainMenuBar,&MainWind);
	}
	else
	{
		setmenubar(&FileMgrMenuBar,&MainWind);
	}
#else
	setmenubar(&FileMgrMenuBar,&MainWind);
#endif
	AddFileManAccelerators();
	// FrameMenuBar(&MainWind);

	/* draw top portion of screen where drives go */
	GetClientRrc(&MainWind,&rrcClient);
	rrcClient.ryTop +=2; /* exclude title and menu and drive status */
	rrcClient.ryBottom =rrcClient.ryTop+3;

	isa = (ISA) ((glob.TreeMode == TR_SEARCH) ? isaBackground : isaDrivebox) ;
	FillRrc(&MainWind,&rrcClient,' ',isa);

	/* else no drive icons region exists in Search Mode */

	/* draw bottom portion of screen where list boxes will go*/
	GetClientRrc(&MainWind,&rrcClient);
	rrcClient.ryTop +=5; /* exclude title and menu and drivebox */
	rrcClient.ryBottom -=1; /*exclude status bar */
	FillRrc(&MainWind,&rrcClient,' ',isaBackground);

	/* draw the drive box background for the double tree */
	if(glob.TreeMode == TR_DOUBLE)
	{
		rrcClient.ryTop = Get_List_Rect(&TreeList[0]).ayBottom+!gisgraph;
		rrcClient.ryBottom = rrcClient.ryTop+3;
		FillRrc(&MainWind,&rrcClient,' ',isaDrivebox);
	}
#ifndef NOGROUPINFILE
	if(glob.TreeMode == TR_SHARE)
	{
		rrcClient.ryTop = Get_List_Rect(&TreeList[0]).ayBottom+!gisgraph;
		rrcClient.ryBottom = rrcClient.ryTop+1;
		FillRrc(&MainWind,&rrcClient,' ',isaDrivebox);
	}
#endif

	if (glob.TreeMode == TR_SEARCH)
		MessageBar(szSearchMessage, isaMenu, TRUE);
	else
		MessageBar(szFileMessage, isaMenu,TRUE);
    /*
     * Since we just erased the screen, the file & program icons
     * are no longer there, so we must redraw them
     */
	if(gisgraph)
	{
		InitIconCache();
	}

} /* SetUpScreen */
void RefreshFMScreen(BOOL erase)
{
	int ith ;
	int filefocusline ;

	TakeDownBusyDialog(0);
	TakeDownBusyDialog(1);
	
	if(erase)
		SetUpScreen() ;
	FileMgrStatusBar(listinfo[glob.FocusBox].tree,
						listinfo[glob.FocusBox].files);

	for (ith = 0 ; ith <= glob.MaxTree ; ith++ )
	{
#ifndef NOGROUPINFILE
		if((ith == 0) && (glob.TreeMode == TR_SHARE))
		{
		    RefreshStartPrograms();
		    listinfo[1].UpdateDrives = FALSE;

		}
		if((ith == 0) || ((ith ==1) &&(glob.TreeMode != TR_SHARE)))
#endif
		{
		  listinfo[ith].UpdateDrives = TRUE;
		  filefocusline = Get_List_Focus(&FileList[ith]) ;

		  // Not_Blank(&TreeList[ith]);
		  // Not_Blank(&FileList[ith]);
		  // DoRedisplayList(&TreeList[ith]);
		  // DoRedisplayList(&FileList[ith]);
		  UpdateListBox(&TreeList[ith]);
		  UpdateListBox(&FileList[ith]);
		  // FocusLineChange(&TreeList[ith], glob.lineselected[ith]) ;

		  // FocusLineChange(&FileList[ith], filefocusline) ;
		}
	}
	if ( (glob.TreeMode == TR_SYSTEM) && (WhoHasGlobalFocus() != FILE0) )
		gfFlatLeftInfoDrawn = FALSE ;

} /* RefreshFMScreen */

/****	DoFileMgr - run file mgr windows (activated from menu)
**	This fn enables the file manager portion of the shell.  It turns
**	on the list boxes, and changes the menu bar.
**
**	EFFECTS:
**	    enables listboxes TreeList and FileList, inits several members of
**	glob.
*/

/* Following variable is used to inform the routines DoSingleTree,
   DoDoubleTree, DoFlatDisplay as to whether they have been called from
   DoFileMgr at startup or from the menu pull downs. */

BOOL ginitial = FALSE ; /* This has to be the default state */

extern VOID FAR DoShareMode(void);


/* Mark the glob variable and also the INI parsed stuff as being in the FM */
void MarkAsInFM(void)
{
	glob.InFileMgr = TRUE;
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_STARTUP,TK_FILEMGR);
	gfFMVisited = TRUE ;
} /* MarkAsInFM */


VOID DoFileMgr(void)
{
#ifndef NOLOADER
	if ( gfFileMgrStartUp && GET_WAIT_FLAG() )
	{
		gfFileMgrStartUp = FALSE ; /* Reset it back to FALSE -- default state */
		/* ZZZZZ */
		/* Time to swap tree structure in !! */
		DoSwapIn() ;
	}
#endif

	 /* The variable ginitial is looked at by the DoSingle... routines to
	  * decide whether to sort the tree, etc.
	  */
    ginitial = TRUE  ;

    switch(glob.TreeMode)
    {
		case TR_DOUBLE:
		    DoDoubleTree();	/* init for double tree display	*/
	    	break;

		case TR_SYSTEM:
		    DoFlatDisplay();
		    break;
#ifndef NOGROUPINFILE
		case TR_SHARE:
		    DoShareMode();
		    break;
#endif
		default:
			DoSingleTree();				/* init for single tree display */
    }
	/* swap in the tree now if it is there.
	 * do it after the window has been drawn so the user is
	 * not presented with a blank screen for too long
	 */

	ginitial = FALSE ;

	MarkAsInFM() ;

} /* proc DoFileMgr */


/* Puts the tree back in original shape -- i.e., the state in which it was
	before we entered the search mode. */
void HandleSearchQuit(void)
{
	/* Re-enable the menu-items that were non-reachable in Search Mode */
	EnableDisableForSearchMode(TRUE, TRUE) ;

	strcpy(glob.MatchPat, gSavedMatchPat) ;
	MarkAllTreeMatches(listinfo[0].tree, FALSE) ;
	glob.TreeMode = gSavedTreeMode ;
	SortCmp = SortFnArr[glob.SortKey = gSavedSortOrder] ;

	/* Clear all selections when leaving Search mode! */
	if (listinfo[0].tree->NumSel > 0)
		DeselectTree(listinfo[0].tree) ;

	/* Sort the tree & put it in appropriate state -- ZZZZ If bg sort is taken
		off then this can be removed?? */
	if (glob.TreeMode == TR_SYSTEM)
		SystemSort(listinfo[0].tree, FALSE) ;
	else
#ifdef OLDCOMPLETETREESORT
		FormDirectoryOrder(listinfo[0].tree, FALSE) ;
#else
		if (listinfo[0].tree->skey != glob.SortKey)
		{
			SetUpTreeForSort(listinfo[0].tree) ;
			SortDirectory(listinfo[0].tree, NULL) ;
			SortDirectory(listinfo[0].tree, listinfo[0].files) ;
		}
#endif

	/* Restore the global focus back to what it was before the search was
	 * initiated. If the file listbox has 0 files now, move it to the
	 * corresponding directory listbox to its left.
	 */
	if (gSavedGlobalFocus == FILE0)
	{
		if (GetNumItems(&FileList[0]) == 0)
			gSavedGlobalFocus = TREE0 ;
	}
	else if (gSavedGlobalFocus == FILE1)
	{
		if (GetNumItems(&FileList[1]) == 0)
			gSavedGlobalFocus = TREE1 ;
	}

	SetGlobalFocusBox(glob.FocusId = gSavedGlobalFocus) ;

} /* HandleSearchQuit */

/* Stores information like SortOrder, SortKey, etc (the persistent FM
 * state from the global variables into the INIPARSE data structure.
 */
/* ZZZZZZ If exiting is slow because of this, we can do these assignements
 * each time these values change!!
 */
void StoreFMState(void)
{
    Set_KeyWord_Assignment(TK_SAVESTATE, TK_SORTKEY, (TK_NAME+glob.SortKey));

    Set_KeyWord_Assignment(TK_SAVESTATE, TK_SORTORDER, 
								(gDescendingOrder ? TK_DESCENDING : TK_ASCENDING));
    Set_KeyWord_Assignment(TK_SAVESTATE, TK_DISPHIDDENFILES, 
								(glob.DisplayHiddenFiles ? TK_ENABLED : TK_DISABLED));
    Set_KeyWord_Assignment(TK_SAVESTATE,TK_RCONFIRM,
								(glob.VerifyOverwrite ? TK_ENABLED : TK_DISABLED));
    Set_KeyWord_Assignment(TK_SAVESTATE,TK_DCONFIRM,
								(glob.VerifyDelete ? TK_ENABLED : TK_DISABLED));
    Set_KeyWord_Assignment(TK_SAVESTATE,TK_MCONFIRM,
								(glob.MouseConfirm ? TK_ENABLED : TK_DISABLED));
    Set_KeyWord_Assignment(TK_SAVESTATE,TK_CROSSDIRSEL,
								(glob.CrossDirSel ? TK_ENABLED : TK_DISABLED));
} /* StoreFMState */

/****	ExitFileMgr - leave File Manager section of shell
**	It returns to the main Shell screen and menu.
**
**	EFFECTS:
**	    removes lists boxes, restores main menu bar.  Modifies
**	glob.InFileMgr.
*/
VOID FAR ExitFileMgr()
{
	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;
    TakeDownBusyDialog(0);
    TakeDownBusyDialog(1);
    glob.InFileMgr = FALSE;
    Set_KeyWord_Assignment(TK_SAVESTATE,TK_STARTUP,TK_STARTPGRMS);

	 StoreFMState() ;

    InitializeStartPrograms();
}

#ifndef NOGROUPINFILE
VOID DoStartProgramsIdle(void);
#endif

/****	FileMgrIdle - run bground processing for File Manager
**	    This fn updates the file mgr list boxes, and adds another disk
**	file to the displayed trees.
**	EXIT:
**	    TRUE if no background tasking, FALSE otherwise
**	EFFECTS:
**	    updates screen, adds a file to the visible tree(s).  
*/
BOOL FileMgrIdle()
{
	unsigned i;										// current list box
	BOOL notreallyidle;
#if 0  
	MouseIdle(); //now done in mouse idle!
#endif
	notreallyidle = gMouseDown;

	// If the tree has not been read in yet, begin reading it in.
	// This is where we read the tree in the background.
	// Don't do it when in help (since graphics takes so much memory)
	// or when in a dialog box not in file manager (unneccessary speed
	// hit)
	if ((!((gCnx == cnxDialog) && (!glob.InFileMgr))) && !(gNumHelps>=0))
	{
	     for (i=0; i <= glob.MaxTree; i++)
	     {
		     if (!listinfo[i].tree->Started)
		     {
			     listinfo[i].tree->Started = TRUE;
			     listinfo[i].tree->ContinueTree = TRUE;

			     /* The sort modes for the tree will be set on actual sorting! */
			     /* tree->mpat is always assumed to be "*.*" at read in time */
			     /* It is initilaized in InitFileMgr that way. Thus all file nodes
				start with matchespattern field = TRUE at start */
		     }
		     // only if interactive:if (!Is_List_Captured(&TreeList[i]))
		     notreallyidle |= listinfo[i].tree->ContinueTree;
		     UpdateFileTree(i);
	     }
	}
    // Update screen if in File Manager. Don't do if a dialog is
    // up or a menu is down
    if ((glob.InFileMgr) && (gCnx==cnxNull))
    {
		// Update any listbox sections which need it.
		for (i=0; i <= glob.MaxTree; i++)
		{
			if (listinfo[i].UpdateDrives)
			{
				UpdateDrives();
				listinfo[i].UpdateDrives = FALSE;
			}
			/* ZZZZ Is this check needed or will we have UpdateFiles, etc TRUE
				only if tree is completely read in? */
			if(!listinfo[i].tree->ContinueTree)
			{
			   TakeDownBusyDialog(i);
			   if (listinfo[i].UpdateTree)
			   {
					/* Invalidate the icon cache in the tree listbox region! */
					/* The tree listbox is going to be cleared and re-drawn*/
					InvalidateIconCache(Get_List_Rect(&TreeList[i]).axLeft,
									Get_List_Rect(&TreeList[i]).ayTop,
									Get_List_Rect(&TreeList[i]).axRight,
									Get_List_Rect(&TreeList[i]).ayBottom);
				   DoRedisplayList(&TreeList[i]);
				   listinfo[i].UpdateTree = FALSE;
				   notreallyidle = TRUE;
			   }
			   if (listinfo[i].UpdateFiles)
			   {
#if 0
					/* Invalidate the icon cache in the file listbox region! */
					/* The file listbox is going to be cleared and re-drawn*/
					InvalidateIconCache(Get_List_Rect(&FileList[i]).axLeft,
									Get_List_Rect(&FileList[i]).ayTop,
									Get_List_Rect(&FileList[i]).axRight,
									Get_List_Rect(&FileList[i]).ayBottom);
#endif
				   FileList[i].blank = TRUE;
				   DoRedisplayList(&FileList[i]);

					/* If mode is Implicit mode, automatically select first file in
					 * File listbox. IF cross-dir-selection is ON we don't want to
					 * do such default selection as it is potentially dangerous.
					 */
					if ( (FileList[i].mode) && (!glob.CrossDirSel) )
						ListKey(&FileList[i], ' ', 0) ;

				   listinfo[i].UpdateFiles = FALSE;
				   notreallyidle = TRUE;
			   }

			   notreallyidle |= !ListBoxIdle(&FileList[i]);
			   notreallyidle |= !ListBoxIdle(&TreeList[i]);
			}
		} /* for */
#ifndef NOGROUPINFILE
		if(glob.TreeMode == TR_SHARE)
		{
		    DoStartProgramsIdle();
		}
#endif
    } /* if in FileMgr */

	/* if the last dialog/menu up didn't repaint, do it now */
	if(gfRepaintonidle)
	{
		if(gCnx == cnxNull)
		{
			InitIconCache();
			if(glob.InFileMgr)
				RefreshFMScreen(FALSE);
			else
			{
				if (m_fPerformingViewFile())
					/* Don't clear and redraw */
					RefreshViewFileScreen(FALSE) ;
				else
					RefreshStartPrograms();
			}
			gfRepaintonidle = FALSE;
	   }
	}

    return(!notreallyidle);
} /* proc FileMgrIdle */

/****	UpdateFileTree - Add a file to the current drive tree.
**	This fn adds a file to the listbox's tree; if it is a directory then the
**	directory list box is refreshed.
**
**	ENTRY
**		slot - which list box set: 0 if not in 2-tree mode.  In two-tree mode,
**			0 = upper list box set
**			1 = lower list box set
**	EXIT
**		TRUE if work done, FALSE if not
*/
VOID UpdateFileTree(set)
int set;

{
	treehdr far *tree = listinfo[set].tree;	// the listbox tree
	PENTRY ret;								// NULL if at end of files
	int i ;
 /*
	NOTE: doing multiple addfiles here does not enhance speed
	significantly.
	It could mess up compact mode anyway.
 */
	/* If there are more entries to add to the tree or file boxes,
	** format the next line and add it to the tree box.
	*/
	if (tree->ContinueTree)
	{
		ret = AddFile(tree);
		if(ret)
		{
		    if(glob.InFileMgr)
		       PutUpBusyDialog(set);
		}
		else
		{
			/* Tree has been completely read in. So, now sort the tree
			   in appropriate order, Mark All matches correctly if pattern
			   has changed. Get Disk Information for system tree mode 
			   Redisplay the file tree(s). */
			tree->ContinueTree = FALSE;

			if (tree->Compacted)
			{
				/* No files have been read into this tree. Note: In
				   compact mode only directories are read in. */
				for (i = 0 ; i <= glob.MaxTree ; i++)
				{
					if ( (listinfo[i].tree == tree)  && 
					      ( (i!=1) || (listinfo[1].tree!=listinfo[0].tree) ||
									listinfo[0].files != listinfo[1].files ) )
						LoadCompactDir(listinfo[i].tree, listinfo[i].files) ;
				}

			}
#ifdef OLDSORT
			if ( (glob.TreeMode == TR_SYSTEM) && (glob.SortKey != SORT_DISK) )
				SystemSort(listinfo[0].tree, TRUE) ;
			else
				FormDirectoryOrder(tree, TRUE) ;
#else
			tree->SortRequired = TRUE ;
#endif

			HandleSpecialCaseNovell(tree) ;

			MarkAllTreeMatches(tree, FALSE) ;

			/* Mark the 'lastdir' bit for all directory nodes!! */
			Marklastdir(tree) ;

			if (glob.InFileMgr)
			{
				/* If the same tree is being displayed in
				 * two windows, disable both dialogs, otherwise
				 * only disable the right one!
				 */
				if(listinfo[set].tree->head == listinfo[0].tree->head)
				{
				   TakeDownBusyDialog(0);
				}
				if(listinfo[set].tree->head == listinfo[1].tree->head)
				{
				   TakeDownBusyDialog(1);
				}

				DoRedisplayList(&TreeList[set]) ;
				DoRedisplayList(&FileList[set]) ;
		    }
		}
	}
} /* proc UpdateFileTree */

/* In System tree mode (flat mode), erase the left part of the screen where
 * the "showInfo" stuff is drawn.
 */
void EraseFlatLeft(void)
{
	RRC rrcClient;

	/* FileList[0]'s rectangle will be the system tree mode's right side box */
	rrcClient.rxRight = Get_List_Rect(&FileList[0]).axLeft - 1	;
	rrcClient.rxLeft = 0 ;
	rrcClient.ryTop = Get_List_Rect(&FileList[0]).ayTop ;
	rrcClient.ryBottom = Get_List_Rect(&FileList[0]).ayBottom ;
    FillRrc(&MainWind,&rrcClient,' ',isaBackground);


}  /* EraseFlatLeft */


void SetFocusDrive(WORD list, BYTE whichdriveicon)
{
    gHighlightedDrive[list] = whichdriveicon ;
}

BYTE GetFocusDrive(WORD list)
{
    return(gHighlightedDrive[list]);
}

BYTE GetSelectedDrive(WORD list)
{
    return(gSelectedDrive[list]);
}


/****	DrawDrive - paint disk icon and letter in appropriate spot
**
**	ENTRY
**	EXIT
**	WARNING:
**	EFFECTS:
*/
VOID DrawDrive(WORD list,WORD drive,ISA highlight)
{	  
	char letter;
	WORD x, y;
	treehdr far *drivetree;
	BITMAP *pbitmap ;
	int seldrive;

	if(glob.TreeMode == TR_SEARCH)
	   return;

	drivetree = gDriveList[list][drive].tree;
	
	letter = drivetree->root[0];
	x = gDriveList[list][drive].IconX;
	y = gDriveList[list][drive].IconY;
	seldrive = GetSelectedDrive(list);
	if (gisgraph)
	{
	     switch(drivetree->DriveType)
	     {
		case HARDDISK_TYPE :
		   pbitmap = (drive==seldrive) ? HDIconInvert : HDIcon ;
		   break ;

		case RAMDRIVE_TYPE :
		   pbitmap = (drive==seldrive) ? RamDriveIconInvert : RamDriveIcon ;
		   break ;

		case CDROM_TYPE :
		   pbitmap = (drive==seldrive) ? CDRomIconInvert : CDRomIcon ;
		   break ;

		case FLOPPY_TYPE :
		   pbitmap = (drive==seldrive) ? FloppyIconInvert : FloppyIcon ;
		   break ;

		case REMOTE_TYPE :
		default:
		   pbitmap = (drive==seldrive) ? RemoteIconInvert : RemoteIcon ;
		   break ;
		 } /* switch */

		if(!(gIconCache && (gIconCache[y*MAXCOLS+x] == (char) (drive == seldrive))))
		{
			 PlotBmp(pbitmap, x*CWIDTH, y*CHEIGHT,isaDrivebox);
			if(gIconCache)
				gIconCache[y*MAXCOLS+x] = (char)(drive == seldrive);
		}
		CharOut(&MainWind, (RX) x+3, (RY) y, letter, highlight);

	}
	else
	{
	   CharOut(&MainWind, (RX) x, (RY) y, '[', highlight);
	   CharOut(&MainWind, (RX) x+1, (RY) y, letter, highlight);
	   CharOut(&MainWind, (RX) x+2, (RY) y, ':', highlight);
	   CharOut(&MainWind, (RX) x+3, (RY) y, ']', highlight);
	}

	
} /* proc DrawDrive */

PTREE HighlightDrive(WORD list, WORD drive, ISA highlight)
{
	WORD i,numlists;
	BYTE focusdrive ;

	numlists = (glob.TreeMode == TR_DOUBLE) ? 2 : 1;

	if ( (highlight==isaHilite) || (highlight == isaSelect) )
		focusdrive = gHighlightedDrive[list] = (BYTE) drive ;
	else
		focusdrive = gHighlightedDrive[list] ;


	FEnableMouseNest(FALSE) ; // will help reduce mouse flicker!

	if(highlight==isaSelect)
	{
		 DrawDrive(list, gSelectedDrive[list]=(BYTE)drive,
					(ISA) ((focusdrive == (BYTE)drive) ? isaHilite : isaSelect));
	}
	else
	if(highlight==isaHilite)
	{
		DrawDrive(list, drive, (ISA) ((gHighlightedDrive[list] == (BYTE)drive) ? isaHilite :isaSelect));
	}
	else /* This means that we want to draw plain drive selection icon! */
		DrawDrive(list, drive, (ISA) (gSelectedDrive[list]==(BYTE)drive?isaSelect:isaDriveicon));

    for (i = 0; i < glob.DriveCount; i++)
		if (i != drive)
		{
		   if(gSelectedDrive[list] == (BYTE) i)
			   DrawDrive(list, i, (ISA)((gHighlightedDrive[list] == gSelectedDrive[list]) ? isaHilite : isaSelect));
		   else
			   DrawDrive(list, i, (ISA) ((gHighlightedDrive[list] == (BYTE)i) ? isaHilite :isaDriveicon));

		}

	FEnableMouseNest(TRUE) ;

	return(gDriveList[list][drive].tree) ;
}

VOID SelectDrive(WORD list,WORD drive)
{
	BOOL newtree;
	PTREE drivetree;

	drivetree = HighlightDrive(list,drive,isaSelect);

	newtree = (drivetree != listinfo[0].tree) || 
	 						(glob.MaxTree && (drivetree != listinfo[1].tree));

	/* ZZZZ Is there a problem with foll. in compact mode? */
	if (newtree && (drivetree->Started) && !drivetree->ContinueTree)
	{
		if (glob.TreeMode == TR_SYSTEM)
			SystemSort(drivetree, FALSE) ;
		else
#ifdef OLDCOMPLETETREESORT
			FormDirectoryOrder(drivetree, FALSE) ;
#else
			SetUpTreeForSort(drivetree) ;
			 /* sort root directory of drive tree */
		SortDirectory(drivetree, NULL) ;
#endif

		MarkAllTreeMatches(drivetree, FALSE) ;
	}
	/* The new tree selected might be a different guy from	the trees
	 * already seen
	 */
	if ((drivetree != glob.SelTree[0]) && (drivetree != glob.SelTree[1]))
	{
		glob.SelTree[glob.SelRepInd] = drivetree ;
		glob.SelRepInd = !glob.SelRepInd ;/* toggle SelRepInd */
	}
	else
	{
		/* tree selected is one of the trees already in our
		 * queue update the index to the guy not selected. Check
		 * glob.SelTree[1] as it is always valid
		 */
		glob.SelRepInd = (drivetree == glob.SelTree[1]) ? 0 : 1 ;
	}

	/* Take busy dialog down, anyway! In case we currently have busy dialog
	 * up with say drive 'C' and he does a "Ctrl+C" we would take down
	 * the busy dialog and then put it back up!
	 */
	TakeDownBusyDialog(list) ;

	/* In System tree mode, erase the flatleft portion of screen? */
	if (glob.TreeMode == TR_SYSTEM)
		EraseFlatLeft() ;

	listinfo[list].tree = drivetree;
	listinfo[list].files = drivetree->SelDir ; // put back in last sel dir
	glob.lineselected[list] = drivetree->SelLine ;  // check mark line

	// move focus to first file.
	Set_List_Focus(&FileList[list], 0);

	// move focus to selected directory.
	Set_List_Focus(&TreeList[list], 0);
	FocusLineChange(&TreeList[list], glob.lineselected[list]) ;

	/* ZZZZZ As a side effect, any files that were previously
	 * selected in the file listbox would get deselected.
	 * If I don't do this LoadCompactDir() sometimes it will say no
	 * files in the root dir (even thouh there are files).
	 */
	if ( (drivetree->Started) &&
			(!drivetree->ContinueTree) &&
			(drivetree->Compacted) &&
			(newtree)
		 )
	{
		LoadCompactDir(drivetree, listinfo[list].files) ;
		listinfo[list].UpdateFiles = TRUE ;
	}

	/* In SystemTree mode, When we do FlatLeft this is taken care of correctly!!*/
	/* Update the directory status line displaying selected dir. */
	FileMgrStatusBar(drivetree, listinfo[list].files) ;

	ListBoxPath(drivetree, listinfo[list].files, list) ;

	/* trash our icon cache as the tree box, file box are going to be cleared
	 * and re-drawn again if we put a busy dialog, etc.
	 */
	InitIconCache() ;

	InsertListItem(&TreeList[list], 0) ;  
	InsertListItem(&FileList[list], 0) ;

	gfFlatLeftInfoDrawn = FALSE ;
}

VOID UpdateDrives(void)
{
#if 0
	WORD i,j;
	WORD numlists;
#endif

	ISA highlight1, highlight2 ;

	/* By default assume that the drive icons are not highlighted! */
	highlight1 = highlight2 = isaDriveicon ;

	if (WhoHasGlobalFocus() == DRIVELIST0)
		highlight1 = isaHilite ;
	else
	/* In our case DRIVELIST1 and GROUPBOX have the same #define!! */
	if (WhoHasGlobalFocus() == DRIVELIST1)
			highlight2 = isaHilite ;

	HighlightDrive(0, GetFocusDrive(0), highlight1) ;

	if (glob.TreeMode == TR_DOUBLE)
		HighlightDrive(1, GetFocusDrive(1), highlight2) ;
} /* UpdateDrives */


void DriveListKey(WORD list,WORD key, WORD state)
{
	BYTE lastfocus ;

	UnReferenced(state) ;

	lastfocus = GetFocusDrive(list);
	switch(key)
	{
		case VK_RIGHT:
			   lastfocus = (lastfocus+1)%glob.DriveCount;
			   HighlightDrive(list,lastfocus,isaHilite);
			break;

		case VK_LEFT:
			   lastfocus = (lastfocus+glob.DriveCount-1)%glob.DriveCount;
			   HighlightDrive(list,lastfocus,isaHilite);
			break;

		case ' ':
			   SelectDrive(list,lastfocus);
			break;

		case '\r':
				/* previously Shift+Enter used to cause re-reading! */
			   // if (state & KK_SHIFT)
					JunkTree(gDriveList[list][lastfocus].tree) ;

				/* ZZZZ should I save currently viewed dir on this box and
				 * try to restore it later! Will be difficult as disk info
				 * could have changed and this dir might not be present
				 * on re-read!
				 */
				 if ((glob.TreeMode == TR_DOUBLE) &&
							(listinfo[list].tree == listinfo[1-list].tree))
				 {
					 listinfo[1-list].files = NULL;	  // root directory
					 glob.lineselected[1-list] = 0 ;

				 }

				 SelectDrive(list,lastfocus);
			break;
	} /* switch */
} /* DriveListKey */

BOOL DriveMouse(WORD mx,WORD my,WORD msg)
{
    WORD i,j,numlists;

    /*
     * when we are in the search "dialog" (haha) the drives
     * are not supposed to be accessable.
     */
    if(glob.TreeMode == TR_SEARCH)
		return(FALSE);

	numlists = (glob.TreeMode == TR_DOUBLE) ? 2 : 1;
#ifndef NODIRECT
    if((msg == WM_LBUTTONDOWN) ||
       (msg == WM_LBUTTONDBLCLK) ||
       ((msg == WM_MOUSEMOVE) && (gMouseDown)) )
#else
    if((msg == WM_LBUTTONDOWN) || (msg == WM_LBUTTONDBLCLK))
#endif
		for (i = 0; i < glob.DriveCount; i++)
			for(j = 0; j < numlists ; j++)
			{
				if ((my == gDriveList[j][i].IconY) &&
						(mx >= gDriveList[j][i].IconX) &&
						(mx <= gDriveList[j][i].IconX+4))
				{
					/* Drive needs to be re-read in case of a mouse
					 * double-click! It will happen in the file manager
					 * idle cycle if we junk the tree now.
					 */
					if(msg == WM_LBUTTONDBLCLK)
					{
						JunkTree(gDriveList[j][i].tree) ;

						/* ZZZZ should I save currently viewed dir on this box and
						 * try to restore it later! Will be difficult as disk info
						 * could have changed and this dir might not be present
						 * on re-read!
						 */
						 if ((glob.TreeMode == TR_DOUBLE) &&
									(listinfo[j].tree == listinfo[1-j].tree))
						 {
							 listinfo[1-j].files = NULL;	  // root directory
							 glob.lineselected[1-j] = 0 ;
						 }

					}
#ifndef NODIRECT
				       if (msg != WM_MOUSEMOVE)
				       {
					  SelectDrive(j,i);
				       }
				       else
				       {
					    if(gMouseDown)
					       HighlightDrive(j,i,isaHilite);
				       }
#else
					  SelectDrive(j,i);
#endif
					InitIconCache() ;

					/* Move the focus to the drive icons! */
					InitGlobalFocus((j == 0) ? DRIVELIST0 : DRIVELIST1) ;

					return(TRUE);
				}
			}
    return(FALSE);
}

/* DoDiskReread() is invoked from the menu. The selected drive is the
 * one we want to re-read instead of the focus drive?
 */
void DoDiskReread(void)
{
	SetFocusDrive(glob.FocusBox, GetSelectedDrive(glob.FocusBox) ) ;

	/* Make it look like the "Enter" key was pressed to re-read the disk */
	DriveListKey(glob.FocusBox, '\r', 0) ;

	InitGlobalFocus(glob.FocusBox ? DRIVELIST1 : DRIVELIST0) ;
		
} /* DoDiskReread */

/* Function is called when user presses Ctrl+F5 -- Keyboard accelerator
 * This function should be called only from within the FM. Note that
 * this assumption holds right now as the accelerator Ctrl+F5 is active
 * only when the FM menu is put up!
 */
void RereadSelectedDir(void)
{
	/* If in System Tree mode (All Files mode), Ctrl+F5 does not mean
	 * anything really. We could do a DoDiskReread in this case if we
	 * wanted -- same as F5.
	 */
	if ( (glob.TreeMode == TR_SEARCH) || (glob.TreeMode == TR_SYSTEM) )
	{
		Shell_Beep() ;
		return ;
	}

	/* Note that we must have started reading this tree as we are in the FM */ 
	assert(listinfo[glob.FocusBox].tree->Started) ;


	/* Also, if the tree has not been fully read in as yet, don't do
	 * anything. Ofcourse, this could be treated the same as an F5.
	 */
	if (listinfo[glob.FocusBox].tree->ContinueTree)
		return ;

	/* Basically, if we are here the mode is TR_SINGLE, TR_DOUBLE, or
	 * TR_SHARE.
	 */
	assert ( (glob.TreeMode == TR_SINGLE) ||
			   (glob.TreeMode == TR_DOUBLE) ||
			   (glob.TreeMode == TR_SHARE)
			 ) ;

	LoadCompactDir(listinfo[glob.FocusBox].tree,
															listinfo[glob.FocusBox].files) ;
	listinfo[glob.FocusBox].UpdateFiles = TRUE ;

	/* See if we in dual tree mode and if the same directory is displayed
	 * in the other listbox too. In that case, we need to update it too.
	 */
	if ( (glob.TreeMode == TR_DOUBLE) &&
		  (listinfo[0].tree == listinfo[1].tree) &&
		  (listinfo[0].files == listinfo[1].files)
		)
	{
		FileList[1-glob.FocusBox].blank = TRUE;
		DoRedisplayList(&FileList[1-glob.FocusBox]);
	}
	
} /* RereadSelectedDir */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\dts_api.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; ZZZZZZ Are there bugs with offset calculations?? Is DGROUP the right
; assume for DS? I am unable to access variable DoQuickCompare from 'C'
; The offset is off by 64 bytes!!

?WIN = 0                ;Not windows;
?PLM = 1                ;DO use pl/m
include cmacros.inc

;;;BUG BUG should share .inc file with others!

MAX_NUM_PROGRAMS equ 16
MAX_PROGRAM_LENGTH equ 80
MAX_TITLE  equ 30

F_DTS_API_INITED   equ 0000000000001000b ;1=>The DTS init has been posted;set by shell
F_SWAP_NOT_OK      equ 0000000000010000b ;1=>external tasker incompatible;set by shell
extrn _C_GET_GLOBAL_SWITCH_DATA:FAR

Switch_Entry   STRUC
       Program_Name    db MAX_PROGRAM_LENGTH  DUP(?); Program name
       Program_Title   db MAX_TITLE DUP (?)      ; switcher screen title
       Conv_Req        dw ?                      ; min conv mem required
       XMS_Req         dw ?                      ; XMS required
       XMS_Want        dw ?                      ; XMS desired
       HK_Scan_Code_1  db ?                      ; 1st directed hot key scan code
       HK_Scan_Code_2  db ?                      ; 2nd directed hot key scan code
       HK_Shift_State  db ?                      ; ALT/CTRL/SHIFT states
       Program_Flags   dw ?                      ; Special flags for program
       Next_In_List    db ?                      ; Next program in Z order list
       Program_Id      dw ?                      ; internal program ID
       Path_Id         db ?                      ; internal id of swap path
       Shell_Cookie    dw ?                      ; magic cookie for shell
Switch_Entry   ENDS


Switch_Info    STRUC
       Switcher_Id     db   ?                    ; low nibble is unique id
       CPU_Type        dw   ?                    ; CPU type flag bits
       SFT_Size        dw   ?                    ; SFT SIZE
       Parameters      db   130 dup (?)          ; parameters to the program
       Grabber_Name    db   80 dup (?)           ; grabber path and name
       Swap_Path1      db   68 dup (?)           ; first swap drive and path 
       Swap_Path2      db   68 dup (?)           ; second swap drive & path
       Min_Path1       dw   ?                    ; min k space to be left on drv1
       Min_Path2       dw   ?                    ; min k space to be left on drv2
       XMS_Handle      dw   ?                    ; Handle of locked XMS block
       XMS_Size        dd   ?                    ; size of block in bytes
       Int_15_Users_Id dw   ?                    ; ID of app using INT 15 memory
       Id_Serial       dw   ?                    ; running app serial number
       Exit_Code       dw   ?                    ; switcher exit code
       Num_Lines       db   ?                    ; start up screen lines
       Global_Flags    db   ?                    ; various global descisions
       Screen_Back     db   ?                    ; back ground screen color
       Title_Fore      db   ?                    ; Title text color
       Title_Back      db   ?                    ; Title back ground color
       Num_Programs    db   ?                    ; number of programs in the list
       First_In_List   db   ?                    ; first program in Z order list
       Program_List    db SIZE Switch_Entry *MAX_NUM_PROGRAMS DUP(?)
Switch_Info    ENDS


sBegin data
sEnd data

sBegin code
    assumes cs, code
    assumes ds, DGROUP

Switch_Call_Back STRUC
	SCBI_Next       dd      ?
	SCBI_Entry_Pt   dd      ?
	SCBI_Reserved   dd      ?
	SCBI_API_Ptr    dd      ?
Switch_Call_Back ENDS

Parent_Switcher_CallBack dd 0
do_resume_on_exit db 0
Switcher_Call_Entry dd ?
Switcher_Call_Chain dd ?

;;; Call Out to DTS task switchers usint the DTS API
;;; 
;;; 
;;; local statics
inDTSax dw  ?
inDTSbx dw  ?
inDTScx dw  ?
inDTSdx dw  ?
DTS_API proc near
	mov inDTSax,ax
	mov inDTSbx,bx
	mov inDTScx,cx
	mov inDTSdx,dx

	mov ax,4b01h
	xor bx,bx
	mov es,bx
	mov cx,bx  ; note that the call in address is NULL! BUG BUG
	mov dx,bx
	int 2fh
	;;; returns in es:bx of a switch_call_back_info data block
chain_loop:
	mov ax,es
	or  ax,bx
	jz  chain_done
	mov ax,WORD PTR ES:[BX].SCBI_Next[0]
	mov WORD PTR Switcher_Call_Chain[0],ax
	mov ax,WORD PTR ES:[BX].SCBI_Next[2]
	mov WORD PTR Switcher_Call_Chain[2],ax
	mov ax,WORD PTR ES:[BX].SCBI_Entry_Pt[0]
	mov WORD PTR Switcher_Call_Entry[0],ax
	mov ax,WORD PTR ES:[BX].SCBI_Entry_Pt[2]
	mov WORD PTR Switcher_Call_Entry[2],ax
	
	;;; set call-in handler to NULL
	xor di,di
	mov es,di
	mov ax,inDTSax
	mov bx,inDTSbx
	mov cx,inDTScx
	mov dx,inDTSdx
	mov si,0D055h
	call DWORD PTR [Switcher_Call_Entry]
	or ax,ax
	jnz  chain_done
	mov  bx,WORD PTR Switcher_Call_Chain[0]
	mov  es,WORD PTR Switcher_Call_Chain[2]
	jmp chain_loop
chain_done:
	ret
DTS_API endp


cProc DTS_API_Exit, PUBLIC <si,di,ds,es>
cBegin DTS_API_Exit
	;;; If we suspended the parent switcher, we should resume him!
	cmp cs:do_resume_on_exit,1
	jne dont_resume
	mov ax,3        ;; resume switcher
	xor di,di       ;; note NULL callback
	mov es,di       
	mov cx,0D055h
	call DWORD PTR [Parent_Switcher_CallBack]
dont_resume:

	call _C_GET_GLOBAL_SWITCH_DATA
	;; dx:ax -> global switcher data
	mov es,dx
	mov bx,ax
	mov bl,es:[bx].Global_Flags
	test bl,F_DTS_API_INITED
	jz doneDTS_API_Exit
	
	mov ax,7        ;;Exit Switcher
	mov bx,1        ;;BUG BUG this should see if we are the only switcher
	call DTS_API    

doneDTS_API_Exit:
cEnd DTS_API_Exit

;;; Returns 1 if DosTaskSwitcher API handlers said its okay to switcher
;;;        -1    if no DTS handler responded
;;;         0 if DTS handlers refused us switching
cProc DTS_API_Init, PUBLIC <si,di,ds,es>
cBegin DTS_API_Init

	;;; Only do DTS initialization on first launch!
	call _C_GET_GLOBAL_SWITCH_DATA
	;; dx:ax -> global switcher data
	mov es,dx
	mov bx,ax
	mov bl,es:[bx].Global_Flags
	test bl,F_DTS_API_INITED
	jnz     DTS_already_inited


	mov     ax,4B02h        ; Detect_Switcher
	xor     bx,bx           ; bx is defined to be zero in spec DTS API 0.6
	mov     es,bx           ; es:di = 0
	mov     di,bx
	mov     cx,0D055h       ; signature for DOS5 just in case (not doc'd!)
	int     2fh
	or      ax,ax
	jnz     no_DTS_Responder

	;;; we are running under a DTS API switcher
	;;; es:di = call in address of parent switcher 
	;;; Now we are supposed to attempt to suspend parent switcher
	;;; It can refuse if it wishes. However, we are supposed to ignore
	;;; the error it gives anyway, just in case it decides we should
	;;; run our switcher anyway; it will let us know when we Init_Switcher
	mov ax,2
	mov WORD PTR Parent_Switcher_CallBack,di
	mov WORD PTR Parent_Switcher_CallBack[2],es
	xor di,di
	mov es,di
	mov cx,0D055h
	;;; we do a direct call to the parent_switcher on this call...
	call DWORD PTR [Parent_Switcher_CallBack]
	;;; so spec 0.6 is a bit confusing. AX=1 advises us not to run, so
	;;; be it
	cmp ax,1
	je  DTS_SaidNo
	;;; if ax is zero, we have suspended the parent; so we should
	;;; resume him on exit!
	or  ax,ax
	jnz parent_not_suspended
	mov cs:do_resume_on_exit,1
parent_not_suspended:
No_DTS_Responder:
	;;; otherwise we might be able to run our switcher, so now Init_Switcher
	;;; this needs to be done with the DTS APIs chain method so all
	;;; switchers will have a say
	xor ax,ax
	call DTS_API
	or ax,ax
	jnz DTS_SaidNO
	jmp short DTS_SaidOK
DTS_Already_Inited:
	;;;WARNING assumes bl is flags from above!
	test bl,F_SWAP_NOT_OK
	jnz DTS_SaidNOalready
	jmp short DTS_SaidOKalready
	
;No_DTS_Responder:
;
;       call _C_GET_GLOBAL_SWITCH_DATA
;       ;; dx:ax -> global switcher data
;       mov es,dx
;       mov bx,ax
;       or  BYTE PTR es:[bx].Global_Flags,F_DTS_API_INITED
;       mov ax,-1
;       jmp short doneDTS
DTS_SaidNO: 
	call _C_GET_GLOBAL_SWITCH_DATA
	;; dx:ax -> global switcher data
	mov es,dx
	mov bx,ax
	or  BYTE PTR es:[bx].Global_Flags,F_SWAP_NOT_OK OR F_DTS_API_INITED
DTS_SaidNOalready:      
	xor ax,ax
	jmp short doneDTS
DTS_SaidOK:
	call _C_GET_GLOBAL_SWITCH_DATA
	;; dx:ax -> global switcher data
	mov es,dx
	mov bx,ax
	and  BYTE PTR es:[bx].Global_Flags,NOT F_SWAP_NOT_OK
	or  BYTE PTR es:[bx].Global_Flags,F_DTS_API_INITED

DTS_SaidOKalready:
	mov ax,1
doneDTS:
cEnd DTS_API_Init

 
;;INPUTS none
;;OUTPUTS 1 if running under tasker; 0 otherwise
;;      (if 1, don't allow enabling of task switcher)
;;
cProc RunningUnderMStasker, PUBLIC <si,di,ds,es>
cBegin RunningUnderMStasker
	call DTS_API_Init
	or ax,ax
	jz already_tasking
	cmp ax,1
	je say_OK
;;;detection code for older MS taskers (<=W3.0)
	mov     ax,4680h ;switcher call out
	int     2fh
	or      ax,ax
	jz      already_tasking
	mov     ax,1600h ;enhanced mode callout
	int     2fh
	test    al,7fh   ;if not low bits set 
			 ;there is a random himem which might set hi bit
	;or      al,al
	jnz already_tasking
say_OK:
	xor ax,ax
tasktestdone:

cEnd RunningUnderMStasker
already_tasking:
	mov     ax,1
	jmp short tasktestdone


sEnd   code

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\edit.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <edit.h>

editstruct gEdit;

editline far *AllocLine(editstruct far *e)
{
    editline far *t;
    int size;
    /* BUG BUG! */
    size = e->width+6;

    t=LpbAllocWorkFar(size);
    t->next = NULL;
    t->length = 0;
    return(t);
}

VOID FreeLine(editline far * e)
{
    FreeWorkFar(e);
}

BOOL Init_EditStruct(editstruct *e,int width)
{
    int i;

    e->numlines = 1;
    e->curline = 0;
    e->curoffset = 0;
    e->width = width;
    e->head = AllocLine(e);

    if(!e->head)
	return(FALSE);
    return(TRUE);
}


VOID InitEdit()
{
    Init_EditStruct(&gEdit,30);
}

long Get_Num_Lines(editstruct *e)
{
    return(e->numlines);
}

editline far *get_nth_line(editstruct *e,int n)
{
    int i;
    editline far *t;
    t=e->head;
    if(t==NULL)
	return(NULL);
    for(i=0;i<n;i++)
    {
	t=t->next;
	if(t==NULL)
	    break;
    }
    return(t);
}

BOOL Get_Ith_Line(editstruct *e,char *dest,int ith,int len)
{
    int i;
    editline far *t;
    int clen;
    t = get_nth_line(e,ith);
    i = 0;
    if(t!=NULL)
    {
	clen = min(t->length,len);
	for(i=0;i<clen;i++)
	{
	    dest[i]=t->text[i];
	}
    }
    for(;i<len;i++)
	dest[i] = ' ';
    return(TRUE);
}

BOOL Ripple(editstruct *e)
{
    int i;
    editline far *t;
    int savecurline;
    int savecuroffset;
    int start;
    char wrapchar;

    t = get_nth_line(e,e->curline);
    if(t==NULL)
	return(FALSE);
    start = e->curoffset;
    wrapchar = t->text[e->width-4];
    for(i=t->length;i>start;i--)
    {
	  t->text[i] = t->text[i-1];
    }
    ++t->length;
    if(t->length >= e->width-3)
    {
	savecurline=e->curline;
	savecuroffset=e->curoffset;
	++e->curline;
	e->curoffset=0;
	InsertChar(e,wrapchar);
	e->curline = savecurline;
	e->curoffset=savecuroffset;
	--t->length;
    }
    return(TRUE);
}
VOID Oversert(editstruct *e,char c)
{
    editline far *t;
    t = get_nth_line(e,e->curline);
    t->text[e->curoffset] = c;
    ++e->curoffset;

}
BOOL DeleteChar(editstruct *e)
{
    int i;
    editline far *t;
    int start;

    if(e->curoffset <= 0)
    {
	Beep();
	return(FALSE);
    }
    t = get_nth_line(e,e->curline);
    if(t==NULL)
	return(FALSE);
    --e->curoffset;
    start = e->curoffset;

    for(i=start;i<t->length;i++)
    {
	  t->text[i] = t->text[i+1];
    }
    --t->length;
    return(TRUE);
}

BOOL InsertChar(editstruct *e,char c)
{
    if(e->curoffset >= e->width-4)
    {
	InsertLine(e);
    }
    if(Ripple(e))
    {
	Oversert(e,c);
    }else
    {
	Beep();
	return(FALSE);
    }
}

BOOL InsertLine(editstruct *e)
{
    int i;
    editline far *t;
    editline far *link;
    t = get_nth_line(e,e->curline);
    if(t==NULL)
	return(FALSE);
    link = t->next;
    t->next = AllocLine(e);
    if(t->next ==NULL)
	return(FALSE);
    t->next->next = link;
    ++e->numlines;
    ++e->curline;
    e->curoffset = 0;
    return(TRUE);
}

BOOL BackLine(editstruct *e)
{
    editline far *t;
    if(e->curline > 0)
    {
	--e->curline;
	t = get_nth_line(e,e->curline);

	if(e->curoffset > t->length)
	    e->curoffset = t->length;
	return(TRUE);
    } else
    {
	Beep();
	return(FALSE);
    }
}
BOOL ForwardLine(editstruct *e)
{
    editline far *t;
    if(e->curline < e->numlines)
    {
	++e->curline;
	t = get_nth_line(e,e->curline);
	if(e->curoffset > t->length)
	    e->curoffset = t->length;

	return(TRUE);
    } else
    {
	Beep();
	return(FALSE);
    }
}
BOOL BackArrow(editstruct *e)
{
    if(e->curoffset > 0 )
    {
	--e->curoffset;
	return(TRUE);
    } else
    {
	Beep();
	return(FALSE);
    }

}
BOOL ForwardArrow(editstruct *e)
{
    editline far *t;
    t = get_nth_line(e,e->curline);
    if(t==NULL)
    {
	Beep();
	return(FALSE);
    }
    if(e->curoffset < t->length)
    {
	++e->curoffset;
	return(TRUE);
    } else
    {
	Beep();
	return(FALSE);
    }
}

BOOL DeleteLine(editstruct *e)
{
    editline far *t;
    editline far *link;
    if(e->curline > 0)
    {
       t = get_nth_line(e,e->curline-1);
       if(t==NULL)
	return(FALSE);
       link=t->next;
       t->next = t->next->next;
       if(t->next == NULL)
       {
	t->next = link;
	t->next->length=0;
       }else
       {
	 FreeLine(link);
	 --e->numlines;
       }
    }
    else
    {
	link = e->head->next;
	if(link == NULL)
	    e->head->length = 0;
	else
	{
	   FreeLine(e->head);
	   --e->numlines;
	   e->head = link;
	}
    }
    e->curoffset = 0;
    return(TRUE);
}
BOOL Home(editstruct *e)
{
    e->curoffset = 0;
    return(TRUE);
}
BOOL End(editstruct *e)
{
    editline far *t;
    t = get_nth_line(e,e->curline);
    if(t==NULL)
	return(FALSE);
    e->curoffset = t->length;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\graphics.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/** This module enhances the CW graphics capabilities
**/

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>

VOID  MySetColor(WORD color);
VOID  MySetColor(WORD color)
{
#define NUMCOLORCACHE 10

    static WORD lastcolor[NUMCOLORCACHE] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
    static WORD pcov[NUMCOLORCACHE];
    static WORD rgcoi[3];
    static WORD rgbval[NUMCOLORCACHE];
    static WORD nexttrash = 0;
    int i;

    /* FGetColorPalette is so slow we don't want to do it very often! */
    for(i=0;i<NUMCOLORCACHE;i++)
    {
	if (lastcolor[i] == color)
	{
	  SetColor(pcov[i],rgbval[i]);
	  return;
	}
    }
    /* If we got here, the color is not chached, so
     * we have to trash a color in the cache
     */
    nexttrash = (nexttrash+1)%NUMCOLORCACHE;
       FGetColorPalette(color,&pcov[nexttrash],rgcoi);
       rgbval[nexttrash] = (((((WORD)rgcoi[0]) << 10)&0x7C00) | ((((WORD)rgcoi[1])<<5)&0x3E0) | (rgcoi[2]&0x1F));
       pcov[nexttrash] = color;
       lastcolor[nexttrash] = color;
    SetColor(pcov[nexttrash],rgbval[nexttrash]);
}

/*
 * What PlotBmp Does:
 *  To reduce flashing on the screen (given that there is no srccopy mode
 *  in BitBlt), we erase the pixels which should not be set(black) by blting
 *  the complement of the bitmap through the background color. Then we
 *  blt the actual bitmap to the screen. Thus the fewest number of pixels
 *  *change their color* on the screen.
 *  This is of course an ugly slimy kludge from the nether world since the
 *  drivers should support a srccopy mode.
 *
 */
VOID PlotBmp(BITMAP *bmp,WORD x,WORD y,ISA color)
{
    WORD fore,back;
    GetIsaColor(color,&fore,&back);
    MySetColor(fore);
    Move(x,y);
    FEnableMouseNest(FALSE) ;
    TextOut(&MainWind, (RX) (x/CWIDTH), (RY) (y/CHEIGHT), "    ",bmp->cbRow,color);
    BitBlt(&bmp->rectBound,bmp->lrgb,bmp->cbRow,FALSE);
    FEnableMouseNest(TRUE) ;
}
#if 0
VOID GetBmp(BITMAP *bmp,WORD x,WORD y)
{
	Move(x,y);
	SetColor(0,0x7FFF);
	SetAreaPat(0);
	SetLinePat(1);
	BitRead(&bmp->rectBound,bmp->lrgb,bmp->cbRow);
}
#endif


VOID FrameCharRect(WORD top, WORD left, WORD bottom, WORD right, WORD linepat,ISA color)
{
    RECT lRect;
    WORD fore,back;

    if (gisgraph)
    {
	 lRect.xLeft = left * CWIDTH;
	 lRect.yTop  = top * CHEIGHT;
	 lRect.xRight = right * CWIDTH;
	 lRect.yBottom = bottom *CHEIGHT;

	 FEnableMouseNest(FALSE) ;
	 GetIsaColor(color,&fore,&back);
	 MySetColor(fore);

	 SetAreaPat(0); // Set clear area == 0
	 SetLinePat(linepat);

	 Rectangle(&lRect);
	 FEnableMouseNest(TRUE) ;
    }
}

VOID FrameDialog(WORD top, WORD left, WORD bottom, WORD right)
{
    RECT lRect;
    WORD fore,back;

    lRect.xLeft = left * CWIDTH;
    lRect.yTop	= top * CHEIGHT; /*-3;*/
    lRect.xRight = right * CWIDTH;
    lRect.yBottom = bottom *CHEIGHT;

    FEnableMouseNest(FALSE);

    GetIsaColor(isaBorders,&fore,&back);
    MySetColor(fore);

    SetAreaPat(0);
    SetLinePat(1);

    Rectangle(&lRect);
    lRect.xLeft  += 2;
    lRect.yTop	 += 2;
    lRect.xRight -= 2;
    lRect.yBottom -= 2;
    Rectangle(&lRect);
    lRect.xLeft  += 1;
    lRect.yTop	 += 1;
    lRect.xRight -= 1;
    lRect.yBottom -= 1;
    Rectangle(&lRect);

    FEnableMouseNest(TRUE);
}

VOID FrameButton(WORD top, WORD left, WORD bottom, WORD right)
{
    RECT lRect;
    int i;
    int round;
    WORD fore,back;
    if(!gisgraph)
	return;
    GetIsaColor(isaPushButton,&fore,&back);
    MySetColor(back);
    SetAreaPat(0);
    SetLinePat(1);


     lRect.xLeft = left * CWIDTH     + CWIDTH;
     lRect.yTop  = top * CHEIGHT     ;
     lRect.xRight = right * CWIDTH   - CWIDTH;
     lRect.yBottom = bottom *CHEIGHT ;

     FEnableMouseNest(FALSE);
     round = 1;
     for(i=0;i<(CHEIGHT+1)/2;i++)
     {
	MySetColor(back);

	Move(lRect.xLeft + CWIDTH,lRect.yTop+i);
	Draw(lRect.xLeft-round+1,lRect.yTop+i);

	Move(lRect.xRight - CWIDTH,lRect.yTop+i);
	Draw(lRect.xRight+round-1,lRect.yTop+i);

	Move(lRect.xLeft + CWIDTH,lRect.yTop+CHEIGHT-i-1);
	Draw(lRect.xLeft-round+1,lRect.yTop+CHEIGHT-i-1);

	Move(lRect.xRight - CWIDTH,lRect.yTop+CHEIGHT-i-1);
	Draw(lRect.xRight+round-1,lRect.yTop+CHEIGHT-i-1);
	if(i == 0)
	{
	    round+=2;
	}
	if(i == 1)
	    ++round;
	if(i == 3)
	    ++round;

     }
     round = 1;
     for(i=0;i<(CHEIGHT+1)/2;i++)
     {

	MySetColor(fore);
	Move(lRect.xLeft-round,lRect.yTop+i);
	Draw(lRect.xLeft-round,lRect.yTop+i);
	Move(lRect.xRight+round,lRect.yTop+i);
	Draw(lRect.xRight+round,lRect.yTop+i);

	Move(lRect.xLeft-round,lRect.yTop+CHEIGHT-i-1);
	Draw(lRect.xLeft-round,lRect.yTop+CHEIGHT-i-1);
	Move(lRect.xRight+round,lRect.yTop+CHEIGHT-i-1);
	Draw(lRect.xRight+round,lRect.yTop+CHEIGHT-i-1);
	if(i == 0)
	{
	    Move(lRect.xLeft-round-1,lRect.yTop+i);
	    Draw(lRect.xLeft-round-1,lRect.yTop+i);
	    Move(lRect.xRight+round+1,lRect.yTop+i);
	    Draw(lRect.xRight+round+1,lRect.yTop+i);

	    Move(lRect.xLeft-round-1,lRect.yTop+CHEIGHT-i-1);
	    Draw(lRect.xLeft-round-1,lRect.yTop+CHEIGHT-i-1);
	    Move(lRect.xRight+round+1,lRect.yTop+CHEIGHT-i-1);
		Draw(lRect.xRight+round+1,lRect.yTop+CHEIGHT-i-1);

	    round+=2;
	}
	if(i == 1)
	    ++round;
	if(i == 3)
	    ++round;
	 }
	 /* BUG BUG if you don't set the color here, buttons look like
	  * donkey dicks on hercules graphics.
	  * We don't know why exactly, but there they are!
	  */
	 if(fMonochrome)
		SetColor(0,0x7FFF);

	 Move(lRect.xLeft, lRect.yTop-1);
	 Draw(lRect.xRight, lRect.yTop-1);
	 Move(lRect.xLeft, lRect.yTop+CHEIGHT);
	 Draw(lRect.xRight, lRect.yTop+CHEIGHT);

	 FEnableMouseNest(TRUE);
}


VOID FrameCharRectInset(WORD top, WORD left, WORD bottom, WORD right,WORD inx,WORD iny,ISA color)
{
    RECT lRect;
    WORD fore,back;
#define SCREENMINX 0
#define SCREENMINY 0
#define SCREENMAXX (axMac * CWIDTH)
#define SCREENMAXY (ayMac * CHEIGHT)

    lRect.xLeft =  (left * CWIDTH)-inx;
    if (lRect.xLeft < SCREENMINX)
	lRect.xLeft = SCREENMINX;
    if (lRect.xLeft > SCREENMAXX)
	lRect.xLeft = SCREENMAXX;

    lRect.yTop	=  (top * CHEIGHT)-iny;
    if (lRect.yTop < SCREENMINY)
	lRect.yTop = SCREENMINY;
    if (lRect.yTop > SCREENMAXY)
	lRect.yTop = SCREENMAXY;

    lRect.xRight = (right * CWIDTH)+inx;
    if (lRect.xRight < SCREENMINX)
	lRect.xRight = SCREENMINX;
    if (lRect.xRight > SCREENMAXX)
	lRect.xRight = SCREENMAXX;

    lRect.yBottom =(bottom *CHEIGHT)+iny;
    if (lRect.yBottom < SCREENMINY)
	lRect.yBottom = SCREENMINY;
    if (lRect.yBottom > SCREENMAXY)
	lRect.yBottom = SCREENMAXY;


    SetAreaPat(0);
    SetLinePat(1);
    GetIsaColor(color,&fore,&back);
	MySetColor(fore);
    Rectangle(&lRect);

}

void EasyDrawBox(PWND pwd, BYTE top, BYTE left, BYTE bottom, BYTE right,ISA isa)
{
    RRC trect;
    BOX  tboxinfo;

    tboxinfo.chTopLeftCorner	  = cinch._chTopLeftCorner1;
    tboxinfo.chTopRightCorner	  = cinch._chTopRightCorner1;
    tboxinfo.chBottomLeftCorner   = cinch._chBottomLeftCorner1;
    tboxinfo.chBottomRightCorner  = cinch._chBottomRightCorner1;
    tboxinfo.chTopSide		  = cinch._chTopSide1;
    tboxinfo.chBottomSide	  = cinch._chBottomSide1;
    tboxinfo.chLeftSide 	  = cinch._chLeftSide1;
    tboxinfo.chRightSide	  = cinch._chRightSide1;
    trect.ryTop = top;
    trect.rxLeft = left;
    trect.ryBottom = bottom;
    trect.rxRight = right;
    FEnableMouseNest(FALSE) ;
    DrawBox(pwd, &trect, &tboxinfo, isa);
    FEnableMouseNest(TRUE) ;
} /* EasyDrawBox */

/* draws a line from (x1, y1) to (x2, y2) */
void EasyDrawLine(BYTE x1, BYTE y1, BYTE x2, BYTE y2, BOOL fdec)
{
    AX ty1, ty2 ;

    FEnableMouseNest(FALSE) ;
    /* ZZZZZ Should this nonsense be done each time we do a draw */
    SetAreaPat(0);
    SetLinePat(1);
    SetColor(0,0x7FFF);
    ty1 = y1*CHEIGHT ;
    ty2 = y2*CHEIGHT ;
    if (fdec)
    {
	ty1-- ; ty2-- ;
    }
    Move(x1*CWIDTH, ty1) ;
    Draw(x2*CWIDTH, ty2) ;
    FEnableMouseNest(TRUE) ;
} /* EasyDrawLine */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\flatleft.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*  --------  --------- ---------------------------------------------------
**   10/10/89  harikris Created this file - flatleft.c
**   12/11/89  harikris Optimized it to use tree->SizeSel & tree->NumSel
**                      instead of having to call GetTreeSelInfo!
*/
#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>
#include <help.h>

extern BOOL gfFMBeingInited ;

#if defined(SWE)|| defined(RUS)
  void CopyNumberYST(char *dest, unsigned long val, BOOL fFillBlanks, int maxc);
#endif

/****   DispFlatLeft - Displays the info about the node
**
**      ENTRY
**              node - The file node whose info is to be displayed
**              tree - The tree to which it belongs.
*/

/* Note: Same Stuff is used by showinfo too!!  ShowInfo Dialogue box should */
/*        thus be as wide as this width!!                                   */
/*                                                                          */

/* ZZZ We can get rid of extra blanks to the right of the showinfo strings
	and dynamically generate them. This may slow flat display quite a bit.
	Also we need to only re-display the non-static strings on screen,
	that is only the info that changes. This doesn't seem to be a problem
	though. Disk may not have to re-read for info like label, etc!
*/
//  BEGIN  - IPG (Mihindu)  Moved to DOSSHELL\INC\TEXT.H
// /* INTERNATIONALIZE HERE! */
// /* INFOWIDTH is the number of characters in the Info strings! So, if the    */
// /* strings are changed, this constant has to be changed too. It should be   */
// /* noted that these strings are actually modified in place -- by filling in */
// /* the names, numbers of files, etc. It should also be borne in mind that 25*/
// /* is about the right(max) number, as screens generally are 80 chars wide, and*/
// /* System Tree Mode in the file list box uses up 52 chars! We also would    */
// /* like to have framing around the file information we display (1 char on   */
// /* sides). The other constants below may also need tinkering on internat....*/
// #define INFOWIDTH        22

// #define NAMEOFFSET   10 /* Index into the info strings where the name starts */

// #define RIGHTMARGIN  (INFOWIDTH-1)  /* offset of last character -- i.e., index
//                                         of end of buffer in our case.  */
// #define RIGHTDRIVEOFFSET  RIGHTMARGIN /* location (index) of right drive letter */
// #define LEFTDRIVEOFFSET  (RIGHTMARGIN-6) /* location (index) of left drive letter */

// /* INTERNATIONALIZE HERE! */
// /* The following are the attribute characters */
// #define READCH 'r'
// #define HIDDCH 'h'
// #define SYSTCH 's'
// #define ARCHCH 'a'
//  END  - IPG (Mihindu)  Moved to DOSSHELL\INC\TEXT.H

#define FILLCH '.'

/* (XTopLeft, YTopLeft) is the relative coordinate in pwnd, where the first
	character of the first text line is placed. */

void DispFlatLeft(PENTRY node, PTREE tree, PWND pwnd, RX XTopLeft,
						RY YTopLeft, ISA isa)
{
    char fname[NAMELEN+EXTLEN+2] ;
    PENTRY parent ;
    unsigned numfiles ;
    /* ZZZ we could reuse some of these variables but readability lost!
       compiler should anyway optimize these */
    unsigned long dirsize, selsize ;
	 unsigned int DummyNumSelFiles ;

#ifndef NOCONSISTENCY
    if (node->attribs & _A_SUBDIR)
    {
		printf("**** showinfo called with a directory node\n") ;
		exit(0) ;
    }
#endif

	/* If node == NULL, we need to display 'No File' for file entry
		but directory stuff should be proper stuff! */

	if (node)
	Internal2Normal(fname, node->name) ;
	else
		strcpy(fname, NoFile) ;

    CopyNameForTextOut(FileName+NAMEOFFSET, fname) ;

    /* The compiler should optimize these indexing operations */
    FileAttr[NAMEOFFSET] = ( node && (node->attribs & _A_RDONLY) ) ? 
					  (char) READCH : (char) FILLCH ;
    FileAttr[NAMEOFFSET+1] = ( node && (node->attribs & _A_HIDDEN) ) ? 
					  (char) HIDDCH : (char) FILLCH ;
    FileAttr[NAMEOFFSET+2] = ( node && (node->attribs & _A_SYSTEM) ) ? 
					  (char) SYSTCH : (char) FILLCH ;
    FileAttr[NAMEOFFSET+3] = ( node && (node->attribs & _A_ARCH) ) ? 
					  (char) ARCHCH : (char) FILLCH ;

    SelectedHeader[RIGHTDRIVEOFFSET] = glob.SelTree[1]->root[0] ;
    
    CopyNumberForTextOut(SelectedNumber+RIGHTDRIVEOFFSET,
				  (unsigned long) glob.SelTree[1]->NumSel, TRUE) ;
	selsize = glob.SelTree[1]->SizeSel ;
    if (glob.SelTree[0] != glob.SelTree[1])
    {
		SelectedHeader[LEFTDRIVEOFFSET] = glob.SelTree[0]->root[0] ;
		CopyNumberForTextOut(SelectedNumber+LEFTDRIVEOFFSET,
					(unsigned long) glob.SelTree[0]->NumSel, TRUE) ;
		selsize += glob.SelTree[0]->SizeSel ;
    }
	CopyNumberForTextOut(SelectedSize+RIGHTDRIVEOFFSET, selsize, TRUE) ;

	if (!node)
		parent = listinfo[glob.FocusBox].files ;
	else
	{
		parent = FindParent(node) ;
		if (glob.TreeMode == TR_SYSTEM)
		{
			listinfo[0].files = parent ;
			/* The follwoing sets the line with the check mark -- so that
			 * switching back to Single/Double tree mode is fine -- i.e.,
			 * the focus will be on the right directory!
			 */
			// glob.lineselected[0] = GetIndexDir(parent, tree) ;
		}
	}

    if (!parent)
		strcpy(fname, RootName) ;  /* Root directory is the parent */
    else
		Internal2Normal(fname, parent->name) ;
    CopyNameForTextOut(DirectoryName+NAMEOFFSET, fname) ;

    numfiles = GetDirInfo(parent, tree, &dirsize, &DummyNumSelFiles) ;
	CopyNumberForTextOut(DirectorySize+RIGHTMARGIN, dirsize, TRUE) ;
    CopyNumberForTextOut(DirectoryFiles+RIGHTMARGIN,
					 (unsigned long) numfiles, TRUE) ;

    if (!tree->fdiskinfoknown)
    {
		if (GetDiskInfo(tree, tree->VolLabel, &tree->SizeTotal,
																&tree->SizeAvail))
		{
	     tree->fdiskinfoknown = TRUE ;
		}
		/* else GetDiskInfo clears out old info */
    }
    CopyNameForTextOut(DiskName+NAMEOFFSET, tree->VolLabel) ;
	CopyNumberForTextOut(DiskSize+RIGHTMARGIN, tree->SizeTotal, TRUE) ;
	CopyNumberForTextOut(DiskAvail+RIGHTMARGIN, tree->SizeAvail, TRUE) ;

    CopyNumberForTextOut(DiskFiles+RIGHTMARGIN,
					  (unsigned long) tree->Diskfilecount, TRUE);
    /* Add 1 for the root directory -- It is not part of DirCount */
    CopyNumberForTextOut(DiskDirs+RIGHTMARGIN,
					  (unsigned long) tree->DirCount+1, TRUE) ;

	FEnableMouseNest(FALSE) ;

	/* ZZZZZZZZZ put this in a loop and make these strings arrays */
    TextOut(pwnd, XTopLeft, YTopLeft, FileHeader, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+1, FileName, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+2, FileAttr, INFOWIDTH, isa) ;


    TextOut(pwnd, XTopLeft, YTopLeft+3, SelectedHeader, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+4, SelectedNumber, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+5, SelectedSize, INFOWIDTH, isa) ;

    TextOut(pwnd, XTopLeft, YTopLeft+6, DirectoryHeader, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+7, DirectoryName, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+8, DirectorySize, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+9, DirectoryFiles, INFOWIDTH, isa) ;

    TextOut(pwnd, XTopLeft, YTopLeft+10, DiskHeader, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+11, DiskName, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+12, DiskSize, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+13, DiskAvail, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+14, DiskFiles, INFOWIDTH, isa) ;
    TextOut(pwnd, XTopLeft, YTopLeft+15, DiskDirs, INFOWIDTH, isa) ;

	FEnableMouseNest(TRUE) ;

} /* DispFlatLeft */


/*  Copies the name from 'src' to 'dest'. 'dest' is assumed to have a
    NULL character at its extreme (last character in memory allocated to it)
    'src' is a null terminated name.   */
void CopyNameForTextOut(char *dest, char far *src)
{
    for ( ; *src ; src++, dest++)
	*dest = *src ;
    while(*dest && (*dest != ' '))
	/* Blank out previous garbage characters after name -- Note that we know
       that everything to the right of a blank is a blank */
	*(dest++) = ' ' ;
}

/*  Copies the number from 'val' to 'dest'. 'dest' is assumed to have a
    blank at the left location where the 'val' can't encroach. This is
    used to blank out leftover characters from previous call in buffer
    'dest' is actually a pointer to the end of the buffer.              */
char *CopyNumberForTextOut(char *dest, unsigned long val, BOOL fFillBlanks)
{
    int j ;
	unsigned long val2, val3 ;

    j = 0;
    do
    {
		if (j >= 3)
		{
			*(dest--) = DIGITSEP ;
			j = 0 ;
		}
		val3 = val/10 ;
		val2 = (val3<<1) + (val3<<3) ;  /* val2 = val3*10 */
		val2 = val - val2 ; /* val2 = val % 10 */
		*(dest--) = (char) (val2+'0');
		j++ ;
		val = val3 ;

    } while(val>0);

	if (fFillBlanks)
	{
		/* Blank out previous garbage characters before number -- Note that
		 * we know that everything to the left of a blank is a blank
		 * and that there will be at least 1 blank (the one after the ':').
		 */
		while (*dest != ' ')
			*(dest--) = ' ' ;
	}
	return (dest+1) ; /* ptr to last char added to dest */
}

#if defined(SWE)|| defined(RUS)
  void CopyNumberYST(char *dest, unsigned long val, BOOL fFillBlanks, int maxc)
   {
	 int j, p;
	unsigned long val2, val3 ;

	 j = 0;
	 p = 0;
	 do
	 {
		if (j >= 3)
		{
			*(dest--) = DIGITSEP ;
			j = 0 ;
			p++;
		}
		val3 = val/10 ;
		val2 = (val3<<1) + (val3<<3) ;   /* val2 = val3*10 */
		val2 = val - val2 ; /* val2 = val % 10 */
		*(dest--) = (char) (val2+'0');
		j++ ;
		p++;
		val = val3 ;

	 } while(val>0);

	if (fFillBlanks)
	{
		/* Blank out previous garbage characters before number -- Note that
		 * we know that everything to the left of a blank is a blank
		 * and that there will be at least 1 blank (the one after the ':').
		 * 
		 * Note from YST (16/08/91 MS IPG Ireland). 
		 * I changed blank to ':', because Sweden, Russian and etc. uses
		 * blank as thousand separator and if previous values was more
		 * then 1 000 then we had garbage on the screen. 
		 * If your country use ':' as separator, change this again.
		 *                                     (  YST)
		 */
		while ((*dest !=':') && (p < maxc)) {
			*(dest--) = ' ' ;
			p++;
		}
	}
   }
#endif

/* function reads the appropriate storage media (based on tree) and passes
   back by reference the disk label, disk size and disk avail. The status it
   returns indicates whether the information was succesfully retrieved.
   Problems could occur for removable media. Returns true for success
   else false */
int GetDiskInfo(PTREE tree, char far *disklabel, unsigned long far *disksize,
															unsigned long far *diskavail)
{
	char *pch ;
	struct diskfree_t d_info ;
	struct find_t f_info ;
	char rootpath[10] ; // will store path of the form C:\*.*
	int ret, action ;
	char *tempcaption ;

	do 
	{
		action = ACT_OK ;

	/* Map name of the root directory of tree. Map 'A' to 1, etc. */
	if (! (ret = _dos_getdiskfree(*(tree->root) - 'A' + 1, &d_info)))
	{
			/* call was succesful */
			*disksize = (unsigned long) d_info.total_clusters *
				d_info.sectors_per_cluster * d_info.bytes_per_sector ;
			*diskavail = (unsigned long) d_info.avail_clusters *
				d_info.sectors_per_cluster * d_info.bytes_per_sector ;
	}
	else
	{       /* Unsuccesful call */
			if (!gfFMBeingInited)
			{
				tempcaption = gpszFileOpCaption ;
				gpszFileOpCaption = szErrorCaption ;
				action = DOSErrorBox(szDiskInfo, errno, HELP_ERRDISKFREE) ;
				gpszFileOpCaption = tempcaption ;
			}
	}
	} while (action == ACT_RETRY) ;

	if (ret)
	{
		/* _dos_getdiskfree failed, We send back garbage values! */
		*disksize = *diskavail = 0 ;
		strfcpy(disklabel, NoLabel) ;
		return FALSE ;
	}

	/* get the disk's volume Label now */
	/* ZZZ Do I retry in a loop on error like unformatted disk, etc? */

	strfcpy(rootpath, tree->root) ;
	strcpy(rootpath+3, szStarDotStar) ;

	if (!shell_findfirst(rootpath, _A_VOLID, &f_info))
	{
		/* label found succesfully. If '.' is present remove it ! */
		for (pch = f_info.name ; *pch ; pch++)
			if (*pch != '.')
				*(disklabel++) = *pch ;
		*disklabel = '\0' ;
	}
	else
		strfcpy(disklabel, NoLabel) ;

	return TRUE ; /* Succesful return */
} /* GetDiskInfo */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\fileops.c ===
/* Revision history since 5.0 Golden:
 *
 *  M012 SHK 07/31/91 Fixed bug in fn CopyIt(). It used to screw up
 *							 if file size was between 64K-512 and 64K-256
 *
 */

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   fileops.c - fns to execute each operation on selected files
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  8/16/89       t-jeffro      Created file
**  8/28/89   t-jeffro  added loads of error handling
**  10/??/89  harikris  Changed lots and lots, added several new functions.
*/
#include <ctype.h>
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <help.h>
#include <fileopts.hs>
#include <fileopts.sdm>
#include <rename.hs>
#include <rename.sdm>

#include <assert.h>

#define COPY_SUCCESS                            100
#define COPY_SRC_OPEN_ERR               2
#define COPY_DST_CREAT_ERR      4
#define COPY_RD_WR_ERR                  6

extern BYTE ErrorCrit ;

extern char * PASCAL MySetMessageText(TMC tmc, char *message, int nWid) ;
extern void Marklastdir(PTREE tree) ;
extern void InsertDirAndMarkLastDirBits(PTREE tree, PENTRY parent, PENTRY newdir) ;
extern void InsertDir(PTREE tree, PENTRY parent, PENTRY newdir) ;
extern PENTRY HandleDeletednext(PTREE tree, PENTRY deldir) ;
extern VOID easycheck(int (FAR *theproc)(), BOOL docheck) ;
extern int ReplaceConfirmationDialog(char *srcpath, char *destpath, 
											PENTRY srcnode, struct find_t destfindinfo) ;
extern int DeleteConfirmationDialog(char *dpath, BOOL fIsDelFile, char *Message) ;
extern BOOL FPerformOpOnDirFilesAlone(void);

/* ZZZZ should I use a different error number & provide a specific help message
 * on this error as this is a new feature!
 */
#define NESTING_DEEP_ERR 5

#define m_fPerformingMoveFile() (gpszFileOpCaption == szMoveFileCaption)

/* We try to allocate a copy buffer size to be a multiple of this number,       */ 
/*      which is the sector size!                                                                                               */
#define BUFSIZE 512 

/****   DeleteFile - delete one file with verification
**
**      ENTRY
**              tree  - tree containing file to delete
**              node  - node of file to delete
**              placeholder - just that
**              total - number of selected files
**              count - index in selected files
**              verify- if FALSE, do not put up any verification dialog box, else
**                                put it up in case glob.VerifyDelete is TRUE.
**      EXIT
**              Action code from GetResponse().
**      WARNING
**              This fn's argument list must match that in DoFileOp(), as this fn is
**      called through a ptr by DoFileOp().
*/      
/* ZZZZ placeholder unused. */
int DeleteFile(PTREE tree, PENTRY node, char *placeholder, int count, 
																	int total, BOOL verify)
{
	int action;
	char path[MAX_PATH+1];                                  // path of file
	char statusline[STATUS_LEN];
	BOOL fIPutMsgUp ;
	int dummylen ;

	UnReferenced(placeholder) ;
	Tree2Path(tree, node, path, &dummylen);

	FormCountStatusLine(statusline, szOpDelFile, path, count, total, 
													STATUS_COUNT_START) ;
	action = ACT_FORCE;
	if (verify)
	{
		/* Always prompt if Read Only file in case "verify" is TRUE */
		if (node->attribs & _A_RDONLY)
		{
			action = DeleteConfirmationDialog(path, TRUE, szWarningReadOnly) ;
		}
		// else
		else if (glob.VerifyDelete)
		{
			action = DeleteConfirmationDialog(path, TRUE, NullString) ;
		}
	}
	switch (action)
	{
		case ACT_FORCE: 
		case ACT_OK:    
				/* If gfStatusMsg is TRUE, A status message has already been
					put up (by MoveFile)!! Note that this fn (DeleteFile) is
					called to do the 'DeleteFile' menu operation and also by
					MoveFile as part of its total operation!
				*/
				if (!m_fPerformingMoveFile())
				{
					fIPutMsgUp = TRUE ;
					PutUpStatusMessage(statusline, count) ;
				}
				else
					fIPutMsgUp = FALSE ;

				action = KillFile(statusline, path);

				/* If we didn't put up the message, we shouldn't take it off.
					It is the task of the person who actually put it up.
				*/
				if (fIPutMsgUp)
				{
					TakeDownStatusMessage(count, total) ;
				}
		default:
				break;
	}
	if (action == ACT_FORCE)
		return ACT_OK;
	else
		return action;
} /* proc DeleteFile */

/****   KillFile - delete a file even if it is read-only
**
**              This fn removes any read-only status from the given file and deletes it.
**
**      ENTRY
**                      path - file to excise
**  EXIT
**                      ACT_OK, ACT_SKIP or ACT_CANCEL.
**      WARNING
**                      The file must exist.
**      NOTE
**                      The file is removed from its in-memory tree also.
*/
int KillFile(char *statusline, char *path)
{
	treehdr far *tree;                                              // tree containing file
	PENTRY node;                                            // file's tree entry
	PENTRY parent;                                          // file's parent
	unsigned attr;                                          // file's attributes
	int code;                                                       // return code from dos call
	int action;                                                     // user's requested action
	BYTE dummy ;

	do {
		code = _dos_getfileattr(path, &attr);
		if (code)
			action = DOSErrorBox(statusline, code, HELP_ERRGETATTR);
		else
			action = ACT_OK;
	} while (action == ACT_RETRY);
	if (action != ACT_OK && action != ACT_FORCE)
	{
		return ( (action == ACT_SKIP) ? ACT_SKIP : ACT_CANCEL ) ;
	} else
	{
		/* This function cannot handle a DeleteDirectory! This problem can
		 * if the user has changed the floppy say and the new disk has a
		 * directory the same name as the file in the original disk.
		 */
		if (attr & _A_SUBDIR)
		{
			return ACT_CANCEL ;
		} else if (attr & _A_RDONLY)
		{
			do {
				ErrorCrit = 0xFF ;
				code = _dos_setfileattr(path, 0);
				if (code)
				{
					/* Did a critical error occur? -- say, disk write protected! */
					if (ErrorCrit != 0xFF)
						action = GetResponse(statusline, 
											szCriticalMessages[ErrorCrit], 
											BT_FILERETRYSKIPQUIT, HELP_ERRSETATTR);
					else
						action = DOSErrorBox(statusline, code, HELP_ERRSETATTR);
				}
				else
					action = ACT_OK;
			} while (action == ACT_RETRY);

			if (action != ACT_OK && action != ACT_FORCE)
			{
				return ( (action == ACT_SKIP) ? ACT_SKIP : ACT_CANCEL ) ;
			}
		}

		do {
			ErrorCrit = 0xFF ;
			code = unlink(path);
			if (code)
			{
				/* Was there a critical error during this operation -- like
				 * say "write-protect" disk, etc.
				 */
				if (ErrorCrit != 0xFF)
					action = GetResponse(statusline, szCriticalMessages[ErrorCrit], 
												BT_FILERETRYSKIPQUIT, HELP_ERRDELFILE);
				else
					/* We could execute the following code on a read-only share
					 * where we don't have access rights!
					 */
					action = DOSErrorBox(statusline, errno, HELP_ERRDELFILE) ;
			}
			else
				action = ACT_OK;
		} while (action == ACT_RETRY);

		if (code)
		{
			return action;
		} else
		{
			tree = FindTree(path, &dummy);

			/* If tree has been fully read in, then update tree data structure
			 * Note that if we tried to copy/move files to a tree that has
			 * not been read in, we call JunkTree() on it anyway. One
			 * cannot call DeleteFile on a tree that has not been read in. We
			 * allow DeleteFile() only if user has explicitly selected files
			 * from within the SHELL. That field is non-editable.
			 */
			if ( tree && (tree->Started) && (!tree->ContinueTree) )
			{
				tree->Diskfilecount-- ; // one less file on disk as unlink succeeded

				if (2 == FindNode(tree, path, &parent, &node, FALSE))
					DelFileEntry(tree, parent, node);
			}

			return ACT_OK ;
		}
	}
} /* proc KillFile */

/****   CopyFile - copy one file with verification
**              This fn copies the file specified by 'tree' and 'node' into 'path'.
**      ENTRY
**              tree  - tree containing file to copy
**              node  - node of file to copy
**              path  - destination file name
**              total - number of selected files
**              count - index in selected files
**              verify- pop up verification dbox on overwrite
**      EXIT
**              Action code from GetResponse().
*/      
int CopyFile(PTREE tree, PENTRY node, char *path, int count, 
																		int total, BOOL verify)
{
	int ret;                                                                // return code
	char oldpath[MAX_PATH+1] ;
	char statusline[STATUS_LEN];
	BOOL fIPutMsgUp ;
	struct find_t findinfo ;
	PTREE temptree ;
	PENTRY tempparent ;
	int dummylen ;

	Tree2Path(tree, node, oldpath, &dummylen);

	FormCountStatusLine(statusline, szOpCopyFile, oldpath, count, total, 
													STATUS_COUNT_START) ;

	/* ZZZZZZ get true name and then compare the two!!!! */
	/* See if we are trying to copy a file onto itself */
	if (!strcmp(path, oldpath))
	{
		// chastise the user saying that the file can't be copied onto itself.
		ret = GetResponse(statusline, szNoSelfCopy, BT_SKIPQUIT, HELP_NOSELFCOPY) ;
	}
	else if (_dos_findfirst(path, _A_HIDDEN | _A_SYSTEM, &findinfo))
		ret = ACT_OK;
	// If force is TRUE, skip the questionnaire dialogue box.
	else if (verify || (findinfo.attrib & _A_RDONLY) )
	{
		// file exists, ask what to do.
		ret = ReplaceConfirmationDialog(oldpath, path, node, findinfo) ;
	} else
		ret = ACT_FORCE;

	/* If gfStatusMsg is TRUE, A status message has already been
	 *      put up (by MoveFile)!! Note that this fn (DeleteFile) is
	 *      called to do the 'DeleteFile' menu operation and also by
	 *      MoveFile as part of its total operation!
	 */
	if ( (!m_fPerformingMoveFile()) && ( (ret == ACT_OK) || (ret == ACT_FORCE) ) )
	{
		fIPutMsgUp = TRUE ;
		PutUpStatusMessage(statusline, count) ;
	}
	else
		fIPutMsgUp = FALSE ;

	switch (ret)
	{
		case ACT_FORCE: 
				ret = KillFile(statusline, path);
				if (ret != ACT_OK)
					break ;
		case ACT_OK:    
				ret = CopyIt(tree, node, path, count, total);
		default:                
				break;
	}

	/* If we didn't put up the message, we shouldn't take it off.
	 *      It is the task of the routine which actually put it up.
	 */
	if (fIPutMsgUp)
		TakeDownStatusMessage(count, total) ;

	if (ret == ACT_FORCE)
		ret = ACT_OK;

	if (ret == ACT_OK)
	{
		fileinfo rec;                                   // copied file's info

		/* Build record of copied file.
		*/
		FillRecName(path, (PENTRY) &rec); // put name/ext into record
		rec.dtlx.dt.time = node->dtlx.dt.time;
		rec.dtlx.dt.date = node->dtlx.dt.date;

		rec.attribs = node->attribs;

		/* The ReadOnly bit is not preserved unless we do a MoveFile. See
		 * fn CopyIt().
		 */
		if (!m_fPerformingMoveFile())
			rec.attribs = rec.attribs & (~_A_RDONLY) ;

		rec.nosib = rec.SELECTED = 0;
		rec.x.f.size = node->x.f.size;

		/* AddLateFile will locate the proper tree and add our record to it.
		** If the tree is compacted, the record may not actually be added.
		*/
		/* we need to pass in non-null values (temptree and tempparent)
		 * because fn AddLateFile uses these storages.
		 */
		if (!AddLateFile(path, &rec, temptree, tempparent, 0))
			// ret = ACT_NOMEM;
			ret = ACT_CANCEL;
	}

	return ret;
} /* proc CopyFile */

/****   CopyIt - copy a single file
**      This fn takes a source and target path and copies the former into the
**      latter.
**
**      ENTRY
**              tree  - tree containing source file
**              node  - node of source file
**              dest  - target path
**              total - number of selected files
**              count - which one this is
**      EXIT
**              Action code from DOSErrorBox() if error, or ACT_OK if no errors.
**
**      WARNING:
**              This fn cannot write over a read-only file; the caller must delete the
**      existing file himself if that is the intended action.
**
**      EFFECTS:
**          Allocates and frees memory; does disk reads and writes.
*/
int CopyIt(PTREE tree, PENTRY node, char *dest, int count, int total)
{
	unsigned hsrc;                                                          // source file handle
	unsigned hdest;                                                         // target file handle
								
	unsigned rcnt;                                                          // number of bytes read
	unsigned wcnt;                                                          // # of bytes written
	void far *buf;                                                          // intermediate buffer
	unsigned bufsize;                                                       // size of temp buffer
								
	unsigned attr;                                                          // attributes of src file
	unsigned time;                                                          // timestamp of src file
	unsigned date;                                                          // datestamp of src file

	int code;                                                                       // return code of dos call
	int action;                                                                     // what to do about error
	char src[1+MAX_PATH];                                           // path of source file
	char statusline[STATUS_LEN];
	char distance = COPY_SUCCESS;                                           // how far did we get?
	BYTE dummy ;
	int dummylen ;

	Tree2Path(tree, node, src, &dummylen);
	
	FormCountStatusLine(statusline, szOpCopyFile, src, count, total, 
														STATUS_COUNT_START) ;
	/* Determine copy buffer size.
	*/

	// M012 fixed the following compare in the IF statement!
	/* Note that we can only read a maximum of 64K-1 at a time from the disk!
	 * So we try to allocate a buffer that is a multiple of sector size
	 * (512 bytes typically) and the maximum size this can be is
	 * 64K (0x10000L - 512) and still be a WORD!
	 */
	if (node->x.f.size >= (0x10000L-BUFSIZE))
		bufsize = 0x10000L-BUFSIZE ;
	else {
		/* Round size of buffer up to nearest sector - one hopes
		** that this will improve copy speed.
		*/
		unsigned u;

		bufsize = (unsigned) node->x.f.size;
		u = bufsize % BUFSIZE;
		if (u)
			bufsize = bufsize - u + BUFSIZE;
	}
	
	/* Try to allocate copy buffer.  If alloc fails, try a half-size
	** buffer.  Loop.
	*/
	buf = NULL;
	do {
		buf = LpbAllocWorkFar(bufsize);
		if (!buf)
			bufsize /= 2;
	} while (!buf && bufsize);

	if (!buf)
	{
		OutOfMemory() ;
		/* ZZZZ */
		/* Exit At this point -- there isn't even 1 byte of memory free */
		/* or try to run the compaction algorithms! */
	}

	/* Set up file handles.
	*/
	do {
		code = _dos_open(src, O_RDONLY | O_BINARY, &hsrc);
		if (code)
		{
			/* pop up dbox explaining problem */
			action = DOSErrorBox(statusline, code, HELP_ERROPENSRC);
		} else
		{
			action = ACT_OK;
		}
	} while (action == ACT_RETRY);
	if (action != ACT_OK || action == ACT_FORCE)
	{
		distance = COPY_SRC_OPEN_ERR;
		goto abend;
	}

	_dos_getfileattr(src, &attr);

	do {
		code = _dos_creat(dest, 0, &hdest);
		if (code)
			action = DOSErrorBox(statusline, code, HELP_ERRCREATEDEST);
		else
		{
			tree = FindTree(dest, &dummy) ;
			/* ZZZZZ  remove following assert before shipping */
			assert(tree != NULL) ;

			tree->Diskfilecount++ ;

			action = ACT_OK;
		}
	} while (action == ACT_RETRY);
	if (action != ACT_OK && action != ACT_FORCE)
	{
		distance = COPY_DST_CREAT_ERR;
		goto abend;
	}
	
	/* Actual copying.
	*/
	do {
		// Read a chunk.
		do {
			code = _dos_read(hsrc, buf, bufsize, &rcnt);
			if (code)
			{
				/* pop up dbox explaining problem */
				action = DOSErrorBox(statusline, code, HELP_ERRREADSRC);
			} else
			{
				action = ACT_OK;
			}
		} while (action == ACT_RETRY);
		if (action != ACT_OK || action == ACT_FORCE)
		{
			distance = COPY_RD_WR_ERR;
			goto abend;
		}

		// Write a chunk.
		do {
			code = _dos_write(hdest, buf, rcnt, &wcnt);
			if (code)
			{
				/* pop up dbox explaining problem */
				action = DOSErrorBox(statusline, code, HELP_ERRWRITEDEST);
			} else
			{
				action = ACT_OK;
			}
		} while (action == ACT_RETRY);
		if (action != ACT_OK || action == ACT_FORCE)
		{
			distance = COPY_RD_WR_ERR;
			goto abend;
		}

		// Make sure we didn't run out of disk space.
		if (rcnt != wcnt)
		{
			action = GetResponse(statusline, szDiskFull, BT_SKIPQUIT, HELP_DISKFULL);
			distance = COPY_RD_WR_ERR;
			goto abend;
		}
	} while (wcnt);
	
	/* Clean up.
	*/
	_dos_getftime(hsrc, &time, &date);      // mark new file with same
	_dos_setftime(hdest,time, date);        // datestamp as old file.

	/* GOTO here if there is an error setting stuff up.  Yes, goto's are
	** not appreciated by optimisers and maintainers, but we save on
	** duplicated cleanup code by having it here.
	*/
abend:
	switch (distance)
	{
		case COPY_SUCCESS:
		case COPY_RD_WR_ERR:
			_dos_close(hdest);
		case COPY_DST_CREAT_ERR:
			_dos_close(hsrc);
		case COPY_SRC_OPEN_ERR:
			FreeWorkFar(buf);
		default:
			break ;
	}

	if (distance == COPY_SUCCESS)                                   // no errors at all
	{
		/* When we copy a file, the new one created should not be marked
		 * as a ReadOnly file. If it was part of a MOVE operation, it is
		 * better to leave it alone.
		 */
		if (!m_fPerformingMoveFile())
			attr = attr & (~_A_RDONLY) ;

		// copy file's attributes except maybe read only attr
		_dos_setfileattr(dest, attr);
	}
	else if (distance == COPY_RD_WR_ERR)
	{
		/* disk became full when we tried to copy this file. Delete this file */
		unlink(dest);
	}

	return action;
}/* proc CopyIt */

/****   MoveFile - move one file with verification
**              This fn moves the file specified by 'tree' and 'node' into 'path'.
**      ENTRY
**              tree  - tree containing file to move
**              node  - node of file to move
**              path  - destination file
**              total - number of selected files
**              count - index in selected files
**              verify- verify on overwrite
**      EXIT
**              Action code, as from GetResponse().
*/      
int MoveFile(PTREE tree, PENTRY node, char *path, int count, 
																	int total, BOOL verify)
{
	int action;                             // user action
	char currpath[MAX_PATH+1] ;
	char statusline[STATUS_LEN];
	int ret ;
	BOOL jobdone ;
	struct find_t findinfo ;
	int dummylen ;

	jobdone = FALSE ;

	Tree2Path(tree, node, currpath, &dummylen) ;
	FormCountStatusLine(statusline, szOpMoveFile, currpath, count, total, 
													STATUS_COUNT_START) ;
	if (tree->root[0] == path[0])
	{
		/* ZZZZZZ get true name and then compare the two!!!! */
		if ( (ret = strcmp(path, currpath)) )
		{
			/* source and destination are not the same */
			/* Check if destination path exists, if not just rename 
				else check if the user wants to replace that file */
			if (_dos_findfirst(path, _A_HIDDEN | _A_SYSTEM, &findinfo))
			{
				PutUpStatusMessage(statusline, count) ;

				action = RenameFile(tree, node, path, count, total, FALSE);
				jobdone = TRUE ;

				TakeDownStatusMessage(count, total) ;
			}
			else
			{
				if (verify || (findinfo.attrib & _A_RDONLY) )
					action = ReplaceConfirmationDialog(currpath, path, node, findinfo) ;
				else
					action = ACT_OK ;
			}
		}
		else
			action = GetResponse(statusline, szNoSelfCopy, BT_SKIPQUIT, HELP_NOSELFCOPY) ;

		if (!jobdone)
		{
			switch(action)
			{
				case ACT_FORCE:
					action = ACT_OK ;
				case ACT_OK:
					PutUpStatusMessage(statusline, count) ;

					if ( (action = KillFile(statusline, path)) == ACT_OK )
						action = RenameFile(tree, node, path, count, total, 
															FALSE);

					TakeDownStatusMessage(count, total) ;
				default:
					break ;
			} /* switch */
		}
	} else
	{
		PutUpStatusMessage(statusline, count) ;

		// Copy file to new path.
		action = CopyFile(tree, node, path, count, total, verify);

		/* Do I delete source file even if it is read only? That is
		   what I am doing now as verify is FALSE to DeleteFile!! */
		if (action == ACT_OK)
			action = DeleteFile(tree, node, NULL, count, total, FALSE);
		
		/*      Keep in mind that MoveFile is expected to be able to restore the
		** system to its original state if it runs out of memory.  This is
		** accomplished now because it can only run out of memory in copy.
		**      Things will be much harder if Delete can also crap out.
		*/

		TakeDownStatusMessage(count, total) ;
	}
	return action;
} /* proc MoveFile */

/****   FDlgFileOpts - dialog proc for file options dialogue box */
/* Prompts the user for new settings & stores them                              */
BOOL FAR PASCAL FDlgFileOpts(WORD dlm,TMC tmc,WORD wNew,WORD wOld,WORD wParam)
{
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch (dlm) 
	{
		case dlmInit:
			SetTmcVal(tmcVerifyDelete, glob.VerifyDelete);
			SetTmcVal(tmcVerifyOverwrite, glob.VerifyOverwrite);
			SetTmcVal(tmcMouseConfirm, glob.MouseConfirm);

			SetUpDialog(tmcOK,szFileOptionsCaption);

			SetUpButtonForGraphics(tmcOK);
			SetUpButtonForGraphics(tmcCancel);
			SetUpButtonForGraphics(tmcfileoptshelp);
			SetUpCheckBox(tmcVerifyDelete) ;
			SetUpCheckBox(tmcVerifyOverwrite) ;
			SetUpCheckBox(tmcMouseConfirm) ;

			break ;

	case dlmTerm:
		if (tmc == tmcOK)
		{
			glob.VerifyOverwrite = GetTmcVal(tmcVerifyOverwrite);
			glob.VerifyDelete = GetTmcVal(tmcVerifyDelete);
			glob.MouseConfirm = GetTmcVal(tmcMouseConfirm);
		}
		/* else cancel or help which we ignore */
		break ;

	case dlmSetFocus:
		gCurrentTMC = tmc;
		break ;

	case dlmClick:
		 if(tmc == tmcfileoptshelp)
			Help(hemDialog, ((PDLG)&dlgFileOpts)->hid, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;

	} /* switch */

	return TRUE;
} /* proc FDlgFileOpts */

/****   DoFileOptions - run file options dbox
**
**      ENTRY
**              none
**      EXIT
**              none
*/
VOID FAR DoFileOptions(void)
{
	HCABFileOpts hcab;                              // dialogue box storage

	// Init dlg box.
	hcab = HcabAlloc(cabiCABFileOpts);
	if (!hcab)
	{
		OutOfMemory() ;
		return;
	}
	InitCab(hcab, cabiCABFileOpts) ;

	SzToCab(hcab, szEnterButton, Iag(CABFileOpts, pszfileoptsEB));
	SzToCab(hcab, szCancelButton, Iag(CABFileOpts, pszfileoptsCB));
	SzToCab(hcab, szHelpButton, Iag(CABFileOpts, pszfileoptsHB));

	// Run dlg box.
	MyTmcDoDlg(&dlgFileOpts, hcab);

	FreeCab(hcab);
} /* proc DoFileOptions */

/****   DoSelectAll - select all files in the focus tree
**
**      ENTRY
**              none
**      EXIT
**              none
*/
VOID FAR DoSelectAll(void)
{
	PENTRY node;                            // current file node
	PTREE  ftree ;

	ftree = listinfo[glob.FocusBox].tree ;

	/* If tree has not yet been built, don't do anything! */
	if ( (!ftree) || (ftree->ContinueTree) )
		return ;

	if (    (glob.TreeMode == TR_SYSTEM) ||
			((glob.TreeMode == TR_SEARCH) && gfSearchDisk)
		)
	{
#ifndef NOCONSISTENCY
		if (glob.FocusBox != 0)
		{
			printf("*** System Tree mode FocusBox = %d\n", glob.FocusBox) ;
			exit(0) ;
		}
#endif
		node = ftree->FirstFile;
		while (node)
		{
			if (node->MATCHESPATTERN)
				node->SELECTED = TRUE;
			node = node->x.f.snext;
		}
	} else
	{
		node = listinfo[glob.FocusBox].files;
		if (node)
			node = node->x.d.child;
		else
			node = ftree->head;
		while (node)
		{
			if ((node->MATCHESPATTERN) && (!(node->attribs & _A_SUBDIR)) )
				node->SELECTED = TRUE;
			if (node->nosib)
				break;
			else
				node = node->sibling;
		}
	} /* non system tree mode */

	/* The above selections may or may not have have added new selections
	   So re-calculate tree selections!! */
	ftree->NumSel = GetTreeSelectedInfo(ftree, &(ftree->SizeSel)) ;

	/* Now Redraw the file list box */
	InsertListItem(&FileList[glob.FocusBox], 0) ;
} /* proc DoSelectAll */

/* Deselects all file nodes in a tree */
VOID FAR DeselectTree(PTREE tree)
{
	PENTRY node;

	/* If tree has not yet been built, don't do anything! */
	if ( (!tree) || (tree->ContinueTree) )
		return ;

	for (node = tree->FirstFile; node ; node = node->x.f.snext)
		node->SELECTED = FALSE;

	tree->NumSel = 0 ; /* All files in tree have been deselected */
	tree->SizeSel = 0 ;
} /* DeselectTree */

extern BOOL gNeedToUpdateFileList[2];

/****   DoDeselectAll - unselect all files in any displayed trees
**
**      ENTRY
**              none
**      EXIT
**              none
*/
VOID FAR DoDeselectAll()
{
	int i ;
	PTREE tree ;

	tree = listinfo[glob.FocusBox].tree ;

	if (FPerformOpOnDirFilesAlone())
	{
		DeselectDir(listinfo[glob.FocusBox].files, tree) ;
	}
	else
	{
		DeselectTree(tree) ;
	}

	/* fake a space key to re-select the current focus item in focus listbox */
   ListKey(&FileList[glob.FocusBox], ' ', 0);

	for (i = 0 ; i <= glob.MaxTree ; i++)
	{
		InsertListItem(&FileList[i], 0) ;
	}
} /* DoDeselectAll */

void DeselectDir(PENTRY dir, PTREE tree)
{
	PENTRY node ;

	if (tree->NumSel > 0)
	{
		node = (dir) ? dir->x.d.child : tree->head;
	
		while(node)
		{
			if ((node->SELECTED) && !(node->attribs & _A_SUBDIR))
			{
				node->SELECTED = FALSE;
				tree->NumSel-- ;
				tree->SizeSel -= node->x.f.size ;
			}
			node = (node->nosib) ? NULL : node->sibling ;
		} /* while */
	}
} /* DeselectDir */

/* Deselects all file nodes in a tree that are displayed -- 
 * ones matching MatchPat 
 */
VOID FAR DeselectTreeMatches(PTREE tree)
{
	PENTRY node;

	if ( (!tree) || (tree->NumSel == 0) )
		return ;

	for (node = tree->FirstFile; node ; node = node->x.f.snext)
		if ( (node->SELECTED) && (node->MATCHESPATTERN) )
		{
			node->SELECTED = FALSE;
			tree->NumSel-- ;
			tree->SizeSel -= node->x.f.size ;
		}
} /* DeselectTreeMatches */


VOID FAR DoCUA2DeselectAll(TMC tmc)
{
	PTREE tree ;

	tree = listinfo[tmc].tree ;

	if ( (glob.TreeMode == TR_SYSTEM) || (glob.TreeMode == TR_SEARCH) )
	{
		DeselectTreeMatches(tree) ;
	}
	else
	{
		// check to see & redisplay files in other listbox if we are looking to 
		// deselect files in the directory being displayed there.
		if ( (glob.TreeMode == TR_DOUBLE) && 
		     (listinfo[1-tmc].tree == tree) &&
		     (listinfo[1-tmc].files == listinfo[tmc].files) )
				InsertListItem(&FileList[1-tmc], 0) ;

		DeselectDir(listinfo[tmc].files, tree) ;
	}
	InsertListItem(&FileList[tmc], 0) ;
} /* DoCUA2DeselectAll */

/* Global variables thru which info is passed on to FDlgRename */
static int Rcount;
static int Rtotal;
static char *Roldname;

/****   RenameFile - rename a file or directory
**      This fn renames the file specified by 'tree' and 'node'.  If ask = TRUE,
**      the user is prompted for the new file name (only).  Else, the new path
**      is assumed to be in prognew.  Note that the dbox will only allow name
**      changes, but the other way allows full path renaming.
**
**      ENTRY
**              tree  - tree containing file to move
**              node  - node of file to move
**              prognew- destination path if ask == FALSE
**              total - number of selected files
**              count - index in selected files
**              ask   - TRUE = prompt user for new name, FALSE = use prognew.
**      EXIT
**              Action code, as from GetResponse().
*/      
int RenameFile(PTREE tree, PENTRY node, char *prognew, int count,
																		int total, BOOL ask)
{
		int i, j;
		int ret;                                                // return value
		int action;                                             // reaction to critical error
		TMC tmc;                                                // return from dbox
		HCABRename hcab;                                // the dbox
		char usernew[MAX_PATH+1];               // holds new file path
		char curpath[MAX_PATH+1];               // old file path
		char tempname[128] ;
		char statusline[STATUS_LEN];
		char troot[4];          /* To hold a temporary root name like "C:\" etc */
		char *p ;
		BYTE dummy ;
		PTREE temptree ;
		PENTRY tempparent ;
		int dummylen ;
		char *barebonename ;
		BOOL fParentIsRootDir ;
		
		action = ACT_OK ; /* default value */

		Tree2Path(tree, node, curpath, &dummylen);

		/* If total == 0, it is a dir rename operation -- no files selected. */
		p = (total > 0) ? szOpRenameFile : szOpRenameDir ; 
		FormCountStatusLine(statusline, p, curpath,
										count, total, STATUS_COUNT_START) ;

		tmc = tmcOK ; /* Default value */

		i = FindLastComponent(curpath);
		if (curpath[i] == PATHCHAR)
		{
			fParentIsRootDir = FALSE ;
			i++;
		}
		else
			fParentIsRootDir = TRUE ;

		/* ZZZZ In case we are renaming a directory, we need to make sure
		   that the cwd is not in the path of the renamed directory --
		   simple approach is to do a chdir to the root directory -- Note
		   that we could at this point be in any directory as Jeff does
		   chdir's in quite a few places!! */
		if (node->attribs & _A_SUBDIR)
		{
			/* ZZZZZ For efficiency & not screw up cwd, getcwd should
			   be used and if this is same as curpath change to root
			   directory for rename. Check if cwd is COMPSPEC dir too
			   as otherwise his machine will be non-bootable --  give
			   warning in this case. Current DOSSHELL has this bug!! */
			/* Copy from far memory to near memory */
			strfcpy(troot, tree->root) ;

			/* ZZZZZ No error checking done on this call!! */
			if (fParentIsRootDir)
				UnixChdir(troot) ;
			else
			{
				curpath[i-1] = '\0' ;
				UnixChdir(curpath) ;
				curpath[i-1] = PATHCHAR ;
			}
		}

		do
		{
			if (ask)
			{
				// Fill in fields.
				Roldname = curpath+i;
				Rtotal = total;
				Rcount = count;

				// Allocate dbox.
				hcab = HcabAlloc(cabiCABRename);
				if (!hcab)
				{
					OutOfMemory();
					return ACT_CANCEL;
				}
				InitCab(hcab, cabiCABRename) ;
	
				/* Use default of Null name */
				SzToCab(hcab, NullString, Iag(CABRename, NewName));
				SzToCab(hcab, szEnterButton, Iag(CABRename, pszrenameEB));
				SzToCab(hcab, szCancelButton, Iag(CABRename, pszrenameCB));
				SzToCab(hcab, szHelpButton, Iag(CABRename, pszrenameHB));


				// Run dialogue box.
				tmc = MyTmcDoDlg(&dlgRename, hcab);
				if (tmc == tmcOK)
				{
					strncpy(usernew, curpath, i);   // copy all but old filename
					SzFromCab(hcab,tempname,MAX_PATH,Iag(CABRename,NewName));
					ScrunchFileName(usernew+i, tempname, FALSE) ;
					// ZZZ remove all such strupr's later, if dialog box does it
#ifdef DBCS
					DBCSstrupr(usernew+i);
#else
					strupr(usernew+i);
#endif
					prognew = usernew;
				}
				else
				{
#ifndef NOCONSISTENCY
if (tmc != tmcCancel)
{
	printf("*** Not Cancel button in Rename\n") ;
	exit(0) ;
}
#endif
					/* Warning! Assuming tmcCancel and not Help */
					action = ACT_CANCEL ;
					FreeCab(hcab);
					break ; /* leave while loop */
				}
				FreeCab(hcab);

			} /* if (ask) */
			/* At this point 'prognew' has the new path, either given by the
			   user or already passed in to the routine */

			if (node->attribs & _A_SUBDIR)
			{
				if (translate_name(curpath, tempname))
					strcpy(tempname, curpath) ;

				/* Do path length check!! */
				if (path_len_check(tempname, node, 
											strlen(prognew)-strlen(curpath)))
				{
					j = FindLastComponent(prognew) ;
					if (prognew[j] == PATHCHAR)
						j++ ;

					barebonename = prognew+j ;

					ret = rename(curpath, barebonename) ;
				}
				else
				{
					ret = -1 ; // mark as error!
					_doserrno = NESTING_DEEP_ERR ;
				}
			}
			else
				ret = rename(curpath, prognew);

			if (ret)
				action = DOSErrorBox(statusline, _doserrno, HELP_ERRRENAME);
			else
				action = ACT_OK;
		} while (action == ACT_RETRY);
		if (action == ACT_OK || action == ACT_FORCE)
		{
			fileinfo rec;                                   // copied file's info
			treehdr far *ftree;                     // tree holding old file record
			PENTRY parent, file;                    // parent, self of old rcd
			
			if (node->attribs & _A_SUBDIR)
			{
#ifdef RENAME_DIR_IN_PLACE
				FillRecName(prognew, node);     // rename existing record
#else
				parent = FindParent(node) ;

				/* tree->DirectoryCount does not change as we are only renaming
				 * this directory.
				 */
				HandleDeletednext(tree, node) ;
				FillRecName(prognew, node);     // rename existing record

				/* If directory has got sub-directories, marking the LASTDIR
				 * bits is not trivial. So, we just go thru the process of marking
				 * the LASTDIR bits of LASTDIR bits afresh. This is fast and
				 * we don't want to write special code for this.
				 */
				if (node->HASSUBDIRS)
				{
					InsertDir(tree, parent, node) ;
					Marklastdir(tree) ;
				}
				else
				{
					InsertDirAndMarkLastDirBits(tree, parent, node) ;
				}
#endif
			} else
			{
				/* It's a normal file. Build record of copied file.  */
				FillRecName(prognew, (PENTRY) &rec); // put name/ext into record
				rec.dtlx.dt.time = node->dtlx.dt.time;
				rec.dtlx.dt.date = node->dtlx.dt.date;
				rec.attribs = node->attribs;
				rec.nosib = rec.SELECTED = 0;
				rec.x.f.size = node->x.f.size;

				/* Delete old record.
				*/
				ftree = FindTree(curpath, &dummy);
				if (2 == FindNode(ftree, curpath, &parent, &file, FALSE))
					DelFileEntry(ftree, parent, file);

				/* AddLateFile will locate the proper tree and add our record to it.
				*/
				/* we need to pass in non-null values (temptree and tempparent)
				 * because fn AddLateFile uses these storages.
				 */
				if (!AddLateFile(prognew, &rec, temptree, tempparent, 0))
					// action = ACT_NOMEM;
					action = ACT_CANCEL;
			}
		}
		if (tmc == tmcCancel)
		{
			action = ACT_CANCEL ;
		}

		if ( (action == ACT_FORCE) || (action == ACT_SKIP) )
			return ACT_OK;
		else
			return action;
} /* proc RenameFile */

char *GetPrintErrMsg(int print_err_code)
{
	char *msg ;

	switch(print_err_code)
	{
		case 2:
		case 3:
			msg = szPathNotFound ;
			break ;

		case 8:
			msg = szPrintQueueFull ;
			break ;

		case 9:
			msg = szSpoolerBusy ;
			break ;

		case 5:
		default:
			msg = szAccessDenied ;
			break ;

	} /* switch */

	return msg ;

} /*  GetPrintErrMsg */

/* Prints the file specified by 'node' */
int PrintFile(PTREE tree, PENTRY node, char *placeholder, int count,
																	int total, BOOL verify)
{
	int action;
	int ret ;
	char path[MAX_PATH+1];                                  // path of file
	char TrueName[128] ;
	char statusline[STATUS_LEN];
	extern BOOL PDisable ; /* Says if print.com is not resident */
	int dummylen ;

	UnReferenced(placeholder) ;
	UnReferenced(verify) ;

	action = ACT_CANCEL ;

	if (PDisable)
	{
		ShellMessageBox(szPrintFileCaption, szPrintLine1) ;
		return action ;
	}

	Tree2Path(tree, node, path, &dummylen);

	/* print.com's int 2f interface screws up if we passed in a path
	 * with a drive letter for a substituted drive.
	 */
	if (translate_name(path, TrueName))
		strcpy(TrueName, path) ;

	FormCountStatusLine(statusline, szOpPrintFile, path, count, total, 
													STATUS_COUNT_START) ;
	PutUpStatusMessage(statusline, count) ;

	do
	{
		/* File succesfully printed => we get 0 else 1 */
		if (!(ret = a_print_file((char far *)TrueName)))
			action = ACT_OK ;
		else
		{
			action = GetResponse(statusline, GetPrintErrMsg(ret),
											BT_FILERETRYSKIPQUIT, HELP_PRINTERR) ;
		}
	} while (action == ACT_RETRY) ;

	if (action == ACT_SKIP)
	   action = ACT_OK ;

	TakeDownStatusMessage(count, total) ;

	return action ;

} /* proc PrintFile */

/* This is the function that gets control when the user selects the "Cross
 * Directory Selection" menu item in the file manager.
 */
void SelectAcrossDirs(void)
{
	/* Toggle cross dir selection option. */
	glob.CrossDirSel = !glob.CrossDirSel ;

	/* Following call is not needed as we do it before a menu pops down! */
	// easycheck(SelectAcrossDirs, glob.CrossDirSel) ;

} /* SelectAcrossDirs */

/* If Rtotal > 0, this routine writes out the line xx of xx */
/* RTotal = 0 is sent in when renaming directories */
BOOL FAR PASCAL FDlgRename(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	char temp[MAX_PATH+1];                          // file name for verification
	PWND lwind;
	int nWid;
	char *msg ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch (dlm)
	{
		case dlmInit:
			SetUpDialog(tmcOK,gpszFileOpCaption);

			SetUpButtonForGraphics(tmcOK);
			SetUpButtonForGraphics(tmcCancel);
			SetUpButtonForGraphics(tmcrenamehelp);

			SetUpEditBox(tmcNewName, TRUE,NAMELEN+EXTLEN+1, TRUE);
			
			FormCountStatusLine(temp, szCurrName, Roldname, Rcount, Rtotal,
														STATUS_COUNT_START) ;
			Shell_SetTmcText(tmcrenamestatus, temp) ;
			Shell_SetTmcText(tmcstrenamenew, szNewName) ;
			break;

		case dlmTerm:
			if (tmc == tmcOK)
			{
				GetTmcText(tmcNewName, temp, MAX_PATH);

				/* Did the user not type any name? If so don't dismiss dialog */
				if (!(*temp))
				{
					Shell_Beep() ;
					return FALSE ;
				}

				/* check to see if the user is trying to use nested names */
#ifdef DBCS
				if (DBCSstrchr(temp, PATHCHAR))
#else
				if (strchr(temp, PATHCHAR))
#endif
				{
					lwind = PwndOfTmc(tmcrenameerr1) ;
				nWid = lwind->arcWindow.axRight - lwind->arcWindow.axLeft + 1;

					msg = MySetMessageText(tmcrenameerr1, szNoPathCharsInRename,
																							nWid) ;
					/* Warning! Assuming that both these edit items have same width */
					MySetMessageText(tmcrenameerr2, msg, nWid) ;

					return FALSE ; /* Don't dismiss dialog -- invalid name */
				}
			}
			break ;

#if 0
		case dlmChange:
			/* The user has typed in a new name */
			/* ZZZ Now check for lower case, etc!! */
			// GetTmcText(tmcNewName, temp, MAX_PATH);
			return(TRUE) ;
#endif

	case dlmSetFocus:
		gCurrentTMC = tmc;
		break ;

	case dlmClick:
		 if(tmc == tmcrenamehelp)
			Help(hemDialog, ((PDLG)&dlgRename)->hid, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
		 break ;

		case dlmIdle:
		default:
			break ;
	}
	return TRUE;
} /* proc FDlgRename */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\groups.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <tasklist.h>

// Lets you compile in debug mode without running out of near heap
//  #define DEBUG  
#ifndef DEBUG
#include <prot.h>
#else
extern  VOID FARPUBLIC Shell_SetTmcText(TMC tmc, char *text);
extern  void SetUpDialog(unsigned short tmcchild,char *title);
extern  void SetUpButtonForGraphics(unsigned short tmc);
extern void SetUpCheckBox(TMC tmc) ;
extern  void SetUpEditBox(unsigned short tmc, BOOL fRealOrNot, WORD maxcount, BOOL fHasInitialFocus);
extern  void SetUpRadioGroupForGraphics(unsigned short group, TMC prevtmc, TMC nexttmc);
extern  void SetUpRadiobuttonForGraphics(unsigned short tmc,int index);
VOID FAR PASCAL Help(WORD hem, WORD hid,VOID *pv,WORD kk);
extern  void pascal far OutOfMemory(void );
extern TMC      MyTmcDoDlg(VOID *pdlg, HCAB hcab) ;
extern TOKEN Delete_Ith_Element(TOKEN list,int ith);
extern unsigned char far cdecl GET_WAIT_FLAG(void);
extern  void SetTitle(struct ListBoxData *TestList,char *title);
extern  void InitIconCache(void );
extern  void FocusLineChange(struct ListBoxData *TestList,int amt);
extern  void InsertListItem(struct ListBoxData *TestList,unsigned short isz);
extern  void DoRedisplayList(struct ListBoxData *TestList);
extern  int Tree2Path(PTREE tree,PENTRY node,char *str, int *plength);
extern  void strfcpy(char far *dst,char far *src);
extern  unsigned int myfstrlen(unsigned char far *s);
extern  void PlotBmp(struct BITMAP *bmp,unsigned short x,unsigned short y,ISA color);
extern void DrawFocusMarker(PWND pwnd, RX rxText, RY ryText, RX rxGraphics,
				RY ryGraphics, WORD len, BOOL isfocus, BOOL issel, ISA isa) ;
extern  void far StartAProgram(void);
extern VOID ShellMessageBox(char *messagetitle, char *message) ;
extern  void far AddProgram(void);
extern  void far AddGroup(void);
extern  void far ChangeGroup(void);
extern  void far ChangeProgram(void);
extern  void MessageBar(char *message, ISA isa,WORD force);
extern  VOID ListBoxInit(ListBoxData *TestList,WORD (*ListProc)(),
	PWND pwd,WORD top,WORD left,WORD bottom,WORD right,char *title, 
	WORD tmc,WORD startfocusabsolute,WORD startfocusrelative);
extern  void UpdateMainTitleBar(char *szTitle);
extern  void setmenubar(struct _mnu * * *amenu,struct _wnd *towind);
extern  void FrameMenuBar(struct _wnd *pwnd);
extern  void NextGlobalFocus(void );
extern  void GlobalFocusBox(struct ListBoxData *TestList,int yesorno);
extern  int ListBoxIdle(struct ListBoxData *TestList);
extern  void UpdateListBox(struct ListBoxData *TestList);
extern  void ListKey(struct ListBoxData *TestList,unsigned short key, unsigned short state);
extern  int ListMouse(struct ListBoxData *TestList,unsigned short x,unsigned short y,unsigned short message,int state);
extern  void DoSingleTree(void );
extern  void DoDoubleTree(void );
extern  void DoFlatDisplay(void );
extern  void DoShareMode(void );

#endif
#include <groups.h>
#include <icons.h>


#include <addgroup.hs>
#include <addgroup.sdm>
#include <addprog.hs>
#include <addprog.sdm>
#include <adddialo.hs>
#include <adddialo.sdm>
#include <advanced.hs>
#include <advanced.sdm>
#include <password.hs>
#include <password.sdm>
#include <new.hs>
#include <new.sdm>

extern void DrawDialogBorderAndTitle(PWND pwnd) ;
extern BOOL Buffered_Write_Ini_File(BOOL bFreeFM);

extern BOOL gTaskListEnabled;
extern BOOL gSwitchingEnabled;

extern BOOL gfFMVisited ;

extern BOOL fDrawItem;
extern BOOL fRedrawItem;
extern BOOL gfRepaintonidle;
extern char *szCurDialogCaption ;

WORD PASCAL ListProcTaskList(WORD tmm, char *sz, WORD isz, TMC tmc,WORD x, WORD y, WORD bArg);
#ifndef NOSWITCHER
BOOL TaskManKey(WORD wParam,DWORD LParam);
BOOL TaskManIdle(void);
BOOL TaskManMouse(WORD mx,WORD my,WORD message,BYTE state);
VOID InitTaskMan(WORD top,WORD left,WORD bottom,WORD right);
extern void Set_Task_Name(char far *name);
extern VOID Set_Task_Info(TOKEN);
extern TOKEN Get_Identifier_Token(char far *identifier);
extern ListBoxData TaskList;
extern BOOL SetupCommand(char far *commands, char *startdir,BOOL dolaunch,TOKEN info);
#endif

extern WORD GetIthGroupOrProgramIndex(TOKEN group, int isz);
extern TOKEN Duplicate_Token(TOKEN src);
extern void Insert_Symbol(TOKEN, TOKEN, int);

extern char *gpszNonSwap ;

extern char gStartUpDir[] ;
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */
extern char gStartInDir[] ;

extern char far *gIconCache;
#ifndef NODIRECT
VOID Arrow(void);
VOID ProgramCursor(void);
VOID FAR Advanced(void);
#endif
VOID DoUserCommand(char *startdir);
VOID FAR DoCopyProgram(void);
VOID DoReorderGroup(void);

#ifdef USA
   #define MAXUSERTITLE 23
#else
   #define MAXUSERTITLE 27 // IPG- increased prog item lengths 23 to 27 for intl vers.
#endif
#define MAXUSERINSTRUCTIONS 105
#define MAXUSERPROMPT 18
#define MAXUSERDEFAULT 64
#define MAXUSERCOMMAND 256
#define MAXUSERPASSWORD 20
#define MAXUSERHELP 255
extern MENUINFO MainMenuBar;
extern char userTitle[MAXUSERTITLE];
extern char userInstructions[MAXUSERINSTRUCTIONS];
extern char userPrompt[MAXUSERCOMMAND];
extern char userDefault[MAXUSERDEFAULT];
extern char userCommand[MAXUSERCOMMAND];
extern char userPassword[MAXUSERPASSWORD];

BOOL gPauseChecked; /* pause on exit on/off? */
WORD gInitPMFocus = 0;
char currentPassword[MAXUSERPASSWORD];

#define IsGroupOrProgramType(tkTemp) ((tkTemp)==TK_GROUP||(tkTemp)==TK_PROGRAM)

/* Note: PROGLINELEN must be at least 2 more than MAXUSERTITLE */
#ifndef NOSWITCHER
   #ifdef USA
      #define PROGLINELEN 25
   #else
      #define PROGLINELEN 29 //IPG- for international versions
   #endif
#else
#define PROGLINELEN 40
#endif

struct ListBoxData ProgramList;
char ProgramTitle[MAXUSERTITLE+1];
TOKEN gGroupLevel = TK_PROGRAMSTARTER;
BOOL ischangedialog;
BOOL gInCopy = FALSE;
BOOL gInReorder = FALSE;
TOKEN gCopyProgram; /* used for reorder group as well! */
TOKEN gReorderType;
TOKEN gReorderItem;

TOKEN token,commandtoken,filemgrtoken;

int FarToNearsz(char *temp, char far *str, int max)
{
	register int i = 0;

	if(str) {
		for(--max; i<max; ++i) {
			if(str[i])
				temp[i] = str[i];
			else
				break;
		}
	}
	temp[i] = '\0';

	return(i);
}


char RotChar(char c)
{
    int ret;
    ret = c+13;
    ret = 'A' + ret%26;
    return((char)ret);
}

/*
 * warning; tmp and a can be the same location!
 */
VOID MakeEncryptPass(char *tmp,char *a)
{
    int i;
    for(i=0;i<MAXUSERPASSWORD;i++)
    {
	if(a[i] == 0)
	    break;
	else
	   tmp[i] = RotChar(a[i]);
    }
    tmp[i] = 0;
}
/*
 * a is the attempted password string, b is the encrypted on from .ini
 */
BOOL PasswordMatch(char *a,char *b)
{
    int i;
    char tmppass[MAXUSERPASSWORD];

    MakeEncryptPass(tmppass,a);

    for(i=0;i<MAXUSERPASSWORD;i++)
    {
	if ((tmppass[i] ==0) && (b[i] == 0))
	    return(TRUE);
	if (tmppass[i] != b[i])
	    return(FALSE);
    }
    return(TRUE);
}

DWORD FAR PASCAL Pfnpasswordbox(PWND, WORD, WORD, DWORD);

BOOL FAR PASCAL
FDlgpassword(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
    char tstr[MAXUSERPASSWORD];

	UnReferenced(tmc);
	UnReferenced(wNew);
	UnReferenced(wOld);
	UnReferenced(wParam);

	if(dlm == dlmInit)
	{
		 SetUpDialog(tmcOK,szPasswordCaption);
		 SetUpButtonForGraphics(tmcOK);
		 SetUpButtonForGraphics(tmcpasswordHB);
		 SetUpButtonForGraphics(tmcCancel);

		 SetUpEditBox(tmcpassword, TRUE,MAXUSERPASSWORD, TRUE);
		 SetWindowProc(PwndOfListbox(tmcpassword), Pfnpasswordbox);
	} else if(dlm == dlmTerm) {
	    GetTmcText(tmcpassword, tstr, MAXUSERPASSWORD);
	    currentPassword[strlen(tstr)] = '\0';
	} else if(dlm == dlmSetFocus)
	gCurrentTMC = tmc;
	else if(dlm == dlmClick) {
		 if(tmc == tmcpasswordHB)
			Help(hemDialog, hidPASSWORD, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
    }
	return(TRUE);
}

BOOL PasswordBox(void)
{
    BOOL retval;
    HCABpassword        h;

    retval = FALSE;
    h = HcabAlloc(cabiCABpassword);
    if (!h)
    {
       OutOfMemory() ;
       return (FALSE);
    }
    InitCab(h, cabiCABpassword) ;

    SzToCab(h, NullString, Iag(CABpassword, pszpassword));

    SzToCab(h, szEnterButton, Iag(CABpassword, pszpasswordEB));
    SzToCab(h, szCancelButton, Iag(CABpassword, pszpasswordCB));
    SzToCab(h, szHelpButton, Iag(CABpassword, pszpasswordHB));

    if (MyTmcDoDlg(&dlgpassword,        h) == tmcOK)
    {
	if(PasswordMatch(currentPassword,userPassword))
	{
	    retval = TRUE;
	}
	else
	 Shell_Beep();
    }
    else
	 retval = FALSE;
    FreeCab(h);
    return(retval);
}
int Num_Items_In_Group(TOKEN token)
{
    int i;
    int numitems;
    int length;
    TOKEN token2;

    length = Get_List_Length(token);
    numitems = 0;
    for(i=0;i<length;i++)
    {
	 token2 = Get_Ith_Element(token,i+1);
	 token2 = Get_Symbol_Type(Token_To_Symbol(token2));
	 if((token2 == TK_GROUP) || (token2 == TK_PROGRAM))
	 {
	     ++numitems;
	 }
    }
    return(numitems);
}

void PASCAL VariableToString(TOKEN tkList, TOKEN tkItem, char *szItem, int nMax)
{
	if((tkItem=Get_KeyWord_Assignment(tkList, tkItem)) > 0)
		FarToNearsz(szItem, Get_Token_Identifier(tkItem), nMax);
	else
		*szItem = '\0';
}

BOOL PASCAL VariableToCab(TOKEN section, TOKEN variable,
	HCAB h, WORD iag)
{
    char tstr[256];
    BOOL retval;

    retval = TRUE;
    VariableToString(section, variable, tstr, sizeof(tstr));
    if(variable == TK_PASSWORD && *tstr) {
	currentPassword[0] = 0;
	strcpy(userPassword, tstr);
	if(!PasswordBox())
	{
	    retval = FALSE;
	    tstr[0] = 0;
	}
	else
	{
		strcpy(tstr, currentPassword);
	}
    }
    SzToCab(h, tstr, iag);
    return(retval);
}

void PASCAL CabToVariable(HCAB h, WORD iag,
	TOKEN section, TOKEN variable)
{
    TOKEN tkTemp;
    char tstr[256];

    SzFromCab(h, tstr, sizeof(tstr), iag);
    if(*tstr) {
	if(variable == TK_PASSWORD)
	    MakeEncryptPass(tstr, tstr);
	if((tkTemp=Get_Identifier_Token(tstr)) <= 0)
	    return;
    } else
	tkTemp = TK_UNKNOWN;
    Set_KeyWord_Assignment(section, variable, tkTemp);
}


/*
 * Get a token to the group's parent.
 * root is the highest level to look at. This is used so
 * we can be recursive. Regular call should use TK_PROGRAMSTARTER
 * as the root. NOTE: group does not have to be a group, a program
 * will also work!
 */
TOKEN GroupParent(TOKEN root, TOKEN group)
{
    TOKEN tkTemp1, tkTemp2, tkTemp3;
    int i, index = 0;
    TOKEN retval;
    int length;

    if(root<=0 || group<=0)
	return(TK_NOTHING);

    if(root == TK_PROGRAMSTARTER)
	tkTemp3 = Get_KeyWord_Assignment(root, TK_GROUP);
    else
	tkTemp3 = Get_Symbol_Value(Token_To_Symbol(root));

    if(tkTemp3 <= 0)
	return(TK_NOTHING);

    length = Get_List_Length(tkTemp3);
    for(i=0; i<length; ++i) {
	tkTemp1 = Get_Ith_Element(tkTemp3, i+1);
	if(Get_Symbol_Value(Token_To_Symbol(tkTemp1))==group ||
		tkTemp1==group) /* we have found our group! */ {
	    gInitPMFocus = index;
	    return(root);
	}

	tkTemp2 = Get_Symbol_Type(Token_To_Symbol(tkTemp1));
	if(IsGroupOrProgramType(tkTemp2)) {
	    ++index;

	    if(tkTemp2 == TK_GROUP) {
/* recurse into this group */
		if((retval=GroupParent(tkTemp1, group)) > 0)
		    return(retval); /* we found the guy in here */
	    }
	}
    }

/*
 * we never found the guy under this root, so his parent is
 * not under this root
 */
    return(TK_NOTHING);
}

//bug bug this is necessary because the damn thing is recursive
BOOL gLoadEqualsProcessed = FALSE;

void Get_StartupItem(TOKEN tkStartGroup)
{
    TOKEN tkItem, tkType, tkValue;
    TOKEN tkGroup;
    int i, length, index = -1;

    if(tkStartGroup == TK_PROGRAMSTARTER)
	tkGroup = Get_KeyWord_Assignment(tkStartGroup, TK_GROUP);
    else
	tkGroup = tkStartGroup;
    if(tkGroup <= 0)
	return;

    length = Get_List_Length(tkGroup);
    for(i=1; i<=length; ++i) {
	tkItem = Get_Ith_Element(tkGroup, i);
	tkType = Get_Symbol_Type(Token_To_Symbol(tkItem));
	tkValue = Get_Symbol_Value(Token_To_Symbol(tkItem));

	if(IsGroupOrProgramType(tkType))
	    ++index;

	if(tkType == TK_GROUP) {
/* recurse into this group */
	    Get_StartupItem(tkValue);

	    if(gLoadEqualsProcessed && gGroupLevel!=TK_NOTHING)
		return;
	} else if(tkType == TK_SPECIAL) {
	    if(tkValue == TK_DEFAULT) {
		if(gGroupLevel == TK_NOTHING) {
		    gGroupLevel = tkStartGroup;
		    gInitPMFocus = index;
		    if(gLoadEqualsProcessed)
			return;
		} else {
		    Delete_Ith_Element(tkGroup, i);
		    --i;
		    --length;
		}
	    }
	} else if(tkType==TK_PROGRAM &&
		!gLoadEqualsProcessed && !GET_WAIT_FLAG()) {
	    if(Get_KeyWord_Assignment(tkValue, TK_LOAD) == TK_ENABLED) {
		VariableToString(tkValue,TK_COMMAND,userCommand,MAXUSERCOMMAND);
		Set_Task_Info(tkValue);
		SetupCommand(userCommand, NULL, FALSE, tkValue);
	    }
	}
    }

    return;
}

void Set_StartupItem(void)
{
    TOKEN tkSaveGroup, tkItem;

    tkSaveGroup = gGroupLevel;
    gGroupLevel = TK_NOTHING;
    Get_StartupItem(TK_PROGRAMSTARTER);
    if(gGroupLevel != TK_PROGRAMSTARTER)
	++gInitPMFocus;
    if(gGroupLevel==tkSaveGroup && gInitPMFocus==Get_List_Focus(&ProgramList)) {
	return;
    }

/* This will clear the old "special = default" line. */
    if(gGroupLevel == TK_PROGRAMSTARTER)
	gGroupLevel = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
    Set_KeyWord_Assignment(gGroupLevel, TK_SPECIAL, TK_UNKNOWN);

    gInitPMFocus = Get_List_Focus(&ProgramList);
    if((gGroupLevel=tkSaveGroup) == TK_PROGRAMSTARTER)
	tkSaveGroup = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
    else
	--gInitPMFocus;

    if((tkItem=SubClassSymbol(TK_SPECIAL)) > 0) {
	Set_Symbol_Value(Token_To_Symbol(tkItem), TK_DEFAULT);
	Insert_Symbol(tkSaveGroup, tkItem,
		GetIthGroupOrProgramIndex(tkSaveGroup, gInitPMFocus));
    }
}

TOKEN Get_Progman_Item(int i)
{
    int numitems;
    TOKEN token;
    BOOL doorpresent;

    if(gGroupLevel == TK_PROGRAMSTARTER) {
	token = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
	if(token < 0) /* there is no group at all */ {
/* we need to create a group! */
	    if((token=SubClassSymbol(TK_GROUP)) <= 0)
		return(TK_NOTHING);
	    Set_KeyWord_Assignment(gGroupLevel, TK_GROUP, token);
	}
	doorpresent = FALSE;
    } else {
	token = gGroupLevel;
	doorpresent = TRUE;
    }

    if(!(numitems=Num_Items_In_Group(token)+doorpresent) || i>=numitems)
	return(-1);

    i -= doorpresent;
    if(i < 0) /* it's the door */ {
	token = GroupParent(TK_PROGRAMSTARTER, gGroupLevel);
	if(token <= 0)
	    token = TK_PROGRAMSTARTER;
    } else {
	i = GetIthGroupOrProgramIndex(token, i);
	token = Get_Ith_Element(token, i);
    }

    return(token);
}

TOKEN Get_Focus_Item(void)
{
    return(Get_Progman_Item(Get_List_Focus(&ProgramList)));
}


#define MAXGROUPTITLELEN 76
VOID SetGroupTitle(TOKEN token)
{
    char *str;

    if(token == TK_PROGRAMSTARTER) {
	str = szMainGroup;
    } else {
	VariableToString(token, TK_TITLE, ProgramTitle, sizeof(ProgramTitle));
	if(ProgramTitle[0])
	    str = ProgramTitle;
	else
	    str = szNoItemTitle;
    }
    SetTitle(&ProgramList, str);
}

void UpLevel(void)
{
    if(gGroupLevel == TK_PROGRAMSTARTER) {
	Shell_Beep();
	return;
    }

    gInitPMFocus = 0; /* default value */
    if((gGroupLevel=GroupParent(TK_PROGRAMSTARTER, gGroupLevel)) <= 0) {
	Shell_Beep();
	gGroupLevel = TK_PROGRAMSTARTER;
    }

    if(gGroupLevel != TK_PROGRAMSTARTER) {
	++gInitPMFocus;
	gGroupLevel = Get_Symbol_Value(Token_To_Symbol(gGroupLevel));
    }

    SetGroupTitle(gGroupLevel);
    InitIconCache();
    FocusLineChange(&ProgramList, gInitPMFocus - Get_List_Focus(&ProgramList));
    InsertListItem(&ProgramList, 0);
}

#if 0
int RemoveQuotes(char *temp, char far *str)
{
    register int i;

    if(*str == '"')
	*str++;

    for(i=0; i<MAXUSERTITLE && *str && *str!='"'; ++i)
	*temp++ = *str++;
    *temp = '\0';

    return(i);
}
#endif

int BuildOutString(char *temp, char far *str)
{
	register int i, saveI;

	for(i=saveI=str?FarToNearsz(temp, str, MAXUSERTITLE+1):0;
			i<PROGLINELEN+4; ++i)
		temp[i] = ' ';
	return(saveI);
}

WORD PASCAL ListProcProgramList(WORD tmm, char *sz, WORD isz, TMC tmc,
											WORD x, WORD y, WORD bArg)
{
    char far *str;
    char temp[80];
    TOKEN token,token2;
    BITMAP *pbitmap ;
    char icontype;
    int len;
    BOOL isgroup;
    char RunInDir[MAX_PATH+1] ;
    char *pStartDir ;
    int dummylen ;

    UnReferenced(tmc);

    switch(tmm) {
#ifndef NODIRECT
#if 0
//we dont do this . too bad
		case tmmPickUp:
		     ProgramCursor();
		     break;
		case tmmDrop:
		     Arrow();
		     break;
#endif
#endif
    case tmmCount:
	if(gGroupLevel == TK_PROGRAMSTARTER) {
	    if((token=Get_KeyWord_Assignment(gGroupLevel, TK_GROUP)) > 0)
		return(Num_Items_In_Group(token));
	    else
		return(0);
	} else
	    return(Num_Items_In_Group(gGroupLevel) + 1);
	break;

    case tmmSetFocus:
	break;

    case tmmActivate:
	if(gInReorder) {
	    DoReorderGroup();
	    break;
	}

	if(gGroupLevel!=TK_PROGRAMSTARTER && !isz) {
	    UpLevel();
	    break;
	}
	    
	if((token=Get_Progman_Item(isz)) < 0) {
	    Shell_Beep();
	    break;
	}

	if(token==TK_PROGRAMSTARTER)
	    goto DisplayGroup;
	else if(Get_Symbol_Type(Token_To_Symbol(token))==TK_GROUP) {
	    userPassword[0] = userPrompt[0] = 0;
/* get the password into userpassword */
	    if((token2=Get_KeyWord_Assignment(Get_Symbol_Value(
		    Token_To_Symbol(token)), TK_PASSWORD)) > 0) {
		FarToNearsz(userPassword, Get_Token_Identifier(token2),
			MAXUSERPASSWORD);
		if(*userPassword && !PasswordBox())
		    return(TRUE);
	    }

	    token = Get_Symbol_Value(Token_To_Symbol(token));
DisplayGroup:
	    gGroupLevel = token;
	    SetGroupTitle(gGroupLevel);
	    InitIconCache();
	    DoRedisplayList(&ProgramList);
	} else {
/* Run the program */
	    token = Get_Symbol_Value(Token_To_Symbol(token));
	    Set_Task_Info(token);

/* get the command string into usercommand */
	    token2 = Get_KeyWord_Assignment(token,TK_COMMAND);
	    if(token2 > 0)
		FarToNearsz(userCommand, Get_Token_Identifier(token2),
			MAXUSERCOMMAND);
	    else 
		Shell_Beep();

	    token2 = Get_KeyWord_Assignment(token, TK_PAUSE);
/* If token2 is invalid or not disabled, set global save
 * state to enabled. This is looked at when exiting a
 * launched program!
 */
	    if(token2 != TK_DISABLED)
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_PAUSE, TK_ENABLED);
	    else
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_PAUSE, TK_DISABLED);

	    userPassword[0] = 0;
	    userPrompt[0] = 0;
/* get the password into userpassword */
	    token2 = Get_KeyWord_Assignment(token, TK_PASSWORD);
	    if(token2 > 0)
		FarToNearsz(userPassword, Get_Token_Identifier(token2),
			MAXUSERPASSWORD);
	    if(token2>0 && userPassword[0] && !PasswordBox())
		return(TRUE);

/* Change directory to the startup dir specified by user */
	    token2 = Get_KeyWord_Assignment(token, TK_DIRECTORY);
	    if(token2>0) 
	    {
		FarToNearsz(temp, Get_Token_Identifier(token2), 64);
		if(temp[1] != ':') // user did not specify a drive letter
		{
			FarToNearsz(temp+2,Get_Token_Identifier(token2),64);
			if(gfFMVisited) /* if file manager has current drive */
			{
				/* get current selected drive letter */
				Tree2Path(listinfo[glob.FocusBox].tree,
			       listinfo[glob.FocusBox].files, RunInDir, &dummylen) ;
				temp[0] = RunInDir[0];
			}
			else
			{
				/* use startup directory */
				temp[0] = gStartInDir[0]; // copy drive letter
			}
			temp[1] = ':';
		}
		pStartDir = temp;
	    } else 
	    {
		pStartDir = gStartInDir ;
		if(gfFMVisited) 
		{
		    Tree2Path(listinfo[glob.FocusBox].tree,
								listinfo[glob.FocusBox].files, RunInDir, &dummylen) ;
		    pStartDir = RunInDir ;
		}
	    }

	    DoUserCommand(pStartDir);
	}
	break;

    case tmmGetItemString:
    case tmmDrawItem:
	if((token=Get_Progman_Item(isz)) < 0) {
	    BuildOutString(temp, NULL);
	    TextOut(&MainWind, (RX)x, (RY)y, temp, PROGLINELEN+4,isaBackground);
	    break;
	    break;
	}

	if(token == TK_PROGRAMSTARTER) {
	    isgroup = TRUE;
	    str = szMainGroup;
	} else {
	    isgroup = Get_Symbol_Type(Token_To_Symbol(token)) == TK_GROUP;
	    if((token=Get_Symbol_Value(Token_To_Symbol(token)))<=0)
		break;

	    if((token=Get_KeyWord_Assignment(token, TK_TITLE)) <= 0)
		str = szNoItemTitle;
	    else
		str = Get_Token_Identifier(token);
	}

	if(tmm == tmmGetItemString) {
	    FarToNearsz(sz, str, MAXUSERTITLE+1);
	    return(TRUE);
	}

	if(isgroup && !gisgraph) {
	    len = BuildOutString(temp+1, str) + 2;
	    temp[0]   = '[';
	    temp[len-1] = ']';
	} else
	    len = BuildOutString(temp, str);

	if(gisgraph) {
	    if(isgroup) {
		if(bArg & TF_ISFOCUS) {
		    pbitmap = GroupIconInvert;
		    icontype = 2;
		} else {
		    pbitmap = GroupIcon ;
		    icontype = 1;
		}
	    } else {
		if(bArg & TF_ISFOCUS) {
		    pbitmap = ProgManIconInvert ;
		    icontype = 3;
		} else {
		    pbitmap = ProgManIcon;
		    icontype = 4;
		}
	    }

	    if(!(gIconCache && (gIconCache[y*MAXCOLS+x] == icontype))) {
		PlotBmp(pbitmap, x*CWIDTH, y*CHEIGHT, isaBackground);
		if(gIconCache) {
		    gIconCache[y*MAXCOLS+x] = icontype;
		}
	    }
	}

	TextOut(&MainWind, (RX)x+4, (RY)y, temp, len, bArg&TF_ISFOCUS);
	TextOut(&MainWind, (RX)x+4+len, (RY)y, temp+len, PROGLINELEN-len,
		isaBackground);
	DrawFocusMarker(&MainWind, (RX)1+2*gisgraph, (RY)y, (RX)x+4, (RY)y,
		len, bArg&TF_ISFOCUS, FALSE, isaBackground) ;
	break;

    default:
	break;
    }
    return TRUE;
}

extern DWORD (FAR *Pfneditbox_chain)(PWND,WORD,WORD,DWORD);
extern WORD gEditBoxScanCode;
extern WORD gEditBoxKey;
extern WORD gEditBoxLastKey;
extern VOID SetUpSpecialEditBoxForGraphics(TMC tmc);
extern VOID HookISR9(void);
extern VOID UnHookISR9(void);
extern WORD GetLastScanCode(void);

WORD gEditBoxLastMod;
WORD gEditBoxModifier;
WORD gScanInfo=0;
#define ISEXTENDED 0x1000

VOID UpdateShiftKk(WORD kkNew,WORD kkOld)
{
	UnReferenced(kkOld) ;

	gEditBoxLastMod = gEditBoxModifier;
	gEditBoxModifier = kkNew;
}

extern DWORD FAR PASCAL Pfneditbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam);
DWORD FAR PASCAL Pfnspecialeditbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	WORD thekey;
	char Temp_Str[30];
	char charstr[10];
	char *keystring;
	BOOL added;
	int i;
	
	switch(message)
	{
		case WM_CHAR:
		{
			switch(wParam)
			{
				case VK_LEFT:
				case VK_RIGHT:
				case VK_UP:
				case VK_DOWN:
				case VK_TAB:
				case KEY_TAB:
				case VK_ESCAPE:
				case ESCAPE:
				case VK_RETURN:
				case 13: //enter key
					goto passthrough;
				break;
			}
			Temp_Str[0] = 0;
		   added = FALSE;
			thekey = HIWORD(LParam)&KK_VK;
			if((wParam != VK_ALT) && 
				(gEditBoxModifier & (KK_ALT|KK_CONTROL|KK_SHIFT))||
				(wParam == VK_BACK) || (wParam == 8) || (wParam == 127))
			{
					if((wParam == VK_BACK) || (wParam == 8) ||
					   (((wParam == 127))&&(!(gEditBoxModifier&(KK_ALT|KK_CONTROL|KK_SHIFT)))) )
					{
						gScanInfo = 0;
						strcat(Temp_Str,szNone);
					}
					else
					{
						/* scan code used is only the top 3 nibbles */
						/* we use top nibble to determine if it was the extended keyboard */
						gScanInfo = GetLastScanCode() & 0xFFF;
						if(gEditBoxModifier & KK_ALT)
						{
							strcat(Temp_Str,szAlt);                         
							added = TRUE;
	
						}
						if(gEditBoxModifier & KK_CONTROL)
						{
							if(added)
								strcat(Temp_Str,szPlusSign);
							strcat(Temp_Str,szCtrl);                                
							added = TRUE;
						}
						if(gEditBoxModifier & KK_SHIFT)
						{
							if(added)
								strcat(Temp_Str,szPlusSign);
							strcat(Temp_Str,szShift);                               
						}
						switch(wParam)
						{
							case VK_F1:
								keystring = szF1;
								break;
							case VK_F2:
								keystring = szF2;
								break;
							case VK_F3:
								keystring = szF3;
								break;
							case VK_F4:
								keystring = szF4;
								break;
							case VK_F5:
								keystring = szF5;
								break;
							case VK_F6:
								keystring = szF6;
								break;
							case VK_F7:
								keystring = szF7;
								break;
							case VK_F8:
								keystring = szF8;
								break;
							case VK_F9:
								keystring = szF9;
								break;
							case VK_F10:
								keystring = szF10;
								break;
							case VK_F11:
								keystring = szF11;
								break;
							case VK_F12:
								keystring = szF12;
								break;
							case VK_INSERT:
								gScanInfo |= ISEXTENDED;
								keystring = szInsert;
								break;
							case VK_DELETE:
							case 127: //also delete
								gScanInfo |= ISEXTENDED;
								keystring = szDelete;
								break;
						   case VK_HOME:
								gScanInfo |= ISEXTENDED;
								keystring = szHome;
								break;
							case VK_END:
								gScanInfo |= ISEXTENDED;
								keystring = szEnd;
								break;
							case VK_PRIOR:
								gScanInfo |= ISEXTENDED;
								keystring = szPageUp;
								break;
							case VK_NEXT:
								gScanInfo |= ISEXTENDED;
								keystring = szPageDown;
								break;
							case ' ':
								keystring = szSpace;
								break;
							default:
								charstr[0] = (char) thekey&KK_VK;
								if(!((charstr[0] >= 'A') && (charstr[0] <= 'Z')))
									charstr[0] = (char) toupper(wParam);
								charstr[1] = 0;
								keystring = charstr;
						}
						strcat(Temp_Str,szPlusSign);
						strcat(Temp_Str,keystring);
					}
					/* bug bug this is dumb */
					for(i=strlen(Temp_Str);i<24;i++)
					{
					strcat(Temp_Str," ");
					}
					/* WARNING do not use
					 * Shell_SetTmcText here or
					 * the text will not display!
					 */
					SetTmcText(tmcshortcut,Temp_Str);
				}
			}
		   return(TRUE);
		}
passthrough:
	return Pfneditbox(pwnd, message, wParam, LParam) ;
} /* Pfnfakeeditbox */

VOID SetUpSpecialEditBoxForGraphics(TMC tmc)
{
     PWND dwind;

     dwind = PwndOfListbox(tmc);
     Pfneditbox_chain = GetWindowProc(dwind);
	  dwind->id = tmc;

	  SetWindowProc(dwind, Pfnspecialeditbox) ;
}


BOOL FAR PASCAL FDlgaddprogram(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
	char Temp_Str[max(MAXUSERCOMMAND,MAXUSERTITLE)+1] ;

	UnReferenced(tmc);
	UnReferenced(wNew);
	UnReferenced(wOld);
	UnReferenced(wParam);

	switch(dlm)
	{
		case dlmInit:
		{
			SetTmcVal(tmcpaddprompt, gPauseChecked);

			SetUpDialog(tmcOK,ischangedialog?szChangeProgramCaption:szAddProgramCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcpaddHB);
			SetUpButtonForGraphics(tmcadvanced);
			SetUpCheckBox(tmcpaddprompt) ;

			SetUpEditBox(tmcpaddtitle, TRUE,MAXUSERTITLE, TRUE);
			SetUpEditBox(tmcpaddcommand, TRUE, MAXUSERCOMMAND, FALSE);
			SetUpEditBox(tmcaddpassword, TRUE,MAXUSERPASSWORD, FALSE);
			SetUpEditBox(tmcpaddstartupdir, TRUE,ALLOWED_PATH, FALSE);
		SetUpSpecialEditBoxForGraphics(tmcshortcut);
		   //HookISR9();
		}
		break;
		case dlmTerm:
		{
			if (tmc == tmcOK)
			{
				GetTmcText(tmcpaddcommand, Temp_Str, MAXUSERCOMMAND);
				if (Temp_Str[0] == '\0')
				{
					Shell_Beep() ;
					SetFocusTmc(tmcpaddcommand) ;
					return FALSE ;
				}
				GetTmcText(tmcpaddtitle, Temp_Str, MAXUSERTITLE);
				if ((Temp_Str[0] == '\0'))
				{
					Shell_Beep() ;
					SetFocusTmc(tmcpaddtitle) ;
					return FALSE ;
				}

				gPauseChecked = GetTmcVal(tmcpaddprompt);
			}
		}
		break;
		case dlmClick:
		{
			if(tmc == tmcadvanced)
			{
				Advanced();

				/* In case we ran out of memory trying to save graphics behind the
				 * "Advanced Dialog" -- The "add" dialog, repaint it entirely.
				 */
				//if (gisgraph && gfRepaintonidle)
				/* ZZZZZ How do I know if we indeed ran out of memory instead
				 * of just always repainting?
				 */
				if (gisgraph)
				{
				fDrawItem = TRUE;
				fRedrawItem=FALSE;

					/* We need to set dialogcaption again as we changed it just
					 * when we put up the "Advanced" dialog
					 */
					szCurDialogCaption = (ischangedialog) ? szChangeProgramCaption : 
																		 szAddProgramCaption;

					// Make it repaint the whole dialog window with borders, etc.
				// SendMessage(PwndParent(PwndOfListbox(tmcOK)), 
					//                                                                                                                      WM_PAINT, 0, 0L);

					// make it draw only the dialog borders.
					DrawDialogBorderAndTitle(PwndParent(PwndOfListbox(tmcOK)));

					/* ZZZZZZZ */
					/* If one wanted to optimize for code size, one can actually
					 * make use of the fact that the tmc values are actually in
					 * order and one can have a loop here. However, if the dialog
					 * items are reordered or deleted could cause problems.
					 */
					/* repaint all the editboxes, check boxes, etc */
				SendMessage(PwndOfListbox(tmcpaddprogtitle), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddtitle), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddcommands), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddcommand), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddstartdir), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddstartupdir), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddappshortcutkey), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcshortcut), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddprompt), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddpasswd), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcaddpassword), WM_PAINT, 0, 0L);

					/* Repaint all the buttons */
				SendMessage(PwndOfListbox(tmcOK), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcCancel), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcpaddHB), WM_PAINT, 0, 0L);
				SendMessage(PwndOfListbox(tmcadvanced), WM_PAINT, 0, 0L);

					/* Reset this variable so that we don't keep drawing the
					 * buttons, etc.
					 */
					fRedrawItem = TRUE ;
				}
				
				SetFocusTmc(tmcOK);
			} else if(tmc == tmcpaddHB) {
				Help(hemDialog, ((PDLG)&dlgaddprogram)->hid, NULL, 0);
			SetFocusTmc(gCurrentTMC) ;
	    }
		 break ;
		}
		break;
		case dlmSetFocus:
	   gCurrentTMC = tmc;
	   break ;

	  
	}

	return(TRUE);
}

WORD gVideoMode;
BOOL gAltEsc, gAltTab, gCtrlEsc, gPrevent;

BOOL FAR PASCAL FDlgadvanced(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
    UnReferenced(tmc);
    UnReferenced(wNew);
    UnReferenced(wOld);
    UnReferenced(wParam);

    if(dlm == dlmInit) {
	SetTmcVal(tmcvideomode,gVideoMode);
	SetTmcVal(tmcalttab,gAltTab);
	SetTmcVal(tmcaltesc,gAltEsc);
	SetTmcVal(tmcctrlesc,gCtrlEsc);
	SetTmcVal(tmcprevent,gPrevent);

	SetUpDialog(tmcOK,szAdvanced);
	SetUpButtonForGraphics(tmcOK);
	SetUpButtonForGraphics(tmcCancel);
	SetUpButtonForGraphics(tmcadvancedHB);

	SetUpEditBox(tmcaddhelptext, TRUE, MAXUSERHELP, TRUE);

	SetUpEditBox(tmckbrequired, TRUE,5, FALSE); // 5 digits for kb required! big program!
	SetUpEditBox(tmcxmsrequired, TRUE,5, FALSE);
	SetUpEditBox(tmcxmslimit, TRUE, 5, FALSE);
		  SetUpCheckBox(tmcalttab) ;
		  SetUpCheckBox(tmcaltesc) ;
		  SetUpCheckBox(tmcalttab) ;
		  SetUpCheckBox(tmcctrlesc) ;
		  SetUpCheckBox(tmcprevent) ;
	if(gisgraph) {
	    SetUpRadioGroupForGraphics(tmcvideomode, tmcxmslimit, tmcprevent);
	    SetUpRadiobuttonForGraphics(tmctextmode,0);
	    SetUpRadiobuttonForGraphics(tmcgraphicsmode,1);
	}
    } else if(dlm == dlmTerm) {
	if(tmc == tmcOK) {
	    gVideoMode = GetTmcVal(tmcvideomode);
	    gAltEsc = GetTmcVal(tmcaltesc);
	    gAltTab = GetTmcVal(tmcalttab);
	    gCtrlEsc = GetTmcVal(tmcctrlesc);
	    gPrevent = GetTmcVal(tmcprevent);
	}
    } else if(dlm == dlmSetFocus)
	gCurrentTMC = tmc;
	else if(dlm ==  dlmClick) {
		 if(tmc == tmcadvancedHB)
			Help(hemDialog, hidADVANCED, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
    }

    return(TRUE);
}

BOOL FAR PASCAL
FDlgadddialog(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
	UnReferenced(tmc);
	UnReferenced(wNew);
	UnReferenced(wOld);
	UnReferenced(wParam);
	if(dlm == dlmInit)
	{
		SetUpDialog(tmcOK,ischangedialog?szChangeProgramCaption:szAddProgramCaption);
	   SetUpButtonForGraphics(tmcOK);
	   SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcdialHB);
		SetUpEditBox(tmcdialtitle, TRUE,MAXUSERTITLE, TRUE);
		SetUpEditBox(tmcdialinformation, TRUE,MAXUSERINSTRUCTIONS, FALSE);
		SetUpEditBox(tmcdialprompt, TRUE,MAXUSERPROMPT, FALSE);
		SetUpEditBox(tmcdialdefault, TRUE,MAXUSERDEFAULT, FALSE);

	} else if(dlm == dlmSetFocus)
	gCurrentTMC = tmc;
	else if(dlm == dlmClick) {
		 if(tmc == tmcdialHB)
			Help(hemDialog, hidADDDIALO, NULL, 0);

		 SetFocusTmc(gCurrentTMC) ;
    }
	return(TRUE);
}

BOOL FAR PASCAL
FDlgaddgroup(dlm, tmc, wNew, wOld, wParam)
WORD    dlm;
TMC     tmc;
WORD    wNew, wOld, wParam;
{
    char Temp_Str[MAXUSERTITLE+1];

	UnReferenced(tmc);
	UnReferenced(wNew);
	UnReferenced(wOld);
	UnReferenced(wParam);

    switch(dlm) {
	case dlmInit:
		SetUpDialog(tmcOK,ischangedialog?szChangeGroupCaption:szAddGroupCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcgrouphelp);
		SetUpButtonForGraphics(tmcCancel);

		SetUpEditBox(tmcgrouptitle, TRUE,MAXUSERTITLE, TRUE);
		SetUpEditBox(tmcgrouphelptext, TRUE,MAXUSERHELP, FALSE);
		SetUpEditBox(tmcgrouppassword, TRUE,MAXUSERPASSWORD, FALSE);
	break;

	case dlmSetFocus:
	gCurrentTMC = tmc;
	break;

	case dlmClick:
		if(tmc == tmcgrouphelp)
	    Help(hemDialog, ((PDLG)&dlgaddgroup)->hid, NULL, 0);

		SetFocusTmc(gCurrentTMC) ;
	break;

    case dlmTerm:
	if(tmc == tmcOK) {
	    GetTmcText(tmcgrouptitle, Temp_Str, MAXUSERTITLE);
	    if(Temp_Str[0] == '\0') {
		Shell_Beep() ;
		SetFocusTmc(tmcgrouptitle) ;
		return FALSE ;
	    }
	}
    }

	return(TRUE);
}

VOID StartAProgram()
{
		if(gTaskListEnabled && TaskList.hasglobalfocus) 
		{
			ListProcTaskList(tmmActivate, NULL, TaskList.focusitem, 0, 0, 0, 0);
		}
		else
		{
		ListProcProgramList(tmmActivate, NULL, ProgramList.focusitem, 0, 0, 0, 0);
		}
}

#define CHARPROMPT '%'

TOKEN GetParamDialog(TOKEN list, int param)
{
    TOKEN token, token2;
    char tstr[10];
    int i, length;

    length = Get_List_Length(list);

    for(i=0; i<length; ++i) {
	token = Get_Ith_Element(list, i+1);
	if(Get_Symbol_Type(Token_To_Symbol(token)) != TK_DIALOG)
	    continue;

	token = Get_Symbol_Value(Token_To_Symbol(token));
	if((token2=Get_KeyWord_Assignment(token, TK_PARAMETER)) > 0) {
	    FarToNearsz(tstr, Get_Token_Identifier(token2), sizeof(tstr));
	    if(tstr[0]==CHARPROMPT && (int)tstr[1]-'0'==param)
		return(token);
	}
    }

    return(-1);
}

TOKEN gPropertyItem;
BOOL FAR AddDialog(TOKEN list, int param)
{
    TOKEN token, token2;
    char tstr[256];
    BOOL retval = FALSE;        
    HCABadddialog h;

    if(!(h=HcabAlloc(cabiCABadddialog))) {
	OutOfMemory() ;
	return(FALSE) ;
    }
    InitCab(h, cabiCABadddialog) ;

    if((token=GetParamDialog(list, param)) <= 0) {
		if((token2=SubClassSymbol(TK_DIALOG))<=0 ||
			(token=SubClassSymbol(TK_DIALOG))<=0)
	    goto Error1;
		Append_Symbol(list, token2);
		Set_Symbol_Value(Token_To_Symbol(token2), token);
    }

    VariableToCab(token, TK_TITLE, h, Iag(CABadddialog, pszdialtitle));
    VariableToCab(token, TK_INFO, h, Iag(CABadddialog, pszdialinformation));
    VariableToCab(token, TK_PROMPT, h, Iag(CABadddialog, pszdialprompt));
    VariableToCab(token, TK_DEFAULT, h, Iag(CABadddialog, pszdialdefault));

    tstr[0] = (char) param+'0'; /*WARNING param must be between 0 and 9! */
    tstr[1] = 0;
    SzToCab(h, tstr, Iag(CABadddialog, pszdialparamnum));
    SzToCab(h, szEnterButton, Iag(CABadddialog, pszdialEB));
    SzToCab(h, szCancelButton, Iag(CABadddialog, pszdialCB));
    SzToCab(h, szHelpButton, Iag(CABadddialog, pszdialHB));

    if(MyTmcDoDlg(&dlgadddialog,  h) == tmcOK) {
	CabToVariable(h, Iag(CABadddialog, pszdialtitle), token, TK_TITLE);
	CabToVariable(h, Iag(CABadddialog, pszdialinformation), token, TK_INFO);
	CabToVariable(h, Iag(CABadddialog, pszdialprompt), token, TK_PROMPT);
	CabToVariable(h, Iag(CABadddialog, pszdialdefault), token, TK_DEFAULT);

	tstr[0] = CHARPROMPT;
/* BUG BUG param *must* be between 1 and 9 */
	tstr[1] = (char) param + (char)'0';
	tstr[2] = (char) 0;
	Set_KeyWord_Assignment(token, TK_PARAMETER, Get_Identifier_Token(tstr));
	retval = TRUE;
    }

    FreeCab(h);
    InitIconCache();
Error1:
    return(retval);
}

/*
 * after each % is a number pertaining to a parameter
 */
BOOL FindParameters(TOKEN list,char *commandstring)
{
#define NUMPARAMS 10
   int i;
   int len;
   int param;
   BOOL parametersdone [NUMPARAMS];

   /*
    * We haven't done dialogs for any parameter
    * yet
    */
	for(i=0;i<NUMPARAMS;i++)
		parametersdone[i] = FALSE;
   len = strlen(commandstring);
   for(i=0;i<len;i++)
   {
		if(commandstring[i] == '%')
		{
			param = commandstring[i+1] - '0';
		//param = atoi(&commandstring[i+1]); THIS WONT WORK FOR %S
		if((param > 0) && (param < 10))
		{
				++i;
				/*
				* We need to find information about the
				* dialog for this parameter.
				* We should not ask twice for the same parameter!
				*/
				if(!parametersdone[param])
				{
				parametersdone[param] = TRUE;
				if(!AddDialog(list,param)) //user canceled
					{
						return(FALSE);
					}
				}
		}
		}
	}
	return(TRUE);
}

VOID FAR DoGroup(void)
{
    TOKEN tkGroup, list;
    HCABaddgroup h;

    if(!(h = HcabAlloc(cabiCABaddgroup))) {
	OutOfMemory();
	return;
    }
    InitCab(h, cabiCABaddgroup);

    if(ischangedialog) {
	((PDLG)&dlgaddgroup)->hid = hidCHANGEGROUP;
	if((tkGroup=Get_Focus_Item())<=0 || tkGroup==TK_PROGRAMSTARTER ||
		(tkGroup=Get_Symbol_Value(Token_To_Symbol(tkGroup)))<=0)
	    goto Error1;

	VariableToCab(tkGroup, TK_TITLE, h, Iag(CABaddgroup, pszgrouptitle));
	VariableToCab(tkGroup, TK_HELP, h, Iag(CABaddgroup, pszgrouphelp));
	if(!VariableToCab(tkGroup, TK_PASSWORD,
		h, Iag(CABaddgroup, pszgrouppassword)))
	    goto Error1;
    } else {
	((PDLG)&dlgaddgroup)->hid = hidADDGROUP;
	SzToCab(h, NullString, Iag(CABaddgroup, pszgrouptitle));
	SzToCab(h, NullString, Iag(CABaddgroup, pszgrouphelp));
	SzToCab(h, NullString, Iag(CABaddgroup, pszgrouppassword));
    }

    SzToCab(h, szCancelButton, Iag(CABaddgroup, pszaddgCB));
    SzToCab(h, szEnterButton, Iag(CABaddgroup, pszaddgSB));
    SzToCab(h, szHelpButton, Iag(CABaddgroup, pszaddgHB));

    if(MyTmcDoDlg(&dlgaddgroup, h) == tmcOK) {
	if(!ischangedialog) {
	    if((list=SubClassSymbol(TK_GROUP))<=0 ||
		    (tkGroup=SubClassSymbol(list))<=0)
		goto Error1;
	    Set_Symbol_Value(Token_To_Symbol(list), tkGroup);
	    Append_Symbol(gGroupLevel!=TK_PROGRAMSTARTER ? gGroupLevel :
		    Get_KeyWord_Assignment(gGroupLevel, TK_GROUP), list);
	}

	CabToVariable(h, Iag(CABaddgroup, pszgrouptitle), tkGroup, TK_TITLE);
	CabToVariable(h, Iag(CABaddgroup, pszgrouphelp), tkGroup, TK_HELP);
	CabToVariable(h, Iag(CABaddgroup, pszgrouppassword),
		tkGroup, TK_PASSWORD);

	if(!Buffered_Write_Ini_File(FALSE))
	    ShellMessageBox(szNoIniTitle, szNoIniMsg1);
    }

Error1:
    FreeCab(h);
    InsertListItem(&ProgramList, 0);
    InitIconCache();
}

VOID FAR DoProgram(void)
{
    TOKEN text, program, grouplevel, token;
    char tstr[256];
    int i;
    BOOL bFirstTime = TRUE;
    HCABaddprogram h;

    if(!(h = HcabAlloc(cabiCABaddprogram))) {
	OutOfMemory();
	return ;
    }

/* Get all the correct stuff from the .ini file */
/* Get_Focus_Item must be called before determining the grouplevel to make sure
 * there is a grouplevel
 */
    token = Get_Focus_Item();

    if(!(program=SubClassSymbol(TK_PROGRAM)))
	goto Error1;

    if(ischangedialog) {
	if(token<=0 || Get_Symbol_Type(Token_To_Symbol(token))!=TK_PROGRAM) {
	    Shell_Beep();
	    goto Error1;
	}

	((PDLG)&dlgaddprogram)->hid = hidCHANGEPROG;
	token = Duplicate_Token(Get_Symbol_Value(Token_To_Symbol(token)));
    } else {
	((PDLG)&dlgaddprogram)->hid = hidADDPROG;
	token = SubClassSymbol(program);
    }
    if(token <= 0) {
	Shell_Beep();
	goto Error1;
    }

    Set_Symbol_Value(Token_To_Symbol(program), token);
    gPropertyItem = token; /* save for AddDialog!,and Advanced too! */

    if(gGroupLevel == TK_PROGRAMSTARTER)
	grouplevel = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
    else
	grouplevel = gGroupLevel;

redoprogram:
    InitCab(h, cabiCABaddprogram);

    VariableToCab(token, TK_TITLE, h, Iag(CABaddprogram, pszpaddtitle));
    VariableToCab(token, TK_COMMAND, h, Iag(CABaddprogram, pszpaddcommand));
    VariableToCab(token, TK_DIRECTORY, h,Iag(CABaddprogram, pszpaddstartupdir));
    gPauseChecked = Get_KeyWord_Assignment(token, TK_PAUSE) != TK_DISABLED;
    if(bFirstTime) {
	if(!VariableToCab(token, TK_PASSWORD,
		h, Iag(CABaddprogram, pszaddpassword)))
	    goto Error1;
    } else
	SzToCab(h, userPassword, Iag(CABaddprogram, pszaddpassword));
    VariableToCab(token, TK_SHORTCUT, h, Iag(CABaddprogram, pszshortcut));

    gScanInfo = 0;
    SzToCab(h, szEnterButton, Iag(CABaddprogram, pszpaddEB));
    SzToCab(h, szCancelButton, Iag(CABaddprogram, pszpaddCB));
    SzToCab(h, szHelpButton, Iag(CABaddprogram, pszpaddHB));

    if(MyTmcDoDlg(&dlgaddprogram, h) != tmcOK)
	goto Error1;

    SzFromCab(h, tstr, sizeof(tstr), Iag(CABaddprogram, pszshortcut));
    if(*tstr) {
/*strip off trailing spaces*/
	for(i=strlen(tstr)-1; i>0 && tstr[i]==' '; --i) /* empty loop */ ;
	tstr[i+1] = 0;
	text = Get_Identifier_Token(tstr);
    } else
	text = TK_UNKNOWN;
    Set_KeyWord_Assignment(token, TK_SHORTCUT, text);

    if(!strcmp(tstr, szNone))
	Set_KeyWord_Assignment(token, TK_SHORTCUTCODE, TK_UNKNOWN);
    else if(text!=TK_UNKNOWN && gScanInfo) {
/* if there was a hotkey string, there must be a scancode */
	itoa(gScanInfo, tstr, 10);
	text = Get_Identifier_Token(tstr);
	Set_KeyWord_Assignment(token, TK_SHORTCUTCODE, text);
    }

    CabToVariable(h, Iag(CABaddprogram, pszpaddcommand), token, TK_COMMAND);
    CabToVariable(h, Iag(CABaddprogram, pszpaddtitle), token, TK_TITLE);
    CabToVariable(h, Iag(CABaddprogram, pszaddpassword), token, TK_PASSWORD);
    SzFromCab(h, userPassword, sizeof(userPassword),
	    Iag(CABaddprogram, pszaddpassword));
    bFirstTime = FALSE;
    CabToVariable(h,Iag(CABaddprogram, pszpaddstartupdir), token, TK_DIRECTORY);
    Set_KeyWord_Assignment(token, TK_PAUSE,
	    gPauseChecked ? TK_ENABLED : TK_DISABLED);

    SzFromCab(h, tstr, sizeof(tstr), Iag(CABaddprogram, pszpaddcommand));
    if(!FindParameters(token, tstr))
	goto redoprogram;

    if(ischangedialog) {
	i = Get_List_Focus(&ProgramList) -
		(gGroupLevel==TK_PROGRAMSTARTER ? 0 : 1);
	Delete_Ith_Element(grouplevel, GetIthGroupOrProgramIndex(grouplevel,i));

	if(--i < 0)
	    i = 0;
	else
	    i = GetIthGroupOrProgramIndex(grouplevel, i);
	Insert_Symbol(grouplevel, program, i);
    } else
	Append_Symbol(grouplevel, program);

    InsertListItem(&ProgramList, 0);

    if(!Buffered_Write_Ini_File(FALSE))
	ShellMessageBox(szNoIniTitle, szNoIniMsg1);

Error1:
    FreeCab(h);
    InitIconCache();
}

VOID FAR Advanced(void)
{
    TOKEN token;
    HCABadvanced h;

    if(!(h = HcabAlloc(cabiCABadvanced))) {
	OutOfMemory();
	return;
    }
    InitCab(h, cabiCABadvanced);

    if((token=gPropertyItem) <= 0)
	goto Error1;

    VariableToCab(token, TK_HELP, h, Iag(CABadvanced, pszaddhelptext));
    VariableToCab(token, TK_KBREQUIRED, h, Iag(CABadvanced, pszkbrequired));
    VariableToCab(token, TK_XMSREQUIRED, h, Iag(CABadvanced, pszxmsrequired));
    VariableToCab(token, TK_XMSLIMIT, h, Iag(CABadvanced, pszxmslimit));

    gVideoMode = Get_KeyWord_Assignment(token, TK_SCREENMODE)
	    == TK_GRAPHICS ? 1 : 0;
    gAltEsc = Get_KeyWord_Assignment(token, TK_ALTESC) == TK_DISABLED;
    gAltTab = Get_KeyWord_Assignment(token, TK_ALTTAB) == TK_DISABLED;
    gCtrlEsc = Get_KeyWord_Assignment(token, TK_CTRLESC) == TK_DISABLED;
    gPrevent = (Get_KeyWord_Assignment(token, TK_PREVENT) == TK_ENABLED);

    SzToCab(h, szEnterButton, Iag(CABadvanced, pszadvancedEB));
    SzToCab(h, szCancelButton, Iag(CABadvanced, pszadvancedCB));
    SzToCab(h, szHelpButton, Iag(CABadvanced, pszadvancedHB));

    if(MyTmcDoDlg(&dlgadvanced, h) == tmcOK) {
	CabToVariable(h, Iag(CABadvanced, pszaddhelptext), token, TK_HELP);
	CabToVariable(h, Iag(CABadvanced, pszkbrequired), token, TK_KBREQUIRED);
	CabToVariable(h, Iag(CABadvanced, pszxmsrequired),token,TK_XMSREQUIRED);
	CabToVariable(h, Iag(CABadvanced, pszxmslimit), token, TK_XMSLIMIT);

	Set_KeyWord_Assignment(token, TK_SCREENMODE,
		gVideoMode == 0 ? TK_TEXT : TK_GRAPHICS);
	Set_KeyWord_Assignment(token, TK_ALTTAB,
		gAltTab == 0 ? TK_ENABLED : TK_DISABLED);
	Set_KeyWord_Assignment(token, TK_ALTESC,
		gAltEsc == 0 ? TK_ENABLED : TK_DISABLED);
	Set_KeyWord_Assignment(token, TK_CTRLESC,
		gCtrlEsc == 0 ? TK_ENABLED : TK_DISABLED);
	Set_KeyWord_Assignment(token, TK_PREVENT,
		gPrevent != 0 ? TK_ENABLED : TK_DISABLED);
    }
Error1:
    FreeCab(h);
    InitIconCache();
}

VOID FAR ChangeProgram()
{
    TOKEN token;

    if((token=Get_Focus_Item())<=0 || token==TK_PROGRAMSTARTER)
	return;

    ischangedialog = TRUE;
    if(Get_Symbol_Type(Token_To_Symbol(token)) == TK_PROGRAM)
	DoProgram();
    else
	DoGroup();
}

int GroupOrProgram;
BOOL FAR PASCAL FDlgnew(WORD dlm, TMC tmc, WORD wNew,WORD wOld, WORD wParam)
{

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;
	switch (dlm) {
	case dlmInit:
	{

		SetUpDialog(tmcOK, szNewProgObjCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		if (gisgraph)
		{
		   SetUpRadioGroupForGraphics(tmcnewgroup, tmcCancel, tmcOK);
		   SetUpRadiobuttonForGraphics(tmcnewgroupitem,0);
		   SetUpRadiobuttonForGraphics(tmcnewprogramitem,1);
		}
		SetTmcVal(tmcnewgroup,1);
	}
	case dlmTerm:
	    GroupOrProgram = GetTmcVal(tmcnewgroup);
	    break;
	case tmcCancel:
	    break;
	case dlmSetFocus:
	    gCurrentTMC = tmc;
	    break ;
	}
	return(TRUE);
}


VOID FAR AddProgram()
{
     HCABnew        h;
     TMC tmc;
     h = HcabAlloc(cabiCABnew);
     if (!h)
     {
		OutOfMemory() ;
		return ;
     }
     InitCab(h, cabiCABnew) ;

     SzToCab(h, szEnterButton, Iag(CABnew, psznewEB));
     SzToCab(h, szCancelButton, Iag(CABnew, psznewCB));

     tmc = MyTmcDoDlg(&dlgnew, h);
     FreeCab(h);
     if(tmc == tmcOK)
     {
		 if(GroupOrProgram) /* Program */
		 {
			ischangedialog = FALSE;
			DoProgram();
		 }
		 else
		 {
			AddGroup();
		 }
     }
}


VOID FAR AddGroup()
{
    ischangedialog = FALSE;
    DoGroup();
}

VOID FAR ChangeGroup()
{
    ischangedialog = TRUE;
    DoGroup();
}

WORD GetIthGroupOrProgramIndex(TOKEN group,int isz)
{

	int length;
	int i;
	int numitems;
	TOKEN token2,token4,tokentemp;

 if (group>0)
	{

		length = Get_List_Length(group);
		numitems =0;
		for(i=1;i<=length;i++)
		{
		       token4 = Get_Ith_Element(group,i);
		       tokentemp = Get_Symbol_Type(Token_To_Symbol(token4));

		       if(IsGroupOrProgramType(tokentemp))
		       {
			     token2 = token4;
			     ++numitems;
		       }
		       if(numitems-1 == isz)
		       {
			     return(i);
		       }
		}
	}
	else
	{
		return(-1);
	}
}



VOID CopyProgram(void)
{
    gInReorder = FALSE;
    if((gCopyProgram=Get_Focus_Item())>0 &&
	    Get_Symbol_Type(Token_To_Symbol(gCopyProgram))==TK_PROGRAM &&
	    (gCopyProgram=Get_Symbol_Value(Token_To_Symbol(gCopyProgram)))>0) {
	gInCopy = TRUE;
	MessageBar(szCopyProgram, isaMenu,TRUE);
    } else {
	gInCopy = FALSE;
	gCopyProgram = TK_NOTHING;
    }
    InitIconCache();
}

VOID FAR DoCopyProgram()
{
    TOKEN groups, token, dup;

    if(gGroupLevel == TK_PROGRAMSTARTER)
	groups = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
    else
	groups = gGroupLevel;

    if(groups>0 && (dup=Duplicate_Token(gCopyProgram))>0 &&
	    (token=SubClassSymbol(TK_PROGRAM))>0) {
	Set_Symbol_Value(Token_To_Symbol(token), dup);
	Append_Symbol(groups, token);
    } else
	Shell_Beep();

    MessageBar(szFileMessage, isaMenu,TRUE);
    InsertListItem(&ProgramList,0);
    SetGroupTitle(gGroupLevel);
    gInCopy = FALSE;
    InitIconCache();
}

extern char *bigProgramIconData;

VOID ReorderGroup(void)
{
    TOKEN tkGroup;
    WORD element;

    gInReorder = TRUE;
    gInCopy = FALSE;

    element = Get_List_Focus(&ProgramList);
    if(gGroupLevel == TK_PROGRAMSTARTER) {
	tkGroup = Get_KeyWord_Assignment(gGroupLevel, TK_GROUP);
    } else {
	tkGroup = gGroupLevel;
	--element;
    }

    if(tkGroup > 0) {
	gReorderItem = GetIthGroupOrProgramIndex(tkGroup, element);
	MessageBar(szReorderGroup, isaMenu, TRUE);
	InitIconCache();
    } else {
	gInReorder = FALSE;
	Shell_Beep();
    }
}

VOID FAR DoReorderGroup(void)
{
    TOKEN tkGroup, tkItem;
    int element;

    gInReorder = FALSE;

    element = Get_List_Focus(&ProgramList) - 1;
    if(gGroupLevel == TK_PROGRAMSTARTER) {
	tkGroup = Get_KeyWord_Assignment(gGroupLevel,TK_GROUP); 
    } else {
	tkGroup = gGroupLevel;
	--element;
    }

    if(tkGroup > 0) {
	tkItem = Get_Ith_Element(tkGroup, gReorderItem);
	Delete_Ith_Element(tkGroup, gReorderItem);

	if(element < 0)
	    element = 0;
	else
	    element = GetIthGroupOrProgramIndex(tkGroup, element);

	Insert_Symbol(tkGroup, tkItem, element);
	InsertListItem(&ProgramList, 0);
	InitIconCache();
    } else
	Shell_Beep();

    MessageBar(szFileMessage, isaMenu, TRUE);
}

void AddProgManAccelerators(void);

VOID InitStartProgramList(WORD top,WORD left,WORD bottom,WORD right)
{
    if(!gLoadEqualsProcessed) {
	gInitPMFocus = -1; /* default value */
	gGroupLevel = TK_NOTHING;
	Get_StartupItem(TK_PROGRAMSTARTER);
	Set_Task_Info(TK_NOTHING);
	gLoadEqualsProcessed=TRUE; //see get_startupgroup bug bug
	if(gGroupLevel <= 0)
	    gGroupLevel = TK_PROGRAMSTARTER;
	if(gGroupLevel != TK_PROGRAMSTARTER)
	    ++gInitPMFocus;
    } else
	gInitPMFocus = Get_List_Focus(&ProgramList);

    ListBoxInit(&ProgramList,ListProcProgramList,&MainWind,
	    top,left,bottom,right,szMainGroup,999,0,0);
/* gInitPMFocus is set in Get_StartupItem */
    FocusLineChange(&ProgramList, gInitPMFocus - Get_List_Focus(&ProgramList));
    SetGroupTitle(gGroupLevel);
}
VOID InitializeStartPrograms(VOID)
{
      RRC rrcClient;


      UpdateMainTitleBar(szDOSShellTitle);
      setmenubar(&MainMenuBar,&MainWind);
      AddProgManAccelerators();
      GetClientRrc(&MainWind,&rrcClient);
      rrcClient.ryTop +=2; /* exclude title and menu */
      rrcClient.ryBottom -=1; /*exclude status bar */
      FillRrc(&MainWind,&rrcClient,' ',isaBackground);
      gInCopy = FALSE;
      gInReorder = FALSE;
#if 0
      /*
       * If there is no setting for command or filemanager,
       * then we don't have an ini file or it is messed up.
       * so we add them here so when we save the ini they will
       * be present
       */
       token = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_GROUP);
       if(token < 0)  /* there is no group listing */
       {
	    commandtoken = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_COMMAND);
	    filemgrtoken = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_FILEMGR);

	    if(commandtoken ) && (filemgrtoken != TK_DISABLED)
	    {
	       /*
		* looks like the ini file either doesn't exist, or
		* is messed up, so we be sure to use command and
		* filemgr!
		*/
	       commandtoken = TK_ENABLED;
	       filemgrtoken = TK_ENABLED;
	    }
       }
       else
       {

       }

	    return(Get_List_Length(token));
#endif
      FrameMenuBar(&MainWind);
      MessageBar(szProgMessage, isaMenu,TRUE);
#ifndef NOSWITCHER
		if(gTaskListEnabled)
	   {
#define TASKADJ  1
	InitStartProgramList(3,0,ayMac-1,axMac/2-TASKADJ);
	InitTaskMan(3,axMac/2-TASKADJ,ayMac-1,axMac);
	GlobalFocusBox(&TaskList,FALSE);
	GlobalFocusBox(&ProgramList,TRUE);
	   }
		else
#endif
		{
	InitStartProgramList(3,0,ayMac-1,axMac);
		}
      InitIconCache();
}

extern WORD gCnx;
BOOL DoStartProgramsIdle(VOID)
{
#ifndef NOSWITCHER
		if(gTaskListEnabled)
	   return(ListBoxIdle(&ProgramList)|TaskManIdle());
	   else
#endif
	   return(ListBoxIdle(&ProgramList));

}
VOID RefreshTaskMan(VOID);
VOID RefreshStartPrograms(VOID)
{
      //DoRedisplayList(&ProgramList);
		InsertListItem(&ProgramList,0);
      UpdateListBox(&ProgramList);
		RefreshTaskMan();
}


BOOL StartProgramsIdle(VOID)
{
    if (!(glob.InFileMgr || m_fPerformingViewFile()))
    {
	if(gCnx != cnxDialog)

	   return(DoStartProgramsIdle());
    }
    else
	return(TRUE);
}

VOID GroupManagerKey(WORD ,DWORD );
VOID GroupManagerKey(WORD wParam,DWORD LParam)
{
#ifndef NOSWITCHER
	 if(gTaskListEnabled)
	 {
	if(wParam == '\t')
      {
			if(!glob.InFileMgr)
			{
			GlobalFocusBox(&TaskList,!TaskList.hasglobalfocus);
			GlobalFocusBox(&ProgramList,!ProgramList.hasglobalfocus);
			}
			else
			{
				NextGlobalFocus();
			}
			return;
      }
	 }
#endif
#ifndef NOSWITCHER
      if((!gTaskListEnabled) || (!TaskManKey(wParam,LParam)))
	
#endif
      {
      if((gInCopy) || (gInReorder))
      {
	 /* escape for F3 will exit from copy mode */
	 if ((LOBYTE(wParam) == 0x1b) || (wParam == VK_F3))
	 {
	   gInCopy = FALSE;
	   gInReorder = FALSE;
		MessageBar(szFileMessage, isaMenu,TRUE);
	   // Shell_Beep();
	 }
	 else
	 if(wParam == VK_F2)
	 {
	    if(gInCopy)
	      DoCopyProgram();
#if 0
	    else
	      DoReorderGroup();
#endif
	 }
	 else
		ListKey(&ProgramList,wParam,HIWORD(LParam));
	 return;
      }
      else
      {
			if (LOBYTE(wParam) == 0x1b)
			{
				UpLevel();
			}
			else
			ListKey(&ProgramList,wParam,HIWORD(LParam));
      }
    }
}

VOID GroupManagerMouse(WORD mx,WORD my,WORD message,BYTE state)
{
       if ((message == WM_LBUTTONDOWN)&&
	   (my == Get_List_Rect(&ProgramList).ayTop-1) &&
	   (mx > Get_List_Rect(&ProgramList).axLeft) &&
	   (mx < Get_List_Rect(&ProgramList).axLeft+3))
       {
	    UpLevel();
       }
       else
       {
#ifndef NOSWITCHER
			if(gTaskListEnabled)
			{
				if((my >= Get_List_Rect(&ProgramList).ayTop-1) &&
			   (my <= Get_List_Rect(&ProgramList).ayBottom) &&
			(mx >= Get_List_Rect(&ProgramList).axLeft) &&
			   (mx <= Get_List_Rect(&ProgramList).axRight))
			{
			if(ListMouse(&ProgramList,mx,my,message,state))
			{
						if(!ProgramList.hasglobalfocus)
						{
						GlobalFocusBox(&ProgramList,TRUE);
						   GlobalFocusBox(&TaskList,FALSE);
						}
			}
			   }
			else
			   {
			   if(TaskManMouse(mx,my,message,state))
			{
						if((!TaskList.hasglobalfocus) && (C_GET_LIST_LENGTH()))
						{
						   GlobalFocusBox(&TaskList,TRUE);
						GlobalFocusBox(&ProgramList,FALSE);
						}
			      }
			}
			}
			else
#endif
		ListMouse(&ProgramList,mx,my,message,state);
      }
}

extern void MarkAsInFM(void) ;

/* The following are for switching to the other view modes from
 * progman. We do it differently since the file manager must be inited
 * as this was once a "separate" program.
 * These cannot be macros, as they are called from menu items.
 */
VOID PDoSingleTree(void)
{
	DoSingleTree();
	MarkAsInFM() ;
}

VOID PDoDoubleTree(void)
{
	DoDoubleTree();
	MarkAsInFM() ;
}

VOID PDoFlatDisplay(void)
{
	DoFlatDisplay();

	/* If the tree is in compact tree mode, we refuse to get into this
	 * FM mode from the PM mode.
	 */
	if (!listinfo[0].tree->Compacted)
		MarkAsInFM() ;
}

VOID PDoShareMode(void)
{
	DoShareMode();
	MarkAsInFM() ;
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\hist.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************* hist.c *********************************/
/*	Contains routines to maintain a history of the contexts of the	*/
/*	current help session. The history stack is maintained as an array*/
/*	with indices 'gstart' and 'glast' giving the start & end.	*/
/************************************************************************/

/* ZZZZZ change malloc in hist.h used in MakeCopy if problem exists!! */

#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "hist.h"

char *gHistArr[MAXHIST];
int gfirst=0, glast=0 ; /* Implies there is one element in History array */

/************************************************************************/
/*	Routine to Initialize the history stack. 'szcontext' points to  */
/*	the first context to be present in the history.			*/
/* 	ZZ should be a macro? 						*/
/************************************************************************/
void far InitHistory(char *szcontext)
{
    gHistArr[gfirst = glast = 0] = MakeCopy(szcontext) ;
}

/************************************************************************/
/*	Routine to add another context string to the history stack. This*/
/*	stack wraps around the array and the history maintained is of the*/
/*	last MAXHIST context strings.					*/
/* BUGS: Doesn't free the context string memory when it leaves the history*/
/************************************************************************/
void far AddToHistory(char *szcontext)
{
    if (FHistArrFull()) {
	/* ZZZZ freeing of gHistArr[gfirst] needs to be done here !! */
        gHistArr[glast=gfirst] = MakeCopy(szcontext) ;
        gfirst = NextLoc(gfirst) ;
    }
    else
        gHistArr[++glast] = MakeCopy(szcontext) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\helper.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   file helper.c: miscellaneous helper routines for File Manager.
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  7/27/89   t-jeffro  Modified routines to recognize the _A_NOSIB flag.
**            harikris  Rewrote some fns like FillRecName.
**                                              Added utility routines like Internal2Normal,
**                                              Normal2Internal, etc.
*/
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <help.h>

#include <assert.h>


/****   Tree2Path - construct full path of a node
**      This fn constructs the actual pathname of the file or directory stored
**      in 'node'.
**
**      ENTRY
**              tree - tree containing the file node
**              node - file node to look at, or NULL for the tree root
**              str  - string to store path in
**    plength - storage to put the length of 'str' (formed path).
**      EXIT
**              str  - contains path string
**    plength - has length of constructed path
**              Returns depth in tree of file, 0 = root directory itself
**      WARNING:
**          Make sure str is at least MAX_PATH+1 long.
*/
int Tree2Path(PTREE tree, PENTRY node, char *str, int *plength)
{
	char components[MAXNODE][NAMELEN+EXTLEN+2];
	int temp ;
	char *ptemp ;
	int level = 0;
	int idx = 0;
	
	if (!tree || !str)
	{
		*plength = 0 ;

		if (str)
			*str = '\0' ;

		return -1;
	}
	
	/* Build component strings.
	*/
	while (node)
	{
		Internal2Normal(components[idx], node->name);
		node = FindParent(node);
		idx++;
	}
	level = idx;
	
	/* Combine the components into a path. */
	idx--;
	strfcpy(str, tree->root);
	temp = 3 ; // length of root path like c:\  etc is 3!

	while (idx >= 0)
	{
		ptemp = components[idx] ;
		while(*ptemp)
		{
			str[temp++] = (*ptemp++) ;
		}

		if (idx)
			str[temp++] = PATHCHAR ;

		idx--;
	}
	str[*plength = temp] = '\0' ;

	return level;
} /* proc Tree2Path */

/****   FindParent - returns ptr to parent of given record in tree
**      There's really not much else to say.
**
**      ENTRY
**              node - record whose parent you want
**      EXIT
**              ptr to the parent record, or NULL if error or parent is root.
*/
PENTRY FindParent(PENTRY node)
{
	if (!node)
		return NULL;
	
	/* If nosib is turned on, then there are no more siblings and the
	** sibling ptr actually points to the parent.
	*/
	while (!node->nosib)
		node = node->sibling;
	return node->sibling;
} /* proc FindParent */

/***    FindLastComponent - returns index of last component of a path
**
**      This fn finds the index of the last component of the path.  The
**      index returned points to the backslash in front of the component
**      name, except in two cases.  The first is when the path is like 
**        "bin", where the index returned is 0; the second is when it is
**      like "C:\bin" where the index returned is the beginning of the name
**      itself.  This is done so that lopping off the last component leaves
**      the correct parent, "C:\", rather than "C:" which refers to the
**      current directory on C:.
**       
**      ENTRY
**              path - path to work on
**
**      EXIT
**              Return val: index as described above.
**
**      WARNING:
**          If the app wants the name of the component, it should skip forward
**      one byte if path[return val] == PATHCHAR.  "path" is not checked
**      for NULLness.
**
**      EFFECTS:
**              none
*/
int FindLastComponent(path)
char path[];
{
	register int i;
	BOOL hasdrive;
	
	if (path[1] == ':')
		hasdrive = TRUE;
	else
		hasdrive = FALSE;
	
	i = strlen(path)-2;                                     // start at last char but one
#ifdef DBCS
	while ((i >= 0 && path[i] != PATHCHAR) ||
			(i >= 0 && CheckDBCSTailByte(path,&path[i])))
#else
	while (i >= 0 && path[i] != PATHCHAR)
#endif
		i--;
	if (i == 0)                                                     // path like "\word"
		i = 1;                                  
	else if (i < 0) {                                       // path like "word"
		i = 0;
		return i;
	} else if (hasdrive) {
		if (i == 2)                                             // path like "c:\word"
			return 3;                                       // it belongs to 1st component
	}
	return i;
	
} /* proc FindLastComponent */

/* ZZZZZZ I think I can get rid of      this function and use fn Internal2Normal
 * instead!!
*/
/****   FillRecName - put file name into a record
**      This fn takes the filename part of a path and puts it into the given
**      fileinfo record.
**
**      ENTRY
**                      path - the filename to add
**                      rec  - far ptr to the record
**      EXIT
**                      none
**      WARNING
**              Although the fn will accept a fully qualified path, only the actual
**      file name is stored in the record.  The rest is not used.
**              There is no error checking to speak of.
*/
VOID FillRecName(path, rec)
char *path;
PENTRY rec;
{
	path += FindLastComponent(path);                // skip over path
	if (*path == PATHCHAR)
		path++;

	Normal2Internal(rec->name, path) ;
} /* proc FillRecName */

/****   FindTree - locate tree corresponding to the given pathname
**
**      ENTRY
**              path - fully qualified pathname
**      EXIT
**              a ptr to the tree, or NULL if not found. Also index in the list 0 based.
**      NOTE
**              The path does not need to specify a real file; only the drive letter
**      is used.
*/
PTREE FindTree(char path[], BYTE *driveind)
{
	PTREE tree;

	*driveind = 0 ;
	tree = glob.drives;
	while (tree && tree->root[0] != *path)
	{
		*driveind = (*driveind) + 1 ;
		tree = tree->next;
	}
	return tree;
}

/****   FindNode - find node corresponding to given file
**
**      ENTRY
**              tree      - tree to search, or NULL to force fn to find it
**              path      - path to find node of
**              theparent - ptr to variable to store parent ptr in
**              thenode   - ptr to variable to store file ptr in
**              fForceFind   - whether to find node even if tree is not yet fully
**                   built. TRUE implies Search for it anyway.
**      EXIT
**              0 - neither file nor its parent were found.
**              1 - file wasn't found, but its parent was; *theparent contains the ptr.
**              2 - file was found; both *theparent and *thenode contain valid ptrs.
*/
int FindNode(PTREE tree, char path[], PENTRY *theparent, PENTRY *thenode,
																	BOOL fForceFind)
{
	BOOL done;                                                      // found last directory
	char *temp;                                                     // used for excising path components
	PENTRY node;                                            // local file ptr
	PENTRY parent;                                          // local parent ptr
	BYTE dummy ;

	if (!tree)                                                      // need to locate tree
	{
		tree = FindTree(path, &dummy);
	}

	if ( (!tree) || (!tree->Started) )
		return 0 ;

	/* If fForceFind is FALSE, and if tree is not yet built completely, say
	 * that node and its parent are not present.
	 */
	if ( (!fForceFind) && (tree->ContinueTree) )
		return 0 ;

	path += 3;                                                      // get past drive & leading '\'
	done = FALSE;
	parent = NULL;                                          // start from root directory
	do {
		/* Isolate the top-level component.  */
#ifdef DBCS
		temp = DBCSstrchr(path, PATHCHAR);
#else
		temp = strchr(path, PATHCHAR);
#endif
		if (!*temp)
		{
			done = TRUE;                            // only the file name remains
		} else
		{
			*temp = EOS;
		
			/* Find component's location in tree.  */
			parent = File2Node(tree, parent, path);
			*temp = PATHCHAR;                       // restore string
			if (!parent)
			{
				return 0;                               // directory not found
			}
			path = temp+1;                          // beginning of next component
		}
	} while (!done);

	*theparent = parent;

	if (*path == EOS)
	{
		// path is empty - we are examining the root directory itself.
		*thenode = NULL;
		return 2;                                               // both items valid
	} else
	{
		node = File2Node(tree, parent, path);
		*thenode = node;
		return (node ? 2 : 1);                  // either one or both items is valid 
	}
} /* proc FindNode */

/****   File2Node - finds node corresponding to a file
**
**      ENTRY
**                      tree - tree to investigate
**                      dir  - directory that the file is in
**                      file - file name to locate
**      EXIT
**                      pointer to the file's record, or NULL if not found.
*/
PENTRY File2Node(tree, dir, file)
PTREE tree;
PENTRY dir;
char file[];
{
	char pInternalForm[NAMELEN+EXTLEN];             // extension of file
	PENTRY node;                                                    // node to check

	node = (dir) ? dir->x.d.child : tree->head ;
		
	if (!node)
		return NULL;

	Normal2Internal(pInternalForm, file) ;
	
	while (node)
	{
		if (fstrncmp(pInternalForm, node->name, NAMELEN) ||
			fstrncmp(pInternalForm+NAMELEN, node->name+NAMELEN, EXTLEN))
		{
			node = (node->nosib) ? NULL : node->sibling ;
		} 
		else
			break; /* node found! */
	} /* while */

	return node;
} /* proc File2Node */

extern char szStarDotStar[] ;

/****   LoadCompactDir  - read in new directory's files in low-memory mode
**
**      ENTRY
**                      tree - tree to manipulate
**                      new  - newly selected directory
**      EXIT
**                      TRUE if ok, FALSE if out of memory
**      CAUTION
**              This fn should not be called if the files are already in the tree.
*/
BOOL LoadCompactDir(PTREE tree, PENTRY new)
{
	struct find_t fdata;                            // data used by _dos_findxxx
	fileinfo rec;                                           // record to add to tree
	unsigned ret;                                           // return code from dos call
	int action;                                                     // what to do
	BOOL first;                                                     // TRUE if run findfirst
	char path[MAX_PATH+1];                          // path of new directory
	int idx;                                                        // index of file in directory
	int dummylen ;
	char *tempcaption ;

	/* Wipe out from memory any files currently in directory 'new' and
	 * start with a clean slate.
	 */
	ClobberDir(tree, new) ;

	/* Add all the files in this directory.
	*/
	Tree2Path(tree, new, path, &dummylen);
	idx = strlen(path);
#ifdef DBCS
	if (path[idx-1] != PATHCHAR || CheckDBCSTailByte(path,&path[idx-1]))
#else
	if (path[idx-1] != PATHCHAR)
#endif
		path[idx++] = PATHCHAR;
	strcpy(path+idx, szStarDotStar) ;

	first = TRUE;
	idx = 0;
	do {

		// Get the file from disk.
		do {
			if (first)
			{
				first = FALSE;
				ret = shell_findfirst(path, _A_HIDDEN | _A_SYSTEM, &fdata);
			} else
				ret = _dos_findnext(&fdata);

			if (ret && ret != 18)           // abnormal error
			{
				/* No status line */
				tempcaption = gpszFileOpCaption ;
				gpszFileOpCaption = szErrorCaption ;
				action = DOSErrorBox(szErrorFindfirstnext, ret, HELP_DISKLOADFILES);
				gpszFileOpCaption = tempcaption ;
			} else
				action = ACT_OK;
		} while (action != ACT_OK && action != ACT_FORCE);

		// If there is a file to add, add it to the tree.
		if (!ret)
		{
			// Found a file; add it to the tree.
			FillRecName(fdata.name, (PENTRY) &rec); // put name/ext into record
			rec.dtlx.dt.time = fdata.wr_time;
			rec.dtlx.dt.date = fdata.wr_date;
			rec.attribs = fdata.attrib;
			rec.sibling = NULL;
			rec.nosib = rec.SELECTED = 0;
			rec.x.f.size = fdata.size;
			rec.x.f.snext = NULL;

			/* AddLateFile will locate the proper tree and add our record to it.
			*/
			if (!AddLateFile(NULL, &rec, tree, new, idx))
			{
				// out of memory reading in...
				// OutOfMemory();
				SortDirectory(tree, new) ;
				return FALSE ;
			}
		}
		idx++;
	} while (!ret);

	SortDirectory(tree, new) ;

	/* Files have just been loaded in! -- just re-calc this as the directory
	 * that was re-loaded could have had selected files that got clobbered
	 * now!
	 */
	tree->NumSel = GetTreeSelectedInfo(tree, &(tree->SizeSel)) ;

	if (ret != 18)
		return FALSE;                                   // had an error
	else
		return TRUE;
} /* proc LoadCompactDir */


/* If 'tree' is a Network Drive and it says that there are no files
 * or directories on it, it could be a Novell server on which the user
 * hasn't logged in.
 * If it is any other drive type or network drive, do nothing!
 */
void HandleSpecialCaseNovell(PTREE tree)
{
	BOOL ret ;
   struct find_t findinfo ;
	char LoginDirFilesMatchPat[32] ;
	int len ;

	/* If we are on a network drive and if we get a report that there
	 * are no files or directories on the network, it is likely
	 * to be a Novell server on which the user has not logged in.
	 * We see if there are files in the LOGIN directory. Note that
	 * Novell kind of fakes the directory structure and shows only this
	 * directory (and 8 files belonging to it) when one does a 'dir'
	 * Actually _dos_findfirst() fails on the LOGIN directory but succeeds
	 * on the files belonging to it.
	 */
	/* Since it is a HACK anyway, I am using the string "LOGIN" straightaway.
	 * I don't see much point in getting the current working directory on
	 * this network drive and then seeing if it is a non-root directory
	 * and if so using that name (LOGIN or whatever).
	 */
	if (    (tree->DriveType == REMOTE_TYPE) &&
			(tree->Diskfilecount+tree->DirCount == 0)
		)
	{
		/*   Form the path of the form "H:\LOGIN\*.*"      */
		strfcpy(LoginDirFilesMatchPat, tree->root) ;
		strcpy(LoginDirFilesMatchPat+3, szNovellLoginDirName) ;
		len = strlen(LoginDirFilesMatchPat) ;
		LoginDirFilesMatchPat[len++] = '\\' ;
		strcpy(LoginDirFilesMatchPat+len, szStarDotStar) ;

		ret = _dos_findfirst(LoginDirFilesMatchPat, _A_HIDDEN | _A_SYSTEM,
																		&findinfo) ;
		/* Did we find any files in this directory? If so, it is Novell! */
		if (!ret)
		{
			/* There are no files/dirs -- so it is trivially in sorted order */
			tree->SortRequired = FALSE ;

			/* Create a fake directory -- If we pass in FALSE for the last
			 * argument, fn CreateDirectory() will not attempt to create
			 * a directory on the disk. It will only add this directory
			 * to the tree.
			 */
			CreateDirectory(tree, NULL, szNovellLoginDirName, FALSE) ;

			/* Note that tree->FirstDirectory will be this login directory */
			LoadCompactDir(tree, tree->FirstDirectory) ;
		}
	}
} /* HandleSpecialCaseNovell */


/****   Internal2Normal - forms the proper name from the internal format
**
**      ENTRY
**              dest - destination -- dest has atleast storage for 13 characters
**             8 for name + 3 for extension + 1 for '.' and 1 for NULL.
**              src  - source which is in internal format for file names.
**      EXIT
**              dest - has the filename with '.' as appropriate and null terminated.
**              returns the number of characters in normal name (without NULL)
*/
int Internal2Normal(char far *dest, char far *src)
{
	char far *srcbound ;
	char far *deststart ;

	srcbound = src + NAMELEN ;
	deststart = dest ;

	for ( ; (src < srcbound) && *src ; )
		*(dest++) = *(src++) ;
		
	if (*srcbound)
	{
		*(dest++) = '.';

		src = srcbound ;
		srcbound += EXTLEN ; /* reuse of variable extstart to point to end! */

		for ( ; (src < srcbound) && *src ; )
			*(dest++) = *(src++) ;
		
	}

	*dest = '\0' ;

	return (dest - deststart) ;

} /* Internal2Normal */

/* Returns TRUE iff char 'ch' can't be a part of a file name */
/* ZZZZZ for now we are only handling blanks */
#define fInvalidChar(ch) (ch == ' ')

/****   Normal2Internal - Convert from normal null terminated name to internal
**  format (stored in 11 character format (may or may not be null terminated).
**  Short names & extensions are padded with NULL chars -- aids in sorting!
**
**  ENTRY:
**      'dest' has 11 character storage in it (OK, if more storage available).
*/
VOID Normal2Internal(char far *dest, char far *src)
{
	char far *extstart ;

	extstart = dest + NAMELEN ;

	/* Take upto the '.' or NULL but a max of NAMELEN (= 8) characters */
	while ( (*src != '.') && *src && (dest < extstart) )
	{
		/* Skip invalid chars -- chars that can't be part of file name */
		if (fInvalidChar(*src))
			src++ ;
		else
			*(dest++) = *(src++);
	}

	/* Null fill till end of name  */
	while (dest < extstart)
		*(dest++) = '\0' ;

	/* Extension may be present -- skip until EOS or '.' */ 
	while (*src && (*src != '.') )
		src++ ;

	extstart = extstart + EXTLEN ; /* reuse of this variable */

	/* Is there an extension in the name, i.e., is there a '.'?  */
	if (*src)
	{
		src++ ; /* point to character after '.' */
	

		/* '.' cannot be part of extension -- so we use that as terminator
		 * in case src is ill-formed 
		*/
		while ( (*src != '.') && *src && (dest < extstart) )
		{
			/* Skip invalid chars -- chars that can't be part of file name */
			if (fInvalidChar(*src))
				src++ ;
			else
				*(dest++) = *(src++);
		} /* while */
	} /* if */

	/* If extension is less than 3 characters -- pad with Null characters */
	while (dest < extstart)
		*(dest++) = '\0' ;

} /* Normal2Internal */

/* Warning! Assuming dest & src are pointers to different storages! Otherwise
 * strange things may happen. If fSpecial is TRUE, special handling is done
 * to patterns with a '.' as the suffix -- This is so that pattern matching
 * strings can use this to specify all strings without an extension ("*.")
 * In normal names we can't have a period in the name without an extension.
 */
VOID ScrunchFileName(char *dest, char *src, BOOL fSpecial)
{
	char temp[NAMELEN+EXTLEN] ;
	char *p ;
	int i ;

	Normal2Internal(temp, src) ;

	i = Internal2Normal(dest, temp) ;

	if (fSpecial)
	{
		/* We want to transform patterns like "*." to "*." and not "*" so 
		 * do this special case handling using strchr, etc.
		 */
		p = strchr(src, '.') ;

		if (p && (*(p+1) == '\0'))
		{
			*(dest+i) = '.' ;
			*(dest+i+1) = '\0' ;
		}
	}
} /* ScrunchFileName */

/* Given a file node, this fn, sets it MATCHESPATTERN bit based on
 * "glob.MatchPat" and "glob.DisplayHiddenFiles.
 */
void MarkMatchesBit(PENTRY fil)
{
	fil->MATCHESPATTERN = pmatch(glob.MatchPat, fil->name, FULLNAME) ;
	fil->MATCHESPATTERN =
			fil->MATCHESPATTERN && 
				(glob.DisplayHiddenFiles || 
					!(fil->attribs & (_A_HIDDEN | _A_SYSTEM))) ;
} /* MarkMatchesBit */


/* Reset TreeMatchedFiles optimizations -- This is typically done when the
 * "MatchPat" has changed or if the user has decided to change the hidden or
 * system files display mode -- basically, the total number of displayed
 * files on the disk/tree has changed.
 */
void ResetTreeMatchedFilesOpt(PTREE tree)
{
	extern PENTRY gLastEntry ;
	
	tree->nummatches = RECALCNUMMATCHES ;
	gLastEntry = NULL ;
} /* ResetTreeMatchedFilesOpt */


void FormCountStatusLine(char *statusline, char *szopstr, char *path,
					  unsigned  count, unsigned total, int indexofcount)
{
	int i ;

	/* Copy string (ex of strings: "Moving File:", "Deleting File:", etc) */
	for (i= 0 ; *szopstr ; i++)
		*(statusline++) = *(szopstr++) ;

	/* two blanks after the operation string! */
	/* only one if ONESPACEAFTERCOLONINSTATUSLINE is defined */
#ifndef ONESPACEAFTERCOLONINSTATUSLINE
	*(statusline++) = ' ' ;
	*(statusline++) = ' ' ;
	i+=2;
#else
	*(statusline++) = ' ' ;
	i+=1 ;
#endif
	/* Now the filename starts! */
	path += FindLastComponent(path) ;
	if (*path == PATHCHAR)
		path++ ;

	for (; *path ; i++)
		*(statusline++) = *(path++) ;

	if (total > 0)
	{
		/* Pad with blanks until start of string xx of xx */
		for ( ; i < indexofcount ; i++ )
			*(statusline++) = ' ' ;
	
		/* Warning! Assuming that Formxxofxx puts the EOS at end of string */
		Formxxofxx(statusline, count, total) ;
	}
	else
		*statusline = '\0' ;
} /* FormCountStatusLine */

/* Warning! Assuming that "str" is atleast 15 bytes long! -- 5 bytes for
count, 4 bytes for " of ", 5 bytes for total, 1 for NULL char. */
void Formxxofxx(char *str, int count, int total)
{
    char szCount[7], szTotal[7];
    int i;

    for(i=0; i<6; ++i)
	szCount[i] = szTotal[i] = ' ';
    szCount[6] = szTotal[6] = '\0';

    CopyNumberForTextOut(szCount+5, (unsigned long) count, FALSE);
    CopyNumberForTextOut(szTotal+5, (unsigned long) total, FALSE);

    FormStringWithoutPlaceHolders(str, szXOfX, (char far *)szCount+1,
	    (char far *)szTotal+1);
} /* Formxxofxx */


/* Concatenates str1, str2 with 2 blanks as separator in between them           */
/* Also 'maxlen' is the number of bytes in storage availbale in statusline  */
/* At the end of this routine, 'statusline' will be null terminated.            */
void FormStringStatusLine(char *statusline, char *str1, char *str2, int maxlen)
{
	int len ;

	len = strlen(str1) ;
	/* ZZZ remove before shipping! -- There should be atleast space for
	 * str1, two blanks & NULL char.
	 */
	assert(maxlen > (len + 2 + 1)) ;

	strcpy(statusline, str1) ;

	/* two blanks as separator */
	statusline[len]   = ' ' ;
	statusline[len+1] = ' ' ;

	strncpy(statusline+len+2, str2, maxlen-1-len-2) ;

	statusline[maxlen-1] = '\0' ;

} /* FormStringStatusLine */

#if 0
/* ZZZ Old code!! I rewrote it using call Normal2Internal fn call! */
/*      Saves on code-size. Normal2Internal takes care of ill-formed path! */
VOID FillRecName(path, rec)
char *path;
PENTRY rec;
{
	int i;
	char c;                                                                 // current character
	char far *dest;                                                 // destination ptr

	path += FindLastComponent(path);                // skip over path
	if (*path == PATHCHAR)
		path++;

	dest = rec->name;

	/* Copy name.
	*/
	while ((c=*path) != '.' && c)
		*dest++ = *path++;
	*dest = EOS;

	/* Copy extension.
	*/
	dest = rec->name+NAMELEN;
	if (c == '.')
	{
		path++;

		i = 0;
		while (*path)
		{
			*dest++ = *path++;
			i++;
		}
		if (i < EXTLEN)
			*dest = EOS;
	} else
	{
		*dest = EOS;
	}
} /* proc FillRecName */

/* I rewrote this routine to reduce code size and improve readability! */
PENTRY File2Node(tree, dir, file)
PTREE tree;
PENTRY dir;
char file[];
{
	char ext[4];                                                    // extension of file
	PENTRY node;                                                    // node to check
	char *extptr;                                                   // ptr to extension of file

	if (dir)
		node = dir->x.d.child;                          // fetch first child
	else
		node = tree->head;
	if (!node)
		return NULL;

	extptr = strchr(file, '.');
	if (extptr)
	{
		strncpy(ext, extptr+1, EXTLEN);         // copy extension w/o '.'
		ext[3] = EOS;                                           // used if ext is 3 chars long
		*extptr = EOS;                                          // zap out extension from file
	} else
	{
		ext[0] = EOS;
	}

	while (node)
	{
		if (fstrncmp(file, node->name, NAMELEN) ||
			fstrncmp(ext, node->name+NAMELEN, EXTLEN))
		{
			if (node->nosib)                                // end of chain, file doesn't exist
			{
				node = NULL;
				break;
			} else
				node = node->sibling;
		} else
		{
			break;
		}
	}
	if (extptr)
		*extptr = '.';                                          // restore full file name

	return node;
} /* File2Node */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\icons.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	icons.c - contains all the icons
**
*/
#include <common.h>
#include <icons.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>


char bigRadioButtonUnSelData[] =
{
/*		   3210321032103210 */
	0x03,0xC0,	/*		 XXXX		*/
    0x0C,0x30,	/*     XX    XX     */
    0x30,0x0C,	/*   XX        XX   */
	0x20,0x04,	/*	 X			X	*/
	0x40,0x02,	/*	X			  X */
	0x40,0x02,	/*	X			  X */
	0x40,0x02,	/*	X			  X */
	0x40,0x02,	/*	X			  X */
	0x20,0x04,	/*	 X			  X	*/
    0x30,0x0C,	/*   XX        XX   */
    0x0C,0x30,	/*     XX    XX     */
	0x03,0xC0  /*		 XXXX		*/
};

char bigRadioButtonSelData[] =
{
/*		   3210321032103210 */
	0x03,0xC0,	/*		 XXXX		*/
    0x0C,0x30,	/*     XX    XX     */
    0x30,0x0C,	/*   XX        XX   */
	0x27,0xE4,	/*	 X	 XXXXXX	 X	*/
	0x4F,0xF2,	/*	X	XXXXXXXX  X */
	0x4F,0xF2,	 /* X	XXXXXXXX  X */
	0x4F,0xF2,	 /* X	XXXXXXXX  X */
	0x4F,0xF2,	 /* X	XXXXXXXX  X */
	0x27,0xE4,	/*	 X	 XXXXXX	 X	*/
    0x30,0x0C,	/*   XX        XX   */
    0x0C,0x30,	/*     XX    XX     */
	0x03,0xC0  /*		 XXXX	   */
};


char bigUpArrowData[] =
{
    0x00,0x00,
    0x00,0x00,
    0x00,0x00,
    0x01,0x80,	/*	   XX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x07,0xE0,	/*	 XXXXXX 	*/
    0x0F,0xF0,	/*	XXXXXXXX	*/
	0x1F,0xF8,	/* XXXXXXXXXX	*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0	/*	  XXXX		*/
};

char bigDownArrowData[] =
{
    0x00,0x00,
    0x00,0x00,
    0x00,0x00,
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
    0x03,0xC0,	/*	  XXXX		*/
	0x1F,0xF8,	/* XXXXXXXXXX	*/
    0x0F,0xF0,	/*	XXXXXXXX	*/
    0x07,0xE0,	/*	 XXXXXX 	*/
    0x03,0xC0,	/*	  XXXX		*/
    0x01,0x80,	/*	   XX		*/
};


char bigProgramIconData[] =
{						/*	 000011112222333344445555	*/
	0x00,0x00,0x00,
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/
	0x40,0x00,0x10,		/*	  x 				     x	*/
	0x40,0x00,0x10,		/*	  x 				     x	*/
	0x7f,0xff,0xf0, 	   /*	  xxxxxxxxxxxxxxxxxxx	*/
	0x40,0x00,0x10,		/*	  x 				     x	*/
	0x40,0x00,0x10, 	   /*	  x                 x	*/
	0x40,0x00,0x10,		/*	  x   	 	  	     x	*/
	0x40,0x00,0x10, 	   /*	  x                 x	*/
	0x40,0x00,0x10, 	   /*	  x   	 	  	     x	*/
	0x40,0x00,0x10, 	   /*	  x                 x	*/
	0x40,0x00,0x10, 	   /*	  x 				     x	*/
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/

};

char bigProgramIconDataInvert[] =
{						/*	 000011112222333344445555	*/
	0xff,0xff,0xf8,		/*	 xxxxxxxxxxxxxxxxxxxxx		*/
	0x80,0x00,0x08,		/*	 x					      x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0x80,0x00,0x08, 	   /*	 x					      x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xbf,0xff,0xe8, 	   /*	 x xxxxxxxxxxxxxxxxx x     */
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xbf,0xff,0xe8, 	   /*	 x xxxxxxxxxxxxxxxxx x     */
	0xbf,0xff,0xe8, 	   /*	 x xxxxxxxxxxxxxxxxx x		*/
	0xbf,0xff,0xe8, 	   /*	 x xxxxxxxxxxxxxxxxx x     */
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0x80,0x00,0x08,		/*	 x					      x		*/
	0xff,0xff,0xf8, 	   /*	 xxxxxxxxxxxxxxxxxxxxx		*/

};


char bigProgManIconData[] =
{						/*	 000011112222333344445555	*/
	0x00,0x00,0x00,
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/
	0x40,0x00,0x10,		/*	  x 				x	*/
	0x40,0x00,0x10,		/*	  x 				x	*/
	0x7f,0xff,0xf0, 	/*	  xxxxxxxxxxxxxxxxxxx	*/
	0x40,0x00,0x10,		/*	  x 				x	*/
	0x4f,0xff,0x90, 	/*	  x  xxxxxxxxxxxxx	x	*/
	0x48,0x88,0x90,		/*	  x  x	 x	 x	 x	x	*/
	0x4f,0xff,0x90, 	/*	  x  xxxxxxxxxxxxx	x	*/
	0x48,0x88,0x90, 	/*	  x  x	 x	 x	 x	x	*/
	0x4f,0xff,0x90, 	/*	  x  xxxxxxxxxxxxx	x	*/
	0x40,0x00,0x10, 	/*	  x 				x	*/
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/

};

char bigProgManIconInvertData[] =
{						/*	 000011112222333344445555	*/
	0xff,0xff,0xf8,		/*	 xxxxxxxxxxxxxxxxxxxxx		*/
	0x80,0x00,0x08,		/*	 x					 x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0x80,0x00,0x08, 	/*	 x					 x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xb0,0x00,0x68, 	/*	 x xx			  xx x		*/
	0xb7,0x77,0x68,		/*	 x xx xxx xxx xxx xx x		*/
	0xb0,0x00,0x68, 	/*	 x xx			  xx x		*/
	0xb7,0x77,0x68, 	/*	 x xx xxx xxx xxx xx x		*/
	0xb0,0x00,0x68, 	/*	 x xx			  xx x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0x80,0x00,0x08,		/*	 x					 x		*/
	0xff,0xff,0xf8, 	/*	 xxxxxxxxxxxxxxxxxxxxx		*/

};



char smallProgManIconData[] =
{						/*	 000011112222333344445555	*/
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/
	0x40,0x00,0x10,		/*	  x 				x	*/
	0x4f,0xff,0x90, 	/*	  x  xxxxxxxxxxxxx	x	*/
	0x48,0x88,0x90, 	/*	  x  x	 x	 x	 x	x	*/
	0x48,0x88,0x90,		/*	  x  x	 x	 x	 x	x	*/
	0x4f,0xff,0x90, 	/*	  x  xxxxxxxxxxxxx	x	*/
	0x40,0x00,0x10, 	/*	  x 				x	*/
	0x7f,0xff,0xf0,		/*	  xxxxxxxxxxxxxxxxxxx	*/

};

char smallProgManIconInvertData[] =
{						/*	 000011112222333344445555	*/

	0x80,0x00,0x08, 	/*	 x					 x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0xb0,0x00,0x68, 	/*	 x xx			  xx x		*/
	0xb7,0x77,0x68,		/*	 x xx xxx xxx xxx xx x		*/
	0xb7,0x77,0x68, 	/*	 x xx xxx xxx xxx xx x		*/
	0xb0,0x00,0x68, 	/*	 x xx			  xx x		*/
	0xbf,0xff,0xe8,		/*	 x xxxxxxxxxxxxxxxxx x		*/
	0x80,0x00,0x08,		/*	 x					 x		*/


};




char bigFileIconData[] =	   /*	000011114444555566667777   */
{
    0x00,0x00,0x00,			/*   12345678123412345678  */
    0x7F,0xFC,0x00,			/*    XXXXXXXXXXXXX	   */
    0x40,0x06,0x00,			/*    X 	  XX	   */
    0x5E,0x65,0x00,			/*    X XXXX  XX  X X	   */
    0x40,0x04,0x80,			/*    X 	  X  X	   */
    0x59,0xC4,0x40,			/*    X XX  XXX   X   X    */
    0x40,0x07,0xE0,			/*    X 	  XXXXXX   */
    0x5E,0x70,0x20,			/*    X XXXX  XXX      X   */
    0x40,0x00,0x20,			/*    X 	       X   */
    0x40,0x00,0x20,			/*    X 	       X   */
    0x40,0x00,0x20,			/*    X 	       X   */
    0x7F,0xFF,0xE0,			/*    XXXXXXXXXXXXXXXXXX   */
    0x00,0x00,0x00
};

char bigFileIconDataInvert[] =	   /*	000011114444555566667777   */
{					/*   12345678123412345678   */
    0xff,0xfc,0x00,			/*   xxxxxxxxxxxxxx	    */
    0x80,0x02,0x00,			/*   x		   x	    */
    0xbf,0xf9,0x00,			/*   x xxxxxxxxxxx  x	    */
    0xA1,0x9a,0x80,			/*   x x    xx	xx x x	    */
    0xbf,0xfb,0x40,			/*   x xxxxxxxxxxx xx x     */
    0xA6,0x3b,0xa0,			/*   x x  xx   xxx xxx x    */
    0xbf,0xf8,0x10,			/*   x xxxxxxxxxxx	x   */
    0xA1,0x8f,0xd0,			/*   x x    xx	 xxxxxx x   */
    0xbf,0xff,0xd0,			/*   x xxxxxxxxxxxxxxxx x   */
    0xbf,0xff,0xd0,			/*   x xxxxxxxxxxxxxxxx x   */
    0xbf,0xff,0xd0,			/*   x xxxxxxxxxxxxxxxx x   */
    0x80,0x00,0x10,			/*   x			x   */
    0xff,0xff,0xf0			/*   xxxxxxxxxxxxxxxxxxxx   */
};

#ifdef USEOLDPILLICON
char bigProgramIconDataInvert[]= // 000011112222333344445555
{					//    12345678123412345678
	0x1f,0xff,0x80, 		//	 xxxxxxxxxxxxxx
	0x20,0x00,0x40, 		//	x	       x
	0x5f,0xff,0xA0, 		//     x xxxxxxxxxxxxxx x
	0xbf,0xff,0xd0, 		//    x xxxxxxxxxxxxxxxx x
	0xb0,0x00,0xd0, 		//    x xx	      xx x
	0xbf,0xff,0xd0, 		//    x xxxxxxxxxxxxxxxx x
	0xb0,0x03,0xd0, 		//    x xx	    xxxx x
	0xbf,0xff,0xd0, 		//    x xxxxxxxxxxxxxxxx x
	0xb0,0x00,0xd0, 		//    x xx	      xx x
	0xbf,0xff,0xd0, 		//    x xxxxxxxxxxxxxxxx x
	0x5f,0xff,0xA0, 		//     x xxxxxxxxxxxxxx x
	0x20,0x00,0x40, 		//	x	       x
	0x1f,0xff,0x80, 		//	 xxxxxxxxxxxxxx
};

char bigProgramIconData[] =	   //	000011112222333344445555
{
	0x00,0x00,0x00, 		//    12345678123412345678
	0x1f,0xff,0x80, 		//	 xxxxxxxxxxxxxx
	0x20,0x00,0x40, 		//	x	       x
	0x40,0x00,0x20, 		//     x		x
	0x4f,0xff,0x20, 		//     x  xxxxxxxxxxxx	x
	0x40,0x00,0x20, 		//     x		x
	0x4f,0xfC,0x20, 		//     x  xxxxxxxxxx	x
	0x40,0x00,0x20, 		//     x		x
	0x4f,0xff,0x20, 		//     x  xxxxxxxxxxxx	x
	0x40,0x00,0x20, 		//     x		x
	0x20,0x00,0x40, 		//	x	       x
	0x1f,0xff,0x80, 		//	 xxxxxxxxxxxxxx
	0x00,0x00,0x00
};
#endif	
char bigDirExpansionIconData[] =
{					//	00001111222244445555
	0x00,0x00,0x00, 		//
	0x1E,0x00,0x00, 		//	   xxxx
	0x21,0x00,0x00, 		//	  x    x
	0x40,0xff,0x80, 		//	 x	xxxxxxxxx
	0x7f,0x00,0x40, 		//	 xxxxxxx	 x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x20,0x20, 		//	 x	  x	  x
	0x40,0x20,0x20, 		//	 x	  x	  x
	0x40,0xf8,0x20, 		//	 x	xxxxx	  x
	0x40,0x20,0x20, 		//	 x	  x	  x
	0x40,0x20,0x20, 		//	 x	  x	  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x7f,0xff,0xe0, 		//	 xxxxxxxxxxxxxxxxxx
	0x00,0x00,0x00,
	0x00,0x00,0x00
};
	
char bigDirCollapseIconData[] =
{
					//	00001111222244445555
	0x00,0x00,0x00, 		//
	0x1E,0x00,0x00, 		//	   xxxx
	0x21,0x00,0x00, 		//	  x    x
	0x40,0xff,0x80, 		//	 x	xxxxxxxxx
	0x7f,0x00,0x40, 		//	 xxxxxxx	 x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0xF8,0x20, 		//	 x	xxxxx	  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x7f,0xff,0xe0, 		//	 xxxxxxxxxxxxxxxxxx
	0x00,0x00,0x00,
	0x00,0x00,0x00
};

char bigDirNoZoomIconData[] =
{					//	00001111222244445555
	0x00,0x00,0x00, 		//
	0x1E,0x00,0x00, 		//	   xxxx
	0x21,0x00,0x00, 		//	  x    x
	0x40,0xff,0x80, 		//	 x	xxxxxxxxx
	0x7f,0x00,0x40, 		//	 xxxxxxx	 x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x40,0x00,0x20, 		//	 x		  x
	0x7f,0xff,0xe0, 		//	 xxxxxxxxxxxxxxxxxx
	0x00,0x00,0x00,
	0x00,0x00,0x00
};



char bigFloppyIconData[] =	   /*	000011112222333344445555   */
{
	0x00,0x00,0x00,		/*                              */
	0x7f,0xff,0xfc,		/*    xxxxxxxxxxxxxxxxxxxxx     */
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x41,0xff,0x06,		/*    x     xxxxxxxxx     xx	*/
	0x41,0x01,0x06,		/*    x     x       x     xx	*/
	0x4f,0xff,0xe6,		/*    x  xxxxxxxxxxxxxxx  xx	*/
	0x41,0x01,0x06,		/*    x     x       x     xx	*/
	0x41,0xff,0x06,		/*    x     xxxxxxxxx     xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x7f,0xff,0xfe,		/*    xxxxxxxxxxxxxxxxxxxxxx	*/
	0x3f,0xff,0xfe,		/*     xxxxxxxxxxxxxxxxxxxxx	*/
};

char bigFloppyIconDataInvert[] =   /*	000011112222333344445555   */
{
	0xff,0xff,0xfe,		/*   xxxxxxxxxxxxxxxxxxxxxxx	*/
	0x80,0x00,0x03,		/*   x                     xx	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbe,0x00,0xf9,		/*   x xxxxx         xxxxx  x	*/
	0xbe,0xfe,0xf9,		/*   x xxxxx xxxxxxx xxxxx  x   */
	0xb0,0x00,0x19,		/*   x xx               xx  x	*/
	0xbe,0xfe,0xf9,		/*   x xxxxx xxxxxxx xxxxx  x   */
	0xbe,0x00,0xf9,		/*   x xxxxx         xxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0x80,0x00,0x01,		/*   x                      x	*/
	0xc0,0x00,0x01,		/*   xx                     x   */
	0x7f,0xff,0xff		/*    xxxxxxxxxxxxxxxxxxxxxxx	*/
};

char bigHDIconData[] =		   /*	000011112222333344445555   */
{
	0x00,0x00,0x00,		/*                              */
	0x00,0x00,0x00,		/*                              */
	0x7f,0xff,0xfc,		/*    xxxxxxxxxxxxxxxxxxxxx     */
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x07,0xe6,		/*    x           xxxxxx  xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x7f,0xff,0xfe,		/*    xxxxxxxxxxxxxxxxxxxxxx	*/
	0x3f,0xff,0xfe,		/*     xxxxxxxxxxxxxxxxxxxxx	*/
	0x00,0x00,0x00		/*                              */
};

char bigHDIconDataInvert[] =	   /*	000011112222333344445555   */
{
	0x00,0x00,0x00,		/*                              */
	0xff,0xff,0xfe,		/*   xxxxxxxxxxxxxxxxxxxxxxx	*/
	0x80,0x00,0x03,		/*   x                     xx	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xf8,0x19,		/*   x xxxxxxxxxxx      xx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0x80,0x00,0x01,		/*   x                      x	*/
	0xc0,0x00,0x01,		/*   xx                     x   */
	0x7f,0xff,0xff		/*    xxxxxxxxxxxxxxxxxxxxxxx	*/
};
#if 0
char bigRemoteIconData[] =		   /*	000011112222333344445555   */
{
	0x00,0x00,0x00,		/*                              */
	0x00,0x00,0x00,		/*                              */
	0x7f,0xff,0xfc,		/*    xxxxxxxxxxxxxxxxxxxxx     */
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06, 	/*	  x 				  xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x7f,0xff,0xfe,		/*    xxxxxxxxxxxxxxxxxxxxxx	*/
	0x3f,0xff,0xfe,		/*     xxxxxxxxxxxxxxxxxxxxx	*/
	0x00,0x00,0x00		/*                              */
};

char bigRemoteIconDataInvert[] =	   /*	000011112222333344445555   */
{
	0x00,0x00,0x00,		/*                              */
	0xff,0xff,0xfe,		/*   xxxxxxxxxxxxxxxxxxxxxxx	*/
	0x80,0x00,0x03,		/*   x                     xx	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9, 	/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0xbf,0xff,0xf9,		/*   x xxxxxxxxxxxxxxxxxxx  x	*/
	0x80,0x00,0x01,		/*   x                      x	*/
	0xc0,0x00,0x01,		/*   xx                     x   */
	0x7f,0xff,0xff		/*    xxxxxxxxxxxxxxxxxxxxxxx	*/
};

#endif

char bigRemoteIconData[] =
{						/*	 000011112222333344445555	*/
	0x00,0x00,0x00,		/*                              */
	0x7f,0xff,0xfc,		/*    xxxxxxxxxxxxxxxxxxxxx     */
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x51,0x7d,0xf6, 	/*	  x x	x xxxxx	xxxxx xx	*/
	0x59,0x40,0x46,		/*	  x xx	x x		  x	  xx	*/
	0x55,0x78,0x46,		/*	  x x x x xxxx	  x	  xx	*/
	0x53,0x40,0x46,		/*	  x x  xx x		  x	  xx	*/
	0x51,0x7c,0x46,		/*	  x x	x xxxxx	  x	  xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x40,0x00,0x06,		/*    x                   xx	*/
	0x7f,0xff,0xfe,		/*    xxxxxxxxxxxxxxxxxxxxxx	*/
	0x3f,0xff,0xfe,		/*     xxxxxxxxxxxxxxxxxxxxx	*/
};

char bigRemoteIconDataInvert[] =
{						/*	 000011112222333344445555	*/
	0xff,0xff,0xfe,		/*	 xxxxxxxxxxxxxxxxxxxxxxx	*/
	0x80,0x00,0x03,		/*	 x					   xx	*/
	0xbf,0xff,0xf9,		/*	 x xxxxxxxxxxxxxxxxxxx	x	*/
	0xbf,0xff,0xf9,		/*	 x xxxxxxxxxxxxxxxxxxx	x	*/
	0xae,0x82,0x09, 	/*	 x x xxx x	   x	 x	x	*/
	0xa6,0xbf,0xb9,		/*	 x x  xx x xxxxxxx xxx	x	*/
	0xaa,0x87,0xb9,		/*	 x x x x x	  xxxx xxx	x	*/
	0xac,0xbf,0xb9,		/*	 x x xx  x xxxxxxx xxx	x	*/
	0xae,0x83,0xb9,		/*	 x x xxx x	   xxx xxx	x	*/
	0xbf,0xff,0xf9,		/*	 x xxxxxxxxxxxxxxxxxxx	x	*/
	0xbf,0xff,0xf9,		/*	 x xxxxxxxxxxxxxxxxxxx	x	*/
	0x80,0x00,0x01,		/*	 x						x	*/
	0xc0,0x00,0x01,		/*	 xx 					x	*/
	0x7f,0xff,0xff		/*	  xxxxxxxxxxxxxxxxxxxxxxx	*/
};

char bigRamDriveIconData[] =
{
						/*	000011112222333344445555	*/
	0x1B,0x6D,0xB6,		/*	   xx xx xx xx xx xx xx 	*/
	0x3f,0xff,0xfe,		/*	  xxxxxxxxxxxxxxxxxxxxx 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x27,0x19,0x12,		/*	  x  xxx   xx  x   x  x 	*/
	0x24,0xA5,0xB2,		/*	  x  x	x x  x xx xx  x 	*/
	0x27,0xBD,0x52,		/*	  x  xxxx xxxx x x x  x 	*/
	0x25,0x25,0x12,		/*	  x  x x  x  x x   x  x 	*/
	0x24,0xA5,0x12,		/*	  x  x	x x  x x   x  x 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x3f,0xff,0xfe,		/*	  xxxxxxxxxxxxxxxxxxxxx 	*/
	0x1B,0x6D,0xB6,		/*	   xx xx xx xx xx xx xx 	*/
	0x00,0x00,0x00		/*								*/
};

char bigRamDriveIconDataInvert[] =
{						/*	000011112222333344445555   */
	0x3f,0xff,0xfe, 	/*	  xxxxxxxxxxxxxxxxxxxxx    */
	0x64,0x92,0x49, 	/*	 xx  x	x  x  x  x	x  x   */
	0x40,0x00,0x01, 	/*	 x					   x   */
	0x5f,0xff,0xfd, 	/*	 x xxxxxxxxxxxxxxxxxxx x   */
	0x58,0xe6,0xed, 	/*	 x xx	xxx  xx xxx xx x   */
	0x5b,0x5a,0x4d, 	/*	 x xx xx x xx x  x	xx x   */
	0x58,0x42,0xad, 	/*	 x xx	 x	  x x x xx x   */
	0x5a,0xda,0xed, 	/*	 x xx x xx xx x xxx xx x   */
	0x5b,0x5a,0xed, 	/*	 x xx xx x xx x xxx xx x   */
	0x5f,0xff,0xfd, 	/*	 x xxxxxxxxxxxxxxxxxxx x   */
	0x5f,0xff,0xfd, 	/*	 x xxxxxxxxxxxxxxxxxxx x   */
	0x40,0x00,0x01, 	/*	 x					   x   */
	0x64,0x92,0x49, 	/*	 xx  x	x  x  x  x	x  x   */
	0x3f,0xff,0xfe, 	/*	  xxxxxxxxxxxxxxxxxxxxx    */
};

char smallRamDriveIconData[] =
{
						/*	000011112222333344445555	*/
	0x3f,0xff,0xfe,		/*	  xxxxxxxxxxxxxxxxxxxxx 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x27,0x19,0x12,		/*	  x  xxx   xx  x   x  x 	*/
	0x24,0xA5,0xB2,		/*	  x  x	x x  x xx xx  x 	*/
	0x27,0xBD,0x52,		/*	  x  xxxx xxxx x x x  x 	*/
	0x25,0x25,0x12,		/*	  x  x x  x  x x   x  x 	*/
	0x20,0x00,0x02,		/*	  x 				  x 	*/
	0x3f,0xff,0xfe,		/*	  xxxxxxxxxxxxxxxxxxxxx 	*/

};

char smallRamDriveIconDataInvert[] =
{						/*	000011112222333344445555   */
	0x7f,0xff,0xff, 	/*	 xxxxxxxxxxxxxxxxxxxxxxx   */
	0x5f,0xff,0xfd, 	/*	 x xxxxxxxxxxxxxxxxxxx x   */
	0x58,0xe6,0xed, 	/*	 x xx	xxx  xx xxx xx x   */
	0x5b,0x5a,0x4d, 	/*	 x xx xx x xx x  x	xx x   */
	0x58,0x42,0xad, 	/*	 x xx	 x	  x x x xx x   */
	0x5a,0xda,0xed, 	/*	 x xx x xx xx x xxx xx x   */
	0x5f,0xff,0xfd, 	/*	 x xxxxxxxxxxxxxxxxxxx x   */
	0x7f,0xff,0xff, 	/*	 xxxxxxxxxxxxxxxxxxxxxxx   */

};


char bigCDRomIconData[] =
{				/*   000011112222333344445555	*/
	0x00,0x00,0x00,		/*                              */
	0x07,0xff,0xe0, 	/*	  xxxxxxxxxxxxxx	 */
	0x18,0x00,0x18, 	/*	xx		xx	 */
	0x21,0xc7,0x84, 	/*     x    xxx   xxxx	  x	 */
	0x22,0x24,0x44, 	/*     x   x   x  x   x   x	 */
	0x42,0x04,0x22, 	/*    x    x	  x    x   x	 */
	0x42,0x04,0x22, 	/*    x    x	  x    x   x	 */
	0x42,0x04,0x22, 	/*    x    x	  x    x   x	 */
	0x22,0x24,0x44, 	/*     x   x   x  x   x   x	 */
	0x21,0xc7,0x84, 	/*     x    xxx   xxxx	  x	 */
	0x18,0x00,0x18, 	/*	xx		xx	 */
	0x07,0xff,0xe0, 	/*	  xxxxxxxxxxxxxx	 */
	0x00,0x00,0x00		/*                              */
};

char bigCDRomIconDataInvert[] =
{				/*   000011112222333344445555	*/

	0x07,0xff,0xe0, 	/*	  xxxxxxxxxxxxxx	   */
	0x18,0x00,0x18, 	/*	xx		xx	 */
	0x27,0xff,0xe4, 	/*     x  xxxxxxxxxxxxxx  x	 */
	0x5e,0x38,0x7A, 	/*    x xxxx   xxx    xxxx x	 */
	0x5d,0xdb,0xba, 	/*    x xxx xxx xx xxx xxx x	 */
	0xbd,0xfb,0xdd, 	/*   x xxxx xxxxxx xxxx xxx x	 */
	0xbd,0xfb,0xdd, 	/*   x xxxx xxxxxx xxxx xxx x	 */
	0xbd,0xfb,0xdd, 	/*   x xxxx xxxxxx xxxx xxx x	 */
	0x5d,0xdb,0xba, 	/*    x xxx xxx xx xxx xxx x	 */
	0x5e,0x38,0x7A, 	/*    x xxxx   xxx    xxxx x	 */
	0x27,0xff,0xe4, 	/*     x  xxxxxxxxxxxxxx  x	 */
	0x18,0x00,0x18, 	/*	xx		xx	 */
	0x07,0xff,0xe0		/*	  xxxxxxxxxxxxxx	   */
};

char smallCDRomIconData[] =
{				/*   000011112222333344445555	*/
	0x18,0x00,0x18, 	/*	xx		xx	 */
	0x21,0xc7,0x84, 	/*     x    xxx   xxxx	  x	 */
	0x22,0x24,0x44, 	/*     x   x   x  x   x   x	 */
	0x42,0x04,0x22, 	/*    x    x	  x    x   x	 */
	0x42,0x04,0x22, 	/*    x    x	  x    x   x	 */
	0x22,0x24,0x44, 	/*     x   x   x  x   x   x	 */
	0x21,0xc7,0x84, 	/*     x    xxx   xxxx	  x	 */
	0x18,0x00,0x18		/*	xx		xx	 */
};

char smallCDRomIconDataInvert[] =
{
	0x27,0xff,0xe4, 	/*     x  xxxxxxxxxxxxxx  x	 */
	0x5e,0x38,0x7A, 	/*    x xxxx   xxx    xxxx x	 */
	0x5d,0xdb,0xba, 	/*    x xxx xxx xx xxx xxx x	 */
	0xbd,0xfb,0xdd, 	/*   x xxxx xxxxxx xxxx xxx x	 */
	0xbd,0xfb,0xdd, 	/*   x xxxx xxxxxx xxxx xxx x	 */
	0x5d,0xdb,0xba, 	/*    x xxx xxx xx xxx xxx x	 */
	0x5e,0x38,0x7A, 	/*    x xxxx   xxx    xxxx x	 */
	0x27,0xff,0xe4		/*     x  xxxxxxxxxxxxxx  x	 */
};


struct BITMAP  bigProgManIcon =
{
	bigProgManIconData,
	3,
	0, 0, 24, 13
};
struct BITMAP  bigProgManIconInvert =
{
	bigProgManIconInvertData,
	3,
	0, 0, 24, 14
};

struct BITMAP  smallProgManIcon =
{
	smallProgManIconData,
	3,
	0, 0, 24, 8
};
struct BITMAP  smallProgManIconInvert =
{
	smallProgManIconInvertData,
	3,
	0, 0, 24, 8
};




struct BITMAP  bigUpArrow =
{
    bigUpArrowData,
    2,
    0,0,16,13		 /* left,top,right,bottom*/
};

struct BITMAP  bigDownArrow =
{
    bigDownArrowData,
    2,
    0,0,16,13		 /* left,top,right,bottom*/
};

struct BITMAP  bigFileIcon =
{
    bigFileIconData,
    3,
    0,0,24,13		 /* left,top,right,bottom*/
};

struct BITMAP  bigFileIconInvert =
{
    bigFileIconDataInvert,
    3,
    0,0,24,13		 /* left,top,right,bottom*/
};

struct BITMAP  bigProgramIcon =
{
    bigProgramIconData,
    3,
    0,0,24,13		 /* left,top,right,bottom*/
};

struct BITMAP  bigProgramIconInvert =
{
    bigProgramIconDataInvert,
    3,
    0,0,24,14		 /* left,top,right,bottom*/
};

struct BITMAP  bigDirExpansionIcon =
{
	bigDirExpansionIconData,
    3,
	0,0,24,15		 /* left,top,right,bottom*/
};

struct BITMAP  bigDirCollapseIcon =
{
	bigDirCollapseIconData,
    3,
	0,0,24,15		 /* left,top,right,bottom*/
};

struct BITMAP  bigDirNoZoomIcon =
{
	bigDirNoZoomIconData,
    3,
	0,0,24,15		 /* left,top,right,bottom*/
};

struct BITMAP bigFloppyIcon =
{
    bigFloppyIconData,
    3,
	0, 0, 24, 13	/* l, t, r, b */
};

struct BITMAP bigFloppyIconInvert =
{
    bigFloppyIconDataInvert,
    3,
	0, 0, 24, 14	/* l, t, r, b */
};

struct BITMAP bigHDIcon =
{
    bigHDIconData,
    3,
    0, 0, 24, 13	/* l, t, r, b */
};

struct BITMAP bigHDIconInvert =
{
    bigHDIconDataInvert,
    3,
    0, 0, 24, 14	/* l, t, r, b */
};

struct BITMAP bigRemoteIcon =
{
    bigRemoteIconData,
    3,
    0, 0, 24, 13	/* l, t, r, b */
};

struct BITMAP bigRemoteIconInvert =
{
    bigRemoteIconDataInvert,
    3,
    0, 0, 24, 14	/* l, t, r, b */
};

struct BITMAP bigRamDriveIcon =
{
	bigRamDriveIconData,
	3,
	0, 0, 24, 14	/* l, t, r, b */
};

struct BITMAP bigRamDriveIconInvert =
{
	bigRamDriveIconDataInvert,
	3,
	0, 0, 24, 14	/* l, t, r, b */
};

struct BITMAP bigCDRomIcon =
{
	bigCDRomIconData,
    3,
	0, 0, 24, 13	/* l, t, r, b */
};

struct BITMAP bigCDRomIconInvert =
{
	bigCDRomIconDataInvert,
    3,
	0, 0, 24, 13	/* l, t, r, b */
};


struct BITMAP  bigRadioButtonUnSel =
{
	bigRadioButtonUnSelData,
	2,
	0, 0, 16, 12
};

struct BITMAP  bigRadioButtonSel =
{
    bigRadioButtonSelData,
    2,
    0,0,16,12		 /* left,top,right,bottom*/
};


char smallRadioButtonUnSelData[] =
{
                //8421842184218421
    0x03,0xC0,  //      XXXX
    0x0C,0x30,  //    XX    XX
    0x30,0x0C,  //  XX        XX
    0x40,0x02,  // X            X
    0x30,0x0C,  //  XX        XX
    0x0C,0x30,  //    XX    XX
    0x03,0xC0   //      XXXX
};

char smallRadioButtonSelData[] =
{
                //8421842184218421
    0x03,0xC0,  //      XXXX
    0x0C,0x30,  //    XX    XX
    0x31,0x8C,  //  XX   XX   XX
    0x47,0xE2,  // X   XXXXXX   X
    0x31,0x8C,  //  XX   XX   XX
    0x0C,0x30,  //    XX    XX
    0x03,0xC0   //      XXXX
};


char smallUpArrowData[] =
{
                //8421842184218421
    0x00,0x00,  //
    0x01,0x80,  //       XX
    0x03,0xC0,  //      XXXX
    0x07,0xE0,  //     XXXXXX
    0x0F,0xF0,  //    XXXXXXXX
    0x03,0xC0,  //      XXXX
    0x03,0xC0,  //      XXXX
    0x03,0xC0   //      XXXX
};

char smallDownArrowData[] =
{
                //8421842184218421
    0x00,0x00,  //
    0x03,0xC0,  //      XXXX
    0x03,0xC0,  //      XXXX
    0x03,0xC0,  //      XXXX
    0x0F,0xF0,  //    XXXXXXXX
    0x07,0xE0,  //     XXXXXX
    0x03,0xC0,  //      XXXX
    0x01,0x80,  //       XX
};

char smallFileIconData[] =
{
                     //842184218421842184218421
    0x00,0x00,0x00,  //
    0x1F,0xFF,0xF0,  //   XXXXXXXXXXXXXXXXX
    0x10,0x00,0x28,  //   X              X X
    0x15,0x55,0x3C,  //   X X X X X X X  XXXX
    0x12,0xAA,0x84,  //   X  X X X X X X    X
    0x10,0x00,0x04,  //   X                 X
    0x1F,0xFF,0xFC,  //   XXXXXXXXXXXXXXXXXXX
    0x00,0x00,0x00,  //
};

char smallFileIconDataInvert[] =
{
                     //842184218421842184218421
    0x7F,0xFF,0xF8,  // XXXXXXXXXXXXXXXXXXXX
    0x60,0x00,0x0C,  // XX                 XX
    0x6F,0xFF,0xD6,  // XX XXXXXXXXXXXXXX X XX
    0x6A,0xAA,0xC3,  // XX X X X X X X XX    XX
    0x6D,0x55,0x7B,  // XX XX X X X X X XXXX XX
    0x6F,0xFF,0xFB,  // XX XXXXXXXXXXXXXXXXX XX
    0x60,0x00,0x03,  // XX                   XX
    0x7F,0xFF,0xFF,  // XXXXXXXXXXXXXXXXXXXXXXX
};


char smallProgramIconData[] =
{
                     //842184218421842184218421
    0x00,0x00,0x00,  //
    0x07,0xFF,0xF0,  //     XXXXXXXXXXXXXXX
    0x08,0x00,0x08,  //    X               X
    0x15,0x45,0x54,  //   X X X X   X X X X X
    0x15,0x72,0x54,  //   X X X XXX  X  X X X
    0x08,0x00,0x08,  //    X               X
    0x07,0xFF,0xF0,  //     XXXXXXXXXXXXXXX
    0x00,0x00,0x00   //
};
	
char smallProgramIconDataInvert[]=
{
                     //842184218421842184218421
    0x1F,0xFF,0xFC,  //   XXXXXXXXXXXXXXXXXXX
    0x38,0x00,0x0E,  //  XXX               XXX
    0x77,0xFF,0xF7,  // XXX XXXXXXXXXXXXXXX XXX
    0x6A,0x69,0x2B,  // XX X X  XX X  X  X X XX
    0x6A,0x63,0x2B,  // XX X X  XX   XX  X X XX
    0x77,0xFF,0xF7,  // XXX XXXXXXXXXXXXXXX XXX
    0x38,0x00,0x0E,  //  XXX               XXX
    0x1F,0xFF,0xFC   //   XXXXXXXXXXXXXXXXXXX
};

char smallDirExpansionIconData[] =
{
                     //842184218421842184218421
    0x3F,0x00,0x00,  //   xxxx
    0x40,0xff,0xf8,  // x      xxxxxxxxxxxxx
    0x7f,0x00,0x04,  // xxxxxxx             x
    0x40,0x08,0x02,  // x          x         x
    0x40,0x7f,0x02,  // x       xxxxxxx      x
    0x40,0x08,0x02,  // x          x         x
    0x40,0x00,0x02,  // x                    x
    0x7f,0xff,0xfe,  // xxxxxxxxxxxxxxxxxxxxxx
};
	
char smallDirCollapseIconData[] =
{
                     //842184218421842184218421
    0x3F,0x00,0x00,  //   xxxx
    0x40,0xff,0xf8,  // x      xxxxxxxxxxxxx
    0x7f,0x00,0x04,  // xxxxxxx             x
    0x40,0x00,0x02,  // x                    x
    0x40,0x7f,0x02,  // x       xxxxxxx      x
    0x40,0x00,0x02,  // x                    x
    0x40,0x00,0x02,  // x                    x
    0x7f,0xff,0xfe,  // xxxxxxxxxxxxxxxxxxxxxx
};

char smallDirNoZoomIconData[] =
{
                     //842184218421842184218421
    0x3F,0x00,0x00,  //  XXXXXX
    0x40,0xff,0xf8,  // X      XXXXXXXXXXXXX
    0x7f,0x00,0x04,  // XXXXXXX             X
    0x40,0x00,0x02,  // X                    X
    0x40,0x00,0x02,  // X                    X
    0x40,0x00,0x02,  // x                    x
    0x40,0x00,0x02,  // X                    X
    0x7f,0xff,0xfe,  // XXXXXXXXXXXXXXXXXXXXXX
};



char smallFloppyIconData[] =
{
                     //842184218421842184218421
    0x00,0x00,0x00,  //
    0x7f,0xff,0xfC,  // XXXXXXXXXXXXXXXXXXXXX
    0x43,0xE0,0x04,  // X    XXXXX          X
    0x4f,0xff,0xe4,  // X  XXXXXXXXXXXXXXX  X
    0x43,0xE0,0x04,  // X    XXXXX          X
    0x40,0x00,0x04,  // X                   X
    0x7f,0xff,0xfC,  // XXXXXXXXXXXXXXXXXXXXX
    0x00,0x00,0x00   //
};

char smallFloppyIconDataInvert[] =
{
                     //842184218421842184218421
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
    0x80,0x00,0x02,  //X                     X
    0xBC,0x1F,0xFA,  //X XXXX     XXXXXXXXXX X
    0xB0,0x00,0x1A,  //X XX               XX X
    0xBC,0x1F,0xFA,  //X XXXX     XXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0x80,0x00,0x02,  //X                     X
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
};

char smallHDIconData[] =
{
                     //842184218421842184218421
    0x00,0x00,0x00,  //
    0x7f,0xff,0xfc,  // xxxxxxxxxxxxxxxxxxxxx
    0x40,0x00,0x04,  // x                   x
    0x40,0x00,0x04,  // x                   x
    0x4F,0x00,0x04,  // x  XXXX             x
    0x40,0x00,0x04,  // x                   x
    0x7f,0xff,0xfC,  // xxxxxxxxxxxxxxxxxxxxx
    0x00,0x00,0x00,  //
};

char smallHDIconDataInvert[] =
{
                     //842184218421842184218421
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
    0x80,0x00,0x02,  //X                     X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0xB0,0xFF,0xFA,  //X XX    XXXXXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0x80,0x00,0x02,  //X                     X
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
};

#if 0
char smallRemoteIconData[] =
{
                     //842184218421842184218421
    0x00,0x00,0x00,  //
    0x7f,0xff,0xfc,  // xxxxxxxxxxxxxxxxxxxxx
    0x40,0x00,0x04,  // x                   x
    0x40,0x00,0x04,  // x                   x
    0x40,0x00,0x04,  // x                   x
    0x40,0x00,0x04,  // x                   x
    0x7f,0xff,0xfC,  // xxxxxxxxxxxxxxxxxxxxx
    0x00,0x00,0x00,  //
};

char smallRemoteIconDataInvert[] =
{
                     //842184218421842184218421
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
    0x80,0x00,0x02,  //X                     X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0xBF,0xFF,0xFA,  //X XXXXXXXXXXXXXXXXXXX X
    0x80,0x00,0x02,  //X                     X
    0xFF,0xFF,0xFE,  //XXXXXXXXXXXXXXXXXXXXXXX
};
#endif

char smallRemoteIconData[] =
{						/*	 000011112222333344445555	*/
	0x7f,0xff,0xfc,		/*    xxxxxxxxxxxxxxxxxxxxx     */
	0x40,0x00,0x04,		/*	  x 				  x 	*/
	0x51,0x7d,0xf4, 	/*	  x x	x xxxxx	xxxxx x 	*/
	0x59,0x40,0x44,		/*	  x xx	x x		  x	  x 	*/
	0x55,0x78,0x44,		/*	  x x x x xxxx	  x	  x 	*/
	0x53,0x40,0x44,		/*	  x x  xx x		  x	  x 	*/
	0x51,0x7c,0x44,		/*	  x x	x xxxxx	  x	  x 	*/
	0x7f,0xff,0xfe,		/*	  xxxxxxxxxxxxxxxxxxxxx 	*/
};

char smallRemoteIconDataInvert[] =
{						/*	 000011112222333344445555	*/
	0xff,0xff,0xfe,		/*	 xxxxxxxxxxxxxxxxxxxxxxx */
	0xbf,0xff,0xfa,		/*	 x xxxxxxxxxxxxxxxxxxx x	*/
	0xae,0x82,0x0a, 	/*	 x x xxx x	   x	 x x	*/
	0xa6,0xbf,0xba,		/*	 x x  xx x xxxxxxx xxx x	*/
	0xaa,0x87,0xba,		/*	 x x x x x	  xxxx xxx x	*/
	0xac,0xbf,0xba,		/*	 x x xx  x xxxxxxx xxx x	*/
	0xae,0x83,0xba,		/*	 x x xxx x	   xxx xxx x	*/
	0xff,0xff,0xfe		/*	 xxxxxxxxxxxxxxxxxxxxxxx	*/
};


struct BITMAP  smallUpArrow =
{
    smallUpArrowData,
    2,
    0,0,16,8            // left,top,right,bottom
};

struct BITMAP  smallDownArrow =
{
    smallDownArrowData,
    2,
    0,0,16,8            // left,top,right,bottom
};

struct BITMAP smallFileIcon =
{
    smallFileIconData,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallFileIconInvert =
{
    smallFileIconDataInvert,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallProgramIcon =
{
    smallProgramIconData,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallProgramIconInvert =
{
    smallProgramIconDataInvert,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallDirExpansionIcon =
{
    smallDirExpansionIconData,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallDirCollapseIcon =
{
    smallDirCollapseIconData,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP  smallDirNoZoomIcon =
{
    smallDirNoZoomIconData,
    3,
    0,0,24, 8           // left,top,right,bottom
};

struct BITMAP smallFloppyIcon =
{
    smallFloppyIconData,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallFloppyIconInvert =
{
    smallFloppyIconDataInvert,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallHDIcon =
{
    smallHDIconData,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallHDIconInvert =
{
    smallHDIconDataInvert,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallRemoteIcon =
{
    smallRemoteIconData,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallRamDriveIcon =
{
	smallRamDriveIconData,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallRamDriveIconInvert =
{
	smallRamDriveIconDataInvert,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallCDRomIcon =
{
	smallCDRomIconData,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallCDRomIconInvert =
{
	smallCDRomIconDataInvert,
    3,
    0, 0, 24,  8        // left,top,right,bottom
};

struct BITMAP smallRemoteIconInvert =
{
    smallRemoteIconDataInvert,
    3,
    0, 0, 24,  8         // left,top,right,bottom
};

struct BITMAP  smallRadioButtonUnSel =
{
    smallRadioButtonUnSelData,
    2,
    0, 0, 16,  7         // left,top,right,bottom
};

struct BITMAP  smallRadioButtonSel =
{
    smallRadioButtonSelData,
    2,
    0,0,16, 7            // left,top,right,bottom
};

#if 0
/* ZZZZZZZZZZZZZZZZZZZZZZZZZZZ Unused icons ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ */

char bigRightArrowData[]=
{
/*		  321032103232103210 */
	0x00,0x00,	/*			*/
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x40,	/*	     X	    */
    0x00,0x70,	/*	     XXX    */
    0x1F,0xFC,	/*   XXXXXXXXXXXXX  */
    0x1F,0xFE,	/*   XXXXXXXXXXXXXX */
    0x1F,0xFC,	/*   XXXXXXXXXXXXX  */
    0x00,0x70,	/*	     XXX    */
    0x00,0x40,	/*	     X	    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
};


char bigLeftArrowData[] =
{
/*		  321032103232103210  */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x01,0x00,	/*	 X	    */
    0x07,0x00,	/*     XXX	    */
    0x1F,0xFC,	/*   XXXXXXXXXXXXX  */
    0x3F,0xFC,	/*  XXXXXXXXXXXXXX  */
    0x1F,0xFC,	/*   XXXXXXXXXXXXX  */
    0x07,0x00,	/*     XXX	    */
    0x01,0x00,	/*	 X	    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
    0x00,0x00,	/*		    */
};

char bigColorLeftData[]=
{
		     /*765432107654321076543210*/
   0X3F,0xFF,0xFC,   /*  XXXXXXXXXXXXXXXXXXXX  */
   0x60,0x00,0x06,   /* XX		    XX */
   0xA0,0x40,0x05,   /*X X	X	    X X*/
   0xA0,0xC0,0x05,   /*X X     XX	    X X*/
   0xA3,0xFF,0x85,   /*X X   XXXXXXXXXXX    X X*/
   0xA7,0xFF,0x85,   /*X X  XXXXXXXXXXXX    X X*/
   0xA3,0xFF,0x85,   /*X X   XXXXXXXXXXX    X X*/
   0xA0,0xC0,0x05,   /*X X     XX	    X X*/
   0xA0,0x40,0x05,   /*X X	X	    X X*/
   0xA0,0x00,0x05,   /*X X		    X X*/
   0xBF,0xFF,0xFD,   /*X XXXXXXXXXXXXXXXXXXXX X*/
   0xA0,0x00,0x05,   /*X X		    X X*/
   0x40,0x00,0x02,   /* X		     X */
   0x3F,0xFF,0xFC    /*  XXXXXXXXXXXXXXXXXXXX  */
};

char bigColorRightData[]=
{
		     /*765432107654321076543210*/
   0X3F,0xFF,0xFC,   /*  XXXXXXXXXXXXXXXXXXXX  */
   0x60,0x00,0x06,   /* XX		    XX */
   0xA0,0x02,0x05,   /*X X	     X	    X X*/
   0xA0,0x03,0x05,   /*X X	     XX     X X*/
   0xA3,0xFF,0xC5,   /*X X   XXXXXXXXXXXX   X X*/
   0xA3,0xFF,0xE5,   /*X X   XXXXXXXXXXXXX  X X*/
   0xA3,0xFF,0xC5,   /*X X   XXXXXXXXXXXX   X X*/
   0xA0,0x03,0x05,   /*X X	     XX     X X*/
   0xA0,0x02,0x05,   /*X X	     X	    X X*/
   0xA0,0x00,0x05,   /*X X		    X X*/
   0xBF,0xFF,0xFD,   /*X XXXXXXXXXXXXXXXXXXXX X*/
   0xA0,0x00,0x05,   /*X X		    X X*/
   0x40,0x00,0x02,   /* X		     X */
   0x3F,0xFF,0xFC    /*  XXXXXXXXXXXXXXXXXXXX  */
};

char smallRightArrowData[]=
{
                //8421842184218421
    0x00,0x00,  //
    0x00,0x40,  //         X
    0x00,0x70,  //         XXX
    0x1F,0xFC,  //   XXXXXXXXXXX
    0x1F,0xFE,  //   XXXXXXXXXXXX
    0x1F,0xFC,  //   XXXXXXXXXXX
    0x00,0x70,  //         XXX
    0x00,0x40,  //         X
};


char smallLeftArrowData[] =
{
                //8421842184218421
    0x00,0x00,  //
    0x01,0x00,  //       X
    0x07,0x00,  //     XXX
    0x1F,0xFC,  //   XXXXXXXXXXX
    0x3F,0xFC,  //  XXXXXXXXXXXX
    0x1F,0xFC,  //   XXXXXXXXXXX
    0x07,0x00,  //     XXX
    0x01,0x00,  //       X
};

struct BITMAP	bigRightArrow =
{
    bigRightArrowData,
    2,
    0,0,16,14		 /* left,top,right,bottom*/
};
struct BITMAP  bigLeftArrow =
{
    bigLeftArrowData,
    2,
    0,0,16,14		 /* left,top,right,bottom*/
};

struct BITMAP  bigColorLeft=
{
    bigColorLeftData,
    3,
    0,0,24,14
};
struct BITMAP  bigColorRight=
{
    bigColorRightData,
    3,
    0,0,24,14
};

struct BITMAP  smallRightArrow =
{
    smallRightArrowData,
    2,
    0,0,16,8            // left,top,right,bottom
};

struct BITMAP  smallLeftArrow =
{
    smallLeftArrowData,
    2,
    0,0,16,8            // left,top,right,bottom
};

char bigPgDnIconData[] =	   /*  |   D   |   D   |   D   |   D	 */
{				//  32103210321032103210321032103210
	0x00,0x00,0x00,0x00,	/*				      */
	0x1F,0xFF,0xFF,0xF8,	/*     xxxxxxxxxxxxxxxxxxxxxxxxxx     */
	0x2C,0x7F,0x0F,0xF4,	/*    x xx   xxxxxxx	xxxxxxxx x    */
	0x6B,0xA3,0x76,0x36,	/*   xx x xxx x   xx xxx xx   xx xx   */
	0x6B,0x5D,0x75,0xD6,	/*   xx x xx x xxx x xxx x xxx x xx   */
	0x68,0xE1,0x75,0xD6,	/*   xx x   xxx    x xxx x xxx x xx   */
	0x6B,0xFD,0x0D,0xD6,	/*   xx x xxxxxxxx x	xx xxx x xx   */
	0x6B,0xF3,0xFF,0xF6,	/*   xx x xxxxxx  xxxxxxxxxxxxxx xx   */
	0x6F,0xFF,0xFF,0xF6,	/*   xx xxxxxxxxxxxxxxxxxxxxxxxx xx   */
	0x60,0x00,0x00,0x06,	/*   xx 			 xx   */
	0x6F,0xFF,0xFF,0xF6,	/*   xx xxxxxxxxxxxxxxxxxxxxxxxx xx   */
	0x5F,0xFF,0xFF,0xFA,	/*   x xxxxxxxxxxxxxxxxxxxxxxxxxx x   */
	0x3F,0xFF,0xFF,0xFC,	/*    xxxxxxxxxxxxxxxxxxxxxxxxxxxx    */
	0x00,0x00,0x00,0x00,	/*				     */
};

struct BITMAP  bigPgDnIcon =
{
	bigPgDnIconData,
	4,
	0, 0, 32, 14
};

char smallPgDnIconData[] =
{
                          //84218421842184218421842184218421
    0x3F,0xFF,0xFF,0xFC,  //  xxxxxxxxxxxxxxxxxxxxxxxxxxxx
    0x61,0xFF,0xC3,0xFE,  // xxx   xxxxxxxxxxx    xxxxxxxxx
    0x6E,0x8F,0xDD,0x8E,  // xx xxx x   xxxxxx xxx xx   xxx
    0x6D,0x77,0xDD,0x76,  // xx xx x xxx xxxxx xxx x xxx xx
    0x63,0x87,0xDD,0x76,  // xx   xxx    xxxxx xxx x xxx xx
    0x6F,0xF7,0xC3,0x76,  // xx xxxxxxxx xxxxx    xx xxx xx
    0x6F,0xCF,0xFF,0xFE,  // xx xxxxxx  xxxxxxxxxxxxxxxxxxx
    0x3F,0xFF,0xFF,0xFC,  //  xxxxxxxxxxxxxxxxxxxxxxxxxxxx
};

struct BITMAP  smallPgDnIcon =
{
    smallPgDnIconData,
    4,
    0, 0, 32,  8        // left,top,right,bottom
};


char bigPgUpIconData[] =	   /*  |   D   |   D   |   D   |   D	 */
{				//  32103210321032103210321032103210
	0x00,0x00,0x00,0x00,	/*				      */
	0x1F,0xFF,0xFF,0xF8,	/*     xxxxxxxxxxxxxxxxxxxxxxxxxx     */
	0x2C,0x7F,0x77,0xF4,	/*    x xx   xxxxxxx xxx xxxxxxx x    */
	0x6B,0xA3,0x76,0x36,	/*   xx x xxx x   xx xxx xx   xx xx   */
	0x6B,0x5D,0x75,0xD6,	/*   xx x xx x xxx x xxx x xxx x xx   */
	0x68,0xE1,0x75,0xB6,	/*   xx x   xxx    x xxx x xx xx xx   */
	0x6B,0xFD,0x84,0x76,	/*   xx x xxxxxxxx xx	 x   xxx xx   */
	0x6B,0xF3,0xF5,0xF6,	/*   xx x xxxxxx  xxxxxx x xxxxx xx   */
	0x6F,0xFF,0xFF,0xF6,	/*   xx xxxxxxxxxxxxxxxxxxxxxxxx xx   */
	0x60,0x00,0x00,0x06,	/*   xx 			 xx   */
	0x6F,0xFF,0xFF,0xF6,	/*   xx xxxxxxxxxxxxxxxxxxxxxxxx xx   */
	0x5F,0xFF,0xFF,0xFA,	/*   x xxxxxxxxxxxxxxxxxxxxxxxxxx x   */
	0x3F,0xFF,0xFF,0xFC,	/*    xxxxxxxxxxxxxxxxxxxxxxxxxxxx    */
	0x00,0x00,0x00,0x00,	/*				     */
};

struct BITMAP  bigPgUpIcon =
{
	bigPgUpIconData,
	4,
	0, 0, 32, 14
};

char smallPgUpIconData[] =
{
                          //84218421842184218421842184218421
    0x3F,0xFF,0xFF,0xFC,  //  xxxxxxxxxxxxxxxxxxxxxxxxxxxx
    0x61,0xFF,0xDD,0xFE,  // xxx   xxxxxxxxxxx xxx xxxxxxxx
    0x6E,0x8F,0xDD,0x8E,  // xx xxx x   xxxxxx xxx xx   xxx
    0x6D,0x77,0xDD,0x76,  // xx xx x xxx xxxxx xxx x xxx xx
    0x63,0x87,0xDD,0x76,  // xx   xxx    xxxxx xxx x xxx xx
    0x6F,0xF7,0xE1,0x0E,  // xx xxxxxxxx xxxxxx    x    xxx
    0x6F,0xCF,0xFD,0x7E,  // xx xxxxxx  xxxxxxxxxx x xxxxxx
    0x3F,0xFF,0xFF,0xFC,  //  xxxxxxxxxxxxxxxxxxxxxxxxxxxx
};

struct BITMAP  smallPgUpIcon =
{
    smallPgUpIconData,
    4,
    0, 0, 32,  8        // left,top,right,bottom
};

/* ZZZZZZZZZZZZZZZZZZZZZZZZZZZ Unused icons ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\help.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****************************************************************/
/*************************** INCLUDES ***************************/
/****************************************************************/

#include <common.h>

/* To help generate the help text, un-commnet the following line.
 * This will make the shell print the context string
 * that it is using to search in the help file.
 */
// #define    PRINTDEBUGCONTEXTSTR 1

#include <help.hs>
#include <help.sdm>

#include <filemgr.h>
#include <prot.h>
#include <text.h>

/****************************************************************/
/*************************** CONSTANTS **************************/
/****************************************************************/

typedef struct tagHelpState {
    long lHelpOffset;
    int nHelpScroll;
} HelpState;

#define MAXHELPLINE  68
#ifdef DBCS
int     FarCheckDBCSTailByte(unsigned char far *, unsigned char far *);
int     CheckDBCSTailByte(unsigned char *, unsigned char *);
#else
#define FarCheckDBCSTailByte(x,y) (FALSE)
#define CheckDBCSTailByte(x,y) (FALSE)
#endif
#define CONTEXTSTARTCHAR '!'
#define CONTEXTSTARTENDCHAR '@'
#define CONTEXTENDCHAR '@'
#define HOTLINKCHAR '~'

/* the chunksize we read help in */
#define MAXHELPCHUNK 8192
/* the maximum size for a single help entry */
#define MAXHELPSIZE 2048
#define REENTERHELP ((MAXHELPCHUNK-2*MAXHELPSIZE)/sizeof(HelpState))

#define MAXCONTEXTLEN 7 /* example: "!1DMN! " */
#define LINKEXTRA (MAXCONTEXTLEN + 4)
/* just an artificial limit so things don't get out of hand */
#define MAXCONTEXTSPERTEXT 50
char gCurContext[MAXCONTEXTLEN+1];
char gHotLink[MAXCONTEXTLEN+1];

#define PROGRAMCONTEXTOFFSET 0
#define MODECONTEXTOFFSET    1
#define MODESUBCONTEXTOFFSET 2
#define MODESUBSUBCONTEXTOFFSET 3
#define NULLCONTEXTOFFSET    4

#define CONTEXTCHARINDEX   'I'
#define CONTEXTCHARKEY       'K'
#define CONTEXTCHARBASICS  'B'
#define CONTEXTCHARCOMMANDS 'Q'
#define CONTEXTCHARPROCEDURES 'R'
#define CONTEXTCHARUSING 'U'
#define CONTEXTCHARSPECIAL 'H'

#define CONTEXTCHAROK 'O'
#define CONTEXTCHARCANCEL 'C'
#define CONTEXTCHARCOPY 'C'
#define CONTEXTCHARREORDER 'R'

#define CONTEXTCHARPROGMAN  'P'
#define CONTEXTCHARSINGLE   '1'
#define CONTEXTCHARDOUBLE   '2'
#define CONTEXTCHARSYSTEM   'Y'
#define CONTEXTCHARSEARCH   'S'
#define CONTEXTCHARVIEW     'V'
#define CONTEXTCHARTASKMAN  'T'

#define CONTEXTCHARNULL     'N'
#define CONTEXTCHARMENU     'M'
#define CONTEXTCHARDIALOG   'D'

#define INDEXMODE  0
#define KEYMODE    1
#define BASICSMODE 2
#define COMMANDSMODE 3
#define PROCEDURESMODE 4
#define USINGMODE 5
#define HELPONHELPMODE 6
#define HOTLINKMODE 7
#define REGULARHELP 8
#define EXTRABUFFER (MAXCONTEXTLEN*MAXCONTEXTSPERTEXT)
#define HOTCHAR '"'

#define NOHELPAVAIL (-1)
#define USERDEFHELP (-2)

/****************************************************************/
/*************************** GLOBALS ****************************/
/****************************************************************/

char gErrHelpId ;

int gNumHelps = -1; /* number of times help has been re-entered */
BOOL gHelpErr = FALSE; /* Gets set if we have a help error condition */
ListBoxData HelpList;
char far *gCurHelp = NULL; // we only need one of these
HelpState far *gHelpState = NULL; // we only need one of these
WORD gHelpChunk;

WORD gHelpSize;        // we only need one of these
WORD gNumHelpLines;
WORD far *gHelpLines;
TMC gCurrentTMC = tmcNull;
WORD gCWContext = 0;
WORD gCWhid = 0;
VOID *gCWpv = NULL;
char cMode[] = {
    CONTEXTCHARINDEX, CONTEXTCHARKEY, CONTEXTCHARBASICS, CONTEXTCHARCOMMANDS,
    CONTEXTCHARPROCEDURES, CONTEXTCHARUSING, CONTEXTCHARSPECIAL
} ;
WORD gSpecialMode = REGULARHELP;
int gHotLinkLine = 0; // see below

extern char gStartUpDir[];
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */
extern char userCommand[];
#define szTitle userCommand
extern BOOL fDrawItem;
extern BOOL fRedrawItem;
extern BOOL gInCopy, gInReorder;
extern char *szCurDialogCaption;
extern ListBoxData ProgramList, TaskList;
extern BOOL gTaskListEnabled;

/****************************************************************/
/*************************** FUNCTION DECLARATIONS **************/
/****************************************************************/

VOID FAR HelpBox(void);
VOID FAR KeyBox(void);
VOID FAR IndexBox(void);
VOID FAR UsingHelpBox(void);

VOID NEAR PASCAL GoNextHotLink(BOOL bOnlyInView);
VOID NEAR PASCAL GoPrevHotLink(void);

extern TOKEN Get_Focus_Item(void);

/****************************************************************/
/*************************** PRIVATE FUNCTIONS ******************/
/****************************************************************/

int PASCAL TextLineLen(char far *lpText, int nMaxLen, char cEndChar)
{
    int i, nLastWord;
    BOOL bSpace = FALSE;
#ifdef DBCS
    char far *lpStartText = lpText;
#endif

    if(*lpText==cEndChar && (!cEndChar || *(lpText+1)==cEndChar))
	return(-1);

    for(i=0, nLastWord=0; ; ++i, ++lpText) {
	if(*lpText==cEndChar && !FarCheckDBCSTailByte(lpStartText, lpText)
		&& (!cEndChar || *(lpText+1)==cEndChar))
	    return(i);

	switch(*lpText) {
	case('\n'):
	case('\r'):
	    if(!FarCheckDBCSTailByte(lpStartText, lpText))
		return(i);
	    break;

#ifndef JAPAN
	case(' '):
	    if(!FarCheckDBCSTailByte(lpStartText, lpText))
		bSpace = TRUE;
	    break;
#endif

	case('^'):
	    if(gHelpState[gNumHelps].lHelpOffset==USERDEFHELP &&
		    !FarCheckDBCSTailByte(lpStartText, lpText) &&
		    (*(lpText+1)=='m' || *(lpText+1)=='M')) {
		*lpText     = '\r';
		*(lpText+1) = '\n';
		return(i);
	    }
/* NOTE: we fall through here */
	default:
	    if(bSpace) {
		bSpace = FALSE;
		nLastWord = i;
	    }
	    break;
	}

	if(i >= nMaxLen-1) {
	    if(bSpace) {
		for(++lpText, ++i; *lpText==' '; ++lpText, ++i)
		    /* skip trailing spaces */ ;
		return(i);
	    }

	    if(!nLastWord && FarCheckDBCSTailByte(lpStartText, lpText))
		return(i-1);

	    return(nLastWord ? nLastWord : i);
	}
    }
}

VOID NEAR PASCAL Get_Ith_Help_Line(char *line, int ith)
{
    int i, nLineLen;
    char far *lpHelpText = gCurHelp + gHelpLines[-ith];

/* Fill the buffer to the newline or MAXHELPLINE chars */
    nLineLen = TextLineLen(lpHelpText, MAXHELPLINE, CONTEXTENDCHAR);
    if(nLineLen > MAXHELPLINE-1)
	nLineLen = MAXHELPLINE - 1;
    for(i=nLineLen; i>0; --i)
	*line++ = *lpHelpText++;

/* Pad the rest with spaces */
    for(i=nLineLen; i<MAXHELPLINE; ++i)
	*line++ = ' ';
    *line = '\0';
}

VOID NEAR PASCAL SetUpCurHelp(void)
{
    int i = 0, j, nLineLen;
    char far *lpHelpText = gCurHelp;

    gNumHelpLines = 0;

    if(gHelpState[gNumHelps].lHelpOffset == NOHELPAVAIL ||
	    (nLineLen=TextLineLen(lpHelpText, MAXHELPLINE, CONTEXTENDCHAR))<0) {
	FormStringWithoutPlaceHolders(lpHelpText, "\n%1@@",
		(char far *)szNoHelpAvail);
	nLineLen = 0;
    }

    for( ; i<nLineLen; ++i)
	szTitle[i] = *lpHelpText++;
    szTitle[i] = '\0';
    SetTitle(&HelpList, szTitle);

    while(*lpHelpText=='\n' || *lpHelpText=='\r') {
	++i;
	++lpHelpText;
    }

    for( ; ; ++gNumHelpLines) {
	gHelpLines[-gNumHelpLines] = i;
	nLineLen = TextLineLen(lpHelpText, MAXHELPLINE, CONTEXTENDCHAR);
	if(nLineLen < 0)
	    break;

	i += nLineLen;
	lpHelpText += nLineLen;
	if(i >= (gHelpSize-gNumHelpLines*sizeof(WORD)))
	    goto FillWithBlank;

	for( ; *lpHelpText=='\r'; ++i, ++lpHelpText)
	    /* do nothing */ ;
	if(*lpHelpText == '\n') {
	    ++i;
	    ++lpHelpText;
	}
    }

/* Add the end of help marker */
    *lpHelpText++ = '\n';
    gHelpLines[-gNumHelpLines++] = ++i;
    nLineLen = strlen(szHelpEnd);
    for(j=(MAXHELPLINE-nLineLen)/2, i+=j+nLineLen; j>0; --j)
	*lpHelpText++ = ' ';
    RepeatMove(lpHelpText, szHelpEnd, nLineLen);
    lpHelpText += nLineLen;

/* Fill the rest of the gHelpLines array with blank lines */
FillWithBlank:
    *lpHelpText = '\r';
    for( ; gNumHelpLines<HelpList.numlinesonscreen; ++gNumHelpLines)
	gHelpLines[-gNumHelpLines] = i;

    GoNextHotLink(FALSE);
    HelpList.focusitem = gHotLinkLine;
}

VOID NEAR PASCAL Free_Help(void)
{
    if(gHelpState)
	FreeWorkFar(gHelpState);

    gHelpState = NULL;
}

VOID NEAR PASCAL Get_Current_Context(void)
{
    BOOL bNull;
    char topcontextchar;
    char contextchar;
    char subcontextchar;
    char subsubcontextchar;

    topcontextchar = ' ';
    contextchar = ' ';
    subcontextchar = ' ';
    subsubcontextchar = ' ';

    bNull = !(gCWContext==hemMenu || gCWContext==hemMenuItem ||
	    gCWContext==hemDialog);

    if(gSpecialMode < HOTLINKMODE) {
	topcontextchar = cMode[gSpecialMode];
    } else if(gSpecialMode == HOTLINKMODE) {
	topcontextchar = gHotLink[1];
/* Does the tail byte check need to be done?
 * I don't think we allow non-ASCII context strings
 */
	if(gHotLink[2] != HOTLINKCHAR ||
		CheckDBCSTailByte(gHotLink,&gHotLink[2])) {
	    contextchar = gHotLink[2];
	    if(gHotLink[3] != HOTLINKCHAR ||
		    CheckDBCSTailByte(gHotLink,&gHotLink[3])) {
		subcontextchar = gHotLink[3];
		if(gHotLink[4] != HOTLINKCHAR ||
			CheckDBCSTailByte(gHotLink,&gHotLink[4])) {
		    subsubcontextchar = gHotLink[4];
		}
	    }
	}
    } else {
	if(m_fPerformingViewFile())
	    topcontextchar = CONTEXTCHARVIEW;
	else if(!glob.InFileMgr || glob.TreeMode==TR_SHARE) {
/* We are either in program manager view, or shared mode */
	    if(ProgramList.hasglobalfocus) {
		if(!bNull)
		    topcontextchar = CONTEXTCHARPROGMAN;
		else if(gInCopy) {
		    topcontextchar = CONTEXTCHARSPECIAL;
		    contextchar = CONTEXTCHARCOPY;
		    goto ContextFound;
		} else if(gInReorder) {
		    topcontextchar = CONTEXTCHARSPECIAL;
		    contextchar = CONTEXTCHARREORDER;
		    goto ContextFound;
		} else
		    topcontextchar = CONTEXTCHARPROGMAN;
	    } else if(gTaskListEnabled && TaskList.hasglobalfocus && bNull)
		topcontextchar = CONTEXTCHARTASKMAN;
	    else
		topcontextchar = CONTEXTCHARSINGLE;
	} else {
	    switch(glob.TreeMode) {
	    case TR_SEARCH:
		topcontextchar = CONTEXTCHARSEARCH;
		break;

	    case TR_DOUBLE:
		topcontextchar = CONTEXTCHARDOUBLE;
		break;

	    case TR_SYSTEM:
		topcontextchar = CONTEXTCHARSYSTEM;
		break;

	    /* case TR_SINGLE: */
	    default:
		topcontextchar = CONTEXTCHARSINGLE;
		break;
	    }
	}

	switch(gCWContext) {
	case hemMenu:
	case hemMenuItem:
	    contextchar = CONTEXTCHARMENU;
	    subcontextchar = ((((unsigned char )gCWhid)&0x0F0) >> 4) + 'A';
	    subsubcontextchar = (((unsigned char) gCWhid)&0x0F) + 'A';
	    break;

	case hemDialog:
	    if(gCurrentTMC == tmcOK) {
		topcontextchar = CONTEXTCHAROK;
	    } else if(gCurrentTMC == tmcCancel) {
		topcontextchar = CONTEXTCHARCANCEL;
	    } else {
		contextchar = CONTEXTCHARDIALOG;
		subcontextchar = (char) gCWhid;
		if(subcontextchar == hidERR) {
		    subsubcontextchar = (char) gErrHelpId ;
		} else {
		    subsubcontextchar = (char) (gCurrentTMC+'A') ;
		}
	    }
	    break;

	default:
	    contextchar = CONTEXTCHARNULL;
	}
    }

ContextFound:

	 /* HACK!!! The help file does not have the context strings for all
	  * topics in SEARCH mode. Hence we now modify all the SEARCH context
	  * strings except the "SN" (default search help) to make it look
	  * like SINGLE tree mode.
	  */
	 if ( (topcontextchar == CONTEXTCHARSEARCH) &&
		   (contextchar != CONTEXTCHARNULL)
		 )
	 {
		topcontextchar = CONTEXTCHARSINGLE ;
	 }

    gCurContext[PROGRAMCONTEXTOFFSET] = topcontextchar;
    gCurContext[MODECONTEXTOFFSET] = contextchar;
    gCurContext[MODESUBCONTEXTOFFSET] = subcontextchar;
    gCurContext[MODESUBSUBCONTEXTOFFSET] = subsubcontextchar;
    gCurContext[NULLCONTEXTOFFSET] = 0;

    gSpecialMode = REGULARHELP;

#ifdef PRINTDEBUGCONTEXTSTR
    gHelpErr = TRUE;
    ShellMessageBox("Context string:", gCurContext);
    gHelpErr = FALSE;
#endif
}

int Get_Cur_Help(void)
{
    int i, k;
    char far *gHelpText;

    for(i=0, gHelpText=gCurHelp; i<gHelpSize; ++i, ++gHelpText) {
/*
 * Find the correct text for this context.
 * the format is !context!...@text...%
 */
	if(*gHelpText==CONTEXTSTARTCHAR &&
		!FarCheckDBCSTailByte(gCurHelp, gHelpText)) {
/* we have found a '!', now see if the string following
 * is the correct context...
 */
	    for(k=0, ++i, ++gHelpText; *gHelpText==gCurContext[k];
		    ++k, ++i, ++gHelpText)
		if(k > MAXCONTEXTLEN)
/* something is wrong with the help file, so
 * pretend we can't find the context string
 */
		    return(-1);

	    if(*gHelpText == CONTEXTSTARTCHAR) {
		if(gCurContext[k] == ' ' || gCurContext[k] == '\0') {
/* We found the context string; now look for the @ */
		    for(k=0; *gHelpText!=CONTEXTSTARTENDCHAR ||
			    FarCheckDBCSTailByte(gCurHelp, gHelpText);
			    ++k, ++i, ++gHelpText)
			if(k > EXTRABUFFER-MAXCONTEXTLEN)
/* something is wrong with the help file, so
 * pretend we can't find the context string
 */
			    return(-1);

/* We found the string and the '@' char */
		    return(i);
		}

/* If we get to here, we found a trailing '!' without
 * finding the whole context string, so let's try again
 */
		--i;
		--gHelpText;
	    }
	}
    }

/* We didn't find the string */
    return(-1);
}

VOID NEAR PASCAL SetUpUserHelp(void)
{
    char far *szHelpTitle;
    char far *szHelpText;
    TOKEN tkTemp, tkTemp1;

    gHelpSize = gHelpChunk;

    if((tkTemp=Get_Focus_Item()) < 0)
	goto Error1;
    else if(tkTemp==TK_PROGRAMSTARTER) {
	szHelpTitle = szMainGroup;
	szHelpText = szMainHelp;
    } else if((tkTemp=Get_Symbol_Value(Token_To_Symbol(tkTemp))) >= 0) {
	tkTemp1 = Get_KeyWord_Assignment(tkTemp, TK_TITLE);
	szHelpTitle = tkTemp1>=0 ? Get_Token_Identifier(tkTemp1) : (char far *)szNoItemTitle;
	tkTemp1 = Get_KeyWord_Assignment(tkTemp, TK_HELP);
	szHelpText = tkTemp1>0 ? Get_Token_Identifier(tkTemp1) : (char far *)szNoHelpAvail;
    } else {
Error1:
	szHelpTitle = szNoItemTitle;
	szHelpText = szNoHelpAvail;
    }

    FormStringWithoutPlaceHolders(gCurHelp, szHelpFor, szHelpTitle, szHelpText);
}

BOOL NEAR PASCAL IsUserContext(void)
{
    if(gInCopy || gInReorder)
	return(FALSE);

    if(gCurContext[0] != CONTEXTCHARPROGMAN)
	return(FALSE);
    if(gCurContext[1] == CONTEXTCHARNULL) {
	if(gCurContext[2] != ' ' || gCurContext[3] != ' ')
	    return(FALSE);
    } else if(gCurContext[1] == CONTEXTCHARDIALOG) {
	if(gCurContext[2] != hidUSER)
	    return(FALSE);
    } else
	return(FALSE);

    return(TRUE);
}

BOOL Get_Help(BOOL bBack)
{
    int i, fhandle, ind;
    BOOL bNotEOF;
    BOOL bHelpFileAvail = TRUE;
    char szErrorMessage[150];

    gNumHelpLines = 0;
    if(bBack) {
	if(gHelpState[gNumHelps].lHelpOffset==NOHELPAVAIL)
	    goto Error1;
    } else
	gHelpState[gNumHelps].lHelpOffset = NOHELPAVAIL;

    if(gNumHelps==0 && (IsUserContext() ||
	    (bBack && gHelpState[0].lHelpOffset==USERDEFHELP))) {
	gHelpState[0].lHelpOffset = USERDEFHELP;
	SetUpUserHelp();
	goto Error1;
    }

    ind = gStartUpDirEnd;
#ifdef DBCS
    if(gStartUpDir[ind-1] != '\\' || CheckDBCSTailByte(gStartUpDir,&gStartUpDir[ind-1]))
#else
    if(gStartUpDir[ind-1] != '\\')
#endif
	gStartUpDir[ind++] = '\\';
    strcpy(gStartUpDir+ind, szHelpFileName);
    if(_dos_open(gStartUpDir, O_RDONLY, &fhandle)) {
	FormStringWithoutPlaceHolders(szErrorMessage, szShellFileNotFound,
		(char far *)szHelpFileName);
	gHelpErr = TRUE;
	ShellMessageBox(szHelpErrTitle, szErrorMessage);
	gHelpErr = FALSE;
	bHelpFileAvail = FALSE;
	goto Error2;
    }

    if(bBack)
	goto FoundOffset;
	
/* initially read in the first EXTRABUFFER bytes */
    if(_dos_read(fhandle, gCurHelp, EXTRABUFFER, (unsigned *)&gHelpSize))
	goto Error3;

/* Fill in the rest of the buffer */
    for(bNotEOF=TRUE, gHelpState[gNumHelps].lHelpOffset=0;
	    bNotEOF && !_dos_read(fhandle, gCurHelp+EXTRABUFFER,
	    gHelpChunk, (unsigned *)&gHelpSize);
	    gHelpState[gNumHelps].lHelpOffset+=gHelpChunk) {
/* We look for the context string only in the first part of the buffer,
   until we hit EOF, when we'll look at the whole buffer.  This is so
   that if we find a context string, we can be sure that the whole help
   text is already in the buffer */
	if(gHelpSize < gHelpChunk) {
	    gHelpSize += EXTRABUFFER;
	    bNotEOF = FALSE;
	}

	if((i=Get_Cur_Help()) >= 0) {
	    for(++i; gCurHelp[i]=='\n' || gCurHelp[i]=='\r'; ++i)
		/* skip the '@', '\n', and '\r' */ ;
	    gHelpState[gNumHelps].lHelpOffset += i; /* skip the '@' */
FoundOffset:
	    lseek(fhandle, gHelpState[gNumHelps].lHelpOffset, SEEK_SET);
	    if(_dos_read(fhandle, gCurHelp, gHelpChunk, (unsigned *)&gHelpSize))
		goto Error4;
	    goto Error3; /* actually not an error */
	}

/* move the end of the buffer to the beginning */
	for(i=0; i<EXTRABUFFER; ++i)
	    gCurHelp[i] = gCurHelp[i+gHelpSize];
    }

Error4:
    gHelpState[gNumHelps].lHelpOffset = NOHELPAVAIL;
Error3:
    _dos_close(fhandle);
Error2:
    gStartUpDir[gStartUpDirEnd] = 0;
Error1:
    SetUpCurHelp();
    return(bHelpFileAvail);
}

BOOL FindHotLinks(char *outputline, int *hotstart, int *hotend,
	int *hotcontextstart, int *hotcontextend)
{
    int i;

/* Look for the beginning of a hot string */
    for(i=0; outputline[i]!=HOTCHAR ||
	    CheckDBCSTailByte(outputline,&outputline[i]); ++i)
	if(i >= MAXHELPLINE)
	    goto NotFound;
    *hotstart = i;

/* Look for the end of the hot string */
    for(++i; outputline[i]!=HOTCHAR ||
	    CheckDBCSTailByte(outputline,&outputline[i]); ++i)
	if(i >= MAXHELPLINE)
	    goto NotFound;
/* Look for the context string immediately following */
    if(outputline[i+1] != HOTLINKCHAR ||
	    CheckDBCSTailByte(outputline,&outputline[i+1]))
	goto NotFound;
    *hotend = i;
    *hotcontextstart = ++i;

/* Look for the end of the context string */
    for(++i; outputline[i]!=HOTLINKCHAR ||
	    CheckDBCSTailByte(outputline,&outputline[i]); ++i)
	if(i >= MAXHELPLINE)
	    goto NotFound;
    *hotcontextend = i;

    return(TRUE);
NotFound:
    *hotstart = -1;
    *hotend = -1;
    *hotcontextstart = -1;
    *hotcontextend = -1;
    return(FALSE);
}

WORD PASCAL ListProcHelpList(WORD tmm, char *sz, WORD isz, TMC tmc,
	WORD x, WORD y, WORD bArg)
{
    RX xval;
    char temp[MAXHELPLINE+LINKEXTRA+3];
    int hotstart, hotend, hotcontextstart, hotcontextend;
    ISA color;
    int i,j;

    UnReferenced(sz);
    UnReferenced(tmc);
    UnReferenced(x);

    xval = Get_List_Rect(&HelpList).axLeft;
    switch(tmm) {
    case tmmCount:
	return(gNumHelpLines);
	break;

    case tmmSetFocus:
	break;

    case tmmSelect:
	break;

    case tmmActivate:
	Get_Ith_Help_Line(temp, isz);
	if(FindHotLinks(temp, &hotstart, &hotend,
		&hotcontextstart, &hotcontextend)) {
	    for(j=0, i=hotcontextstart; i<=hotcontextend; ++j, ++i)
		gHotLink[j] = temp[i];
	    gHotLink[j] = 0;
	    gSpecialMode = HOTLINKMODE;
	    HelpBox();
	}
	break;

    case tmmGetItemString:
	if(isz < gNumHelpLines) {
	    Get_Ith_Help_Line(temp, isz);

	    if(FindHotLinks(temp, &hotstart, &hotend,
		    &hotcontextstart, &hotcontextend)) {
		for(i=hotstart+1; temp[i]==' '; ++i) ;
		RepeatMove(sz, temp+i, hotend-i);
		*(sz+hotend-i) = '\0';
	    } else
		*sz = '\0';
	}else
	{
		*sz = 0;
	}
	break;

    case tmmDrawItem:
	if(isz < gNumHelpLines) {
	    *temp = ' ';
	    Get_Ith_Help_Line(temp+1, isz);

	    if(FindHotLinks(temp, &hotstart, &hotend,
		    &hotcontextstart, &hotcontextend)) {
/* Put enough spaces at the end of the string so the printable part is the
   same length as the original string */
		i = MAXHELPLINE + 3 + hotcontextend - hotcontextstart;
		temp[i] = '\0';
		for(--i; i>=MAXHELPLINE; --i)
		    temp[i] = ' ';

		if(bArg)
		    gHotLinkLine = isz;

		color = (ISA)(bArg ? isaHilite : isaHotLink) ;
		TextOut(HelpList.pwd, (RX)xval+1, (RY)y,
			temp, hotstart, isaDialogBox);
		TextOut(HelpList.pwd, (RX)xval+1+hotstart, (RY)y,
			temp+hotstart+1, hotend-hotstart-1, color);
		TextOut(HelpList.pwd, (RX)xval+hotend, (RY)y,
			temp+hotcontextend+1, -1, isaDialogBox);
		DrawFocusMarker(HelpList.pwd, xval+1, (RY) y,
			HelpList.pwd->arcWindow.axLeft+xval+1+hotstart,
			HelpList.pwd->arcWindow.ayTop +y, hotend-hotstart-1,
			bArg & TF_ISFOCUS, FALSE,
			(ISA) (gisgraph ? isaHilite : isaDialogBox));
	    } else {
		TextOut(HelpList.pwd, (RX)xval+1,(RY)y,
			temp, -1, isaDialogBox);
	    }
	}
	break;

    default:
	break;
    }

    return TRUE;
}

VOID NEAR PASCAL GoNextHotLink(BOOL bOnlyInView)
{
    char temp[MAXHELPLINE+2];
    int i, maxLine, minLine;
    int hotstart, hotend, hotcontextstart, hotcontextend;

    if(bOnlyInView) {
	minLine = gHotLinkLine + 1;
	if(minLine < HelpList.numlinesscrolled)
	    minLine = HelpList.numlinesscrolled;

	maxLine = HelpList.numlinesscrolled + HelpList.numlinesonscreen;
	if(maxLine > gNumHelpLines)
	    maxLine = gNumHelpLines;
    } else {
	minLine = 0;
	maxLine = gNumHelpLines;
    }

    for(i=minLine; i<maxLine; ++i) {
	Get_Ith_Help_Line(temp, i);
	if(FindHotLinks(temp, &hotstart, &hotend,
		&hotcontextstart, &hotcontextend)) {
	    gHotLinkLine = i;
	    return;
	}
    }

    gHotLinkLine = -1;
}

VOID NEAR PASCAL GoPrevHotLink(void)
{
    char temp[MAXHELPLINE+2];
    int i, maxLine, minLine;
    int hotstart, hotend, hotcontextstart, hotcontextend;

    minLine = HelpList.numlinesscrolled;
    if(gHotLinkLine < 0)
	gHotLinkLine = HelpList.numlinesscrolled + HelpList.numlinesonscreen;

    maxLine = HelpList.numlinesscrolled + HelpList.numlinesonscreen;
    if(maxLine > gHotLinkLine - 1)
	maxLine = gHotLinkLine - 1;

    for(i=maxLine; i>=minLine; --i) {
	Get_Ith_Help_Line(temp, i);
	if(FindHotLinks(temp, &hotstart, &hotend,
		&hotcontextstart, &hotcontextend)) {
	    gHotLinkLine = i;
	    return;
	}
    }

    gHotLinkLine = -1;
}

LONG FAR PASCAL Pfnhelplist(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    UnReferenced(pwnd);
    UnReferenced(wParam);

    switch(message) {
    case WM_CHAR:
	switch(wParam) {
	case(ESCAPE):
	    return(FALSE);
	    break;

	case('\t'):
	    if(HIWORD(LParam)&KK_SHIFT)
		GoPrevHotLink();
	    else
		GoNextHotLink(TRUE);

	    if(gHotLinkLine == -1)
		return(FALSE); //no hotlinks, so tab back to buttons
	    FocusLineChange(&HelpList, gHotLinkLine-HelpList.focusitem);
	    break;

	case(VK_UP):
	    DoScrollListBox(&HelpList, -1, TRUE);
	    break;

	case(VK_DOWN):
	    DoScrollListBox(&HelpList, 1, TRUE);
	    break;

	case(VK_PRIOR):
	    DoScrollListBox(&HelpList, 1-HelpList.numlinesonscreen, TRUE);
	    break;

	case(VK_NEXT):
	    DoScrollListBox(&HelpList, HelpList.numlinesonscreen-1, TRUE);
	    break;

	default:
	    ListKey(&HelpList, wParam, 0);
	    EnableCursor(pwnd, FALSE);
	    break;
	}
	break;

    case WM_SETFOCUS:
	gHotLinkLine = -1;
	if(gCurrentTMC == tmcCancel)
	    GoPrevHotLink();
	else
	    GoNextHotLink(TRUE);
	if(gHotLinkLine != -1)
	    FocusLineChange(&HelpList, gHotLinkLine-HelpList.focusitem);

	GlobalFocusBox(&HelpList, TRUE);
	EnableCursor(pwnd, FALSE);
	break;

    case WM_KILLFOCUS:
	GlobalFocusBox(&HelpList, FALSE);
	break;
    }

    return(TRUE);
}

extern BOOL gDialogIgnoreNextPaint;
BOOL FAR PASCAL FDlghelp(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
    PWND dwind;
    PWND lwind;
    static BOOL fListBoxInited;

    dwind = PwndParent(PwndOfListbox(tmcCancel));
    switch(dlm) {
    case dlmInit:
/* We get the context before the HelpBox'listbox button gets focus */
/* But we can't Get_Help until after the list box is OK */
	Get_Current_Context();

	fListBoxInited = FALSE ;

	SetUpDialog(tmcCancel, szHelpBoxTitle);
	SetUpButtonForGraphics(tmcCancel);
	SetUpButtonForGraphics(tmchelpBB);
	SetUpButtonForGraphics(tmchelpIB);
	SetUpButtonForGraphics(tmchelpKB);
	SetUpButtonForGraphics(tmchelpHB);

	lwind = PwndOfListbox(tmchelplist);
	SetWindowProc(lwind, Pfnhelplist);

	ListBoxInit(&HelpList, ListProcHelpList, lwind, 1, 0,
		lwind->arcWindow.ayBottom - lwind->arcWindow.ayTop - 1,
		lwind->arcWindow.axRight  - lwind->arcWindow.axLeft,
		szTitle, tmchelplist, 0, 0);
	Halt_Listbox(&HelpList);
       
	GlobalFocusBox(&HelpList, TRUE);
	Set_List_Color(&HelpList, isaDialogBox);
	break;

    case dlmIdle:
	if(!fListBoxInited) {
	    fListBoxInited = TRUE;
	    UnHalt_Listbox(&HelpList);

	    if(!Get_Help(FALSE))
		EndDlgTmc(tmcCancel);
	    SetFocusTmc(tmchelplist);
	}
	ListBoxIdle(&HelpList);
	break;

    case dlmTerm:
	gDialogIgnoreNextPaint = TRUE;
	break;

    case dlmKey:
	switch(wNew) {
	case(VK_UP):
	case(VK_DOWN):
	case(VK_PRIOR):
	case(VK_NEXT):
	case(VK_HOME):
	case(VK_END):
	    EnableCursor(dwind,FALSE);
	    SendMessage(PwndOfListbox(tmchelplist), WM_CHAR, wNew, 0L);
	    SetFocusTmc(tmchelplist);
	    break;
	}
	break;

    case dlmClientMouse:
	if(ListMouse(&HelpList, LOBYTE(wParam)-1, HIBYTE(wParam)-2, wNew, wOld))
		  {
			   if(!HelpList.hasglobalfocus)
				{
					SetFocusTmc(tmchelplist);
		ListMouse(&HelpList, LOBYTE(wParam)-1, HIBYTE(wParam)-2, wNew, wOld);
				}

		  }
	break;

    case dlmClick:
	switch(tmc) {
	case(tmchelpBB):
	    if(gNumHelps == 0) {
		gHelpErr = TRUE;
		ShellMessageBox(szHelpErrTitle, szHelpNoBack);
		gHelpErr = FALSE;
		break;
	    }
	    --gNumHelps;
	    gCurHelp -= sizeof(HelpState);
	    gHelpChunk += sizeof(HelpState);

	    Get_Help(TRUE);
	    DoScrollListBox(&HelpList, gHelpState[gNumHelps].nHelpScroll -
		    HelpList.numlinesscrolled, FALSE);
	    InsertListItem(&HelpList, 0);
	    break;

	case(tmchelpIB):
	    IndexBox();
	    break;

	case(tmchelpKB):
	    KeyBox();
	    break;

	case(tmchelpHB):
	    gSpecialMode = HELPONHELPMODE;
	    HelpBox();
	    break;
	}
    }

    return(TRUE);
}

/****************************************************************/
/*************************** PUBLIC FUNCTIONS *******************/
/****************************************************************/


VOID FAR HelpBox(void)
{
/* NUMSLICES is the number of allocations we use to save the graphics
 * behind the help dialog box. We need to do this since CW cannot
 * handle >64k. Also, we need smaller chunks so the allocations won't
 * fail when memory is fragmented.
 */
#define NUMSLICES 20
    HCABhelp h;
    BYTE FAR *graphicssave[NUMSLICES];
    WORD cbSave, gSaveTMC;
    WORD top, left, bottom, right, middle, cheight;
    int i;
    char *szSaveDialogCaption;

    if(gHelpErr || gNumHelps>=REENTERHELP-1) {
	Shell_Beep();
	return;
    }

    if(gNumHelps >= 0) {
	gHelpState[gNumHelps].nHelpScroll = HelpList.numlinesscrolled;
	++gNumHelps;
	gCurHelp += sizeof(HelpState);
	gHelpChunk -= sizeof(HelpState);

	DoScrollListBox(&HelpList, -HelpList.numlinesscrolled, FALSE);
	Get_Current_Context();
	if(Get_Help(FALSE)) {
	    InsertListItem(&HelpList, 0);
	} else {
	    --gNumHelps;
	    gCurHelp -= sizeof(HelpState);
	    gHelpChunk += sizeof(HelpState);
	    Get_Help(TRUE);
	}
    } else {
	gNumHelps = 0;
	gHelpChunk = MAXHELPCHUNK;

	Free_Help();
	if(!(gCurHelp=(char far *)LpbAllocWorkFar(gHelpChunk+EXTRABUFFER))) {
	    OutOfMemory();
	    goto Error1;
	}
	gHelpLines = (WORD far *)(gCurHelp+MAXHELPCHUNK-sizeof(WORD));
	gHelpState = (HelpState far *)gCurHelp;
	gCurHelp += sizeof(HelpState);
	gHelpChunk -= sizeof(HelpState);

	if(!(h=HcabAlloc(cabiCABhelp))) {
	    OutOfMemory();
	    goto Error2;
	}

	InitCab(h, cabiCABhelp);

	SzToCab(h, szClose, Iag(CABhelp, pszhelpEB));
	SzToCab(h, szBack, Iag(CABhelp, pszhelpBB));
	SzToCab(h, szIndex, Iag(CABhelp, pszhelpIB));
	SzToCab(h, szKeys, Iag(CABhelp, pszhelpKB));
	SzToCab(h, szHelpButton, Iag(CABhelp, pszhelpHB));

#if 1
	if(gisgraph) {
/* save behind the whole dialog in small chunks */
	    left = ((PDLG)&dlghelp)->crcDlg.x;
	    right = ((PDLG)&dlghelp)->crcDlg.x + ((PDLG)&dlghelp)->crcDlg.dx+2;
	    top = ((PDLG)&dlghelp)->crcDlg.y;
	    bottom = ((PDLG)&dlghelp)->crcDlg.y + ((PDLG)&dlghelp)->crcDlg.dy+2;
	    cheight = (bottom - top + NUMSLICES - 1)/NUMSLICES;

	    middle = top + cheight;
	    for(i=0; i<NUMSLICES && top<bottom; ++i) {
		cbSave = (right-left) * (middle-top);
		graphicssave[i] = MyLpbSaveGraphicArc(LpbAllocWorkFar, cbSave,
			(AX)left, (AY)top, (AX)right, (AY)middle);
		top = middle;
		middle += cheight;
	    }
	}
#endif
	FEnableMouse(FALSE) ;

	szSaveDialogCaption = szCurDialogCaption;
	gSaveTMC = gCurrentTMC;
	TmcDoDlg(&dlghelp, h);
	gCurrentTMC = gSaveTMC;
	szCurDialogCaption = szSaveDialogCaption;

#if 1
	if(gisgraph) {
	    top = ((PDLG)&dlghelp)->crcDlg.y;

	    middle = top + cheight;
	    for(i=0; i<NUMSLICES && top<bottom; ++i) {
		if(graphicssave[i])
		    MyRestoreGraphicArc(FreeWorkFar, (AX)left, (AY)top,
			    (AX)right, (AY)middle, graphicssave[i]);
		top = middle;
		middle += cheight;
	    }
	}
#endif
#if 0
			InitIconCache();
			if(glob.InFileMgr)
				RefreshFMScreen(FALSE);
			else
				 RefreshStartPrograms();

#endif
#if 1
		  /* Following is code to re-draw dialogs behing help dialog boxes */
		  /* Invariably we run out of memory in this case to save graphics */

			   gDialogIgnoreNextPaint = FALSE;
		  if (gCWContext == hemDialog)
		  {
				// DrawWindow(NULL) ;
				fDrawItem = TRUE;
				fRedrawItem = FALSE;

				DrawWindow(PwndParent(PwndOfTmc(tmcCancel))) ;
		  }


#endif

	FreeCab(h);
Error2:
	Free_Help();
Error1:
	gNumHelps = -1;
	gSpecialMode = REGULARHELP;
    }
}

VOID FAR IndexBox(void)
{
    gSpecialMode = INDEXMODE;
    HelpBox();
}

VOID FAR KeyBox(void)
{
    gSpecialMode = KEYMODE;
    HelpBox();
}

VOID FAR BasicsBox(void)
{
    gSpecialMode = BASICSMODE;
    HelpBox();
}

VOID FAR CommandsBox(void)
{
    gSpecialMode = COMMANDSMODE;
    HelpBox();
}

VOID FAR ProceduresBox(void)
{
    gSpecialMode = PROCEDURESMODE;
    HelpBox();
}

VOID FAR UsingHelpBox(void)
{
    gSpecialMode = USINGMODE;
    HelpBox();
}

BOOL gfDisplayDelayedHelp = FALSE ;

void ClearHelpContext(void)
{
	gCWContext = 0;
	gCWhid = 0;
	gCWpv = NULL;
}

/*
 * this is CW's entry point to help
 */
VOID FAR PASCAL Help(WORD hem, WORD hid,VOID *pv,WORD kk)
{
/* The #if 0 code below was needed before because we could have the Help
 * dialog come up even when the menu was popped down. I changed this. We
 * no longer have the Help dialog up with the menu pulled down. This was
 * done to circumvent a known CW bug regarding Menu strings being blanked
 * when in a low memory situation. The following behaviour is present
 * in WORD 5.5 too according to antoine.
 */
#if 0
	char chMyTopSide1;
#endif

	MSG fake_esc_msg ;

	UnReferenced(kk) ;

	gCWpv = pv;
	gCWContext = hem;
	gCWhid = hid;

	if ((hem == hemMenu) || (hem == hemMenuItem))
	{
		gfDisplayDelayedHelp = TRUE ;

		/* Add a fake message to the queue to cause the menu to be closed. This
		 * is a WM_CHAR message to the (fake?) menu window with ESC key(wParam).
		 * Low word of lParam is the char repeat count (1 in this case).
		 */
		fake_esc_msg.pwnd = GetFocus() ;
		fake_esc_msg.message = WM_CHAR ;
		fake_esc_msg.wParam = LOBYTE(VK_ESCAPE) ;
		fake_esc_msg.lParam = (DWORD) ((((WORD)VK_ESCAPE) << 16)) + 1 ;
		// fake_esc_msg.time = 0 ;      // DOC says that this value is not reliable!

		UngetMessage(&fake_esc_msg) ;

	}
	else
	{
#if 0 
		chMyTopSide1 = inch._chTopSide1;
		inch._chTopSide1 = ' ';
#endif

		HelpBox();
		ClearHelpContext() ;

#if 0
		inch._chTopSide1 = chMyTopSide1;
#endif
	}

}


#ifdef DBCS
int     FarCheckDBCSTailByte(str,point)
unsigned char far *str;
unsigned char far *point;
{
	unsigned char far *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\list.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>

/* make this #if to fail so that you can build in DEBUG mode without
 * running out of near heap space when compiling this file!!!
 */
#if 1
#include <prot.h>
#else
extern VOID get_temp_dir(char *buffer,BOOL UseTemp) ;
extern  void far *pascal far LpbAllocWorkFar(unsigned short cb);
extern  void pascal far FreeWorkFar(void far *lpb);
extern void HandleSearchQuit(void) ;
extern  void JunkTree(struct th_t far *tree);
extern  struct fi_t far *GetNthVisibleDir(struct th_t far *tree,int count);
extern  struct fi_t far *GetNthDir(struct th_t far *tree,int count);
extern	struct th_t far *FindTree(char *path, BYTE *driveind);
extern  struct fi_t far *FindOpenSlot(struct th_t far *tree);
extern  struct fi_t far *GetLastDirFile(struct fi_t far *dir);
extern  struct fi_t far *GetFirstDirFile(struct fi_t far *dir);
extern  struct fi_t far *GetLastRootFile(struct th_t far *tree);
extern  struct fi_t far *GetFirstRootFile(struct th_t far *tree);
extern  void ResetTreeOptimizations(void );
extern  void ClobberFiles(struct th_t far *tree);
extern  void ClobberDir(struct th_t far *tree,struct fi_t far *dir);
extern  void ClobberSel(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *curr);
extern  void PackDirs(struct th_t far *tree);
extern  int CompactOne(int sel);
extern  void CompactAll(void );
extern  void DelFileEntry(struct th_t far *tree,struct fi_t far *parent,struct fi_t far *node);
extern  struct fi_t far *FindParent(struct fi_t far *node);
extern  void strfcpy(char far *dst,char far *src);
extern  int CompactifyTree(struct th_t far *tree,int sel);
extern  int LoadCompactDir(struct th_t far *tree,struct fi_t far *new);
#endif
#include <text.h>

#define AllocFarNormalized(cb)  LpbAllocWorkFar(cb)
#define FreeFarNormalized(fptr) FreeWorkFar(fptr)

extern char gStartUpDir[] ;
extern int gStartUpDirEnd ;
extern BYTE	gHighlightedDrive[];
extern BYTE	gSelectedDrive[];

extern void SetUpTreeForSort(PTREE tree) ;
extern BOOL FPerformOpOnDirFilesAlone(void) ;

int gswapfhandle;
int gnumpages;

/* ZZZZZ should I try user's RAM drive, temp path, etc before the start up dir? */

/***************************************************************************/
/* Opens the swap file in write-only mode. Global variable gswapfhandle    */
/* is assigned the handle to this file.									   */
/* On exit, returns TRUE on success, else FALSE.						   */
/***************************************************************************/
BOOL initswapout(void)
{
	 int ret ;
	 char swpname[91];
	 int ind ;

	 get_temp_dir(swpname,TRUE);

	 /* Don't swap to a floppy!! */
#ifdef JAPAN
	if (getdrivetype(*swpname - 'A' + 1) == FLOPPY_TYPE)
		return FALSE;
#else
	 if ( (*swpname == 'A') || (*swpname == 'B') )
		return FALSE ;
#endif

	 /* form full path name of swap file. */
	 ind = strlen(swpname) ;
#ifdef DBCS
	 if (swpname[ind-1] != '\\' || CheckDBCSTailByte(swpname,&swpname[ind-1]))
#else
	 if (swpname[ind-1] != '\\')
#endif
	 {
		swpname[ind++] = '\\' ;
	 }
	 strcpy(swpname+ind,szShellSwap);

	 /* ZZZZZ what if user has file of same name!! _ Do I warn him? */
	 _dos_setfileattr(swpname, 0); /* remove any read-only attrib on file */

	 ret = _dos_creat(swpname,(O_WRONLY | O_BINARY),&gswapfhandle) ;
	 return(!ret);
} /* initswapout */

/***************************************************************************/
/* Opens the swap file in read-only mode. Global variable gswapfhandle	  */
/* is assigned the handle to this file.									   */
/* On exit, returns TRUE on success, else FALSE.						   */
/***************************************************************************/
BOOL initswapin(void)
{
	 int ret ;
	 int ind ;
	 char swpname[91];

	 get_temp_dir(swpname,TRUE);

	 /* form full path name of swap file. */
	 ind = strlen(swpname) ;
#ifdef DBCS
	 if (swpname[ind-1] != '\\' || CheckDBCSTailByte(swpname,&swpname[ind-1]))
#else
	 if (swpname[ind-1] != '\\')
#endif
	 {
		swpname[ind++] = '\\' ;
	 }
	 strcpy(swpname+ind,szShellSwap);

	 ret = _dos_open(swpname,(O_RDONLY | O_BINARY),&gswapfhandle);
	 return(!ret);

} /* initswapin */

/***************************************************************************/
/* Closes the swap in file. In addition it deletes the swap file from the 	*/
/* disk iff the boolean input variable 'fDelSwapFile' is set (non-zero).	*/
/***************************************************************************/
VOID endswap(BOOL fDelSwapFile)
{
	 int ind ;
	 char swpname[91];

	_dos_close(gswapfhandle) ;

	 if (fDelSwapFile)
	 {

		get_temp_dir(swpname,TRUE);

		/* form full path name of swap file. */
		ind = strlen(swpname) ;
#ifdef DBCS
		if (swpname[ind-1] != '\\' || CheckDBCSTailByte(swpname,&swpname[ind-1]))
#else
		if (swpname[ind-1] != '\\')
#endif
		{
			swpname[ind++] = '\\' ;
		}
		strcpy(swpname+ind,szShellSwap);
	
		_dos_setfileattr(swpname, 0); /* Remove any read-only attrib */
	
		unlink(swpname) ; /* Delete the swap file from disk */
	}
} /* endswap */

/* This is the segmnet association array! */
typedef struct FIXUP
{
    char far *old;
    char far *new;
}FIXUP;

struct FIXUP far *fixups;

/***************************************************************************/
/* Accepts a far pointer as input. Output is a far pointer with the segment*/
/* part of this pointer modified based on the segment association array. If*/
/* an association is not found, output == input.						   */
/***************************************************************************/

char far *fixup(char far *old)
{
     int i;
     char far *retval;

	  /* Actually this special case code might not be needed as the loop
		* below will fail and we will retun NULL anyway.
		*/
	  if (old == NULL)
			return NULL ;

     retval = old;
     for(i=0;i<gnumpages;i++)
     {
		/* Note that our pointers are normalized pointers, as the allocation
			routine returns such a pointer. 
		*/
#if 0
		if(HIWORD(fixups[i].old) == HIWORD(old))
		/* Note: FP_SEG macro doesn't cast it to a far pointer!! So, If I used
		 it there would be a long address to short address conversion
		if (FP_SEG((fixups[i].old)) == FP_SEG(old))
		*/
#endif
		/* See if the segment values of these two far pointers are the same */
		if ( *( ((WORD FAR *)&(fixups[i].old))+1) == *( ((WORD FAR *)&old)+1) )
		{
			/* Change retval's segment value to that in fixups[i].new */
#if 0
	    	retval = (char far *)(((unsigned long) retval & 0xFFFF) | 
							( ((unsigned long)HIWORD(fixups[i].new)) <<16) ) ;
#endif
			/* Note that far pointers are stored as OFFSET followed by segment
			*	in the intel architectures -- That's the reason for the "+1".
			*/
			*( ((WORD FAR *)&retval) + 1) = *( ((WORD FAR *)&(fixups[i].new)) + 1) ;
	    	break ;
		}
     } /* for */

     return(retval);
} /* function fixup */

/****************************************************************************/
/* Appends to the swap file (accessed using the global handle gswapfhandle) */
/* 'size' bytes from buffer 'bytes'. Actually, this routine assumes that the*/
/* caller has left the file pointer at the end of the file.					*/
/* If successful returns TRUE else FALSE. 									*/
/****************************************************************************/
BOOL appendswap(char far *bytes,int size)
{
   int asize;

   if ( (!_dos_write(gswapfhandle,bytes,size,&asize)) && (asize == size) )
		return TRUE ;
   else
		return FALSE ;
} /* appendswap */

/****************************************************************************/
/* Reads 'size' bytes from swap file (accessed using the global handle		*/
/* gswapfhandle) into buffer 'bytes'. These bytes are picked up from wherever*/
/* the file pointer happens to be pointing in the file. 					*/
/* If successful returns TRUE else FALSE.									*/
/****************************************************************************/
BOOL getappended(char far *bytes,int size)
{
   int asize;

   if ( (!_dos_read(gswapfhandle,bytes,size,&asize)) && (asize == size) )
		return TRUE ;
	else
		return FALSE ;
} /* getappended */

BOOL SwapInTree(PTREE tree)
{
    int i,j;

	if (gnumpages > 0)
	{
    	fixups = LpbAllocWorkFar(sizeof(FIXUP)*gnumpages);
    	if(!fixups)
			return(FALSE);
	}

	/* Now, try to allocate enuf mem for the file entries to be swapped in */
    for(i=0;i<gnumpages;i++)
    {
       fixups[i].new = AllocFarNormalized(sizeof(filepage));
       if(!fixups[i].new)
       {
	 		/* Allocation failed, free it all */
			for ( ; i ; )
				FreeFarNormalized(fixups[--i].new) ;

			FreeWorkFar(fixups) ;
			return(FALSE);
       }
    }

	/* Read Tree and Directory-Entries that were previously swapped to disk. */
    getappended((char far*) tree,sizeof(treehdr));

	/* No file pages need be swapped in -- Will happen only when we are swapping
	 * in a 'junk'ed tree. Only the 'tree' data stucture need be swapped in
	 * and that has been done in the line above.
	 */
	if (gnumpages == 0)
		return(TRUE) ;

    for(i=0;i<gnumpages;i++)
    {
       getappended(fixups[i].new,sizeof(filepage));
    }

	/* perform all the pointer fixups */
    fixups[0].old = (char far *) tree->pagehead;
    for(i=1;i<gnumpages;i++)
    {
		fixups[i].old = (char far *) ((PPAGE)fixups[i-1].new)->next;
    }

    for(i=0;i<gnumpages;i++)
    {
		for(j=0;j<PAGESIZE;j++)
		{
	  		((PPAGE) fixups[i].new)->files[j].sibling=
				(PENTRY)fixup((char far *)((PPAGE)fixups[i].new)->files[j].sibling);
	  		if(!(((PPAGE)fixups[i].new)->files[j].attribs & _A_SUBDIR))
	  		{
	     		((PPAGE)fixups[i].new)->files[j].x.f.snext=
		   		(PENTRY)fixup((char far *)((PPAGE)fixups[i].new)->files[j].x.f.snext);
	  		}
	  		else
	  		{
	     		((PPAGE)fixups[i].new)->files[j].x.d.dnext=
		    		(PENTRY) fixup((char far *)((PPAGE)fixups[i].new)->files[j].x.d.dnext);
	     		((PPAGE)fixups[i].new)->files[j].x.d.child=
		    		(PENTRY) fixup((char far *)((PPAGE)fixups[i].new)->files[j].x.d.child);
	  		}
		} /* inner for */
	    ((PPAGE) fixups[i].new)->next=
		    (PPAGE) fixup((char far *)((PPAGE)fixups[i].new)->next);
    } /* outer for */
    tree->head = (PENTRY)(fixup((char far *)tree->head));

    tree->pagehead = (PPAGE)(fixup((char far *)tree->pagehead));
    tree->pagetail = (PPAGE)(fixup((char far *)tree->pagetail));

    tree->FirstDirectory = (PENTRY)fixup((char far *)tree->FirstDirectory);
    tree->LastDirectory = (PENTRY)fixup((char far *)tree->LastDirectory);
    tree->FirstFile = (PENTRY)fixup((char far *)tree->FirstFile);
    tree->LastFile = (PENTRY)fixup((char far *)tree->LastFile);

    tree->parent = (PENTRY)fixup((char far *)tree->parent);
    tree->lastlink = (PENTRY)fixup((char far *)tree->lastlink);

	 tree->SelDir =  (PENTRY)fixup((char far *)tree->SelDir);
	/* tree->next is not fixed here!! The caller of this routine does that! */

	/* Free the memory allocated for the pairs of pointers */
    FreeWorkFar(fixups) ;

	return (TRUE) ;
} /* SwapInTree */

BOOL SwapOutTree(PTREE tree)
{
   PPAGE page;
	BOOL ret ;

    ret = appendswap((char far *)tree,sizeof(treehdr)) ;

    page = tree->pagehead;
    while(ret && page)
    {
		ret = appendswap((char far *)page,sizeof(filepage)) ;
		page=page->next;
    }

	return ret ;
} /* SwapOutTree */

unsigned int GetNumFilePages(PTREE tree)
{
	unsigned int i ;
	PPAGE page ;

	for(i= 0 , page = tree->pagehead ; page ; page = page->next)
		i++ ;

	return i ;
} /* GetNumFilePages */

/****************************************************************************/
/* Swap out the tree(s) being displayed to the user, so that we can return	*/
/* to the file manager mode promptly. If any errors in opening file or 		*/
/* writing to disk, etc occur during this swap, no swap file will be left on*/
/* the disk.																*/
/****************************************************************************/
VOID DoSwapOut(void)
{
	/* 'ptr' is pointer to place in 'glob' where we can stick in some values. */
	unsigned char far *ptr ; 

	// ZZZ We don't swapout TR_SEARCH mode as we consider it a temporary mode!
	if (glob.TreeMode == TR_SEARCH)
		HandleSearchQuit() ;

	/* If tree is not fully read in!! we trash it!! The reason we
	 * trash it is because we can't be sure if the find_t structure
	 * has meaningful values now, because user could have done something
	 * to the disk. Of course if we were smart and make sure disk hasn't
	 * changed since the last time, we can swap out partial tree and then
	 * read it back in and continue where we left off!
	 */
	if (listinfo[0].tree->ContinueTree)
		JunkTree(listinfo[0].tree) ;

   if (!initswapout())
		return ;

	/* This structure "glob" will get swapped to disk, so store the global
	 * variable "gDescendingOrder" in this field.
	 */
	glob.TempDescendingOrder = gDescendingOrder ;
	glob.TempFileListFocusItem[0] = Get_List_Focus(&FileList[0]);
	glob.TempFileListFocusItem[1] = Get_List_Focus(&FileList[1]);
	glob.TempFileListScrolled[0] =  Get_List_Scrolled(&FileList[0]);
	glob.TempFileListScrolled[1] = Get_List_Scrolled(&FileList[1]);

	/* ptr now points to a location that is 8 bytes long (= 2 far pointers). */
	/* we use only 4 of these presently. The remaining 4 are still left free */
	ptr = (unsigned char far *) &(glob.SelTree[0]) ;
	*ptr = listinfo[0].tree->root[0] ;

	/* even if we are not in TR_DOUBLE mode, we save drive1's name too */
	*(ptr+1) = listinfo[1].tree->root[0] ;

	/* The following 2 locations store the number of filepages reqd for tree
	 * It should also be noted that 1 filepage can store upto PAGESIZE entries
	 * (= 256). Given that the size of a filepage is nearly 8K, 256 filepages
	 * is a lot. Therefore, the number of filepages can be stored in a byte
	 * Note that if tree is still being built, we use 0 for the number of file
	 * pages. This is because we call JunkTree before swapping out in this
	 * case.
	 */
	*(ptr+2) = (BYTE) ((listinfo[0].tree->ContinueTree) ? 0 :
								(unsigned char) GetNumFilePages(listinfo[0].tree)) ;
	*(ptr+3) = (BYTE) ((listinfo[1].tree->ContinueTree) ? 0 :
								(unsigned char) GetNumFilePages(listinfo[1].tree)) ;

   if (!appendswap((char far *)&glob,sizeof(global_t)))
	{
		/* Disk is probably full - we couldn't write to disk! 				*/
		/* This routine is basically called when we need to launch a program */
		/* and we want to do that as soon as possible without bothering about*/
		/* this error! We will re-read disk on return from launch!			 */
		endswap(TRUE) ; /* delete swap file created */
		return ;
	}

   if (!SwapOutTree(listinfo[0].tree))
	{
		/* Error in swapping out tree! */
		endswap(TRUE) ; /* delete swap file created */
		return ;
	}

	if ((glob.TreeMode == TR_DOUBLE) && (listinfo[0].tree != listinfo[1].tree))
	{
		/* If tree is not fully read in!! we trash it!! The reason we
		 * trash it is because we can't be sure if the find_t structure
		 * has meaningful values now, because user could have done something
		 * to the disk.
		 */
		if (listinfo[1].tree->ContinueTree)
			JunkTree(listinfo[1].tree) ;

   	if (!SwapOutTree(listinfo[1].tree))
		{
			/* Error in swapping out tree! */
			endswap(TRUE) ; /* delete swap file created */
			return ;
		}
	}

	/* Swapping out suucesfully completed -- close swap file */
	endswap(FALSE) ;
} /* DoSwapOut */

/* ZZZZ Handle correctly the case when we run out of memory doing swap in!! */
VOID DoSwapIn(void)
{
   PTREE tree ;
	global_t temp_glob ;
	unsigned char far *ptr ;
	unsigned char drive_letter1, drive_letter2 ;
	unsigned char num_pages1, num_pages2 ;
	PTREE next_tree ;
	BYTE driveind ;

   if (!initswapin())
		return ; 

	temp_glob = glob ; /* store glob's current values for use later */

	getappended((char far *) &glob, sizeof(global_t)) ;

	/* Transfer the sort order flag to "gDescendingOrder" as it is being
	 * looked at by the string compare routines, etc!
	 */
	gDescendingOrder = glob.TempDescendingOrder ;

	Set_List_Focus(&FileList[0],glob.TempFileListFocusItem[0]);
	Set_List_Focus(&FileList[1],glob.TempFileListFocusItem[1]);

	Set_List_Scrolled(&FileList[0],glob.TempFileListScrolled[0]);
	Set_List_Scrolled(&FileList[1],glob.TempFileListScrolled[1]);

	/* Location where the drive letters, the two filepage numbers are stored! */
	ptr = (unsigned char far *) &(glob.SelTree[0]) ;

	/* Retrieve the following 4 values as they will be lost when we change the
		value of glob.SelTree[0] later! */
	drive_letter1 = *ptr ;
	drive_letter2 = *(ptr+1) ;
	num_pages1 = *(ptr+2) ;
	num_pages2 = *(ptr+3) ;

	glob.drives = temp_glob.drives ;
	glob.DriveCount = temp_glob.DriveCount ;
	
	tree = FindTree(&drive_letter1, &driveind) ;
	if (tree)
	{
		listinfo[0].tree = listinfo[1].tree = tree ;
		glob.SelTree[0] = glob.SelTree[1] = tree ;
		gnumpages = (int) num_pages1 ;

		/* store this as SwapInTree will trash its value!! */
		next_tree = tree->next ; 

     	if (SwapInTree(tree))
		{
			tree->next = next_tree ;

			/* Set the directory with check mark correctly */
			listinfo[0].files = GetNthVisibleDir(tree, glob.lineselected[0]) ; 
			listinfo[1].files = GetNthVisibleDir(tree, glob.lineselected[1]) ;

			gHighlightedDrive[0] = driveind ;
			gSelectedDrive[0] = driveind;
			gHighlightedDrive[1] = driveind ;
			gSelectedDrive[1] = driveind ;

			/* ZZZZZ	What about TR_SEARCH? */
			if ( (glob.TreeMode==TR_DOUBLE) && (drive_letter1!=drive_letter2) )
			{
				tree = FindTree(&drive_letter2, &driveind) ;
				if (tree)
				{
					listinfo[1].tree = tree ;
					glob.SelTree[1] = tree ;
					gnumpages = (int) num_pages2 ;
					
					/* store this as SwapInTree will trash its value!! */
					next_tree = tree->next ; 
					if (SwapInTree(tree))
					{
						gHighlightedDrive[1] = driveind ;
						gSelectedDrive[1] = driveind ;

						tree->next = next_tree ;
						/* Set the directory with check mark correctly */
					   listinfo[1].files=GetNthVisibleDir(tree, 
														glob.lineselected[1]) ;
					}
				} /* tree2 != NULL */
			} /* TR_DOUBLE handled */
		} /* tree1 swapped in OK */
	} /* tree1 != NULL */

	/* Swapping in complete, now delete the swap file from disk */
	endswap(TRUE) ;
} /* DoSwapIn */


/****	AllocTreeEntry - Give a location to add a record to file tree
**
**	ENTRY
**		tree - ptr to tree header
**	EXIT
**		address of object in tree, or NULL if error
**
**	EFFECTS
**		Modifies tree, allocates memory
**	WARNING
**	    Does not adjust any pointers except filepage ptrs; this includes
**	tree->head.  Does not adjust any _A_NOSIB bits.
*/

/* NOTE: In following two routines page->files is used to cast the address
		 pointed to by 'page' to PENTRY. As 'files' is an array of PENTRies
		 all is well */
PENTRY  AllocTreeEntry(PTREE tree)
{
	PPAGE page;								// page with open slot
	PENTRY node;							// the open slot
	
	if (!tree)
		return FALSE;

	/* Try to get an open slot.  If there is none, allocate a new page.
	*/
	node = FindOpenSlot(tree);
	if (!node)
	{
		page = AllocFarNormalized(sizeof(filepage));
		if (!page)
			return FALSE;

		page->next = NULL;
		for (node=page->files; node < page->files+PAGESIZE; node++)
			node->name[0] = EOS;	// make all nodes unused

		if (!tree->pagehead)
		{
			tree->pagehead = page;
		} else
		{
			tree->pagetail->next = page;
		}
		tree->pagetail = page;

		/* the first entry is returned */
		node = page->files ;
		tree->freeind = 1 ; /* We have just used the entry at index 0! */
	}
	
	return node;
} /* proc AllocTreeEntry */

/****	FindOpenSlot - given a filepage list, locate an empty node in it
**
**	ENTRY
**			page - head of filepage list
**	EXIT
**			address of empty slot, or NULL if none found.
*/
PENTRY FindOpenSlot(PTREE tree)
{
	PENTRY node;
	PENTRY bound;
	PENTRY found;
	PPAGE page ;

	found = NULL ;

	if (tree->holecount == 0)
	{
		/* NOTE: At startup, tree->freeind == PAGESIZE and this will fail */
		if (tree->freeind < PAGESIZE)
		{
#ifndef NOCONSISTENCY
			if (!tree->pagetail)
			{
				printf("*** BUG: pagetail = NULL and will be derefed\n") ;
				exit(0) ;
			}
#endif
			found = tree->pagetail->files + tree->freeind ;
			tree->freeind++ ;
		}
		/* else -- no free slots in last page allocated so far */
	}
	else
	{
#ifdef DBGBEEP
		Beep() ;
#endif

		/* There are holes in the entries allocated so far -- start from
		   first page and search. */
		/* ZZZZZ we could have stored the list of holes or one hole for
		   each tree and use that immediately instead of this search.
		   Or use some smart heuristics to avoid search */

		page = tree->pagehead ;
	
		while (page && !found)
		{
			node = page->files;
			bound = node+PAGESIZE;
			while (node < bound && node->name[0])
				node++;
			if (node >= bound)
				page = page->next;
			else
			{
				found = node;
#ifndef NOCONSISTENCY
				if (tree->holecount <= 0)
				{
					printf("*** holecount=%d '--'ed!\n", tree->holecount) ;
					exit(0) ;
				}
#endif
				tree->holecount-- ;
			}
		} /* while */
	} /* else */
	return found;
} /* proc FindOpenSlot */


PENTRY AllocTreeEntryCompactIfNeeded(PTREE tree)
{
	BOOL retry ;
	PENTRY rptr ;

	do
	{
		rptr = AllocTreeEntry(tree);

		/* If allocation failed, compact a tree & retry */
		if (!rptr)
			retry = CompactOne(FALSE);
		else
			break ;
	} while (retry) ;

	return rptr ;

} /* AllocTreeEntryCompactIfNeeded */

/* Free up any memory allocated to trees that are not being viewed by the
 * user. Currently this function is being called only by ViewFile().
 */
BOOL FreeUnusedFMMemory(void)
{
	PTREE tree ;
	PTREE non_slowtree = NULL ;
	PTREE slowtree = NULL ;
	PTREE DontFreeTree1, DontFreeTree2 ;

	/* DontFreeTree1(2) are the tree(s) that are being displayed to the
	 * user. We do not want to free the memory allocated to them.
	 */
	DontFreeTree1 = listinfo[0].tree ;

	/* In case the user is not in Dual tree mode, mark both trees as the same*/
	if (glob.MaxTree)
		DontFreeTree2 = listinfo[1].tree ;
	else
		DontFreeTree2 = DontFreeTree1 ;

	for (tree= glob.drives ; tree ; tree = tree->next )
	{
		if (tree->Started)
		{
			if ( (tree == DontFreeTree1) || (tree == DontFreeTree2) )
				continue ;

			/* We treat slow drives (network/cd-roms) as special cases.
			 * In case of a network drive, if it has been fully read in
			 * we don't want to free it unless we have no other option.
			 */
			if ( (tree->DriveType != REMOTE_TYPE) &&
												(tree->DriveType != CDROM_TYPE) )
			{
				non_slowtree = tree ;
			}
			else
			{
				/* has tree not been fully read in? */
				if (tree->ContinueTree)
				{
					JunkTree(tree) ;
					return TRUE ;
				}

				slowtree = tree ;
			}
		} /* if tree has been started */

	} /* for */

	/* free the fast tree, if present, before looking for the slow tree
	 * to free
	 */
	if (non_slowtree)
	{
		JunkTree(non_slowtree) ;
		return TRUE ;
	}

	if (slowtree)
	{
		JunkTree(slowtree) ;
		return TRUE ;
	}

	return FALSE ;

} /* FreeUnusedFMMemory */


/* Counts the number of files in directory 'dir' -- Don't recurse */
/* Works only in non-system mode -- as lastdirfile is meaningless in 
	TR_SYSTEM display mode.  */
unsigned CountDirFiles(PENTRY dir, PTREE tree)
{
	unsigned count ;
	PENTRY temp ;
	
	/* dir == NULL implies that we want to count files in the root directory */
	temp = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!temp)
		return 0;
	
	for (count = 1 ; !temp->LASTDIRFILE ; temp = temp->x.f.snext, count++ )
		/* Do Nothing */ ;

	return count;
}

/* Counts the number of files in directory 'dir' -- Don't recurse */
/* Works only in non-system mode -- as lastdirfile is meaningless in 
	TR_SYSTEM display mode.  */
/* ZZZZ Once the selected functions are used -- the normal versions can be
got rid of -- like CountDirFiles, GetNthFile!! */
unsigned CountDirMatchedFiles(PENTRY dir, PTREE tree)
{
	unsigned count ;
	PENTRY temp ;
	
	/* dir == NULL implies that we want to count files in the root directory */
	temp = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!temp)
	{
		return 0;
	}

	count = temp->MATCHESPATTERN ? 1 : 0 ;
	
	while (!temp->LASTDIRFILE)
	{
		temp = temp->x.f.snext ;
		if (temp->MATCHESPATTERN)
			count++ ;
	}

	return count;
}  /* CountDirMatchedFiles */

/* returns the count of files selected in the tree. It also passes by
reference the sum of the sizes of files selected */
unsigned GetTreeSelectedInfo(PTREE tree, unsigned long far *psize)
{
	unsigned count ;
	PENTRY temp ;

	*psize = 0 ;
	if (!tree)
	    return 0 ;

	for (temp = tree->FirstFile, count = 0 ; temp ; temp = temp->x.f.snext)
		if (temp->SELECTED)
	    {
		count++ ;
		*psize += temp->x.f.size ;
	    }

	return count;
}  /* GetTreeSelectedInfo */


#ifdef THISISOLDCODE
unsigned CountTreeMatchedFiles(PTREE tree)
{
	unsigned count ;
	PENTRY temp ;
	
	if (!tree)
		return 0 ;

	for (temp = tree->FirstFile, count = 0 ; temp ; temp = temp->x.f.snext)
		if (temp->MATCHESPATTERN)
			count++ ;

	return count;
}  /* CountTreeMatchedFiles */
#endif

WORD gLastCount=0;
PENTRY gLastEntry=NULL;
PTREE gLastTree =NULL;


VOID ResetTreeOptimizations()
{
     PTREE tree;

    tree = glob.drives;
    while (tree)
    {
	tree->nummatches=RECALCNUMMATCHES;
	tree = tree->next;
    }
    gLastCount=0;
    gLastEntry=NULL;
    gLastTree =NULL;
}

unsigned CountTreeMatchedFiles(PTREE tree)
{
	unsigned count ;
	PENTRY temp ;

	if (!tree)
		return 0 ;

	if(tree->nummatches != RECALCNUMMATCHES)
	    return(tree->nummatches);

	for (temp = tree->FirstFile, count = 0 ; temp ; temp = temp->x.f.snext)
		if (temp->MATCHESPATTERN)
			count++ ;
	return (tree->nummatches=count);
}  /* CountTreeMatchedFiles */

PENTRY GetNthMatchedFile(PENTRY dir, int count, PTREE tree)
{
	PENTRY fil ;
	
	fil = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!fil)
		return NULL;

	/* ZZZZ One idea is to call pmatch here instead of marking all files
	when pattern is changed and then just checking that bit here */
	while (!fil->MATCHESPATTERN)
		if (fil->LASTDIRFILE)
			return (NULL) ;
		else
			fil = fil->x.f.snext ;

	for (; count > 0;count--)
	{
		do
		{
			if (fil->LASTDIRFILE)
				return (NULL) ;
			else
				fil = fil->x.f.snext ;
		} while (!fil->MATCHESPATTERN) ;
	}

	return(fil);

} /* proc GetNthMatchedFile */

#ifdef THISISOLDCODE
PENTRY GetNthFlatMatchedFile(PTREE tree, int count )
{
	PENTRY fil ;
	
	if (!(fil= tree->FirstFile))
		return NULL;

	while (!fil->MATCHESPATTERN)
		if (!(fil = fil->x.f.snext))
			return (NULL) ;

	for (; count > 0;count--)
	{
		do
		{
			if (!(fil = fil->x.f.snext))
				return (NULL) ;
		} while (!fil->MATCHESPATTERN) ;
	}

	return(fil);

} /* proc GetNthFlatMatchedFile */
#endif
PENTRY GetNthFlatMatchedFile(PTREE tree, int count )
{
	WORD start;
	PENTRY fil;

	if (CountTreeMatchedFiles(tree) <= count)
	{
	    return(gLastEntry=NULL);
	}

	if (((gLastCount <= count) && (tree == gLastTree) && (gLastEntry != NULL)))
	{
	    start = gLastCount;
	}
	else
	{
	    gLastEntry = tree->FirstFile;
	    start = 0;
	}

	fil = gLastEntry;

	/* Claim: 'fil' can never be NULL from now on! Reason: tree->nummatches is
	*	strictly greater than count!
	*/
	gLastCount = count;
	gLastTree = tree;
	while(!fil->MATCHESPATTERN)
		 fil=fil->x.f.snext;
	
	while (start++ < count)
	{
	   do
	   {
		 fil=fil->x.f.snext;
	   }
	   while(!fil->MATCHESPATTERN);
	}
	return(gLastEntry=fil);

} /* proc GetNthFlatMatchedFile */

/* ZZZZZZZ Is this routine needed anymore? */
/****	GetNthDir - get the 'nth' directory in the tree, in depth-first order
**	This is used by MakeTreeLine().
**
**	ENTRY
**		branch - branch to search along
**		count  - which record you want
**	EXIT
**		ptr to appropriate record, or NULL if not found
*/
PENTRY GetNthDir(tree, count)
treehdr far *tree;
int count;
{
	int curcount;
	PENTRY dir;

	if (count > 0)
	{
		dir = tree->FirstDirectory;
		for(curcount = 1; ((curcount < count) && dir) ;curcount++)
		{
			dir = dir->x.d.dnext;
		}
	}
	else
	{
	    dir = NULL;
	}
	return(dir);
} /* GetNthDir */

/****	GetNthVisibleDir - get the 'nth' directory in the tree,
**      		in depth-first order that is being displayed to the user.
**	This is used by MakeTreeLine().
**
**	ENTRY
**		branch - branch to search along
**		count  - which record you want
**	EXIT
**		ptr to appropriate record, or NULL if not found
*/
PENTRY GetNthVisibleDir(PTREE tree, int count)
{
	int curcount;
	PENTRY dir;

	if (count > 0)
	{
		dir = tree->FirstDirectory;
		curcount = dir->DISPLAYED; /* ZZZ It's OK if dir is NULL in DOS! */

		while (dir && (curcount < count))
		{
			dir = dir->x.d.dnext ;
			if (dir->DISPLAYED) /* ZZZ It's OK if dir is NULL in DOS! */
				curcount++ ;
		} /* while */

	}
	else
	{
	    dir = NULL;
	}
	return(dir);
} /* GetNthVisibleDir */

/* Returns a BOOL to indicate if a given directory has got any sub-dirs */
BOOL AreThereSubDirs(PTREE tree, PENTRY dir)
{
	PENTRY child ;

	if (!dir)
		// root directory has sub-directories if there is any directory at all
		return (tree->DirCount > 0) ;
	else
	{
		child = dir->x.d.child ;
		while (child)
		{
			if (child->attribs & _A_SUBDIR)
				return TRUE ;
			else
				/* ZZZZZ following can be optimized using '-' and '&' ops */
				child = (child->nosib) ? NULL : child->sibling ;
		}
		return FALSE ; /* dir does not have any sub-dirs */
	}
} /* AreThereSubDirs */

/* Expand visiblity of directory 'dir' -- recursive routine.
 * The recursion should not cause concern regarding stack space as the
 * maximum recursion level is bounded by the nesting of directories.
 * The directory 'dir' is assumed to have been already been read into 
 * memory. It is now only a matter of setting the collapse bits for 'dir'
 * and its sub-dirs. It expands all levels or 1 level depending on 'fAllLevels'.
 * 'dir' is assumed to be in a non-expanded form at this stage.
 */
void ExpandDirVisibility(PTREE tree, PENTRY dir, BOOL fAllLevels)
{
	PENTRY child;

	if ( ((!dir) && (tree->DirCount > 0)) || (dir->HASSUBDIRS) )
	{
		if (dir)
		{
			/* Assumption: 'dir' must already be visible! */
			dir->EXPANDED = TRUE ; 
			child = dir->x.d.child ;
		}
		else
			child = tree->head ;
	
		while (child)
		{
			if (child->attribs & _A_SUBDIR)
			{
				/* child's HASSUBDIRS bit assumed to be already set correctly */
				child->DISPLAYED = TRUE ; 
				tree->VisibleDirCount++ ;
	
				/* we want to expand all levels of 'dir', so expand 'child' */
				if (fAllLevels)
					ExpandDirVisibility(tree, child, fAllLevels) ;
			}
	
			/* ZZZZZ following can be optimized using '-' and '&' ops */
			child = (child->nosib) ? NULL : child->sibling ;
		}
	}
	/* else 'dir' does not have any sub-dirs, so no expansion required! */
} /* ExpandDirVisibility */


/* Collapse visiblity -- All sub-dirs of 'dir' made invisible -- recursive.
 * The recursion should not cause concern regarding stack space as the
 * maximum recursion level is bounded by the nesting of directories.
 * The directory 'dir' is assumed to have been already been read into 
 * memory. It is now only a matter of setting the collapse bits for 'dir'
 * and its sub-dirs. It makes all sub-dirs of 'dir' invisible.
 */
void CollapseDirVisibility(PTREE tree, PENTRY dir)
{
	PENTRY child;

	if ( ((!dir) && (tree->VisibleDirCount > 0)) || (dir->EXPANDED) )
	{
		if (dir) 
		{
			/* Assumption: 'dir' must already be visible! */
			dir->EXPANDED = FALSE ; 
			child = dir->x.d.child ;
		}
		else
			child = tree->head ;
	
		while (child)
		{
			if ( (child->attribs & _A_SUBDIR) && (child->DISPLAYED) )
			{
				/* child's HASSUBDIRS bit assumed to be already set correctly */
				child->DISPLAYED = FALSE ; 
				tree->VisibleDirCount-- ;

				if (child->EXPANDED)
					CollapseDirVisibility(tree, child) ;
			}
	
			/* ZZZZZ following can be optimized using '-' and '&' ops */
			child = (child->nosib) ? NULL : child->sibling ;
		}
	}
	/* else 'dir' not expanded, so no collapseing required! */
} /* CollapseDirVisibility */

/****	GetDirInfo - Get Total Number of files in a directory & sum of their
**  sizes. Used by DispFlatLeft. Returns the count of directories. The size
**  is passed back in psize (passed by reference). The number of files in
**  dir that are selected are also passed back by reference.
*/
unsigned GetDirInfo(PENTRY dir, PTREE tree, unsigned long *psize,
																unsigned int *pNumSelFiles)
{
	PENTRY temp ;
	unsigned count ;

	*psize = *pNumSelFiles = count = 0 ;
	
	temp = (dir) ? dir->x.d.child : tree->head ;
	
	while (temp)
	{ 
      if (!(temp->attribs & _A_SUBDIR) )
		{
			count++ ;
			*psize += temp->x.f.size ;

			if (temp->SELECTED)
				(*pNumSelFiles)++ ;
		}

		temp = (temp->nosib) ? NULL :	temp->sibling ;
	}

	return count ;

} /* GetDirInfo */

extern char szStarDotStar[] ;

/****	JunkTree - deallocate all file space from given tree
**		This fn is called when memory is low, or before rereading a tree
**	(e.g. a floppy tree).  It deletes all memory used to store the tree's
**	file nodes, and resets tree elements such as filecount and dircount.
**
**	ENTRY
**		tree - the tree to hack up
**	EXIT
**		none
*/
VOID JunkTree(treehdr far *tree)

{
	PPAGE page, next;

	gfFlatLeftInfoDrawn = FALSE ; /* this initialization helps in system tree mode */

	/* Free all file pages. */
	for (page = tree->pagehead ; page ; page = next )
	{
		next = page->next ;
		FreeFarNormalized(page);
	}

	tree->head = tree->lastlink = NULL;
	tree->pagehead = tree->pagetail = NULL;

	tree->parent = NULL ;
	
	tree->FirstDirectory = tree->LastDirectory = NULL;
	tree->FirstFile = tree->LastFile = NULL;

	tree->Diskfilecount = tree->filecount =  0;
	tree->DirCount = tree->VisibleDirCount = 0;
	ResetTreeOptimizations() ; // ZZZZ I think I can call ResetTreeMatchedFilesOpt()

	tree->Started = FALSE;
	tree->Compacted = FALSE;
	tree->ContinueTree = TRUE;

	tree->fdiskinfoknown = FALSE ;
	tree->SortRequired = TRUE ;

	/* Initially at read-in time, we set
	 * "matchespattern" bit to be true for all
	 * files, which means this!
	 */
	tree->DisplayHiddenFiles = TRUE ;
	strfcpy(tree->mpat, szStarDotStar) ;
	tree->skey = tree->tmode = -1 ; /* non-sort key, non-tree mode */

	tree->NumSel = 0 ;
	tree->SizeSel = 0 ;

	tree->SelDir = NULL ; // ZZZZ default directory goes back to ROOT!!
	tree->SelLine = 0 ;

	tree->holecount = 0 ;
	tree->freeind = PAGESIZE ;

} /* proc JunkTree */

/****	CompactifyTree - expunge file nodes from tree, leaving directories
**		This fn attempts to conserve memory by deleting all non-directory
** nodes from the given tree and putting the remaining nodes in the fewest
** possible filepages.
**
**	ENTRY
**		tree - tree to compact
**		sel  - FALSE = delete all files; compress directories into first few
**					   filepages.
**			   TRUE  = only delete unselected files; don't compress directories.
**	EXIT
**		TRUE if we compressed things, FALSE if not.
*/
BOOL CompactifyTree(tree, sel)
PTREE tree;
BOOL sel;

{
	PENTRY dir;							// directory under scrutiny
	PENTRY node;						// for following ptrs

#ifdef COMPACTCHECK
com1("IN CompactifyTree\n") ;
#endif

	if (tree->Compacted)
		return FALSE;

	/* ZZZZ Will the following field being set cause problems if we end up
	 * doing the CLobberSel() part of the code?
	 */
	/* Note that even empty trees are tagged! */
	tree->Compacted = TRUE ;

	/* If "sel" is TRUE we want to retain file selections in the tree, no
	 * matter what! ELSE if the tree in the focus listbox is the one
	 * being compacted and there are files selected in it, we don't want
	 * to lose these selections!
	 */
	/* ZZZZ This could cause loss of unselected files from the file listbox
	 * for the dirtectory being displayed temporarily. Could also be not
	 * OK in dual tree mode if wrong tree has focus!
	 */
	if ( (sel) || ((listinfo[glob.FocusBox].tree == tree) && (tree->NumSel)) )
	{
		if (tree->Started)
		{
			/* This is not TRUE COMPACTION!! as we might still have files
			 * selected in other diretories (if cross dir selection ON!)
			 */
			/* Note that root dir (NULL) is the parent of tree->head */
			ClobberSel(tree, NULL, tree->head);

			return TRUE;
		}
		else
			return FALSE;
	}
	else
	{
		if (!tree->Started)
			return FALSE;

		/* If the tree being compacted is not the one being operated upon
		 * (one in focus!) Deselect all files belonging to it.
		 */
		if ((listinfo[glob.FocusBox].tree != tree) && (tree->NumSel))
		{
			DeselectTree(tree) ;
			if ( (glob.TreeMode == TR_DOUBLE) &&
									(listinfo[1-glob.FocusBox].tree == tree) )
			{
				InsertListItem(&FileList[1-glob.FocusBox], 0) ;
			}
		}

		/* Fix tree->head to point to the first directory in the sibling
		 * chain of the root directory. Note that this will in general
		 * not be tree->FirstDirectory as we now sort dirs by name!
		 */
		 if ( (node = tree->head) && (!(node->attribs & _A_SUBDIR)) )
		 {
			while(node)
			{
				/* Note that we need not look at 'nosib' as parent is NULL  */
				node = node->sibling ; 

				if (node->attribs & _A_SUBDIR) // It is OK even if node is NULL!
					break ; 
			}
			tree->head = node ;
		 }
		 /* else tree->head is NULL or it is pointing to correct dir already */

		// Make sibling, child ptrs of dirs point only to other dirs.
		dir = tree->FirstDirectory;
		while (dir)
		{
			dir->FIRSTFILEFOUND = FALSE ; /* we are now junking all files
											belonging to dir */
			if (!dir->nosib)
			{
				node = dir->sibling;
				while (!((node->attribs & _A_SUBDIR) || node->nosib))
					node = node->sibling;
				
				if (node->attribs & _A_SUBDIR)
					// found one, make it the sibling
					dir->sibling = node;
				else
				{
					// no more dirs, save parent ptr
					dir->nosib = TRUE;
					dir->sibling = node->sibling;
				}
			}
		
			node = dir->x.d.child;
			if (node)
			{
				while (!((node->attribs & _A_SUBDIR) || node->nosib))
					node = node->sibling;

				if (node->attribs & _A_SUBDIR)
					// found one, make it the first child
					dir->x.d.child = node;
				else
				{
					// no more dirs
					dir->x.d.child = NULL;
				}
			}
			dir = dir->x.d.dnext;
		}

		/* Warning! It is assumed that call to ClobberFiles is always
			immediately followed by PackDirs */
		ClobberFiles(tree);
	
		// Now put all remaining nodes in a block at the front of the page list.
		PackDirs(tree);
	}
/* ZZZZZZZZ */
/* Following is a major bug left by Jeff!! His comment is funny!! */
/* We need to use this field -- lastlink when filesystem is being read in */
/* Since we have thrown out the files, tree->lastlink should be
*  set to the last directory read in so far! If we ran out of memory
*  before encountering the first sub-directory, set tree->head to NULL so
*  as to start reding from the root directory */
#if 0
	tree->lastlink = NULL;					// don't think too hard about it
#else
	tree->lastlink = tree->LastDirectory ;
	if (!tree->lastlink)
		tree->head = NULL ;
	/* else tree->head will be correctly pointing to the first directory! */
#endif
#ifdef COMPACTCHECK
com1("OUT CompactifyTree\n") ;
#endif
	return TRUE;
} /* proc CompactifyTree */

/****	ClobberFiles - delete all unselected files in the given tree
**
**	ENTRY
**			tree - tree to modify
**	EXIT
**			none
**	WARNING
**		This fn does not signal for listboxes to be updated.
*/
void ClobberFiles(PTREE tree)
{
	PPAGE page;								// filepage under examination
	PENTRY node;							// file record within page
	int i;

	// Eliminate all file nodes from tree.
	page = tree->pagehead;
	while (page)
	{
		node = page->files;
		for (i=0; i < PAGESIZE; i++)
		{
			/* ZZZZ Warning! It is assumed that this function ClobberFiles
				call is followed immediately by a PackDirs call, so
				we don't increment tree->holecount here. PackDirs assigns
				the right value to it */
			if (!(node->attribs & _A_SUBDIR))
				node->name[0] = EOS;
			node++;
		}
		page = page->next;
	}
	tree->FirstFile = tree->LastFile = NULL;
	tree->filecount = 0;

	/* Note that we have deleted all files belonging to this tree. So
	 * mark it so that the tree is not sorted in any order at all!
	 */
	SetUpTreeForSort(tree) ;

} /* proc ClobberFiles */

/****	ClobberDir - delete all normal files in a given directory
**
**	ENTRY
**			tree - the tree
**			dir  - the directory
**	EXIT
**		none
**	WARNING
**		This fn does not signal for listboxes to be updated; this should be
**	done by the caller.
*/
void ClobberDir(PTREE tree, PENTRY dir)
{
	PENTRY curr;						// node being examined
	PENTRY next;						// the next one to look at

	if (dir)
		curr = dir->x.d.child;
	else
		curr = tree->head;

	// Remove all normal files from the list.
	while (curr)
	{
		if (curr->nosib)
			next = NULL;
		else
			next = curr->sibling;

		if (!(curr->attribs & _A_SUBDIR))
		{
			DelFileEntry(tree, dir, curr);
		}
		curr = next;
	}

	/* All files belonging to this directory have been thrown out, so
	 * clear these following bits.
	 */
	dir->DIRSORTED = FALSE ;
	dir->FIRSTFILEFOUND = FALSE ;

} /* proc ClobberDir */

/****	ClobberSel - delete all selected files in a branch and its twigs
**		This fn deletes selected files in the given directory and all of its
**	subdirectories.
**
**	ENTRY
**			tree - the tree
**			parent  - the parent directory of curr
**			curr - first file/directory belonging to parent
**	EXIT
**		none
**	WARNING
**		This fn does not ask for listboxes to be updated when it is done,
**	because the fn is assumed to be called in the middle of a fn where it is
**	not feasible to compact the whole tree.  At the end of the fn,
**	CompactifyTree should be called to delete the remaining files and cause
**	the listboxes to be redrawn.
*/
void ClobberSel(PTREE tree, PENTRY parent, PENTRY curr)
{
	PENTRY next;						// the next one to look at

	while (curr)
	{
		if (curr->nosib)
			next = NULL;
		else
			next = curr->sibling;

		// If directory, recurse; if normal file, maybe delete it.
		if (!(curr->attribs & _A_SUBDIR))
		{
			if (!curr->SELECTED)
				DelFileEntry(tree, parent, curr);
		} else
		{
			ClobberSel(tree, curr, curr->x.d.child);
		}
	
		curr = next;
	}
} /* proc ClobberSel */

/****	PackDirs - Move directory nodes to front of page list, free excess pages
**		This fn takes a tree which has no normal file records remaining.  It
**	puts all the remaining (directory) nodes into sequential records at the
**	front of the page list, and then frees any completely empty pages.
**
**	ENTRY
**			tree - tree to modify
**	EXIT
**			none
**	WARNING
**		There must not be any normal file nodes remaining.  The pointer
**	fixup portion expects only to deal with directory nodes.
*/
void PackDirs(PTREE tree)
{
	PPAGE freepage;						// page of unused slot
	PENTRY freeslot;					// unused slot
	PENTRY freebound;					// first record beyond the current page
	
	PPAGE dirpage;						// page of directory to move
	PENTRY dirslot;						// directory to move
	PENTRY dirbound;					// first record beyond the current page

	PENTRY prevdir;						// previous dir, in dnext order
	PENTRY parent;						// parent of directory
	PENTRY sib;							// previous sibling of directory
	PENTRY child;						// last child of directory
	PPAGE temppage;						/* temporary variable */

	freepage = tree->pagehead;
	if (!freepage)
		return;

#ifdef COMPACTCHECK
com1("In PackDirs\n") ;
#endif

	freeslot = freepage->files;
	freebound = freeslot+PAGESIZE;
	dirpage = freepage;
	prevdir = NULL;
	do {
		// Search for an open slot in this page.
		if (freeslot->name[0] == EOS)
		{
			// found an open slot; find the next directory node.
			if (freeslot < (freebound-1))
			{
				dirpage = freepage;
				dirbound = freebound;
				dirslot = freeslot+1;
			}
			else
			{
				dirpage = freepage->next ;
				if (dirpage)
				{
					dirslot = dirpage->files ;
					dirbound = dirslot + PAGESIZE ;
				}
			}
			
			while (dirpage)
			{
				if (dirslot->name[0])
				{
					/* Fix ptrs in records which point to this one.
					*/

					// Adjust parent/sibling pointers.
					parent = FindParent(dirslot);
					if (!parent)
					{
						if (tree->head == dirslot)
						{
							tree->head = freeslot;
						} else
						{
							sib = tree->head;
							while (sib->sibling != dirslot)
								sib = sib->sibling;
							sib->sibling = freeslot;
						}
					} else
					{
						if (parent->x.d.child == dirslot)
						{
							parent->x.d.child = freeslot;
						} else
						{
							sib = parent->x.d.child;
							while (sib->sibling != dirslot)
								sib = sib->sibling;
							sib->sibling = freeslot;
						}
					}

					// Adjust child pointer.
					child = dirslot->x.d.child;
					if (child)
					{
						while (!child->nosib)
							child = child->sibling;
						child->sibling = freeslot;
					}

					// Adjust x.d.dnext pointer.
					if (prevdir && prevdir->x.d.dnext == dirslot)
					{
						prevdir->x.d.dnext = freeslot;
					} else
					{
						prevdir = tree->FirstDirectory;
						while (prevdir && prevdir->x.d.dnext != dirslot)
							prevdir = prevdir->x.d.dnext;
						if (prevdir)
							prevdir->x.d.dnext = freeslot;
						else
							tree->FirstDirectory = freeslot;
					}
					prevdir = freeslot;

					if (tree->LastDirectory == dirslot)
						tree->LastDirectory = freeslot;

					if (tree->parent == dirslot)
						tree->parent = freeslot;

					if (tree->SelDir == dirslot)
						tree->SelDir = freeslot ;

					/* For the two trees that could be displayed */
					if (listinfo[0].files == dirslot)
						listinfo[0].files = freeslot ;

					if (listinfo[1].files == dirslot)
						listinfo[1].files = freeslot ;

					*freeslot = *dirslot;
					dirslot->name[0] =EOS;
					
					break;
				} else
				{
					dirslot++;
					if (dirslot >= dirbound)
					{
						dirpage = dirpage->next;
						if (dirpage)
						{
							dirslot = dirpage->files;
							dirbound = dirslot+PAGESIZE;
						}
					}
				}
			} /* end while (dirpage) */
		}

		if (dirpage)
		{
			freeslot++;
			if (freeslot >= freebound)
			{
				// no open slots in this page; try the next one.
				freepage = freepage->next;
				if (freepage)
				{
					freeslot = freepage->files;
					freebound = freeslot+PAGESIZE;
				}
			}
		} else
		{
			/* Couldn't find a directory to copy to the free slot we found,
			** so there aren't any more.  Free any filepages after the current
			** one because they contain no records.
			*/
#ifdef COMPACTCHECK
			if (!freepage)
			    com1("BOGOSITY--freepage is NULL!\n");
			else
			    com1("FREEPAGE IS OK\n");
#endif
			temppage = freepage ;

			freepage = freepage->next;
			while (freepage)
			{
				dirpage = freepage->next;
				FreeFarNormalized(freepage);
				freepage = dirpage;
			}

			temppage->next = NULL ;
		}
	} while (freepage);

	/* Now assign to pagetail the right page address, set holecount and
	   freeind correctly */

	tree->holecount = 0 ; /* No holes present as packing is tight now! */
	if (!tree->pagehead)
	{
		tree->pagetail = NULL ;
		tree->freeind = PAGESIZE ; /* => no free slots in last page as
										there is no last page!! */
	}
	else
	{
		/* assertion: tree->pagetail can't be NULL now! */
		for (tree->pagetail = tree->pagehead ; 
				(tree->pagetail->next) ; tree->pagetail = tree->pagetail->next)
			; /* Do Nothing */

		freeslot = tree->pagetail->files ; /* reuse of variable for start */
		freebound = tree->pagetail->files + PAGESIZE ; /* reuse again */

		for ( ; ( (freeslot < freebound) && (freeslot->name[0]) ) ; freeslot++)
			; /* Do Nothing */
		
		tree->freeind = (freeslot - (PENTRY) tree->pagetail->files) ;
	}
#ifdef COMPACTCHECK
com1("OUT PackDirs\n") ;
#endif

} /* proc PackDirs */

/* Given two trees -- It selects one of the two for compaction.
*
*  'ctree' -- the current candidate for compaction -- can be NULL.
*  'tree'  -- the new candidate for compaction.
*  This routine checks the drive types of the two and decides which one of
*  this is to be compacted.
*  Ram Drives are selected first of course...
*  Remote_Drives (network drives) are selected over any other type. Between 2
*	    remote_drives, 'ctree' is chosen instead of 'tree'.
*  Hard_Drives are selected next. Between 2 Hard_Drives 'tree' is chosen
*	    instead of 'ctree'.
*  Floppy_Drives are chosen last. Between 2 Floppy_Drives 'tree' is chosen
*	    instead of 'ctree'.
* The tie-breaking rule uses the fact that 'ctree' has a lexicographically
*   smaller alphabet that 'tree' -- that is the way the caller presently passes
*   in the arguments. The tie-breaking rule is just a nice heuristic I chose.
* BUG BUG this should be a macro
*/
PTREE ChooseCompactionTree(PTREE ctree, PTREE tree)
{
    PTREE ret_tree ;

    ret_tree = ( (
		 (!ctree) ||
		 (ctree->DriveType == FLOPPY_TYPE) ||
		 ((ctree->DriveType == HARDDISK_TYPE) &&
				    (tree->DriveType != FLOPPY_TYPE))
		 && (ctree->DriveType != RAMDRIVE_TYPE))
	       ) ? tree : ctree ;

    return ret_tree ;

} /* ChooseCompactionTree */

BOOL CompactOne(BOOL sel)
{
	PTREE tree, ctree;
	int i;
	BOOL ret;	  // return value of CompactifyTree

	ctree = NULL ;
	tree = glob.drives ;
	while (tree)
	{
	    if ( (!tree->Compacted) && (tree->Started) )
			ctree = ChooseCompactionTree(ctree, tree) ;
		tree = tree->next ;
	} /* while */

	if (!ctree)
	{
		/* ZZZZZZZ Change to SingleTree mode at this point!! If we are in
		   double tree mode junk the second tree */
		/* All trees are either compacted or not started. At this point
		    we try to totally get rid of trees that have been started but that
		    are not being displayed.
		*/
		tree = glob.drives ;
		while (tree)
		{
			/* ZZZ Assumption: We should move user out of DUAL tree mode at this
			 * point, if he is in one!
			 */
			if ( tree->Started && (listinfo[glob.FocusBox].tree != tree) )
			{
				if ( (glob.TreeMode == TR_DOUBLE) &&
											(listinfo[1-glob.FocusBox].tree == tree) )
				{
					listinfo[1-glob.FocusBox].tree = listinfo[glob.FocusBox].tree ;
					listinfo[1-glob.FocusBox].files = listinfo[glob.FocusBox].files ;
					glob.lineselected[1-glob.FocusBox] = glob.lineselected[glob.FocusBox] ;
				}

				JunkTree(tree) ;
				return TRUE ;
			}
			else
				tree = tree->next ;
		} /* while */

		return FALSE;
	}

#ifdef DBGBEEP
Beep() ; Beep() ; Beep() ; Beep() ;
#endif

	/* compact 'ctree' */
	ret = CompactifyTree(ctree, sel);

	/* If 'ctree' has already been completely read in and is being
	  displayed load the files belonging to the directory being displayed */
	/* If it is still being read in, LoadCompactDir will be done after
	   reading in all directories belonging to this tree */
	for (i = 0 ; i <= glob.MaxTree ; i++)
	{
		if ( (listinfo[i].tree == ctree) && (listinfo[i].tree->Started) &&
										(!listinfo[i].tree->ContinueTree) )
			if ( (i != 1) || (listinfo[1].tree != listinfo[0].tree) ||
								listinfo[0].files != listinfo[1].files )
				LoadCompactDir(listinfo[i].tree, listinfo[i].files) ;
	}

	return ret;
} /* proc CompactOne */

/* This routine frees up all the memory allocated to the FileManager that
 * was used to store the TREE/FILE PAGE information.
 */
void FreeFMMemory(void)
{
	PTREE tree, nexttree ;
	PPAGE page, nextpage ;

	for (tree = glob.drives ; tree ; tree = nexttree)
	{
		/* Free all file pages. */
		for (page = tree->pagehead ; page ; page = nextpage )
		{
			nextpage = page->next ;
			FreeFarNormalized(page);
		} /* file page loop */

		nexttree = tree->next ;

		/* free memory allocated to tree data structure */
		FreeWorkFar(tree) ;
	} /* tree loop */
} /* FreeFMMemory */

void CompactAll()
{
	PTREE tree;

	for (tree = glob.drives; tree; tree = tree->next)
		CompactOne(FALSE) ;
}

/* Function returns the index of the directory in dnext chain counting only
 * directories that are currently marked as being displayed in the dir listbox.
 */
unsigned GetIndexVisibleDir(PENTRY dir, PTREE tree)
{
	PENTRY temp ;
	unsigned count ;

	/* dir == NULL => root directory at index 0 */
	if (!dir)
		return 0 ;

	count = 1 ;
	/* Warning! dir should be a directory node in the tree, thus temp guaranteed
	   not to become NULL!!  */
	for (temp = tree->FirstDirectory ; temp != dir ; temp = temp->x.d.dnext)
	{
#ifndef NOCONSISTENCY
		if (!temp)
		{
			printf("*** GetIndexVisibleDir -- dir not found!!\n") ;
			exit(0) ;
		}
#endif
		if (temp->DISPLAYED)
			count++ ;
	} /* for */

	return count ;
} /* GetIndexVisibleDir */

/* Expands ancestors (parent, grand-parent, etc)  of 'dir', if necessary, to
 * make dir visible in the directory listbox.
 */
void MakeDirVisible(PENTRY dir, PTREE tree)
{
	PENTRY parent ;

	/* Root dir (i.e., dir == NULL) is always visible! If dir is a non-root
	 * dir, we handle it in the manner shown below.
	 */
	if (dir)
	{
		/* We need to see if the directory under consideration, namely,
	 	* listinfo[0].files, is visible, if not we should expand it's
	 	* parent's visibility and this could be recursive until we reach
	 	* a visible directory (Note that the root dir is always visible).
	 	*/
	 	if (!dir->DISPLAYED)
	 	{
			MakeDirVisible((parent = FindParent(dir)), tree) ; // recursion!
		
			/* Expand 'parent' by 1 level -- "FALSE" means just that! */
			ExpandDirVisibility(tree, parent, FALSE) ;
	 	}
	}
} /* MakeDirVisible */

/* Makes the directory that is 'selected' (the one that is supposed to have 
 * the tick mark) visible in the dir listbox. This is needed when we switch from
 * 'system' tree mode to single/double tree mode, so that the right directory
 * has the tick mark.
 */ 
void SetSelectedDirFocus(void)
{
	MakeDirVisible(listinfo[0].files, listinfo[0].tree) ;
	glob.lineselected[0] = 
					GetIndexVisibleDir(listinfo[0].files, listinfo[0].tree) ;
} /* SetSelectedDirFocus */


unsigned CountFilesToOperateOn(void)
{
	unsigned int ret ;
	unsigned long DummyDirSize ;

	if (FPerformOpOnDirFilesAlone())
	{
		GetDirInfo(listinfo[glob.FocusBox].files, listinfo[glob.FocusBox].tree,
								&DummyDirSize, &ret) ;
	}
	else
	{
		ret = listinfo[glob.FocusBox].tree->NumSel ;
	}
	return ret ;

} /* CountFilesToOperateOn */


/* We want to perform operations on files SELECTED that are in the
 * focus box and not all the files selected (say in DUAL TREE mode). This
 * function sets the bit FILEOPMARKER for all the files that we want to
 * operate on.
 */
void MarkFilesBeforeFileOp(void)
{
	PTREE tree ;
	PENTRY dir, temp ;
	PENTRY node ;

	tree = listinfo[glob.FocusBox].tree;

	if (FPerformOpOnDirFilesAlone())
	{
		/* First clear the 'FILEOPMARKER' bit for all files */
		for (node = tree->FirstFile ; node ; node = node->x.f.snext)
		{
			node->FILEOPMARKER = FALSE ;
		}
		
		/* Now set the 'FILEOPMARKER' bit for all files selected in 'dir' */
		dir = listinfo[glob.FocusBox].files ;
		temp = (dir) ? dir->x.d.child : tree->head ;
		while (temp)
		{
  			if (!(temp->attribs & _A_SUBDIR) )
			{
				if (temp->SELECTED)
					temp->FILEOPMARKER = TRUE ;
			}
			temp = (temp->nosib) ? NULL :	temp->sibling ;
		} /* while */
	}
	else
	{
		/* All SELECTED files need to be operated on! */
		for (node = tree->FirstFile ; node ; node = node->x.f.snext)
		{
			node->FILEOPMARKER = node->SELECTED ;
		}
	}
} /* MarkFilesBeforeFileOp */

/* Deselect all files in 'tree' that are marked as not matching the global
 * MatchPat. This is done because wer don't want the user accidentally
 * performing operations on files that he does not see in listboxes.
 * It returns a BOOL indicating whether any files were de-selected here.
 */
BOOL DeselectUnMatchedFiles(PTREE tree)
{
	unsigned int numsel ;
	PENTRY fil ;

	if (tree->NumSel == 0)
		return FALSE ;

	numsel = tree->NumSel ;
	for (fil = tree->FirstFile ; fil ; fil = fil->x.f.snext)
	{
		if (!fil->MATCHESPATTERN)
		{
			if (fil->SELECTED)
			{
				tree->NumSel-- ;
				tree->SizeSel -= fil->x.f.size ;
				fil->SELECTED = FALSE ;
			}
		}
	}

	return (numsel != tree->NumSel) ;

} /* DeselectUnMatchedFiles */



/* ZZZZZ It might be possible to combine some of the count functions, etc into
  one smart monolithic function.
*/

#if 0
/*  ZZZ unused fns! ***********************************************         */
unsigned int CountTotalFilesSelected(void)
{
      unsigned count ;

      count = listinfo[0].tree->NumSel ;

#ifdef DEBUG
      SelCountCheck(listinfo[0].tree) ;
#endif
      if ( (glob.MaxTree == 1) && (listinfo[1].tree != listinfo[0].tree) )
      {
#ifdef DEBUG
	      SelCountCheck(listinfo[1].tree) ;
#endif
	      count += listinfo[1].tree->NumSel ;
      }

    return count ;
} /* CountTotalFilesSelected */

/****	GetNthFile - get file from top level of branch
**	This fn gets the 'n'th file of the branch.  It does not search

**	in any subdirectories of the branch.
**
**	ENTRY
**		PENTRY dir;  directory whose nth file we need.
**		unsigned count; a value of 0 for first file & so on.
**	EXIT
**		ptr to requested file, or NULL if not found.
*/
/*  ZZZZZZ Previous optimizations using static stuff is gone */
/*  we can still do it if tree building is over!! */
PENTRY GetNthFile(PENTRY dir, int count, PTREE tree)
{
	PENTRY fil ;
	
	fil = dir ? GetFirstDirFile(dir) : GetFirstRootFile(tree) ;

	if (!fil)
		return NULL;
	
	for (; count > 0;count--)
	{
		if (fil->LASTDIRFILE)
			/* set the static pointer node before returning */
	 		return (NULL);
		fil = fil->x.f.snext ;
	}

	return(fil);

} /* proc GetNthFile */

/****	CountBranch - count number of files in a branch
**	This fn takes a chunk of a tree and counts the number of files, or
**	directories, or both, in it.
**
**	ENTRY
**		current - first node of branch to count
**		flags   - behavior modification, OR'ed together:
**			  CB_NORMAL  - count files
**			  CB_SUBDIR  - count directories
**			  CB_DESCEND - count things in subtrees too
**	EXIT
**		the number of files found
*/
unsigned CountBranch(current, flags)
PENTRY current;
unsigned flags;

{
	unsigned count=0;
	unsigned attr;
	
	if (!current)
		return 0;
	
	do
	{
		attr = current->attribs;
		if (attr & _A_SUBDIR)
		{
			if (flags & CB_SUBDIR)
				count++;
			if (flags & CB_DESCEND)
				count +=CountBranch(current->x.d.child,flags);
		} else
		{
			if (flags & CB_NORMAL)
				count++;
		}
		if (current->nosib)
			break;
		current = current->sibling;
	} while (1);
	
	return count;
}

/* Function returns the index of the directory in dnext chain */
unsigned GetIndexDir(PENTRY dir, PTREE tree)
{
	PENTRY temp ;
	unsigned count ;

	/* dir == NULL => root directory at index 0 */
	if (!dir)
		return 0 ;

	count = 1 ;
	/* Warning! dir should be a directory node in the tree, thus temp guaranteed
	   not to become NULL!!  */
	for (temp = tree->FirstDirectory ; temp != dir ; temp = temp->x.d.dnext)
	{
#ifndef NOCONSISTENCY
		if (!temp)
		{
			printf("*** GetIndexDir -- dir not found!!\n") ;
			exit(0) ;
		}
#endif
		count++ ;
	} /* for */

	return count ;
} /* GetIndexDir */

/*        ***********************************************         */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\lbox.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   lbox.c - routines directly supporting the File Mgr list boxes
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  7/13/89   t-jeffro  Header added to file.
**  7/17/89   t-jeffro  Replaced sprintf with individual calls.
**  7/19/89   t-jeffro  Selection in both list boxes is stable.  Installed
**                                              hack to make icons display properly.
**  7/22/89   scottq    made some optimizations to makefileline
**  10/?/89   harikris  Implemented System Tree mode.
**  10/?/89   harikris  changed all GetCount & GetNthFile routines.
**  11/?/89   harikris  wrote DisplayNoFilesMsg function
**  12/6/89   harikris  rewrote the two ListProc routines.
**
*/
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <icons.h>
#include <text.h>

/* INTERNATIONALIZE HERE! */
/* Indexes into the string that displays the info about the file */
#define NAMESTART       5
#define EXTSTART        14
#define SIZESTART       17
#define SIZESIZE        12
#define DATESTART       32
#define TIMESTART       (DATESTART+8+2)

#define ICONCACHEY (MAXCOLS * MAXROWS)
char far *gIconCache = NULL; /* pointer to array for short circuit draw icon */

extern BOOL gfManipulating ;

BOOL gNeedToUpdateFileList[2];

VOID Arrow(void);
extern BOOL GetLastKeyState(void);
extern BOOL FIsExecutableFile(char far *ext) ;

VOID ProgramCursor(void);

/*
 * Drawing Icons is really slow. So we never want to draw an icon
 * over itself while the user is scrolling a list box.
 * We remember what icon was last drawn at a location, and do not
 * draw it if it is already there. This will require that
 * some places invalidate the cache.
 */
void InitIconCache(void)
{
	register int j;
	if(gisgraph)
	{
	   if(gIconCache == NULL)
	   {
	   gIconCache = LpbAllocWorkFar(ICONCACHEY);
	   }
	   if(gIconCache == NULL)
	   return;
	   for(j=0;j<ICONCACHEY;j++)
	   {
		 gIconCache[j] = -1;
	   }
	}
} /* InitIconCache */

/*  Invalidate the cache entries in the rectangle specified by the 4 co-ords */
void InvalidateIconCache(AX axLeft, AY ayTop, AX axRight, AY ayBottom)
{
	AX x ;
	AY y ;

	if (gIconCache)
	{
		/* y-loop is the outer one and x-loop is the inner one for opt! */
		for (y = ayTop ; y <= ayBottom ; y++)
			for (x = axLeft ; x <= axRight ; x++)
				gIconCache[y*MAXCOLS+x] = -1 ;
	}
	/* else IconCache memory not allocated -- so can't update! */
} /* InvalidateIconCache */

#define ICONLEN 2                       // CheckMark icon len!
#define COLL_ICON_LEN   4       // Dir Icon len including the ' ' after it!

/* we use "-2" in following #define so that we discount the 2 cols lost to the
*       scroll bar to the right of the tree list box!
*/
#define TREELINELEN (TREEBOXWIDTH-ICONLEN-2)

#define FOCUS_CHAR      chRightArrow

/* The x-coord where the FOCUS MARKER character for the root dircetory will
 * be drawn.
 */
#define MAGICROOTX      1

/*  Draws the focus marker -- 
 *  In graphics mode:
 *              A rectangular box 1 char wide and 'len' long at rxGraphics, ryGraphics
 *  In text mode:
 *              FOCUS_CHAR at rxText, ryText in the isa color!
 *  isfocus, issel specify whether the line in question has focus, selection.
 */
void DrawFocusMarker(PWND pwnd, RX rxText, RY ryText, RX rxGraphics,
					RY ryGraphics, WORD len, BOOL isfocus, BOOL issel, ISA isa)
{
	WORD fore1,back1,fore2,back2;
	UnReferenced(issel) ;

	if (isfocus)
	{
		if (!gisgraph)
		{
			CharOut(pwnd, rxText, ryText, FOCUS_CHAR, isa);

			/* The focus marker character is being drawn at a different column
			 * for the root directory than for other directory lines, so
			 * we need to erase old character.
			 */
			if (rxText != MAGICROOTX)
				CharOut(pwnd, (RX) MAGICROOTX, ryText, ' ', isa);
		}
		else
		{
			// if (!issel) // WE DONT CARE IF IT IS SELECTED ANYMORE

			if(isfocus)
			{
				GetIsaColor(isa,&fore1,&back1);
				GetIsaColor(isaHilite,&fore2,&back2);
				if(fore1 == back2)
				{
					isa = (ISA) isaSelect;
				}
							
			}
				FrameCharRect(ryGraphics, rxGraphics,
					  ryGraphics+1, rxGraphics+len, 1,isa) ;
		}
	}
	else
		/* In Text mode, we need to erase any focus char left behind */
		if (!gisgraph)
			CharOut(pwnd, rxText, ryText, ' ', isa);
} /* DrawFocusMarker */

/* 'dirnode' is a directory node belonging to tree 'tree'. This routine
*  returns the character to be drawn on the screen in front of dir name.
*/
unsigned char GetCollapseChar(PTREE tree, PENTRY dirnode)
{
	unsigned char ch ;

	/* Note that tree->DirCount & tree->VisibleDirCount don't include the root
	 *  directory.
	 */
	if (!dirnode)
	{
		if (tree->DirCount == 0)
			ch = NOZOOM_CHAR ;
		else if (tree->VisibleDirCount == 0)
			ch = EXPANSION_CHAR ;
		else
			ch = COLLAPSE_CHAR ;
	}
	else
	{
		if (!dirnode->HASSUBDIRS)
			ch = NOZOOM_CHAR ;
		else if (dirnode->EXPANDED)
			ch = COLLAPSE_CHAR ;
		else
			ch = EXPANSION_CHAR ;                   
	}

	return ch ;
} /* GetCollapseChar */

/* Draw the collapsible/non-collapsible marker here! 'ch' is the character
*  that specifies whether a dir can be expanded, collapsed, etc.
*/
void DrawDirIcon(PWND pwd, RX x, RY y, char ch, ISA isa)
{
	BITMAP *pbitmap ;

	// A blank character at the end of the icon is needed both in graphics
	//  and text mode.
	CharOut(pwd, x+3, y, ' ', isa);
	InvalidateIconCache(x+3, y, x+3, y) ;
	
	if(gIconCache && (gIconCache[y*MAXCOLS+x] == ch))
		return;

	if (gisgraph)
	{
		switch (ch) 
		{
			case EXPANSION_CHAR :
				pbitmap = DirExpansionIcon ;
				break ;
			case COLLAPSE_CHAR:
				pbitmap = DirCollapseIcon ;
				break ;
			default:
				pbitmap = DirNoZoomIcon ;
		}
			
		PlotBmp(pbitmap, x*CWIDTH, y*CHEIGHT,isaBackground);
		if(gIconCache)
		{
			gIconCache[y*MAXCOLS+x] = ch;
		}

	}
	else
	{
		CharOut(pwd, x, y, COLLAPSE_LCHAR, isa);
		CharOut(pwd, x+1, y, ch, isa);
		CharOut(pwd, x+2, y, COLLAPSE_RCHAR, isa);
	}
} /* DrawDirIcon */

/* returns BOOL to indicate whether or not the mouse click which occured
*   at relative x-coordinate 'rx' corresponds to a click on the collapse
*   icon.
*/
BOOL FIconClick(PENTRY dirnode, int x)
{
	int xIconCenter ;
	int namelen ;
	char dirname[NAMELEN+EXTLEN+2] ;

	/* ZZZZZZ These magic numbers 5, 3, etc are used only in this routine
	 * So, we don't need #defines and they need to be changed only in this
	 * routine.
	 */
	if (!dirnode)
		xIconCenter = 3 ;
	else
	{
		/* We indent to the right by 3 for each additional level! */
		xIconCenter = (dirnode->dtlx.lx.level + 1) * 3 ;

		/* Given current setup, we can have 5 levels of directories without
		* clipping (dir list box is 35 cols wide now!). If it is different
		* we need to fix this routine.
		*/
		/* Could clipping have happened? */
		if (dirnode->dtlx.lx.level > 5)
		{
			namelen = Internal2Normal(dirname, dirnode->name) ;
			
			// The +2 is for the distance between Icon center and the dir name
			// Check if clipping actually happened!
			if ( (xIconCenter+2+namelen) > (ICONLEN+TREELINELEN-1) )
			{
				// Set XIconCenter so that above Boolean will be ==
				xIconCenter = ICONLEN+TREELINELEN-1-namelen-2 ;
			}
		}
	}
	return ( (x >= xIconCenter - 1) && (x <= xIconCenter+1) ) ;
} /* FIconClick */

extern VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen);
extern WORD gCnx;
/* 
 * called by disp.c and below to set up the path title in the file boxes
 */
VOID ListBoxPath(treehdr far *tree,PENTRY node,int whichtree)
{
	char pathstring[MAX_PATH+1];
	int dummylen ;
	/* titles are always less than 1/2 the screen, max 90 */
#define MAXFILETITLE 45
	static char filetitlebuf[MAXFILETITLE*2];
	char *filetitle = &filetitlebuf[(whichtree) * MAXFILETITLE];

	if (glob.TreeMode != TR_SYSTEM)
	{
		Tree2Path(tree, node, pathstring, &dummylen);
		MakeDirNameFit(pathstring,glob.MatchPat,filetitle,
									Get_List_Rect(&FileList[whichtree]).axRight -
										Get_List_Rect(&FileList[whichtree]).axLeft - 2);
	}
	else
	{
		/* In System Tree mode, we only display the MatchPat as listbox title */
		strcpy(filetitle, glob.MatchPat) ;
	}

	if(gCnx == cnxNull)
		SetTitle(&FileList[whichtree], filetitle) ;
}

BOOL    gEricStraubsShiftWish = FALSE; //shift+key makes tree update now
/****   ListProcTreeList - list proc for directory tree list box
**      This fn does all the normal things a listboxproc does.
**
**      ENTRY
**              tmc -   0 for upper (or only) list box
**                              1 for lower list box
**              tmm - message type
**              isz - listbox line number (for tmmSetFocus, tmmDrawItem)
**              x, y- absolute character position of the mouse click.
**              sz  - unused by this proc
**              bArg- flags, not used by this proc
**      EXIT
**              If tmm == tmmCount, then number of directories on the disc.
**              Otherwise, 0??.
**      EFFECTS:
**              if cross-directory selection is off, all the files in the old
**      directory will be deselected (unless they are also displayed in the other
**      file listbox).
*/
WORD PASCAL ListProcTreeList(WORD tmm, char *sz, WORD isz, TMC tmc, 
										WORD x, WORD y, WORD bArg)
{
	PWND pwnd;                      // window of the list box
	treehdr far *tree;              // which tree are we dealing with
	PENTRY dirnode;                 // new displayed directory
	PENTRY olddirnode;              // old displayed directory
	BOOL   fCollExp ;       // specifies whether a dir was expanded/collapsed!

	UnReferenced(sz) ;

	tree = listinfo[tmc].tree;

	/* Don't show tree list until the tree is completely read in.
	 * Sometimes, like in System Tree mode, we will have our listproc
	 * called even before we start reading the tree. 
	 */
	if ( (!tree->Started) || (tree->ContinueTree) )
		return 0 ; /* Not ready to draw -- say num of dirs is 0 */

	/* Even in SYSTEM_TREE mode, we do a ListBoxInit() on TreeListBox. At
	 * that time this proc may get called. So, do nothing in this case.
	 */
	if (glob.TreeMode == TR_SYSTEM)
		return(0) ; /* junk value */

	olddirnode = listinfo[tmc].files ;

	pwnd = Get_List_Window(&TreeList[tmc]);

	switch (tmm) {
		case tmmCount:
			// return tree->DirCount+1;
			return tree->VisibleDirCount+1;
#ifndef NODIRECT
#if 0
//we dont do this. too bad
		case tmmPickUp:
			 ProgramCursor();
			 break;
		case tmmDrop:
			 Arrow();
			 break;
#endif
#endif
		case tmmGetItemString:
			dirnode = (isz) ? GetNthVisibleDir(tree, isz) : NULL;
			if (dirnode)
				Internal2Normal(sz, dirnode->name) ;
			else {
				/* hack to get to root directory! on typing '\\' */
				/* INTERNATIONALIZE HERE!!!!! */
				*sz = '\\' ;
				*(sz+1) = '\0' ;
			}
			break ;

		case tmmActivate:
			/* treat tmmActivate's like tmmSelect -- Bug report didn't want
			 * us to open directories on "enter". To be windows compatible,
			 * we don't open directories on mouse double-click or enter.
			 * Now directories can be opened or closed only by using '+', '-'
			 * or mouse click on that icon!
			 */
			tmm = tmmSelect ;
		case tmmToggleSelect:
		case tmmSelect:

			/* Ignore select messages when one is direct manipulating */
			if (gfManipulating)
				return 0 ; // garbage

			if(sz==(char *)ISRANGESELECT)
			{
				gNeedToUpdateFileList[tmc]=TRUE;
				gEricStraubsShiftWish = TRUE; // shift causes immediate update
				break;
			}

			gNeedToUpdateFileList[tmc]=FALSE;

			if (isz > tree->VisibleDirCount)
			{
				return (0) ; /* garbage value */
			}

			/* Change directories and update the file listbox.  */
			dirnode = (isz) ? GetNthVisibleDir(tree, isz) : NULL;

			fCollExp = FALSE ;

			/* Did the user click on the icon portion of the dir line? */
			if ( (tmm == tmmActivate) || (FIconClick(dirnode, x)) )
			{
				// We want to treat a select on Collapse icon as tmmActivate.
				tmm = tmmActivate ; 
				switch(GetCollapseChar(tree, dirnode))
				{
					case EXPANSION_CHAR:
						/* Expand 1 level of dirnode's visibility. */
						ExpandDirVisibility(tree, dirnode, FALSE) ;
						fCollExp = TRUE ;
						break ;
					case COLLAPSE_CHAR:
						CollapseDirVisibility(tree, dirnode) ;
						fCollExp = TRUE ;
						break ;
					default:
						// Shell_Beep() ; /* can't expand/collapse! */
						break ;
				}
			}

			/* InsertListItem is "Asynchronous" -- meaning no drawing
				done until back in Idle Loop */
			InsertListItem(&TreeList[tmc], min(isz, glob.lineselected[tmc]));

			/* Update tree in other listbox too if we have collapsed or
			 * expanded a directory in the same tree.
			 */
			if (fCollExp && (glob.TreeMode == TR_DOUBLE) &&
											(tree == listinfo[1-tmc].tree) )
				InsertListItem(&TreeList[1-tmc], 0);

			glob.lineselected[tmc] = tree->SelLine = isz;

			// glob.FocusBox = tmc ; /* being done elsewhere */

			/* Unselect files in the old directory if cross-dir selection
			 * is not enabled and we need to do so!
			 */
			if ( (!glob.CrossDirSel) && (tree->NumSel > 0) &&
															(dirnode != olddirnode) )
			{
				// redisplay files in other listbox as we are looking to 
				// deselect files in the directory being displayed there.
				if ( (glob.TreeMode == TR_DOUBLE) && 
					 (listinfo[1-tmc].tree == tree) &&
					 (listinfo[1-tmc].files == olddirnode) )
				{
					listinfo[1-tmc].UpdateFiles = TRUE ;
				}

				DeselectDir(olddirnode, tree) ;
				
			} /* no crossdir selection */

			FileMgrStatusBar(tree,dirnode);
			ListBoxPath(tree,dirnode,tmc);

			if (tree->Compacted)
			{
				BOOL load ;
				BOOL kill ;

				/* If (olddirnode == dirnode), we don't have to load from disk */
				load = kill = (olddirnode != dirnode) ;

				/* Check if we are in double tree mode! */
				if (glob.MaxTree)
				{
					// Is the other tree displaying the same files as tree tmc?
					if ( (listinfo[1-tmc].files == olddirnode) &&
						 (listinfo[1-tmc].tree == tree) )
						kill = FALSE ;
					if ( (listinfo[1-tmc].files == dirnode) &&
						 (listinfo[1-tmc].tree == tree) )
						load = FALSE;
				}
					
#ifndef NOCONSISTENCY
				if (tree->ContinueTree)
				{
					printf("*** User clicked in the partially read in tree\n") ;
					exit(0) ;
				}
#endif
				if (kill)
					ClobberDir(tree, olddirnode);
				if (load)
					LoadCompactDir(tree, dirnode);
			} /* if tree is compacted */

			SortDirectory(tree, dirnode) ;

			listinfo[tmc].files = tree->SelDir = dirnode;

			if (dirnode != olddirnode)
				listinfo[tmc].UpdateFiles = TRUE;

			break;

		case tmmDrawItem:
			/* ZZZZ since this is the only invocation of MakeTreeLine, we
				probably don't need to pass in '0' for the x-coordinate */
#if 1
			MakeTreeLine(pwnd, tree, isz, (RX) 0, (RY) y,
						  bArg & TF_ISFOCUS,glob.lineselected[tmc] == isz);
#else
			/* We never show the selection line now */
			MakeTreeLine(pwnd, tree, isz, (RX) 0, (RY) y,
						  bArg & TF_ISFOCUS,FALSE);
#endif

			break;

		case tmmSetFocus:
		glob.lineselected[tmc] = isz;
			/* Update FM status bar on top of screen. */
			// FileMgrStatusBar(listinfo[tmc].tree, listinfo[tmc].files) ;
			gNeedToUpdateFileList[tmc] = TRUE;
		break;
#if 0
		case tmmDeselectAll:
			/* ignore these messages! */
#endif
		default:
			break;
	}
	return TRUE;
} /* proc ListProcTreeList */

extern BOOL gMouseDown;
BOOL AsynchUpdateTreeList(void)
{
	BOOL retval = TRUE;

	if(gEricStraubsShiftWish || GetLastKeyState())
	{
		if(gEricStraubsShiftWish || !fPollKeyboard)
		{
			if((gNeedToUpdateFileList[0])&&(!gMouseDown))
			{
				ListProcTreeList(tmmSelect,NULL,TreeList[0].focusitem,0,0,0,0); 
				retval = FALSE;
		 
			}
			if((gNeedToUpdateFileList[1])&&(!gMouseDown))
			{
				ListProcTreeList(tmmSelect,NULL,TreeList[1].focusitem,1,0,0,0); 
				retval = FALSE;
			}
		}
		gEricStraubsShiftWish = FALSE;
	}
	return(retval);
}

extern PENTRY glaunchnode ; // File node to be launched.
PTREE glaunchtree ; // the tree to which above node belongs.

extern BOOL gfActivate ;

/****   ListProcFileList - list box proc for current directory listbox
**
**
**      ENTRY
**
**      EXIT
**
**      WARNING:
**
**      EFFECTS:
**
*/
/* ZZZZZ static suff for optimizations have been removed!! as we are dynamically
inserting to snext chain in sorted order.       If tree has been built the
optimizations can be used */

extern void DoCUA2DeselectAll(TMC tmc) ;

VOID BeginManipulation(treehdr far *tree,PENTRY node);
VOID EndManipulation(void);
void Set_Task_Name(char far *name);
extern char *gpszNonSwap ;

WORD PASCAL ListProcFileList(WORD tmm, char *sz, WORD isz, TMC tmc, 
												WORD x, WORD y, WORD flags)
{
   PWND pwd;                            /* Window of list box                                   */
   RX xval;                                     /* x val of left edge of list box       */
   treehdr far *tree;
   PENTRY node; 
	char pName[15];


	UnReferenced(sz) ;
	UnReferenced(x) ;

	tree = listinfo[tmc].tree;

	/* Don't show file list until the tree is completely read in.
	 * Sometimes, like in System Tree mode, we will have our listproc
	 * called even before we start reading the tree. 
	 */
	if ( (!tree->Started) || (tree->ContinueTree) )
		return 0 ; /* Not ready to draw -- say num of files is 0 */

	/* The tree needs to be sorted before we display it.                  */
	/* This is done the first time, we get here for 'tree'. Note that */
	/* we do it here, as we don't sort as soon as the tree is read-in */
	/* Background sorting is not advisable as it might take a while.  */
	if (tree->SortRequired)
	{
		if (glob.TreeMode == TR_SYSTEM)
		 {
			SystemSort(listinfo[0].tree, TRUE) ;
		 }
		else
#ifdef OLDCOMPLETETREESORT
			FormDirectoryOrder(tree, TRUE) ;
#else
			/* sort root directory and viewed dir alone at start up!! */
			SortDirectory(tree, NULL) ; 
			SortDirectory(tree, listinfo[tmc].files) ;

			/* The very first time when we come in here, we need to send a
			 * Select message to the file listbox after directories are sorted.
			 * Fake it by sending a ' ' key. Do this in implicit mode alone.
			 */
			if (FileList[tmc].mode)
				ListKey(&FileList[tmc], ' ', 0);
#endif
	}

	xval = Get_List_Rect(&FileList[tmc]).axLeft +1;
	pwd = Get_List_Window(&FileList[tmc]);

	switch (tmm) {
		case tmmCount:
			return ( (glob.TreeMode == TR_SYSTEM) || 
					 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ? 
						/* ZZZZ Store following with tree for speed!! */
						CountTreeMatchedFiles(tree) :
						CountDirMatchedFiles(listinfo[tmc].files, tree);
#ifndef NODIRECT
		case tmmPickUp:
			 node = ( (glob.TreeMode == TR_SYSTEM) ||
					 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ? 
					GetNthFlatMatchedFile(tree, isz) :
					GetNthMatchedFile(listinfo[tmc].files, isz, tree);

			 BeginManipulation(tree,node);
			 break;
		case tmmDrop:
			 EndManipulation();
			 break;
#endif
		case tmmActivate:
			gfActivate = TRUE ; // launch file because of an activate message. 

			glaunchnode = ( (glob.TreeMode == TR_SYSTEM) ||
					 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ? 
					GetNthFlatMatchedFile(tree, isz) :
					GetNthMatchedFile(listinfo[tmc].files, isz, tree) ;
			if(!glaunchnode)
				break;
			glaunchtree = tree ;
#ifndef NOSWITCHER
			Internal2Normal(pName,glaunchnode->name);
		  Set_Task_Name(pName);
#endif
			LaunchBox();
			break;

		case tmmDeselectAll:
			if (gfManipulating)
				return 0 ; // garbage ;

			DoCUA2DeselectAll(tmc);
			break;

		case tmmGetItemString:
			node = ( (glob.TreeMode == TR_SYSTEM) ||
					 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ? 
					GetNthFlatMatchedFile(tree, isz) :
					GetNthMatchedFile(listinfo[tmc].files, isz, tree) ;
			if (node)
				Internal2Normal(sz, node->name) ;
			else
				*sz = '\0' ;
			break ;

		case tmmImplicit:
			Set_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL,TK_DISABLED);
			MessageBar(gpszNonSwap, isaMenu,TRUE);
			break ;

		case tmmExplicit:
			Set_KeyWord_Assignment(TK_SAVESTATE,TK_EXPLICITSEL,TK_ENABLED);
			MessageBar(gpszNonSwap, isaMenu,TRUE);
			break ;

		case tmmToggleSelect:
		case tmmDeSelect:
		case tmmSelect:
			if (gfManipulating)
				return 0 ; // garbage ;

		case tmmQuerySelect:
		case tmmDrawItem:
			node = ( (glob.TreeMode == TR_SYSTEM) ||
					 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ? 
					GetNthFlatMatchedFile(tree, isz) :
					GetNthMatchedFile(listinfo[tmc].files, isz, tree) ;
			if (!node) 
			{
				/* don't draw on any message but the tmmDraw message */
				if (tmm == tmmDrawItem)
					DisplayNoFilesMsg(pwd, tmc, xval, y, isz, flags, tree) ;
				return 0; /* junk value */
			}

			if(tmm == tmmQuerySelect)
				return(node->SELECTED);

			if(tmm==tmmSelect || tmm==tmmToggleSelect || tmm==tmmDeSelect)
			{
				/* following stuff is not used any more as our focus/selection
				 * drawing mechanism has changed.
				 */
				// flags |= TF_ICONONLY;         /* only repaint icon */
				if(tmm == tmmToggleSelect)
				{
				   if (node->SELECTED)
				   {
					   tree->NumSel-- ;
					   tree->SizeSel -= node->x.f.size ;
				   }
				   else
				   {
						tree->NumSel++ ;
						tree->SizeSel += node->x.f.size ;

				   }
				   /* Toggle the file's selection bit. */
				   node->SELECTED ^= 1;
				}
				else if(tmm == tmmDeSelect) {
				   if(node->SELECTED) {
					   tree->NumSel-- ;
					   tree->SizeSel -= node->x.f.size ;
					   node->SELECTED ^= 1;
				   }
				}
				else /* not toggle */
				if (!(node->SELECTED))
				{
				   tree->NumSel++ ;
				   tree->SizeSel += node->x.f.size ;
				   /* set the file's selection bit */
				   node->SELECTED ^= 1;
				}

				/* If same dir is in both file listboxes, update both */
				if ( (glob.TreeMode == TR_DOUBLE) && 
					(listinfo[0].tree == listinfo[1].tree) &&
					(listinfo[0].files == listinfo[1].files) )
				{
					InsertListItem(&FileList[1-tmc], 0);
				}

			} /* tmm == tmmSelect or tmmToggleSelect or tmmDeSelect */
			else
			{
				/* On tmmcSelect, don't draw!! tmmDraws will follow!! */
				if (glob.TreeMode != TR_SEARCH)
					MakeFileLine(pwd, node, (RX) xval, (RY) y, flags, tree);
				else
					MakeSearchLine(pwd, node, (RX) xval, (RY) y, flags, tree);
			}
			break ;

		case tmmSetFocus:
		default:
			break ;

	} /* switch */

	return 0 ;
} /* ListProcFileList */

/****   MakeTreeLine - create given line for the tree listbox
**      This routine is called once for each line in the directory tree list
**      box.  It fetches the 'line'th directory of 'tree' in depth-first
**      order, and builds the listbox line associated with it.  It then
**      displays it.
**
**      ENTRY
**              pwd     - window to output to
**              tree    - points to tree structure
**              line    - line you want, or -1 for last
**              x, y    - character position to display line.
**              isfocus - TRUE if this is our current directory.
**      EXIT
**              Returns TRUE if line was valid, else FALSE.
*/
BOOL MakeTreeLine(PWND pwd, PTREE tree, int line, RX x, RY y, 
									BOOL isfocus, BOOL ischecked )
{
	int i, index;
	PENTRY node;                            // directory under consideration
	PENTRY walk;                            // used for tree traversal
	char lines[MAXNODE+1];          // '|' or space for each ancestor
	char str[(MAXNODE+1)*3+1];      // string to be displayed
	char dirname[NAMELEN+EXTLEN+2];
	int namelen ;
	int cliplimit ;

	/* ZZZZ look into not handling line == 0 differently than the rest! */
	if (!line)
	{
		strfcpy(str, tree->root);
		index = strlen(str);

		/* Draw the collapsible/non-collapsible marker here! */
		DrawDirIcon(pwd, x+ICONLEN, y, GetCollapseChar(tree, NULL), 0) ;

		// Draw directory name, highlighted if necessary.
		TextOut(pwd, x+ICONLEN+COLL_ICON_LEN, y, str, index,
					isfocus?isaHilite:(ischecked?isaSelect:isaBackground)) ;
		// The InvalidateInconCache() for this has been taken care of below!

		/* The number '3' is the length of root name ex: "C:\" */
		DrawFocusMarker(pwd, 1, y, x+ICONLEN+COLL_ICON_LEN, y, 3, isfocus,
													ischecked, isaBackground) ;
		// Erase rest of line.
		index += COLL_ICON_LEN ;
		for (i=0; i < TREELINELEN-index; i++)
			str[i] = ' ';
		TextOut(pwd, (RX) x+index+ICONLEN, y, str, TREELINELEN-index, isaBackground);
		InvalidateIconCache((AX)x+ICONLEN+COLL_ICON_LEN, y,
										(AX)x+ICONLEN+TREELINELEN-1, y) ;
		return TRUE;
	} else
	{
		node  = GetNthVisibleDir(tree, line);
	}
	if (!node)
	{
		for (i=0; i < TREELINELEN+ICONLEN-1+1; i++)
				str[i] = ' ';

		/* BUG BUG this has been overridden, now we always do like text */
		/* In Text mode, draw a blank line starting at column 1 of screen,
		 * so as not to erase the border character we draw at column 0.
		 * In graphics mode, we use column 0 too to erase check mark trails.
		 */
		TextOut(pwd, (RX) 1, y, str, TREELINELEN+ICONLEN-1,isaBackground);
		InvalidateIconCache((AX)1, y,
					(AX)1+TREELINELEN+ICONLEN-1-1, y) ;
		return FALSE;
	}
	
	/* Convert name from internal form to NAME.EXT form */
	namelen = Internal2Normal(dirname, node->name) ;

	/* For each ancestor of the directory, we need to use the appropriate
	* graphics character in the string to give the listbox a tree-like
	* appearance. This means a vertical line if the ancestor has siblings
	* after it, or a blank otherwise.
	*/
	index = 0;
	walk = FindParent(node);
	while (walk)
	{
		if (walk->LASTDIR)
			lines[index] = ' ';
		else
			lines[index] = VERTLINE;
		index++;
		walk = FindParent(walk);
	}
	
	/* Now fill string with the characters in proper order (they are backwards
	 * now).
	 */
	i = 0;
	while (--index >= 0)
	{
		str[i++] = ' ' ;
		str[i++] = lines[index];
		str[i++] = ' ' ;
	}
	
	// add an extra blank to center 'node' wrt its predecessor directory.
	str[i++] = ' ' ;

	/* The '-2' is for the two special characters we add later for node */
	cliplimit =  TREELINELEN - namelen - COLL_ICON_LEN - 2 ;

	/* Is clipping needed? */
	if (i > cliplimit)
	{
		i = cliplimit ;
		str[i++] = ' ' ;
		//str[i++] = chLeftArrow ;
		str[i++] = ' ' ;
	}
	else
	{
		/* Add special chars for node itself, and display the string.*/
		if (node->LASTDIR)
			str[i++] = LLCORNER;
		else
			str[i++] = MIDLEFT;

		str[i++] = HORIZLINE;
	}

	
	TextOut(pwd, x+ICONLEN, y, str, i, isaBackground);
	InvalidateIconCache(x+ICONLEN, y, x+ICONLEN+i-1, y) ;

	DrawDirIcon(pwd, x+i+ICONLEN, y, GetCollapseChar(tree, node), 0) ;

	/* Display directory name in highlight mode; add trailing blanks to
	* supress any leftover chars to the right of the name.
	*/
	TextOut(pwd, x+i+ICONLEN+COLL_ICON_LEN, y, dirname, namelen,isfocus?isaHilite:(ischecked?isaSelect:isaBackground));
	InvalidateIconCache(x+i+ICONLEN+COLL_ICON_LEN, y, 
						x+i+ICONLEN+COLL_ICON_LEN+namelen-1, y) ;

	DrawFocusMarker(pwd, 2, y, x+i+ICONLEN+COLL_ICON_LEN, y, namelen, isfocus,
												ischecked, isaBackground) ;

	index = x + i + ICONLEN + COLL_ICON_LEN + namelen ;

	i = TREELINELEN + ICONLEN - index ; // Number of padding blanks

	if (i > 0)
	{
		for ( --i ; i >= 0 ; i--)
			str[i] = ' ';

		TextOut(pwd, (RX)index, y, str, TREELINELEN+ICONLEN-index, isaBackground);
		InvalidateIconCache((AX)index, y, (AX)(TREELINELEN+ICONLEN-1), y) ;
	}
	/* else no padding required */

	return TRUE;
} /* proc MakeTreeLine */

/* Caller takes responsibility to disable the mouse & re-enable it */

void DrawFileIcon(BOOL progfile, BOOL sel, PWND pwnd, RX x, RY y)
{
	BITMAP *pbitmap ;

	if (gisgraph)
	{
		/*
		 * check the icon cache to see if we should
		 * really do some drawing here
		 */
		if (gIconCache && 
				(gIconCache[y*MAXCOLS+x] == (char)((progfile<<1)|(sel))))
			return;

		if (sel)
		{
			pbitmap = (progfile) ? ProgramIconInvert : FileIconInvert;
		} else
		{
			pbitmap = (progfile) ? ProgramIcon : FileIcon ;
		}
		PlotBmp(pbitmap, (x+1)*CWIDTH, (y)*CHEIGHT,isaBackground);
		/*
		 * set the icon we just drew in the IconCache
		 */
		if(gIconCache)
		   gIconCache[y*MAXCOLS+x] = (char)((progfile<<1)|(sel));
	} else
	{
		if (sel)
			CharOut(pwnd, x+3, y, SELCHAR, 0);
		else
			CharOut(pwnd, x+3, y, ' ', 0);
	}
} /* DrawFileIcon */


/****   MakeFileLine - Make line of Files list box
**      This fn is called once for each line in the listbox containing the
**      current directory files.  It locates the 'line'th file of the current
**      directory, then builds a string with the file's name, size, and
**      access date and displays it; it also displays either a program or data
**      file icon.
**
**      ENTRY
**              pwnd  - window to write line to
**              node  - record of file to display
**              x, y  - character position of beginning of line
**              flags:
**                  bit 0: 1 = selected, 0 = unselected
**                  bit 1: 1 = draw icon only, 0 = draw text and icon
**      EXIT
**              Return Val: TRUE if found, else FALSE
**      NOTE:
**          The date format is currently hard-coded for USA format.  We need
**      to have it look at country info and act accordingly.
*/

/* Indices in string
*/
/* Flat File listbox length > Normal File box length -- so we use
   this bigger buffer in either case for blanking out buffer!! */
#define FLATLINELEN     (FLATRIGHTWIDTH-4)
#define FILELINELEN     (FILEBOXWIDTH-4)

/*  The Top Left relative co-ordinates in MainWind where the first character
	of fileinfo is placed. */
#define SYSTEMLEFTX 2
#define SYSTEMLEFTY 7

BOOL MakeFileLine(PWND pwnd, PENTRY node, RX x, RY y, WORD flags, PTREE tree)
{
	int i,j;
	BOOL progfile;                                                  // TRUE = executable file
	BOOL fispm = TRUE ;
	/* % is ok in the expression below as it is a constant expression! */
	char str[1+FLATLINELEN+((FLATLINELEN+1)%2)]; // length must be even
	WORD DrawLen ;  

	/* ZZZ I hope the compiler optimizes all the /, %, >> */

	/* make string of all blanks - this way I don't have a while loop
	** for each possible gap in the string.
	*/
	for (i=0; i < FLATLINELEN; i+=2)
	{
		*(WORD *)&str[i] = 0x2020;
	}

	DrawLen = (glob.TreeMode == TR_SYSTEM) ? FLATLINELEN : FILELINELEN ;

	/* If there is no file for this line, clear the line.  */
	if (node == NULL)
	{
		// FEnableMouseNest(FALSE);
		TextOut(pwnd, x, y, str, DrawLen, isaBackground);
		// FEnableMouseNest(TRUE);
		/* Invalidate the Icon cache for this line. */
		InvalidateIconCache(x, y, x+DrawLen-1, y) ;
		return FALSE;
	}

	/* Add extension to string. We always do this, cause we test it later */
	if (node->name[NAMELEN])
	{
		/* copy extension */
		str[EXTSTART-1] = '.';
		for (i=EXTSTART, j=NAMELEN; j<NAMELEN+EXTLEN && node->name[j]; i++,j++)
			str[i] = node->name[j];
	}

	/* Add name to string.  */
	for (i=NAMESTART, j=0; j < NAMELEN && node->name[j]; i++, j++)
		str[i] = node->name[j];
	
	/* Add file size to string. */
	CopyNumberForTextOut(str+SIZESTART+SIZESIZE, node->x.f.size, FALSE) ;
	
	/* Add date to string */
	Get_Date_and_Time_Strings(node->dtlx.dt.date, node->dtlx.dt.time,
		str+DATESTART, str+TIMESTART, 0);

	/* Compute icon type to display. We now use a program icon for BAT's too */
#if 0
	progfile = (((*(DWORD *)&str[EXTSTART])) == *(DWORD *)ExeStr) ||
			   (((*(DWORD *)&str[EXTSTART])) == *(DWORD *)ComStr) ;
#else
	progfile = FIsExecutableFile(str+EXTSTART) ;
#endif

	/* Now put (text and) icon onscreen. */
	// FEnableMouseNest(FALSE);

	TextOut(pwnd, x+NAMESTART, y, str+NAMESTART, DrawLen-NAMESTART,
							(flags & TF_ISFOCUS)?isaHilite:((BOOL)node->SELECTED?isaSelect:isaBackground));
	DrawFocusMarker(pwnd, x+1, y, x+NAMESTART, y, DrawLen-NAMESTART,
					 flags & TF_ISFOCUS, (BOOL) node->SELECTED, isaBackground) ;
	DrawFileIcon(progfile, (BOOL)node->SELECTED, pwnd, x, y) ;

	/* Node has been selected / deselected => selected info on system tree
	   mode on left needs to be updated or it has focus  */
	if (glob.TreeMode == TR_SYSTEM)
	{
		if (flags & TF_ISFOCUS)
		{
			DispFlatLeft(node, tree, &MainWind, SYSTEMLEFTX, SYSTEMLEFTY,
										isaBackground) ;
			FileMgrStatusBar(tree, FindParent(node)) ;
		}
		else
		if (!gfFlatLeftInfoDrawn)
		{
			/* ZZZZZ should this be set here or in DispFlatLeft fn?? */
			gfFlatLeftInfoDrawn = TRUE ;

			/* Draw the first file -- index 0 if we haven't yet drawn the
			 * the flatleft info for any file as yet -- This could happen
			 * if the focus has not yet come to the file list box.
			 */
			// node = GetNthFlatMatchedFile(tree, 0) ;
			node = GetNthFlatMatchedFile(tree, Get_List_Focus(&FileList[0])) ;
			DispFlatLeft(node, tree, &MainWind, SYSTEMLEFTX, SYSTEMLEFTY,
										isaBackground) ;
			FileMgrStatusBar(tree, FindParent(node)) ;

		}
	}

	// FEnableMouseNest(TRUE);
	
	return TRUE;
} /* proc MakeFileLine */

#define SEARCHLINELEN (SEARCHWIDTH-4)

BOOL MakeSearchLine(PWND pwnd, PENTRY node, RX x, RY y, WORD flags, PTREE tree)
{
	int i;
	BOOL progfile;                                                  // TRUE = executable file
	int dummylen ;

	/* % is ok in the expression below as it is a constant expression! */
	char str[MAXCOLS]; // length must be even

	/* ZZZ I hope the compiler optimizes all the /, %, >> */
	/* make string of all blanks - this way I don't have a while loop
	** for each possible gap in the string.
	*/
	for (i=0; i < SEARCHLINELEN; i+=2)
	{
		*(WORD *)&str[i] = 0x2020;
	}

	/* If there is no file for this line, clear the line.  */
	if (node == NULL)
	{
		// FEnableMouseNest(FALSE);
		TextOut(pwnd, x, y, str, SEARCHLINELEN, isaBackground);
		// FEnableMouseNest(TRUE);
		/* Invalidate the Icon cache for this line. */
		InvalidateIconCache(x, y, x+SEARCHLINELEN-1, y) ;
		return FALSE;
	}

	/* Add name to string. */
	Tree2Path(tree, node, str+NAMESTART, &dummylen) ;

	/* Compute icon type to display. We now use a program icon for BAT's too */
#if 0
	progfile = !( fstrncmp(ExeStr, node->name+NAMELEN, 3) &&
				  fstrncmp(ComStr, node->name+NAMELEN, 3) ) ;
#else
	progfile = FIsExecutableFile(node->name+NAMELEN) ;
#endif

	/* Now put (text and) icon onscreen.  */
	// FEnableMouseNest(FALSE);

	TextOut(pwnd, x+NAMESTART, y, str+NAMESTART, SEARCHLINELEN-NAMESTART,
								  (flags & TF_ISFOCUS)?isaHilite:(((BOOL)node->SELECTED?isaSelect:isaBackground))) ;
	DrawFocusMarker(pwnd, x+1, y, x+NAMESTART, y, SEARCHLINELEN-NAMESTART,
					 flags & TF_ISFOCUS, (BOOL) node->SELECTED, isaBackground) ;

	DrawFileIcon(progfile, (BOOL)node->SELECTED, pwnd, x, y) ;

	// FEnableMouseNest(TRUE);
	
	return TRUE;
} /* proc MakeSearchLine */

/* Puts up the meassage no files present or no files match in file listbox */
void DisplayNoFilesMsg(PWND pwd, TMC tmc, RX xval, WORD y, WORD isz, 
								WORD flags, PTREE tree)
{
	/* strings to show when no files displayed */
	char *messagestr1, *messagestr2;
	PENTRY node ;

	/* Following variable is used to reduce code size. See assignment below!! */
	int (*linedrawfn)(PWND, PENTRY, RX, RY, WORD, PTREE) ;

	/*Depending on mode, we need to call the right fn. Store now to use later*/
	linedrawfn = (glob.TreeMode != TR_SEARCH) ? MakeFileLine : MakeSearchLine ;
	
	switch(isz) {
	case 0 :
		if ( (glob.TreeMode != TR_SYSTEM) &&
			 (glob.TreeMode != TR_SEARCH) &&
			 (CountDirFiles(listinfo[tmc].files,tree) == 0)
		   )
		{
			messagestr1 = szNoFilesPresent1;
			messagestr2 = szNoFilesPresent2;
		}
		else
		{
			messagestr1 = szNoFilesMatch1;
			messagestr2 = szNoFilesMatch2;
		}

		/* Blank out this line and subsequent line -- Calling MakeFileLine or
		   MakeSearchLine with node = NULL, blanks out that line! */
	
		(*linedrawfn)(pwd, NULL, (RX) xval, (RY) y, flags, tree);
		(*linedrawfn)(pwd, NULL, (RX) xval, (RY) y+1, flags, tree);
		(*linedrawfn)(pwd, NULL, (RX) xval, (RY) y+2, flags, tree);

		/* Draw in place of subsequent lines (line 1, line2) */
		TextOut(pwd, (RX)xval+NAMESTART, (RY)y+1,messagestr1, -1, isaBackground);
		TextOut(pwd, (RX)xval+NAMESTART, (RY)y+2,messagestr2, -1, isaBackground);

		/* DispFlateLeft has to be called here with NULL node, as MakeFileLine
		   in System Tree mode handles cases only when node != NULL */
		if (glob.TreeMode == TR_SYSTEM)
			DispFlatLeft(NULL, tree, &MainWind, SYSTEMLEFTX, SYSTEMLEFTY,
											isaBackground) ;
		break ;

	case 1:
	case 2:
		node = ( (glob.TreeMode == TR_SYSTEM) ||
				 ( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ?
					GetNthFlatMatchedFile(tree, 0) :
					GetNthMatchedFile(listinfo[tmc].files, 0, tree) ;

		/* See above (isz == 0) -- the line 0 msg had 2 lines drawn
		 * for "No files ..." msg in line 1 and 2!
		 */
		if (!node)
			break ;
		/* else flow thru and clear this line!! */

	default:
		/* This function, when called with NULL, blanks out that line */
		(*linedrawfn)(pwd, NULL, (RX) xval, (RY) y, flags, tree);
	} /* switch */

#ifndef NOCONSISTENCY
	if (y < 6)
	{
		printf("**** Bug!! -- Bad draw message\n") ;
		exit (0) ;
	}
#endif
} /* DisplayNoFilesMsg */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\listbox.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   listbox.c - list box manager routines
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  7/??/89   scottq    wrote all the functions
**  7/20/89   t-jeffro UserListProc now calls the listproc with proper x,y
**                      coords instead of filler.
**  7/21/89   scottq    made UserListProc go away, now called directly
*/
#include <common.h>
#include <icons.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>

#define NOFILECLICKED (0)
#define DESELFILEONMOUSEUP (1)
#define DESELALLONMOUSEUP (2)
#define NOACTIONONMOUSEUP (3)

int  NextFocusLineChange(ListBoxData *,int);

extern BYTE gMouseX, gMouseY; /* this is here for slime with the scroll bar */
extern BYTE gMouseDownX, gMouseDownY;
extern WORD gCnx;
extern VOID     MySetColor(WORD color);

WORD gListKeyDelay = 18;


/*  NAME
 *      CalcBarRect
 *  DESCRIPTION
 *      Calculates the graphical absolute rectangle for the scrollbar belonging
 *      to the list.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *      RECT* is a near pointer to the destination rectanble
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *      none
 *  COMMENTS
 *      Note that this calculates the rectangle in pixels, not characters!
 *  WARNINGS
 *  HACKS
 */

VOID CalcBarRect(ListBoxData *TestList,RECT *br)
{
#ifdef CUA1
    br->yTop   = (TestList->scroll.rect.ayTop+2)*CHEIGHT;
    br->yBottom= (TestList->scroll.rect.ayBottom-2)*CHEIGHT;
    br->xLeft  = TestList->scroll.rect.axLeft*CWIDTH;
    br->xRight = TestList->scroll.rect.axRight*CWIDTH;
#else
    br->yTop   = (TestList->scroll.rect.ayTop+1)*CHEIGHT;
    br->yBottom= (TestList->scroll.rect.ayBottom-1)*CHEIGHT;
    br->xRight = TestList->scroll.rect.axRight*CWIDTH;
    if(gisgraph)
	br->xLeft  = TestList->scroll.rect.axLeft*CWIDTH;
    else
	br->xLeft = br->xRight-1;
#endif
}

/*  NAME
 *      CalcThumbRect
 *  DESCRIPTION
 *      Calculates the graphical absolute rectangle for the scrollbar thumb
 *      belonging to the listbox.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *      RECT* is a near pointer to the destination rectanble
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *      none
 *  COMMENTS
 *      Note that this calculates the rectangle in pixels, not characters!
 *  WARNINGS
 *  HACKS
 */

VOID CalcThumbRect(ListBoxData *TestList,RECT *tr)
{
#ifdef CUA1
    WORD theight;
    if (TestList->scroll.maxvalue <= 0)
    {
       tr->yTop   = (TestList->scroll.rect.ayTop+2) * CHEIGHT;
       tr->yBottom= (TestList->scroll.rect.ayBottom-2) * CHEIGHT;
    }
    else
    {
       theight = (WORD)(((long)((TestList->rect.ayBottom-TestList->rect.ayTop-4)*
		 (TestList->rect.ayBottom-TestList->rect.ayTop-4) * CHEIGHT))/
		 (TestList->scroll.maxvalue+TestList->numlinesonscreen));
       if (gisgraph)
       {
	  if (theight <= 10)
	       theight = 10;
       }
       else
       {
	  if (theight <= 1)
	       theight = 1;
       }
       tr->yTop =(WORD)((TestList->scroll.rect.ayTop+2)*CHEIGHT+
		 ((long)TestList->scroll.value*
		 ((long)(TestList->scroll.rect.ayBottom-
		 TestList->scroll.rect.ayTop-4)*CHEIGHT-theight))/
		 TestList->scroll.maxvalue);
       tr->yBottom = tr->yTop + theight;
    }
    tr->xLeft = (TestList->scroll.rect.axLeft)*CWIDTH+1;
    tr->xRight= (TestList->scroll.rect.axRight)*CWIDTH-1;
#else
    WORD theight;
    DWORD ttop;
    //theight = CHEIGHT;

    if (TestList->scroll.maxvalue <= 0)
    {
       tr->yTop   = (TestList->scroll.rect.ayTop+1) * CHEIGHT;
       tr->yBottom= (TestList->scroll.rect.ayBottom-1) * CHEIGHT;
    }
    else
    {

       theight = (WORD)(((long)((TestList->rect.ayBottom-TestList->rect.ayTop-2)*
		 (TestList->rect.ayBottom-TestList->rect.ayTop-2)))/
		 (TestList->scroll.maxvalue+TestList->numlinesonscreen));

	  if (theight <= 1)
		   theight = 1;

	  tr->yTop =(TestList->scroll.rect.ayTop+1)*CHEIGHT;

	  if(TestList->scroll.maxvalue != 0)
	  {
	      /* In order to get the scroll bar to appear to work
	       * smoothly, we cheat here so that the thumb will
	       * always align with mouse cursor, even though
	       * the correlation of the thumb and the scrolledness
	       * will be off
	       * This may cause the thumb to jump after the user
	       * lets go of the thumb.
	       * Not so easy at it seems to get this to work well!
	       */
	       if(TestList->scroll.dragging &&
		   gMouseY>TestList->scroll.rect.ayTop+
		       TestList->scroll.mouseoffset &&
		   (int)gMouseY<(int)(TestList->scroll.rect.ayBottom-
		       (int)theight-(int)TestList->scroll.mouseoffset) &&
		   gMouseX>=TestList->scroll.rect.axLeft-1 &&
		   gMouseX<TestList->scroll.rect.axRight+1)
		       tr->yTop = (gMouseY-TestList->scroll.mouseoffset)*CHEIGHT;
	      else
	      {
		  ttop=((DWORD)TestList->scroll.value)*(TestList->numlinesonscreen-2-theight);
		  tr->yTop += (WORD) ((ttop/(TestList->scroll.maxvalue))*CHEIGHT);
	      }
	      //ttop = (TestList->scroll.maxvalue+(TestList->numlinesonscreen-2-theight-1))/(TestList->numlinesonscreen-2-theight);
	      //tr->yTop += TestList->scroll.value/ttop;
	  }
	  tr->yBottom = tr->yTop + theight*CHEIGHT;
    }
    tr->xRight= (TestList->scroll.rect.axRight)*CWIDTH-1;
    if(gisgraph)
    {
       tr->xLeft = (TestList->scroll.rect.axLeft)*CWIDTH+1;
    }
    else
       tr->xLeft = tr->xRight-1;

#endif
}

/*  NAME
 *      DrawScrollBar
 *  DESCRIPTION
 *      Draws the scrollbar on the screen in the current graphics mode.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *      Init is TRUE if this is the first time the scroll bar is drawn.
 *      The entire scrollbar is drawn if Init is TRUE, otherwise only the
 *      Thumb area is updated.
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *      Changes graphics pen color/state. All routines are expected to set
 *      this as desired before drawing, so this is ok.
 *  COMMENTS
 *      Draws scrollbar in either graphics mode, or character, depending on
 *      the global flag gisgraphics.
 *  WARNINGS
 *  HACKS
 */

VOID DrawScrollBar(ListBoxData *TestList,BOOL init)
{
    RECT bRect;
    RECT tRect;
    RECT tmpRect;
    RRC  rbRect;
    RRC  rtRect;
    WORD fore,back;

    if (TestList->stupid)
	return;

    FEnableMouseNest(FALSE);
    CalcThumbRect(TestList,&tRect);
    if (gisgraph)
    {
	CalcBarRect(TestList,&bRect);
	if (init)
	{
	  tmpRect.yTop=    bRect.yTop;
	  tmpRect.yBottom= bRect.yBottom;
	  tmpRect.xLeft=  bRect.xLeft;
	  tmpRect.xRight=  bRect.xRight;

	  if(gisgraph)
	  {
	  tmpRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
	  tmpRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;

	  GetIsaColor(isaScrollbar,&fore,&back);
	  MySetColor(back);

	     SetAreaPat(0);
	     SetLinePat(1);
	     Rectangle(&tmpRect);
	  }
	}
	tmpRect.yTop=    bRect.yTop;
	tmpRect.yBottom= tRect.yTop+1;
	tmpRect.xLeft=  bRect.xLeft;
	tmpRect.xRight=  bRect.xRight;

	if(gisgraph)
	{
	  GetIsaColor(isaScrollbar,&fore,&back);
	  MySetColor(back);

	   SetAreaPat(1);
	   SetLinePat(0);
	  tmpRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
	  tmpRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;


	   if (tmpRect.yTop < tmpRect.yBottom)
	   {
	    /* above the thumb */
	     Rectangle(&tmpRect);
	   }
	}
	tmpRect.yTop=    tRect.yTop+1;
	tmpRect.yBottom= tRect.yBottom;
	tmpRect.xLeft=  tRect.xLeft;
	tmpRect.xRight=  tRect.xRight;
	if ((gisgraph) && (tmpRect.yTop < tmpRect.yBottom))
	{
	  tmpRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
	  tmpRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;


	    if(TestList->scroll.dragging)
	    {
	       SetAreaPat(0);
	       SetLinePat(1);
	  GetIsaColor(isaScrollbar,&fore,&back);
	  MySetColor(back);

	       Rectangle(&tmpRect);
	       tmpRect.xLeft+=1;
	       tmpRect.xRight-=1;
	       tmpRect.yTop+=1;
	       tmpRect.yBottom-=1;
	    }
	    SetLinePat(0);
	    SetAreaPat(1);
	   GetIsaColor(isaElevator,&fore,&back);
	   MySetColor(back);

	    /* the thumb */
	    Rectangle(&tmpRect);
	}
	tmpRect.yTop=    tRect.yBottom;
	tmpRect.yBottom= bRect.yBottom+1;
	tmpRect.xLeft=  bRect.xLeft;
	tmpRect.xRight=  bRect.xRight;
	if (gisgraph)
	{
	  tmpRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
	  tmpRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
	  tmpRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;

	   SetAreaPat(1);
	   SetLinePat(0);
	  GetIsaColor(isaScrollbar,&fore,&back);
	  MySetColor(back);

	  if (tmpRect.yTop < tmpRect.yBottom)
	  {
	  /* below the thumb */
	    Rectangle(&tmpRect);
	  }
	}
    }
    else
    {
#ifdef CUA1
	rbRect.ryTop    = (BYTE)TestList->scroll.rect.ayTop+2;
	rbRect.ryBottom = (BYTE)TestList->scroll.rect.ayBottom-2;
	rbRect.rxLeft   = (BYTE)TestList->scroll.rect.axLeft;
	rbRect.rxRight  = (BYTE)TestList->scroll.rect.axRight;
	FillRrc(TestList->pwd,&rbRect,cinch._chScrollbar,isaScrollbar);
	rtRect.ryTop    = (BYTE)tRect.yTop;
	rtRect.ryBottom = (BYTE)tRect.yBottom;
	if (tRect.yBottom - tRect.yTop == 0)
	    ++ rtRect.ryBottom;
	rtRect.rxLeft   = (BYTE)tRect.xLeft-1;
	rtRect.rxRight  = (BYTE)tRect.xRight+1;
	FillRrc(TestList->pwd,&rtRect,cinch._chElevator,isaElevator);

#else
	/* top region of scroll bar */
	rbRect.ryTop    = (BYTE)TestList->scroll.rect.ayTop+1;
	rbRect.rxLeft   = (BYTE)TestList->scroll.rect.axLeft+1;
	rbRect.rxRight  = (BYTE)TestList->scroll.rect.axLeft+2;
	rbRect.ryBottom = (BYTE)tRect.yTop;
	FillRrc(TestList->pwd,&rbRect,cinch._chScrollbar,isaScrollbar);
	/* thumb */
	rtRect.ryTop    = (BYTE)tRect.yTop;
	rtRect.ryBottom = (BYTE)tRect.yBottom;
	if (tRect.yBottom - tRect.yTop == 0)
	    ++ rtRect.ryBottom;
	rtRect.rxLeft   = (BYTE)tRect.xLeft+1;
	rtRect.rxRight  = (BYTE)tRect.xRight+1;
	FillRrc(TestList->pwd,&rtRect,cinch._chElevator,isaElevator);
	/* bottom region of scroll bar */
	rbRect.ryTop = (BYTE)tRect.yBottom;
	rbRect.rxLeft   = (BYTE)TestList->scroll.rect.axLeft+1;
	rbRect.rxRight  = (BYTE)TestList->scroll.rect.axLeft+2;
	rbRect.ryBottom = (BYTE)TestList->scroll.rect.ayBottom-1;
	FillRrc(TestList->pwd,&rbRect,cinch._chScrollbar,isaScrollbar);

#endif
    }
    FEnableMouseNest(TRUE);

}

/*  NAME
 *      DrawScrollBarArrow
 *  DESCRIPTION
 *      Draws the scrollbar arrows and chevrons on the srceen in graphics mode.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *      UporDown is TRUE if we are drawing the Up arrow and chevron
 *      UporDown is FALSE if we are drwing the Down arrow and chevron
 *      enabled is TRUE if black
 *      enabled is FALSE if grey
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *      Changes graphics pen color/state. All routines are expected to set
 *      this as desired before drawing, so this is ok.
 *  COMMENTS
 *      Draws scrollbar arrows in either graphics mode, or character, depending on
 *      the global flag gisgraphics.
 *  WARNINGS
 *  HACKS
 */

VOID DrawScrollBarArrow(ListBoxData *TestList,BOOL UporDown)
{
    WORD x;
    WORD y;

    if (UporDown)
    {
      y = TestList->scroll.rect.ayTop;
    }
    else
    {
      y = TestList->scroll.rect.ayBottom-1;
    }
    x = TestList->scroll.rect.axLeft;
    if (gisgraph)
    {
	 y   += TestList->pwd->arcWindow.ayTop;
	 x   += TestList->pwd->arcWindow.axLeft;

       SetAreaPat(0);
       SetLinePat(1);
       if (UporDown)
       {
	  PlotBmp(UpArrow,x*CWIDTH,y*CHEIGHT,isaBackground);
#ifdef CUA1
	  PlotBmp(UpChevron,x*CWIDTH,(y+1)*CHEIGHT,isaBackground);
	  Move(x*CWIDTH,(y+1)*CHEIGHT);
	  Draw((x+2)*CWIDTH-1,(y+1)*CHEIGHT);
#endif
	  Move(x*CWIDTH,y*CHEIGHT);
	  Draw(x*CWIDTH,(y+2)*CHEIGHT);
       }
       else
       {
	  PlotBmp(DownArrow,x*CWIDTH,y*CHEIGHT,isaBackground);
#ifdef CUA1

	  PlotBmp(DownChevron,x*CWIDTH,(y-1)*CHEIGHT,isaBackground);
	  Move(x*CWIDTH,(y)*CHEIGHT);
	  Draw((x+2)*CWIDTH-1,(y)*CHEIGHT);
#endif
	  Move(x*CWIDTH,(y-1)*CHEIGHT);
	  Draw(x*CWIDTH,(y+1)*CHEIGHT);
	 }
    }
    else
    {
#ifdef UGLYSCROLLBARS
	if(UporDown)
	{
	   TextOut(TestList->pwd,TestList->scroll.rect.axLeft,TestList->rect.ayTop,"",2,isaScrollbar);
	   TextOut(TestList->pwd,TestList->scroll.rect.axLeft,TestList->rect.ayTop+1,"\xf0\xf0",2,isaScrollbar);
	}
	else
	{
	   TextOut(TestList->pwd,TestList->scroll.rect.axLeft,TestList->scroll.rect.ayBottom-1,"",2,isaScrollbar);
	   TextOut(TestList->pwd,TestList->scroll.rect.axLeft,TestList->scroll.rect.ayBottom-2,"\xf0\xf0",2,isaScrollbar);
	}
#else
	if(UporDown)
	{
	   CharOut(TestList->pwd,TestList->scroll.rect.axLeft+1,TestList->rect.ayTop,chUpArrow,isaScrollbar);
	}
	else
	{
	   CharOut(TestList->pwd,TestList->scroll.rect.axLeft+1,TestList->scroll.rect.ayBottom-1,chDownArrow,isaScrollbar);
	}
#endif
    }
}

/*  NAME
 *      UpdateScrollBar
 *  DESCRIPTION
 *      Calls DrawScrollBar to redraw the scroll bar and thumb in the
 *      current state (maxvalue,value).
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *      maxvalue is the maximum number of entries in the list
 *      value is the value the thumb should be set to.
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *      Changes graphics pen color/state. All routines are expected to set
 *      this as desired before drawing, so this is ok.
 *  COMMENTS
